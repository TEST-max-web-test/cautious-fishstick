{"source": "github", "repo": "OWASP/ASVS", "file": ".github/ISSUE_TEMPLATE/standard-asvs-issue.md", "url": "https://github.com/OWASP/ASVS/blob/master/.github/ISSUE_TEMPLATE/standard-asvs-issue.md", "content": "---\nname: Standard ASVS issue\nabout: This template should be used for all ASVS issues.\ntitle: ''\nlabels: ''\nassignees: ''\n\n---\n<!---\nBEFORE YOU OPEN AN ISSUE:\n- If you have a question about content, make sure you are looking at the raw .md files which contain the master version of the text and not in the CSV, JSON, XLSX, PDF, DOCX files which are derived from this.\n- Please search the issues in case your question has been discussed before.\n- Make sure you are looking at the latest edits at: https://github.com/OWASP/ASVS/tree/master/5.0\n- When you reference requirements, please include them as a link, similarly to this:\n[6.1.2](https://github.com/OWASP/ASVS/blob/master/5.0/en/0x14-V6-Cryptography.md#v61-data-classification)\n\nOTHER NOTES:\n- Please do not open a pull request without first opening an associated issue.\n- Please carry out all discussion in the associated issue only.\n-->\n", "timestamp": "2025-10-24T11:39:35.984773"}
{"source": "github", "repo": "OWASP/ASVS", "file": ".github/pull_request_template.md", "url": "https://github.com/OWASP/ASVS/blob/master/.github/pull_request_template.md", "content": "<!---\nIMPORTANT NOTES:\n- Changes should always be made only in the raw .md files and not in the CSV, JSON, XLSX, PDF, DOCX files, etc.\n- Please do not open a pull request without first opening an associated issue.\n- Please carry out all discussion in the associated issue only.\n-->\n\nThis Pull Request relates to issue #...\n", "timestamp": "2025-10-24T11:39:36.106095"}
{"source": "github", "repo": "OWASP/ASVS", "file": ".github/workflows/config/local-custom.txt", "url": "https://github.com/OWASP/ASVS/blob/master/.github/workflows/config/local-custom.txt", "content": "asvs\nASVS\nElar\nGrossman\nManico\nAhnoff\nAndalis\nJacquot\nShanni\nPrutchi\nIman\nSharafaldin\nYardeni\nSjoerd\nLangkemper\nSandro\nGauci\nBoberski\nWichers\nfrontends\nmetacharacters\nscriptable\nJNDI\nTsai\nexfiltration\nHSTS\nnosniff\nCORB\nReferer\ntabnabbing\nsafelisted\nhostnames\nXSSI\nSubresource\nNSAPI\nSilverlight\nNACL\ncodenames\nIDAS\nCSPRNG\nTOTP\nPSTN\nCISA\nPOLP\nIDOR\nBOPLA\nPKCE\nbackchannel\nciba\nFAPI\nCHACHA\nPKCS\nHMAC\nDiffie\nECDH\ncryptosystem\nFIPS\nOCSP\nSaft\nsandboxing\nTOCTOU\nlivelocks\nSIEMs\nSIEM\nMultipoint\nDatagram\nDTLS\nSRTP\nCRNG\nRTCP\nSRTCP\nSDLC\nSAMM\nCryptobom\nTDEA\nFFDH\nurandom\nDRBG\ngetentropy\ncodebook\nHKDF\nsecp\nMODP\nffdhe\nKMAC\nCMAC\nGMAC\nRSSA\nmlkem\nbackdoors\ndocumentbuilder\ncreativecommons\nSeren\nKhalina\nDaria\nShnayder\nSmirnov\nVyacheslav\nMukovkin\nDmitry\nNadezhda\nFomin\nDanil\nSluzhevsky\nZolotarev\nKirill\nNosenko\nAleksei\nCédric\nLallier\nAlexandre\nJoly\nVacarella\nSebastien\nGioria", "timestamp": "2025-10-24T11:39:36.699451"}
{"source": "github", "repo": "OWASP/ASVS", "file": "1.0/asvs-covers-fr-texts.txt", "url": "https://github.com/OWASP/ASVS/blob/master/1.0/asvs-covers-fr-texts.txt", "content": "Top Cover:\n----------\n\nOWASP The Open Web Application Sécurity Project\nOWASP Projet Ouvert de Sécurité d'application Web\n\nOWASP Application Security Verification Standard 2009\nStandard OWASP de vérification de la sécurité d'application 2009\n\n- Web Application Standard\n- Standard d'application Web\n\nrelease\nversion finale\n\n( if needed for versioning :\n\n  alpha\n  version alpha\n\n  beta\n  version beta\n)\n\nCreative Commons (CC) Attribution Share-Alike\nCreative Commons (CC) Attribution Partage à l'identique\n\n\nBottom cover:\n-------------\n\nTHE BELOW ICONS REPRESENT WHAT OTHER VERSIONS ARE AVAILABLE IN PRINT FOR THIS LITTLE BOOK.\nLES ICONES CI-DESSOUS REPRESENTENT LES DIFFERENTES VERSIONS DISPONIBLES POUR CE DOCUMENT.\n\nALPHA: \"Alpha Quality\" book content is a working draft. Content is very rough and in development until the next level of publication.\nALPHA : Une \"version alpha\" du document est une ébauche approximative, son contenu est en cours de développement jusqu'à la prochaine version publié.\n\nBETA: \"Beta Quality\" book content is the next highest level. Content is still in development until the next publishing.\nBETA : Une \"version beta\" du document est un niveau supérieur de qualité, son contenu en cours de développement jusqu'à la prochaine version publié.\n\nRELEASE: \"Release Quality\" book content is the highest level of quality in a books title's lifecycle, and is a final product.\nFINALE : Une \"version finale\" du document est le plus haut niveau de qualité de développement d'un document, c'est un produit fini.\n\nALPHA PUBLISHED\nVERSION ALPHA\n\nBETA PUBLISHED\nVERSION BETA\n\nRELEASE PUBLISHED\nVERSION FINALE\n\nYOU ARE FREE:\nVOUS ETES LIBRE :\n\nto share - to copy, distribute and transmit the work\nde partager - copier, distribuer et transmettre le travail\n\nto remix - to adapt the work\nde modifier - adapter le travail\n\nUNDER THE FOLLOWING CONDITIONS:\nSOUS LES CONDITIONS SUIVANTES :\n\nAttribution. You must attribute the work in the manner specified by the author or licensor (but not in way that they endorse you or your use of the work).\n\nShare Alike. - If you alter, transform, or build upon this work, you may distribute the resulting work only under the same, similar or a compatible license.\n\nOWASP The Open Web Application Security Project\nOWASP Projet de sécurité des applications web\n\nThe Open Web Application Security Project (OWASP) is a worldwide free and open community focused on improving the security of application software. Our mission is to make application security \"visible\", so that people and organizations can make informed decisions about application security risks. Everyone is free to participate in OWASP and all of our materials are available under a free and open software license. The OWASP Foundation is a 501c3 not for profit charitable organization that ensures the ongoing availability and support for our work.\nLe projet de sécurité des applications web (OWASP) est une communauté mondiale libre et ouverte, focalisée sur l'amélioration de la sécurité des applications logicielles. Notre mission est de rendre la sécurité des applications \"visible\", de sorte à ce que les gens et les organisations, puissent prendre des décisions éclairées à propos des risques de sécurité liés aux applications. Chacun est libre de participer au projet OWASP, et tous nos produits sont disponibles sous une licence logicielle libre et ouverte. La fondation OWASP organisation à but non lucratif qui assure la disponibilité continue de notre travail.\n\n\nOn the cover: Braconid wasps, beetles, and aphids. After a female injects an egg into a host, the larva feeds slowly on that single host. By the time the host dies, the larva is fully grown. It pupates inside or near the dead host, sometimes in a sikken cocoon, to emerge later as an adult wasp. \nSur la couverture : guêpes parasites, scarabées, et pucerons. Après que la femelle injecte un oeuf dans un hôte, la larve s'alimente doucement depuis cet hôte. Avec le temps l'hôte meurt, la larve elle, est devenue grande. Elle se transforme alors en chrysalide dans ou à coté de son hôte, parfois dans un cocon, pour sortir plus tard en guêpe adulte.\n\n", "timestamp": "2025-10-24T11:39:37.674684"}
{"source": "github", "repo": "OWASP/ASVS", "file": "1.0/asvs-xml/readme.txt", "url": "https://github.com/OWASP/ASVS/blob/master/1.0/asvs-xml/readme.txt", "content": "From: Pekka Sillanp‰‰ [mailto:pekka.sillanpaa@nixu.com] \nSent: Tuesday, December 01, 2009 11:05 AM\nTo: Boberski, Michael [USA]\nSubject: Re: Owasp ASVS two versions\n\n\nHello,\n\n\nWhoops, this took quite a while :) Yes, you may add Nixu to the list of ASVS users.\n\n\nFinally had some time to play with xslt:s to make the conversion. I might still improve the namespace a bit, but this basically does what we need. Do you have any additional ideas? Now it's just quick and dirty solution to fit into our needs.\n\n\nI attached few files. If you open the asvs.xml in a browser, you should see how it works. (at least FF does the xslt-conversion). Within the asvs.xsl file you can choose which levels should be included in the \"checklist\", so only the checks relevant to the specified level(s) are listed. (level_to and level_from params)\n\n\nTo create asvs.xml from the ASVS document:\n\n\n1. Convert ASVSxxx.doc to ASVSxxx.odt in OpenOffice\n2. Unzip content.xml from ASVSxxx.odt\n3. xsltproc odt2asvs.xsl content.xml > asvs.xml\n\n\nRegards,\nPekka\n", "timestamp": "2025-10-24T11:39:38.546886"}
{"source": "github", "repo": "OWASP/ASVS", "file": "3.0/spreadsheets/README.md", "url": "https://github.com/OWASP/ASVS/blob/master/3.0/spreadsheets/README.md", "content": "Spreadsheet version of ASVS\n\nWe used these in AppSec EU to review each and every control, but these are now out of date. \n\nIf you want to see the Google Spreadsheets of each of our review, please visit:\n\nhttps://drive.google.com/folderview?id=0B4xgbqJzimL4fm11WTdIc2JBUkozTkdsbmZhQk5LTDR4TFgyYlBfQkhQbnZjVlZqQWVaSzA&usp=sharing\n\nIf you want edit access, please send mail to vanderaj@owasp.org\n\n", "timestamp": "2025-10-24T11:39:40.445764"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/TRANSLATIONS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/TRANSLATIONS.md", "content": "# v4.x - Translations\n\nThe following translations of versions v4.0.1-v4.0.3 were prepared:\n\n* v4.0.3\n    * [OWASP Application Security Verification Standard 4.0.3 Spanish (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-es.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_es). (Thanks to [Carlos Allendes](https://github.com/CarlosAllendes) and [Hans Herrera](https://github.com/hansphp))\n    * [OWASP Application Security Verification Standard 4.0.3 Simplified Chinese (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-zh-cn.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_zh-cn).  (Thanks to [Unc1e](https://github.com/hi-unc1e))\n    * [OWASP Application Security Verification Standard 4.0.3 Arabic (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-ar.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_ar).  (Thanks to [Aref Shaheed](https://github.com/aref2008) and Mhd Ghassan Alhabash)\n    * [OWASP Application Security Verification Standard 4.0.3 Russian (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-ru.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_ru). (Thanks to [Andrei Titov](https://github.com/andrettv))\n    * [OWASP Application Security Verification Standard 4.0.3 French (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-fr.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_fr). (Thanks to [Cédric Lallier](https://github.com/clallier94), [Alexandre Joly](https://github.com/inaz0), [Sebastien Gioria](https://github.com/SPoint42), and [Marc Aubry](https://github.com/Marx314))\n    * [OWASP Application Security Verification Standard 4.0.3 German (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-de.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_de). (Thanks to [Jörg Brünner](https://github.com/JoergBruenner))\n    * [OWASP Application Security Verification Standard 4.0.3 Portuguese (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-pt.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_pt). (Thanks to [Cesar Kohl](https://github.com/cesarkohl))\n    * [OWASP Application Security Verification Standard 4.0.3 Italian (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.3-it.pdf) and [other formats](https://github.com/OWASP/ASVS/raw/master/4.0/docs_it). (Thanks to [Riccardo Sirigu](https://github.com/ricsirigu))\n* v4.0.2\n    * [OWASP Application Security Verification Standard 4.0.2 German (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.2-de.pdf) and [Microsoft Word format](https://github.com/OWASP/ASVS/raw/master/4.0/docs_de/OWASP%20Application%20Security%20Verification%20Standard%204.0.2-de.docx). (Thanks to [Jörg Brünner](https://github.com/JoergBruenner)) \n    * [OWASP Application Security Verification Standard 4.0.2 Russian (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.2-ru.pdf) and [Microsoft Word format](https://github.com/OWASP/ASVS/raw/master/4.0/docs_ru/OWASP%20Application%20Security%20Verification%20Standard%204.0.2-ru.docx). (Thanks to [Sergey Diakonov](https://github.com/sergeydiak1980))\n* v4.0.1\n    * [OWASP Application Security Verification Standard 4.0.1 Persian (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.1-fa.pdf) (Thanks to CERT of Ferdowsi University of Mashhad / [Ardalan Foroughipour](https://github.com/ardalanForoughipour))\n    * [OWASP Application Security Verification Standard 4.0.1 Japanese (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.1-ja.pdf) (Thanks to Software ISAC Japan / [Riotaro OKADA](https://github.com/okdt))\n    * [OWASP Application Security Verification Standard 4.0.1 Turkish (PDF)](https://github.com/OWASP/ASVS/raw/master/4.0/OWASP%20Application%20Security%20Verification%20Standard%204.0.1-tr.pdf) (Thanks to [Fatih ERSINADIM](https://github.com/fatihersinadim))", "timestamp": "2025-10-24T11:39:41.110223"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x01-Frontispiece.md", "content": "# البداية\n\n## عن المعيار\n\nمعيار التحقق من أمان التطبيقات هو قائمة لمتطلبات أو اختبارات أمان التطبيقات التي يمكن استخدامها من قبل مهندسي معمارية التطبيقات Architecture ، والمطورين ، والمختبرين ومحترفي أمن المعلومات وبائعي الأدوات والمستهلكين لتحديد وبناء واختبار والتحقق من التطبيقات الآمنة.\n\n## حقوق الطبع والرخصة\n\nالنسخة 4.0.3 ، أكتوبر 2021\n\n![license](../images/license.png)\n\nحقوق الطبع محفوظة لمنظمة OWASP 2008 – 2021. تم نشر هذا المستند تحت  [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/). يجب أن يتم توضيح شروط ترخيص هذا العمل للآخرين عند أي إعادة استخدام أو توزيع.\n\n## قادة المشروع\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## المساهمون الرئيسيون\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## المساهمون والمراجعون الآخرون\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\nإذا كان هناك نقص في القائمة أعلاه، يرجى تسجيل تذكرة في GitHub ليتم أخذها بعين الاعتبار في التحديثات المستقبلية للإصدار 4.x. \n\nتم بناء معيار التحقق من أمان التطبيقات بتضافر جهود المشاركين في ASVS 1.0 عام 2008  لغاية عام 2016 وصولاً للإصدار 3.0 من هذا المعيار. لقد وضع كل من Mike Boberski وJeff Willams وDave Wichers الجزء الأكبر من البنية ومعظم مواد التحقق في ASVS. هناك أيضاً العديد من المساهمين. شكراً لجميع الذين ساهموا سابقاً. للحصول على قائمة شاملة لجميع المساهمين في الإصدارات السابقة، يرجى الرجوع لكل إصدار سابق.\n", "timestamp": "2025-10-24T11:39:41.573763"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x02-Preface.md", "content": "# تمهيد\n\nأهلاً بك في الإصدار 4.0 من معيار التحققق من أمان التطبيقات ASVS. إن ASVS هو تضافر جهود مجتمعية لإنشاء إطار عمل لمتطلبات وضوابط الأمان التي تركز على تحديد ضوابط الأمان الوظيفية وغير الوظيفية المطلوبة عند تصميم وتطوير واختبار تطبيقات وخدمات الويب الحديثة.\n\nالإصدار 4.0.3 هو التصحيح الثانوي الثالث للإصدار 4.0 وفيه تم تصحيح الأخطاء الإملائية وجعل المتطلبات أكثر وضوحاً بدون إجراء تغييرات حادة كتغييرات جوهرية في المتطلبات أو إضافة المتطلبات أو حتى تقويتها. ومع ذلك، قد تكون بعض المتطلبات قد ضعفت قليلاً ورأينا أنها مناسبة فتم إبقاؤها، كما تم إزالة بعض المتطلبات الزائدة والمتكررة بشكل كامل (لم يؤثر ذلك على الترقيم فهو لم يتغير).\n\nإن ASVS الإصدار 4.0 هو تتويج لجهود مجتمعية والتعليقات الراجعة من قطاع الصناعة خلال العقد الماضي. لقد حاولنا تقديم استخدام أسهل للمعيار مع مجموعة متنوعة لحالات الاستخدام المختلفة طوال أي دورة تطوير برمجيات آمنة.\n\nنتوقع ألا يكون هناك إجماع بنسبة 100% على محتوى أي معيار لتطبيقات الويب، بما في ذلك ASVS. إن تحليل المخاطر هو دائماً قائم على الحكم الشخصي (ليس موضوعي) مما يجعل هناك تحدي في توحيد أو تعميم هذا المعيار وجعله يناسب الجميع. ومع ذلك، نأمل أن تكون التحديثات الأخيرة التي تم وضعها في هذا الإصدار خطوة في الاتجاه الصحيح، وأن تعزز المفاهيم التي تم تقديمها في هذا المعيار الصناعي المهم.\n\n## ما الجديد في الإصدار 4.0\n\nالتغيير الأكثر أهمية في هذا الإصدار هو اعتماد إرشادات الهوية الرقمية NIST 800-63-3، وتقديم ضوابط مصادقة حديثة ومتطورة وقائمة على الأدلة. على الرغم من أننا نتوقع أن يتم التراجع عن بعض معايير المصادقة المتقدمة، إلا أننا نرى أنه من الضروري أن يأخذها المعيار بعين الاعتبار، خاصة عندما يكون معيار أمان التطبيقات له اعتباره وقائم على الشواهد.\n\nيجب على معايير أمان التطبيقات أن تحاول تخفيض عدد المتطلبات الفريدة، فلا تضطر المنظمات الممتثلة لاتخاذ قرار بخصوص الضوابط المنافسة أو غير المتوافقة. تتوافق OWASP - TOP 10 2017 و معيار التحقق من أمان التطبيقات الآن مع المعيار NIST 800-63 في المصادقة وإدارة الجلسة. إننا نشجع المعايير الأخرى NIST والآخرين على العمل معنا للوصول لمجموعة مقبولة من ضوابط أمان التطبيقات لتحقيق أقصى درجة أمان وتخفيض تكلفة الامتثال قدر الإمكان.\n\nتمت إعادة ترقيم ASVS 4.0 بالكامل من البداية إلى النهاية. سمح لنا نظام الترقيم الجديد بتقليص الفجوات الناتجة عن الفصول التي اختفت منذ فترة طويلة ، كما سمح لنا بتقسيم الفصول الأطول لتقليل عدد الضوابط التي يتعين على المطور أو الفريق الامتثال لها. على سبيل المثال ، إذا كان التطبيق لا يستخدم JWT ، فلن يكون القسم الخاص بـ JWT في إدارة الجلسة قابلاً للتطبيق.\n\nالجديد في الإصدار 4.0 هو الربط الشامل مع تعداد نقاط الضعف المشهورة Common Weakness Enumeration (CWE)، وهو أحد أكثر الميزات المرغوبة طلباً وشيوعاً والتي تلقيناها بكثرة على مدار العقد الماضي. يسمح تعيين CWE لبائعي الأدوات وأولئك الذين يستخدمون برامج إدارة الثغرات بمطابقة النتائج من الأدوات الأخرى وإصدارات ASVS السابقة إلى 4.0 وما بعده. لإفساح المجال لإدخال CWE ، كان علينا إزالة  الحقل \"since\" ، وقمنا بإعادة ترقيمه بالكامل ، فقد أصبح أقل أهمية مما كان عليه في الإصدارات السابقة من ASVS. لا يحتوي كل عنصر في ASVS على CWE مرتبط به ، ولأن CWE به قدر كبير من التكرار، فقد حاولنا استخدام الأكثر استخدامًا وليس بالضرورة الأقرب تطابقًا. لا يمكن دائمًا تعيين ضوابط التحقق لنقاط الضعف المقابلة لها. نرحب بالمناقشة المستمرة مع مجتمع CWE ومجال أمن المعلومات بشكل عام حول سد هذه الفجوة.\n\nلقد عملنا على تلبية المتطلبات بشكل شامل لمعالجة OWASP – العشر الأوائل 2017 (OWASP - TOP 10 2017) والضوابط الاستباقية لـ OWASP 2018 (OWASP Proactive Controls 2018). نظرًا لأن OWASP - TOP 10 2017 هو الحد الأدنى لتجنب التقصير، فقد تقصدنا وضع العشرة الأوائل كمتطلبات لضوابط المستوى الأول، مما يسهل على الممتثلين لـ OWASP - TOP 10 الارتقاء إلى معيار الأمان الفعلي.\n\nلقد أكدنا على أن المستوى الأول من ASVS 4.0 هو مجموعة شاملة ووافية من المعيار PCI DSS 3.2.1 (الأقسام 6.5) ، لتصميم التطبيقات ، وكتابة الشيفرة المصدرية، والاختبار ، ومراجعات الشيفرة المصدرية الآمنة ، واختبارات الاختراق. استلزم ذلك تغطية لكل من buffer overflow و unsafe memory operationsفي الفصل 5، و unsafe memory-related compilation flags في الفصل 14، بالإضافة إلى متطلبات التحقق من التطبيقات وخدمة الويب الرائدة في الصناعة.\n\nلقد أكملنا الانتقال بالمعيار ASVS من ضوابط monolithic server-side فقط ، إلى توفير ضوابط أمان لجميع التطبيقات الحديثة وواجهات برمجة التطبيقات APIs. في هذه الأيام ومع وجود البرمجة الوظيفية ، وServer-less API، والهاتف المحمول ، و cloud ، و containers، و CI / CD و DevSecOps، و federation والكثير، لا يمكننا الاستمرار في تجاهل بنية التطبيقات الحديثة. تم تصميم التطبيقات الحديثة بشكل مختلف تمامًا عن تلك التي تم إنشاؤها عند إصدار ASVS الأصلي في عام 2009. يجب أن ينظر ASVS دائمًا بعيدًا في المستقبل حتى نوفر المشورة السليمة لجمهورنا الأساسي - المطورين - ولقد أوضحنا أو أسقطنا أي شرط يفترض أن التطبيقات يتم تنفيذها على أنظمة تابعة لمؤسسة واحدة.\n\nنظرًا لحجم ASVS 4.0 ، وفضلاً عن رغبتنا في أن نصبح معيار التحقق من أمان التطبيقات الأساسي لجميع معايير التحقق من أمان التطبيقات الأخرى، فقد عزلنا الفصل الخاص بالهاتف المحمول، وقدمنا معيار منفصل للتحقق من أمان تطبيقات الهاتف المحمول Mobile Application Security Verification Standard (MASVS). سيظهر ملحق إنترنت الأشياء ضمن اهتمامات IoT  ASVS المستقبلية وذلك في مشروع OWASP لانترنت الأشياء OWASP Internet of Things. لقد قمنا بتضمين معاينة مبكرة لـ IoT ASVS (معيار التحقق من أمان تطبيقات انترنت الأشياء) في الملحق ج. نشكر فريق OWASP Mobile وفريق مشروع OWASP IoT على دعمهم لـ ASVS ، ونتطلع إلى العمل معهم في المستقبل لتوفير معايير مكملة.\n\nأخيرًا ، قمنا بإزالة الضوابط الأقل تأثيرًا. مع الوقت، بدأت ASVS في بالتحول لمجموعة شاملة من الضوابط ، ولكن ليست كل الضوابط متساوية عند صناعة برامج آمنة. هذا الجهد لإزالة الضوابط منخفضة التأثير يمكن أن يذهب أبعد من ذلك. في إصدار مستقبلي من ASVS ، سيساعد نظام تسجيل نقاط الضعف المشترك Common Weakness Scoring System (CWSS) على إعطاء الأولوية لمزيد من الضوابط التي تعتبر مهمة حقًا وتلك التي يجب إيقافها.\n\nاعتبارًا من الإصدار 4.0 ، ستركز ASVS فقط على كونها معايير تطبيقات وخدمات الويب الرائدة، والتي تغطي بنية التطبيقات التقليدية والحديثة ، وممارسات الأمان للمنهجية الرشيقة agile وثقافة DevSecOps.\n", "timestamp": "2025-10-24T11:39:41.634629"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x03-Using-ASVS.md", "content": "# استخدام ASVS\n\nلـ ASVS هدفين رئيسيين:\n\n* مساعدة المنظمات على تطوير وصيانة تطبيقات آمنة.\n* إتاحة التوافق بين المتطلبات لبائعي خدمات أمن المعلومات، وبائعي أدوات أمن المعلومات، والمستهلكين للتوافق مع متطلباتهم وعروضهم.\n\n## مستويات التحقق من أمان التطبيقات\n\nيحدد معيار التحقق من أمان التطبيقات ثلاثة مستويات للتحقق من الأمان، تزداد المتطلبات مع الانتقال بين المستويات للأعلى.\n\n* المستوى 1 من المعيار هو لمستويات أمان منخفضة، وهو قابل لاختبارات الاختراق بشكل كامل.\n* المستوى 2 من المعيار هو للتطبيقات التي تتضمن بيانات حساسة والتي تتطلب حماية وهو المستوى المقترح لمعظم التطبيقات.\n* المستوى 3 من المعيار وهو للتطبيقات الأكثر أهمية – التطبيقات التي تقوم بتنفيذ أعمال عالية القيمة ، أو تتضمن بيانات طبية حساسة، أو أي تطبيق يتطلب أعلى مستوى من الثقة.\n\nيتضمن كل مستوى من مستويات ASVS قائمة من متطلبات الأمان. يمكن أيضاً تعيين كل متطلب من هذه المتطلبات إلى إمكانيات وميزات أمان خاصة والتي يجب على المطورين أن يقوموا ببنائها في البرنامج.\n\n![ASVS Levels](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"ASVS Levels\")\n\nالشكل 1 - مستويات معيار OWASP للتحقق من أمان التطبيقات 4.0\n\nالمستوى 1 هو المستوى الوحيد القابل لاختبارات الاختراق بشكل كامل عن طريق العامل البشري. تتطلب بقية المستويات الوصول إلى الوثائق والشيفرة المصدرية والتكوين configuration والأشخاص المشاركين في عملية التطوير. ومع ذلك ، حتى لو سمحت L1 بإجراء اختبار \"الصندوق الأسود\" (بدون توثيق ولا شيفرة مصدرية) ، فهو إجراء غير فعال ولا يجب التشجيع على ممارسته. فالمهاجمين يمتلكون متسعاً من الوقت، أما اختبارات الاختراق تنتهي معظمها في غضون أسبوعين. يحتاج المسؤولين عن الحماية إلى بناء ضوابط أمنية، والحماية من نقاط الضعف والعثور عليها وحلها ، واكتشاف الجهات الفاعلة الضارة والرد عليها في وقت مناسب. بشكل أساسي لدى الجهات الفاعلة الضارة وقتًا غير محدود ولا تحتاج إلا لنقطة ضعف واحدة أو غياب ميزة كشف لنجاح أعمالها الضارة. إن اختبار الصندوق الأسود الذي يتم إجراؤه في نهاية التطوير بشكل سريع - أو لا يتم إجراؤه على الإطلاق - غير قادر بشكل تام على مواجهة ذلك.\n\nعلى مدار الثلاثين عامًا الماضية ، أثبت اختبار الصندوق الأسود مرارًا وتكرارًا أنه لا يغطي مشكلات الأمان الحرجة التي تؤدي مباشرة إلى المزيد من الانتهاكات الهائلة. نحن نشجع بشدة على استخدام مجموعة واسعة من ضمانات الأمان والتحقق ، بما في ذلك استبدال اختبارات الاختراق باختبارات اختراق (هجينة) موجهة بالشيفرة المصدرية penetration tests with source code led في المستوى 1 ، مع إمكانية الوصول الكامل إلى المطورين والوثائق طوال عملية التطوير. لا يتسامح المنظمون الماليون مع عمليات التدقيق المالي الخارجية دون الوصول إلى الدفاتر ، أو المعاملات النموذجية ، أو الأشخاص الذين يقومون بالرقابة. يجب أن تطالب الصناعة والحكومات بنفس معيار الشفافية في مجال هندسة البرمجيات.\n\nنحن نشجع بشدة على استخدام أدوات الأمان في عملية التطوير نفسها. يمكن استخدام أدوات DAST و SAST بشكل مستمر للعثور بسهولة على مشكلات الأمان التي يجب ألا تكون موجودة أبدًا.\n\nإن الأدوات المؤتمتة automated tools وعمليات الفحص عبر الإنترنت online scan غير قادرة على إكمال أكثر من نصف ASVS دون تدخل العامل البشري. إذا كانت هناك حاجة إلى أتمتة اختبار شامل لكل build ، فسيتم استخدام مجموعة من اختبارات الوحدة والتكاملunit and integration tests جنبًا إلى جنب مع عمليات الفحص عبر الإنترنت. أما عيوب منطق الأعمال Business logic flaws واختبار التحكم في الوصول access control testing  فهي ممكنة فقط عن طريق العامل البشري. ولذلك يجب تحويلها إلى unit and integration tests.\n\n## كيفية استخدام هذا المعيار\n\nواحدة من أفضل الطرق لاستخدام معيار التحقق من أمان التطبيقات هي استخدامه كمخطط عمل لإنشاء قائمة تحقق checklist لكتابة شيفرة مصدرية آمنة، هذه القائمة هي خاصة بتطبيقك أو منصتك أو مؤسستك. سيؤدي استخدام ASVS مع الـuse cases  الخاصة بك إلى زيادة التركيز على متطلبات الأمان الأكثر أهمية لمشاريعك وبيئاتك.\n\n### المستوى 1: الخطوات الأولى، مؤتمت، أو استعراض المحفظة بشكل كامل\n\nيحقق التطبيق المستوى 1 من ASVS إذا كان يحمي بشكل كاف من الثغرات الأمنية للتطبيقات التي يسهل اكتشافها، وتم تضمينها في OWASP – العشر الأوائل وقوائم التحقق الأخرى المماثلة.\n\nالمستوى 1 هو الحد الأدنى الذي يجب أن تسعى جميع التطبيقات لتحقيقه. كما أنه مفيد كخطوة أولى في جهد متعدد المراحل أو عندما لا تخزن التطبيقات البيانات الحساسة أو تتعامل معها ، وبالتالي لا تحتاج إلى ضوابط أكثر صرامة كالضوابط في المستوى 2 أو 3. يمكن التحقق من ضوابط المستوى 1 إما آلياً بواسطة الأدوات المؤتمتة أو ببساطة يدويًا دون الوصول إلى الشيفرة المصدرية. نحن نعتبر المستوى 1 هو الحد الأدنى المطلوب لجميع التطبيقات.\n\nمن المرجح أن تكون التهديدات التي يتعرض لها التطبيق من المهاجمين الذين يستخدمون تقنيات بسيطة ومنخفضة الجهد لتحديد نقاط الضعف التي يسهل العثور عليها واستغلالها. هذا على عكس المهاجم الذي سيبذل جهود كبيرة ومركزة لاستهداف التطبيق على وجه التحديد. إذا كانت البيانات التي تتم معالجتها بواسطة التطبيق الخاص بك ذات قيمة عالية ، فنادراً ما ترغب في التوقف عند مراجعة المستوى 1.\n\n### المستوى2:  معظم التطبيقات\n\nيحقق التطبيق المستوى 2 (أو القياسي) من ASVS إذا كان يحمي بشكل كاف من معظم المخاطر المرتبطة بالبرنامج اليوم.\n\nيضمن المستوى 2 أن ضوابط الأمان مطبقة وفعالة ومستخدمة داخل التطبيق. عادةً ما يكون المستوى 2 مناسبًا للتطبيقات التي تتعامل مع المعاملات  transactions الهامة بين الشركات ، بما في ذلك تلك التي تعالج معلومات الرعاية الصحية ، أو تنفذ وظائف مهمة أو حساسة للأعمال ، أو تعالج الأصول الحساسة الأخرى ، أو الصناعات التي تكون فيها السلامةintegrity  جانبًا مهمًا لحماية أعمالها ، مثل صناعة الألعاب لمكافحة الغش في الألعاب واختراقها.\n\nعادةً ما تكون التهديدات التي تواجه تطبيقات المستوى 2 عبارة عن مهاجمين ماهرين ومتحمسين يركزون على أهداف محددة باستخدام أدوات وتقنيات يتم استخدامها بشكل كبير وفعال في اكتشاف واستغلال نقاط الضعف داخل التطبيقات.\n\n### المستوى 3: قيمة عالية ، أو ضمان عالي ، أو سلامة عالية\n\nالمستوى 3 من ASVS هو أعلى مستوى للتحقق داخل ASVS. عادةً ما يكون هذا المستوى مخصص للتطبيقات التي تتطلب مستويات كبيرة من التحقق الأمني ، كالتطبيقات في المجالات العسكرية والصحة والسلامة والبنية التحتية الحيوية وما إلى ذلك.\n\nقد تطلب المنظمات ASVS المستوى 3 للتطبيقات التي تؤدي وظائف مهمة ، حيث يمكن لفشل التطبيق أن يؤثر بشكل كبير على عمليات المنظمة ، وحتى على بقائها. ويرد أدناه مثال على إرشادات حول تطبيق ASVS المستوى 3. يحقق التطبيق المستوى 3 من ASVS (أو المستوى المتقدم) إذا كان يحمي بشكل كاف من الثغرات الأمنية المتقدمة للتطبيقات ويوضح أيضًا مبادئ التصميم الآمن الجيد.\n\nيتطلب التطبيق في المستوى 3 من ASVS تحليلًا معمقًا للبنية وكتابة الشيفرة المصدرية والاختبار أكثر من جميع المستويات الأخرى. يتم نمذجة modularized التطبيق الآمن بطريقة هادفة (لتسهيل المرونة وقابلية التوسع والأهم من ذلك كله ، طبقات الأمان) ، وكل وحدة module (مفصولة عن طريق اتصال الشبكة و / أو كيان فيزيائي) تهتم بمسؤولياتها الأمنية الخاصة (الدفاع في العمق defense in depth) ، التي تحتاج إلى توثيقها بشكل صحيح. تشمل المسؤوليات ضوابط لضمان السرية confidentiality  (مثل التشفير) ، والسلامة integrity (مثل المعاملات transactions ، والتحقق من صحة المدخلات input validation) ، والتوافر availability (مثل التعامل مع الحمل بأمان handling load gracefully) ، والمصادقة authentication  (بما في ذلك بين الأنظمة) ، والتفويض authorization ، والتدقيق auditing (التسجيل logging).\n\n## تطبيق المعيار بشكل عملي\n\nالتهديدات المختلفة لها دوافع مختلفة. بعض الصناعات لديها معلومات فريدة وأصول تقنية ومتطلبات الامتثال لقوانين خاصة بنطاق عملها.\n\nيتم تشجيع المؤسسات بشدة على النظر بعمق في خصائص المخاطر الفريدة الخاصة بها بناءً على طبيعة أعمالها ، وبناءً على تلك المخاطر ومتطلبات العمل لتحديد مستوى ASVS المناسب.\n\n## كيفية الرجوع إلى متطلبات  ASVS\n\nيوجد معرف لكل متطلب بالصيغة \"<الفصل>.<القسم>.<المتطلب>\" حيث كل حقل في هذا المعرف هو رقم ، على سبيل المثال \"3.11.1\".\n- الحقل \"<الفصل>\" يشير للفصل الذي يتتمي له المتطلب، على سبيل المثال: كل متطلبات \"#.#.1\" تابعة لفصل المعمارية.\n- الحقل \"<القسم>\" يشير للقسم الذي يتم فيه عرض المتطلب، على سبيل المثال: كل متطلبات \"#.11.1\" هي قسم معمارية منطق الأعمال في فصل المعمارية.\n- الحقل \"<المتطلب>\" يشير لمتطلب محدد في الفصل والقسم، على سبيل المثال: \"3.11.1\" هو المتطلب من الإصدار 4.0.3 في هذا المعيار والذي ينص على:\n\n> \"تحقق من أن جميع تدفقات منطق الأعمال عالية القيمة ، بما في ذلك المصادقة وإدارة الجلسة والتحكم في الوصول آمنة عند استخدام الـthread  ومقاومة لـ time-of-check and time-of-use race conditions\".\n\nقد تتغير المعرفات بين الإصدارات المختلفة من المعيار لذلك يفضل في التقارير والمستندات الأخرى أو الأدوات أن يتم استخدام الصيغة التالية: \n\"ن<رقم الإصدار>-<الفصل>.<القسم>.<المتطلب>\" ، حيث \"<رقم الإصدار>\" هو وسم لإصدار ASVS. على سبيل المثال: \"ن 4.0.3-1-11-3\" هي إشارة واضحة للمتطلب الثالث في معمارية منطق الأعمال في فصل المعمارية من الإصدار 4.0.3. (يمكن اختصار ذلك للصيغة \"ن<رقم الإصدار>-<معرف المتطلب>\"(. ملاحظات: حرف النون الذي يسبق المعرف هو اختصار كلمة نسخة (المقابل في المعيار الإنجليزي هو حرف v وهو اختصار لكلمة version) وتم الترقيم من اليمين إلى اليسار فالمتطلب الخامس الموجود في القسم الرابع من الفصل الأول هو في النسخة العربية 5.4.1 وفي النسخة الإنكليزية 1.4.5 ، لم يتم تغيير الترتيب وإنما اتجاه الترقيم فقط\n\nملاحظة: يجب أن تكون الحرف`v` الذي يسبق جزء الإصدار صغير lower case.\n\nإذا لم يتم استخدام حرف النون أو حرف v فهذا يعني أن المعرف يشير للمتطلب الموجود في محتوى آخر إصدار في ASVS. كما يتضح للقارئ أن المعيار ينمو ويتغير وهذا يشكل معضلة، لذلك يجب وضع رقم إصدار ASVS في معرف المتطلب.\n\nإن قائمة متطلبات ASVS متاحة بصيغ مختلفة لدعم الاستخدامات البرمجية كـ CSV و JSON وغيرها من الصيغ المفيدة.\n", "timestamp": "2025-10-24T11:39:41.713390"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x04-Assessment_and_Certification.md", "content": "# التقييم والشهادة\n\n## موقف OWASP من شهادات ASVS وعلامات الثقة\n\nإن OWASP بصفتها منظمة غير ربحية محايدة للبائع، لا تصادق حاليًا على أي بائعين أو محققين أو برامج.\n\nجميع تأكيدات الثقة assurance assertions أو علامات الثقة trust marks أو الشهادات لم يتم فحصها رسميًا أو تسجيلها أو اعتمادها من قبل OWASP، لذلك يجب على المنظمة التي تعتمد على هذه الرؤية أن تكون حذرة بشأن الثقة الموضوعة في أي طرف ثالث أو علامة ثقة تطالب بشهادة ASVS.\n\nينبغي لهذا الأمر ألا يمنع المنظمات من تقديم خدمات ضمان مشابهة، طالما أنها لا تطالب بشهادة رسمية من OWASP.\n\n## دليل إعطاء شهادة أمان للمنظمات\n\nيمكن استخدام معيار التحقق من أمان التطبيقات ككتاب مفتوح للتحقق من التطبيق، بما في ذلك الوصول المفتوح وغير المقيد إلى الموارد الرئيسية متضمنة مهندسي معمارية التطبيقات والمطورين، ووثائق المشروع، والشيفرة المصدرية، والوصول المصادق لاختبار الأنظمة (بما في ذلك الوصول إلى حساب واحد أو أكثر في كل صلاحية role) ، خاصة بالنسبة لعمليات التحقق من المستوى 2 و 3.\n\nتاريخياً، شملت اختبارات الاختراق ومراجعات شيفرة المصدرية الآمنة قضايا \"بالاستثناء exception\" - أي أن الاختبارات الفاشلة فقط تظهر في التقرير النهائي. يجب على المنظمة المعتمدة أن تدرج في أي تقرير نطاق التحقق (خاصة إذا كان أحد العناصر الأساسية خارج النطاق، مثل مصادقة الدخول الواحد SSO)، وملخص لنتائج التحقق، بما في ذلك الاختبارات الناجحة والفاشلة، مع مؤشرات واضحة حول كيفية حل الاختبارات الفاشلة.\n\nقد لا تنطبق بعض متطلبات التحقق على التطبيق قيد الاختبار. على سبيل المثال، إذا قمت بتنفيذ stateless service layer API دون تنفيذclient implementation  لعملائك، فإن العديد من المتطلبات في الفصل الثالث (إدارة الجلسة) لا تنطبق بشكل مباشر. في حالات كهذه قد تستمر المنظمة المعتمدة في المطالبة بالامتثال الكامل لـ ASVS، ولكن يجب أن تشير بوضوح في أي تقرير إلى سبب عدم قابلية تطبيق متطلبات التحقق المستبعدة هذه.\n\nيعتبر حفظ أوراق العمل التفصيلية، ولقطات الشاشة أو الأفلام والبرامج النصية Scripts للاختبار لاستغلال مشكلة ما بشكل موثوق ومتكرر، والسجلات الإلكترونية للاختبار مثل اعتراض السجلات البرمجيات الوسيطة (intercepting Proxy logs) والملاحظات المرتبطة بها مثل cleanup list، كل هذا يعتبر ممارسات معيارية ويمكن أن تكون مفيدة حقا كدليل للنتائج للمطورين الذين يشعرون بالإرتياب. إن تشغيل الأدوات وتقديم تقرير عن حالات الفشل فقط لا يكفي، فهذا لا يوفر دليل كافيا على أن جميع المشاكل على مستوى التصديق certifying قد تم اختبارها بدقة. في حالة حدوث مناقشات، ينبغي أن تكون هناك أدلة كافية لضمان أن كل متطلب تم التحقق منه وأنه بالفعل تم اختباره.\n\n### طريقة الاختبار\n\nتتمتع المنظمات المعتمدة بحرية اختيار طرق الاختبار المناسبة، ولكن يجب الإشارة إليها في التقرير.\n\nاعتمادًا على التطبيق قيد الاختبار ومتطلبات التحقق، يمكن استخدام طرق اختبار مختلفة ليكون هناك ثقة مماثلة في النتائج. على سبيل المثال، قد يتم تحليل التحقق من فعالية آليات التحقق من المدخلات input verification mechanisms من خلال اختبار اختراق يدوي أو عن طريق تحليل الشيفرة المصدرية.\n\n#### دور أدوات اختبار الأمان المؤتمتة\n\nيتم التشجيع على استخدام أدوات اختبار الاختراق المؤتمتة لتوفير أكبر قدر ممكن من التغطية.\n\nلا يمكن إتمام التحقق من ASVS بالكامل باستخدام أدوات اختبار الاختراق المؤتمتة وحدها. ولكن يمكن تنفيذ الغالبية العظمى من المتطلبات في L1 باستخدام الاختبارات المؤتمتة، إن الغالبية الإجمالية من المتطلبات ليست قابلة لاختبار الاختراق المؤتمت.\n\nيرجى ملاحظة أن الخطوط الفاصلة بين الاختبار المؤتمت واليدوي قد أصبحت مموهة مع تقدم ونضوج صناعة أمان التطبيقات. غالبًا ما يتم ضبط الأدوات المؤتمتة يدويًا بواسطة خبراء، وغالبًا ما يستفيد المختبرون اليدويون من مجموعة متنوعة من الأدوات المؤتمتة.\n\n#### دور اختبارات الاختراق\n\nفي الإصدار 4.0، قررنا جعل L1 قابلاً لاختبارات الاختراق بشكل تام دون الوصول إلى الشيفرة المصدرية أو الوثائق أو المطورين. للتوافق مع البند 10 (A10) في OWASP -العشر الأوائل 2017-  يتطلب وجود عنصرين logging ، كما يتطلب مقابلات أو لقطات شاشة أو جمع أدلة أخرى ، تمامًا كما يفعلونه في OWASP - العشر الأوائل. ومع ذلك، فإن عملية الاختبار دون الوصول إلى المعلومات الضرورية ليست طريقة مثالية للتحقق الأمني، فهي تفتقد إمكانية الرجوع للشيفرة المصدرية، وتحديد التهديدات والضوابط المفقودة، وإجراء اختبار أكثر شمولاً في إطار زمني أقصر. \n\nيلزم الوصول كلما أمكن إلى المطورين والوثائق والشيفرة المصدرية والوصول إلى تطبيق اختباري ببيانات غير التي توجد في البيئة الحقيقية test application with non-production data، عند إجراء تقييم L2 أو L3. تتطلب اختبارات الاختراق هذا المستوى من الوصول عندما يتم إجراؤها على مستويات كهذه، والذي نسميه \"المراجعات الهجينة hybrid reviews\" أو \"اختبارات الاختراق الهجينة hybrid penetration tests\". \n\n## استخدامات أخرى لـ ASVS\n\nإلى جانب استخدامه لتقييم أمان التطبيقات، فقد حددنا عددًا من الاستخدامات المحتملة الأخرى لـ ASVS.\n\n### استخدام المعيار كدليل تفصيلي لمعمارية الآمان\n\nأحد الاستخدامات الأكثر شيوعًا لمعيار التحقق من أمان التطبيقات هو كمورد لمهندسي أمان معمارية التطبيق security architects. يفتقد Sherwood Applied Business Security Architecture (SABSA) قدرًا كبيرًا من المعلومات الضرورية لإكمال مراجعة شاملة لمعمارية أمان التطبيق. يمكن استخدام ASVS لسد هذه الفجوات من خلال السماح لمهندسي الأمن باختيار ضوابط أفضل للمشاكل الشائعة، مثل أنماط حماية البيانات data protection patterns واستراتيجيات التحقق من صحة المدخلات input validation strategies.\n\n### استخدام المعيار كبديل لقوائم التحقق الثانوية وغير المستخدمة للشيفرة المصدرية الآمنة On the shelf Secure Coding Checklists\n\nيمكن للعديد من المنظمات الاستفادة من اعتماد ASVS، عن طريق اختيار أحد المستويات الثلاثة، أو عن طريق إنشاء تفريع forking لـ ASVS وتغيير ما هو مطلوب لكل مستوى من مستويات مخاطر التطبيق في مجال معين. نحن نشجع هذا النوع من الـتفريع طالما يتم الاحتفاظ بتتبع التعديلات، بحيث إذا اجتاز التطبيق المتطلب 4.1، فالنسخ المتفرعةforked copies  يجب أن تجتاز نفس المتطلب.\n\n### استخدام المعيار كدليل لـ Unit and Integration Tests المؤتمتة\n\nتم تصميم ASVS ليكون قابلاً للاختبار بدرجة عالية، باستثناء متطلبات البنية المعمارية والشيفرة الضارة malicious code. من خلال بناء اختبارات الوحدة والتكامل والتي تختبر fuzz cases و abuse casesمحددة، عندها يصبح التطبيق قريب إلى التحقق الذاتي self-verifying مع كل build للتطبيق. على سبيل المثال، يمكن إجراء اختبارات إضافية لمجموعة الاختبار لـ login controller، واختبار المدخلات كبارامتر username لأسماء المستخدمين الافتراضية الشائعة، وaccount enumeratio، و brute forcing، وحقن LDAP و SQL، و XSS. وبالمثل، يجب أن يتضمن اختبار بارامتر كلمة المرور طول كلمة المرور وكلمات المرور الشائعة و null byte injectionوإزالة البارامتر remove parameter و XSS وغيرها.\n\n### استخدام المعيار كتدريب للتطوير البرمجي الآمن\n\nيمكن أيضًا استخدام ASVS لتحديد خصائص البرامج الآمنة. العديد من دورات \"التنفيذ البرمجي الآمن\" هي ببساطة دورات قرصنة أخلاقية مع مسحة خفيفة من نصائح التنفيذ البرمجي. قد لا يساعد هذا بالضرورة المطورين على كتابة تعليمات برمجية أكثر أمانًا. ولكن يمكن استخدام ASVS في دورات التطوير الآمنة مع التركيز الشديد على الضوابط الاستباقية الموجودة في ASVS، بدلاً من أهم 10 أشياء سلبية لا يجب القيام بها.\n\n### استخدام المعيار لقيادة تطوير التطبيقات الرشيقة\n\nيمكن استخدام ASVS في عملية التطوير الرشيقةagile development process  كإطار عمل لتحديد المهام المحددة التي يجب أن ينفذها الفريق للحصول على منتج آمن. قد يكون أحد الأساليب: بدءًا من المستوى 1، التحقق من التطبيق أو النظام المحدد وفقًا لمتطلبات ASVS للمستوى المحدد، والعثور الضوابط المفقودة ورفع tickets/tasks محددة في الـ backlog. يساعد هذا في تحديد أولويات مهام محددة (أو grooming)، ويجعل الأمان مرئيًا في منهجية agile. يمكن استخدام هذا أيضًا لتحديد أولويات مهام التدقيق والمراجعة في المؤسسة، حيث يمكن أن يكون متطلب محدد في ASVS دافعًا للمراجعة أو إعادة البناء أو التدقيق لعضو فريق معين ويكون مرئيًا على أنه \"مُستحَق debt \" في الـ backlog ويجب القيام به في النهاية.\n\n### استخدام المعيار كإطار لتوجيه شراء البرامج الآمنة\n\nASVS هو إطار عمل رائع للمساعدة في شراء البرامج الآمنة أو شراء خدمات التطوير المخصصة. يمكن للمشتري ببساطة أن يضع مطلبًا بأن \nالبرنامج الذي يرغب في شرائه يجب أن يتم تطويره على مستوى ASVS X، ويطلب من البائع إثبات أن البرنامج يفي بالمستوى X من ASVS. يعمل هذا بشكل جيد عند دمجه مع ملحق عقد OWASP للبرنامج الآمن OWASP Secure Software Contract Annex.\n", "timestamp": "2025-10-24T11:39:41.780677"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x10-V1-Architecture.md", "content": "# ت1: المعمارية، والتصميم ونمذجة التهديدات\n\n## الهدف من ضوابط الأمان\n\nأصبح أمان المعمارية فنًا مفقوداً في العديد من المنظمات. لقد ولت أيام مهندس معمارية التطبيق في المؤسسة enterprise architect في عصر DevSecOps. يجب على مجال أمان التطبيقات أن يواكب الجديد ويعتمد مبادئ أمان agile عند إعادة تقديم مبادئ أمان المعمارية الرائدة لممارسي هندسة البرمجيات. المعمارية ليست تنفيذ، ولكنها طريقة للتفكير في مشكلة يحتمل أن يكون لها العديد من الإجابات المختلفة، ولا توجد إجابة واحدة \"صحيحة\". في كثير من الأحيان، يُنظر إلى الأمان على أنه غير مرن ويتطلب من المطورين تعديل الشيفرة المصدرية بطريقة معينة عندما يجد المطورون طريقة أفضل لحل المشكلة. لا يوجد حل واحد بسيط للمعمارية، والاعتقاد بخلاف ذلك يضر بمجال هندسة البرمجيات.\n\nربما تتم مراجعة تنفيذ معين لتطبيق ويب بشكل مستمر طوال حياته، تتغير المعمارية نادراً ولكنها تتطور ببطىء. إن معمارية الأمان مماثلة في كل التفاصيل والأوقات على حد سواء - نحتاج إلى المصادقة اليوم ، وسنحتاج المصادقة غدًا ، وسنحتاجها بعد خمس سنوات من الآن. إذا اتخذنا قرارات سليمة اليوم، فيمكننا توفير الكثير من الجهد والوقت والمال إذا اخترنا الحلول المتوافقة مع المعمارية وأعدنا استخدامها. على سبيل المثال، قبل عشرة سنوات، كان استخدام المصادقة متعددة العوامل multi-factor authentication  نادراً.\n\nفيمكن تحديث مزود الهوية لدمج متطلبات جديدة مثل متطلبات الامتثال لـ NIST 800-63 ، مع عدم تغيير واجهات التطبيق الأصلي. إذا كانت العديد من التطبيقات تشترك في نفس معمارية الأمان وبالتالي نفس المكون، فإنهم جميعًا يستفيدون من هذه الترقية مرة واحدة. ومع ذلك، لن تظل SAML دائمًا أفضل حل مصادقة أو أنسبها - فقد يلزم استبدالها بحلول أخرى مع تغير المتطلبات. مثل هذه التغييرات إما معقدة، ومكلفة للغاية بحيث تتطلب إعادة كتابة كاملة، أو مستحيلة تمامًا بدون معمارية الأمان.\n\nفي هذا الفصل، يغطي ASVS الجوانب الأساسية لأي معمارية أمان سليمة: التوافر availability والسرية confidentiality وسلامة المعالجة processing integrity وعدم الإنكار non-repudiation والخصوصية privacy. يجب أن تكون مبادئ الأمان هذه بديهية وأساسية في جميع التطبيقات. إنه من المهم \"التحول نحو اليسار shift left\"، بدءًا من تمكين المطور من خلال قوائم التحقق من كتابة الشيفرة المصدرية الآمنة secure coding checklists، والتوجيه mentoring والتدريب، وكتابة الشيفرة المصدرية والاختبار، والبناء  build، والنشر deployment ، والتكوين configuration ، والعمليات ، والانهاء بالاختبارات المستقلة يتبع ما سبق للتأكد من أن جميع ضوابط الأمان موجودة وفعالة. الخطوة الأخيرة هي استخدام كل ما سبق في الصناعة، ولكن هذا لم يعد كافيًا عندما يضع المطورون الشيفرة المصدرية في بيئة الإنتاج الحقيقية production  عشرات أو مئات المرات يومياً. يجب على محترفي أمان التطبيقات مواكبة تقنيات agile، مما يعني اعتماد أدوات المطور developer tools، وتعلم البرمجة، والعمل مع المطورين بدلاً من انتقاد المشروع بعد شهور من انتقال أي شخص آخر.\n\n## ق1.1 دورة حياة تطوير البرمجيات الآمنة\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | تحقق من استخدام دورة حياة تطوير البرمجيات الآمنة التي تتناول الأمان في جميع مراحل التطوير. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **2.1.1** | تحقق من استخدام نمذجة التهديد عند كل تغيير في التصميم أو في الـ sprint لتحديد التهديدات، والتخطيط للإجراءات المضادة، وتسهيل الاستجابات المناسبة للمخاطر، وتوجيه اختبارات الأمان. | | ✓ | ✓ | 1053 |\n| **3.1.1** | تحقق من أن جميع قصص المستخدم user stories والميزات تحتوي على قيود أمان وظيفية، مثل \"بصفتي مستخدمًا، يجب أن أتمكن من عرض ملف التعريف الخاص بي وتعديله. لا ينبغي أن أكون قادرًا على عرض ملف التعريف الخاص بأي شخص آخر أو تعديله\" | | ✓ | ✓ | 1110 |\n| **4.1.1** | تحقق من التوثيق والتبرير justification لجميع حدود ثقة التطبيق trust boundaries والمكونات وتدفقات البيانات significant data flows الهامة. | | ✓ | ✓ | 1059 |\n| **5.1.1** | تحقق من التعريف والتحليل الأمني للمعمارية عالية المستوى high-level architecture للتطبيق وجميع الخدمات المتصلة عن بعد connected remote services. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **6.1.1** | تحقق من تنفيذ ضوابط أمنية مركزية وبسيطة (الاقتصاد في التصميم economy of design) تم فحصها وتعتبر آمنة وقابلة لإعادة الاستخدام لتجنب الضوابط المكررة أو المفقودة أو غير الفعالة أو غير الآمنة. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **7.1.1** | تحقق من توفر قائمة تحقق لكتابة شيفرة مصدرية آمنة secure coding checklist ،أو متطلبات الأمان أو إرشادات أو سياسة لجميع المطورين والمختبرين. | | ✓ | ✓ | 637 |\n\n## ق2.1 معمارية المصادقة\n\nعند تصميم المصادقة ، لا يهم أن يكون لديك مصادقة متعددة العوامل ممكّنة للأجهزة القوية إذا كان بإمكان المهاجم إعادة تعيين حساب عن طريق الاتصال بمركز الاتصال call center والإجابة على الأسئلة الشائعة. عند إثبات الهوية، يجب أن تتمتع جميع مسارات المصادقة authentication paths بنفس القوة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | تحقق من استخدام حسابات نظام تشغيل فريدة أو خاصة بامتيازات منخفضة low-privilege لجميع مكونات التطبيق والخدمات والخوادم. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **2.2.1** | تحقق من أن جميع الاتصالات بين مكونات التطبيق ، بما في ذلك الـ APIs وmiddleware وطبقات البيانات data layers هي مصادق عليها authenticated. يجب أن تحتوي المكونات على أقل الامتيازات اللازمة. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **3.2.1** | تحقق من أن التطبيق يستخدم آلية مصادقة واحدة تم فحصها ومن المعروف أنها آمنة ، ويمكن توسيعها لتشمل مصادقة قوية ، ولديه ما يكفي من التسجيل logging والمراقبة لاكتشاف إساءة استخدام الحساب أو الخروقات account abuse or breaches . | | ✓ | ✓ | 306 |\n| **4.2.1** | تحقق من أن جميع مسارات المصادقة وواجهات برمجة تطبيقات إدارة الهوية identity management APIs تستخدم ضوابط أمان قوية وملائمة للمصادقة ، بحيث لا توجد بدائل أضعف من ناحية مخاطر التطبيق. | | ✓ | ✓ | 306 |\n\n## ق3.1 معمارية إدارة الجلسة\n\nهذه الفقرة فارغة للمتطلبات المعمارية المستقبلية المتعلقة بإدارة الجلسة.\n\n## ق4.1 معمارية التحكم في الوصول\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | تحقق من أن نقاط التنفيذ الموثوقة trusted enforcement points كالتي عند بوابات التحكم في الوصول والخوادم والـserverless functions  تفرض ضوابط الوصول. لا تفرض أبدًا ضوابط الوصول على العميل. | | ✓ | ✓ | 602 |\n| **2.4.1** | [تم حذفها ، غير قابلة للتنفيذ] | | | | |\n| **3.4.1** | [تم حذفها ، مكررة عن 3.1.4] | | | | |\n| **4.4.1** | تحقق من أن التطبيق يستخدم آلية واحدة للتحكم في الوصول تم فحصها جيدًا للوصول إلى البيانات والموارد المحمية. يجب أن تمر جميع الطلبات من خلال هذه الآلية الفردية لتجنب النسخ واللصق أو المسارات البديلة غير الآمنة insecure alternative paths. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **5.4.1** | تحقق من استخدام التحكم في الوصول المستند على الخاصية أو الميزة attribute or feature-based access control  حيث تتحقق الشيفرة المصدرية من وجود تفويض للمستخدم للوصول للميزة أو لعنصر البيانات بدلاً من التحقق من دوره فقط. يجب أن يتم حصر تخصيص الأذونات Permissions باستخدام الأدوار. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## ق5.1 معمارية المدخلات والمخرجات\n\nفي الإصدار 4.0 ، ابتعدنا عن مصطلح \"من جهة الخادم\"server-side \" كمصطلح حدود الثقة المحملة loaded trust boundary. لا تزال حدود الثقة مثيرة للقلق - اتخاذ القرارات بشأن المتصفحات غير الموثوق بها أو أجهزة العميل أمر يمكن تجاوزه - ومع ذلك ، في عمليات نشر المعمارية السائدة mainstream architectural deployments اليوم ، تغيرت نقطة إنفاذ الثقة trust enforcement point بشكل كبير. لذلك ، عند استخدام مصطلح \"طبقة الخدمة الموثوقة trusted service layer \" في ASVS ، فإننا نعني أي نقطة تنفيذ موثوقة trusted enforcement point ، بغض النظر عن الموقع ، مثل خدمة مصغرة microservice والـ serverless API وserver-side والـ trusted API على جهاز عميل لديه إقلاع آمن secure boot أو partner or external APIs، وما إلى ذلك.\n\nيشير مصطلح \"العميل غير الموثوق به untrusted client\" هنا إلى تقنيات من جهة العميل client-side technologies التي تعرض طبقة العرض التقديمي presentation layer، والتي يشار إليها عادةً باسم تقنيات \"الواجهة الأمامية 'front-end \". لا يشير مصطلح \"التسلسل serialization \" هنا فقط إلى إرسال البيانات عبر السلك over the wire مثل مجموعة من القيم أو أخذ بنية JSON وقراءتها ، بل يشير أيضًا إلى تمرير الكائنات المعقدة التي يمكن أن تحتوي على منطق.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | تحقق من أن متطلبات المدخلات والمخرجات تحدد بوضوح كيفية التعامل مع البيانات ومعالجتها بناءً على النوع والمحتوى والقوانين واللوائح المعمول بها والامتثال للسياسة الأخرى. | | ✓ | ✓ | 1029 |\n| **2.5.1** | تحقق من عدم استخدام التسلسل عند الاتصال بعملاء غير موثوق بهم. إذا لم يكن ذلك ممكنًا ، فتأكد من فرض ضوابط الحماية الكافية (كالتشفير إذا تم إرسال بيانات حساسة) لمنع هجمات إلغاء التسلسل deserialization attacks  بما في ذلك حقن الكائنات object injection. | | ✓ | ✓ | 502 |\n| **3.5.1** | تحقق من أن التحقق من صحة المدخلات input validation يتم فرضه على طبقة خدمة موثوقة trusted service layer. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **4.5.1** | تحقق من أن ترميز المخرجات output encoding يحدث بالقرب من أو من قبل مفسر الأوامر interpreter الموجه إليه. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## ق6.1 معمارية التشفير\n\nيجب تصميم التطبيقات باستخدام معمارية تشفير قوية لحماية أصول البيانات وفقًا لتصنيفها. يعد تشفير كل شيء إهدارًا ، ولا يعد عدم تشفير أي شيء إهمالًا قانونيًا. يجب تحقيق توازن وهذا يكون عادةً أثناء التصميم المعماري أو عالي المستوى high level design ، أو في design sprints  أو المسامير المعمارية architectural spikes. إن تصميم أو تعديل التشفير للتنفيذ الآمن أثناء المضي قدماً سيكلف حتماً أكثر بكثير مقارنة ببنائه من البداية.\n\nتعتبر المتطلبات المعمارية جوهرية لأساس الشيفرة المصدرية بأكملها ، وبالتالي تزيد من صعوبة اختبارات الوحدة والتكامل unit or integrate test. تحتاج المتطلبات المعمارية إلى النظر في معايير كتابة الشيفرة المصدرية coding standards ، طوال مرحلة التنفيذ البرمجي، ويجب مراجعتها ضمن معمارية الأمان، أو مراجعات الأقران أو مراجعات الشيفرة المصدرية ، أو عمليات الاسترجاع retrospectives.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | تحقق من وجود سياسة واضحة لإدارة مفاتيح التشفير وأن دورة حياة مفتاح التشفير تتبع معيار إدارة المفاتيح مثل NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **2.6.1** | تحقق من أن مستخدمي خدمات التشفير يحمون المواد الأساسية Key material والأسرار الأخرى other secrets باستخدام خزائن المفاتيح key vaults أو البدائل القائمة على APIs. | | ✓ | ✓ | 320 |\n| **3.6.1** | تحقق من أن جميع المفاتيح وكلمات المرور قابلة للاستبدال وأنها جزء من عملية معرفة جيدًا لإعادة تشفير البيانات الحساسة. | | ✓ | ✓ | 320 |\n| **4.6.1** | تحقق من أن المعمارية تتعامل مع الأسرار من جهة العميل client-side secrets - مثل المفاتيح المتناظرة symmetric keys أو كلمات المرور أو الرموز المميزة لواجهة برمجة التطبيقات API tokens - باعتبارها غير آمنة ولا تستخدمها أبدًا لحماية البيانات الحساسة أو الوصول إليها. | | ✓ | ✓ | 320 |\n\n## ق7.1 معمارية الأخطاء، التسجيل والمراقبة\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | تحقق من استخدام طريقة وتنسيق شائع للتسجيل common logging format and approach داخل النظام. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **2.7.1** | تحقق من أن السجلات يتم إرسالها بشكل آمن إلى نظام التحكم عن بعد remote system  للتحليل والاكتشاف والتنبيه alerting والتصعيد escalation. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## ق8.1 معمارية حماية البيانات والخصوصية\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | تحقق من تحديد وتصنيف جميع البيانات الحساسة ضمن مستويات حماية protection levels. | | ✓ | ✓ | |\n| **2.8.1** | تحقق من أن جميع مستويات الحماية لها مجموعة مرتبطة من متطلبات الحماية ، مثل متطلبات التشفير ، ومتطلبات السلامة integrity requirements ، والاحتفاظ retention ، والخصوصية وغير ذلك من متطلبات السرية confidentiality requirements ، وأنه يتم تطبيقها في المعمارية. | | ✓ | ✓ | |\n\n## ق9.1 معمارية الاتصالات\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | تحقق من أن التطبيق يقوم بتشفير الاتصالات بين المكونات، خاصة عندما تتواجد المكونات في حاويات containers أو أنظمة أو مواقع أو مزودي خدمات سحابية cloud providers مختلفة. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **2.9.1** | تحقق من أن مكونات التطبيق تتحقق من صحة authenticity في كل جانب في حلقة الاتصال communication link لمنع هجمات الشخص في المنتصف person-in-the-middle. على سبيل المثال، يجب أن تتحقق مكونات التطبيق من صحة شهادات TLS وسلاسلها TLS certificates and chains. | | ✓ | ✓ | 295 |\n\n## ق10.1 معمارية البرمجيات الخبيثة\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | تحقق من أن نظام التحكم في الشيفرة المصدرية source code control system قيد الاستخدام ، مع إجراءات للتأكد من أن عمليات تسجيل الوصول يرافقها قضايا أو تذاكر تغيير issues or change tickets. يجب أن يمتلك نظام التحكم في الشيفرة المصدرية تحكماً في الوصول ومستخدمين يمكن التعرف عليهم للسماح بتتبع أي تغييرات. | | ✓ | ✓ | 284 |\n\n## ق11.1 معمارية منطق الأعمال\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | تحقق من تعريف وتوثيق جميع مكونات التطبيق من حيث الأعمال أو وظائف الأمان التي توفرها. | | ✓ | ✓ | 1059 |\n| **2.11.1** | تحقق من أن جميع تدفقات منطق الأعمال عالية القيمة high-value business logic flows ، بما في ذلك المصادقة وإدارة الجلسة والتحكم في الوصول ، لا تشترك في الحالة غير المتزامنة unsynchronized state. | | ✓ | ✓ | 362 |\n| **1.11.3** | تحقق من أن جميع تدفقات منطق الأعمال عالية القيمة ، بما في ذلك المصادقة وإدارة الجلسة والتحكم في الوصول ، هي آمنة عند استخدام الـthread  ومقاومة لـ time-of-check and time-of-use race conditions. | | | ✓ | 367 |\n\n## ق12.1 معمارية رفع الملفات بشكل آمن\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [تم حذفها ، مكررة عن 1.4.12] | | | | |\n| **2.12.1** | تحقق من أن الملفات التي يتم رفعها بواسطة المستخدم - إذا كان هناك حاجة لعرضها أو تحميلها  من التطبيق - يتم تقديمها إما من خلال تنزيلات دفق الثماني octet stream downloads ، أو من نطاق مختلف غير مرتبط بنطاق التطبيق unrelated domain ، مثل حاوية تخزين الملفات السحابية cloud file storage bucket. قم بتنفيذ سياسة أمان محتوى مناسبة Content Security Policy (CSP) لتقليل مخاطر هجمات XSS أو الهجمات الأخرى من الملف الذي تم رفعه. | | ✓ | ✓ | 646 |\n\n## ق13.1 معمارية واجهة التطبيقات البرمجية API\n\nهذه الفقرة فارغة للمتطلبات المعمارية المستقبلية المتعلقة بواجهة التطبيقات البرمجية API.\n\n## ق14.1 معمارية التكوين\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | تحقق من فصل مكونات مستويات الثقة المختلفة من خلال ضوابط أمان معرفة جيدًا ، أو قواعد جدار الحماية ، أو API gateways ، أو مخدمات البروكسي العكسية reverse proxies، أو مجموعات الأمان المستندة القائمة على السحابة  cloud-based security groups ، أو الآليات المماثلة. | | ✓ | ✓ | 923 |\n| **2.14.1** | تحقق من استخدام التوقيعات الثنائية binary signatures ، والاتصالات الموثوقة trusted connections، ونقاط النهاية التي تم التحقق منها verified endpoints لنشر الـ Binary على الأجهزة البعيدة. | | ✓ | ✓ | 494 |\n| **3.14.1** | تحقق من أن الـbuild pipeline يحذر من المكونات القديمة أو غير الآمنة ويتخذ الإجراءات المناسبة. | | ✓ | ✓ | 1104 |\n| **4.14.1** | تحقق من أن الـ build pipeline يحتوي على خطوة بناءbuild step  للبناء والتحقق من النشر الآمن للتطبيق تلقائياً build and verify the secure deployment of the application ، لا سيما إذا كانت البنية الأساسية للتطبيق معرفة برمجياً software defined ، مثل البرامج النصية لإنشاء بيئة السحابة cloud environment build scripts. | | ✓ | ✓ | |\n| **5.14.1** | تحقق من أن عمليات نشر التطبيق تقوم بشكل كاف بـ: استخدام وضع الحماية sandbox و / أو استخدام الحاويات containerize  و / أو عزل على مستوى الشبكة لتأخير وردع المهاجمين من مهاجمة التطبيقات الأخرى ، خاصةً عندما يقومون بأفعال حساسة أو خطيرة مثل إلغاء التسلسل deserialization. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **6.14.1** | تحقق من أن التطبيق لا يستخدم تقنيات غير مدعومة أو غير آمنة أو مهملة deprecated  من جهة العميل مثل مكونات NSAPI الإضافية NSAPI plugins أو Flash أو Shockwave أو ActiveX أو Silverlight أو NACL أو تطبيقات Java الصغيرة من جهة العميل client-side Java applets. | | ✓ | ✓ | 477 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:41.862299"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x11-V2-Authentication.md", "content": "# ت2: المصادقة\n\n## الهدف من ضوابط الأمان\n\nالمصادقة هي عملية تأكيد شخص ما (أو شيء ما) على أنه حقيقي وموثوق به وأن الادعاءات التي يقدمها شخص أو جهاز ما صحيحة ومقاومة لانتحال الهوية وتمنع استرداد كلمات المرور أو اعتراضها Interception.\n\nعندما تم إصدار ASVS لأول مرة ، كان اسم المستخدم + كلمة المرور أكثر أشكال المصادقة شيوعًا خارج أنظمة الأمان المشددة. تم قبول المصادقة متعددة العوامل Multi-factor Authentication (MFA)  بشكل عام في دوائر الأمان security circles  ولكنها نادرًا ما تكون مطلوبة في أي مكان آخر. مع زيادة عدد عمليات اختراق كلمات المرور ، تعارضت فكرة أن أسماء المستخدمين سرية إلى حد ما وكلمات المرور غير معروفة مع العديد من ضوابط الأمان وجعلت منها ضوابط غير مقبولة. على سبيل المثال ، يعتبر NIST 800-63 أسماء المستخدمين والمصادقة المستندة إلى المعرفة Knowledge Based Authentication (KBA)  بمثابة معلومات عامة وتعتبر كل من إشعارات الرسائل القصيرة والبريد الإلكتروني على أنها أنواع مصادقة \"مقيدة\" \"restricted\" authenticator types وتعتبر كلمات المرور على أنها مخترقة مسبقًا. وهذا في الواقع يجعل المصادقات القائمة على المعرفة ، واستعادة الرسائل القصيرة والبريد الإلكتروني ، وسجل كلمات المرور ، والتعقيد complexity ، وضوابط التدويرrotation controls  عديمة الفائدة. لطالما كانت هذه الضوابط أقل فائدة ، وغالبًا ما تجبر المستخدمين على ابتكار كلمات مرور ضعيفة كل بضعة أشهر ، ولكن مع ظهور أكثر من 5 مليارات عملية اختراق لاسم المستخدم وكلمة المرور ، فقد حان الوقت للمضي قدمًا.\n\nمن بين جميع الفصول في ASVS ، تغيرت فصول المصادقة وإدارة الجلسة أكثر من غيرها. سيكون تبنَي ممارسة رائدة فعالة وقائمة على الأدلة تحدياً كبيراً بالنسبة للكثيرين ، وهذا أمر جيد تمامًا. علينا أن نبدأ الانتقال إلى مستقبل ما بعد كلمة المرور الآن.\n\n## NIST 800-63 - معيار مصادقة حديث قائم على الأدلة\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) هو معيار حديث قائم على الأدلة ، ويمثل أفضل اقتراح متاح ، بغض النظر عن قابلية التطبيق. المعيار مفيد لجميع المنظمات في جميع أنحاء العالم ولكنه وثيق الصلة بشكل خاص بالوكالات الأمريكية وتلك التي تتعامل معها.\n\nيمكن أن تكون مصطلحات NIST 800-63 مربكة بعض الشيء في البداية ، خاصة إذا كنت تستخدم فقط المصادقة التقليدية (اسم المستخدم + كلمة المرور). تعتبر التطورات في المصادقة الحديثة ضرورية ، لذلك يتعين علينا تقديم مصطلحات ستصبح شائعة في المستقبل ، إننا ندرك أن هناك صعوبة الفهم لغاية استقرار الصناعة على هذه المصطلحات الجديدة. لقد قدمنا قائمة مصطلحات في نهاية هذا الفصل للمساعدة. لقد أعدنا صياغة العديد من المتطلبات لتحقيق الغاية الرئيسية منها، بدلاً من نص المتطلب. على سبيل المثال ، يستخدم ASVS مصطلح \"كلمة المرور password\" عندما يستخدم NIST \"السر المحفوظ \"memorized secret   في جميع فقرات هذا المعيار.\n\nتم ملائمة ت2 المصادقة، ت3 إدارة الجلسات وبدرجة أقل ت4 التحكم في الوصول لتكون مجموعة فرعية متوافقة من ضوابط NIST 800-63b المحددة ، والتي تركز على التهديدات الشائعة ونقاط الضعف الشائعة في المصادقة. عندما يكون الامتثال الكامل لـ NIST 800-63 مطلوبًا ، يرجى الرجوع إلى NIST 800-63.\n\n### اختيار مستوى NIST AAL المناسب\n\nحاول معيار التحقق من أمان التطبيقات تعيين ASVS L1 لمتطلبات NIST AAL1 و L2 إلى AAL2 و L3 إلى AAL3. ومع ذلك ، فإن نهج المستوى 1 في ASVS كضوابط  \"أساسية\" قد لا يكون بالضرورة هو مستوى AAL الصحيح للتحقق من تطبيق أو واجهة برمجة تطبيقات API. على سبيل المثال ، إذا كان التطبيق عبارة عن تطبيق من المستوى 3 أو لديه متطلبات تنظيمية ليكون AAL3 ، فيجب اختيار المستوى 3 في الفصلين ت2 و ت3. يجب إجراء اختيار مستوى تأكيد المصادقة Authentication Assertion Level (AAL)  المتوافق مع NIST وفقًا لإرشادات NIST 800-63b كما هو موضح في تحديد AAL في [NIST 800-63b Section 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## فقرة توضيحية\n\nفي كثير من الأحيان تحتاج التطبيقات لمتطلبات تفوق متطلبات المستوى الحالي خاصة إذا كان التطبيق يستخدم المصادقة الحديثة. سابقاً، إذا كان ASVS يتطلب المصادقة متعددة العوامل كمتطلب أساسي ولكن NIST لا يتطلب ذلك. استخدمنا التصميم الاختياري optional designation  في هذا الفصل للإشارة إلى الحالات التي توصي ASVS باستخدام الضابط فيها، ولكن لا تفرضه. المفاتيح التالية لتوصيات ASVS ضمن هذا المعيار هي في الجدول التالي:\n\n| العلامة | التوصيف |\n| :--: | :-- |\n| | غير مطلوب |\n| o | موصى به، ولكنه غير مطلوب |\n| ✓ | مطلوب |\n\n## ق1.2 أمان كلمة المرور\n\nتتضمن كلمات المرور التي تطلق NIST 800-63 عليها اسم \"الأسرار المحفوظة Memorized Secrets\"، كلمات المرور وأرقام التعريف الشخصية PIN  وأنماط إلغاء القفل unlock patterns واختيار القط الصحيح pick the correct kitten أو عنصر صورة آخر وعبارات المرور passphrases. يتم اعتبارها بشكل عام \"شيئًا تعرفه something you know\" ، وغالبًا ما تستخدم كمصادقين أحاديي العامل single-factor authenticators. هناك تحديات كبيرة أمام الاستخدام المستمر للمصادقة أحادية العامل ، بما في ذلك المليارات من أسماء المستخدمين وكلمات المرور الصحيحة التي تم تسريبها على الإنترنت ، وكلمات المرور الافتراضية أو الضعيفة ، وجداول قوس قزح rainbow tables والقواميس المنظمة ordered dictionaries لكلمات المرور الأكثر شيوعًا.\n\nيجب أن تشجع التطبيقات المستخدمين بشدة على اسنخدام المصادقة متعددة العوامل ، ويجب أن تسمح للمستخدمين بإعادة استخدام الرموز المميزة tokens التي يمتلكونها بالفعل ، مثل الرموز المميزة FIDO أو U2F ، أو الارتباط بمزود خدمة الاعتماد credential service provider الذي يوفر مصادقة متعددة العوامل.\n\nيوفر مزودو خدمة الاعتماد Credential Service Providers (CSPs)  هوية موحدة للمستخدمين. غالبًا ما يكون لدى المستخدمين أكثر من هوية واحدة federated identity مع العديد من CSPs ، مثل هوية المؤسسة باستخدام Azure AD أو Okta أو Ping Identity أو Google ، أو هوية المستهلك باستخدام Facebook أو Twitter أو Google أو WeChat ، وهذا على سبيل المثال لا الحصر. هذه القائمة ليست إقراراً لهذه الشركات أو الخدمات ، ولكنها مجرد تشجيع للمطورين للنظر في حقيقة أن العديد من المستخدمين لديهم العديد من الهويات الثابتة. يجب أن تفكر المنظمات في التكامل مع هويات المستخدمين الحالية ، وفقًا لملف تعريف المخاطر الخاص بقوة CSP في إثبات الهوية risk profile of the CSP's strength of identity proofing. على سبيل المثال ، من غير المحتمل أن تقبل منظمة حكومية هوية وسائل التواصل الاجتماعي كمعلومات تسجيل دخول للأنظمة الحساسة ، حيث أنه من السهل إنشاء هويات مزيفة أو التخلص منها ، في حين أن شركة ألعاب الهاتف المحمول قد تحتاج إلى الاندماج مع منصات الوسائط الاجتماعية الرئيسية لتنمية قاعدة اللاعبين النشطين.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.1.2** | تحقق من أن طول كلمات المرور التي يقوم المستخدم بتعيينها لا يقل عن 12 حرفًا (بعد دمج مسافات متعددة).  ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | تحقق من أن كلمات المرور المكونة من 64 حرفًا أو أكثر مسموح بها ويجب ألا تزيد عن 128 حرفًا. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **3.1.2** | تحقق من عدم تنفيذ اقتطاع truncation كلمة المرور. ومع ذلك ، يمكن استبدال المسافات المتعددة المتتالية بمسافة واحدة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **4.1.2** | تحقق من السماح باستخدام أي حرف Unicode قابل للطباعة ، بما في ذلك الأحرف المحايدة للغة مثل المسافات والرموز التعبيرية في كلمات المرور. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **5.1.2** | تحقق من قدرة المستخدمين على تغيير كلمة المرور الخاصة بهم. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **6.1.2** | تحقق من أن تابع تغيير كلمة المرور يتطلب كلمة المرور الحالية والجديدة للمستخدم. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **7.1.2** | Vتحقق من فحص كلمات المرور المرسلة أثناء عمليات تسجيل الحساب وتسجيل الدخول وتغيير كلمة المرور مقابل مجموعة من كلمات المرور المخترقة إما محليًا (مثل أكثر 1000 كلمة مرور أو 10000 كلمة مرور شائعة تتطابق مع سياسة النظام لكلمة مرور) أو باستخدام واجهة برمجة تطبيقات خارجية. في حالة استخدام واجهة برمجة التطبيقات ، يجب استخدام zero knowledge proof أو أي آلية أخرى لضمان عدم إرسال كلمة مرور بشكل صريح أو استخدامها للتحقق من حالة كلمة المرور. إذا تم اختراقها، يجب أن يطلب التطبيق من المستخدم تعيين كلمة مرور جديدة غير مخترقة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **8.1.2** | تحقق من توفير مقياس قوة كلمة المرور password strength meter لمساعدة المستخدمين على تعيين كلمة مرور أقوى. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **9.1.2** | تحقق من عدم وجود قواعد بناء كلمة مرور password composition rules تحد من نوع الأحرف المسموح بها. يجب ألا تكون هناك متطلبات للأحرف الكبيرة أو الصغيرة أو الأرقام أو الأحرف الخاصة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **10.1.2** | تحقق من عدم وجود متطلبات دورية لتداول بيانات الاعتماد credential rotation أو متطلبات سجل كلمة المرور password history. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **11.1.2** | تحقق من السماح لـ وظيفة \"اللصق paste\" ، ومساعدات كلمة مرور المتصفح browser password helpers ، ومديري كلمات المرور الخارجية external password managers. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **12.1.2** | تحقق من أن المستخدم يمكن أن يختار إما عرض كلمة المرور المقنعة بالكامل  masked password مؤقتًا ، أو عرض آخر حرف مكتوب من كلمة المرور مؤقتًا على الأنظمة الأساسية التي لا توجد فيها هذه الوظيفة كوظيفة مضمنة built-in. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nملاحظة: الهدف من السماح للمستخدم بمشاهدة كلمة المرور الخاصة به أو رؤية الحرف الأخير مؤقتًا هو تحسين إمكانية استخدام إدخال بيانات الاعتماد ، لا سيما فيما يتعلق باستخدام كلمات مرور وعبارات مرور passphrases ومديري كلمات مرور password managers أطول. سبب آخر لتضمين هذا المتطلب هو منع تقارير الاختبار التي تطلب من المنظمات بشكل غير ضروري كتابة تنفيذ برمجي جديد لسلوك حقل كلمة مرور المدمج override built-in platform password field behavior  وذلك لإزالة هذه التجربة الأمنية الحديثة سهلة الاستخدام.\n\n## ق2.2 الأمان العام للمصادق authenticator\n\nتعد سرعة أداة المصادقة ضرورية للتطبيقات المستقبلية. يجب إعادة بناء refactor محقق التطبيق application verifier للسماح بالمصادقين الإضافيين وفقًا لما يرغبه المستخدم ، فضلاً عن السماح للمصادقين المتقاعدين أو غير الآمنين بطريقة منظمة.\n\nتعتبر NIST البريد الإلكتروني والرسائل القصيرة من  [أنواع المصادقة \"المقيدة\" \"restricted\" authenticator types](https://pages.nist.gov/800-63-FAQ/#q-b1)، ومن المحتمل إزالتها من NIST 800-63 وبالتالي يتم إزالتها أيضاً من ASVS في وقت ما في المستقبل. يجب أن تخطط التطبيقات لخريطة طريق لا تتطلب استخدام البريد الإلكتروني أو الرسائل القصيرة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.2.2** | تحقق من أن ضوابط مضادات الأتمتة anti-automation controls  فعالة في تخفيف breached credential testing و brute force وهجمات إغلاق الحساب account lockout attacks. تتضمن هذه الضوابط حظر كلمات المرور المخترقة الأكثر شيوعًا ، أو عمليات الإغلاق الناعمة soft lockouts ، أو تحديد المعدل rate limiting ، أو اختبار CAPTCHA ، أو زيادة التأخيرات باستمرار بين المحاولات، أو قيود على عنوان IP (IP address restrictions)، أو القيود القائمة على المخاطر risk-based restrictions  مثل الموقع، أو أول تسجيل دخول على الجهاز، أو المحاولات الأخيرة لإلغاء قفل الحساب ، وغير ذلك. تحقق من أنه لا يمكن إجراء أكثر من 100 محاولة فاشلة في الساعة على حساب واحد. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | تحقق من أن استخدام المصادق الضعيف weak authenticator (مثل الرسائل القصيرة والبريد الإلكتروني) يقتصر على التحقق الثانوي والموافقة على المعاملات وليس كبديل لطرق المصادقة الأكثر أمانًا. تحقق من تقديم طرق أقوى قبل الطرق الضعيفة ، أو أن المستخدمين على دراية بالمخاطر ، أو أن الإجراءات المناسبة موجودة للحد من مخاطر اختراق الحساب. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **3.2.2** | تحقق من إرسال الإشعارات الآمنة secure notifications إلى المستخدمين بعد التحديثات على تفاصيل المصادقة ، مثل إعادة تعيين بيانات الاعتماد credential resets ، أو تغيير البريد الإلكتروني أو العنوان ، أو تسجيل الدخول من مواقع غير معروفة أو خطرة. يُفضل استخدام إشعارات الدفع push notifications - بدلاً من الرسائل القصيرة أو البريد الإلكتروني - ، ولكن في حالة عدم وجود إشعارات الدفع ، فإن استخدام الرسائل القصيرة أو البريد الإلكتروني مقبول طالما لم يتم الكشف عن أي معلومات حساسة في الإشعار. | ✓ | ✓ | ✓ | 620 | |\n| **4.2.2** | تحقق من مقاومة انتحال الهوية impersonation resistance ضد التصيد الاحتيالي phishing ، مثل استخدام المصادقة متعددة العوامل ، أو أجهزة التشفير بقصد cryptographic devices with intent (مثل المفاتيح المتصلة مع الدفع connected keys with a push  للمصادقة) ، أو الشهادات من جهة العميل عند مستويات أعلى من AAL. | | | ✓ | 308 | 5.2.5 |\n| **5.2.2** | تحقق من أنه في حالة فصل مزود خدمة الاعتماد (CSP) عن تطبيق التحقق من المصادقة ، فإن TLS المصادق عليه بشكل متبادل موجود بين نقطتي النهاية. | | | ✓ | 319 | 5.2.6 |\n| **6.2.2** | تحقق من مقاومة إعادة التشغيل replay resistance  من خلال الاستخدام الإلزامي لأجهزة كلمات المرور لمرة واحدة One-time Passwords (OTP) أو مصادقوا التشفير cryptographic authenticators أو رموز البحث lookup codes. | | | ✓ | 308 | 5.2.8 |\n| **7.2.2** | تحقق من نية المصادقة من خلال طلب إدخال OTP token أو إجراء بدأه المستخدم مثل الضغط على زر على مفتاح جهاز FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## ق3.2 دورة حياة المصادق authenticator\n\nالمصادقة عبارة عن كلمات مرور ورموز إلكترونية soft tokens ورموز للأجهزة hardware tokens وأجهزة قياس حيوية biometric devices. تعد دورة حياة المصادقين أمرًا بالغ الأهمية لأمان التطبيق - إذا كان بإمكان أي شخص تسجيل حساب بنفسه بدون دليل على الهوية ، فستكون الثقة أقل في تأكيد الهوية. بالنسبة لمواقع التواصل الاجتماعي مثل Reddit ، هذا جيد تمامًا. بالنسبة للأنظمة المصرفية ، يعد التركيز الأكبر على تسجيل وإصدار بيانات الاعتماد والأجهزة أمرًا بالغ الأهمية لأمن التطبيق.\n\nملاحظة: لا يشترط أن يكون لكلمات المرور عمر أعظمي أو أن تخضع كلمة المرور للتدوير rotation . يجب فحص كلمات المرور للتأكد إذا تم اختراقها أو لا يتم تغييرها بانتظام.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.3.2** | تحقق من أن كلمات المرور الأولية أو رموز التنشيط rotation التي تم إنشاؤها بواسطة النظام ويتم توليدها بشكل عشوائي وآمن، ويجب ألا يقل طولها عن 6 خانات ، وقد تحتوي على أحرف وأرقام ، وتنتهي صلاحيتها بعد فترة قصيرة من الوقت. يجب ألا يُسمح لهذه الأسرار الأولية initial secrets  بأن تصبح كلمة مرور طويلة المدى. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | تحقق من دعم التسجيل واستخدام أجهزة المصادقة التي يوفرها المستخدم ، مثل رموز U2F أو FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **3.3.2** | تحقق من إرسال تعليمات التجديد مع إتاحة الوقت الكافي لتجديد المصادقين المقيدين time bound authenticators. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## ق4.2 تخزين بيانات الاعتماد\n\nيجب على مهندسي المعمارية والمطورين الالتزام بهذا القسم عند بناء أو إعادة بناء الشيفرة المصدرية. لا يمكن التحقق من هذا القسم بالكامل إلا باستخدام مراجعة الشيفرة المصدرية source code review  أو من خلال secure unit or integration tests. لا يمكن لاختبار الاختراق تحديد أي من هذه المشكلات.\n\nتم تفصيل قائمة one-way key derivation functions  المعتمدة في NIST 800-63 B القسم 5.1.1.2 ، وفي  [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). يمكن اختيار أحدث خوارزمية وطنية أو إقليمية ومعايير طول المفتاح بدلاً من هذه الاختيارات.\n\nلا يمكن تنفيذ اختبار الاختراق للتحقق من متطلبات هذا القسم ، لذلك لم يتم تمييز الضوابط على أنها L1. ومع ذلك ، فإن هذا القسم له أهمية حيوية لأمان بيانات الاعتماد في حالة سرقتها ، لذلك عند تفريع  (forking) ASVS للحصول على إرشادات معمارية أو كتابة شيفرة مصدرية أو قائمة مراجعة أو قائمة تحقق لمراجعة الشيفرة المصدرية، يرجى إعادة الضوابط هذه إلى L1 في إصدارك الخاص.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.4.2** | تحقق من تخزين كلمات المرور بشكل يقاوم الهجمات التي لا تحتاج لاتصال بالإنترنت. يجب استخدام salt مع كلمات المرور وتجزئتها hashed باستخدام one-way key derivation function أو وظيفة تجزئة كلمة المرور password hashing function. تأخذ وظائف اشتقاق المفاتيح وتجزئة كلمة المرور كل من كلمة المرور وقيمة salt وعامل تكلفة cost factor  كمدخلات عند إنشاء hash لكلمة المرور. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | تحقق من أن قيمة salt يبلغ طوله 32 بتًا على الأقل وأن يتم اختياره بشكل عشوائي لتقليل تصادمات قيمة salt (salt value collisions) بين التجزئات المخزنة .يجب تخزين قيمة salt فريدة والتجزئة الناتجة لكل بيانات اعتماد. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **3.4.2** | تحقق من أنه في حالة استخدام PBKDF2 ، يجب أن يكون عدد التكرار iteration كبيرًا بقدر ما يسمح به أداء خادم التحقق ، وعادةً ما لا يقل عن 100،000 تكرار. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **4.4.2** | تحقق من أنه في حالة استخدام bcrypt، يجب أن يكون عامل العمل work factor كبيرًا بالقدر الذي يسمح به أداء خادم التحقق ، بالحد الآدنى 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **5.4.2** | تحقق من إجراء تكرار إضافي لـ key derivation function ، باستخدام قيمة salt تكون سرية ومعروفة فقط للمدققverifier . قم بتوليد قيمة salt باستخدام مولد بت عشوائي معتمد  random bit generator [SP 800-90Ar1] وقدّم على الأقل الحد الأدنى من قوة الأمان المحددة minimum security strength  في أحدث مراجعة من SP 800-131A. يجب تخزين قيمة salt السرية (secret salt value) بشكل منفصل عن كلمات المرور المجزأة hashed passwords  (على سبيل المثال ، في جهاز متخصص مثل وحدة أمان الأجهزة hardware security module). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nعند ذكر المعايير الأمريكية ، يمكن استخدام معيار إقليمي أو محلي بدلاً من أو بالإضافة إلى معيار الولايات المتحدة كما هو مطلوب.\n\n## ق5.2 استعادة بيانات الاعتماد\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.5.2** | تحقق من عدم إرسال التنشيط الأولي initial activation للنظام أو سر الاسترداد initial activation  بنص واضح للمستخدم. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | تحقق من عدم وجود تلميحات كلمة المرور أو المصادقة المستندة إلى المعرفة (ما يسمى \"الأسئلة السرية\"). | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **3.5.2** | التحقق من أن استعادة بيانات اعتماد كلمة المرور لا يكشف كلمة المرور الحالية بأي شكل من الأشكال. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **4.5.2** | تحقق من عدم وجود الحسابات المشتركة أو الافتراضية (مثل \"root\" أو \"admin\" أو \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **5.5.2** | تحقق من أنه في حالة تغيير عامل المصادقة authentication factor أو استبداله ، يتم إعلام المستخدم بهذا الحدث. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **6.5.2** | تحقق من استخدام مسارات استرداد آمنة في حال نسيان كلمة المرور أو استخدام طريقة استعادة أخرى، مثل OTP المستندة إلى الوقت time-based OTP (TOTP)  أو soft token آخر، أو دفع الهاتف المحمول mobile push ، أو آلية استرداد أخرى في وضع عدم الاتصال. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **7.5.2** | تحقق من أنه في حالة فقد OTP أو عوامل المصادقة متعددة العوامل ، يتم إجراء إثبات الهوية على نفس المستوى كما هو الحال أثناء التسجيل. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## ق6.2 البحث عن المحقق السري Look-up Secret Verifier\n\nأسرار البحث Look up secrets هي قوائم مُنشأة مسبقًا من الرموز السرية ، على غرار أرقام تفويض المعاملات Transaction Authorization Numbers  (TAN) ، أو رموز الاسترداد في تطبيقات التواصل الاجتماعي، أو شبكة تحتوي على مجموعة من القيم العشوائية. يتم توزيعها بشكل آمن على المستخدمين. يتم استخدام رموز البحث هذه مرة واحدة ، وبمجرد استخدام كل عناصر القائمة ، يتم تجاهلها بالكامل. يعتبر هذا النوع من المصادقة \"شيئًا لديك something you have\".\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.6.2** | تحقق من إمكانية استخدام أسرار البحث lookup secrets  مرة واحدة فقط. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | تحقق من أن أسرار البحث lookup secrets  تمتلك عشوائية كافية (112 بت من الانتروبيا entropy) ، أو إذا كان أقل من 112 بت من الانتروبيا ، مع قيمة salt فريدة وعشوائية بطول 32 بت ومجزئة hashed باستخدام تجزئة أحادية الاتجاه معتمدة. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **3.6.2** | تحقق من أن أسرار البحث مقاومة للهجمات التي لا تحتاج لانترنت offline attacks ، مثل القيم المتوقعة predictable values. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## ق7.2 المدقق خارج النطاق\n\nفي الماضي ، كان المدقق خارج النطاق out of band verifier الأكثر شيوعاً هو عبارة عن بريد إلكتروني أو رسالة نصية قصيرة تحتوي على رابط إعادة تعيين كلمة المرور. يستخدم المهاجمون هذه الآلية الضعيفة لإعادة تعيين الحسابات التي لا يوجد لديهم تحكم بها، مثل الاستيلاء على حساب البريد الإلكتروني لشخص ما وإعادة استخدام أي روابط استرداد reset links تم اكتشافها. هناك طرق أفضل للتعامل مع التحقق خارج النطاق.\n\nالمصادقون الآمنون خارج النطاق Secure out of band authenticators  هم أجهزة فيزيائية يمكنها التواصل مع المدقق عبر قناة ثانوية آمنة. تشمل الأمثلة دفع الإشعارات إلى الأجهزة المحمولة. يعتبر هذا النوع من المصادقة \"شيئًا لديك\". عندما يرغب المستخدم في المصادقة ، يرسل تطبيق التحقق رسالة إلى المصادق خارج النطاق عبر اتصال بالمصادق بشكل مباشر أو غير مباشر من خلال خدمة طرف ثالث third party service. تحتوي الرسالة على رمز مصادقة (عادةً ما يكون رقمًا عشوائيًا مكونًا من ستة أرقام أو مربع حوار موافقة مشروطة modal approval dialog). ينتظر تطبيق التحقق استلام رمز المصادقة من خلال القناة الأساسية ويقارن تجزئة القيمة المستلمة بتجزئة رمز المصادقة الأصلي. إذا كانت متطابقة ، يمكن أن يفترض المدقق خارج النطاق أن المستخدم قد قام بالمصادقة.\n\nيفترض ASVS أن عددًا قليلاً فقط من المطورين سوف يطورون مصادقات جديدة خارج النطاق ، مثل دفع الإشعارات ، وبالتالي تنطبق عناصر تحكم ASVS التالية على أدوات التحقق ، مثل واجهة برمجة تطبيقات المصادقة authentication API وتطبيقات تسجيل الدخول الأحادي. في حالة تطوير مصادق جديد خارج النطاق ، يرجى الرجوع إلى NIST 800-63B &sect; 5.1.3.1.\n\nلا يتم السماح للمصادقين غير الآمنين خارج النطاق مثل البريد الإلكتروني و VOIP. مصادقة PSTN و SMS \"مقيدة\" حاليًا بواسطة NIST ويجب التوقف عن استخدامها واستخدام دفع الإشعارات أو ما شابه ذلك. إذا كنت بحاجة إلى استخدام مصادقة خارج النطاق عبر الهاتف أو الرسائل النصية القصيرة ، فيرجى الاطلاع على &sect; 5.1.3.3.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.7.2** | تحقق من أن المصادقين خارج النطاق (\"المقيدة\" في NIST)  الذين يستخدمون النص الواضح  ، مثل SMS أو PSTN ، لا يتم تقديمهم افتراضيًا ، ويتم تقديم بدائل أقوى مثل دفع الإشعارات أولاً. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | تحقق من انتهاء صلاحية المدقق خارج النطاق لطلبات المصادقة أو الرموز codes أو الرموز المميزة tokens  خارج النطاق بعد 10 دقائق. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **3.7.2** | تحقق من أن طلبات المصادقة أو الرموزcodes أو الرموز المميزة tokens  لأداة التحقق خارج النطاق قابلة للاستخدام مرة واحدة فقط ، ولطلب المصادقة الأصلي فقط. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **4.7.2** | تحقق من أن طلبات المصادقة أو الرموزcodes أو الرموز المميزة tokens  لأداة التحقق خارج النطاق قابلة للاستخدام مرة واحدة فقط ، ولطلب المصادقة الأصلي فقط. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **5.7.2** | تحقق من أن المدقق خارج النطاق يحتفظ فقط بإصدار مجزأ  من رمز المصادقة hashed version of the authentication code. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **6.7.2** | تحقق من أن رمز المصادقة الأولي يتم إنشاؤه بواسطة مولد رقم عشوائي آمن ، يحتوي على 20 بت على الأقل من الانتروبيا (عادةً ما يكفي ستة خانات عشوائية رقمية). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## ق8.2 التحقق مرة واحدة أو متعددة العوامل\n\nكلمات المرور أحادية الاستخدام (OTPs) هي رموز physical أو soft تعرض تحديًا عشوائيًا زائفًا لمرة واحدة متغير باستمرار pseudo-random one-time challenge. تجعل هذه الأجهزة التصيدphishing  (انتحال الهوية impersonation ) أمرًا صعبًا ، ولكنه ليس مستحيلًا. يعتبر هذا النوع من المصادقة \"شيئًا لديك\". تتشابه الرموز المميزة متعددة العوامل Multi-factor tokens مع رموز OTP أحادية العامل single-factor OTPs ، ولكنها تتطلب رمز PIN صالحًا أو إلغاء قفل المقاييس الحيوية biometric unlocking أو إدخال  USB (USB insertion) أو اقتران NFC (NFC pairing) أو بعض القيم الإضافية (مثل حاسبات توقيع المعاملات transaction signing calculators) ليتم إدخالها لإنشاء كلمة المرور لمرة واحدة (OTP) النهائية final OTP.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.8.2** | تحقق من أن كلمات المرور لمرة واحدة المستندة إلى الوقت  time-based OTPs لها عمر محدد قبل انتهاء صلاحيتها. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | تحقق من أن المفاتيح المتناظرة symmetric keys المستخدمة للتحقق من OTPs محمية بدرجة كبيرة ، مثل استخدام وحدة أمان للأجهزة hardware security module  أو تخزين مفاتيح يعتمد على نظام التشغيل الآمن operating system based key storage. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **3.8.2** | تحقق من استخدام خوارزميات التشفير المعتمدة في إنشاء ، وتوزيع ، والتحقق من OTPs. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **4.8.2** | تحقق من أن كلمات المرور لمرة واحدة المستندة إلى الوقت  time-based OTPs يمكن استخدامها مرة واحدة فقط خلال فترة الصلاحية. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **5.8.2** | تحقق من أنه في حالة إعادة استخدام رمز OTP متعدد العوامل المستند إلى الوقت time-based multi-factor OTP token  خلال فترة الصلاحية ، يتم تسجيله logged  ورفضه مع إرسال إشعارات آمنة إلى حامل الجهاز. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **6.8.2** | تحقق من إمكانية إبطال مولد OTP الفيزيائي أحادي العامل physical single-factor OTP generator  في حالة السرقة أو أي خسارة أخرى. تأكد من أن الإلغاء ساري المفعول على الفور عبر الجلسات التي تم تسجيل الدخول إليها ، بغض النظر عن الموقع. | | ✓ | ✓ | 613 | 5.2.1 |\n| **7.8.2** | تحقق من إمكانية إبطال مولد OTP الفيزيائي أحادي العامل physical single-factor OTP generator  في حالة السرقة أو أي خسارة أخرى. تأكد من أن الإلغاء ساري المفعول على الفور عبر الجلسات التي تم تسجيل الدخول إليها ، بغض النظر عن الموقع. | | o | ✓ | 308 | 5.2.3 |\n\n## ق9.2 التحقق من برامج وأجهزة التشفير\n\nمفاتيح أمان التشفير هي بطاقات ذكية smart cards أو مفاتيح FIDO ، حيث يتعين على المستخدم توصيل جهاز التشفير بالكمبيوتر أو إقرانه لإكمال المصادقة. يرسل المحققون تحديًا غير متكرر challenge nonce إلى أجهزة أو برامج التشفير ، ويقوم الجهاز أو البرنامج بإنشاء استجابة اعتماداً على مفتاح تشفير مخزن بشكل آمن.\n\nمتطلبات أجهزة وبرامج التشفير أحادي العامل وأجهزة وبرامج التشفير متعددة العوامل هي نفسها ، حيث يثبت التحقق من مصادق التشفير cryptographic authenticator امتلاك عامل المصادقة authentication factor.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.9.2** | تحقق من تخزين مفاتيح التشفير المستخدمة في التحقق بشكل آمن ومحمي ضد الكشف ، مثل استخدام وحدة النظام الأساسي الموثوق Trusted Platform Module (TPM) أو وحدة أمان الأجهزة Hardware Security Module (HSM)، أو خدمة نظام التشغيل التي يمكنها استخدام هذا التخزين الآمن. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | تحقق من أن التحدي غير المكرر challenge nonceيبلغ طوله 64 بت على الأقل ، وأنه فريد إحصائيًا أو فريدًا خلال فترة عمر جهاز التشفير cryptographic device. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **3.9.2** | تحقق من أن التحدي غير المكرر challenge nonceيبلغ طوله 64 بت على الأقل ، وأنه فريد إحصائيًا أو فريدًا خلال فترة عمر جهاز التشفير cryptographic device. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## ق10.2 مصادقة الخدمة\n\nلا يمكن تنفيذ اختبار الاختراق للتحقق من متطلبات هذا القسم، لذلك لا يتضمن أي متطلبات L1، ومع ذلك ، إذا تم استخدامه في معمارية أو تشفير أو مراجعة آمنة للشيفرة المصدرية، فيرجى افتراض أن البرنامج (تمامًا مثل Java Key Store) هو الحد الأدنى من المتطلبات في L1. تخزين الأسرارsecrets بشكلها الصريح غير مقبول تحت أي ظرف من الظروف.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.10.2** | لا يمكن تنفيذ اختبار الاختراق للتحقق من متطلبات هذا القسم، لذلك لا يتضمن أي متطلبات L1، ومع ذلك ، إذا تم استخدامه في معمارية أو تشفير أو مراجعة آمنة للشيفرة المصدرية، فيرجى افتراض أن البرنامج (تمامًا مثل Java Key Store) هو الحد الأدنى من المتطلبات في L1. تخزين الأسرارsecrets بشكلها الصريح غير مقبول تحت أي ظرف من الظروف. | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | تحقق من أنه إذا كانت كلمات المرور مطلوبة لمصادقة الخدمة ، فإن حساب الخدمة الذي تم استخدامه لا يمتلك بيانات اعتماد افتراضية. (على سبيل المثال ، يكون root / root أو admin / admin افتراضيًا في بعض الخدمات أثناء التثبيت). | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **3.10.2** | تحقق من تخزين كلمات المرور بحماية كافية لمنع هجمات الاسترداد في وضع عدم الاتصال بالانترنت offline recovery attacks، بما في ذلك الوصول إلى النظام المحلي. | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **4.10.2** | تحقق من إدارة كلمات المرور والتكامل مع قواعد البيانات وأنظمة الجهات الخارجية third-party systems والتوزيع  seedsوالأسرار الداخلية ومفاتيح واجهة برمجة التطبيقات  API keysبشكل آمن وتحقق من عدم تضمينها في الشيفرة المصدرية أو تخزينها في مستودعات الشيفرة المصدرية repositories. يجب أن يقاوم هذا التخزين الهجمات في وضع عدم الاتصال بالانترنت. يوصى باستخدام مخزن مفاتيح آمن للبرامج (L1) أو جهاز TPM أو HSM (L3) لتخزين كلمات المرور. | | OS assisted | HSM | 798 | |\n\n## المتطلبات الإضافية للوكالة الأمريكية\n\nالوكالات الأمريكية لديها متطلبات إلزامية بخصوص NIST 800-63. لطالما كان معيار التحقق من أمان التطبيقات يشكل حوالي 80٪ من ضوابط الأمان التي تنطبق على ما يقارب 100٪ من التطبيقات ، على خلاف الضوابط الأمنية 20٪ المتبقية والتي هي من الضوابط المتقدمة أو تلك التي لديها إمكانية تطبيق محدودة. على هذا النحو ، فإن ASVS هي مجموعة فرعية صارمة من NIST 800-63 ، خاصة لتصنيفات IAL1 / 2 و AAL1 / 2 ، ولكنها ليست شاملة بما فيه الكفاية ، لا سيما فيما يتعلق بتصنيفات IAL3 / AAL3..\n\nنحث الوكالات الحكومية الأمريكية بشدة على مراجعة وتنفيذ NIST 800-63 بالكامل.\n\n## قائمة المصطلحات\n\n| المصطلح | المعنى |\n| -- | -- |\n| CSP | Credential Service Provider يُطلق على مزود خدمة الاعتماد أيضًا اسم مزود الهوية. |\n| المصادق | Authenticator الكود البرمجي الذي يصادق على كلمة المرور والرمز المميز token و MFA والتأكيد الموحد federated assertion وما إلى ذلك. |\n| المدقق | Verifier \"كيان يتحقق من هوية المدعي عن طريق التحقق من حيازة المدعي والتحكم فيه على واحد أو اثنين من المصادقين باستخدام بروتوكول مصادقة. للقيام بذلك ، قد يحتاج المدقق أيضًا إلى التحقق من صحة بيانات الاعتماد التي تربط المصادق (المصادقين) بمعرف المشترك والتحقق وضعهم \". |\n| OTP | One-time password كلمة السر لمرة واحدة |\n| SFA | Single-factor authenticators المصادقة أحادية العامل ، مثل شيء تعرفه something you know (الأسرار المحفوظة memorized secrets ، وكلمات المرور ، وعبارات المرور passphrases ، وأرقام التعريف الشخصية PINs) ، أو شيء ما أنت عليه something you are  (القياسات الحيوية biometrics ، أو بصمات الأصابع fingerprint ، أو مسح الوجه face scans) ، أو شيء لديك something you have (رموز OTP ، جهاز تشفير cryptographic device  مثل البطاقة الذكية something you have)|\n| MFA | Multi-factor authentication مصادقة متعددة العوامل ، والتي تتضمن عاملين منفصلين أو أكثر |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:41.944960"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x12-V3-Session-management.md", "content": "# ت3: إدارة الجلسة\n\n## الهدف من ضوابط الأمان\n\nأحد المكونات الأساسية لأي تطبيق مستند إلى الويب web-based application  أو واجهة برمجة التطبيقات ذات الحالة stateful API  هو الآلية التي يتحكم بها ويحافظ على الحالة للمستخدم أو الجهاز الذي يتفاعل معها. تقوم إدارة الجلسة بتغيير بروتوكول عديم الحالة stateless protocol ليصبح ذو حالة stateful ، وهو أمر بالغ الأهمية للتمييز بين المستخدمين أو الأجهزة المختلفة.\n\nتأكد من أن التطبيق الذي تم التحقق منه يلبي المتطلبات رفيعة المستوى لإدارة الجلسة وهي:\n\n* الجلسات فريدة لكل مستخدم ولا يمكن تخمينها أو مشاركتها.\n* يتم إبطال  الجلسات invalidated  عند عدم الحاجة إليها وتنتهي مهلتها خلال فترات عدم النشاط.\n\nكما لوحظ سابقًا ، تم موائمة هذه المتطلبات لتكون مجموعة فرعية متوافقة من ضوابط NIST 800-63b المحددة ، والتي تركز على التهديدات الشائعة ونقاط ضعف المصادقة التي يتم استغلالها بشكل شائع. تم إلغاء متطلبات التحقق السابقة أو إلغاء خدعها de-duped أو موائمتها في معظم الحالات لتتماشى بشكل قوي مع الغرض من متطلبات  [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) الإلزامية.\n\n## متطلبات التحقق الأمني\n\n## ق1.3 أمان إدارة الجلسة الأساسية  Fundamental Session Management Security\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.1.3** | تحقق من أن التطبيق لا يكشف أبدًا عن الرموز المميزة للجلسة session Tokens في بارامترات الرابط URL parameters. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 ق2.3 ربط الجلسة\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.2.3** | تحقق من أن التطبيق ينشئ رمزًا مميزًا جديدًا للجلسة session token  عند مصادقة المستخدم. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **2.2.3** | تحقق من أن الرموز المميزة للجلسة session token تمتلك ما لا يقل عن 64 بتًا من الانتروبيا entropy. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | تحقق من أن التطبيق يخزن فقط الرموز المميزة للجلسة session token في المتصفح باستخدام طرق آمنة مثل ملفات تعريف الارتباط المؤمنة secured cookies  بشكل مناسب (انظر القسم 4.3) أو تخزين جلسة HTML 5 (HTML 5 session storage). | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **4.2.3** | تحقق من توليد رمز الجلسة session token باستخدام خوارزميات التشفير المعتمدة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nإن TLS أو قناة نقل آمنة أخرى secure transport channel إلزامية لإدارة الجلسة. هذا مغطى في فصل أمان الاتصالات.\n\n## ق3.3 إنهاء الجلسة\n\nتمت موائمة مهلات الجلسة Session timeouts مع NIST 800-63 ، مما يسمح بمهلة أطول للجلسة أكثر مما تسمح به معايير الأمان تقليديًا. يجب على المؤسسات مراجعة الجدول أدناه ، وإذا كان من المرغوب فيه الحصول على مهلة أطول استنادًا إلى مخاطر التطبيق ، فيجب أن تكون قيمة NIST هي الحدود العليا لمهلة الخمول للجلسة session idle timeouts.\n\nL1 في هذا السياق هي IAL1 / AAL1 ، L2 هي IAL2 / AAL3 ، L3 هي IAL3 / AAL3. بالنسبة إلى IAL2 / AAL2 و IAL3 / AAL3 ، تكون مهلة الخمول idle الأقصر هي الحد الأدنى لأوقات الخمول لتسجيل الخروج أو إعادة المصادقة لاستئناف resume الجلسة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.3.3** | تحقق من أن تسجيل الخروج وانتهاء الصلاحية يبطلان الرمز المميز للجلسة ، بحيث لا يستأنف زر الرجوع أو الطرف المعتمد المتلقين للمعلومات جلسة مصادق عليها ، بما في ذلك عبر الأطراف المعتمدة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **2.3.3** | تحقق من أن تسجيل الخروج وانتهاء الصلاحية يبطلان الرمز المميز للجلسة ، بحيث لا يستأنف زر الرجوع أو الطرف المعتمد المتلقين للمعلومات جلسة مصادق عليها ، بما في ذلك عبر الأطراف المعتمدة. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 days | 12 hours or 30 minutes of inactivity, 2FA optional | 12 hours or 15 minutes of inactivity, with 2FA | 613 | 7.2 |\n| **3.3.3** | تحقق من أن التطبيق يمنح خيار إنهاء جميع الجلسات النشطة الأخرى بعد تغيير كلمة المرور بنجاح (بما في ذلك التغيير عبر إعادة تعيين / استرداد كلمة المرور) ، وأن هذا فعال عبر التطبيق ، وتسجيل الدخول الموحد (إن وجد) ، وأي أطراف معتمدة. | | ✓ | ✓ | 613 | |\n| **4.3.3** | تحقق من أن التطبيق يمنح خيار إنهاء جميع الجلسات النشطة الأخرى بعد تغيير كلمة المرور بنجاح (بما في ذلك التغيير عبر إعادة تعيين / استرداد كلمة المرور) ، وأن هذا فعال عبر التطبيق ، وتسجيل الدخول الموحد (إن وجد) ، وأي أطراف معتمدة. | | ✓ | ✓ | 613 | 7.1 |\n\n## ق4.3 إدارة الجلسة المستندة إلى ملفات تعريف الارتباط\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.4.3** | تحقق من أن الرموز المميزة للجلسة المستندة إلى ملفات تعريف الارتباط cookie-based session tokens مفعل بها السمة \"secure\". ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **2.4.3** | تحقق من أن الرموز المميزة للجلسة المستندة إلى ملفات تعريف الارتباط cookie-based session tokens  مفعل بها السمة \"HttpOnly\". ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | تحقق من أن الرموز المميزة للجلسة المستندة إلى ملفات تعريف الارتباط cookie-based session tokens  تستخدم سمة \"SameSite\" للحد من التعرض لهجمات طلبات التزوير عبر المواقع cookie-based session tokens. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1275 | 7.1.1 |\n| **4.4.3** | تحقق من أن الرموز المميزة للجلسة المستندة إلى ملفات تعريف الارتباط cookie-based session tokens تستخدم بادئة  \"-Host__\" لذلك يتم إرسال ملفات تعريف الارتباط فقط إلى المضيف الذي قام في البداية بتعيين ملف تعريف الارتباط. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **5.4.3** | تحقق من أنه إذا تم نشر التطبيق تحت اسم نطاق مع تطبيقات أخرى تقوم بتعيين أو استخدام ملفات تعريف ارتباط الجلسة التي قد تكشف عن ملفات تعريف الارتباط للجلسة ، فقم بتعيين سمة path  في الرموز المميزة للجلسة المستندة إلى ملفات تعريف الارتباط باستخدام المسار الأكثر دقة ممكنًا. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## ق5.3 إدارة الجلسة المستندة إلى الرمز المميز\n\nتتضمن إدارة الجلسة المستندة إلى الرمز المميز مفاتيح JWT و OAuth و SAML و API. من بين هذه المفاتيح ، من المعروف أن مفاتيح API ضعيفة ويجب عدم استخدامها في كود جديد.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.5.3** | تحقق من أن التطبيق يسمح للمستخدمين بإبطال revoke رموز OAuth المميزة التي تشكل علاقات ثقة مع التطبيقات المرتبطة. | | ✓ | ✓ | 290 | 7.1.2 |\n| **2.5.3** | تحقق من أن التطبيق يستخدم الرموز المميزة للجلسة بدلاً من أسرار ومفاتيح واجهة برمجة التطبيقات الثابتة static API secrets and keys  ، باستثناء عمليات التنفيذ القديمة legacy implementations. | | ✓ | ✓ | 798 | |\n| **3.5.3** | تحقق من أن الرموز المميزة للجلسة عديمة الحالة stateless session tokens  تستخدم التوقيعات الرقمية والتشفير وغيرها من الإجراءات المضادة للحماية من هجمات التلاعب tampering ، والتغليف enveloping  ، وإعادة التشغيل reply، والتشفير الفارغ null cipher ، استبدال المفتاح key substitution. | | ✓ | ✓ | 345 | |\n\n## ق6.3 إعادة المصادقة الموحدة Federated Re-authentication\n\nيتعلق هذا القسم بأولئك الذين يكتبون الشيفرة المصدرية للطرف المعتمد Relying Party (RP) أو مزود خدمة الاعتماد Credential Service Provider (CSP). في حالة الاعتماد على التعليمات البرمجية التي تنفذ هذه الميزات ، تأكد من التعامل مع هذه المشكلات بشكل صحيح.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.6.3** | تحقق من أن الأطراف المعتمدة Relying Parties (RPs) تحدد الحد الأقصى لوقت المصادقة لمقدمي خدمات الاعتماد (CSPs) وأن CSPs يعيدون مصادقة المستخدم إذا لم يستخدموا جلسة خلال تلك الفترة. | | | ✓ | 613 | 7.2.1 |\n| **2.6.3** | تحقق من أن مقدمي خدمات الاعتماد (CSPs) يبلغون الأطراف المعتمدة (RPs) بحدث المصادقة الأخير ، للسماح لـ RPs بتحديد ما إذا كانوا بحاجة إلى إعادة مصادقة المستخدم. | | | ✓ | 613 | 7.2.1 |\n\n## ق7.3 الحماية ضد استغلالات إدارة الجلسة\n\nهناك عدد قليل من هجمات إدارة الجلسات ، بعضها يتعلق بتجربة المستخدم (UX) للجلسات. في السابق ، بناءً على متطلبات ISO 27002 ، تطلب ASVS حظر عدة جلسات متزامنة. لم يعد حظر الجلسات المتزامنة مناسبًا ، ليس فقط لأن المستخدمين الحديثين لديهم العديد من الأجهزة أو أن التطبيق عبارة عن واجهة برمجة تطبيقات بدون جلسة متصفح  API without a browser session ، ولكن في معظم هذه التطبيقات ، يفوز المصادق الأخير ، والذي غالبًا ما يكون المهاجم. يوفر هذا القسم إرشادات رائدة حول ردع وتأخير واكتشاف هجمات إدارة الجلسة باستخدام التعليمات البرمجية.\n\n### وصف الهجوم نصف المفتوح\n\nفي أوائل عام 2018 ، تم اختراق العديد من المؤسسات المالية باستخدام ما أطلق عليه المهاجمون \"هجمات نصف مفتوحة half-open attacks \". هذا المصطلح عالق في الصناعة. قام المهاجمون بضرب مؤسسات متعددة بقواعد رموز احتكارية مختلفة proprietary code bases ، ويبدو بالفعل أن قواعد كود مختلفة داخل نفس المؤسسات. يستغل الهجوم نصف المفتوح عيبًا في نمط التصميم شائعًا في العديد من أنظمة المصادقة الحالية وإدارة الجلسة والتحكم في الوصو.\n\nيبدأ المهاجمون هجومًا نصف مفتوح بمحاولة قفل بيانات الاعتماد أو إعادة تعيينها أو استردادها. يعيد نمط تصميم إدارة الجلسة الشائع استخدام كائنات / نماذج objects/models لجلسة ملف تعريف المستخدم بين غير مصادق unauthenticated، ونصف مصادق half-authenticated  (إعادة تعيين كلمة المرور ، نسيان اسم المستخدم) ، ورمز مصادق بالكامل fully authenticated code. يملأ نمط التصميم هذا كائن جلسة صالحًا أو رمزًا مميزًا يحتوي على ملف تعريف الضحية ، بما في ذلك تجزئة كلمة المرور password hashes والأدوار rules. إذا لم يتحقق التحكم في الوصول في وحدات التحكم أو أجهزة التوجيه بشكل صحيح من تسجيل المستخدم للدخول بشكل كامل ، فسيكون المهاجم قادرًا على التصرف كمستخدم. يمكن أن تشمل الهجمات تغيير كلمة مرور المستخدم إلى قيمة معروفة ، وتحديث عنوان البريد الإلكتروني لإجراء إعادة تعيين كلمة مرور صالحة ، أو تعطيل المصادقة متعددة العوامل أو تسجيل جهاز MFA جديد ، أو الكشف عن مفاتيح واجهة برمجة التطبيقات  API keys أو تغييرها ، وما إلى ذلك.\n\n| # | التوصيف | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **1.7.3** | تحقق من التطبيق يضمن جلسة تسجيل دخول كاملة وصالحة أو يتطلب إعادة المصادقة أو التحقق الثانوي قبل السماح بأي معاملات حساسة أو تعديلات على الحساب. | ✓ | ✓ | ✓ | 306 | |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:42.040202"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x12-V4-Access-Control.md", "content": "# ت4: التحكم في الوصول\n\n## الهدف من ضوابط الأمان\n\nالتفويض Authorization هو مفهوم السماح بالوصول إلى الموارد فقط لمن يُسمح لهم باستخدامها. تأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى التالية:\n\n* يمتلك الأشخاص الذين يصلون إلى الموارد بيانات اعتماد صالحة للقيام بذلك.\n* يرتبط المستخدمون بمجموعة معرفة جيداً من الأدوار والامتيازات.\n* البيانات الوصفية metadata للدور والإذن محمية من الإعادة replay أو العبثtampering .\n\n## متطلبات التحقق الأمني\n\n## ق1.4 التصميم العام للتحكم في الوصول\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.4** | تحقق من أن التطبيق يفرض قواعد التحكم في الوصول على طبقة خدمة موثوقة trusted service layer ، خاصةً إذا كان التحكم في الوصول من جانب العميل موجودًا ويمكن تجاوزه. | ✓ | ✓ | ✓ | 602 |\n| **2.1.4** | تحقق من أن جميع خصائص المستخدم attributes والبيانات ومعلومات السياسة المستخدمة بواسطة عناصر التحكم في الوصول لا يمكن التلاعب بها من قبل المستخدمين النهائيين ما لم يتم التفويض بذلك على وجه التحديد. | ✓ | ✓ | ✓ | 639 |\n| **3.1.4** | تحقق من وجود مبدأ الامتيازات الأقل least privilege - يجب أن يكون المستخدمون قادرين فقط على الوصول إلى الوظائف وملفات البيانات وعناوين URL ووحدات التحكم والخدمات والموارد الأخرى التي يمتلكون تفويضًا محددًا لها. هذا يعني الحماية ضد الانتحال spoofing ورفع الامتيازات elevation of privilege. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [تم حذفها ، مكررة عن 3.1.4] | | | | |\n| **5.1.4** | تحقق من أن ضوابط الوصول تفشل بشكل آمن بما في ذلك عند حدوث استثناء exception. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## ق2.4 التحكم في الوصول لمستوى التشغيل\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.4** | تحقق من أن البيانات الحساسة وواجهات برمجة التطبيقات محمية ضد هجمات مرجع الكائن المباشر غير الآمن Insecure Direct Object Reference (IDOR) التي تستهدف إنشاء السجلات وقراءتها وتحديثها وحذفها ، مثل إنشاء أو تحديث سجل شخص آخر أو عرض سجلات الجميع أو حذف جميع السجلات. | ✓ | ✓ | ✓ | 639 |\n| **2.2.4** | تحقق من أن التطبيق أو إطار العمل يفرض آلية قوية لمكافحة CSRF (anti-CSRF mechanism) لحماية الوظائف المصادق عليها ، وأن مكافحة الأتمتة anti-automation  الفعالة أو مكافحة CSRF تحمي الوظائف غير المصادق عليها. | ✓ | ✓ | ✓ | 352 |\n\n## ق3.4 اعتبارات أخرى للتحكم في الوصول\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.4** | تحقق من أن واجهات الإدارة تستخدم المصادقة متعددة العوامل المناسبة لمنع الاستخدام غير المصرح به. | ✓ | ✓ | ✓ | 419 |\n| **2.3.4** | تحقق من تعطيل تصفح الدليل directory browsing ما لم يكن ذلك مطلوبًا بشكل متعمد. بالإضافة إلى ذلك ، يجب ألا تسمح التطبيقات باكتشاف البيانات الوصفية metadata للملف أو المجلد أو الكشف عنها ، مثل مجلدات Thumbs.db أو .DS_Store أو .git أو .svn. | ✓ | ✓ | ✓ | 548 |\n| **3.3.4** | تحقق من أن التطبيق لديه تفويض إضافي (مثل المصادقة التكيفية أو التصعيد step up or adaptive authentication) للأنظمة الأقل أهمية lower value systems ، و / أو فصل المهام للتطبيقات عالية القيمة high value applications  لفرض ضوابط مكافحة الاحتيال anti-fraud وفقًا لمخاطر التطبيق والاحتيال السابق. | | ✓ | ✓ | 732 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:42.145321"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# ت5: التحقق من الصحة Validation والتعقيم Sanitization  والترميز Encoding\n\n## الهدف من ضوابط الأمان\n\nإن أكثر نقاط ضعف أمان تطبيقات الويب شيوعًا هي الفشل في التحقق بشكل صحيح من المدخلات الواردة Input validation  من العميل أو البيئة قبل استخدامها مباشرة دون أي ترميز للمخرجاتoutput encoding . تؤدي هذه المشكلة تقريبًا إلى جميع نقاط الضعف المهمة في تطبيقات الويب ، مثل البرمجة النصية عبر الموقع Cross-Site Scripting (XSS) ، وحقن قواعد البيانات SQL injection ، وحقن المترجم interpreter injection ، وهجمات الإعدادات المحلية / Unicode (locale/Unicode attacks)، وهجمات نظام الملفات file system attacks ، وتدفقات المخزن المؤقت buffer overflows.\n\nتأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى التالية:\n\n* التحقق من صحة المدخلات ومعمارية ترميز المخرجات output encoding architecture لهاpipeline  متفق عليه لمنع هجمات الحقن.\n* يتم كتابة بيانات المدخلات بشكل صارم strongly typed ، ويتم التحقق من صحتها ومن النطاق  range أو الطول ، أو في أسوأ الأحوال ، يتم تعقيمها sanitized أو تصفيتها filtered.\n* يتم ترميز بيانات المخرجاتencoded  أو تفعيل أحرف الهروب escaped وفقًا لسياق البيانات context of the data  بحيث تكون أقرب ما يمكن للمترجم interpreter.\n\nفي هندسة تطبيقات الويب الحديثة ، أصبح ترميز المخرجات أكثر أهمية من أي وقت مضى. من الصعب توفير التحقق القوي من صحة المدخلات في سيناريوهات معينة ، لذا فإن استخدام واجهة برمجة تطبيقات أكثر أمانًا safer API مثل الاستعلامات ذات البارامترات parameterized queries  أو إطارات عمل القوالب التلقائية auto-escaping templating frameworks أو اختيار طريقة ترميز المخرجات بعناية أمر بالغ الأهمية لأمان التطبيق.\n\n## ق1.5 التحقق من صحة المدخلات\n\nإن استخدام قوائم السماح الإيجابيةpositive allow lists  وكتابة البيانات بشكل صارم strong data typing في ضوابط التحقق من صحة المدخلات المطبقة بشكل صحيح يمكّن من القضاء على أكثر من 90٪ من جميع هجمات الحقن. يمكن لفحوصات الطول والنطاق Length and range checks أن تقلل هذا بدرجة أكبر. إن البناء باستخدام التحقق الآمن من صحة المدخلات هو مطلوب في معمارية التطبيق، وسرعة التصميم ، وكتابة الشيفرة المصدرية، واختبارات الوحدة والتكامل unit and integration testing. على الرغم من أن العديد من هذه العناصر لا يمكن العثور عليها في اختبارات الاختراق ، إلا أن نتائج عدم تنفيذها توجد عادةً في ق3.5 - متطلبات ترميز المخرجات ومنع الحقن. يوصى المطورين ومراجعي الشيفرة المصدرية الآمنة secure code reviewers بالتعامل مع هذا القسم كما لو كان L1 مطلوبًا لجميع العناصر لمنع عمليات الحقن.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.5** | تحقق من أن التطبيق لديه دفاعات ضد هجمات تلوث مدخلات HTTP (HTTP parameter pollution attacks)، خاصةً إذا كان إطار عمل التطبيق application framework  لا يميز مصدر مدخلات الطلب (GET أو POST أو ملفات تعريف الارتباط cookies أو الرؤوس headers أو متغيرات البيئة environment variables). | ✓ | ✓ | ✓ | 235 |\n| **2.1.5** | تحقق من أن إطارات العمل تحمي من هجمات تخصيص المدخلات الجماعية mass parameter assignment attacks ، أو أن التطبيق لديه إجراءات مضادة للحماية من تعيين قيم المدخلات بشكل غير آمن unsafe parameter assignment ، مثل وضع علامة على الحقول على أنها خاصة أو مشابهة marking fields private. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **3.1.5** | تأكد من التحقق من صحة جميع المدخلات (حقول نموذج HTML (HTML form fields) وطلبات REST وبارامترات URL ورؤوس HTTP وملفات تعريف الارتباط Cookies و batch files و RSS feedsوما إلى ذلك) باستخدام التحقق الإيجابي (قوائم السماح).  ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **4.1.5** | Vتحقق من أن البيانات المنظمة مكتوبة بشكل صارم وتم التحقق من صحتها مقابل مخطط schema  محدد بما في ذلك الأحرف المسموح بها والطول والنمط (مثل أرقام بطاقة الائتمان، البريد الالكتروني وأرقام الهواتف ، أو التحقق من صحة حقلين مرتبطين ، مثل التحقق من الضاحية ومطابقة الرمز البريدي).  ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | تحقق من أن عمليات إعادة التوجيه إلى الخلف وإعادة التوجيه إلى الأمام (URL redirects and forwards) لعناوين URL تسمح فقط بالوجهات التي تظهر في قائمة السماح ، أو تظهر تحذيرًا عند إعادة التوجيه إلى محتوى يحتمل أن يكون غير موثوق به. | ✓ | ✓ | ✓ | 601 |\n\n## ق2.5 التعقيم Sanitization ووضع الحماية Sandboxing\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.5** | تحقق من أن جميع مدخلات HTML غير الموثوق بها من محرري WYSIWYG أو ما شابهها قد تم تعقيمها بشكل صحيح باستخدام HTML sanitizer library  أو ميزة في إطار العمل. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **2.2.5** | تحقق من تعقيم البيانات غير المهيكلة unstructured لفرض تدابير السلامة مثل الأحرف والطول المسموح بهما. | ✓ | ✓ | ✓ | 138 |\n| **3.2.5** | تحقق من أن التطبيق يقوم بتعقيم مدخلات المستخدم قبل المرور إلى أنظمة البريد للحماية من هجمات حقن SMTP أو IMAP. | ✓ | ✓ | ✓ | 147 |\n| **4.2.5** | تحقق من أن التطبيق يتجنب استخدام ()eval أو ميزات تنفيذ التعليمات البرمجية الديناميكية الأخرى dynamic code execution features. في حالة عدم وجود بديل ، يجب تعقيم sanitized أي مدخلات للمستخدم يتم تضمينه أو استخدام وضع الحماية sandboxed له قبل تنفيذه. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | تحقق من أن التطبيق يحمي من هجمات حقن القالب template injection attacks من خلال التأكد من أن أي مدخلات للمستخدم يتم تضمينه معقم أو وضع الحماية. | ✓ | ✓ | ✓ | 94 |\n| **6.2.5** | تحقق من أن التطبيق يحمي من هجمات SSRF ، عن طريق التحقق من صحة البيانات غير الموثوق بها أو بيانات تعريف ملف HTTP (HTTP file metadata) أو تعقيمها ، مثل أسماء الملفات وحقول مدخلات عنوان URL ، واستخدام قوائم البروتوكولات والنطاقات والمسارات والمنافذ المسموح بها. | ✓ | ✓ | ✓ | 918 |\n| **7.2.5** | تحقق من أن التطبيق يقوم بتعقيم أو تعطيل أو وضع الحماية للمحتوى القابل للبرمجة Scalable Vector Graphics (SVG) الذي يوفره المستخدم ، خاصةً فيما يتعلق بـ XSS الناتج عن البرامج النصية المضمنة inline scripts و ForeignObject. | ✓ | ✓ | ✓ | 159 |\n| **8.2.5** | تحقق من أن التطبيق يقوم بتعقيم أو تعطيل أو وضع الحماية لمحتوى لغة قالب التعبير user-supplied scriptable  أو لغة قالب التعبير  expression template languageالتي يوفرها المستخدم ، مثل Markdown أو CSS أو XSL Stylesheets أو BBCode أو ما شابه ذلك. | ✓ | ✓ | ✓ | 94 |\n\n## ق3.5 ترميز المخرجات ومنع الحقن\n\nيعد ترميز المخرجات بالقرب من المترجم أو بجواره أمرًا بالغ الأهمية لأمن أي تطبيق. عادةً ، ترميز المخرجات هو غير دائم not persisted ، ولكن يتم استخدامه لجعل المخرجات آمنة في سياق المخرجات المناسب للاستخدام الفوري. سيؤدي الفشل في ترميز المخرجات إلى تطبيق غير آمن وقابل للحقن.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.5** | تحقق من أن ترميز المخرجات مناسب للمترجم والسياق المطلوب. على سبيل المثال ، استخدم المرمزات encoders خصيصًا لقيم HTML ، وسماتHTML  attributes)  (HTML  ، وJavaScript ، وبارامترات URL ، ورؤوس HTTP ، و SMTP ، وغيرها كما يتطلب السياق ، لا سيما من المدخلات غير الموثوق بها (مثل الأسماء التي تحتوي على Unicode أو الفواصل العليا ، مثل ね こ أو O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **2.3.5** | تحقق من أن ترميز المخرجات يحافظ على مجموعة الأحرف واللغة التي اختارها المستخدم، بحيث تكون أي نقطة محرف Unicode (Unicode character point) صالحة ويتم التعامل معها بأمان. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **3.3.5** | تحقق من العناية بالسياق context-aware ، ويفضل أن يكون مؤتمتًا - أو في أسوأ الأحوال ، يدويًا - يحمي من XSS المنعكس والمخزن والمستند إلى DOM (reflected, stored, and DOM based XSS). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **4.3.5** | تحقق من أن اختيار البيانات أو استعلامات قاعدة البيانات (مثل SQL و HQL و ORM و NoSQL) تستخدم الاستعلامات ذات المدخلات parameterized  أو ORMs أو أطر عمل الكيانات entity frameworks أو أن تكون محمية بطريقة أخرى من هجمات حقن قواعد البيانات. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | تحقق من أنه في حالة عدم وجود parameterized  أو تقنيات أكثر أمانًا ، يتم استخدام ترميز المخرجات الخاص بالسياق للحماية من هجمات الحقن ، مثل استخدام SQL escaping للحماية من حقن SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **6.3.5** | تحقق من أن التطبيق يحمي من هجمات حقن JSON وهجمات JSON eval وJavaScript expression evaluation. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **7.3.5** | تحقق من أن التطبيق يحمي من الثغرات الأمنية كحقن LDAP ، أو أنه يتم تنفيذ ضوابط أمان محددة لمنع حقن LDAP. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **8.3.5** | تحقق من أن التطبيق يحمي من حقن أوامر نظام التشغيل وأن استدعاءات نظام التشغيل تستخدم استعلامات نظام تشغيل ذات مدخلات parameterized OS queries  أو تستخدم ترميز إخراج سطر الأوامر السياقي contextual command line output encoding. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **9.3.5** | تحقق من أن التطبيق يحمي من هجمات تضمين الملفات المحلية Local File Inclusion (LFI)  أو تضمين الملفات عن بُعد Remote File Inclusion (RFI). | ✓ | ✓ | ✓ | 829 |\n| **1.3.5** | تحقق من أن التطبيق يحمي من حقن XPath أو هجمات حقن XML. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nملاحظة: استخدام الاستعلامات ذات المدخلات parameterized queries أو الهروب من SQL (parameterized queries) لا يكفي دائمًا ؛ لا يمكن الهروب من أسماء الجداول والأعمدة ، ORDER BY وما إلى ذلك. يؤدي تضمين البيانات التي قدمها المستخدم التي تم تجاوزها في هذه الحقول إلى فشل الاستعلامات أو حقن SQL.\n\nملاحظة: يسمح تنسيق SVG صراحةً بـ ECMA script  في جميع السياقات تقريبًا ، لذلك قد لا يكون من الممكن حظر جميع SVG XSS vectors  تمامًا. إذا كان تحميل SVG مطلوبًا ، فنحن نوصي بشدة إما بتقديم هذه الملفات التي تم تحميلها كـ text/plain أو استخدام مجال محتوى منفصل يوفره المستخدم separate user supplied content domain لمنع XSS الناجح من الاستيلاء على التطبيق.\n\n## ق4.5 الذاكرة Memory والسلسلة String والشيفرة المصدرية غير المُدارة unmanaged code\n\nسيتم تطبيق المتطلبات التالية فقط عندما يستخدم التطبيق لغة أنظمة systems language أو شيفرة مصدرية غير مُدارة unmanaged code.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.5** | تحقق من أن التطبيق يستخدم سلسلة آمنة للذاكرة memory-safe string ونسخ ذاكرة أكثر أمانًا و المؤشرpointer arithmetic  لاكتشاف أو منع stack, buffer, heap overflows. | | ✓ | ✓ | 120 |\n| **2.4.5** | تحقق من أن سلاسل التنسيق format strings  لا تأخذ مدخلات يحتمل أن تكون معادية ، وأنها ثابتة. | | ✓ | ✓ | 134 |\n| **3.4.5** | تحقق من استخدام تقنيات التحقق من صحة الإشارة والمجال والمدخلات sign, range, and input validation techniques  لمنع integer overflows.  | | ✓ | ✓ | 190 |\n\n## ق5.5 متطلبات منع فك التسلسل\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | تحقق من أن الكائنات المتسلسلة تستخدم فحوصات سلامة integrity checks أو أنها مشفرة لمنع إنشاء كائن معاد hostile object creation  أو التلاعب بالبيانات data tampering.  ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | تحقق من أن التطبيق يقيد محللات XML (XML Parsers) بشكل صحيح لاستخدام التكوين الأكثر تقييدًا restrictive configuration  وللتأكد من تعطيل الميزات غير الآمنة مثل حل الكيانات الخارجية resolving external entities لمنع هجمات XML eXternal Entity (XXE). | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | تحقق من أن فك تسلسل البيانات غير الموثوق بها يتم تجنبه أو حمايته في كل من التعليمات البرمجية المخصصة ومكتبات الجهات الخارجية (مثل محللات JSON و XML و YAML). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | تحقق من أنه عند تحليل JSON في المتصفحات أو الخلفيات المستندة إلى JavaScript ، يتم استخدام JSON.parse لتحليل مستند JSON. لا تستخدم ()eval  لتحليل JSON. | ✓ | ✓ | ✓ | 95 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nلمزيد من المعلومات حول الهروب التلقائي auto-escaping ، يرجى الاطلاع على:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nلمزيد من المعلومات حول فك التسلسل deserialization ، يرجى الاطلاع على:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:42.220730"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x14-V6-Cryptography.md", "content": "# ت6: التشفير المخزن\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى التالية:\n\n* تفشل جميع وحدات التشفير بطريقة آمنة ويتم التعامل مع الأخطاء بشكل صحيح.\n* يتم استخدام مولد رقم عشوائي مناسب.\n* تتم إدارة الوصول إلى المفاتيح بشكل آمن.\n\n## ق1.6 تصنيف البيانات\n\nأهم الأصول هي البيانات التي تتم معالجتها أو تخزينها أو نقلها بواسطة تطبيق ما. قم دائمًا بإجراء تقييم لتأثير الخصوصية privacy impact assessment لتصنيف احتياجات حماية البيانات لأي بيانات مخزنة بشكل صحيح.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.6** | تحقق من أن البيانات الخاصة المنظمة privacy impact assessment مخزنة بشكل مشفر أثناء الراحة at rest، مثل معلومات التعريف الشخصية Personally Identifiable Information (PII) أو المعلومات الشخصية الحساسة أو البيانات التي يُحتمل أن تكون خاضعة للائحة العامة لحماية البيانات (GDPR) الخاصة بالاتحاد الأوروبي EU's GDPR. | | ✓ | ✓ | 311 |\n| **2.1.6** | تحقق من أن البيانات الصحية المنظمة regulated health data  مخزنة بشكل مشفر أثناء الراحة، مثل السجلات الطبية أو تفاصيل الجهاز الطبي أو سجلات البحث مجهولة المصدر. | | ✓ | ✓ | 311 |\n| **3.1.6** | تحقق من أن البيانات المالية المنظمة regulated financial data يتم تخزينها مشفرة أثناء الراحة ، مثل الحسابات المالية أو التخلف عن السداد أو تاريخ الائتمان أو السجلات الضريبية أو سجل الدفع أو المستفيدين أو سجلات البحث أو السوق مجهولة المصدر. | | ✓ | ✓ | 311 |\n\n## ق2.6 الخوارزميات\n\nتوضح التطورات الحديثة في التشفير أن الخوارزميات وأطوال المفاتيح الآمنة سابقًا لم تعد آمنة أو كافية لحماية البيانات. لذلك ، ينبغي أن يكون من الممكن تغيير الخوارزميات. \n\nعلى الرغم من أن هذا القسم لا يتم اختباره بسهولة ، إلا أن المطورين يجب أن يعتبروا هذا القسم بأكمله إلزاميًا على الرغم من أن L1 مفقود من معظم العناصر.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.6** | تحقق من أن جميع وحدات التشفيرcryptographic modules  تفشل بشكل آمن ، وأن الأخطاء يتم معالجتها بطريقة لا تتيح هجمات Padding Oracle. | ✓ | ✓ | ✓ | 310 |\n| **2.2.6** | تحقق من استخدام خوارزميات التشفير والأنماط modes والمكتبات التي أثبتت جدواها في الصناعة أو المعتمدة من الحكومة ، بدلاً من التشفير المخصص المبرمَج custom coded cryptography. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **3.2.6** | تحقق من تكوين متجه تهيئة التشفير encryption initialization vector والنصوص المشفرة  cipher و block modes  بشكل آمن وباستخدام أحدث التوصيات. | | ✓ | ✓ | 326 |\n| **4.2.6** | تحقق من أن الأرقام العشوائية أو التشفير أو خوارزميات التجزئة أو أطوال المفاتيح أو الدورات rounds أو النصوص المشفرة ciphers أو الأنماط ، يمكن إعادة تكوينها أو ترقيتها أو تبديلها في أي وقت للحماية من فواصل التشفير cryptographic breaks. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **5.2.6** | تحقق من أنماط الكتلة غير الآمنة insecure block modes  المعروفة (مثل ECB ، وما إلى ذلك) ، وأنماط الحشو padding modes (مثل PKCS # 1 v1.5 ، وما إلى ذلك) ، وخوارزميات التشفير ذات أحجام الكتل الصغيرة ciphers with small block sizes  (مثل Triple-DES ، و Blowfish ، وما إلى ذلك) ، وخوارزميات التجزئة الضعيفة (مثل MD5 و SHA1 وما إلى ذلك) لا يتم استخدامها ما لم يكن ذلك مطلوبًا للتوافق مع الإصدارات السابقة. | | ✓ | ✓ | 326 |\n| **6.2.6** | تحقق من أن nonces ومتجهات التهيئة initialization vectors وأرقام الاستخدام الفردي الأخرى other single use numbers لا تستخدم الأرقام أكثر من مرة في مفتاح تشفير معين. يجب أن تكون طريقة التوليد مناسبة للخوارزمية المستخدمة. | | ✓ | ✓ | 326 |\n| **7.2.6** | تحقق من مصادقة البيانات المشفرة عبر التوقيعات signatures  أو أنماط التشفير المصدق عليها authenticated cipher modes أو HMAC لضمان عدم تغيير النص المشفر من قبل طرف غير مصرح له. | | | ✓ | 326 |\n| **8.2.6** | تحقق من أن جميع عمليات التشفير تتم في وقت ثابت ، مع عدم وجود عمليات \"ماس كهربائي short-circuit \" في المقارنات أو الحسابات أو القيم الراجعة returns ، لتجنب تسريب المعلومات. | | | ✓ | 385 |\n\n## ق3.6 القيم العشوائية\n\nإنه من الصعب توليد الأرقام الزائفة العشوائية الحقيقية True Pseudo-random Number Generation (PRNG) بطريقة صحيحة. بشكل عام ، المصادر الجيدة للإنتروبيا داخل النظام سوف يتم نفاذها سريعًا إذا تم الإفراط في استخدامها ، ولكن المصادر ذات العشوائية الأقل يمكن أن تؤدي إلى مفاتيح وأسرار يمكن التنبؤ بها.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.6** | تحقق من أن جميع الأرقام العشوائية وأسماء الملفات العشوائية ومعرفات GUID العشوائية والسلاسل العشوائية يتم توليدها باستخدام مولد الأرقام العشوائي الآمن المشفر المعتمد من وحدة التشفير cryptographic module's approved cryptographically secure random number generator عندما يكون الهدف هو عدم تخمين هذه القيم العشوائية من قبل المهاجم. | | ✓ | ✓ | 338 |\n| **2.3.6** | تحقق من إنشاء المعرفات الفريدة العمومية العشوائية GUIDs باستخدام خوارزمية GUID v4 ، ومولد الأرقام العشوائي الزائف الآمن Cryptographically-secure Pseudo-random Number Generator (CSPRNG). يمكن التنبؤ بمعرفات GUIDs التي تم توليدها باستخدام مولدات الأرقام العشوائية الزائفة الأخرى. | | ✓ | ✓ | 338 |\n| **3.3.6** | تحقق من إنشاء أرقام عشوائية مع الانتروبيا المناسبة حتى عندما يكون التطبيق تحت حمل ثقيل heavy load ، أو أن التطبيق يتدهور بطريقة آمنة في مثل هذه الظروف. | | | ✓ | 338 |\n\n## ق4.6 إدارة السر\n\nعلى الرغم من أن هذا القسم لا يتم اختباره بسهولة ، إلا أن المطورين يجب أن يعتبروا هذا القسم بأكمله إلزاميًا على الرغم من أن L1 مفقود من معظم العناصر.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.6** | تحقق من استخدام حل إدارة الأسرار secrets management solution  مثل خزنة المفاتيح لإنشاء الأسرار وتخزينها والتحكم في الوصول إليها وتدميرها بشكل آمن. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **2.4.6** | تحقق من عدم تعرض المادة الرئيسية للتطبيق ولكن بدلاً من ذلك تستخدم وحدة أمان معزولة مثل vault لعمليات التشفير. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:42.348872"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x15-V7-Error-Logging.md", "content": "# ت7: التسجيل ومعالجة الخطأ\n\n## الهدف من ضوابط الأمان\n\nالهدف الأساسي من معالجة الأخطاء error handling والتسجيل logging هو توفير معلومات مفيدة للمستخدم والمسؤولين وفرق الاستجابة للحوادث. ليس الهدف هو الحصول على كميات هائلة من السجلات ، ولكن سجلات عالية الجودة تتضمن معلومات مفيدة وبارزة.\n\nغالبًا ما تحتوي السجلات عالية الجودة على بيانات حساسة ، ويجب حمايتها وفقًا لقوانين أو توجيهات خصوصية البيانات المحلية. يجب أن يشمل ذلك:\n\n* عدم جمع أو تسجيل المعلومات الحساسة ما لم يكن ذلك مطلوبًا على وجه التحديد.\n* التأكد من التعامل مع جميع المعلومات المسجلة بشكل آمن ومحمي وفقًا لتصنيف البيانات الخاص بها.\n* ضمان عدم تخزين السجلات إلى الأبد ، ولكن لها عمر مطلق أقصر ما يمكن.\n\nإذا كانت السجلات تحتوي على بيانات خاصة أو حساسة ، يختلف تعريفها من بلد إلى آخر ، فإن السجلات تصبح من أكثر المعلومات حساسية التي يحتفظ بها التطبيق وبالتالي جذابة للغاية للمهاجمين في حد ذاتها.\n\nمن المهم أيضًا التأكد من فشل التطبيق بشكل آمن وأن الأخطاء لا تكشف عن معلومات غير ضرورية.\n\n## ق1.7 محتوى السجل\n\nيعد تسجيل المعلومات الحساسة أمرًا خطيرًا - حيث يتم تصنيف السجلات بنفسها ، مما يعني ضرورة تشفيرها وإخضاعها لسياسات الاحتفاظ ويجب الكشف عنها في عمليات تدقيق الأمان. تأكد من الاحتفاظ بالمعلومات الضرورية فقط في السجلات ، وبالتأكيد لا توجد عمليات دفع أو بيانات اعتماد (بما في ذلك الرموز المميزة للجلسة) أو معلومات حساسة أو معلومات شخصية.\n\nإن ق1.7 يغطي OWASP Top 10 2017:A10. وكلا القسمين غير قابلين لاختبار الاختراق ، فهو مهم من أجل:\n\n* ضمان امتثال المطورين الكامل لهذا القسم ، كما لو تم تعيين جميع العناصر على أنها L1.\n* تحقق مختبرو الاختراق من الامتثال الكامل لجميع العناصر في ق1.7 عبر المقابلة أو لقطات الشاشة أو التأكيد assertion.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.7** | تحقق من أن التطبيق لا يسجل بيانات الاعتماد أو تفاصيل عمليات الدفع. يجب تخزين الرموز المميزة للجلسة فقط في السجلات في شكل مجزأ hashed بطريقة لا يمكن الرجوع فيها irreversible. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **2.1.7** | تحقق من أن التطبيق لا يسجل بيانات حساسة أخرى على النحو المحدد بموجب قوانين الخصوصية المحلية أو سياسة الأمان ذات الصلة. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **3.1.7** | تحقق من أن التطبيق يسجل الأحداث المتعلقة بالأمان بما في ذلك أحداث المصادقة الناجحة والفاشلة وفشل التحكم في الوصول وفشل إلغاء التسلسل وفشل التحقق من صحة المدخلات. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **4.1.7** |تحقق من أن كل سجل حدث log event  يتضمن المعلومات الضرورية التي من شأنها أن تسمح بإجراء تحقيق مفصل للجدول الزمني عند وقوع الحدث. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## ق2.7 معالجة السجل\n\nيعد التسجيل في الوقت المناسب أمرًا بالغ الأهمية لأحداث التدقيق والفرز triage والتصعيد escalation. تأكد من أن سجلات التطبيق واضحة ويمكن مراقبتها وتحليلها بسهولة إما محليًا أو يتم إرسالها إلى نظام مراقبة عن بُعد remote monitoring system.\n\nإن ق2.7 يغطي OWASP Top 10 2017:A10. As 2017:A10. وكلا القسمين غير قابلين لاختبار الاختراق ، فهو مهم من أجل:\n\n* ضمان امتثال المطورين الكامل لهذا القسم ، كما لو تم تعيين جميع العناصر على أنها L1.\n* تحقق مختبرو الاختراق من الامتثال الكامل لجميع العناصر في ق1.7 عبر المقابلة أو لقطات الشاشة أو التأكيد assertion.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.7** | تحقق من تسجيل جميع قرارات المصادقة authentication decisions ، دون تخزين الرموز المميزة للجلسة أو كلمات المرور الحساسة. يجب أن يتضمن ذلك الطلبات مع الـ metadata ذات الصلة اللازمة للتحقيقات الأمنية security investigations. | | ✓ | ✓ | 778 |\n| **2.2.7** | تحقق من إمكانية تسجيل جميع قرارات التحكم في الوصول وتسجيل جميع القرارات الفاشلة. يجب أن يتضمن ذلك الطلبات مع الـ metadata ذات الصلة اللازمة للتحقيقات الأمنية. | | ✓ | ✓ | 285 |\n\n## ق3.7 متطلبات حماية السجل\n\nالسجلات التي يمكن تعديلها أو حذفها بشكل طفيف لا تفيد في التحقيقات والملاحقات القضائية. قد يؤدي الكشف عن السجلات إلى كشف التفاصيل الداخلية حول التطبيق أو البيانات التي يحتوي عليها. يجب توخي الحذر عند حماية السجلات من الكشف أو التعديل أو الحذف غير المصرح به.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.7** | تحقق من أن جميع مكونات التسجيل تقوم بترميز البيانات بشكل مناسب لمنع حقن السجل. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **2.3.7** | [تم حذفها ، مكررة عن 1.3.7] | | | | |\n| **3.3.7** | تحقق من أن سجلات الأمان محمية من الوصول والتعديل غير المصرح به. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **4.3.7** | تحقق من مزامنة مصادر الوقت  time sourcesمع الوقت والمنطقة الزمنية الصحيحة. ضع في اعتبارك وبشكل صارم التسجيل في التوقيت العالمي المنسق فقط إذا كانت الأنظمة عالمية للمساعدة في تحليل الأدلة الرقمية بعد الحادث. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nملاحظة: من الصعب اختبار ومراجعة ترميز السجل (1.3.7) باستخدام أدوات ديناميكية آلية واختبارات الاختراق ، ولكن يجب على مهندسي المعمارية والمطورين ومراجعي الشيفرة المصدرية اعتباره من متطلبات المستوى 1.\n\n## ق4.7 معالجة الأخطاء\n\nالغرض من معالجة الأخطاء هو السماح للتطبيق بتوفير الأحداث الأمنية ذات الصلة للمراقبة والفرز traige والتصعيد. ليس الغرض هو توليد سجلات. عند تسجيل الأحداث المتعلقة بالأمان ، تأكد من تحقق الغاية من وجود السجل ، وأنه يمكن تمييزه بواسطة SIEM أو برامج التحليل.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.7** | تحقق من ظهور رسالة عامة عند حدوث خطأ غير متوقع أو حساس للأمان ، من المحتمل أن يكون بمعرف فريد يمكن لموظفي الدعم استخدامه للتحقيق. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **2.4.7** | تحقق من ظهور رسالة عامة عند حدوث خطأ غير متوقع أو حساس للأمان ، من المحتمل أن يكون بمعرف فريد يمكن لموظفي الدعم استخدامه للتحقيق. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **3.4.7** | تحقق من تعريف معالج الأخطاء \"الملاذ الأخير last resort\" والذي سيلتقط كافة الاستثناءات التي لم تتم معالجتها. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nملاحظة: لا تدعم لغات معينة ، مثل Swift و Go - ومن خلال ممارسة التصميم الشائعة - والعديد من اللغات الوظيفية ، الاستثناءات أو معالجات أحداث الملاذ الأخير last resort. في هذه الحالة ، يجب على مهندسي المعمارية والمطورين استخدام نمط أو لغة أو طريقة مريحة لإطار العمل لضمان أن التطبيقات يمكنها التعامل بأمان مع الأحداث الاستثنائية أو غير المتوقعة أو المتعلقة بالأمان.\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:42.463806"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x16-V8-Data-Protection.md", "content": "# ت8: حماية البيانات\n\n## الهدف من ضوابط الأمان\n\nهناك ثلاثة عناصر رئيسية لحماية البيانات: السرية والنزاهة والتوافر Confidentiality, Integrity and Availability (CIA). يفترض هذا المعيار أن حماية البيانات يتم فرضها على نظام موثوق به ، مثل الخادم ، الذي تم تعزيزه ولديه إجراءات حماية كافية.\n\nيجب أن تفترض التطبيقات أن جميع أجهزة المستخدم قد تعرضت للاختراق بطريقة ما. عندما ينقل أحد التطبيقات أو يخزن معلومات حساسة على أجهزة غير آمنة ، مثل أجهزة الكمبيوتر والهواتف والأجهزة اللوحية المشتركة ، يكون التطبيق مسؤولاً عن ضمان تشفير البيانات المخزنة على هذه الأجهزة ولا يمكن الحصول عليها بسهولة أو تغييرها أو الكشف عنها بشكل غير مشروع.\n\nتأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى لحماية البيانات التالية:\n\n* السرية Confidentiality: يجب حماية البيانات من المراقبة أو الإفصاح غير المصرح به سواء أثناء النقل أو عند التخزين.\n* النزاهة Integrity: يجب حماية البيانات من أن يتم إنشاؤها بشكل ضار أو تغييرها أو حذفها من قبل مهاجمين غير مصرح لهم.\n* التوافر Availability: يجب أن تكون البيانات متاحة للمستخدمين المصرح لهم حسب الحاجة.\n\n## ق1.8 حماية البيانات العامة\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.8** | تحقق من أن التطبيق يحمي البيانات الحساسة من التخزين المؤقت cached في مكونات الخادم مثل موازنات التحميل load balancers وذاكرة التخزين المؤقت للتطبيق application caches. | | ✓ | ✓ | 524 |\n| **2.1.8** | تحقق من أن جميع النسخ المخزنة أو المؤقتة cached or temporary  للبيانات الحساسة الموجودة على الخادم محمية من الوصول غير المصرح به أو تم إزالتها / إبطالها بعد وصول المستخدم المصرح له إلى البيانات الحساسة. | | ✓ | ✓ | 524 |\n| **3.1.8** | تحقق من أن التطبيق يقلل من عدد البارامترات في الطلب ، مثل الحقول المخفية hidden fields ومتغيرات Ajax (Ajax variables) وقيم ملفات تعريف الارتباط cookies  والرؤوس headers. | | ✓ | ✓ | 233 |\n| **4.1.8** | تحقق من أن التطبيق يمكنه الاكتشاف والتنبيه عن عدد غير طبيعي من الطلبات abnormal numbers of requests ، كالكشف من خلال الـ IP أو المستخدم أو إجمالي الطلبات في الساعة أو اليوم أو أي نشاط غير طبيعي في التطبيق. | | ✓ | ✓ | 770 |\n| **5.1.8** | تحقق من إجراء نسخ احتياطية بشكل منتظم للبيانات الهامة وإجراء اختبار استعادة البيانات. | | | ✓ | 19 |\n| **6.1.8** | تحقق من تخزين النسخ الاحتياطية بشكل آمن لمنع سرقة البيانات أو تلفها. | | | ✓ | 19 |\n\n## ق2.8 حماية البيانات من جهة المستخدم\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.8** | تحقق من أن التطبيق يضبط رؤوسًا كافية لمكافحة التخزين المؤقت anti-caching headers  بحيث لا يتم تخزين البيانات الحساسة مؤقتًا في المتصفحات الحديثة. | ✓ | ✓ | ✓ | 525 |\n| **2.2.8** | تحقق من أن البيانات المخزنة في تخزين المتصفحbrowser storage  (مثل التخزين المحلي (local storage) أو تخزين الجلسة session storage أو قاعدة بيانات مفهرسة IndexedDB أو ملفات تعريف الارتباط cookies) لا تحتوي على بيانات حساسة أو معلومات تحديد الهوية الشخصية Personal Identifiable Information (PII) . | ✓ | ✓ | ✓ | 922 |\n| **3.2.8** | تحقق من مسح البيانات المصادق عليها من تخزين العميل client storage ، مثل متصفح DOM (browser DOM) ، بعد الإنهاء من جهة العميل أو إنهاء الجلسة. | ✓ | ✓ | ✓ | 922 |\n\n## ق3.8 البيانات الخاصة الحساسة\n\nيساعد هذا القسم في حماية البيانات الحساسة من الإنشاء أو القراءة أو التحديث أو الحذف دون إذن ، لا سيما في الكميات الكبيرة bulk quantities.\n\nالامتثال لهذا القسم يعني الامتثال لـ ت4: التحكم بالوصول ، وعلى وجه الخصوص ق2.4. على سبيل المثال ، للحماية من التحديثات غير المصرح بها أو الكشف عن المعلومات الشخصية الحساسة يتطلب الالتزام بـ م1.2.4. يرجى الالتزام بهذا القسم و ت4 للتغطية الكاملة.\n\nملاحظة: تؤثر لوائح وقوانين الخصوصية ، مثل مبادئ الخصوصية الأسترالية APP-11 أو GDPR ، بشكل مباشر على كيفية تعامل التطبيقات مع تنفيذ تخزين المعلومات الشخصية الحساسة واستخدامها ونقلها. إن هذا يتراوح من عقوبات شديدة إلى نصيحة بسيطة. يرجى الرجوع إلى القوانين واللوائح المحلية الخاصة بك ، واستشارة متخصص أو محامي خصوصية مؤهل حسب الحاجة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.8** | تحقق من إرسال البيانات الحساسة إلى الخادم في نص أو رؤوس رسالة HTTP (HTTP message body or headers)، وأن بارامترات سلسلة الاستعلام query string parameters  من أي طريقة HTTP (HTTP verb) لا تحتوي على بيانات حساسة. | ✓ | ✓ | ✓ | 319 |\n| **2.3.8** | تحقق من أن المستخدمين لديهم طريقة لإزالة أو تصدير بياناتهم عند الطلب. | ✓ | ✓ | ✓ | 212 |\n| **3.3.8** | تحقق من أن المستخدمين يتم تزويدهم بلغة واضحة فيما يتعلق بجمع واستخدام المعلومات الشخصية المقدمة وأن المستخدمين قد قدموا موافقة الاشتراك opt-in consent لاستخدام تلك البيانات قبل استخدامها بأي شكل من الأشكال. | ✓ | ✓ | ✓ | 285 |\n| **4.3.8** | تحقق من تحديد جميع البيانات الحساسة التي تم إنشاؤها ومعالجتها بواسطة التطبيق ، وتأكد من وجود سياسة حول كيفية التعامل مع البيانات الحساسة. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **5.3.8** | تحقق من تدقيق الوصول إلى البيانات الحساسة (دون تسجيل البيانات الحساسة نفسها) ، إذا تم جمع البيانات بموجب توجيهات حماية البيانات ذات الصلة data protection directives أو عندما يكون تسجيل الوصول مطلوبًا. | | ✓ | ✓ | 532 |\n| **6.3.8** | تحقق من الكتابة فوق (overwritten) المعلومات الحساسة الموجودة في الذاكرة بمجرد عدم الحاجة إليها للتخفيف من هجمات تفريغ الذاكرة memory dumping attacks ، باستخدام الأصفار zeroes أو البيانات العشوائية. | | ✓ | ✓ | 226 |\n| **7.3.8** | تحقق من أن المعلومات الحساسة أو الخاصة المطلوب تشفيرها مشفرة باستخدام خوارزميات معتمدة توفر السرية والنزاهة.  ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | تحقق من أن المعلومات الشخصية الحساسة تخضع لتصنيف الاحتفاظ بالبيانات data retention classification ، مثل حذف البيانات القديمة أو المنتهية صلاحيتها تلقائيًا ، وفقًا لجدول زمني ، أو حسب ما يتطلبه الموقف. | | ✓ | ✓ | 285 |\n\nعند التفكير في حماية البيانات ، يجب أن يكون الاعتبار الأساسي حول الاستخراج أو التعديل بالجملة bulk extraction or modification  أو الاستخدام المفرط excessive usage. على سبيل المثال ، تسمح العديد من أنظمة الوسائط الاجتماعية للمستخدمين فقط بإضافة 100 صديق جديد يوميًا ، ولكن النظام الذي تأتي منه هذه الطلبات ليس مهمًا. قد ترغب منصة مصرفية في حظر أكثر من 5 معاملات في الساعة لتحويل أكثر من 1000 يورو من الأموال إلى مؤسسات خارجية. من المحتمل أن تكون متطلبات كل نظام مختلفة تمامًا ، لذا فإن اتخاذ قرار بشأن \"غير طبيعي abnormal \" يجب أن يأخذ في الاعتبار نموذج التهديد ومخاطر العمل. المعايير المهمة هي القدرة على اكتشاف ، أو ردع ، أو منع (وهو الأفضل) مثل هذه الإجراءات غير الطبيعية بالجملة abnormal bulk actions.\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:42.587083"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x17-V9-Communications.md", "content": "# ت9: الاتصالات\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه يحقق المتطلبات عالية المستوى التالية:\n\n* فرض TLS أو تشفير قوي ، بغض النظر عن حساسية المحتوى.\n* اتبع أحدث الإرشادات ، بما في ذلك:\n  * إرشادات التكوين.\n  * الخوارزميات المفضلة.\n* تجنب الخوارزميات الضعيفة أو التي سيتم إهمالها قريبًا ، إلا كملاذ أخير (في حال عدم وجود حل بديل).\n* تعطيل الخوارزميات المهملة أو المعروفة غير الآمنة.\n\nوتحقق من تضمين المتطلبات التالية:\n\n* كن على اطلاع دائم بنصائح الصناعة الموصى بها بشأن تكوين TLS الآمن ، حيث يتغير كثيرًا (غالبًا بسبب الانقطاعات الكارثية في الخوارزميات والنصوص المشفرة ciphers الموجودة).\n* كن على اطلاع دائم بنصائح الصناعة الموصى بها بشأن تكوين TLS الآمن ، حيث يتغير كثيرًا (غالبًا بسبب الانقطاعات الكارثية في الخوارزميات والنصوص المشفرة ciphers الموجودة).\n* تحقق من التكوين الخاص بك بشكل دوري للتأكد من أن الاتصال الآمن موجود دائمًا وفعال.\n\n## ق1.9 أمان اتصالات العميل\n\nتأكد من إرسال جميع رسائل العميل عبر شبكات مشفرة ، باستخدام TLS 1.2 أو أحدث.\nاستخدم أدوات محدثة لمراجعة تكوين العميل على أساس منتظم.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.9** | تحقق من استخدام TLS لجميع اتصالات العميل ، ولا يعود fall back  إلى الاتصالات غير الآمنة أو غير المشفرة. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **2.1.9** | تحقق من استخدام أدوات اختبار TLS المحدثَة والتي تقوم بتمكين مجموعة الخوارزميات القويةcipher suites  فقط، مع تعيين مجموعة الخوارزميات القوية على أنها المفضلة. | ✓ | ✓ | ✓ | 326 |\n| **3.1.9** | تحقق من تفعيل آخر إصدار موصى به فقط من من بروتوكول TLS والخوارزميات والتكوين ، مثل TLS 1.2 و TLS 1.3. يجب أن يكون أحدث إصدار من بروتوكول TLS هو الخيار المفضل. | ✓ | ✓ | ✓ | 326 |\n\n## ق2.9 أمان اتصالات المخدم\n\nاتصالات الخادم Server communications هي أكثر من مجرد HTTP. يجب أن تكون الاتصالات الآمنة من وإلى الأنظمة الأخرى ، مثل أنظمة المراقبة ، وأدوات الإدارة ، والوصول عن بُعد remote access و SSH ، والبرمجيات الوسيطة middleware ، وقاعدة البيانات ، والحواسيب المركزية mainframes ، وأنظمة الشريك أو المصدر الخارجي partner or external source systems  - في مكانها الصحيح. كل هذه الأشياء يجب أن تكون مشفرة لمنع \"من الصعب من الخارج ، ومن السهل للغاية اعتراضها من الداخل hard on the outside, trivially easy to intercept on the inside \".\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.9** | تحقق من أن الاتصالات من وإلى الخادم تستخدم شهادات TLS الموثوقة. عند استخدام الشهادات التي تم توليدها داخليًا internally generated  أو الموقعة ذاتيًا self-signed ، يجب تكوين الخادم بحيث يثق فقط في المراجع المصدقة الداخلية internal CAs والشهادات الموقعة ذاتيًا self-signed certificates والتي تم تحديدها ويجب رفض كل الآخرين. | | ✓ | ✓ | 295 |\n| **2.2.9** | تحقق من استخدام الاتصالات المشفرة مثل TLS لجميع الاتصالات الواردة والصادرة ، بما في ذلك اتصالات منافذ الإدارة ، والمراقبة ، والمصادقة ، و API ، أو استدعاء خدمة الويب web service calls ، وقاعدة البيانات ، والسحابة ، serverless ، والحاسوب المركزي mainframe ، والخارجية واتصالات الشركاء partner connections. يجب ألا يعود fall back الخادم إلى البروتوكولات غير الآمنة أو غير المشفرة. | | ✓ | ✓ | 319 |\n| **3.2.9** | تحقق من مصادقة جميع الاتصالات المشفرة بالأنظمة الخارجية التي تتضمن معلومات أو وظائف حساسة. | | ✓ | ✓ | 287 |\n| **4.2.9** | تحقق من تمكين وتكوين إبطال الشهادة المناسبة ، مثل تدبيس بروتوكول حالة الشهادة عبر الإنترنت Online Certificate Status Protocol (OCSP) Stapling. | | ✓ | ✓ | 299 |\n| **5.2.9** | تحقق من تسجيل حالات فشل اتصال TLS من جهة الخادم. | | | ✓ | 544 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* ملاحظات حول \"أنماط TLS المعتمدة\":\n    * في الماضي ، أشارت ASVS إلى المعيار الأمريكي FIPS 140-2 ، ولكن كمعيار عالمي ، قد يكون تطبيق المعايير الأمريكية صعبًا أو متناقضًا أو محيرًا للتطبيق. \n    * تتمثل الطريقة الأفضل لتحقيق التوافق مع القسم 9.1 في مراجعة الأدلة مثل  [TLS من جانب الخادم من Mozilla (Mozilla's Server Side TLS)](https://wiki.mozilla.org/Security/Server_Side_TLS) أو [إنشاء تكوينات جيدة معروفة (generate known good configurations)](https://mozilla.github.io/server-side-tls/ssl-config-generator/)، واستخدام أدوات تقييم TLS محدثة ومعروفة للحصول على المستوى المطلوب من الأمان.\n", "timestamp": "2025-10-24T11:39:42.683608"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x18-V10-Malicious.md", "content": "# ت10: الشيفرة الضارة  Malicious Code\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن الشيفرة المصدرية تلبي المتطلبات عالية المستوى التالية:\n\n* يتم التعامل مع الأنشطة الضارة بأمان وبشكل صحيح حتى لا تؤثر على بقية أنشطة التطبيق.\n* لا تحتوي على قنابل موقوتة زمنية time bombs  أو هجمات أخرى على أساس زمني time-based attacks.\n* لا تقوم بالاتصال بوجهات خبيثة أو غير مصرح بها \"phone home\" to malicious or unauthorized destinations.\n* لا يحتوي على أبواب خلفية back doors ، أو بيض عيد الفصح Easter eggs ، أو هجمات salami ، أو rootkits ، أو شيفرة مصدرية غير مصرح بها يمكن للمهاجم التحكم فيه.\n\nالعثور على الشيفرة البرمجية الضارة هو حكم خاطئ Proof of negative، ويستحيل التحقق من صحته تمامًا. يجب بذل أفضل الجهود لضمان عدم احتواء الشيفرة المصدرية على تعليمات برمجية ضارة أو وظائف غير مرغوب فيها.\n\n## ق1.10 سلامة الشيفرة المصدري\n\nأفضل دفاع ضد التعليمات البرمجية الضارة هو \"كن واثقاً، ولكن تحقق trust, but verify \". غالبًا ما يكون إدخال تعليمات برمجية ضارة أو غير مصرح بها في التعليمات البرمجية جريمة جنائية في العديد من الولايات القضائية. يجب أن توضَح السياسات والإجراءات كل العقوبات المتعلقة بالشيفرات المصدرية الخبيثة.\n\nيجب على المطورين الرئيسيين مراجعة عمليات التحقق من التعليمات البرمجية code check-ins  بانتظام ، خاصة تلك التي قد تصل إلى وظائف الوقت أو المدخلات / المخرجات أو الشبكة time, I/O, or network functions.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.10** | تحقق من استخدام أداة تحليل التعليمات البرمجية التي يمكنها اكتشاف التعليمات البرمجية التي يُحتمل أن تكون ضارة ، مثل وظائف الوقت وعمليات الملفات غير الآمنة واتصالات الشبكة. | | | ✓ | 749 |\n\n## ق10.2 البحث عن الشيفرة المصدرية\n\nالشيفرة الخبيثة نادرة للغاية ويصعب اكتشافها. يمكن أن تساعد المراجعة اليدوية للشيفرة المصدرية سطرًا بسطر في البحث عن القنابل المنطقية logical bombs، ولكن حتى مراجعي الكود الأكثر خبرة سيبذلوا جهداً كبيراً ويعانوا للعثور على تعليمات برمجية ضارة حتى لو كانوا يعلمون بوجودها.\n\nلا يمكن الالتزام بهذا القسم بدون الوصول الكامل إلى الشيفرة المصدرية ، بما في ذلك المكتبات الخارجية third-party libraries.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.10** | تحقق من أن الشيفرة المصدرية للتطبيق والمكتبات الخارجية لا تحتوي على إمكانات جمع البيانات أو الاتصال الهاتفي غير المصرح به unauthorized phone home . في حالة وجود هذه الوظيفة ، يجب الحصول على إذن المستخدم لتشغيلها قبل جمع أي بيانات. | | ✓ | ✓ | 359 |\n| **2.2.10** | تحقق من أن التطبيق لا يطلب أذونات غير ضرورية أو مفرطة للميزات أو المستشعرات المتعلقة بالخصوصية ، مثل جهات الاتصال أو الكاميرات أو الميكروفونات أو الموقع. | | ✓ | ✓ | 272 |\n| **3.2.10** | تحقق من أن الشيفرة المصدرية للتطبيق والمكتبات الخارجية لا تحتوي على أبواب خلفية Backdoors، مثل الحسابات أو المفاتيح المكتوبة داخل الشيفرة المصدرية hard-coded أو الإضافية غير الموثقة ، أو تمويه الشيفرة المصدرية code obfuscation ، أو undocumented binary blobs ، أو rootkits، أو ميزات تصحيح الأخطاء غير الآمنة  insecure debugging أو مكافحة التصحيح anti-debugging ، أو وظائف غير آمنة أو مخفية أو منتهية الصلاحية والتي يمكن استخدامها بشكل ضار إذا تم اكتشافها. | | | ✓ | 507 |\n| **4.2.10** | تحقق من أن الشيفرة المصدرية للتطبيق والمكتبات الخارجية لا تحتوي على قنابل موقوتة time bombs من خلال البحث عن الوظائف ذات الصلة بالتاريخ والوقت. | | | ✓ | 511 |\n| **5.2.10** | تحقق من أن الشيفرة المصدرية للتطبيق والمكتبات الخارجية لا تحتوي على شيفرة مصدرية ضارة ، مثل هجمات salami أو التجاوزات المنطقية logic bypasses أو القنابل المنطقية logic bombs. | | | ✓ | 511 |\n| **6.2.10** | تحقق من أن الشيفرة المصدرية للتطبيق والمكتبات الخارجية لا تحتوي على بيض عيد الفصح Easter eggs أو أي وظائف أخرى يحتمل أن تكون غير مرغوب فيها. | | | ✓ | 507 |\n\n## ق10.3 سلامة التطبيق\n\nبمجرد نشر التطبيق ، لا يزال من الممكن تضمين الشيفرة المصدرية الضارة. تحتاج التطبيقات إلى حماية نفسها من الهجمات الشائعة ، مثل تنفيذ تعليمات برمجية غير موقعة من مصادر غير موثوقة executing unsigned code from untrusted sources  وعمليات الاستحواذ على النطاق الفرعي subdomain takeovers.\n\nمن المحتمل أن يكون الامتثال لهذا القسم تشغيليًا ومستمرًا.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.10** | تحقق من أنه إذا كان التطبيق يحتوي على ميزة التحديث التلقائي للعميل أو الخادم ، فيجب الحصول على التحديثات عبر القنوات الآمنة وتوقيعها رقميًا. يجب أن يتحقق رمز التحديث من صحة التوقيع الرقمي للتحديث قبل تثبيت التحديث أو تنفيذه. | ✓ | ✓ | ✓ | 16 |\n| **2.3.10** | تحقق من أن التطبيق يستخدم وسائل حماية السلامة integrity protections ، مثل توقيع الشيفرة المصدريةcode signing  أو سلامة المصدر الفرعي subresource integrity. يجب ألا يقوم التطبيق بتحميل أو تنفيذ تعليمات برمجية من مصادر غير موثوق بها ، مثل تحميل تضمينات includes، أو وحدات modules، أو مكونات إضافية plugins ، أو شيفرة مصدرية ، أو مكتبات من مصادر غير موثوق بها أو من الإنترنت. | ✓ | ✓ | ✓ | 353 |\n| **3.3.10** | تحقق من أن التطبيق يتمتع بالحماية من عمليات الاستحواذ على النطاق الفرعي subdomain takeovers  إذا كان التطبيق يعتمد على إدخالات DNS (DNS Entries) أو نطاقات DNS الفرعية (DNS Subdomains)، مثل أسماء المجال منتهية الصلاحية ، أو مؤشرات DNS أو CNAMEs القديمة ، أو المشاريع منتهية الصلاحية في مستودع الشيفرة المصدرية العام public source code repos ، أو واجهات برمجة التطبيقات السحابية العابرة transient cloud APIs ، أو وظائف بدون خادم serverless functions ، أو دلاء التخزين storage buckets  (autogen-bucket-id.cloud.example.com) أو ما شابه ذلك. يمكن أن تشمل الحماية التأكد من أن أسماء DNS التي تستخدمها التطبيقات يتم فحصها بانتظام من أجل انتهاء الصلاحية أو التغيير. | ✓ | ✓ | ✓ | 350 |\n\n## المراجع\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:42.788062"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x19-V11-BusLogic.md", "content": "# ت11: منطق الأعمال\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى التالية:\n\n* تدفق منطق الأعمال متسلسل ومعالج بالترتيب ولا يمكن تجاوزه.\n* يتضمن منطق الأعمال حدودًا لاكتشاف ومنع الهجمات الآلية ، مثل التحويلات المستمرة للأموال الصغيرة ، أو إضافة مليون صديق واحدًا تلو الآخر ، وما إلى ذلك.\n* تدفقات منطق الأعمال ذات القيمة العالية تأخذ بعين الاعتبار حالات الإساءة abuse cases والجهات الفاعلة الخبيثة ، ولديها وسائل حماية ضد الانتحال spoofing  والعبث tampering  والكشف عن المعلومات information disclosure  ورفع مستوى هجمات الصلاحيات elevation of privilege attacks.\n\n## ق1.11 أمان منطق الأعمال\n\nيعتبر أمن منطق الأعمال فرديًا جدًا لكل تطبيق بحيث لن يتم تطبيق قائمة تحقق واحدة على الإطلاق. يجب تصميم أمان منطق الأعمال للحماية من التهديدات الخارجية المحتملة - لا يمكن إضافته باستخدام جدران حماية تطبيقات الويب أو الاتصالات الآمنة. نوصي باستخدام نمذجة التهديد threat modeling  أثناء سباقات التصميم design sprints ، على سبيل المثال باستخدام OWASP Cornucopia أو أدوات مماثلة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.11** | تحقق من أن التطبيق سيعالج فقط تدفقات منطق الأعمال لنفس المستخدم بترتيب خطوات متسلسل وبدون تخطي الخطوات. | ✓ | ✓ | ✓ | 841 |\n| **2.1.11** | تحقق من أن التطبيق سيعالج تدفقات منطق الأعمال فقط مع معالجة جميع الخطوات في وقت بشري واقعي ، أي لا يتم إرسال المعامَلات transactions بسرعة كبيرة.| ✓ | ✓ | ✓ | 799 |\n| **3.1.11** | تحقق من أن التطبيق لديه حدود مناسبة لإجراءات أو معاملات transactions تجارية معينة يتم فرضها بشكل صحيح على أساس كل مستخدم. | ✓ | ✓ | ✓ | 770 |\n| **4.1.11** | تحقق من أن التطبيق يحتوي على ضوابط لمكافحة الأتمتة ضد الاستدعاءات المفرطة مثل استخراج البيانات الجماعية  mass data exfiltration ، أو طلبات منطق العمل business logic requests ، أو رفع الملفات ، أو هجمات تعطيل الخدمة denial of service attacks. | ✓ | ✓ | ✓ | 770 |\n| **5.1.11** | تحقق من أن التطبيق يحتوي على حدود منطق الأعمال أو التحقق من الصحة للحماية من مخاطر أو تهديدات الأعمال المحتملة ، والتي تم تحديدها باستخدام نمذجة التهديد أو منهجيات مماثلة. | ✓ | ✓ | ✓ | 841 |\n| **6.1.11** | تحقق من أن التطبيق لا يعاني من مشكلات \"وقت التحقق حتى وقت الاستخدام Time Of Check to Time Of Use\" (TOCTOU)\" أو ظروف السباق الأخرى race conditions  للعمليات الحساسة. | | ✓ | ✓ | 367 |\n| **7.1.11** | تحقق من مراقبة التطبيق للأحداث أو الأنشطة غير العادية من منظور منطق الأعمال. على سبيل المثال ، محاولات تنفيذ إجراءات خارج النظام أو إجراءات لن يحاول المستخدم العادي تنفيذها أبدًا. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **8.1.11** | تحقق من أن التطبيق يحتوي على تنبيهات قابلة للتكوين configurable alerting  عند اكتشاف هجمات آلية أو نشاط غير عادي. | | ✓ | ✓ | 390 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* يمكن تحقيق مكافحة الأتمتة بعدة طرق ، بما في ذلك استخدام  [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) •\tيمكن تحقيق مكافحة الأتمتة بعدة طرق ، بما في ذلك استخدام.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:42.887665"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x20-V12-Files-Resources.md", "content": "# ت12: الملفات والموارد\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه يفي بالمتطلبات عالية المستوى التالية:\n\n* يجب التعامل مع بيانات الملف غير الموثوق Untrusted file data  بطريقة آمنة.\n* يتم تخزين بيانات الملف غير الموثوق بها التي تم الحصول عليها من مصادر غير موثوق بها خارج مسار جذر الويب web root  وبأذونات محدودة limited permissions.\n\n## ق1.12 رفع الملف\n\nعلى الرغم من أن القنابل المضغوطة zip bombs  قابلة للاختبار بشكل كبير باستخدام تقنيات اختبار الاختراق ، إلا أنها تعتبر L2 وما فوق لتشجيع التفكير في التصميم والتطوير من خلال اختبار يدوي دقيق ، ولتجنب اختبار الاختراق اليدوي الآلي أو غير الماهر لحالة رفض الخدمة.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.12** | تحقق من أن التطبيق لن يقبل الملفات الكبيرة التي قد تملأ مساحة التخزين أو تتسبب في تعطيل الخدمة. | ✓ | ✓ | ✓ | 400 |\n| **2.1.12** | تحقق من أن التطبيق يتحقق من الملفات المضغوطة (مثل zip و gz و docx و odt) مقابل الحد الأقصى المسموح به للحجم غير المضغوط ومقابل الحد الأقصى لعدد الملفات قبل فك ضغط الملف. | | ✓ | ✓ | 409 |\n| **3.1.12** | تحقق من فرض الحصة النسبية لحجم الملف file size quota  والحد الأقصى لعدد الملفات لكل مستخدم لضمان عدم تمكن مستخدم واحد من ملء التخزين بعدد كبير جدًا من الملفات أو بالملفات الكبيرة جدًا. | | ✓ | ✓ | 770 |\n\n## ق2.12 سلامة الملف\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.12** | Verify that files obtained from untrusted sources are validated to be of expected type based on the file's content. | | ✓ | ✓ | 434 |\n\n## ق3.12 تنفيذ الملف\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.12** | تحقق من أن بيانات تعريف لاسم الملف filename metadata التي يرسلها المستخدم لا يتم استخدامها مباشرة بواسطة أنظمة ملفات النظام أو إطار العمل وأن واجهة برمجة تطبيقات URL (URL API) تستخدم للحماية من اجتياز المسار path traversal. | ✓ | ✓ | ✓ | 22 |\n| **2.3.12** | تحقق من صحة بيانات تعريف لاسم الملف filename metadata المقدمة من المستخدم أو تجاهلها لمنع الكشف عن الملفات المحلية (Local File Inclusion LFI) أو إنشائها أو تحديثها أو إزالتها. | ✓ | ✓ | ✓ | 73 |\n| **3.3.12** | تأكد من التحقق من صحة بيانات التعريف لاسم الملف filename metadata المقدمة من المستخدم أو تجاهلها لمنع الكشف عن الملفات البعيدة أو تنفيذها عبر هجمات تضمين الملفات عن بُعد Remote File Inclusion (RFI) أو هجمات تزوير الطلب من جانب الخادم Server-side Request Forgery (SSRF). | ✓ | ✓ | ✓ | 98 |\n| **4.3.12** | تحقق من أن التطبيق يحمي من تنزيل الملف الانعكاسي Reflective File Download (RFD)  عن طريق التحقق من صحة أو تجاهل أسماء الملفات التي يرسلها المستخدم في بارامتر JSON أو JSONP أو عنوان URL ، ويجب ضبط قيمة رأس استجابة response Content-Type header  بـ text/plain ، ورأس Content-Disposition يجب أن يكون له اسم ملف ثابت. | ✓ | ✓ | ✓ | 641 |\n| **5.3.12** | تحقق من أن بيانات التعريف للملف غير الموثوق بها لا تُستخدم مباشرةً مع واجهة برمجة تطبيقات النظام أو المكتبات ، للحماية من حقن أوامر نظام التشغيل OS command injection. | ✓ | ✓ | ✓ | 78 |\n| **6.3.12** | تحقق من أن التطبيق لا يتضمن وظائف من مصادر غير موثوق بها ولا ينفذها، مثل شبكات توزيع المحتوى التي لم يتم التحقق منها unverified content distribution networks  ، أو مكتبات JavaScript ، أو مكتبات node npm ، أو مكتبات DLL من جانب الخادم. | | ✓ | ✓ | 829 |\n\n## ق4.12 تخزين الملف\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.12** | تحقق من أن الملفات التي تم الحصول عليها من مصادر غير موثوقة مخزنة خارج جذر الويب web root ، بأذونات محدودة limited permissions. | ✓ | ✓ | ✓ | 552 |\n| **2.4.12** | تحقق من أن الملفات التي تم الحصول عليها من مصادر غير موثوقة يتم فحصها بواسطة مضادات الفيروسات antivirus scanners  لمنع تحميل وتخديم محتوى ضار معروف. | ✓ | ✓ | ✓ | 509 |\n\n## ق5.12 تحميل الملف\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.12** | تحقق من تكوين طبقة الويب web tier  لخدمة الملفات ذات امتدادات محددة لمنع تسرب المعلومات أو الشيفرة المصدرية  بشكل غير مقصود. على سبيل المثال ، يجب حظر ملفات النسخ الاحتياطي (مثل .bak) وملفات العمل المؤقتة (مثل .swp) والملفات المضغوطة (.zip و .tar.gz وما إلى ذلك) وغيرها من الامتدادات التي يشيع استخدامها بواسطة المحررين ما لم يكن ذلك مطلوبًا. | ✓ | ✓ | ✓ | 552 |\n| **2.5.12** | تحقق من أن الطلبات المباشرة للملفات التي تم تحميلها لن يتم تنفيذها أبدًا كمحتوى HTML / JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## ق6.12 حماية SSRF\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.12** | تحقق من تكوين خادم الويب أو التطبيق بقائمة سماحية allow list  من الموارد أو الأنظمة التي يمكن للخادم إرسال الطلبات إليها أو تحميل البيانات / الملفات منها. | ✓ | ✓ | ✓ | 918 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:42.998064"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x21-V13-API.md", "content": "# ت13: واجهة برمجة التطبيقات وخدمة الويب\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه والذي يستخدم واجهات برمجة تطبيقات طبقة الخدمة الموثوقة trusted service layer APIs  (التي تستخدم عادةً JSON أو XML أو GraphQL) لديه:\n\n* المصادقة الكافية وإدارة الجلسة والتفويض لجميع خدمات الويب.\n* التحقق من صحة المدخلات لجميع البارامترات التي تنتقل من مستوى ثقة أدنى إلى مستوى أعلى.\n* ضوابط أمنية فعالة لجميع أنواع واجهات برمجة التطبيقات ، بما في ذلك السحابة وواجهة برمجة التطبيقات بدون خادم cloud and Serverless API.\n\nيرجى قراءة هذا الفصل مع جميع الفصول الأخرى في نفس المستوى ؛ لم نعد نكرر ضوابط المصادقة أو إدارة جلسة API.\n\n## ق1.13 أمان خدمة الويب العامة\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.13** | تحقق من أن جميع مكونات التطبيق تستخدم نفس الترميزات encodings والمحللات parsers لتجنب هجمات التحليل parsing attacks  التي تستغل مختلف سلوك URI أو سلوك تحليل الملف file parsing behavior  الذي يمكن استخدامه في هجمات SSRF و RFI. | ✓ | ✓ | ✓ | 116 |\n| **2.1.13** | [تم حذفها ، مكررة عن 1.3.4] | | | | |\n| **3.1.13** | تحقق من أن عناوين URL لواجهة برمجة التطبيقات لا تكشف معلومات حساسة ، مثل مفتاح واجهة برمجة التطبيقات API key والرموز المميزة للجلسة session tokens  وما إلى ذلك. | ✓ | ✓ | ✓ | 598 |\n| **4.1.13** | تحقق من أن قرارات التفويض يتم اتخاذها في كل من URI ، والتي يتم فرضها بواسطة الأمان البرمجي أو التعريفي programmatic or declarative security  على وحدة التحكم controller  أو وحدة التوجيه router ، وعلى مستوى الموارد ، يتم فرضها بواسطة الأذونات المستندة إلى النموذج model-based permissions. | | ✓ | ✓ | 285 |\n| **5.1.13** | تحقق من رفض الطلبات التي تحتوي على أنواع محتوى غير متوقعة أو مفقودة وذلك برؤوس مناسبة (حالة استجابة HTTP 406 غير مقبول Unacceptable  أو 415 نوع وسائط غير مدعوم Unsupported Media Type). | | ✓ | ✓ | 434 |\n\n## ق2.13 خدمة الويب RESTful\n\nالتحقق من صحة مخطط JSON (JSON schema) في مرحلة مسودة للتوحيد القياسي draft stage of standardization  (انظر المراجع). عند التفكير في استخدام التحقق من صحة مخطط JSON ، وهو أفضل ممارسة لخدمات الويب RESTful ، ضع في اعتبارك استخدام استراتيجيات التحقق من صحة البيانات الإضافية هذه جنبًا إلى جنب مع التحقق من صحة مخطط JSON:\n\n* تحليل التحقق من صحة كائن JSON (JSON Object)، مثل ما إذا كانت هناك عناصر مفقودة أو إضافية.\n* التحقق من صحة قيم كائن JSON باستخدام طرق التحقق من صحة المدخلات القياسية ، مثل نوع البيانات ، وتنسيق البيانات ، والطول ، وما إلى ذلك.\n* والتحقق من صحة مخطط JSON الرسمي.\n\nبمجرد إضفاء الطابع الرسمي على معيار التحقق من صحة مخطط JSON ، ستقوم ASVS بتحديث نصائحها في هذا المجال. راقب بعناية أي مكتبات التحقق من صحة مخطط JSON قيد الاستخدام ، حيث ستحتاج إلى تحديثها بانتظام حتى يصبح المعيار رسميًا ويتم التخلص من الأخطاء في عمليات التنفيذ المرجعية.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.13** | تحقق من أن طرق RESTful HTTP الممكّنة هي خيار صالح للمستخدم أو الإجراء ، مثل منع المستخدمين العاديين من استخدام DELETE أو PUT على واجهة برمجة التطبيقات أو الموارد المحمية. | ✓ | ✓ | ✓ | 650 |\n| **2.2.13** | تأكد من أن التحقق صحة مخطط JSON يعمل وموثوق منه قبل قبول المدخلات. | ✓ | ✓ | ✓ | 20 |\n| **3.2.13** | تحقق من أن خدمات الويب RESTful التي تستخدم ملفات تعريف الارتباط cookies  محمية من التزوير عبر الموقع Cross-Site Request Forgery  عبر استخدام واحد أو أكثر مما يلي على الأقل: نموذج إرسال مزدوج لملف تعريف الارتباط double submit cookie pattern  أو CSRF nonces أو عمليات التحقق من رأس طلب Origin. | ✓ | ✓ | ✓ | 352 |\n| **4.2.13** | [تم حذفها ، مكررة عن 4.1.11] | | | | |\n| **5.2.13** | تأكد من أن خدمات REST تتحقق صراحةً من نوع المحتوى الوارد ليكون النوع المتوقع ، مثل application / xml أو application / json. | | ✓ | ✓ | 436 |\n| **6.2.13** | تحقق من أن رؤوس الرسائل والحمولة جديرة بالثقة trustworthy  ولم يتم تعديلها أثناء النقل. قد يكون طلب تشفير قوي للنقل (TLS فقط) كافياً في كثير من الحالات لأنه يوفر كلاً من السرية والسلامة. يمكن أن توفر التواقيع الرقمية لكل رسالة ضمانًا إضافيًا بالإضافة إلى حماية النقل للتطبيقات عالية الأمان ، ولكنها تجلب معها تعقيدًا ومخاطر إضافية مع الفوائد. | | ✓ | ✓ | 345 |\n\n## ق3.13 خدمة ويب SOAP\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.13** | تأكد من أن التحقق من صحة مخطط XSD يتم لضمان تكوين مستند XML بشكل صحيح ، متبوعًا بالتحقق من صحة كل حقل مدخلات قبل إجراء أي معالجة لتلك البيانات. | ✓ | ✓ | ✓ | 20 |\n| **2.3.13** | تحقق من توقيع حمولة الرسالة باستخدام WS-Security لضمان النقل الموثوق به بين العميل والخدمة. | | ✓ | ✓ | 345 |\n\nملاحظة: نظرًا لوجود مشكلات تتعلق بهجمات XXE ضد DTD ، لا ينبغي استخدام التحقق من DTD وتعطيل تقييم DTD لإطار العمل وفقًا للمتطلبات المنصوص عليها في ت14: متطلبات التحقق من التكوين.\n\n## ق4.13 GraphQL\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.13** | تحقق من استخدام قائمة تسمح بالاستعلام أو مجموعة من تحديد العمق وتحديد المقدار combination of depth limiting and amount limiting لمنع تعطيل الخدمة (DoS) لـ GraphQL أو تعبير طبقة البيانات data layer expression  كنتيجة للاستعلامات المتداخلة والمكلفة. لمزيد من السيناريوهات المتقدمة ، يجب استخدام تحليل تكلفة الاستعلام query cost analysis. | | ✓ | ✓ | 770 |\n| **2.4.13** | تحقق من أنه يجب تنفيذ GraphQL أو أي منطق تفويض طبقة البيانات data layer authorization logic  في طبقة منطق الأعمال بدلاً من طبقة GraphQL. | | ✓ | ✓ | 285 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:43.063589"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x22-V14-Config.md", "content": "# ت14: التكوين\n\n## الهدف من ضوابط الأمان\n\nتأكد من أن التطبيق الذي يتم التحقق منه لديه:\n\n* بيئة بناء build environment آمنة وقابلة للتكرار وقابلة للأتمتة automatable.\n* أن  تكون مكتبات الطرف الثالث Third-party libraries، وإدارة التبعية dependency والتكوين configuration  متينة Hardened بحيث لا يتم تضمين المكونات القديمة أو غير الآمنة في التطبيق.\n\nيجب أن يكون تكوين التطبيق الذي يتضمن التشغيل الأساسي فقط آمنًا ليكون على الإنترنت ، مما يعني تكوينًا خارج الصندوق بشكل آمن(safe out of the box).\n\n## ق1.14 البناء والنشر Build and Deploy\n\nالأنابيب الخاصة بالبناء Build pipelines  هو الأساس للأمان المتكرر - في كل مرة يتم اكتشاف شيء غير آمن ، يمكن حله في الشيفرة المصدرية ، أو السكربتات الخاصة بالبناء أو النشر  build or deployment scripts ، واختبارها تلقائيًا. نحن نشجع بشدة على استخدام الأنابيب الخاصة بالبناء Build pipelines مع عمليات فحص الأمان والتبعية المؤتمتة automatic security and dependency checks  والتي تحذر أو تكسر البناء warn or break the build لمنع نشر مشكلات الأمان المعروفة في بيئة الإنتاج الحقيقية. تؤدي الخطوات اليدوية التي يتم إجراؤها بشكل غير منتظم مباشرة إلى أخطاء أمنية يمكن تجنبها.\n\nبما أن الصناعة تنتقل إلى نموذج DevSecOps ، من المهم ضمان استمرار توافر وسلامة النشر deployment  والتكوين configuration  لتحقيق حالة \"جيدة معروفة known good \". في الماضي ، إذا تم اختراق نظام ما ، فقد يستغرق الأمر أيامًا إلى شهور لإثبات عدم حدوث مزيد من الاختراقات. اليوم ، مع ظهور بنية تحتية محددة بالبرمجيات ، وعمليات نشر A / B سريعة rapid A/B deployments بدون توقف ، وإنشاء حاويات آلية للبناء automated containerized builds ، فمن الممكن بشكل تلقائي ومستمر بناء ، وتقوية ، ونشر بديل \"معروف بشكل جيد \"known good\" لأي نظام مخترق\n\nإذا كانت النماذج التقليدية لا تزال موجودة، فيجب اتخاذ خطوات يدوية لتقوية هذا التكوين وعمل نسخة احتياطية منه للسماح باستبدال الأنظمة المخترقة بأنظمة ذات سلامة عالية وغير مخترقة في الوقت المناسب.\n\nيتطلب الامتثال لهذا القسم نظام بناء مؤتمتًا automated build system ، وإمكانية الوصول إلى السكربتات الخاصة بالبناء أو النشر  build or deployment scripts.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.14** | تحقق من تنفيذ عمليات بناء التطبيق ونشره بطريقة آمنة وقابلة للتكرار ، مثل أتمتة CI / CD ، وإدارة التكوين المؤتمت automated configuration management، وسكربتات النشر المؤتمت automated deployment scripts. | | ✓ | ✓ | |\n| **2.1.14** | تحقق من تكوين أعلام المترجم compiler flags  لتمكين جميع عمليات الحماية والتحذيرات المتاحة لـ buffer overflow protections ، بما في ذلك التوزيع العشوائي للمكدس stack randomization  ، ومنع تنفيذ البيانات data execution prevention ، ولكسر البناء o break the build إذا تم العثور على مؤشر أو ذاكرة أو سلسلة تنسيق أو عدد صحيح أو عمليات السلسلة غير آمنة unsafe pointer, memory, format string, integer, or string operations. | | ✓ | ✓ | 120 |\n| **3.1.14** | تحقق من أن تكوين الخادم مقوّى hardened  وفقًا لتوصيات مخدم التطبيق والأطر المستخدمة. | | ✓ | ✓ | 16 |\n| **4.1.14** | تحقق من أن التطبيق والتكوين وجميع التبعيات dependencies يمكن إعادة نشرها باستخدام سكربتات النشر المؤتمت automated deployment scripts، والتي تم إنشاؤها من دفتر تشغيل runbook  موثق ومختبر في وقت معقول ، أو استعادتها من النسخ الاحتياطية في الوقت المناسب. | | ✓ | ✓ | |\n| **5.1.14** | تحقق من أن المسؤولين المصرح لهم يمكنهم التحقق من سلامة جميع التكوينات ذات الصلة بالأمان لاكتشاف التلاعب. | | | ✓ | |\n\n## ق2.14 التبعية Dependency\n\nتعد إدارة التبعية  Dependency أمرًا بالغ الأهمية للتشغيل الآمن لأي تطبيق من أي نوع. يعد الفشل في مواكبة التبعيات القديمة أو غير الآمنة هو السبب الجذري لأكبر الهجمات وأكثرها تكلفة حتى الآن.\n\nملاحظة: في المستوى 1 ، يتعلق الامتثال بالبند 1.2.14 بالملاحظات أو اكتشافات جانب العميل والمكتبات والمكونات الأخرى ، بدلاً من التحليل الثابت للشيفرة المصدرية static code analysis  أو تحليل التبعية dependency analysis الأكثر دقة. يمكن اكتشاف هذه التقنيات الأكثر دقة عن طريق المقابلة كما هو مطلوب.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.14** | تحقق من أن جميع المكونات محدثة ، ويفضل استخدام مدقق التبعية dependency checker أثناء وقت البناء build أو الترجمة compile. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **2.2.14** | تحقق من إزالة جميع الميزات والوثائق ونماذج التطبيقات والإعدادات غير الضرورية. | ✓ | ✓ | ✓ | 1002 |\n| **3.2.14** | تحقق من أنه إذا كانت أصول التطبيق ، مثل مكتبات JavaScript أو CSS أو خطوط الويب ، مستضافة خارجيًا على شبكة توصيل المحتوى Content Delivery Network (CDN) أو مزود خارجي ، فيجب أن يتم استخدام تكامل الموارد الفرعية Subresource Integrity (SRI) للتحقق من سلامة الأصل asset. | ✓ | ✓ | ✓ | 829 |\n| **4.2.14** | تحقق من أن مكونات المكتبات الخارجية تأتي من مستودعات repositories محددة مسبقًا وموثوقة وتتم صيانتها باستمرار.  ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **5.2.14** | تحقق من الاحتفاظ بقائمة مواد البرمجيات Software Bill of Materials (SBOM) لكافة المكتبات الخارجية third party libraries المستخدمة. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **6.2.14** | تحقق من تخفيض سطح الهجوم attack surface  عن طريق وضع الحماية sandbox أو تغليف المكتبات الخارجية لكشف السلوك المطلوب فقط في التطبيق. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## ق3.14 الإفصاح الأمني غير المقصود\n\nيجب تقوية التكوينات الخاصة بالبيئة الحقيقية للحماية من الهجمات الشائعة ، مثل debug consoles ، ورفع مستوى هجمات البرمجة النصية عبر المواقع Cross-site Scripting (XSS) و Remote File Inclusion (RFI) ، وللتخلص من \"نقاط الضعف\" في اكتشاف المعلومات غير المهمة والمتواجدة من تقارير اختبار الاختراق. نادرًا ما يتم تصنيف العديد من هذه المشكلات على أنها مخاطر كبيرة ، ولكنها مرتبطة ببعضها البعض مع نقاط ضعف أخرى. إذا لم تكن هذه المشكلات موجودة بشكل افتراضي ، فإنها ترفع المستوى قبل أن تنجح معظم الهجمات.\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.3.14** | [تم حذفها ، مكررة عن 1.4.7] | | | | |\n| **2.3.14** | تحقق من أن أنماط تصحيح الأخطاء debug modes  في  إطار عمل التطبيق أو خادم الويب والتطبيق معطلة في البيئة الحقيقية لإزالة ميزات تصحيح الأخطاء debug features  ووحدات تحكم المطورين developer consoles  وإفصاحات الأمان غير المقصودة unintended security disclosures. | ✓ | ✓ | ✓ | 497 |\n| **3.3.14** | تحقق من أن رؤوس HTTP أو أي جزء من استجابة HTTP لا تعرض معلومات إصدار تفصيلية لمكونات النظام. | ✓ | ✓ | ✓ | 200 |\n\n## ق4.14 رؤوس أمان HTTP\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.14** | تحقق من أن كل استجابة HTTP تحتوي على رأس نوع المحتوى Content-Type header. أيضاً يجب أن تحدد مجموعة محارف character set  آمنة (على سبيل المثال ، UTF-8 و ISO-8859-1). إذا كان المحتوى هو text / * و / + xml و application / xml فيجب أن يتوافق المحتوى مع رأس نوع المحتوى. | ✓ | ✓ | ✓ | 173 |\n| **2.4.14** | تحقق من أن جميع استجابات API تحتوي على رأس Content-Disposition: attachment؛ filename=\"api.json\" (أو اسم ملف آخر مناسب لنوع المحتوى). | ✓ | ✓ | ✓ | 116 |\n| **3.4.14** | تحقق من وجود رأس استجابة سياسة أمان المحتوى Content Security Policy (CSP) header التي تساعد في التخفيف من تأثير هجمات XSS مثل ثغرات حقن HTML و DOM و JSON و JavaScript. | ✓ | ✓ | ✓ | 1021 |\n| **4.4.14** | تحقق من أن جميع الاستجابات تحتوي على  X-Content-Type-Options: nosniff header. | ✓ | ✓ | ✓ | 116 |\n| **5.4.14** | تحقق من تضمين Strict-Transport-Security header في جميع الاستجابات ولجميع النطاقات الفرعية subdomains ، مثل Strict-Transport-Security: max-age=15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **6.4.14** | تحقق من تضمين Referrer-Policy header  مناسب لتجنب كشف المعلومات الحساسة في عنوان URL من خلال الرأس \"Referer\" لأطراف غير موثوق بها. | ✓ | ✓ | ✓ | 116 |\n| **7.4.14** | تحقق من أن محتوى تطبيق الويب لا يمكن تضمينه في موقع جهة خارجية بشكل افتراضي وأن تضمين الموارد الدقيقة مسموح به فقط عند الضرورة باستخدام الرؤوس Content-Security-Policy: frame-ancestors and X-Frame-Options response headers. | ✓ | ✓ | ✓ | 1021 |\n\n## ق5.14 متطلبات رأس طلب HTTP\n\n| # | التوصيف | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.14** | تحقق من أن خادم التطبيق لا يقبل سوى طرق  HTTP المستخدمة من قبل التطبيق / واجهة برمجة التطبيقات ، بما في ذلك pre-flight OPTIONS ، والسجلات / التنبيهات بشأن أي طلبات غير صالحة لسياق التطبيق. | ✓ | ✓ | ✓ | 749 |\n| **2.5.14** | تحقق من أن Origin header  المقدم لا يتم استخدامه للمصادقة أو قرارات التحكم في الوصول ، حيث يمكن للمهاجم تغيير عنوان Origin بسهولة. | ✓ | ✓ | ✓ | 346 |\n| **3.5.14** | تحقق من أن Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header  يستخدم قائمة سماح صارمة للنطاقات الموثوقة والمجالات الفرعية للمطابقة معها ولا يدعم الأصل \"الفارغ\" \"null\" origin. | ✓ | ✓ | ✓ | 346 |\n| **4.5.14** | تحقق من أن رؤوس HTTP المضافة بواسطة proxy  موثوق به أو أجهزة SSO ، مثل رمز الحامل bearer token ، قد تمت مصادقتها بواسطة التطبيق. | | ✓ | ✓ | 306 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering]( https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* •\tتساعد إضافة Content-Disposition إلى استجابات واجهة برمجة التطبيقات على منع العديد من الهجمات استنادًا إلى سوء فهم نوع MIME بين العميل والخادم ، ويساعد خيار \"filename\" على وجه التحديد في منع [Reflected File Download attacks هجمات تنزيل الملفات المنعكسة Reflected](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:43.188039"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x90-Appendix-A_Glossary.md", "content": "# الملحق أ: قائمة المصطلحات\n\n- **عشوائية تخطيط مساحة العنوان Address Space Layout Randomization** (ASLR) – - أسلوب لجعل استغلال أخطاء فساد الذاكرة أكثر صعوبة.\n- ** قائمة السماح Allow list** – قائمة بالبيانات أو العمليات المسموح بها ، على سبيل المثال قائمة الأحرف المسموح بها لإجراء التحقق من صحة المدخلات.\n- **أمان التطبيق Application Security** – يركز الأمان على مستوى التطبيق على تحليل المكونات التي تشكل طبقة التطبيق الخاصة بالنموذج المرجعي لربط الأنظمة المفتوحة (OSI Model) ، بدلاً من التركيز على نظام التشغيل الأساسي أو الشبكات المتصلة على سبيل المثال.\n- **التحقق من أمان التطبيق Application Security Verification** – التقييم الفني لتطبيق مقابل OWASP ASVS.\n- **تقرير التحقق من أمان التطبيق Application Security Verification Report** – تقرير يوثق النتائج الإجمالية والتحليل الداعم الذي تم إنتاجه بواسطة المدقق لتطبيق معين.\n- **المصادقة Authentication** – التحقق من الهوية المطالب بها لمستخدم التطبيق.\n- **التحقق المؤتمت Automated Verification** – استخدام الأدوات المؤتمتة (إما أدوات التحليل الديناميكي أو أدوات التحليل الثابتة أو كليهما) التي تستخدم تواقيع الثغرات الأمنية vulnerability signatures للعثور على المشكلات.\n- **اختبار الصندوق الأسود Black box testing** – هو طريقة لاختبار البرنامج الذي يفحص وظائف التطبيق دون النظر إلى هياكله أو أعماله الداخلية.\n- **المكوِّن Component** – وحدة تعليمات برمجية قائمة بذاتها ، مع واجهات القرص والشبكة المرتبطة التي تتواصل مع المكونات الأخرى.\n- **البرمجة النصية عبر المواقع Cross-Site Scripting** (XSS) – ثغرة أمنية توجد عادةً في تطبيقات الويب مما يسمح بحقن البرامج النصية من جانب العميل في المحتوى.\n- **وحدة التشفير Cryptographic module** – الأجهزة و / أو البرامج و / أو البرامج الثابتة التي تنفذ خوارزميات التشفير و / أو تنشئ مفاتيح التشفير.\n- **تعداد نقاط الضعف الشائعة  Common Weakness Enumeration** (CWE) - قائمة مطورة من قبل المجتمع لنقاط ضعف أمان البرامج الشائعة. إنها بمثابة لغة مشتركة، وعصا قياس لأدوات أمان البرامج، وكخط أساس لتحديد نقاط الضعف ، والتخفيف ، وجهود الوقاية.\n- **التحقق من التصميم  Design Verification** – التقييم الفني لمعمارية أمان التطبيق.\n- ** اختبار أمان التطبيق الديناميكي Dynamic Application Security Testing** (DAST) - تم تصميم التقنيات لاكتشاف الظروف التي تشير إلى وجود ثغرة أمنية في تطبيق في حالته قيد التشغيل.\n- ** التحقق الديناميكي Dynamic Verification** – استخدام الأدوات المؤتمتة التي تستخدم تواقيع الثغرات الأمنية للعثور على المشكلات أثناء تنفيذ أحد التطبيقات.\n- ** الهوية السريعة عبر الإنترنت Fast IDentity Online** (FIDO) - مجموعة من معايير المصادقة التي تسمح باستخدام مجموعة متنوعة من طرق المصادقة المختلفة بما في ذلك القياسات الحيوية ووحدات النظام الأساسي الموثوقة (TPM Trusted Platform Modules) ورموز أمان USB (USB security tokens) وما إلى ذلك.\n- ** المعرف الفريد العالمي Globally Unique Identifier** (GUID) – رقم مرجعي فريد يستخدم كمعرف في البرنامج.\n- ** بروتوكول نقل النص التشعبي Hyper Text Transfer Protocol** (HTTPS) – بروتوكول تطبيق لأنظمة معلومات الوسائط التشعبية الموزعة والتعاونية. إنها أساس اتصال البيانات لشبكة الويب العالمية.\n- ** المفاتيح المخزنة Hardcoded keys** – مفاتيح التشفير التي يتم تخزينها على نظام الملفات ، سواء أكان ذلك في رمز أو تعليقات أو ملفات.\n- ** وحدة أمان الأجهزة Hardware Security Module** (HSM) - مكون الأجهزة القادر على تخزين مفاتيح التشفير والأسرار الأخرى بطريقة محمية.\n- ** إسبات لغة الاستعلام  Hibernate Query Language** (HQL) - لغة استعلام تشبه في المظهر لغة SQL المستخدمة بواسطة مكتبة Hibernate ORM.\n- ** التحقق من صحة المدخلات Input Validation** – توحيد canonicalization والتحقق من صحة مدخلات المستخدم غير الموثوق به.\n- ** الشيفرة المصدرية الضارة Malicious Code** – شيفرة مصدرية يتم إدخاله في تطبيق ما أثناء تطويره دون علم مالك التطبيق ، والذي يتحايل على سياسة الأمان المقصودة للتطبيق. ليست مثل البرامج الضارة مثل الفيروسات أو الدودة!\n- ** البرمجيات الخبيثة Malware** – التعليمات البرمجية القابلة للتنفيذ التي يتم إدخالها في التطبيق أثناء وقت التشغيل دون معرفة مستخدم التطبيق أو المسؤول.\n- ** مشروع أمان تطبيق الويب المفتوح Open Web Application Security Project** (OWASP) – مشروع أمان تطبيق الويب المفتوح (OWASP) هو مجتمع عالمي مجاني ومفتوح يركز على تحسين أمان برامج التطبيقات. مهمتنا هي جعل أمان التطبيق \"مرئيًا\" ، بحيث يمكن للأفراد والمؤسسات اتخاذ قرارات مستنيرة بشأن مخاطر أمان التطبيق. انظر: https://www.owasp.org/\n- ** كلمة المرور لمرة واحدة One-time Password** (OTP) - كلمة مرور يتم إنشاؤها بشكل فريد لاستخدامها في مناسبة واحدة.\n- ** رسم الخرائط العلائقية للكائن Object-relational Mapping** (ORM) - نظام يستخدم للسماح لقاعدة بيانات علائقية / قائمة على الجدول بالإشارة إليها والاستعلام عنها داخل برنامج تطبيق باستخدام نموذج كائن متوافق مع التطبيق.\n- ** وظيفة اشتقاق المفتاح المعتمد على كلمة المرور 2 Password-Based Key Derivation Function 2** (PBKDF2) -  وظيفة اشتقاق المفتاح المعتمد على كلمة المرور 2 \n- ** وظيفة اشتقاق المفتاح المعتمد على كلمة المرور 2 Personally Identifiable Information** (PII) - هي المعلومات التي يمكن استخدامها بمفردها أو مع معلومات أخرى لتحديد شخص واحد أو الاتصال به أو تحديد موقعه ، أو لتحديد شخص في السياق.\n- ** ملف تنفيذي مستقل عن الموضع Position-independent executable** (PIE) - جسم من كود الآلة body of machine code الذي يتم وضعه في مكان ما في الذاكرة الأساسية primary memory ويتم تنفيذه بشكل صحيح بغض النظر عن عنوانه المطلق absolute address.\n- ** البنية التحتية للمفتاح العام Public Key Infrastructure** (PKI) - ترتيب يربط المفاتيح العامة public keys بهويات الكيانات الخاصة. يتم إنشاء الارتباط من خلال عملية التسجيل وإصدار الشهادات في ومن قبل سلطة إصدار الشهادات (certificate authority CA).\n- **ترتيب يربط المفاتيح العامة public keys بهويات الكيانات الخاصة. يتم إنشاء الارتباط من خلال عملية التسجيل وإصدار الشهادات في ومن قبل سلطة إصدار الشهادات (certificate authority CA).Public Switched Telephone Network** (PSTN) - شبكة الهاتف التقليدية بما في ذلك هواتف الخطوط الثابتة والهواتف المحمولة.\n- ** الطرف المعول Relying Party** (RP) - تطبيق يعتمد على مستخدم قام بالمصادقة تجاه مزود مصادقة منفصل. يعتمد التطبيق على نوع من الرموز المميزة أو مجموعة من التأكيدات الموقعةsigned assertions  التي يوفرها مزود المصادقة للوثوق في ما يدعيه المستخدم.\n- ** اختبار أمان التطبيق الثابت Static application security testing** (SAST) - مجموعة من التقنيات المصممة لتحليل الشيفرة المصدرية للتطبيق ورمز البايت Byte Code والثنائيات Binaries لظروف كتابة الشيفرة المصدرية والتصميم التي تدل على وجود ثغرات أمنية. تحلل طرق SAST التطبيق من \"الداخل إلى الخارج\" وهو في حالة عدم التشغيل.\n- ** دورة حياة تطوير البرمجيات Software development lifecycle** (SDLC) - العملية التدريجية التي يتم من خلالها تطوير البرنامج من المتطلبات الأولية إلى النشر والصيانة.\n- ** معمارية الأمان Security Architecture** – تعبير مجرد لتصميم التطبيق يحدد ويصف مكان وكيفية استخدام عناصر التحكم في الأمان ، كما يحدد ويصف موقع وحساسية كل من بيانات المستخدم والتطبيق.\n- ** تكوين الأمان Security Configuration** – تكوين زمن التشغيل للتطبيق الذي يؤثر على كيفية استخدام عناصر التحكم في الأمان.\n- ** ضابط الأمان Security Control** – وظيفة أو مكون يقوم بإجراء فحص أمني (على سبيل المثال ، فحص التحكم في الوصول) أو عند استدعائه يؤدي إلى تأثير أمني (مثل إنشاء سجل تدقيق).\n- ** تزوير الطلب من جانب الخادم Server-side Request Forgery** (SSRF) - هجوم يسيء استخدام الوظائف الموجودة على الخادم لقراءة أو تحديث الموارد الداخلية عن طريق توفير أو تعديل عنوان URL الذي ستقوم الشيفرة المصدرية التي يتم تشغيلها على الخادم بقراءة البيانات أو إرسالها إليها.\n- ** مصادقة الدخول الموحد Single Sign-on Authentication** (SSO) - يحدث هذا عندما يقوم المستخدم بتسجيل الدخول إلى تطبيق واحد ثم يتم تسجيل الدخول تلقائيًا إلى تطبيقات أخرى دون الحاجة إلى إعادة المصادقة. على سبيل المثال ، إذا تم تسجيل الدخول إلى Google ، عند الوصول إلى خدمات Google الأخرى مثل YouTube ومحرّر مستندات Google و Gmail ، سيتم تسجيل دخولك تلقائيًا.\n- ** حقن SQL SQL Injection** (SQLi) – تقنية حقن التعليمات البرمجية المستخدمة لمهاجمة التطبيقات التي تعتمد على البيانات ، والتي يتم فيها إدراج استعلامات SQL الضارة في نقطة دخول entry point.\n- **SVG** - Scalable Vector Graphics  رسومات موجهة قابلة للتحجيم \n- ** OTP على أساس الوقت  Time-based OTP** - طريقة لإنشاء OTP حيث يعمل الوقت الحالي كجزء من الخوارزمية لإنشاء كلمة المرور.\n- ** نمذجة التهديدات Threat Modeling** - تقنية تتكون من تطوير بنى أمنية مصقولة بشكل متزايد لتحديد عوامل التهديد ، والمناطق الأمنية ، والضوابط الأمنية ، والأصول التقنية والتجارية الهامة.\n- ** أمان طبقة النقل Transport Layer Security** (TLS) – بروتوكولات التشفير التي توفر أمان الاتصال عبر اتصال الشبكة.\n- ** الوحدة النمطية للنظام الأساسي الموثوق به  Trusted Platform Module** (TPM) - نوع من HSM يتم إرفاقه عادةً بمكون أجهزة أكبر مثل اللوحة الأم ويعمل بمثابة \"جذر الثقة \"root of trust\" لهذا النظام.\n- ** المصادقة الثنائية Two-factor authentication** (2FA) - تضيف المستوى الثاني من المصادقة لتسجيل الدخول إلى الحساب.\n- ** العامل الثاني العالمي Universal 2nd Factor** (U2F) - أحد المعايير التي أنشأتها FIDO خصيصًا للسماح باستخدام مفتاح أمان USB أو NFC كعامل مصادقة ثانٍ.\n- **URI/URL/URL fragments  أجزاء URI / URL / URL ** – معرف الموارد المنتظم هو سلسلة من الأحرف المستخدمة لتحديد اسم أو مورد ويب. غالبًا ما يتم استخدام محدد موقع المعلومات Uniform Resource Locator كمرجع إلى أحد الموارد.\n- ** المدقق Verifier** – الشخص أو الفريق الذي يقوم بمراجعة طلب مقابل متطلبات OWASP ASVS.\n- ** ما تراه هو ما تحصل عليه  What You See Is What You Get** (WYSIWYG) - نوع من محرر المحتوى الغني الذي يوضح كيف سيبدو المحتوى بالفعل عند تقديمه بدلاً من إظهار الترميز المستخدم للتحكم في العرض.\n- **X.509 Certificate  شهادة X.509** – شهادة X.509 هي شهادة رقمية تستخدم معيار البنية التحتية للمفتاح العام (PKI) الدولي المقبول على نطاق واسع X.509 للتحقق من أن المفتاح العام ينتمي إلى هوية المستخدم أو الكمبيوتر أو الخدمة المضمنة في الشهادة.\n- **XML eXternal Entity الكيان الخارجي لـ XML ** (XXE) - نوع من كيان XML يمكنه الوصول إلى المحتوى المحلي أو البعيد عبر معرف نظام معلن. قد يؤدي هذا إلى هجمات حقن مختلفة.", "timestamp": "2025-10-24T11:39:43.286877"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x91-Appendix-B_References.md", "content": "# الملحق ب: المراجع\n\nمن المرجح أن تكون مشاريع OWASP التالية مفيدة لمستخدمي / متبني هذا المعيار:\n\n## مشاريع أواسب الأساسية\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n##  مشروع أواسب لمجموعة أوراق المناقشة \n\nيحتوي هذا [المشروع ](https://owasp.org/www-project-cheat-sheets/) على عدد من أوراق المناقشة التي ستكون ذات صلة بمواضيع مختلفة في ASVS.\n\nيوجد تعيين لـ ASVS يمكن العثور عليه هنا: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## المشاريع المتعلقة بأمن الجوال\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## مشاريع أواسب المتعلقة بانترنت الأشياء\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## مشاريع أواسب بدون خادم Serverless OWASP Serverless projects\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## مشاريع أخرى\n\nوبالمثل ، من المرجح أن تكون مواقع الويب التالية مفيدة لمستخدمي / متبني هذا المعيار\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:43.388473"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ar/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ar/0x93-Appendix-C_IoT.md", "content": "# الملحق ج: متطلبات التحقق من إنترنت الأشياء\n\nكان هذا الفصل في الأساس في الفرع الرئيسي ، ولكن مع العمل الذي قام به فريق OWASP IoT ، فليس من المنطقي الاحتفاظ بمكانين مختلفين حول هذا الموضوع. بالنسبة للإصدار 4.0 ، ننقل هذا إلى الملحق ، ونحث كل من يطلب ذلك ، بدلاً من استخدام  [OWASP IoT project مشروع أواسب لانترنت الأشياء](https://owasp.org/www-project-internet-of-things/) الرئيسي\n\n## الهدف من ضوابط الأمان\n\nيجب على الأجهزة المضمنة / إنترنت الأشياء:\n\n* الحصول على نفس مستوى عناصر التحكم في الأمان داخل الجهاز كما هو موجود في الخادم ، من خلال فرض ضوابط الأمان في بيئة موثوقة.\n* يجب أن يتم تخزين البيانات الحساسة على الجهاز بطريقة آمنة باستخدام التخزين المدعوم من الأجهزة مثل العناصر الآمنة.\n* يجب أن تستخدم جميع البيانات الحساسة المرسلة من الجهاز أمان طبقة النقل.\n\n## متطلبات التحقق الأمني\n\n| # | التوصيف | L1 | L2 | L3 | Since |\n| --- | --- | --- | --- | -- | -- |\n| **ض.1** | تحقق من أن واجهات تصحيح أخطاء طبقة التطبيق application layer debugging interfaces مثل USB و UART والمتغيرات التسلسلية serial variants الأخرى معطلة أو محمية بكلمة مرور معقدة. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.2** | تحقق من أن مفاتيح التشفير والشهادات فريدة لكل جهاز على حدة. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.3** | تحقق من تمكين عناصر تحكم حماية الذاكرة مثل ASLR و DEP بواسطة نظام التشغيل المدمج / إنترنت الأشياء embedded/IoT operating system ، إن أمكن. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.4** | تحقق من أن واجهات التصحيح على الرقاقة on-chip debugging interfaces مثل JTAG أو SWD معطلة أو أن آلية الحماية المتاحة تم تمكينها وتكوينها بشكل مناسب. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.5** | تحقق من تنفيذ وتمكين التنفيذ execution الموثوق به ، إذا كان ذلك متاحًا على جهاز SoC أو وحدة المعالجة المركزية. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.6** | تحقق من تخزين البيانات الحساسة والمفاتيح الخاصة والشهادات بشكل آمن في Secure Element أو TPM أو TEE (بيئة تنفيذ موثوقة) أو محمية باستخدام تشفير قوي. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.7** | تحقق من أن تطبيقات البرامج الثابتة firmware apps protect تحمي البيانات أثناء النقل باستخدام أمان طبقة النقل. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.8** | تحقق من أن تطبيقات البرامج الثابتة تتحقق من صحة التوقيع الرقمي لاتصالات الخادم. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.9** | تحقق من أن الاتصالات اللاسلكية مصادقة بشكل متبادل. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.10** | تحقق من إرسال الاتصالات اللاسلكية عبر قناة مشفرة.  | ✓ | ✓ | ✓ | 4.0 |\n| **ض.11** | تحقق من استبدال أي استخدام لوظائف C المحظورة بوظائف مناسبة بحيث تكون بديلة وآمنة. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.12** | تحقق من أن كل برنامج ثابت firmware  يحتفظ بقائمة مواد للبرنامج تقوم بفهرسة مكونات الطرف الثالث ، والإصدارات ، والثغرات الأمنية المنشورة. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.13** | تحقق من جميع الشيفرة المصدرية code بما في ذلك الثنائيات Binaries والمكتبات والأطر التابعة لجهات خارجية والتي تتم مراجعتها لبيانات الاعتماد المشفرة (الأبواب الخلفية Backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **ض.14** | تحقق من أن مكونات التطبيق والبرامج الثابتة firmware ليست عرضة لـحقن أوامر نظام التشغيل عن طريق استدعاء أغلفة أوامر shell (shell command wrappers) أو البرامج النصية أو أن عناصر التحكم الأمنية تمنع حقن أوامر نظام التشغيل. | ✓ | ✓ | ✓ | 4.0 |\n| **ض.15** | تحقق من أن تطبيقات البرامج الثابتة تثبت التوقيع الرقمي بخادم (خوادم) موثوق به. |  | ✓ | ✓ | 4.0 |\n| **ض.16** | تحقق من وجود مقاومة للتلاعب tamper و / أو ميزات كشف التلاعب Tamper Detection. |  | ✓ | ✓ | 4.0 |\n| **ض.17** | تحقق من تمكين أي من تقنيات حماية الملكية الفكرية التي توفرها الشركة المصنعة للرقاقة. |  | ✓ | ✓ | 4.0 |\n| **ض.18** | تحقق من وجود ضوابط الأمان لعرقلة الهندسة العكسية للبرامج الثابتة (على سبيل المثال ، إزالة رموز التصحيح المطول verbose debugging symbols). |  | ✓ | ✓ | 4.0 |\n| **ض.19** | تحقق من قيام الجهاز بالتحقق من صحة توقيع صورة الإقلاع boot image signature  قبل التحميل. |  | ✓ | ✓ | 4.0 |\n| **ض.20** | تحقق من أن عملية تحديث البرنامج الثابت ليست عرضة لهجمات وقت التحقق مقابل وقت الاستخدام time-of-check vs time-of-use attacks. |  | ✓ | ✓ | 4.0 |\n| **ض.21** | تحقق من أن الجهاز يستخدم توقيع الرمز code signing والتحقق من صحة ملفات ترقية البرامج الثابتة firmware upgrade files  قبل التثبيت. |  | ✓ | ✓ | 4.0 |\n| **ض.22** | تحقق من أنه لا يمكن إرجاع الجهاز إلى الإصدارات القديمة downgraded (مكافحة التراجع anti-rollback) من البرامج الثابتة الصالحة. |  | ✓ | ✓ | 4.0 |\n| **ض.23** | تحقق من استخدام منشئ الأرقام العشوائية الزائفة الآمنة المشفرة cryptographically secure pseudo-random number generator على جهاز مضمن embedded device (على سبيل المثال ، باستخدام مولدات الأرقام العشوائية المزودة بشريحة using chip-provided random number generators). |  | ✓ | ✓ | 4.0 |\n| **ض.24** | تحقق من أن البرنامج الثابت يمكنه إجراء تحديثات تلقائية للبرامج الثابتة وفقًا لجدول زمني محدد مسبقًا. |  | ✓ | ✓ | 4.0 |\n| **ض.25** | تحقق من أن الجهاز يفحص البرامج الثابتة والبيانات الحساسة عند اكتشاف التلاعب أو استلام رسالة غير صالحة. |  |  | ✓ | 4.0 |\n| **ض.26** | تحقق من استخدام وحدات التحكم الصغيرة micro controllers  فقط التي تدعم تعطيل واجهات تصحيح الأخطاء (مثل JTAG و SWD). |  |  | ✓ | 4.0 |\n| **ض.27** | تحقق من استخدام وحدات التحكم الصغيرة micro controllers فقط التي توفر حماية كبيرة من هجمات إلغاء السد والقنوات الجانبية decapping and side channel attacks. |  |  | ✓ | 4.0 |\n| **ض.28** | تحقق من عدم تعرض الآثار الحساسة sensitive traces للطبقات الخارجية للوحة الدائرة المطبوعة outer layers of the printed circuit board. |  |  | ✓ | 4.0 |\n| **ض.29** | تحقق من أن الاتصال بين الشرائح مشفر (على سبيل المثال ، اتصال اللوحة الرئيسية Main board  إلى اللوحة الفرعية daughter board). |  |  | ✓ | 4.0 |\n| **ض.30** | تحقق من أن الجهاز يستخدم توقيع الرمز code signing  والتحقق من صحة الرمز قبل التنفيذ. |  |  | ✓ | 4.0 |\n| **ض.31** | تحقق من أن المعلومات الحساسة المحفوظة في الذاكرة قد تم استبدالها overwritten بالأصفار بمجرد عدم الحاجة إليها. |  |  | ✓ | 4.0 |\n| **ض.32** | تحقق من أن تطبيقات البرامج الثابتة تستخدم حاويات kernel للعزل بين التطبيقات. |  |  | ✓ | 4.0 |\n| **ض.33** | تحقق من أن علامات المترجم الآمن مثل -fPIE، -fstack-protector-all، -Wl، -z، noexecstack، -Wl، -z، noexecheap قد تم تكوينها لإنشاءات البرامج الثابتة. |  |  | ✓ | 4.0 |\n| **ض.34** | تحقق من تكوين وحدات التحكم الصغيرة micro controllers مع حماية الشيفرة المصدرية code protection (إن أمكن). |  |  | ✓ | 4.0 |\n\n## المراجع\n\nلمزيد من المعلومات، يمكن أيضاً الاطلاع على:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:43.460321"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/cre_mapping_table.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/cre_mapping_table.md", "content": "<pre>ASVS | CRE\n---- | ---\n[v4.0.3-1.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [616-305 Define security steps in every SDLC stage](https://www.opencre.org/cre/616-305)\n[v4.0.3-1.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [340-754 Threat model every design change or sprint](https://www.opencre.org/cre/340-754)\n[v4.0.3-1.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [822-100 Constrain functional features based on user stories](https://www.opencre.org/cre/822-100)\n[v4.0.3-1.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [820-877 Document all trust boundaries and significant data flows](https://www.opencre.org/cre/820-877)\n[v4.0.3-1.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [004-130 Define High-level architecture and perform security analysis on it](https://www.opencre.org/cre/004-130)\n[v4.0.3-1.1.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [344-611 Centralize security controls](https://www.opencre.org/cre/344-611)\n[v4.0.3-1.1.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v11-secure-software-development-lifecycle) | [036-275 Make (centrally) available secure coding resources for programmers](https://www.opencre.org/cre/036-275)\n[v4.0.3-1.10.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v110-malicious-software-architecture) | [757-271 Use proper source code control system](https://www.opencre.org/cre/757-271)\n[v4.0.3-1.11.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v111-business-logic-architecture) | [162-655 Docuymentation of all components' business or security function](https://www.opencre.org/cre/162-655)\n[v4.0.3-1.11.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v111-business-logic-architecture) | [670-660 Do not share unsynchronized state on high-value logic flows](https://www.opencre.org/cre/670-660)\n[v4.0.3-1.11.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v111-business-logic-architecture) | [380-540 Ensure business flows' thread safety/resistance to race conditions](https://www.opencre.org/cre/380-540)\n[v4.0.3-1.12.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v112-secure-file-upload-architecture) | [634-883 Separate storage of user uploaded files](https://www.opencre.org/cre/634-883)\n[v4.0.3-1.12.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v112-secure-file-upload-architecture) | [384-344 Store and serve user-uploaded files such that they cannot execute/damage server or client](https://www.opencre.org/cre/384-344)\n[v4.0.3-1.14.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [273-600 Segregate components of differing trust levels](https://www.opencre.org/cre/273-600)\n[v4.0.3-1.14.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [171-222 Check binary integrity before deployment](https://www.opencre.org/cre/171-222)\n[v4.0.3-1.14.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [053-751 Force pipeline to check outdated/insecure components](https://www.opencre.org/cre/053-751)\n[v4.0.3-1.14.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [263-184 Automate secure build and deployment, especially with SDI](https://www.opencre.org/cre/263-184)\n[v4.0.3-1.14.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [515-021 Sandbox, containerize and/or isolate applications at the network level](https://www.opencre.org/cre/515-021)\n[v4.0.3-1.14.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v114-configuration-architecture) | [673-475 Disallow unsupported/deprecated client-side technologies](https://www.opencre.org/cre/673-475)\n[v4.0.3-1.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v12-authentication-architecture) | [330-281 Use least privilege OS accounts for system (components)](https://www.opencre.org/cre/330-281)\n[v4.0.3-1.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v12-authentication-architecture) | [278-413 Mutually authenticate application components. Minimize privileges](https://www.opencre.org/cre/278-413)\n[v4.0.3-1.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v12-authentication-architecture) | [113-133 Use centralized authentication mechanism](https://www.opencre.org/cre/113-133)\n[v4.0.3-1.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v12-authentication-architecture) | [576-042 Consistently apply authentication strength](https://www.opencre.org/cre/576-042)\n[v4.0.3-1.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v14-access-control-architecture) | [640-364 Enforce access control on trusted parts/serverside](https://www.opencre.org/cre/640-364)\n[v4.0.3-1.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v14-access-control-architecture) | [412-561 Provide system flexibility for access control](https://www.opencre.org/cre/412-561)\n[v4.0.3-1.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v14-access-control-architecture) | [624-716 Use least privilege for resources](https://www.opencre.org/cre/624-716)\n[v4.0.3-1.4.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v14-access-control-architecture) | [117-371 Use a centralized access control mechanism](https://www.opencre.org/cre/117-371)\n[v4.0.3-1.4.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v14-access-control-architecture) | [801-310 Use ABAC/FBAC on data/feature level, even when using RBAC for permissions](https://www.opencre.org/cre/801-310)\n[v4.0.3-1.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v15-input-and-output-architecture) | [782-234 Clear policy complient I/O requirements](https://www.opencre.org/cre/782-234)\n[v4.0.3-1.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v15-input-and-output-architecture) | [736-554 Block serialization of content from untrusted clients](https://www.opencre.org/cre/736-554)\n[v4.0.3-1.5.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v15-input-and-output-architecture) | [848-711 Enforce input validation on a trusted service layer](https://www.opencre.org/cre/848-711)\n[v4.0.3-1.5.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v15-input-and-output-architecture) | [806-367 Encode output near the consuming interpreter](https://www.opencre.org/cre/806-367)\n[v4.0.3-1.6.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v16-cryptographic-architecture) | [287-305 Document explicit key/secret managementt](https://www.opencre.org/cre/287-305)\n[v4.0.3-1.6.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v16-cryptographic-architecture) | [508-702 Use key vaults](https://www.opencre.org/cre/508-702)\n[v4.0.3-1.6.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v16-cryptographic-architecture) | [821-832 Ensure keys and passwords are replaceable](https://www.opencre.org/cre/821-832)\n[v4.0.3-1.6.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v16-cryptographic-architecture) | [232-325 Treat client-secrets as insecure](https://www.opencre.org/cre/232-325)\n[v4.0.3-1.7.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v17-errors-logging-and-auditing-architecture) | [260-200 Log consistent format across system](https://www.opencre.org/cre/260-200)\n[v4.0.3-1.7.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v17-errors-logging-and-auditing-architecture) | [026-280 Secure transfer of logs (remotely)](https://www.opencre.org/cre/026-280)\n[v4.0.3-1.8.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v18-data-protection-and-privacy-architecture) | [765-788 Classify sensitive data in protection levels](https://www.opencre.org/cre/765-788)\n[v4.0.3-1.8.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v18-data-protection-and-privacy-architecture) | [731-120 Document requirements for (data) protection levels](https://www.opencre.org/cre/731-120)\n[v4.0.3-1.9.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v19-communications-architecture) | [527-034 Protect communication between application components](https://www.opencre.org/cre/527-034)\n[v4.0.3-1.9.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x10-V1-Architecture.md#v19-communications-architecture) | [530-671 Mutually authenticate application components](https://www.opencre.org/cre/530-671)\n[v4.0.3-10.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v101-code-integrity) | [611-158 Use SAST for malicious content](https://www.opencre.org/cre/611-158)\n[v4.0.3-10.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [834-645 Avoid unauthorized client data collection](https://www.opencre.org/cre/834-645)\n[v4.0.3-10.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [540-566 Let application request minimal permisions](https://www.opencre.org/cre/540-566)\n[v4.0.3-10.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [838-636 Check source code to not contain backdoors](https://www.opencre.org/cre/838-636)\n[v4.0.3-10.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [418-525 Check source code to not contain timebombs](https://www.opencre.org/cre/418-525)\n[v4.0.3-10.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [265-800 Check source code to not contain malicious code](https://www.opencre.org/cre/265-800)\n[v4.0.3-10.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v102-malicious-code-search) | [154-031 Harden application by excluding unwanted functiuonality](https://www.opencre.org/cre/154-031)\n[v4.0.3-10.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v103-application-integrity) | [028-254 Secure auto-updates over full stack](https://www.opencre.org/cre/028-254)\n[v4.0.3-10.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v103-application-integrity) | [307-507 Allow only trusted sources both buildtime and runtime; therefore perform integrity checks on all resources and code](https://www.opencre.org/cre/307-507)\n[v4.0.3-10.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x18-V10-Malicious.md#v103-application-integrity) | [336-512 Ensure integrity of DNS entries and domains](https://www.opencre.org/cre/336-512)\n[v4.0.3-11.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [534-605 Enforce natural sequence of business flows to avoid abuse](https://www.opencre.org/cre/534-605)\n[v4.0.3-11.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [456-535 Monitor for realistic \"human time\" business logic flows](https://www.opencre.org/cre/456-535)\n[v4.0.3-11.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [746-705 Limit/authorize user's access to functionality](https://www.opencre.org/cre/746-705)\n[v4.0.3-11.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [630-573 Monitor suspected automation abuse](https://www.opencre.org/cre/630-573)\n[v4.0.3-11.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [660-867 Implement business logic limits against identified business risks](https://www.opencre.org/cre/660-867)\n[v4.0.3-11.1.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [134-412 Protect sensitive functionalities against race conditions](https://www.opencre.org/cre/134-412)\n[v4.0.3-11.1.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [418-853 Monitor unusual activities on system](https://www.opencre.org/cre/418-853)\n[v4.0.3-11.1.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x19-V11-BusLogic.md#v111-business-logic-security) | [725-682 Enable configurable alert against usage anomalies](https://www.opencre.org/cre/725-682)\n[v4.0.3-12.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v121-file-upload) | [660-052 Validate max input/file sizes](https://www.opencre.org/cre/660-052)\n[v4.0.3-12.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v121-file-upload) | [163-518 Check uploaded archives for decompression attacks (eg zip bombs)](https://www.opencre.org/cre/163-518)\n[v4.0.3-12.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v121-file-upload) | [463-820 Limit size and number of uploaded files](https://www.opencre.org/cre/463-820)\n[v4.0.3-12.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v122-file-integrity) | [175-235 Validate file type of data from untrusted sources](https://www.opencre.org/cre/175-235)\n[v4.0.3-12.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [675-168 Sanitize filename metadata from untrusted origin if processing is required](https://www.opencre.org/cre/675-168)\n[v4.0.3-12.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [737-086 Ignore/at least validate filename metadata from untrusted origin (local file context, eg LFI)](https://www.opencre.org/cre/737-086)\n[v4.0.3-12.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [742-056 Ignore/at least validate filename metadata from untrusted origin (remote file context, eg RFI)](https://www.opencre.org/cre/742-056)\n[v4.0.3-12.3.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [421-513 Ignore/at least validate filenames from untrusted origin (against RFD)](https://www.opencre.org/cre/421-513)\n[v4.0.3-12.3.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [683-722 Block direct execution of file metadata from untrusted origin](https://www.opencre.org/cre/683-722)\n[v4.0.3-12.3.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v123-file-execution) | [777-470 Ignore/block execution logic from untrusted sources](https://www.opencre.org/cre/777-470)\n[v4.0.3-12.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v124-file-storage) | [307-111 Securely store files with untrusted origin](https://www.opencre.org/cre/307-111)\n[v4.0.3-12.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v124-file-storage) | [112-273 Scan untrusted files for malware](https://www.opencre.org/cre/112-273)\n[v4.0.3-12.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v125-file-download) | [314-701 Whitelist file extensions served by web tier](https://www.opencre.org/cre/314-701)\n[v4.0.3-12.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v125-file-download) | [545-243 Block execution/output of uploaded files](https://www.opencre.org/cre/545-243)\n[v4.0.3-12.6.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x20-V12-Files-Resources.md#v126-ssrf-protection) | [814-322 Whitelist data sources and sinks](https://www.opencre.org/cre/814-322)\n[v4.0.3-13.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v131-generic-web-service-security) | [061-186 Force uniform encoders and parsers throughout system](https://www.opencre.org/cre/061-186)\n[v4.0.3-13.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v131-generic-web-service-security) | [152-725 Limit access to admin/management functionality](https://www.opencre.org/cre/152-725)\n[v4.0.3-13.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v131-generic-web-service-security) | [333-888 Do not expose data through API URLs](https://www.opencre.org/cre/333-888)\n[v4.0.3-13.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v131-generic-web-service-security) | [664-080 Enforce model-based authorization both at URI and final resourc](https://www.opencre.org/cre/664-080)\n[v4.0.3-13.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v131-generic-web-service-security) | [377-680 Reject non-whitelisted content types](https://www.opencre.org/cre/377-680)\n[v4.0.3-13.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [532-878 Limit REST HTTP methods](https://www.opencre.org/cre/532-878)\n[v4.0.3-13.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [146-706 Enforce JSON schema before processing](https://www.opencre.org/cre/146-706)\n[v4.0.3-13.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [464-084 Add CSRF protection for cookie based REST services](https://www.opencre.org/cre/464-084)\n[v4.0.3-13.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [001-746 Anti-Automation protection for REST services](https://www.opencre.org/cre/001-746)\n[v4.0.3-13.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [543-512 Verify content-type for REST services](https://www.opencre.org/cre/543-512)\n[v4.0.3-13.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v132-restful-web-service) | [426-842 Verify the authenticity of both headers and payload](https://www.opencre.org/cre/426-842)\n[v4.0.3-13.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v133-soap-web-service) | [611-051 Enforce schema on XML structure/field](https://www.opencre.org/cre/611-051)\n[v4.0.3-13.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v133-soap-web-service) | [456-636 Add integrity check to SOAP payload](https://www.opencre.org/cre/456-636)\n[v4.0.3-13.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v134-graphql) | [268-088 Limit query impact GraphQL/data layer expression DoS](https://www.opencre.org/cre/268-088)\n[v4.0.3-13.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x21-V13-API.md#v134-graphql) | [612-252 Separate GraphQL (or similar) authorization logic from data layer](https://www.opencre.org/cre/612-252)\n[v4.0.3-14.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v141-build-and-deploy) | [253-452 Securely automate build and deployment in pipeline](https://www.opencre.org/cre/253-452)\n[v4.0.3-14.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v141-build-and-deploy) | [314-131 Set proper (C) compiler flags](https://www.opencre.org/cre/314-131)\n[v4.0.3-14.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v141-build-and-deploy) | [180-488 Proper Configuration foe all applications and frameworks](https://www.opencre.org/cre/180-488)\n[v4.0.3-14.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v141-build-and-deploy) | [208-355 Ensure repeatability of deployment](https://www.opencre.org/cre/208-355)\n[v4.0.3-14.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v141-build-and-deploy) | [347-352 Set and confirm integrity of security deployment configuration](https://www.opencre.org/cre/347-352)\n[v4.0.3-14.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [715-334 Update third party components build- or compiletime](https://www.opencre.org/cre/715-334)\n[v4.0.3-14.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [462-245 Remove dead code](https://www.opencre.org/cre/462-245)\n[v4.0.3-14.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [577-260 Enforce integrity ckeck for externally hosted assets (eg SRI)](https://www.opencre.org/cre/577-260)\n[v4.0.3-14.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [715-223 Ensure trusted origin of third party resources](https://www.opencre.org/cre/715-223)\n[v4.0.3-14.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [863-521 Maintain/manage inventory of third party repositories](https://www.opencre.org/cre/863-521)\n[v4.0.3-14.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v142-dependency) | [860-084 Sandbox third party libraries](https://www.opencre.org/cre/860-084)\n[v4.0.3-14.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v143-unintended-security-disclosure) | [743-110 Do not disclose technical information in error message](https://www.opencre.org/cre/743-110)\n[v4.0.3-14.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v143-unintended-security-disclosure) | [208-805 Disable debug mode in production](https://www.opencre.org/cre/208-805)\n[v4.0.3-14.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v143-unintended-security-disclosure) | [403-005 Do not disclose technical information in HTTP header or responce](https://www.opencre.org/cre/403-005)\n[v4.0.3-14.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [036-725 Set content HTTP response type](https://www.opencre.org/cre/036-725)\n[v4.0.3-14.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [736-237 Set metadate/content-Disposition for API responses](https://www.opencre.org/cre/736-237)\n[v4.0.3-14.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [257-668 Configure CSP configuration properly](https://www.opencre.org/cre/257-668)\n[v4.0.3-14.4.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [065-388 Configure X-Content-Type-Options properly](https://www.opencre.org/cre/065-388)\n[v4.0.3-14.4.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [036-147 Configure HSTS configuration properly](https://www.opencre.org/cre/036-147)\n[v4.0.3-14.4.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [268-100 Configure Referrer-Policy properly](https://www.opencre.org/cre/268-100)\n[v4.0.3-14.4.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v144-http-security-headers) | [480-071 Configure X-Frame-Options for CSP properly](https://www.opencre.org/cre/480-071)\n[v4.0.3-14.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v145-http-request-header-validation) | [483-715 White-list HTTP methods](https://www.opencre.org/cre/483-715)\n[v4.0.3-14.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v145-http-request-header-validation) | [405-411 Avoid using of Origin header for authentication of access control](https://www.opencre.org/cre/405-411)\n[v4.0.3-14.5.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v145-http-request-header-validation) | [316-272 White-list CORS resources](https://www.opencre.org/cre/316-272)\n[v4.0.3-14.5.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x22-V14-Config.md#v145-http-request-header-validation) | [820-421 Authenticate HTTP headers added by a trusted proxy or SSO device](https://www.opencre.org/cre/820-421)\n[v4.0.3-2.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [027-555 User passwords are of sufficient minimum length](https://www.opencre.org/cre/027-555)\n[v4.0.3-2.1.10](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [338-370 Do not enforce password rotation rules or history requirements](https://www.opencre.org/cre/338-370)\n[v4.0.3-2.1.11](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [630-577 Allow password helpers, including paste functionality](https://www.opencre.org/cre/630-577)\n[v4.0.3-2.1.12](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [487-305 Provide options to view entire password or last typed character](https://www.opencre.org/cre/487-305)\n[v4.0.3-2.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [158-874 Allow long passwords](https://www.opencre.org/cre/158-874)\n[v4.0.3-2.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [715-681 Avoid password truncation, with exception of consecutive spaces](https://www.opencre.org/cre/715-681)\n[v4.0.3-2.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [103-707 Allow unicode in passwords](https://www.opencre.org/cre/103-707)\n[v4.0.3-2.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [751-176 Offer password changing functionality](https://www.opencre.org/cre/751-176)\n[v4.0.3-2.1.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [327-505 Change password with presence of old and new password](https://www.opencre.org/cre/327-505)\n[v4.0.3-2.1.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [576-651 Check new passwords against breached passwords](https://www.opencre.org/cre/576-651)\n[v4.0.3-2.1.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [604-025 Provide a password strength meter](https://www.opencre.org/cre/604-025)\n[v4.0.3-2.1.9](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v21-password-security) | [807-565 Do not limit character types for password composition](https://www.opencre.org/cre/807-565)\n[v4.0.3-2.10.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v210-service-authentication) | [813-610 Do not use static secrets](https://www.opencre.org/cre/813-610)\n[v4.0.3-2.10.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v210-service-authentication) | [065-183 Disallow default credentials](https://www.opencre.org/cre/065-183)\n[v4.0.3-2.10.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v210-service-authentication) | [881-321 Store credentials securely](https://www.opencre.org/cre/881-321)\n[v4.0.3-2.10.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v210-service-authentication) | [774-888 Do not store secrets in the code](https://www.opencre.org/cre/774-888)\n[v4.0.3-2.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [802-056 Restrict excessive authentication](https://www.opencre.org/cre/802-056)\n[v4.0.3-2.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [354-752 Use strong authenticators with priority and weak authenticators only for less secure access](https://www.opencre.org/cre/354-752)\n[v4.0.3-2.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [808-425 Notify users about anomalies in their usage patterns](https://www.opencre.org/cre/808-425)\n[v4.0.3-2.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [333-858 Resist stolen credentials](https://www.opencre.org/cre/333-858)\n[v4.0.3-2.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [558-807 Mutually authenticate application and credential service provider](https://www.opencre.org/cre/558-807)\n[v4.0.3-2.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [524-446 Mandate using multi factor authentication](https://www.opencre.org/cre/524-446)\n[v4.0.3-2.2.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v22-general-authenticator-security) | [525-361 Authenticate by OTP token entry or user-initiated action on multi factor device](https://www.opencre.org/cre/525-361)\n[v4.0.3-2.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v23-authenticator-lifecycle) | [622-835 Generate initial passwords with sufficient secure random, short expiration time and do not allow to reuse the initial password.](https://www.opencre.org/cre/622-835)\n[v4.0.3-2.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v23-authenticator-lifecycle) | [553-413 Support subsciber-provided authentication devices](https://www.opencre.org/cre/553-413)\n[v4.0.3-2.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v23-authenticator-lifecycle) | [138-448 Inform users for authentication renewal](https://www.opencre.org/cre/138-448)\n[v4.0.3-2.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v24-credential-storage) | [622-203 Store passwords salted and hashed](https://www.opencre.org/cre/622-203)\n[v4.0.3-2.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v24-credential-storage) | [082-530 Use unique random salt with sufficient entropy for each credential](https://www.opencre.org/cre/082-530)\n[v4.0.3-2.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v24-credential-storage) | [767-435 Set the highest feasible iteration count for PBKDF2](https://www.opencre.org/cre/767-435)\n[v4.0.3-2.4.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v24-credential-storage) | [078-427 Set the highest feasible work factor for bcrypt](https://www.opencre.org/cre/078-427)\n[v4.0.3-2.4.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v24-credential-storage) | [077-781 Use separately stored secret salt (pepper)](https://www.opencre.org/cre/077-781)\n[v4.0.3-2.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [270-634 Send authentication secrets encrypted](https://www.opencre.org/cre/270-634)\n[v4.0.3-2.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [772-358 Do not use password hints or secret questions](https://www.opencre.org/cre/772-358)\n[v4.0.3-2.5.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [543-621 Do not reveal the current password during password recovery](https://www.opencre.org/cre/543-621)\n[v4.0.3-2.5.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [623-347 Disallow shared high privilige accounts](https://www.opencre.org/cre/623-347)\n[v4.0.3-2.5.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [235-658 Notify user about credential change](https://www.opencre.org/cre/235-658)\n[v4.0.3-2.5.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [581-525 Use secure recovery mechanisms for forgotten passwords](https://www.opencre.org/cre/581-525)\n[v4.0.3-2.5.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v25-credential-recovery) | [358-860 Require proof of identity of the same level as during enrollment when recovering OTP or MFA](https://www.opencre.org/cre/358-860)\n[v4.0.3-2.6.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v26-look-up-secret-verifier) | [101-217 Use lookup secrets only once](https://www.opencre.org/cre/101-217)\n[v4.0.3-2.6.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v26-look-up-secret-verifier) | [346-640 Generate lookup secrets with sufficient entropy](https://www.opencre.org/cre/346-640)\n[v4.0.3-2.6.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v26-look-up-secret-verifier) | [513-845 Use upredictable lookup secrets](https://www.opencre.org/cre/513-845)\n[v4.0.3-2.7.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [320-618 Do not offer weak (clear text) authenticators by default](https://www.opencre.org/cre/320-618)\n[v4.0.3-2.7.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [816-631 Ensure timely expiration of out of band authentication request, code, or tokens](https://www.opencre.org/cre/816-631)\n[v4.0.3-2.7.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [168-186 Use out of band authentication requests, codes or tokens only once](https://www.opencre.org/cre/168-186)\n[v4.0.3-2.7.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [102-811 Communicate out of band authentication requests, codes or tokens Iindependently and securely](https://www.opencre.org/cre/102-811)\n[v4.0.3-2.7.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [342-764 Only store hashed authentication codes](https://www.opencre.org/cre/342-764)\n[v4.0.3-2.7.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v27-out-of-band-verifier) | [206-254 Use secure random to generate initial authentication codes](https://www.opencre.org/cre/206-254)\n[v4.0.3-2.8.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [681-823 Defined lifetime of time-based one-time passowrd](https://www.opencre.org/cre/681-823)\n[v4.0.3-2.8.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [543-428 Use security module to store one-time password verification keys](https://www.opencre.org/cre/543-428)\n[v4.0.3-2.8.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [841-757 Use approved cryptographic algorithms in generation, seeding and verification](https://www.opencre.org/cre/841-757)\n[v4.0.3-2.8.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [404-126 Use time-based OTP only once](https://www.opencre.org/cre/404-126)\n[v4.0.3-2.8.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [646-227 Log and reject re-use of valid time-based OTP tokens and notify device holder.](https://www.opencre.org/cre/646-227)\n[v4.0.3-2.8.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [440-361 Ensure that physical single factor OTP generator can be revoked fully immediately when lost](https://www.opencre.org/cre/440-361)\n[v4.0.3-2.8.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v28-one-time-verifier) | [076-470 Biometric autheticators only as seconday factors](https://www.opencre.org/cre/076-470)\n[v4.0.3-2.9.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v29-cryptographic-verifier) | [783-255 Store cryptographic keys securely](https://www.opencre.org/cre/783-255)\n[v4.0.3-2.9.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v29-cryptographic-verifier) | [287-251 Use a unique challenge nonce of sufficient size](https://www.opencre.org/cre/287-251)\n[v4.0.3-2.9.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x11-V2-Authentication.md#v29-cryptographic-verifier) | [002-801 Use approved cryptographic algorithms for generation, seeding and verification](https://www.opencre.org/cre/002-801)\n[v4.0.3-3.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v31-fundamental-session-management-security) | [402-133 Do not expose session token in URL](https://www.opencre.org/cre/402-133)\n[v4.0.3-3.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v32-session-binding) | [002-630 Generate a new session token after authentication](https://www.opencre.org/cre/002-630)\n[v4.0.3-3.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v32-session-binding) | [704-530 Enforce high entropy session tokens](https://www.opencre.org/cre/704-530)\n[v4.0.3-3.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v32-session-binding) | [455-358 When storing session tokens in browers, use secure methods only](https://www.opencre.org/cre/455-358)\n[v4.0.3-3.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v32-session-binding) | [727-043 Ensure secure algorithms for generating session tokens](https://www.opencre.org/cre/727-043)\n[v4.0.3-3.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v33-session-termination) | [457-165 Terminate session after logout](https://www.opencre.org/cre/457-165)\n[v4.0.3-3.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v33-session-termination) | [065-782 Ensure session timeout (soft/hard)](https://www.opencre.org/cre/065-782)\n[v4.0.3-3.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v33-session-termination) | [238-346 Terminate all sessions when password is changed](https://www.opencre.org/cre/238-346)\n[v4.0.3-3.3.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v33-session-termination) | [673-736 Enable option to log out from all active session](https://www.opencre.org/cre/673-736)\n[v4.0.3-3.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management) | [688-081 Set \"secure\" attribute for cookie-based session tokens](https://www.opencre.org/cre/688-081)\n[v4.0.3-3.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management) | [804-220 Set httponly attribute for cookie-based session tokens](https://www.opencre.org/cre/804-220)\n[v4.0.3-3.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management) | [342-055 Set \"samesite\" attribute for cookie-based session tokens](https://www.opencre.org/cre/342-055)\n[v4.0.3-3.4.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management) | [232-034 Set '_Host' prefix for cookie-based session tokens](https://www.opencre.org/cre/232-034)\n[v4.0.3-3.4.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management) | [705-182 Set path attribute in cookie-bases session tokens as precise as possible](https://www.opencre.org/cre/705-182)\n[v4.0.3-3.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management) | [551-400 Allow user revocation of Oauth tokens](https://www.opencre.org/cre/551-400)\n[v4.0.3-3.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management) | [551-054 Use ephemeral secrets rather than static secrets](https://www.opencre.org/cre/551-054)\n[v4.0.3-3.5.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management) | [483-883 Using stateless tokens, ensure cryptographically secure characteristics](https://www.opencre.org/cre/483-883)\n[v4.0.3-3.6.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v36-federated-re-authentication) | [618-403 Enforce authentication time-out when dealing with an authentication third party (CSP)](https://www.opencre.org/cre/618-403)\n[v4.0.3-3.6.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v36-federated-re-authentication) | [052-821 When using an authentication third party (CSP), relay last authentication event to other parties in the chain](https://www.opencre.org/cre/052-821)\n[v4.0.3-3.7.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V3-Session-management.md#v37-defenses-against-session-management-exploits) | [582-541 Re-authenticate before sensitive transactions](https://www.opencre.org/cre/582-541)\n[v4.0.3-4.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v41-general-access-control-design) | [650-560 Enfroce access control on trusted service layer](https://www.opencre.org/cre/650-560)\n[v4.0.3-4.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v41-general-access-control-design) | [524-603 Limit modification of access controls to specifically authorized actors/users](https://www.opencre.org/cre/524-603)\n[v4.0.3-4.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v41-general-access-control-design) | [368-633 Enforce least privilege](https://www.opencre.org/cre/368-633)\n[v4.0.3-4.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v41-general-access-control-design) | [817-808 Deny new users by default](https://www.opencre.org/cre/817-808)\n[v4.0.3-4.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v41-general-access-control-design) | [166-151 Ensure that secure fail-safe is in place for access control](https://www.opencre.org/cre/166-151)\n[v4.0.3-4.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v42-operation-level-access-control) | [304-667 Protect API against unauthorized access/modification (IDOR)](https://www.opencre.org/cre/304-667)\n[v4.0.3-4.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v42-operation-level-access-control) | [060-472 Use CSRF protection against authenticated functionality, add anti-automation controls for unauthenticated functionality](https://www.opencre.org/cre/060-472)\n[v4.0.3-4.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v43-other-access-control-considerations) | [201-246 Use multifactor authentication on administrative interfaces](https://www.opencre.org/cre/201-246)\n[v4.0.3-4.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v43-other-access-control-considerations) | [615-744 Protect against directory browsing/discovery attacks](https://www.opencre.org/cre/615-744)\n[v4.0.3-4.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x12-V4-Access-Control.md#v43-other-access-control-considerations) | [284-521 Enforce additional authorization and segregation of duties](https://www.opencre.org/cre/284-521)\n[v4.0.3-5.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation) | [743-237 Validatie/enforce HTTP inputs (against HTTP parameter polution attacks)](https://www.opencre.org/cre/743-237)\n[v4.0.3-5.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation) | [042-550 Protect against mass parameter assignment attack](https://www.opencre.org/cre/042-550)\n[v4.0.3-5.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation) | [031-447 Whitelist all external (HTTP) input](https://www.opencre.org/cre/031-447)\n[v4.0.3-5.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation) | [653-242 Enforce schema on type/contents of structured data](https://www.opencre.org/cre/653-242)\n[v4.0.3-5.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation) | [232-217 Whitelist redirected/forwarded URLs](https://www.opencre.org/cre/232-217)\n[v4.0.3-5.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [542-445 Sanitize untrusted HTML input](https://www.opencre.org/cre/542-445)\n[v4.0.3-5.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [538-446 Sanitize unstructured data](https://www.opencre.org/cre/538-446)\n[v4.0.3-5.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [881-434 Sanitize user input before passing content to mail systems (SMTP/IMAP injection)](https://www.opencre.org/cre/881-434)\n[v4.0.3-5.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [317-743 Do not use eval or dynamic code execution functions](https://www.opencre.org/cre/317-743)\n[v4.0.3-5.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [422-005 Sanitize/sandbox user input where template-injection is a threat](https://www.opencre.org/cre/422-005)\n[v4.0.3-5.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [657-084 (SSRF) When depending on internal server input, use validation sanitization and whitelisting](https://www.opencre.org/cre/657-084)\n[v4.0.3-5.2.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [145-310 Sanitize, disable, or sandbox untrusted SVG scriptable content](https://www.opencre.org/cre/145-310)\n[v4.0.3-5.2.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing) | [646-462 Sanitize, disable, or sandbox untrusted scriptable or template language content](https://www.opencre.org/cre/646-462)\n[v4.0.3-5.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [620-101 Force output encoding for specific interpreter's context](https://www.opencre.org/cre/620-101)\n[v4.0.3-5.3.10](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [134-207 Protect against XML/XPath injection](https://www.opencre.org/cre/134-207)\n[v4.0.3-5.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [533-516 Encode output while preserving user input formatting](https://www.opencre.org/cre/533-516)\n[v4.0.3-5.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [366-835 Escape output against XSS](https://www.opencre.org/cre/366-835)\n[v4.0.3-5.3.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [732-873 Lock/precompile queries (parameterization) to avoid injection attacks](https://www.opencre.org/cre/732-873)\n[v4.0.3-5.3.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [064-808 Encode output context-specifically](https://www.opencre.org/cre/064-808)\n[v4.0.3-5.3.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [607-671 Protect against JS or JSON injection attacks](https://www.opencre.org/cre/607-671)\n[v4.0.3-5.3.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [531-558 Protect against LDAP injection](https://www.opencre.org/cre/531-558)\n[v4.0.3-5.3.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [857-718 Protect against OS command injection attack](https://www.opencre.org/cre/857-718)\n[v4.0.3-5.3.9](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention) | [547-283 Protect against LFI / RFI](https://www.opencre.org/cre/547-283)\n[v4.0.3-5.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v54-memory-string-and-unmanaged-code) | [831-570 Use memory-safe functions exclusively](https://www.opencre.org/cre/831-570)\n[v4.0.3-5.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v54-memory-string-and-unmanaged-code) | [824-732 Force format strings as constants](https://www.opencre.org/cre/824-732)\n[v4.0.3-5.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v54-memory-string-and-unmanaged-code) | [482-771 Check boundaries against integer overflow weaknesses](https://www.opencre.org/cre/482-771)\n[v4.0.3-5.5.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention) | [762-616 Secure serialized objects (e.g. integrity checks)](https://www.opencre.org/cre/762-616)\n[v4.0.3-5.5.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention) | [764-507 Restrict XML parsing (against XXE)](https://www.opencre.org/cre/764-507)\n[v4.0.3-5.5.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention) | [831-563 Avoid deserialization logic](https://www.opencre.org/cre/831-563)\n[v4.0.3-5.5.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention) | [387-848 Parse JSON safely](https://www.opencre.org/cre/387-848)\n[v4.0.3-6.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v61-data-classification) | [482-866 Encrypt personal data at rest](https://www.opencre.org/cre/482-866)\n[v4.0.3-6.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v61-data-classification) | [224-321 Encrypt health data at rest](https://www.opencre.org/cre/224-321)\n[v4.0.3-6.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v61-data-classification) | [267-468 Encrypt financial data at rest](https://www.opencre.org/cre/267-468)\n[v4.0.3-6.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [036-810 Let cryptographic modules fail securely](https://www.opencre.org/cre/036-810)\n[v4.0.3-6.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [742-431 Use approved cryptographic algorithms](https://www.opencre.org/cre/742-431)\n[v4.0.3-6.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [674-425 Use state of the art cryptographic configuration](https://www.opencre.org/cre/674-425)\n[v4.0.3-6.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [122-287 Ensure cryptographic elements can be upgraded or replaced](https://www.opencre.org/cre/122-287)\n[v4.0.3-6.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [441-132 Use weak crypto only for backwards compatibility](https://www.opencre.org/cre/441-132)\n[v4.0.3-6.2.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [433-122 Use nonces and initialization vectors only once](https://www.opencre.org/cre/433-122)\n[v4.0.3-6.2.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [786-224 Autenticate encrypted data](https://www.opencre.org/cre/786-224)\n[v4.0.3-6.2.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v62-algorithms) | [878-880 Perform cryptographic operations in constant time](https://www.opencre.org/cre/878-880)\n[v4.0.3-6.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v63-random-values) | [542-488 Use cryptographically secure random number generators](https://www.opencre.org/cre/542-488)\n[v4.0.3-6.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v63-random-values) | [027-210 Create random GUIDs with cryptographically secure random number generators](https://www.opencre.org/cre/027-210)\n[v4.0.3-6.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v63-random-values) | [664-571 Ensure proper generation of secure random](https://www.opencre.org/cre/664-571)\n[v4.0.3-6.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v64-secret-management) | [340-375 Use a dedicated secrets management solution](https://www.opencre.org/cre/340-375)\n[v4.0.3-6.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x14-V6-Cryptography.md#v64-secret-management) | [032-213 Use an isolated security module for cryptographic operations](https://www.opencre.org/cre/032-213)\n[v4.0.3-7.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v71-log-content) | [067-050 Do not log credentials or payment details](https://www.opencre.org/cre/067-050)\n[v4.0.3-7.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v71-log-content) | [240-274 Log only non-sensitive data](https://www.opencre.org/cre/240-274)\n[v4.0.3-7.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v71-log-content) | [184-284 Log all security relevant events](https://www.opencre.org/cre/184-284)\n[v4.0.3-7.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v71-log-content) | [555-048 Log events sufficiently to recreate their order](https://www.opencre.org/cre/555-048)\n[v4.0.3-7.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v72-log-processing) | [841-710 Log authentication decisions without exposing sensitive data](https://www.opencre.org/cre/841-710)\n[v4.0.3-7.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v72-log-processing) | [443-447 Log access control decisions](https://www.opencre.org/cre/443-447)\n[v4.0.3-7.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v73-log-protection) | [048-612 Encode user input before logging](https://www.opencre.org/cre/048-612)\n[v4.0.3-7.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v73-log-protection) | [821-540 Protect logs against log injection](https://www.opencre.org/cre/821-540)\n[v4.0.3-7.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v73-log-protection) | [713-683 Protect logs against unauthorized access](https://www.opencre.org/cre/713-683)\n[v4.0.3-7.3.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v73-log-protection) | [770-361 Synchronize time zones for logs](https://www.opencre.org/cre/770-361)\n[v4.0.3-7.4.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v74-error-handling) | [612-435 Show generic message for security exceptions or unanticipated exceptions](https://www.opencre.org/cre/612-435)\n[v4.0.3-7.4.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v74-error-handling) | [863-636 Use exception handling uniformly](https://www.opencre.org/cre/863-636)\n[v4.0.3-7.4.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x15-V7-Error-Logging.md#v74-error-handling) | [118-602 Use a standard last-resort error handler for unhandled errors](https://www.opencre.org/cre/118-602)\n[v4.0.3-8.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [846-302 Prevent caching of sensitive data in server components](https://www.opencre.org/cre/846-302)\n[v4.0.3-8.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [157-430 Protect and clear cached sensitive data](https://www.opencre.org/cre/157-430)\n[v4.0.3-8.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [217-112 Minimize the number of parameters in a request](https://www.opencre.org/cre/217-112)\n[v4.0.3-8.1.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [176-154 Monitor expectation of usage intensity (e.g. number of requests)](https://www.opencre.org/cre/176-154)\n[v4.0.3-8.1.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [257-117 Perform regular backups of important data and test restoration](https://www.opencre.org/cre/257-117)\n[v4.0.3-8.1.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v81-general-data-protection) | [614-353 Store backups securely](https://www.opencre.org/cre/614-353)\n[v4.0.3-8.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v82-client-side-data-protection) | [473-758 Set sufficient anti-chaching headers](https://www.opencre.org/cre/473-758)\n[v4.0.3-8.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v82-client-side-data-protection) | [617-524 Do not store sensitive data on client (browser) storage](https://www.opencre.org/cre/617-524)\n[v4.0.3-8.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v82-client-side-data-protection) | [046-257 Clear authentication data from client storage](https://www.opencre.org/cre/046-257)\n[v4.0.3-8.3.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [186-540 Do not expose data through HTTP verb](https://www.opencre.org/cre/186-540)\n[v4.0.3-8.3.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [762-451 Ensure users can remove or export their data](https://www.opencre.org/cre/762-451)\n[v4.0.3-8.3.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [082-327 Inform users clearly about the collection and use of personal data, and use it only after opt-in consent.](https://www.opencre.org/cre/082-327)\n[v4.0.3-8.3.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [227-045 Identify sensitive data and subject it to a policy](https://www.opencre.org/cre/227-045)\n[v4.0.3-8.3.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [015-063 Log access to sensitive data](https://www.opencre.org/cre/015-063)\n[v4.0.3-8.3.6](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [715-304 Zeroize sensitive information in memory after use](https://www.opencre.org/cre/715-304)\n[v4.0.3-8.3.7](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [504-340 Encrypt sensitive data with algorithms that provide both confidentiality and integrity](https://www.opencre.org/cre/504-340)\n[v4.0.3-8.3.8](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data) | [268-272 Classify personal data regarding retention so that old or outdated data is deleted](https://www.opencre.org/cre/268-272)\n[v4.0.3-9.1.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v91-client-communication-security) | [745-045 Do not fall back to insecure protocols in TCP](https://www.opencre.org/cre/745-045)\n[v4.0.3-9.1.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v91-client-communication-security) | [767-701 Verify strong TLS algorithms by testing](https://www.opencre.org/cre/767-701)\n[v4.0.3-9.1.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v91-client-communication-security) | [248-646 Disable insecure SSL/TLS versions](https://www.opencre.org/cre/248-646)\n[v4.0.3-9.2.1](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v92-server-communication-security) | [430-636 Verify TLS certificates and trust chain](https://www.opencre.org/cre/430-636)\n[v4.0.3-9.2.2](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v92-server-communication-security) | [636-854 Encrypt all communications](https://www.opencre.org/cre/636-854)\n[v4.0.3-9.2.3](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v92-server-communication-security) | [605-735 Authenticate all external connections](https://www.opencre.org/cre/605-735)\n[v4.0.3-9.2.4](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v92-server-communication-security) | [537-367 Enable certification revocation](https://www.opencre.org/cre/537-367)\n[v4.0.3-9.2.5](https://github.com/OWASP/ASVS/blob/v4.0.3/4.0/en/0x17-V9-Communications.md#v92-server-communication-security) | [668-364 Log TLS connection failures](https://www.opencre.org/cre/668-364)\n</pre>\n", "timestamp": "2025-10-24T11:39:43.572821"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x01-Frontispiece.md", "content": "# Frontispiece\n\n## Über diesen Standard\n\nDer Application Security Verification Standard ist eine Sammlung von Anforderungen und Tests an die Sicherheit von Anwendungen, die Architekten, Entwickler, Sicherheitsexperten, Toolhersteller und Verbraucher verwenden können, um sichere Anwendungen zu definieren, zu erstellen, zu testen und zu verifizieren.\n\n## Copyright and License\n\nVersion 4.0.3, Oktober 2021\n\n![license](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. Dieses Dokument wird lizensiert unter [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/). Für jedwede Wiederverwendung oder Verbreitung müssen die Lizenzbedingungen dieses Dokumentes an die jeweiligen Dritten kommuniziert werden.\n\n## Projektleitung\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Hauptautoren\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Weitere Autoren und Reviews von\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\nSollte ein Dank fehlen, eröffne bitte ein Ticket bei GitHub, so dass er in künftigen Updates berücksichtigt werden kann.\n\nDer Application Security Verification Standard 4.0 wurde von denjenigen aufgebaut, die bei ASVS 1.0 im Jahre 2008 bis 3.0 im Jahre 2016 mitgewirkt haben. Viele der Struktur- und Prüfungselemente, die im heutigen ASVS immer noch vorhanden sind, wurden ursprünglich von Mike Boberski, Jeff Williams und Dave Wichers geschrieben Es gibt aber noch viele andere Mitwirkende. Dank all denen, die sich bisher eingebracht haben. Für die umfassende Liste aller, die Beiträge zu früheren Versionen geleistet haben, verweisen wir auf die jeweilige Vorversion.\n", "timestamp": "2025-10-24T11:39:43.946148"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x02-Preface.md", "content": "# Vorwort\n\nWillkommen zum Application Security Verification Standard (ASVS) Version 4.0. Der ASVS ist eine von der Community gesteuerte Initiative, die Rahmenbedingungen für Sicherheitsanforderungen und -maßnahmen auf Anwendungsebene schaffen will. Ihr Schwerpunkt liegt auf der Definition der funktionalen und nicht funktionalen Sicherheitsmaßnahmen, die beim Entwerfen, Entwickeln und Testen moderner Webanwendungen und Webservices erforderlich sind.\n\nVersion 4.0.3 ist das dritte kleine Update der Version 4.0. Es bereinigt Rechtschreibfehler und beschreibt Anforderungen deutlicher, ohne jedoch wesentliche Änderungen, wie das Ändern, Verschärfen oder Hinzufügen von Anforderungen, einzuführen. An einigen Stellen, an denen wir es für geboten hielten, haben wir Anforderungen abgeschwächt. Einige redundante Anforderungen sind entfallen, jedoch ohne neu zu nummerieren.\n\nASVS v4.0 ist das Ergebnis gemeinschaftlicher Anstrengungen und des Feedbacks der Branche der letzten zehn Jahre. Wir haben versucht, die Anwendung des ASVS für viele unterschiedlich geartete Anwendungsfälle und für die Dauer jedes sicheren Softwareentwicklungszyklus einfacher zu gestalten.\n\nWir gehen daher davon aus, dass es wohl nie eine 100%ige Einigung über den Inhalt eines Webanwendungsstandards, einschließlich des ASVS, geben wird. Risikoanalyse ist in gewissem Maße immer subjektiv. Es ist eine Herausforderung diese mit einen universellem und für alle gleichen Standard zu verallgemeinern. Wir hoffen jedoch, dass diese neue Version einen Schritt in die richtige Richtung darstellt und die Konzepte verbessert, die in diesem Standard eingeführt wurden.\n\n## Was ist neu in Version 4.0\n\nDie wichtigste Änderung in dieser Version ist die Annahme der NIST 800-63-3-Richtlinien zur digitalen Identität, mit denen moderne, evidenzbasierte und erweiterte Authentifizierungsmaßnahmen eingeführt werden. Obwohl wir einen gewissen Widerstand bei der Anpassung an einen erweiterten Authentifizierungsstandard erwarten, halten wir es für wesentlich, dass Standards angepasst werden, vor allem wenn ein anderer angesehener Anwendungssicherheitsstandard evidenzbasiert ist.\n\nInformationssicherheitsstandards sollten versuchen, die Anzahl der spezifischen Anforderungen zu minimieren, damit konforme Organisationen nicht über konkurrierende oder inkompatible Maßnahmen entscheiden müssen. Die OWASP Top 10 2017 und nun auch der OWASP Application Security Verification Standard sind jetzt in Bezug auf Authentifizierung und Sessionmanagement an NIST 800-63 angepasst worden. Wir ermutigen andere Normungsgremien, mit uns, NIST und anderen zusammenzuarbeiten, um allgemein anerkannte Maßnahmen der Anwendungssicherheit zu erarbeiten, wodurch die Sicherheit maximiert und Compliancekosten minimiert werden.\n\nIm ASVS 4.0 wurde komplett neu durchnummeriert. Dadurch konnten wir die Lücken weggefallener Kapitel schließen und längere Kapitel neu unterteilen. Weiterhin minimiert es die Anzahl der Maßnahmen, die vom Entwickler oder Team einzuhalten sind. Wenn eine Anwendung beispielsweise kein JWT verwendet, so gilt der gesamte Abschnitt zu JWT für deren Sessionmanagement nicht.\n\nWir haben eine umfassende Zuordnung zur Common Weakness Enumeration (CWE), eine der am häufigsten gewünschten Funktionsanforderungen, die wir im letzten Jahrzehnt hatten, neu eingeführt. Mit der CWE-Zuordnung können Toolhersteller und Benutzer von Software zum Schwachstellenmanagement die Ergebnisse anderer Tools und früherer ASVS-Versionen abgleichen. Um Platz für den CWE-Eintrag zu schaffen, haben wir die Spalte „Seit“ entfernt. Sie ist in der neuen Nummerierung auch weniger sinnvoll. Nicht jeder Anforderung, z. B. sehr generischen, konnte eine CWE zugeordnet werden. Da CWE sehr vielfältig ist, haben wir versucht, die am meisten verwendete und nicht unbedingt die genaueste Übereinstimmung zu verwenden. Wir begrüßen die laufende Diskussion mit der CWE-Community, diese Lücke im Allgemeinen zu schließen.\n\nWir haben uns bemüht, die Anforderungen in Bezug auf die OWASP Top 10 2017 und die OWASP Proactive Controls 2018 umfassend zu erfüllen und zu übertreffen. Da die OWASP Top 10 2017 lediglich das Mindestmaß zur Vermeidung von Fahrlässigkeit darstellt, haben wir bewusst alle Anforderungen außer denen der spezifischen Logging Top 10 zu Maßnahmen der Stufe 1 gemacht. Dies vereinfacht die Anpassung an den derzeitigen Sicherheitsstandard für diejenigen, die OWASP Top 10 übernehmen.\n\nASVS 4.0 Stufe 1 soll die Anforderungen von PCI DSS 3.2.1, Abschnitt 6.5 für Anwendungsdesign, Programmierung, Tests, Überprüfungen von sicheren Codes und Penetrationstests vollständig abdecken. Daher wurden der Pufferüberlauf sowie die unsicheren Speicheroperationen in V5 und unsichere speicherbezogene Compilierflags in V14 zusätzlich zu den bestehenden Anforderungen für die Verifizierung von Anwendungen und Webservices aufgenommen.\n\nWir haben die Umstellung des ASVS von monolithischen, ausschließlich serverseitigen Maßnahmen auf Sicherheitsmaßnahmen für alle modernen Anwendungen und APIs abgeschlossen. In Zeiten funktionaler Programmierung, serverloser API, Mobiltelefon, Cloud, Containern, CI / CD und DevSecOps, Föderation und mehr können wir die moderne Anwendungsarchitektur nicht länger ignorieren. Moderne Anwendungen werden ganz anders gestaltet als diejenigen, die zur Zeit der Veröffentlichung des ursprünglichen ASVS im Jahr 2009 erstellt wurden. Dar ASVS muss immer weit in die Zukunft schauen, damit wir unserer Hauptzielgruppe - den Entwicklern - fundierte Ratschläge geben können. Wir haben alle Anforderungen geändert oder gestrichen, die davon ausgehen, dass Anwendungen auf Systemen ausgeführt werden, die einer einzelnen Organisation gehören.\n\nAufgrund der Größe des ASVS 4.0 sowie unseres Ziels, den ASVS als Basis aller anderen ASVS-Ausarbeitungen zu benutzen, haben wir den mobilen Bereich zugunsten des Mobile Application Security Verification Standard (MASVS) eingestellt. Der Anhang zum Internet of Things (IoT) wird in einem künftigen ASVS IoT bei der Pflege des OWASP IoT-Projektes erscheinen. Wir haben eine frühe Vorschau des ASVS IoT in Anhang C aufgenommen. Wir danken sowohl dem OWASP Mobile Team als auch dem OWASP IoT Projektteam für ihre bei ASVS geleistete Unterstützung und freuen uns darauf, in Zukunft bei der Erstellung ergänzender Standards mit ihnen zusammenzuarbeiten.\n\nSchließlich haben wir weniger wirksame Maßnahmen bereinigt. Im Laufe der Zeit ist der ASVS zu einer umfangreichen Ansammlung von Maßnahmen angewachsen, die aber nicht alle gleich gut sind. Die Bereinigung von Anforderungen mit nur geringer Auswirkung könnte künftig noch weiter gehen. In einer zukünftigen Ausgabe des ASVS wird das Common Weakness Scoring System (CWSS) dazu beitragen, die wirklich wichtigen Maßnahmen weiter zu priorisieren.\n\nAb Version 4.0 wird sich der ASVS ausschließlich darauf konzentrieren, der führende Webanwendungs- und Webservicestandard zu sein, welcher die traditionelle und moderne Anwendungsarchitektur sowie agile Sicherheitspraktiken und die DevSecOps-Kultur abdeckt.\n", "timestamp": "2025-10-24T11:39:44.036098"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x03-Using-ASVS.md", "content": "# Verwendung des ASVS\n\nDer ASVS hat die zwei Hauptziele:\n\n* Organisationen bei der Entwicklung und Pflege sicherer Anwendungen zu unterstützen.\n* Anbietern von Sicherheitsdienstleistungen oder -werkzeugen und deren Kunden die Möglichkeit zu geben, ihre Anforderungen und Angebote aufeinander abzustimmen.\n\n## Stufen zur Verifizierung der Anwendungssicherheit\n\nDer Application Security Verification Standard definiert drei Stufen der Sicherheitsverifikation, wobei jede Stufe an Tiefe zunimmt.\n\n* Stufe 1 ist für geringe Sicherheitsanforderungen gedacht und lässt sich mittels Pentests prüfen.\n* Stufe 2 ist für Anwendungen, die sensible Daten enthalten und diese schützen müssen. Das ist die empfohlene Stufe für die meisten Anwendungen.\n* Stufe 3 ist für die kritischsten Anwendungen, z. B. solche, die hochwertige Transaktionen durchführen, sensible medizinische Daten enthalten oder aus anderen Gründen ein Höchstmaß an Vertrauen erfordern.\n\nJede Stufe des ASVS enthält eine Liste von Sicherheitsanforderungen. Jede dieser Anforderungen kann auch auf sicherheitsspezifische Merkmale und Fähigkeiten abgebildet werden, die von den Entwicklern in die Software eingebaut werden müssen.\n\n![ASVS Levels](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"ASVS Stufen\")\n\nBild 1 - Stufen des OWASP Application Security Verification Standard 4.0\n\nStufe 1 ist die einzige Stufe, die sich komplett mittels Pentests prüfen lässt. Alle anderen Stufen benötigen Zugang zu Dokumentation, Quellcode, Konfiguration und den am Entwicklungsprozess beteiligten Personen. Jedoch stellen Black Box Tests ohne Dokumentation und ohne Quellen keine wirksame Absicherung dar. Sie müssen langfristig ergänzt werden. Böswillige Angreifer haben sehr viel Zeit. Die meisten Penetrationstests hingegen sind innerhalb von wenigen Wochen abgeschlossen. Die Verteidiger müssen alle Sicherheitsmaßnahmen umsetzen, alle Schwachstellen finden und beheben sowie böswillige Akteure innerhalb einer angemessenen Zeit aufspüren und Gegenmaßnahmen ergreifen. Böswillige Akteure haben im Wesentlichen unendlich viel Zeit und benötigen nur eine einzige Lücke in der Verteidigung, eine einzige Schwachstelle, um erfolgreich zu sein. Black Box Tests, die oft am Ende der Entwicklung schnell oder gar nicht durchgeführt werden, sind völlig ungeeignet, dieser Asymmetrie gerecht zu werden.\n\nDie letzten 30 Jahre haben gezeigt, dass Black Box Tests immer wieder kritische Sicherheitsprobleme übersehen, welche direkt zu weiteren, massiveren Problemen geführt haben. Wir befürworten ausdrücklich den Einsatz einer breiten Palette von Maßnahmen zur Gewährleistung und Verifizierung der Sicherheit, einschließlich des Ersatzes der Penetrationstests durch quellcodegeführte (hybride) Penetrationstests auf Stufe 1, mit vollem Zugang zu den Entwicklern und der Dokumentation während des gesamten Entwicklungsprozesses. Die Finanzaufsichtsbehörden dulden keine externen Finanzprüfungen ohne Zugang zu den Büchern, zu Stichproben von Geschäftsvorgängen oder zu den Personen, welche die Prüfungen durchführen. Derselbe Standard an Transparenz muss von der Industrie und den Regierungen auch im Bereich der Softwareentwicklung gefordert werden.\n\nWir befürworten ausdrücklich die Verwendung von Sicherheitstools innerhalb des Entwicklungsprozesses. DAST- und SAST-Tools können in die Buildpipeline eingebunden werden, um leicht zu findende Sicherheitsprobleme aufzuspüren, die niemals vorhanden sein dürfen.\n\nAutomatisierte Tools und Onlinescans können höchsten nur noch die Hälfte des ASVS ohne menschliches Zutun erfassen. Ist eine umfassende Testautomatisierung für jeden Buildprozess erforderlich, wird eine Kombination aus benutzerdefinierten Unit- und Integrationstests zusammen mit den vom Buildprozess veranlassten Onlinescans verwendet. Mängel der Geschäftslogik und der Zugriffskontrolle lassen sich nur mit menschlicher Hilfe testen, am besten in Unit- und Integrationstests.\n\n## Verwendung dieses Standards\n\nEine der besten Möglichkeiten, den Application Security Verification Standard zu nutzen, ist seine Verwendung als Vorlage für die Erstellung einer Checkliste für Anforderungen zur sicheren Softwareentwicklung, die speziell auf Ihre Anwendung, Plattform oder Organisation zugeschnitten ist. In dem Sie die Anforderungen des ASVS auf Ihre Anwendungsfälle passend zuschneiden, setzen Sie den Schwerpunkt auf die Sicherheitsanforderungen, die für Ihre Projekte und Umgebungen am wichtigsten sind.\n\nZu den Sicherheitszielen aller Stufen gehören die Gewährleistung der Vertraulichkeit (z.B. Verschlüsselung), der Integrität (z.B. Transaktionen, Eingabevalidierung), der Verfügbarkeit (z.B. ordnungsgemäße Lastverteilung), der Authentifizierung (auch zwischen Systemen), der Nichtabstreitbarkeit, der Autorisierung und der Protokollierung.\n\n### Stufe 1 - Erste Schritte oder das absolute Minimum\n\nEine Anwendung erreicht ASVS Stufe 1, wenn sie einen ausreichenden Schutz gegen leicht zu entdeckende Schwachstellen bietet, die auch in den OWASP Top 10 und anderen ähnlichen Checklisten aufgeführt sind.\n\nStufe 1 ist das für alle Anwendungen erforderliche absolute Minimum. Sie ist auch nützlich als erster Schritt eines mehrstufigen Prozesses oder für den Fall, wenn Anwendungen keine sensiblen Daten verarbeiten und daher nicht die strengeren Anforderungen der Stufen 2 oder 3 benötigen. Anforderungen der Stufe 1 können entweder automatisch durch Tools oder manuell ohne Zugriff auf den Quellcode überprüft werden.\n\nBedrohungen auf Stufe 1 gehen von Angreifern aus, die einfache und wenig aufwendige Techniken verwenden, um leicht zu findende und leicht ausnutzbare Schwachstellen zu ermitteln. Sie ist ungeeignet zur Abwehr entschlossener Angreifer, die die Anwendung gezielt ins Visier nehmen. Wenn Ihre Anwendung hochwertige Daten verarbeitet, werden Sie kaum mit einer Überprüfung der Stufe 1 zufrieden sein.\n\n### Stufe 2 – Die meisten Anwendungen\n\nEine Anwendung erreicht ASVS Level 2 (oder Standard), wenn sie die meisten Risiken, die heutzutage mit dem Einsatz von Software verbunden sind, angemessen abwehrt.\n\nDabei wird sichergestellt, dass Sicherheitsmaßnahmen wirksam umgesetzt sind. Stufe 2 eignet sich in der Regel für Anwendungen, die wichtige Geschäftsvorgänge abwickeln, einschließlich solcher, die Informationen aus dem Gesundheitswesen verarbeiten, geschäftskritische oder sensible Funktionen umsetzen oder andere sensible Vermögenswerte verarbeiten. Sie eignet sich auch für Branchen, in denen Integrität ein kritischer Aspekt zum Schutz ihres Geschäfts ist, wie z. B. die Spieleindustrie, um Betrügern und Gamehacks entgegenzuwirken.\n\nMaßnahmen zum Schutz der Anwendung auf Stufe 2 gehen in der Regel von geschickten und motivierten Angreifern aus, die sich auf bestimmte Ziele konzentrieren und Tools und Techniken einsetzen, die sehr versiert und wirksam Schwachstellen in Anwendungen entdecken und ausnutzen.\n\n### Stufe 3 - Hoher Wert, hohe Zuverlässigkeit oder hohe Sicherheit\n\nASVS Stufe 3 (oder Erweitert) ist die höchste Verifizierungsstufe innerhalb des ASVS. Diese Stufe ist in der Regel Anwendungen vorbehalten, die ein erhebliches Maß an geprüften Sicherheitsniveau erfordern. Diese sind z.B. im militärischen Bereich, dem Gesundheitssektor oder kritischen Infrastrukturen zu finden.\n\nOrganisationen können ASVS Stufe 3 bei Anwendungen benötigen, die kritische Funktionen ausführen und bei denen ein Ausfall die Betriebsabläufe der Organisation oder sogar ihre Überlebensfähigkeit erheblich beeinträchtigen könnte. Eine Anwendung erreicht ASVS-Stufe 3, wenn sie angemessen vor fortgeschrittenen Schwachstellen geschützt ist und die Grundsätze eines guten Sicherheitsdesigns aufweist.\n\nEine Prüfung auf ASVS-Stufe 3 erfordert eine tiefgründigere Analyse der Architektur, der Programmierung und der Testprozesse als alle anderen Ebenen. Eine sichere Anwendung wird auf sinnvolle Weise modularisiert. So können Resilienz, Skalierbarkeit und vor allem Kapselung leichter umgesetzt werden, da sich jedes Modul selbst um seine eigenen Sicherheitsmaßnahmen kümmern kann (Defense in Depth). Die Umsetzung dieser Maßnahmen muss ordnungsgemäß dokumentiert werden.\n\n## Auswahl der ASVS-Stufen in der Praxis\n\nUnterschiedliche Angreifer haben unterschiedliche Beweggründe. Einige Branchen verfügen über einzigartige Informations- und Technologiewerte sowie branchenspezifische gesetzliche Regulierungen.\n\nWir raten Organisationen dringend dazu, ihre spezifischen Risikomerkmale auf der Grundlage ihres Geschäftsmodells eingehend zu prüfen. Auf dieser Basis wählen sie dann die geeignete ASVS-Stufe aus.\n\n## Referenzen auf Anforderungen des ASVS\n\nJede Anforderung des ASVS wird mittels `<Kapitel>.<Abschnitt>.<Laufende Nummer>` identifiziert, z.B.: `1.11.3`.\n- Das `<Kapitel>` gibt Anforderungen das Kapitel des Standards an, dem die Anforderung entstammt, z.B.: alle Anforderungen mit der Nummer `1.#.#` sind an die Architektur.\n- Der `<Abschnitt>` referenziert auf den Abschnitt, in dem die Anforderung beschrieben wird, z.B.: alle Anforderungen mit der Nummer `1.11.#` beziehen sich auf die architekturellen Anforderungen an die Geschäftslogik.\n- Innerhalb der Abschnitte gibt die `<Laufende Nummer>` schließlich die konkrete Anforderung an, so steht `1.11.3` in der Version 4.0.3 dieses Standards für:\n\n> Prüfen Sie, dass alle geschäftskritischen Abläufe, einschließlich der Authentifizierung, des Sessionmanagements und der Zugriffssteuerung thread-sicher und sicher gegen TOCTOU Race Conditions sind.\n\nDa sich die Kennungen der Anforderungen von Version zu Version ändern, sollten andere DOkumente oder Werkzeuge das Format `v<Version>-<Kapitel>.<Abschnitt>.<Laufende Nummer>` nutzen. 'Version' ist die Versionsnummer des ASVS, z.B.: ist `v4.0.3-1.11.3` die dritte Anforderung des Abschnittes Architektur der Geschäftslogik im Kapitel Architektur, Design und Threat Modeling der Version 4.0.3. Das kann zu `v<Version>-<AnforderungsID>` zusammengefasst werden.\n\nHinweis: Das `v` vor der Versionsnummer ist ein Kleinbuchstabe.\n\nFalls AnforderungsIDs ohne die Angabe der Version genutzt werden, so ist anzunehmen, dass die aktuelle Version des ASVS gemeint ist. Da der Standard wächst, sollte die Version stets angegeben werden.\n\nSo ist z.B.: `v4.0.3-1.11.3` die dritte Anforderung des Abschnittes 'Architektur der Geschäftslogik' im Kapitel 'Architektur, Design und Threat Modeling' des ASVS in Version 4.0.3: Prüfen Sie, dass alle geschäftskritischen Abläufe, einschließlich der Authentifizierung, des Sessionmanagements und der Zugriffssteuerung thread-sicher und sicher gegen TOCTOU Race Conditions sind.\n\nWerden die Versionsangaben weggelassen, bezieht sich die Referenz auf die aktuelle Version des ASVS. Da der Standard sich ändert und stetig wächst, ist dies problematisch. Die Versionsangabe sollte also stets angegeben werden.\n\nDie ASVS Anforderungen werden in CSV, JSON und anderen Formaten zur Verfügung gestellt. Dies unterstützt die maschinelle Verarbeitung.\n", "timestamp": "2025-10-24T11:39:44.151476"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x04-Assessment_and_Certification.md", "content": "# Zertifizierung\n\n## ASVS-Zertifizierungen und Gütesiegel\n\nOWASP ist eine herstellerneutrale, gemeinnützige Organisation. Sie zertifiziert derzeit keine Hersteller, Prüfstellen oder Software.\n\nAlle derartigen Versicherungen, Gütesiegel oder Zertifizierungen werden von OWASP nicht offiziell überprüft, registriert oder zertifiziert. Jede Organisation sollte in Bezug auf Aussagen eines Dritten, der behauptet, ASVS-zertifiziert zu sein, vorsichtig sein.\n\nDies ist jedoch kein Verbot, solche Assurancedienstleistungen anzubieten, solange sie keine offizielle OWASP-Zertifizierung geltend machen.\n\n## Leitfaden für zertifizierende Organisationen\n\nDer Application Security Verification Standard kann als Open Book Prüfung von Anwendungen verwendet werden, was den offenen und ungehinderten Zugang zu Schlüsselressourcen wie Architekten und Entwicklern, Projektdokumentation, Quellcode, authentifiziertem Zugang zu Testsystemen, einschließlich des Zugangs zu einem oder mehreren Benutzerkonten in jeder Rolle, insbesondere für L2- und L3-Verifikationen einschließt.\n\nKlassischerweise werden Penetrationstests und Security Code Reviews so dokumentiert, dass nur fehlgeschlagene Tests im Abschlussbericht erscheinen. Eine zertifizierende Organisation muss jedoch in jedem Bericht den Umfang der Verifizierung angeben. Insbesondere, wenn eine Schlüsselkomponente außerhalb des Umfangs liegt, wie z.B. die SSO-Authentifizierung sowie eine Zusammenfassung der Verifizierungsergebnisse, einschließlich der bestandenen und fehlgeschlagenen Tests, mit klaren Angaben zur Korrektur der gefundenen Probleme.\n\nBestimmte Anforderungen des ASVS sind möglicherweise nicht auf die zu testende Anwendung anwendbar. Wenn Sie beispielsweise Ihren Kunden eine zustandslose API ohne eine Clientimplementierung zur Verfügung stellen, sind viele der Anforderungen im V3 Session Management nicht direkt anwendbar. In solchen Fällen kann eine zertifizierende Organisation immer noch die volle ASVS-Konformität bestätigen, muss aber im Bericht klar einen Grund für die Nichtanwendbarkeit der ausgeschlossenen Verifikationsanforderungen angeben.\n\nDas Aufbewahren von detaillierten Arbeitspapieren, Screenshots, Filmen, Skripten zur zuverlässigen wiederholten Auswertung eines Tests sowie von elektronischen Testaufzeichnungen, wie z. B. Proxyprotokollen und zugehörigen Notizen, wie z. B. einer CleanUp-List, gilt als gängige Praxis. Diese können für kritische Entwickler als Beleg für die Ergebnisse hilfreich sein. Es reicht also nicht aus, einfach ein Tool laufen zu lassen und über die Fehler zu berichten: Dies liefert keinen ausreichenden Beweis dafür, dass alle Probleme auf einer Zertifizierungsebene gründlich getestet und geprüft worden sind. In Streitfällen sollte es ausreichende Nachweise geben, um zu belegen, dass jede einzelne verifizierte Anforderung tatsächlich getestet wurde.\n\n### Prüfmethode\n\nZertifizierende Organisationen können die geeigneten Prüfmethoden frei wählen, sollten diese aber in einem Bericht angeben.\n\nJe nach der zu testenden Anwendung und der Anforderung können unterschiedliche Testmethoden verwendet werden: Die Wirksamkeit der Eingabevalidierung einer Anwendung kann beispielsweise sowohl mit einem manuellen Penetrationstest als auch mit Hilfe von Quellcodeanalysen geprüft werden.\n\n#### Die Rolle automatisierter Sicherheitstesttools\n\nDer Einsatz von automatisierten Penetrationstests wird empfohlen, um eine möglichst hohe Abdeckung zu erreichen.\n\nDie ASVS-Verifizierung kann jedoch nicht ausschließlich mit automatisierten Penetrationstesttools durchgeführt werden. Während die meisten Anforderungen in L1 mit automatisierten Tests durchgeführt werden kann, ist die Mehrheit der Anforderungen der Stufen 2 und 3 nicht für automatisierte Penetrationstests geeignet.\n\nDie Grenzen zwischen automatisierten und manuellen Tests verschwimmen mit zunehmender Reife der Anwendungssicherheitsindustrie immer mehr. Automatisierte Tools werden häufig von Experten angepasst, und manuelle Tester nutzen oft eine Vielzahl von automatisierten Werkzeugen.\n\n#### Die Rolle automatisierter Sicherheitstests\n\nIn Version 4.0 haben wir uns entschieden, L1 komplett penetrationstestfähig zu machen, ohne Zugriff auf Quellcode, Dokumentation oder Entwickler. Zwei Protokollierungselemente, die zur Einhaltung der OWASP Top 10 2017 A10 erforderlich sind, erfordern Interviews, Screenshots oder eine andere Sammlung von Nachweisen, wie sie auch in der OWASP Top 10 2017 erforderlich sind. Das Testen ohne Zugang zu den notwendigen Informationen ist jedoch keine ideale Methode der Sicherheitsüberprüfung, da die Quelle nicht überprüft wird, Bedrohungen und fehlende Maßnahmen nicht identifiziert werden und ein weitaus gründlicherer Test in kürzerer Zeit nicht durchgeführt wird.\n\nZur Durchführung einer Prüfung auf den Stufen 2- oder 3 ist der Zugang zu Entwicklern, der Dokumentation, dem Code sowie der Zugang zu einer Testanwendung mit Testdaten erforderlich. Penetrationstests, die auf diesen Ebenen durchgeführt werden, erfordern diese Zugriffsebene, die wir „hybride Überprüfungen“ oder „hybride Penetrationstests“ nennen.\n\n## Andere Verwendungszwecke für den ASVS\n\nNeben der Verwendung zur Bewertung der Sicherheit einer Anwendung haben wir eine Reihe anderer möglicher Anwendungen für den ASVS identifiziert.\n\n### Detaillierte Anleitung zur Sicherheitsarchitektur\n\nEine der häufigeren Verwendungen des Application Security Verification Standards ist seine Verwendung als Ressource für Sicherheitsarchitekten. So fehlt z. B. in der Sherwood Applied Business Security Architecture (SABSA) eine Menge an Informationen, die für eine gründliche Überprüfung der Anwendungssicherheitsarchitektur erforderlich sind. Der ASVS kann verwendet werden, um diese Lücken zu füllen, indem Sicherheitsarchitekten bessere Maßnahmen für häufige Probleme des Datenschutzes oder der Eingabevalidierungsstrategien wählen können.\n\n### Ersatz für Standardchecklisten für sichere Softwareentwicklung\n\nViele Organisationen können von der Übernahme des ASVS profitieren, indem sie sich für eine der drei Stufen entscheiden, oder den ASVS domänenspezifisch anpassen. Wir befürworten diese Anpassungen, solange die Rückverfolgbarkeit gewährleistet ist. Wenn also eine Anwendung die Anforderung 4.1 bestanden hat, bedeutet dies dasselbe für die angepassten Varianten wie für den Standard aus dem sie sich entwickelt haben.\n\n### Als Leitfaden für automatisierte Unit- und Integrationstests\n\nDer ASVS ist so konzipiert, dass er in hohem Maße testbar ist, mit Ausnahme der Anforderungen an die Architektur und den bösartigen Code. Durch die Erstellung von Unit- und Integrationstests, die spezifische und relevante Testfälle für Fuzz-Tests und Missbrauchsfälle prüfen, wird die Anwendung mit jedem Build nahezu selbstverifizierend. Beispielsweise können zusätzliche Tests für die Testsuite eines Logincontrollers erstellt werden, der die Parameter des Benutzernamens auf gängige Standardbenutzernamen, das Erraten von Benutzernamen, Brute Force Angriffe, LDAP- und SQL-Injektion und XSS testet. In ähnlicher Weise sollte ein Test des übermittelten Passwortes auf gängige Passwörter, die Passwortlänge, Null Byte Injection, Entfernen des Parameters, XSS, etc. umfassen.\n\n### Für Schulungen zur sicheren Softwareentwicklung\n\nDer ASVS kann auch dazu verwendet werden, um Merkmale sicherer Software zu definieren. Viele Kurse zur sicheren Softwareentwicklung sind tatsächlich Kurse „Ethisches Hacking mit einem Hauch von Softwareentwicklung“. Sie orientieren sich gern an den OWASP Top 10 der Programmiersünden. Wissen über Hacking hilft den Entwicklern nicht unbedingt, einen sichereren Code zu schreiben. Anstelle dieses negativen Ansatzes sollten Kurse für sichere Softwareentwicklung den ASVS, mit dem Schwerpunkt auf seinen Sicherheitsmaßnahmen, verwenden.\n\n### Als Treiber für agile Anwendungssicherheit\n\nDer ASVS kann in einem agilen Entwicklungsprozess als Rahmen verwendet werden, um spezifische Aufgaben zu definieren, die vom Team zum Erhalt eines sicheren Produkts implementiert werden müssen. Eine Vorgehensweise wäre: Man beginnt mit Stufe 1 und verifiziert die spezifische Anwendung oder das System gemäß Anforderungen des ASVS. Für fehlende Maßnahmen werden spezifische Tickets oder Aufgaben im Backlog generiert. Dies hilft bei der Priorisierung bestimmter Aufgaben (oder beim Grooming) und macht die Sicherheit im agilen Prozess sichtbar. Dies kann auch zur Priorisierung von Revisions- und Überprüfungsaufgaben in der Organisation verwendet werden. Bestimmte ASVS-Anforderungen können für ein bestimmtes Teammitglied Antrieb für eine Überprüfung, ein Refactoring oder eine Revision sein. Sie werden als „Offen“ im Backlog zur Abarbeitung aufgeführt.\n\n### Zur Beschaffung sicherer Software\n\nDer ASVS ist ein großartiger Rahmen, der bei der Beschaffung sicherer Software oder der Beschaffung von Entwicklungsdienstleistungen hilfreich ist. Der Käufer stellt die Anforderung, dass die Software, auf ASVS-Ebene X entwickelt wird und verlangt vom Verkäufer den entsprechenden Nachweis. Dies funktioniert gut, wenn es mit dem OWASP-Vertragsanhang für sichere Software kombiniert wird.\n", "timestamp": "2025-10-24T11:39:44.230594"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x10-V1-Architecture.md", "content": "# V1 Architektur, Design und Threat Modeling\n\n## Ziel\n\nIn vielen Organisationen ist die Sicherheitsarchitektur fast in Vergessenheit geraten. Die Tage des Enterprise Architekten sind im Zeitalter von DevSecOps vorbei. Der Bereich der Anwendungssicherheit muss aufholen, agile Sicherheitsprinzipien übernehmen und gleichzeitig wichtige Grundsätze der Sicherheitsarchitektur wieder in die Softwareentwicklung einführen. Architektur ist keine Implementierung, sondern die Art und Weise, über ein Problem nachzudenken, das potenziell viele verschiedene aber keine einzig richtige Antwort hat. Nur allzu oft wird Sicherheit zu unflexibel betrachtet, und man verlangt von den Entwicklern, den Code auf eine bestimmte Art und Weise zu schreiben, obwohl diese vielleicht eine viel bessere Möglichkeit kennen, das Problem zu lösen. Es gibt keine einzig richtige, einfache Lösung für die Architektur. Jeder, der anderes behauptet, tut dem Softwareengineering keinen Gefallen.\n\nEine spezifische Implementierung einer Webanwendung wird wahrscheinlich während ihrer gesamten Lebensdauer kontinuierlich überarbeitet, ihre Architektur hingegen wird sich kaum ändern, sondern sich nur langsam entwickeln. Die Sicherheitsarchitektur hingegen ist identisch - wir brauchen Authentifizierung heute, wir brauchen Authentifizierung morgen, und wir werden sie in fünf Jahren brauchen. Treffen wir heute fundierte Entscheidungen, können wir viel Aufwand, Zeit und Geld sparen, wenn wir architekturkonforme Lösungen auswählen und wiederverwenden. So wurde beispielsweise vor einem Jahrzehnt Mehrfaktorauthentifizierung nur selten implementiert.\n\nHätten Entwickler in einen einzigen, sicheren Identitätsprovider investiert, wie z.B. SAML Federated Identity, könnte der Identitätsprovider angepasst werden, um neue Anforderungen wie die Umsetzung des NIST 800-63 einzubeziehen, ohne die Schnittstellen der ursprünglichen Anwendung zu ändern. Wenn viele Anwendungen die gleiche Sicherheitsarchitektur und damit die gleiche Komponente nutzen, profitieren sie alle gleichzeitig von diesem Upgrade. SAML wird jedoch nicht immer die beste oder geeignetste Authentifizierungslösung bleiben - es muss möglicherweise gegen andere Lösungen ausgetauscht werden, wenn sich die Anforderungen ändern. Solche Änderungen sind entweder kompliziert und so kostspielig wie eine komplette Neuentwicklung oder ohne Sicherheitsarchitektur schlichtweg unmöglich.\n\nIn diesem Kapitel behandelt der ASVS die primären Aspekte jeder soliden Sicherheitsarchitektur: Verfügbarkeit, Vertraulichkeit, Integrität, Nichtabstreitbarkeit und Datenschutz. All diese Sicherheitsprinzipien müssen eingebaut sein und allen Anwendungen innewohnen. Es ist entscheidend, Sicherheit zeitig im Entwicklungsprozess zu integrieren. Das beginnt bei der Befähigung der Softwareentwickler mittels Checklisten für sichere Programmierung, Betreuung und Schulung. Es führt über Programmierung und Tests, dem Buildprozess, der Inbetriebnahme, der Konfiguration und dem Betrieb bis hin zu unabhängigen Tests, die sichern, dass alle Sicherheitsmaßnahmen vorhanden und funktionsfähig sind. Der letzte Schritt war früher alles, was wir als Branche getan haben, aber das reicht nicht mehr aus, wenn Entwickler mehrmals am Tag Änderungen in der Produktionsumgebung durchführen. Anwendungssicherheitsexperten müssen mit agilen Techniken Schritt halten, was bedeutet, dass sie Entwicklertools übernehmen, lernen zu programmieren und mit Entwicklern zusammenarbeiten müssen, anstatt das Projekt Monate später zu kritisieren, nachdem alle anderen bereits weitergemacht haben.\n\n## V1.1 Der sichere Softwareentwicklungszyklus\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.1.1** | Prüfen Sie, dass der SDLC die Sicherheit in allen Entwicklungsphasen berücksichtigt. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Prüfen Sie, dass für Designänderung oder Sprintplanung eine Bedrohungsanalyse stattfand, um Bedrohungen zu identifizieren, Gegenmaßnahmen zu planen und umzusetzen sowie passende Sicherheitstests zu planen. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Prüfen Sie, dass alle Userstories und alle Merkmale funktionale Sicherheitsanforderungen enthalten, z.B. „Als Benutzer sollte ich mein Profil anzeigen und bearbeiten können. Ich sollte nicht in der Lage sein, das Profil eines anderen anzusehen oder zu bearbeiten“. | | ✓ | ✓ | 1110 |\n| **1.1.4** | Prüfen Sie die Dokumentation und Erläuterung aller Sicherheitsgrenzen, Komponenten und wichtigen Datenflüsse der Anwendung. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Prüfen Sie die Definition und Sicherheitsanalyse der High Level Architektur der Anwendung und aller verbundenen Remoteservices. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Prüfen Sie, dass Sicherheitsmaßnahmen zentralisiert, einfach, geprüft, sicher und wiederverwendbar implementiert worden sind. Dies vermeidet doppelte, fehlende, unwirksame oder unsichere Maßnahmen. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Prüfen Sie die Verfügbarkeit einer Checkliste für die sichere Programmierung, Sicherheitsanforderungen, eines Leitfadens oder Richtlinien für alle Entwickler und Tester. | | ✓ | ✓ | 637 |\n\n## V1.2 Architektur der Authentifizierung\n\nBeim Entwurf der Authentifizierung spielt es keine Rolle, ob Sie über eine starke, hardwareunterstützte Mehrfaktorauthentifizierung verfügen, wenn ein Angreifer ein Konto zurücksetzen kann, indem er ein Callcenter anruft und auf allgemein bekannte Fragen antwortet. Beim Nachweis der Identität müssen alle Authentifizierungswege die gleiche Stärke haben.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.2.1** | Prüfen Sie die Nutzung spezifischer Betriebssystemkonten bzw. solcher mit minimalen Berechtigungen für alle Komponenten, Dienste und Server. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Prüfen Sie, dass die Kommunikation zwischen Anwendungskomponenten, einschließlich APIs, Middleware und Datenschichten, authentifiziert wird. Komponenten sollten die minimal notwendigen Berechtigungen haben. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Prüfen Sie, dass die Anwendung einen einzigen geprüften und sicheren Authentifizierungsmechanismus verwendet, der auf eine starke Authentifizierung erweitert werden kann und über ein ausreichendes Logging und Monitoring verfügt, um Einbrüche oder Missbrauch zu erkennen. | | ✓ | ✓ | 306 |\n| **1.2.4** | Prüfen Sie, dass alle Authentifizierungspfade und Identitätsmanagement-APIs eine einheitliche Stärke der Authentifizierung implementieren, so dass es keine schwächeren Alternativen pro Anwendungsrisiko gibt. | | ✓ | ✓ | 306 |\n\n## V1.3 Architektur des Sessionmanagements\n\nDies ist ein Platzhalter für zukünftige architektonische Anforderungen.\n\n## V1.4 Architektur der Zugriffskontrolle\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.4.1** | Prüfen Sie, dass Zugriffskontrollen von vertrauenswürdigen Stellen, wie z.B. Accesscontrol Gateways, Servern oder serverlosen Funktionen, ausgeführt werden. Implementieren Sie Zugriffskontrollen niemals am Client. | | ✓ | ✓ | 602 |\n| **1.4.2** | [GELÖSCHT, NICHT UMSETZBAR] | | | | |\n| **1.4.3** | [GELÖSCHT, DUPLIKAT VON 4.1.3] | | | | |\n| **1.4.4** | Prüfen Sie, dass die Anwendung mit einer einzigen und gut erprobten Zugriffssteuerung auf geschützte Daten und Ressourcen zugreift. Alle Anfragen müssen diesen einen Weg nutzen, um Kopieren und Einfügen oder unsichere Alternativpfade zu vermeiden. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Prüfen Sie, dass eine attribut- oder merkmalsbasierte Zugriffskontrolle verwendet wird, die die Berechtigung des Benutzers zum Zugriff auf ein Merkmal oder Datenelement und nicht nur seine Rolle prüft. Die Berechtigungen sollten weiterhin über Rollen vergeben werden. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Architektur des Ein- und Ausgabemanagements\n\nMit der Version 4.0 haben wir uns von dem Begriff „serverseitig“ als Synonym für Vertrauensgrenzen verabschiedet. Die Vertrauensgrenze spielt noch immer eine wichtige Rolle: Entscheidungen von nicht vertrauenswürdigen Clients können umgangen werden. Allerdings hat sich die Stelle, an der die Entscheidungen getroffen werden, bei heutigen Mainstreamarchitekturen dramatisch verändert. Wenn im ASVS der Begriff „vertrauenswürdige Serviceschicht“ verwendet wird, meinen wir daher jede vertrauenswürdige Stelle, unabhängig von ihrer Position, wie z.B. einen Mikroservice, eine serverlose API, serverseitig, eine vertrauenswürdige API auf einem Client, das über sichere Bootmechanismen verfügt, eine Partner- oder externe APIs und so weiter.\n\nDie Bezeichnung „nicht vertrauenswürdiger Client“ bezieht sich auf Frontendtechnologien, wie z.B. der Darstellungsschicht. Der Begriff „Serialisierung“ soll sich nicht nur Daten, wie Felder in JSON-Strukturen, beziehen sondern ebenso auf komplexe Objekte, welche Programmlogik enthalten können.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.5.1** | Prüfen Sie, dass die Ein- und Ausgabeanforderungen klar definieren, wie die Daten auf der Grundlage des Typs, des Inhalts und der anwendbaren Gesetze, Vorschriften und anderen Richtlinien zu verarbeiten sind. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Prüfen Sie, dass bei der Kommunikation mit nicht vertrauenswürdigen Clients keine Serialisierung verwendet wird. Ist dies nicht möglich, prüfen Sie, dass die Integrität geprüft und bei sensiblen Daten auch verschlüsselt wird, um Deserialisierungsangriffe oder Object Injection Angriffe zu verhindern. | | ✓ | ✓ | 502 |\n| **1.5.3** | Prüfen Sie, dass die Eingabevalidierung in einer vertrauenswürdigen Serviceschicht durchgesetzt wird. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Prüfen Sie, dass die Ausgabecodierung in der Nähe des oder durch den Interpreter erfolgt, für den sie bestimmt ist. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Architektur kryptographischer Maßnahmen\n\nAnwendungen müssen mit einer starken kryptographischen Architektur entworfen werden, um die Datenbestände gemäß ihrer Klassifizierung zu schützen. Alles zu verschlüsseln ist Verschwendung, nichts zu verschlüsseln ist fahrlässig. Es muss ein Gleichgewicht gefunden werden, in der Regel bei dem architektonischen oder High Level Design, den Designsprints oder den Architectural Spikes. Die sichere Implementierung kryptographischer Methoden, die nach und nach entworfen oder nachgerüstet werden, ist zwangsläufig viel teurer, als sie von Beginn an einzubauen.\n\nArchitektonische Anforderungen sind in der gesamten Codebasis integriert und lassen sich daher schwer in Unit- oder Integrationstests prüfen. Die architektonischen Anforderungen müssen in den Programmierstandards für die gesamten Programmierphase berücksichtigt werden und sollten während der Sicherheitsarchitektur, bei Peer- oder Code-Reviews oder bei Retrospektiven überprüft werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.6.1** | Prüfen Sie, dass es eine explizite Richtlinie für das Schlüsselmanagement gibt, und dass der Lebenszyklus eines kryptografischen Schlüssels konform zu einem Standard für das Schlüsselmanagement wie NIST SP 800-57 ist. | | ✓ | ✓ | 320 |\n| **1.6.2** | Prüfen Sie, dass Nutzer kryptografischer Dienste Schlüssel und andere Geheimnisse mit Hilfe von Schlüsseltresoren oder API-basierte Alternativen schützen. | | ✓ | ✓ | 320 |\n| **1.6.3** | Prüfen Sie, dass alle Schlüssel und Passwörter ersetzbar und Teil eines genau definierten Prozesses zur Neuverschlüsselung sensibler Daten sind. | | ✓ | ✓ | 320 |\n| **1.6.4** | Prüfen Sie, dass clientseitige Geheimnisse, wie symmetrische Schlüssel, Passwörter oder API-Token, architektonisch als unsicher betrachtet werden. Sie dürfen nicht zum Schutz sensibler Daten verwendet werden. | | ✓ | ✓ | 320 |\n\n## V1.7 Architektur von Fehlerbehandlung, Protokollierung und Audit\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.7.1** | Prüfen Sie, dass im gesamten System Herangehensweise und Protokollformat einheitlich sind. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Prüfen Sie, dass die Protokolle zur Analyse, Erkennung, Alarmierung und Eskalation sicher übertragen werden - vorzugsweise an ein eigenständiges System. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Architektonische Anforderungen zur Einhaltung des Datenschutzes\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.8.1** | Prüfen Sie, dass alle sensiblen Daten identifiziert und klassifiziert werden. | | ✓ | ✓ | |\n| **1.8.2** | Prüfen Sie, dass für alle Schutzklassen entsprechende Anforderungen existieren, z. B. an die Vertraulichkeit, die Integrität, Aufbewahrung, Datenschutz etc. und dass diese in der Architektur angewendet werden. | | ✓ | ✓ | |\n\n## V1.9 Architektur der Kommunikationsverbindungen\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.9.1** | Prüfen Sie, dass die Anwendung die Kommunikation zwischen Komponenten verschlüsselt, insbesondere wenn sich diese in verschiedenen Containern, Systemen, Standorten oder Cloudanbietern befinden. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Prüfen Sie, dass die Anwendungskomponenten die Authentizität beider Seiten einer Kommunikationsverbindung verifizieren, um Man-in-the-Middle-Angriffe zu verhindern. Beispielsweise sollten die Anwendungskomponenten TLS-Zertifikate und Zertifikatsketten verifizieren. | | ✓ | ✓ | 295 |\n\n## V1.10 Architektonische Anforderungen zum Schutz vor unbefugten Änderungen\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.10.1** | Prüfen Sie, dass das Quellcodeverwaltungssystem sicherstellt, dass Check-Ins mit Issues oder Änderungstickets einhergehen. Das Quellcodeverwaltungssystem sollte über eine Zugriffskontrolle und identifizierbare Benutzer verfügen, um Änderungen nachverfolgen zu können. | | ✓ | ✓ | 284 |\n\n## V1.11 Architektur der Geschäftslogik\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.11.1** | Prüfen Sie die Definition und Dokumentation aller Anwendungskomponenten auf die von ihnen bereitgestellten Fach- oder Sicherheitsfunktionen. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Prüfen Sie, dass alle geschäftskritischen Abläufe, inkl. der Authentifizierung, des Sessionmanagements und der Zugriffssteuerung stets synchronisiert sind. | | ✓ | ✓ | 362 |\n| **1.11.3** | Prüfen Sie, dass alle geschäftskritischen Abläufe, einschließlich der Authentifizierung, des Sessionmanagements und der Zugriffssteuerung thread-sicher und sicher gegen TOCTOU Race Conditions sind. | | | ✓ | 367 |\n\n## V1.12 Sicheres Datei Upload\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.12.1** | [GELÖSCHT, DUPLIKAT VON 12.4.1] | | | | |\n| **1.12.2** | Prüfen Sie, dass vom Benutzer hochgeladene Dateien - sofern sie angezeigt oder von der Anwendung heruntergeladen werden müssen - entweder durch Oktett-Stream-Downloads oder von einer nicht verwandten Domäne, wie z.B. einem Cloud File Storage Bucket, bereitgestellt werden. Implementieren Sie geeignete Sicherheitsmaßnahmen für Dateiinhalte, um das Risiko von Angriffen mit Hilfe der hochgeladenen Datei zu reduzieren. | | ✓ | ✓ | 646 |\n\n## V1.13 API-Architektur\n\nDies ist ein Platzhalter für zukünftige architektonische Anforderungen.\n\n## V1.14 Architektonische Anforderungen an die Konfiguration\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.14.1** | Prüfen Sie die Trennung von Komponenten unterschiedlicher Vertrauensstufen durch gut durchdachte Sicherheitsmaßnahmen, Firewallregeln, API-Gateways, Reverseproxies, cloudbasierte Sicherheitsgruppen o.ä. | | ✓ | ✓ | 923 |\n| **1.14.2** | Prüfen Sie, dass digitale Signaturen, vertrauenswürdige Verbindungen und vertrauenswürdige Downloadquellen verwendet werden, um Binärdaten auf Endgeräte zu verteilen. | | ✓ | ✓ | 494 |\n| **1.14.3** | Prüfen Sie, dass die Buildpipeline vor veralteten oder unsicheren Komponenten warnt und entsprechende Maßnahmen ergreift. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Prüfen Sie, dass die Buildpipeline einen Schritt enthält, um die sichere Deploymentversion der Anwendung automatisch zu erstellen und zu verifizieren, insbesondere wenn die Anwendungsinfrastruktur softwarebasiert ist, wie z. B. Cloudumgebungen. | | ✓ | ✓ | |\n| **1.14.5** | Prüfen Sie, dass Anwendungen auf der Netzwerkebene voneinander separiert sind, z.B. per Sandbox oder Container, um Angreifer auszubremsen und davon abzuhalten, andere Anwendungen anzugreifen, insbesondere wenn sie sensible Aktionen wie eine Deserialisierung durchführen. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Prüfen Sie, dass die Anwendung keine nicht unterstützten, unsicheren oder veralteten clientseitigen Technologien wie NSAPI-Plugins, Flash, Shockwave, ActiveX, Silverlight, NACL oder clientseitige Java-Applets verwendet. | | ✓ | ✓ | 477 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:44.312485"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x11-V2-Authentication.md", "content": "# V2 Authentifizierung\n\n## Ziel\n\nAuthentifizierung ist die Bestätigung einer Eigenschaft, wie z.B. der Identität einer Person oder eines Gerätes. Sie muss u.a. widerstandsfähig gegen Nachahmer sein und Passwörter sicher übertragen.\n\nAls der ASVS zum ersten Mal freigegeben wurde, waren Benutzername und Passwort die gebräuchlichste Form der Authentifizierung außerhalb von Hochsicherheitssystemen. Die Mehrfaktorauthentifizierung (MFA) wurde in Sicherheitskreisen allgemein akzeptiert, aber anderswo nur selten verlangt. Mit zunehmenden Passwortverletzungen wurde die Idee, dass Benutzernamen vertraulich und Passwörter unbekannt sind, als Sicherheitsmaßnahme unhaltbar. NIST 800‑63 betrachtet beispielsweise Benutzernamen und wissensbasierte Authentifizierung als öffentliche Informationen, SMS- und E-Mail-Benachrichtigungen als [\"eingeschränkte\" Authentifikatoren (restricted authenticators)](https://pages.nist.gov/800-63-FAQ/#q-b1) und Passwörter als praktisch unsicher. Diese Realität macht wissensbasierte Authentifikatoren, SMS- und E-Mail-Wiederherstellung, Passwortverlauf, Komplexität und Passwortwechselstrategien nutzlos. Diese Maßnahmen waren schon immer wenig hilfreich und zwangen die Benutzer oft dazu, sich alle paar Monate schwache Passwörter auszudenken. Mit der Veröffentlichung von über 5 Milliarden Kombinationen von Benutzernamen und Passwörtern ist es an der Zeit, sich weiter zu entwickeln.\n\nDaher haben sich die Kapitel \"Authentifizierung\" und \"Session Management\" am meisten verändert. Das Ausrichten an einem effektiven, evidenzbasierten Vorbild wird für viele eine Herausforderung sein, das ist völlig in Ordnung. Wir müssen jetzt den Übergang zu einer Zukunft ohne Passwort einleiten.\n\n## NIST 800-63 - Ein moderner, evidenzbasierter Authentifizierungsstandard\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) ist ein moderner, evidenzbasierter Standard. Der Standard ist für alle Organisationen auf der ganzen Welt hilfreich, besonders relevant jedoch für US-Behörden und Organisationen, die mit ihnen in Verbindung stehen.\n\nWenn man die Authentifizierung mit Benutzername und Passwort gewohnt ist, kann die Terminologie von NIST 800‑63 kann anfangs etwas verwirrend sein. Fortschritte in der modernen Authentifizierung sind notwendig, daher müssen wir eine Terminologie einführen, die in Zukunft allgemein üblich sein wird. Wir verstehen aber auch die Verständnisschwierigkeiten, die sich ergeben, bis alle sich auf diese neuen Begriffe eingestellt haben. Wir haben viele Anforderungen des NIST umformuliert, um die Absicht der Anforderung und nicht die Buchstaben der Anforderung zu erfüllen. Zum Beispiel verwendet der ASVS den Begriff \"Passwort\", wenn das NIST von einem \"gespeicherten Geheimnis\" spricht.\n\nDie Kapitel V2: Authentifizierung, V3: Session Management und in geringerem Maße auch V4: Zugriffskontrollen wurden so angepasst, dass sie eine standardkonforme Teilmenge der Maßnahmen gemäß NIST 800-63b sind, die sich auf allgemeine Bedrohungen und häufig ausgenutzte Authentifizierungsschwachstellen konzentrieren. Muss NIST 800-63 vollständig erfüllt werden, so nutzen Sie bitte NIST 800-63 direkt.\n\n### Auswahl einer geeigneten NIST AAL-Stufe\n\nBei der Erstellung des ASVS 4.0 haben wir ASVS L1 den Anforderungen von NIST AAL1, L2 zu AAL2 und L3 zu AAL3 zugeordnet. Dabei ist zu beachten, dass hier die ASVS-Stufe 1 nicht mehr die Voraussetzung für alle anderen Stufen ist: Soll die Anwendung beispielsweise NIST AAL3 erfüllen, so muss in den Abschnitten V2 und V3 Session Management die Stufe 3 - und nur die Stufe 3 - gewählt werden. Die Auswahl des NIST AAL sollte gemäß den Richtlinien von NIST 800-63b erfolgen, wie sie in [NIST800-63b, Abschnitt 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA) unter *Selecting AAL* beschrieben sind.\n\n## Legende\n\nAnwendungen können immer die Anforderungen der aktuellen Stufe überschreiten, insbesondere wenn eine moderne Authentifizierung auf der Roadmap einer Anwendung steht. In den Vorgängerversionen erforderte der ASVS obligatorisch eine Mehrfaktorauthentifizierung (MFA). NIST tut dies nicht. Daher haben wir in diesem Kapitel eine Option eingeführt, die anzeigt, wenn der ASVS eine Eigenschaft empfiehlt. Dabei gilt:\n\n| Symbol | Beschreibung |\n| :--: | :-- |\n| | Nicht erforderlich |\n| o | Empfohlen |\n| ✓ | Erforderlich |\n\n## V2.1 Passwortsicherheit\n\nPasswörter, in NIST 800-63 als \"gespeicherte Geheimnisse\" bezeichnet, umfassen Passwörter, PINs, Entsperrmuster, die Auswahl des richtigen Bildelements sowie Passphrasen. Sie werden im Allgemeinen als \"Wissen\" betrachtet und oft als Einfaktor-Authentifikatoren verwendet. Die weitere Verwendung der Einfaktor-Authentifizierung steht vor erheblichen Herausforderungen, z.B.: Milliarden von öffentlich verfügbaren Kombinationen von Benutzername und Passwort, Standardpasswörtern, schwachen Passwörtern, Rainbowtables sowie Wörterbücher der häufigsten Passwörter.\n\nAnwendungen sollten die Benutzer nachdrücklich dazu ermutigen, sich mittels Mehrfaktor-Authentifizierung anzumelden und ihnen erlauben, Token, wie z.B. FIDO- oder U2F-Token, die sie bereits besitzen, einzusetzen oder sich mit einem Credential Service Provider (CSP) zu verbinden, der Mehrfaktor-Authentifizierung anbietet. CSPs bieten ihren Benutzern eine föderierte Identität an. Benutzer verfügen oft über mehrere Identitäten bei mehreren CSPs, z. B. eine Unternehmensidentität bei Azure AD, Okta, Ping Identity oder Google und eine Verbraucheridentität bei Facebook, Twitter, Google oder WeChat, um nur einige gängige Alternativen zu nennen. Diese Liste soll keine Bestätigung dieser Unternehmen oder Dienste sein, sie soll lediglich Entwickler dazu anspornen, die Realität zu berücksichtigen, dass viele Benutzer viele etablierte Identitäten haben. Organisationen sollten entsprechend ihrem Risikoprofil die Einbindung der Benutzeridentität in Betracht ziehen, die sich aus der Stärke der Identitätsprüfung des CSP ergibt. So ist es beispielsweise unwahrscheinlich, dass eine Regierungsorganisation eine Social-Media-Identität als Login für sensible Systeme akzeptiert, da es leicht ist, falsche Identitäten zu erstellen. Ein Unternehmen für Handyspiele muss sich für die Erweiterung seiner aktiven Spielerbasis möglicherweise an eine große Social-Media-Plattformen anbinden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.1.1** | Prüfen Sie, dass Benutzerpasswörter mindestens 12 Zeichen lang sind, nachdem zusammenhängende Leerzeichen gekürzt wurden. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Prüfen Sie, dass Passwörter mit 64 oder mehr Zeichen erlaubt sind, jedoch nicht mehr als 128 Zeichen. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Prüfen Sie, dass Passwörter nicht gekürzt werden. Mehrere aufeinanderfolgende Leerzeichen können zu einem zusammengefasst werden. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Prüfen Sie, ob alle druckbaren Unicode-Zeichen, auch Leerzeichen oder Emojis, in Passwörtern zulässig sind. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Prüfen Sie, dass Benutzer ihr Passwort ändern können. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Prüfen Sie, dass die Passwortänderungsfunktion das bisherige sowie das neue Kennwort des Benutzers erfordert. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Prüfen Sie, dass die bei der Kontoregistrierung, beim Login und bei der Passwortänderung übermittelten Passwörter mit einen Satz verletzter Passwörtern verglichen werden, und zwar entweder lokal (z. B. mit den 1.000 oder 10.000 häufigsten Passwörtern, die mit der Passwortrichtlinie des Systems übereinstimmen) oder mit Hilfe einer externen API. Bei Verwendung einer API muss sichergestellt werden, dass das Klartextpasswort nicht gesendet oder anderweitig offengelegt wird. Wird das Passwort offengelegt, muss die Anwendung den Benutzer auffordern, ein neues Passwort festzulegen. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Prüfen Sie, dass ein Maß für die Passwortstärke bereitgestellt wird, damit Benutzer ein stärkeres Passwort erstellen können. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Prüfen Sie, dass es keine Regeln für die Zusammenstellung der Passwörter gibt, welche die Art der zulässigen Zeichen einschränken. Die Verwendung bestimmter Zeichen, wie Groß- oder Kleinschreibung, Zahlen oder Sonderzeichen sollte nicht verlangt werden. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Prüfen Sie, dass weder periodischer Passwortwechsel notwendig ist noch eine Passworthistorie gespeichert wird. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Prüfen Sie, dass die \"Einfügen\"-Funktion, Passworthilfen der Browser und externe Passwortmanager zugelassen sind. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Prüfen Sie, dass der Benutzer wählen kann, entweder das gesamte Passwort vorübergehend angezeigt zu bekommen oder das letzte eingetippte Zeichen des Passwortes angezeigt zu bekommen. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nHinweis: Die Möglichkeit des Benutzers, sein Passwort angezeigt zu bekommen oder vorübergehend das letzte Zeichen zu sehen, soll die Eingabefreundlichkeit der Anmeldedaten verbessern, insbesondere bei der Verwendung längerer Passwörter, Passphrasen und Passwortmanager. Weiterhin sollen diese Anforderungen verhindern, Organisationen unnötigerweise dazu zwingen, dieses moderne benutzerfreundliche Sicherheitskonzept einiger Betriebssysteme zu deaktivieren.\n\n## V2.2 Allgemeine Sicherheitsanforderungen an den Authentifikator\n\nDie Agilität des Authentifikators ist für zukunftssichere Anwendungen unerlässlich. Überarbeiten Sie die Application Verifier um zusätzliche Authentifikatoren nach Benutzerpräferenz zuzulassen. Entfernen Sie veraltete oder unsichere Authentifikatoren.\n\nNIST betrachtet E-Mail und SMS als \"eingeschränkt zur Authentifikation tauglich”, und es ist wahrscheinlich, dass sie in der Zukunft aus dem NIST 800-63 und damit dem ASVS entfernt werden. Anwendungen sollten so geplant werden, dass sie ohne E-Mail oder SMS auskommen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.2.1** | Prüfen Sie, dass Maßnahmen gegen automatische Angriffe, wie das Ausprobieren von Passworten oder das Aussperren von Benutzern, wirksam umgesetzt sind. Dazu gehören das Blockieren der am häufigsten verwendeten Passwörter, Soft-Lockouts, die Begrenzung der Anzahl von Anmeldungen, CAPTCHA, wachsende Verzögerungen zwischen den Fehlversuchen, IP-Adressbeschränkungen oder risikobasierte Einschränkungen wie Standort, erste Anmeldung auf einem Gerät, kürzliche Versuche, das Konto zu entsperren oder Ähnliches. Prüfen Sie, dass nicht mehr als 100 Fehlversuche pro Stunde bei einem einzelnen Konto möglich sind. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Prüfen Sie, dass der Einsatz schwacher Authentifikationsmethoden, wie SMS und E-Mail, auf die sekundäre Verifizierung und Transaktionsgenehmigung beschränkt ist und nicht als Ersatz für sicherere Authentifizierungsmethoden dient. Prüfen Sie, dass stärkere Methoden vor schwachen Methoden eingesetzt werden, dass sich die Benutzer der Risiken bewusst sind oder dass geeignete Maßnahmen zur Begrenzung des Risikos getroffen werden. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Prüfen Sie, dass die Benutzer sichere Benachrichtigungen nach Aktualisierungen der Authentifizierungsdetails, wie z. B. das Zurücksetzen von Anmeldedaten, E-Mail- oder Adressänderungen, Anmeldung von unbekannten oder risikobehafteten Orten erhalten. Die Verwendung von Push-Benachrichtigungen - anstelle von SMS oder E-Mail - ist vorzuziehen. Bei fehlenden Push-Benachrichtigungen sind SMS oder E-Mail jedoch akzeptabel, solange in der Benachrichtigung keine sensiblen Informationen offengelegt werden. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Prüfen Sie die Resistenz gegen Phishing durch Authentifizierung mittels Mehrfaktor-Authentifizierung, Public Key Kryptographie, Chipkarten und Push-Nachrichten, auf höheren AAL-Ebenen: clientseitige Zertifikate. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Prüfen Sie, dass der CSP und die nutzende Anwendung über zweiseitig authentifiziertes TLS kommunizieren. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Prüfen Sie, dass Authentifikationsdaten nicht wieder eingespielt werden können. Dies kann z.B. mit One Time Password (OTP) Generatoren, Chipkarten o.ä. verhindert werden. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Prüfen Sie, dass eine Authentifikation nicht unbeabsichtigt stattfinden kann. Verlangen Sie die Eingabe eines OTP-Tokens oder eine vom Benutzer initiierte Aktion, wie z.B. einen Tastendruck auf einem FIDO-Hardwaretoken. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Lebenszyklus des Authentifikators\n\nAuthentifikatoren sind Passwörter, Softtoken, Hardwaretoken und biometrische Geräte. Ihr Lebenszyklus ist für die Sicherheit einer Anwendung entscheidend: Wenn sich jemand auf einem Konto ohne Identitätsnachweis selbst registrieren kann, ist die Identitätsbehauptung wenig vertrauenswürdig. Für Social-Media-Sites wie Reddit ist das völlig in Ordnung. Bei Bankinganwendungen hingegen ist ein größeres Augenmerk auf die Registrierung, die Anmeldedaten bzw. -geräten entscheidend für die Sicherheit der Anwendung.\n\nHinweis: Die NIST hat die Regulierung von Passwörtern geändert. Sie dürfen keine maximale Lebensdauer haben und sollten keinem routinemäßigen Wechsel mehr unterliegen. Passwörter müssen nur noch beim Verdacht auf Offenlegung ersetzt werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.3.1** | Vom System generierte Anfangspasswörter oder Aktivierungscodes SOLLTEN sicher zufällig generiert werden. Sie SOLLTEN mindestens 6 Zeichen lang sein und KÖNNEN Buchstaben und Zahlen enthalten. Sie MÜSSEN nach einer kurzen Zeitspanne ablaufen. Diese Initialpasswörter dürfen nicht zum dauerhaften Passwort werden. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Prüfen Sie, dass die Registrierung und die Verwendung von vom Teilnehmer bereitgestellten Authentifizierungsgeräten unterstützt werden, wie z. B. U2F- oder FIDO-Token. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Prüfen Sie, dass die Aufforderung zur Erneuerung zeitgebundener Authentifikatoren rechtzeitig gesendet werden. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Speicherung der Anmeldedaten\n\nArchitekten und Entwickler sollten sich bei der Erstellung oder dem Refactoring von Software an diesen Abschnitt halten. Dieser Abschnitt kann nur durch Codereview oder durch sichere Unit- oder Integrationstests vollständig verifiziert werden. Penetrationstests können diese Probleme nicht nachweisen, daher sind die Maßnahmen nicht mit L1 gekennzeichnet. Dieser Abschnitt ist jedoch von entscheidender Bedeutung für die Sicherheit von Anmeldedaten, falls diese gestohlen werden. Wenn Sie also den ASVS als Architektur- oder Programmierrichtlinie oder als Checkliste zum Codereview nutzen, setzen Sie diese Maßnahmen bitte wieder auf L1.\n\nDie Liste der anerkannten Einwegfunktionen für die Schlüsselableitung wird in NIST 800-63 B, Abschnitt 5.1.1.2 und in [BSI Kryptographische Verfahren: Empfehlungen und Schlüssellängen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile) detailliert aufgeführt. Anstelle dieser Auswahlmöglichkeiten können die neuesten nationalen oder regionalen Algorithmen und Schlüssellängenstandards gewählt werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.4.1** | Prüfen Sie, dass die Passwörter in einer Form gespeichert werden, die immun gegen Offlineangriffe ist. Passwörter MÜSSEN mit einem Salt versehen werden. Der Passworthash muss mit Hilfe einer sicheren Funktion zur Schlüsselberechnung oder einer Passwort-Hashfunktion berechnet werden. Die Funktionen zur Schlüsselberechnung und zum Passwort-Hashing nehmen ein Passwort, einen Salt und einen Kostenfaktor als Eingabewerte. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Prüfen Sie, dass das Salt mindestens 32 Bit lang ist und zufällig gewählt wird, um Saltwertkollisionen zwischen gespeicherten Hashes zu minimieren. Für jede Anmeldeinformation (Credential) MUSS ein eindeutiger Saltwert und der daraus resultierende Hash gespeichert werden. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Prüfen Sie, dass bei Verwendung von PBKDF2 der Iterationszähler so groß sein SOLLTE, wie es die Leistung des Verifikationsservers zulässt, normalerweise mindestens 100.000 Iterationen. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Prüfen Sie, dass bei Verwendung von bcrypt der Arbeitsfaktor so groß sein SOLLTE, wie es die Leistung des Verifikationsservers erlaubt, jedoch mindestens 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Prüfen Sie, dass eine zusätzliche Iteration einer Funktion zur Schlüsselberechnung durchgeführt wird. Dabei ist ein Saltwert zu verwenden, der nur dem Verifizierer bekannt ist. Generieren Sie den Saltwert mit einem zugelassenen Zufallsgenerator [SP 800-90Ar1]. Stellen Sie die in der letzten Revision von SP 800-131A angegebene Mindestsicherheitsstärke sicher. Der geheime Saltwert MUSS getrennt von den gehashten Passwörtern gespeichert werden, z.B. in einem speziellen Gerät wie einem HSM. | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nWo US-Normen erwähnt werden, kann bei Bedarf anstelle der US-Norm oder zusätzlich zu dieser eine lokale Norm verwendet werden. Ein Teil der Inhalte des SP 800-131A wird von der TR-02102-1 \"Kryptographische Verfahren: Empfehlungen und Schlüssellängen\" des BSI abgedeckt.\n\n## V2.5 Wiederherstellung von Anmeldedaten\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.5.1** | Prüfen Sie, dass ein vom System generiertes Initial- oder Wiederherstellungsgeheimnis nicht im Klartext an den Benutzer gesendet wird. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Prüfen Sie, dass keine Hinweise auf Passwörter oder wissensbasierte Authentifizierung, z.B. \"geheime Fragen\" vorliegen. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Prüfen Sie, dass die Wiederherstellung von Anmeldedaten das aktuelle Kennwort nicht preisgibt. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Prüfen Sie, dass Gemeinschafts- oder Standardkonten, z.B. \"root\", \"admin\", \"Gast\" oder \"sa\" deaktiviert oder gelöscht sind. | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Prüfen Sie, dass der Benutzer informiert wird, wenn ein Authentifizierungsfaktor geändert oder ersetzt wird. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Prüfen Sie, dass der Prozess zur Wiederherstellung, z.B. für vergessene Passwörter, einen sicheren Kanal, z. B. TOTP oder andere Softtoken, Mobile Push oder andere Offlinekanäle, verwendet. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Prüfen Sie, dass der Identitätsnachweis bei Verlust von OTP- oder Mehrfaktor-Token auf derselben Ebene wie bei der Registrierung durchgeführt wird. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Verifizierung von TAN-Listen\n\nVorgenerierte Listen von Geheimcodes, z.B. Transaktionsnummern (TAN), Wiederherstellungscodes für soziale Medien oder eine andere Reihe von Zufallswerten. Diese werden sicher an die Benutzer versandt. Diese Geheimcodes werden einmal verwendet. Wenn alle verwendet wurden, wird die Liste entsorgt. Diese Art von Authentifikator gilt als \"etwas, das Sie haben\" bzw. Besitz.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.6.1** | Prüfen Sie, dass die Geheimcodes nur einmal verwendet werden können. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Prüfen Sie, ob die Geheimcodes eine ausreichende Zufälligkeit aufweisen (112 Bit Entropie). Falls weniger als 112 Bit Entropie vorhanden sind, sind ein einzigartiger und zufälliger 32 Bit Salt und eine zugelassene Hashfunktion zu nutzen. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Prüfen Sie, dass Geheimcodes gegen Offlineangriffe, wie z.B. vorhersehbare Werte, immun sind. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Out-of-Band Verifizierer\n\nIn der Vergangenheit wäre ein üblicher Out-of-Band Verifizierer eine E-Mail oder SMS mit einem Link zum Zurücksetzen des Passworts gewesen. Angreifer nutzen diesen schwachen Mechanismus, um Konten, die sie noch nicht kontrollieren, zurückzusetzen, z. B. indem sie das E-Mail-Konto einer Person übernehmen und Passwörter neu anfordern. Es gibt bessere Möglichkeiten, die Out-of-Band Verifizierung zu handhaben.\n\nSichere Out-of-Band Authentifikatoren sind physische Geräte, die mit dem Verifizierer über einen sicheren Zweitkanal kommunizieren können. Das sind z.B. Push-Nachrichten an mobile Geräte. Diese Art von Authentifikator gilt als \"etwas, das Sie haben\" bzw. Besitz. Will sich ein Benutzer authentifizieren, sendet die verifizierende Anwendung eine Nachricht an den Out-of-Band Authentifikator. Die Nachricht enthält einen Authentifizierungscode, z.B. eine zufällige sechsstellige Zahl oder eine Abfrage der Genehmigung. Die verifizierende Anwendung wartet auf den Empfang des Authentifizierungscodes über den Primärkanal und vergleicht den Hash des empfangenen Wertes mit dem Hash des ursprünglichen Authentifizierungscodes. Wenn sie übereinstimmen, kann der Out-of-Band Verifizierer davon ausgehen, dass der sich der Benutzer authentifiziert hat. Der Prozess kann direkt oder über einen Dienst Dritter ablaufen.\n\nDer ASVS geht davon aus, dass nur wenige Entwickler neue Out-of-Band Authentifizierer wie Push-Nachrichten entwickeln werden, und daher gelten die folgenden Maßnahmen des ASVS für Verifizierer, wie die Authentifizierungs-API, Anwendungen und Single-Sign-On Implementierungen. Wenn Sie einen neuen Out-of-Band Authentifikator entwickeln, beachten Sie bitte NIST 800-63B § 5.1.3.1.\n\nUnsichere Out-of-Band Authentifizierer wie E-Mail und VOIP sind nicht zulässig. PSTN- oder SMS-Authentifizierung ist derzeit durch NIST als eingeschränkt geeignet eingeschätzt und sollten durch Push-Nachrichten oder ähnliche ersetzt werden. Müssen Sie Telefon- oder SMS zur Out-of-Band Authentifizierung verwenden, lesen Sie bitte NIST 800-63B § 5.1.3.3.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.7.1** | Prüfen Sie, dass Out-of-Band Authentifikatoren, die NIST \"restricted\" sind, wie z.B. SMS, nicht standardmäßig angeboten werden und dass stärkere Alternativen wie Push-Nachrichten zuerst angeboten werden. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Prüfen Sie, dass der Out-of-Band Verifizierer bei Out-of-Band Authentifizierungsanforderungen, -Codes oder -Tokens nach 10 Minuten abläuft. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Prüfen Sie, dass Authentifizierungsanfragen, -Codes oder ‑Token an den Out-of-Band Verifizierer nur einmal und nur für die ursprüngliche Authentifizierungsanfrage verwendbar sind. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Prüfen Sie, dass der Out-of-Band Authentifizierer und der Verifizierer über einen sicheren, unabhängigen Kanal kommunizieren. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Prüfen Sie, dass der Out-of-Band Verifizierer nur eine gehashte Version des Authentifizierungscodes speichert. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Prüfen Sie, dass der initiale Authentifizierungscode von einem sicheren Zufallszahlengenerator erzeugt wird, der mindestens 20 Bit Entropie enthält. Normalerweise ist eine sechsstellige Zufallszahl ausreichend. | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 Ein- oder Mehrfaktor-Einwegverifizierer\n\nEinmal-Passwörter (OTPs) sind physische oder Softtoken, die ein sich ständig veränderndes pseudozufälliges Passwort bereitstellen. Diese Geräte erschweren Imitiationsangriffe, wie Phishing, verhindern sie aber nicht. Diese Art von Authentifikator gilt als \"etwas, das Sie haben\" bzw. Besitz. Mehrfaktor-Token sind ähnlich wie Einmalpasswörter erfordern jedoch zusätzlich einen gültigen PIN-Code, biometrische Entsperrung, USB-Stick oder NFC-Kontakt o.ä., der eingegeben werden muss, um den endgültigen OTP zu erstellen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.8.1** | Prüfen Sie, dass zeitbasierte OTPs eine definierte Lebensdauer haben, bevor sie ablaufen. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Prüfen Sie, dass die symmetrischen Schlüssel, die zur Prüfung der eingegebenen OTPs verwendet werden, sicher geschützt sind, z.B. durch Verwendung eines HSM oder der sicheren Schlüsselspeicherung des Betriebssystems. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.3** | Prüfen Sie, dass anerkannte kryptografische Algorithmen bei der Generierung, dem Seeding und der Verifizierung verwendet werden. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Prüfen Sie, dass das zeitbasierte OTP nur einmal innerhalb des Gültigkeitszeitraums verwendet werden können. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Prüfen Sie, dass ein zeitbasiertes Mehrfaktor-OTP, das während der Gültigkeitsdauer wiederverwendet wird, protokolliert und mit sicheren Benachrichtigungen an den Inhaber des Geräts abgelehnt wird. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Prüfen Sie, ob physische OTP-Generatoren im Falle von Diebstahl oder Verlust gesperrt werden können. Stellen Sie sicher, dass der Widerruf sofort für alle eingeloggten Sitzungen, unabhängig vom Standort, wirksam ist. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Prüfen Sie, dass biometrische Authentifikatoren nur als sekundäre Faktoren in Verbindung mit etwas, das Sie haben oder etwas, das Sie wissen, verwendet werden dürfen. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Kryptografische Software und Geräte im Authentifizierungsprozess\n\nKryptographische Geräte sind Chipkarten oder USB-Sticks, die der Benutzer an den Computer anschließen muss, um die Authentifizierung abzuschließen. Der Verifizierer sendet einen Zufallswert (Nonce) an das kryptographische Gerät oder die Software. Dort wird eine Antwort auf der Grundlage eines sicher gespeicherten kryptographischen Schlüssels berechnet.\n\nDie Anforderungen für kryptographische Geräte und Software sind für Ein- und Mehrfaktorauthentifizierung gleich, da die Verifizierung der berechneten Antwort den Besitz des Authentisierungsfaktors nachweist.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.9.1** | Prüfen Sie, dass die bei der Authentifizierung verwendeten kryptografischen Schlüssel sicher gespeichert und gegen Offenlegung geschützt sind, z. B. durch Verwendung eines Trusted Platform Module (TPM) oder eines Hardware Security Modules (HSM) oder eines Betriebssystemdienstes. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Prüfen Sie, dass der Zufallswert mindestens 64 Bit lang ist und statistisch einmalig oder für die Lebensdauer des kryptografischen Geräts einmalig ist. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Prüfen Sie, dass anerkannte kryptografische Algorithmen bei allen kryptographischen Operationen verwendet werden. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Service-Authentifizierung\n\nDieser Abschnitt ist kann nicht mittels Penetrationstest getestet werden und hat daher also keine L1-Anforderungen. Wenn sie jedoch in einer Architektur-, Programmier- oder Codereview verwendet wird, gehen Sie bitte davon aus, dass Software, ebenso wie Java Key Store, die Mindestanforderung von L1 hat. Das Speichern von Geheimnissen im Klartext ist unter keinen Umständen zulässig.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.10.1** | Prüfen Sie, dass Intra-Service-Geheimnisse nicht auf unveränderlichen Credentials, wie Passwörtern, API-Schlüsseln oder gemeinsam genutzten privilegierten Konten beruhen. | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Prüfen Sie, dass Servicekonten, die zur Anmeldung genutzt werden, keine Standardpasswörter, wie root / root oder admin / admin, die häufig voreingestellt sind, nutzen. | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Prüfen Sie, dass Passworthashwerte mit ausreichendem Schutz gespeichert werden, um Offlineangriffe, zu verhindern. | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Prüfen Sie, dass Passwörter, Zugänge zu Datenbanken o.a. Systemen, Seeds, interne Geheimnisse sowie API-Schlüssel sicher verwaltet werden. Sie dürfen nicht in den Quellcode aufgenommen bzw. in Quellcoderepositories gespeichert werden. Eine solche Speicherung muss Offline-Angriffen widerstehen. Für die Passwortspeicherung wird die Verwendung eines sicheren Softwareschlüsselspeichers (L1), eines TPM oder eines HSM (L3) empfohlen. | | OS assisted | HSM | 798 | |\n\n## Zusätzliche Anforderungen der US-Behörden\n\nUS-Behörden müssen NIST 800-63 zwingend erfüllen. Der ASVS konzentriert sich auf die 80 % der Maßnahmen, die für fast alle Anwendungen gelten. In diesem Sinne ist der ASVS eine Teilmenge von NIST 800-63, besonders für die IAL1/2- und AAL1/2-Klassifikationen. Er ist jedoch nicht umfassend genug, insbesondere für die IAL3/AAL3-Klassifikationen.\n\nWenn Sie Software für die US-Regierungsbehörden entwickeln, müssen Sie NIST 800‑63 in seiner Gesamtheit überprüfen und umzusetzen.\n\n## Glossary of terms\n\n| Term | Meaning |\n| --- | --- |\n| CSP | Credential Service Provider also called an Identity Provider |\n| Authenticator | Code that authenticates a password, token, MFA, federated assertion, and so on. |\n| Verifier | \"An entity that verifies the claimant's identity by verifying the claimant's possession and control of one or two authenticators using an authentication protocol. To do this, the verifier may also need to validate credentials that link the authenticator(s) to the subscriber's identifier and check their status\" |\n| OTP | One-time password |\n| SFA | Single-factor authenticators, such as something you know (memorized secrets, passwords, passphrases, PINs), something you are (biometrics, fingerprint, face scans), or something you have (OTP tokens, a cryptographic device such as a smart card) |\n| MFA | Multi-factor authentication, which includes two or more single factors |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:44.410979"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x12-V3-Session-management.md", "content": "# V3 Sessionmanagement\n\n## Ziel\n\nDas Sessionmanagement ist die Kernkomponente jeder webbasierten Anwendung oder zustandsbezogenen API, mit dem sie den Zustand für einen Benutzer oder ein Gerät, das mit ihr kommuniziert, steuert und aufrechterhält. Es ist entscheidend für die Unterscheidung verschiedener Benutzer oder Geräte. Es ändert ein zustandsloses Protokoll in ein zustandsbehaftetes. Prüfen Sie, dass eine verifizierte Anwendung die folgenden Anforderungen an das High Level Session Management erfüllt:\n\n* Sessions sind für jede Person einzigartig und können nicht erraten oder geteilt werden.\n* Sessions werden ungültig, wenn sie nicht mehr benötigt werden.\n* Sessions laufen ab, wenn sie eine bestimmte Zeit nicht aktiv sind.\n\nWie bereits erwähnt, wurden diese Anforderungen so angepasst, dass sie eine konforme Teilmenge ausgewählter NIST 800-63b-Maßnahmen darstellen, die sich auf gemeinsame Bedrohungen und häufig genutzte Authentifizierungsschwachstellen konzentrieren. Frühere Verifizierungsanforderungen wurden entfernt oder in den meisten Fällen so angepasst, dass sie sich stark an der Absicht der verbindlichen Anforderungen des [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) orientieren.\n\n## V3.1 Grundlegende Sicherheit des Sessionmanagements\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.1.1** | Prüfen Sie, dass die Anwendung niemals Sessiontoken in URL-Parametern oder Fehlermeldungen offenbart. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Session Binding\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.2.1** | Prüfen Sie, ob die Anwendung bei der Authentifizierung eines Benutzers ein neues Sessiontoken generiert. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Prüfen Sie, dass Sessiontoken mindestens 64 Bit Entropie aufweisen. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Prüfen Sie, dass die Anwendung Sessiontoken im Browser nur mit sicheren Methoden wie z.B. gesicherten Cookies (siehe Abschnitt 3.4) oder den HTML 5-Methoden speichert. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Prüfen Sie, dass die Sessiontoken mit anerkannten kryptografischen Algorithmen generiert werden. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nTLS oder ein anderer sicherer Transportkanal ist für das Sessionmanagement obligatorisch. Dies wird im Kapitel Kommunikationssicherheit behandelt.\n\n## V3.3 Beenden der Session\n\nDie Session Timeouts wurden an NIST 800-63 angeglichen, was wesentlich längere Sitzungsauszeiten erlaubt, als die Sicherheitsstandards traditionell zulassen. Prüfen Sie die nachstehende Tabelle: Falls eine längere Zeit der Inaktivität mit dem Risiko des Geschäftsbetriebes vereinbar ist, kann sich die Obergrenze am oberen NIST-Grenzwert des Session-Timeouts orientieren.\n\nL1 (Stufe 1) ist in diesem Zusammenhang IAL1/AAL1, L2 (Stufe 2) ist IAL2/AAL3, L3 (Stufe 3) ist IAL3/AAL3. Je kürzer die Leerlaufzeit für IAL2/AAL2 und IAL3/AAL3 ist, desto niedriger ist die Grenze der Leerlaufzeiten für das Ausloggen oder die erneute Authentifizierung zur Wiederaufnahme der Sitzung.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.3.1** | Prüfen Sie, dass Abmeldung und Ablauf das Sessiontoken ungültig machen, so dass die Zurück-Taste oder eine nachgeschaltete Relying Party eine authentifizierte Sitzung auch nicht zwischen den Relying Parties wiederaufnimmt. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Wenn die Benutzer eingeloggt bleiben, Prüfen Sie, dass eine erneute Authentifizierung in regelmäßigen Abständen sowohl bei aktiver Nutzung als auch nach einer Leerlaufphase erfolgt. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 Tage | 12 Stunden oder 30 Minuten Inaktivität, 2FA optional | 12 Stunden oder 15 Minuten Inaktivität, mit 2FA | 613 | 7.2 |\n| **3.3.3** | Prüfen Sie, dass es die Anwendung ermöglicht, alle anderen aktiven Sitzungen nach einer erfolgreichen Kennwortänderung zu beenden. Dies muss in der gesamten Anwendung, der föderierten Anmeldung (falls vorhanden) und bei allen Relying Parties wirksam sein. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Prüfen Sie, dass die Benutzer jede oder alle derzeit aktiven Sitzungen und Geräte sehen und sich von ihnen abmelden können. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Cookiebasiertes Session Management\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.4.1** | Prüfen Sie, dass bei Session-Cookies das Attribut 'Secure' gesetzt ist. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Prüfen Sie, dass bei Session-Cookies das Attribut 'HttpOnly' gesetzt ist. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Prüfen Sie, dass Session-Cookies das 'SameSite'-Attribut verwenden, um die Anfälligkeit für Cross Site Request Forgery zu begrenzen. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | Prüfen Sie, dass Session-Cookies das Präfix '__Host-' verwenden (siehe Referenzen), um die Vertraulichkeit von Session-Cookies zu gewährleisten. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Falls die Anwendung unter einem Domänennamen zusammen mit anderen Anwendungen veröffentlicht wird, die Session-Cookies nutzen, welche die Sitzungscookies der geprüften Anwendung außer Kraft setzen oder offenlegen könnten, prüfen Sie, dass das Pfadattribut in den Cookies einen möglichst exakten Pfad erhält. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Tokenbasiertes Sessionmanagement\n\nTokenbasiertes Sessionmanagement umfasst z.B. JWT-, OAuth-, SAML- und API-Schlüssel. API-Schlüssel sind bekanntermaßen schwach und sollten im neuen Code nicht mehr verwendet werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.5.1** | Prüfen Sie, dass die Anwendung Benutzern erlaubt, OAuth-Token, die Vertrauensbeziehungen zu verknüpften Anwendungen herstellen, zurückzuziehen. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Prüfen Sie, dass die Anwendung Sessiontoken anstatt statischer API-Schlüssel verwendet, außer bei Legacy-Implementierungen. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Prüfen Sie, dass zustandslose Session-Token digitale Signaturen, Verschlüsselung und andere Gegenmaßnahmen zum Schutz vor Manipulation, Enveloping, Wiedergabe, Null-Chiffren und Schlüsselaustausch-Angriffen verwenden. | | ✓ | ✓ | 345 | |\n\n## V3.6 Erneute Authentisierung\n\nDieser Abschnitt bezieht sich auf Entwickler, die den Code für die Relying Party (RP) oder den Credential Service Provider (CSP) schreiben. Wenn Sie auf eine Software vertrauen, die diese Funktionen implementiert, Prüfen Sie, dass die folgenden Punkte korrekt behandelt werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.6.1** | Prüfen Sie, dass die Relying Parties gegenüber den CSPs die maximale Authentifizierungszeit angeben, und dass die CSPs den Teilnehmer erneut authentifizieren, wenn sie innerhalb dieses Zeitraums keine Sitzung verwendet haben. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Prüfen Sie, dass die CSPs die Relying Parties über das letzte Authentifizierungsereignis informieren, damit die RPs feststellen können, ob sie den Benutzer erneut authentifizieren müssen. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Verteidigung gegen Session Management Exploits\n\nEs gibt eine kleine Anzahl von Angriffen auf das Sessionmanagement, von denen einige mit der Benutzerführung von Sessions zusammenhängen. Auf der Grundlage des ISO 27002 Standards haben Vorversionen des ASVS das Blockieren mehrerer gleichzeitiger Sitzungen gefordert. Das Blockieren gleichzeitiger Sitzungen ist jedoch nicht mehr zeitgemäß, nicht nur, weil die heutigen Benutzer viele Geräte haben oder die Anwendung eine API ohne Browsersession ist, sondern auch weil in den meisten dieser Implementierungen der letzte Authentifikator – meist der Angreifer - gewinnt. Dieser Abschnitt ist eine Anleitung zum Abschrecken, Verzögern und Erkennen von Angriffen auf das Sessionmanagement.\n\n### Beschreibung des halboffenen Angriffs\n\nAnfang 2018 wurden mehrere Finanzinstitute durch sogenannte halboffene Angriffe kompromittiert. Die Angreifer griffen sowohl unterschiedliche Institute mit unterschiedlichen proprietären Codebasen an als auch scheinbar verschiedene Codebasen innerhalb derselben Institute. Der halboffene Angriff macht sich einen Fehler im Design vieler Authentifizierungs-, Sessionmanagement- und Zugangskontrollsysteme zu Nutze.\n\nDie Angreifer starten einen halboffenen Angriff, indem sie versuchen, Zugangsdaten zu sperren, zurückzusetzen oder wiederherzustellen. Ein beliebtes Designmuster für das Sessionmanagement verwendet Benutzerprofile in Sessionobjekten bzw. -modellen zwischen nicht authentifiziertem, halb-authentifiziertem, z.B. Kennwortrücksetzung, vergessener Benutzername, und vollständig authentifiziertem Code wieder. Dieses Designmuster pflegt ein gültiges Sessionobjekt oder Token mit dem Profil des Opfers, einschließlich des Passwort-Hashes und der Rollen ein. Wenn die Zugriffskontrollprüfungen nicht korrekt verifizieren, dass der Benutzer vollständig angemeldet ist, kann der Angreifer als der Benutzer handeln. Angriffe könnten das Benutzerkennwort auf einen bekannten Wert ändern, die E-Mail-Adresse zur Durchführung einer gültigen Kennwortzurücksetzung aktualisieren, die Mehrfaktorauthentifizierung deaktivieren oder ein neues MFA-Gerät registrieren, API-Schlüssel offenlegen bzw. ändern und so weiter.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.7.1** | Prüfen Sie, dass die Anwendung eine gültige Login Session gewährleistet oder eine erneute Authentifizierung oder eine sekundäre Verifizierung erfordert, bevor sensible Transaktionen oder Kontenänderungen zugelassen werden. | ✓ | ✓ | ✓ | 306 | |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:44.515288"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x12-V4-Access-Control.md", "content": "# V4 Maßnahmen zur Zugriffssteuerung\n\n## Ziel\n\nAutorisierung ist das Konzept, nur denjenigen den Zugriff auf Ressourcen zu gestatten, die diese auch nutzen dürfen. Prüfen Sie, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* Personen, die auf Ressourcen zugreifen, müssen dafür über gültige Berechtigungen verfügen.\n* Die Benutzer sind mit einem genau definierten Satz von Rollen und Berechtigungen verbunden.\n* Rollen- und Berechtigungsmetadaten sind vor Wiedereinspielen oder Manipulation geschützt.\n\n## V4.1 Design der Allgemeinen Zugriffssteuerung\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.1.1** | Prüfen Sie, dass die Anwendung Regeln zur Steuerung der Zugriffe auf einer vertrauenswürdigen Serviceschicht durchsetzt, insbesondere wenn die clientseitige Zugriffssteuerung umgangen werden könnte. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Prüfen Sie, dass alle Benutzer- und Datenattribute sowie Richtlinieninformationen, die von der Zugriffssteuerung verwendet werden, von den Endnutzern nicht manipuliert werden können, es sei denn, dies wird ausdrücklich genehmigt. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Prüfen Sie, dass das Prinzip der minimalen Berechtigung gilt: Benutzer sollten nur auf die unbedingt notwendigen Funktionen, Dateien, URLs, Controller, Dienste und andere Ressourcen zugreifen können. Dies bedeutet Schutz vor Spoofing und Ausweitung der Berechtigungen. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [GELÖSCHT, DUPLIKAT VON 4.1.3] | | | | |\n| **4.1.5** | Prüfen Sie, dass die Zugriffssteuerungsroutinen im Fehlerfall in einen sicheren Zustand fallen. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Operative Zugriffssteuerung\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.2.1** | Prüfen Sie, dass sensible Daten und APIs vor direkten Objektangriffen geschützt sind, die auf das Erstellen, Lesen, Aktualisieren und Löschen von Datensätzen abzielen, z. B. das Erstellen oder Aktualisieren von Datensätzen einer anderen Person, das Anzeigen oder Löschen aller Datensätze. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Prüfen Sie, dass die Anwendung oder das Framework einen starken Anti-CSRF-Mechanismus zum Schutz authentifizierter Funktionen durchsetzt, und dass eine effektive Anti-Automatisierung oder Anti-CSRF nicht authentifizierte Funktionen schützt. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Weitere Maßnahmen zur Zugriffssteuerung\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.3.1** | Prüfen Sie, dass administrative Schnittstellen eine geeignete Mehrfaktorauthentifizierung verwenden, um unbefugte Nutzung zu verhindern. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Prüfen Sie, dass das Durchsuchen von Verzeichnissen deaktiviert ist, es sei denn, dies ist absichtlich gewünscht. Ferner ist das Auffinden oder die Offenlegung von Datei- oder Verzeichnis-Metadaten, wie z.B. Thumbs.db, .DS_Store, .git oder .svn-Ordner, nicht zulässig. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Prüfen Sie, dass die Anwendung über zusätzliche Berechtigungen (z. B. Step-Up oder adaptive Authentifizierung) für risikoarme Systeme und / oder Aufgabentrennung für brisante Anwendungen verfügt, um Betrugsbekämpfungsmaßnahmen entsprechend dem Anwendungsrisiko durchzusetzen. | | ✓ | ✓ | 732 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:44.631673"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Eingabeprüfung, die Bereinigung der Ausgaben und die Zeichencodierung\n\n## Ziel\n\nDie häufigste Sicherheitsschwachstelle von Webanwendungen ist die mangelhafte Prüfung von Eingabedaten, die vom Client oder von der Umgebung kommen, bevor sie ohne Ausgabecodierung direkt weiterverwendet werden. Diese Schwachstelle führt zu fast allen signifikanten Schwachstellen in Webanwendungen, wie z.B. Cross Site Scripting (XSS), SQL-Injection, Interpreter-Injection, Angriffe auf Zeichensätze oder auf das Dateisystem und schließlich Pufferüberläufe.\n\nPrüfen Sie, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* Die Architektur der Inputvalidierung und der Ausgabebereinigung haben eine abgestimmte Pipeline, um Injektionsangriffe zu verhindern.\n* Die Eingabedaten werden stark typisiert, ihr Wertebereich bzw. ihre Länge wird überprüft, im Maximum werden sie bereinigt oder gefiltert.\n* Die Ausgabedaten werden entsprechend dem Kontext der Daten so nah wie möglich am Interpreter codiert oder bereinigt.\n\nIn modernen Webanwendungen ist die Ausgabecodierung wichtiger denn je. In bestimmten Fällen ist es schwierig, eine robuste Eingabevalidierung umzusetzen. Daher ist die Verwendung sichererer Schnittstellen, wie parametrisierte Abfragen, Autoescape Template-Frameworks oder die sorgfältig ausgewählte Ausgabecodierung für die Sicherheit der Anwendung von entscheidender Bedeutung.\n\n## V5.1 Eingabeprüfung\n\nRichtig implementierte Maßnahmen zur Eingabeprüfung, die eine positive Whitelist und eine starke Datentypisierung verwenden, können mehr als 90% aller Injektion-Angriffe eliminieren. Prüfungen der Länge und des Wertebereiches können weitere Angriffe verhindern. Während der Anwendungsarchitektur, der Designsprints, der Programmierung sowie der Unit- und Integrationstests muss eine sichere Eingabeprüfung eingebaut werden. Viele dieser Probleme können bei Penetrationstests nicht gefunden werden. Die Versäumnisse der Eingabeprüfung müssen dann in der Regel mit den Maßnahmen aus Abschnitt V5.3 Anforderungen an Ausgabecodierung und Injektionsverhinderung ausgebessert werden. Entwicklern und Code-Reviewern wird empfohlen, diesen Abschnitt so zu behandeln, als ob L1 für alle Elemente erforderlich wäre, um Injektions-Angriffe zu verhindern.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.1.1** | Prüfen Sie, dass die Anwendung über Abwehrmechanismen gegen Angriffe auf HTTP-Parameter verfügt, insbesondere dann, wenn das Anwendungsframework die Quelle der Anforderungsparameter (GET, POST, Cookies, Header oder Umgebungsvariablen) nicht unterscheidet. | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Prüfen Sie, dass Frameworks vor Angriffen durch massenhafte Parameterzuweisung schützen, oder dass die Anwendung über Gegenmaßnahmen zum Schutz vor unsicherer Parameterzuweisung verfügt, wie z.B. das Markieren von Feldern als privat oder ähnliches. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Prüfen Sie, dass alle Eingaben (HTML-Formularfelder, REST-Anforderungen, URL-Parameter, HTTP-Header, Cookies, Batch-Dateien, RSS-Feeds usw.) mittels positiver Validierung (Whitelisting) validiert werden. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Prüfen Sie, dass strukturierte Daten stark typisiert sind und gemäß einem definierten Schema validiert werden. Dazu gehören die erlaubten Zeichen, Länge und Muster (z. B. Kreditkarten- oder Telefonnummern, oder die Prüfung, dass zwei zusammenhängende Felder stimmig sind, z.B. Ort und Postleitzahl). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Prüfen Sie, dass URL-Umleitungen und -Weiterleitungen nur Whitelist-Ziele zulassen, oder bei der Weiterleitung auf potenziell nicht vertrauenswürdige Inhalte einen Warnhinweis anzeigen. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Bereinigung und Sandboxing\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.2.1** | Prüfen Sie, dass alle nicht vertrauenswürdigen HTML-Eingaben von WYSIWYG-Editoren o.ä. ordnungsgemäß mit einer HTML-Bereinigungsbibliothek oder einer Frameworkfunktion bereinigt werden. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Prüfen Sie, dass unstrukturierte Daten bereinigt werden, um Sicherheitsmaßnahmen wie erlaubte Zeichen und Längenbegrenzung durchzusetzen. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Prüfen Sie, dass die Anwendung zum Schutz vor SMTP- oder IMAP-Injektion Benutzereingaben bereinigt, bevor sie an Mailsysteme weitergeleitet werden. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Prüfen Sie, dass die Anwendung kein eval() oder andere Funktionen zur dynamischen Ausführung von Code verwendet. Wenn es keine Alternative gibt, müssen alle Benutzereingaben, die einbezogen werden, vor der Ausführung des Programms gesäubert oder per Sandbox abgegrenzt werden. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Prüfen Sie, dass die Anwendung vor Template-Injection-Angriffen schützt, indem Sie sicherstellen, dass alle Benutzereingaben, die aufgenommen werden, bereinigt oder per Sandbox abgegrenzt werden. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Prüfen Sie, dass die Anwendung vor SSRF-Angriffen schützt, indem sie nicht vertrauenswürdige Daten oder HTTP-Dateimetadaten, wie z. B. Dateinamen und URL-Eingabefelder, validiert oder bereinigt. Verwenden Sie eine Whitelist von Protokollen, Domänen, Pfaden und Ports. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Prüfen Sie, dass die Anwendung vom Benutzer bereitgestellte Scaleable Vector Graphics (SVG) von skriptfähigen Inhalten bereinigt, deaktiviert oder in Sandboxen abgrenzt, insbesondere in Bezug auf XSS, das aus Inline-Skripten und aus foreignObject resultiert. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Prüfen Sie, dass die Anwendung vom Benutzer zur Verfügung gestellte skriptfähige Inhalte oder Inhalte von Expression Language Templates wie Markdown, CSS- oder XSL-Stylesheets, BBCode oder Ähnliches bereinigt, deaktiviert oder in Sandboxen abgrenzt. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Ausgabecodierung und Injektionsverhinderung\n\nFür die Sicherheit der Anwendung ist es entscheidend, dass die Ausgabecodierung möglichst eng bei dem verwendeten Interpreter stattfindet. In der Regel wird die Ausgabecodierung nicht beibehalten, sondern dazu verwendet, die Ausgabe im entsprechenden Kontext für die sofortige Nutzung sicher zu machen. Unzureichende Ausgabecodierung führt direkt zu einer unsicheren Anwendung.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.3.1** | Prüfen Sie, dass die Ausgabecodierung für den Interpreter und den erforderlichen Kontext relevant ist. Verwenden Sie z. B. Codierer gezielt für HTML-Werte, HTML-Attribute, JavaScript, URL-Parameter, HTTP-Header, SMTP und andere, wie es der Kontext erfordert, insbesondere bei nicht vertrauenswürdigen Eingaben (z.B. Namen mit Unicode oder Apostroph, wie z.B. ねこ oder O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Prüfen Sie, dass die Ausgabecodierung den vom Benutzer gewählten Zeichensatz sowie die Spracheinstellung beibehält, so dass jeder Unicode-Zeichenpunkt gültig ist und sicher verarbeitet wird. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Prüfen Sie, dass kontextabhängiges, vorzugsweise automatisches Output Escaping vor reflektierten, gespeicherten und DOM-basierten XSS schützt. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Prüfen Sie, dass die Datenauswahl- oder Datenbankabfragen (z.B. SQL, HQL, ORM, NoSQL) parametrisierte Abfragen, ORMs, Entity Frameworks verwenden oder anderweitig vor Datenbank-Injektionsangriffen geschützt sind. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Prüfen Sie, dass dort, wo keine parametrisierten oder sichereren Mechanismen vorhanden sind, eine kontextspezifische Ausgabecodierung, z. B. SQL-Escaping, zum Schutz vor Injektionsangriffen verwendet wird. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Prüfen Sie, dass die Anwendung vor Angriffen mittels JSON-Injektion, JSON-eval() und Evaluierung von JavaScript-Ausdrücken schützt. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Prüfen Sie, dass die Anwendung vor LDAP-Injektionsschwachstellen schützt oder das spezifische Sicherheitsmaßnahmen zur Verhinderung der LDAP-Injektion implementiert wurden. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Prüfen Sie, dass die Anwendung vor dem Einfügen von Betriebssystemkommandos schützt und dass Betriebssystemaufrufe parametrisierte Abfragen oder eine kontextbezogene Ausgabecodierung der Befehlszeile verwenden. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Prüfen Sie, dass die Anwendung vor Local File Inclusion (LFI)- oder Remote File Inclusion (RFI)-Angriffen schützt. | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Prüfen Sie, dass die Anwendung gegen XPath Injection- oder XML-Injection-Angriffe schützt. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nHinweis: Die Verwendung parametrisierter Abfragen oder des SQL-Escape ist nicht immer ausreichend: Tabellen- und Spaltennamen, ORDER BY usw. können nicht escaped werden. Die Aufnahme von escapten, vom Benutzer bereitgestellten Daten in diesen Feldern führt zu fehlgeschlagenen Abfragen oder SQL-Injektion.\n\nHinweis: Das SVG-Format erlaubt explizit ECMA-Skript in fast allen Kontexten, also ist es eventuell nicht möglich, alle SVG-XSS-Vektoren vollständig zu blockieren. Wenn ein SVG-Upload erforderlich ist, empfehlen wir dringend, diese hochgeladenen Dateien entweder als Text/Plain auszuliefern oder eine separate, vom Benutzer bereitgestellte, Inhaltsdomäne zu verwenden, um zu verhindern, dass ein erfolgreiches XSS die Anwendung übernimmt.\n\n## V5.4 Speicher, Strings und Unmanaged Code\n\nDie folgenden Anforderungen gelten nur, wenn die Anwendung eine Systemprogrammiersprache oder unmanaged Code verwendet.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.4.1** | Prüfen Sie, dass die Anwendung speichersichere Zeichenfolgen, sicherere Speicherkopien und sichere Zeigerarithmetik verwendet, um Stapel-, Puffer- oder Heapüberläufe zu erkennen oder zu verhindern. | | ✓ | ✓ | 120 |\n| **5.4.2** | Prüfen Sie, dass Formatstrings keine potenziell feindliche Eingabe annehmen und konstant sind. | | ✓ | ✓ | 134 |\n| **5.4.3** | Prüfen Sie, dass Zeichen-, Bereichs- und Eingabeprüfungstechniken verwendet werden, um Ganzzahlüberläufe zu verhindern. | | ✓ | ✓ | 190 |\n\n## V5.5 Prävention von Deserialisierungsangriffen\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.5.1** | Prüfen Sie, dass serialisierte Objekte Integritätsprüfungen verwenden oder verschlüsselt sind, um die Erstellung feindlicher Objekte oder die Manipulation von Daten zu verhindern. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Prüfen Sie, dass XML-Parser nur die restriktivste Konfiguration verwenden und das unsichere Funktionen wie die Auflösung externer Entitäten deaktiviert sind, um XXE zu verhindern. | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Prüfen Sie, dass die Deserialisierung nicht vertrauenswürdiger Daten sowohl im benutzerdefinierten Code als auch in Bibliotheken von Drittanbietern (wie JSON-, XML- und YAML-Parser) entweder verhindert oder gesichert wird. | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Prüfen Sie, dass beim Parsen von JSON in Browsern oder JavaScript-basierten Backends JSON.parse zum Parsen des JSON-Dokuments verwendet wird. Verwenden Sie kein eval() zum Parsen von JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nWeitere Informationen zum Auto-Escaping finden Sie unter:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nWeitere Informationen zur Deserialisierung finden Sie unter:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:44.697475"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x14-V6-Cryptography.md", "content": "# V6 kryptographische Komponenten\n\n## Ziel\n\nPrüfen Sie, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* Alle kryptographischen Module fallen in einen sicheren Fehlerzustand und behandeln Fehler korrekt.\n* Es wird ein geeigneter Zufallszahlengenerator verwendet.\n* Der Zugriff auf Schlüssel wird sicher verwaltet.\n\n## V6.1 Datenklassifizierung\n\nDas wichtigste Gut sind die Daten, die von einer Anwendung verarbeitet, gespeichert oder übertragen werden. Führen Sie immer eine Datenschutzfolgenabschätzung durch, um die Datenschutzbedürfnisse der gespeicherten Daten korrekt einzuschätzen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.1.1** | Prüfen Sie, dass sensible personenbezogene Daten, oder Daten, die unter andere gesetzliche Regelungen zur Vertraulichkeit fallen, verschlüsselt gespeichert werden. | | ✓ | ✓ | 311 |\n| **6.1.2** | Prüfen Sie, dass Gesundheitsdaten, wie z. B. medizinische Aufzeichnungen, Details zu medizinischen Geräten oder deanonymisierte Forschungsaufzeichnungen, verschlüsselt gespeichert werden. | | ✓ | ✓ | 311 |\n| **6.1.3** | Prüfen Sie, dass Finanzdaten, wie z.B. Konten, Zahlungsausfälle oder Kredithistorie, Steuerunterlagen, Lohnhistorie, Begünstigte oder deanonymisierte Markt- oder Forschungsaufzeichnungen verschlüsselt gespeichert werden. | | ✓ | ✓ | 311 |\n\n## V6.2 Algorithmen\n\nFortschritte in der Kryptographie führen dazu, dass bisher sichere Algorithmen und Schlüssellängen nicht länger sicher genug sind, um Daten zu schützen. Daher muss es möglich sein, die Algorithmen zu ändern.\n\nObwohl dieser Abschnitt nicht leicht mittels Pentests geprüft werden kann, sollten Entwickler diesen gesamten Abschnitt als obligatorisch betrachten, auch wenn L1 bei den meisten Punkten fehlt.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.2.1** | Prüfen Sie, dass alle kryptografischen Module in einen sicheren Fehlerzustand fallen und Fehler so behandelt werden, dass keine Padding-Orakel-Angriffe möglich sind. | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Prüfen Sie, dass allgemein anerkannte oder von der Regierung freigegebene kryptografische Algorithmen, Modi und Bibliotheken anstelle von Eigenentwicklungen verwendet werden. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Prüfen Sie, dass der Initialisierungsvektoren, die Chiffrierkonfiguration und die Blockmodi gemäß den neuesten Empfehlungen sicher konfiguriert werden. | | ✓ | ✓ | 326 |\n| **6.2.4** | Prüfen Sie, dass Zufallszahlengeneratoren, Verschlüsselungs- oder Hashalgorithmen, Schlüssellängen, Runden, Chiffren oder Modi jederzeit rekonfiguriert, aktualisiert oder ausgetauscht werden können. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Prüfen Sie, dass unsichere Blockmodi, wie ECB u.a., Padding-Modi, wie PKCS#1 v1.5 u.a., Algorithmen mit kleinen Blockgrößen, wie Triple-DES, Blowfish u.a., sowie schwache Hashalgorithmen, wie MD5, SHA1 u.a., nicht verwendet werden, es sei denn, dies ist aus Gründen der Rückwärtskompatibilität erforderlich. | | ✓ | ✓ | 326 |\n| **6.2.6** | Prüfen Sie, dass Nonces, Initialisierungsvektoren u. ä. nicht mehr als einmal mit einem bestimmten Verschlüsselungsschlüssel verwendet werden dürfen. Die Methode der Generierung muss für den verwendeten Algorithmus geeignet sein. | | ✓ | ✓ | 326 |\n| **6.2.7** | Prüfen Sie, dass verschlüsselte Daten mittels Signaturen, authentifizierte Chiffriermodi oder HMAC authentifiziert werden, um sicherzustellen, dass der Chiffriertext nicht von Unbefugten verändert wird. | | | ✓ | 326 |\n| **6.2.8** | Prüfen Sie, dass alle kryptografischen Operationen zeitkonstant sind und keine „Kurzschluss“-Operationen bei Vergleichen, Berechnungen oder Rückgaben stattfinden, um Informationslecks zu vermeiden. | | | ✓ | 385 |\n\n## V6.3 Zufallswerte\n\nDas Erzeugen von guten Pseudo-Zufallszahlen (PRN) ist unglaublich schwer. Im Allgemeinen werden gute Entropiequellen innerhalb eines Systems schnell erschöpft, wenn sie übermäßig genutzt werden, Quellen mit weniger Entropie hingegen können zu vorhersagbaren Schlüsseln bzw. Geheimnissen führen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.3.1** | Prüfen Sie, dass alle Zufallszahlen, zufälligen Dateinamen, zufälligen GUIDs und Zufallszeichenfolgen mit einem anerkannten kryptografisch sicheren Zufallszahlengenerator generiert werden, wenn diese Zufallswerte für einen Angreifer nicht zu erraten sein sollen. | | ✓ | ✓ | 338 |\n| **6.3.2** | Prüfen Sie, dass zufällige GUIDs mit dem GUID v4-Algorithmus und einem kryptografisch sicheren Zufallszahlengenerator erstellt werden. GUIDs, die mit anderen Zufallszahlengeneratoren erstellt wurden, können vorhersehbar sein. | | ✓ | ✓ | 338 |\n| **6.3.3** | Prüfen Sie, dass die Zufallszahlen mit der richtigen Entropie erzeugt werden, auch wenn die Anwendung unter starker Belastung steht, oder dass die Anwendung unter solchen Umständen angemessen reagiert. | | | ✓ | 338 |\n\n## V6.4 Management von Schlüsseln und Geheimnissen\n\nObwohl dieser Abschnitt nicht leicht mittels Pentests getestet werden kann, sollten Entwickler diesen gesamten Abschnitt als obligatorisch betrachten, auch wenn L1 bei den meisten Punkten fehlt.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.4.1** | Prüfen Sie, dass eine Lösung für das Schlüsselmanagement, wie z.B. ein Schlüsseltresor, verwendet wird, um Geheimnisse sicher zu erstellen, zu speichern, die Nutzung zu kontrollieren und sie zu zerstören. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Prüfen Sie, dass das Schlüsselmaterial nicht in der Anwendung genutzt wird sondern ein Sicherheitsmodul kryptographische Operationen ausführt. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:44.822522"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x15-V7-Error-Logging.md", "content": "# V7 Fehlerbehandlung und Protokollierung\n\n## Ziel\n\nDas primäre Ziel der Fehlerbehandlung und Protokollierung ist es, nützliche Informationen für den Benutzer, die Administratoren und die Incident Response Teams bereitzustellen. Das Ziel besteht nicht darin, große Mengen von Protokollen zu erstellen, sondern hochwertige Protokolle, die mehr Informationen als nutzloses Rauschen enthalten.\n\nHochwertige Protokolle enthalten oft sensible Daten und müssen gemäß den lokalen Datenschutzgesetzen oder -richtlinien geschützt werden. Dies sollte beinhalten:\n\n* Keine sensiblen Informationen zu protokollieren, es sei denn, dies ist ausdrücklich erforderlich.\n* Sicherzustellen, dass alle protokollierten Informationen sicher gehandhabt und gemäß ihrer Datenklassifizierung geschützt werden.\n* Sicherzustellen, dass die Protokolle nicht für immer gespeichert werden, sondern eine möglichst kurze Lebensdauer haben.\n\nWenn Protokolle personenbezogene oder sensible Daten enthalten, werden sie für Angreifer sehr attraktiv.\n\nEs ist ferner wichtig zu gewährleisten, dass die Anwendung in sichere Fehlerzustände fällt und dass Fehler keine unnötigen Informationen offenbaren.\n\n## V7.1 Protokollinhalt\n\nDie Protokollierung sensibler Informationen ist gefährlich - die Protokolle werden selbst sensibel und müssen verschlüsselt werden. Sie unterliegen Aufbewahrungsrichtlinien und müssen bei Sicherheitsaudits offengelegt werden. Prüfen Sie, dass nur die notwendigen Informationen in den Protokollen aufbewahrt werden, jedoch auf keinen Fall Zahlungen, Anmeldedaten, einschließlich Sessiontoken, sensible oder personenbezogene Informationen.\n\nDieser Abschnitt deckt OWASP Top 10 2017:A10 ab. Weil er nicht durch Penetrationstests verifizierbar ist, sollen:\n\n* Entwickler die vollständige Einhaltung dieses Abschnitts sicherstellen, als ob alle Punkte mit L1 gekennzeichnet wären.\n* Penetrationstester die vollständige Einhaltung aller Punkte durch Befragung, Screenshots oder Zusicherungen validieren.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.1.1** | Prüfen Sie, dass die Anwendung keine Anmeldeinformationen oder Zahlungsdetails protokolliert. Sessiontoken sollten nur in einer irreversiblen, gehashten Form in Protokollen gespeichert werden. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Prüfen Sie, dass die Anwendung keine sonstigen sensiblen Daten protokolliert, die z. B. gemäß Datenschutzgesetzen oder den einschlägigen Sicherheitsrichtlinien als solche definiert werden. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Prüfen Sie, dass die Anwendung sicherheitsrelevante Ereignisse, einschließlich erfolgreicher und fehlgeschlagener Authentifizierungsereignisse, Fehler bei der Zugriffskontrolle, Deserialisierungsfehler und Fehler bei der Eingabeprüfung protokolliert. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Prüfen Sie, dass jedes Protokollereignis die notwendigen Informationen enthält, um bei einem Vorfall eine detaillierte Untersuchung der Timeline zu ermöglichen. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Protokollbearbeitung\n\nDie rechtzeitige Protokollierung ist entscheidend für Auditereignisse, Triage und Eskalation. Prüfen Sie, dass die Anwendungsprotokolle klar sind und entweder lokal oder per Versand an ein Fernüberwachungssystem leicht überwacht und analysiert werden können.\n\nDieser Abschnitt deckt OWASP Top 10 2017:A10 ab. Weil er nicht durch Penetrationstests verifizierbar ist, sollen:\n\n* Entwickler die vollständige Einhaltung dieses Abschnitts sicherstellen, als ob alle Punkte mit L1 gekennzeichnet wären.\n* Penetrationstester die vollständige Einhaltung aller Punkte durch Befragung, Screenshots oder Zusicherungen validieren.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.2.1** | Prüfen Sie, dass alle Authentifizierungsentscheidungen protokolliert werden, ohne dass sensible Sitzungstoken oder Passwörter gespeichert werden. Dies sollte auch die relevanten Metadaten umfassen, die für Sicherheitsuntersuchungen benötigt werden. | | ✓ | ✓ | 778 |\n| **7.2.2** | Prüfen Sie, dass alle Authentifizierungen protokolliert werden können, und dass alle fehlgeschlagenen Versuche protokolliert werden. Dies sollte die relevanten Metadaten umfassen, die für Sicherheitsuntersuchungen benötigt werden. | | ✓ | ✓ | 285 |\n\n## V7.3 Schutz von Protokollen\n\nProtokolle, die einfach geändert oder gelöscht werden können, sind für Sicherheitsuntersuchungen nutzlos. Die Offenlegung von Protokollen kann interne Details über die Anwendung oder die darin enthaltenen Daten enthüllen. Schützen Sie Protokoll sorgfältig vor unbefugter Offenlegung, Änderung oder Löschung.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.3.1** | Prüfen Sie, dass alle Komponenten Daten angemessen codieren, um Log-Injektions-Angriffe zu verhindern. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [GELÖSCHT, DUPLIKAT VON 7.3.1] | | | | |\n| **7.3.3** | Prüfen Sie, dass die Protokolle vor unbefugtem Zugriff und Änderungen geschützt werden. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Prüfen Sie, dass die Zeitquellen mit der richtigen Zeit und Zeitzone synchronisiert sind. Erwägen Sie ernsthaft die Protokollierung ausschließlich in UTC, wenn die Systeme global sind, damit die forensische Analyse nach dem Vorfall unterstützt wird. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nHinweis: Das korrekte Codieren von Logeinträgen (7.3.1) ist mit automatisierten Tools und Penetrationstests schwer zu testen, aber Architekten, Entwickler und Quellcodeprüfer sollten sie dennoch als L1-Anforderung betrachten.\n\n## V7.4 Fehlerbehandlung\n\nDer Zweck der Fehlerbehandlung besteht darin, dass die Anwendung sicherheitsrelevante Ereignisse zur Überwachung, Triage und Eskalation bereitstellen kann. Ihr Zweck ist nicht die Erstellung von Protokollen. Bei der Protokollierung sicherheitsrelevanter Ereignisse ist sicherzustellen, dass das Protokoll zielgerichtet ist und dass es durch SIEM- oder Analysesoftware ausgewertet werden kann.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.4.1** | Prüfen Sie, dass bei Auftreten eines unerwarteten oder sicherheitsrelevanten Fehlers eine generische Meldung angezeigt wird. Ggf. kann die Meldung eine ID enthalten, die dem Supportpersonal die Untersuchung erleichtert. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Prüfen Sie, dass die Ausnahmebehandlung in der gesamten Codebasis verwendet wird, um erwartete und unerwartete Fehlerbedingungen zu berücksichtigen. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Prüfen Sie, dass ein Fehlerbehandlungsdienst der letzten Instanz definiert ist, der alle nicht behandelten Ausnahmen abfängt. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nHinweis: Bestimmte Sprachen, wie z.B. Swift und Go - und durch gängige Designpraxis - viele funktionale Sprachen, unterstützen keine Ausnahmen oder letztinstanzliche Fehlerbehandlung. In diesem Fall sollten Architekten und Entwickler anderweitig sicherstellen, dass Anwendungen außergewöhnliche, unerwartete oder sicherheitsrelevante Ereignisse sicher handhaben können.\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:44.960837"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x16-V8-Data-Protection.md", "content": "# V8 Schutz von Informationen\n\n## Ziel\n\nEs gibt drei Schlüsselelemente für die Informationssicherheit: Vertraulichkeit, Integrität und Verfügbarkeit. Dieser Standard geht davon aus, dass die Informationssicherheit auf einem vertrauenswürdigen System, wie z.B. einem Server, durchgesetzt wird, das gehärtet wurde und ausreichend geschützt ist.\n\nAnwendungen müssen davon ausgehen, dass alle Benutzergeräte in irgendeiner Weise gefährdet sind. Wenn eine Anwendung sensible Informationen auf unsicheren Geräten wie gemeinsam genutzten Computern, Telefonen und Tablets überträgt oder speichert, ist die Anwendung dafür verantwortlich, dass die auf diesen Geräten gespeicherten Daten verschlüsselt werden und nicht so einfach unrechtmäßig erlangt, verändert oder offengelegt werden können.\n\nPrüfen Sie, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* Vertraulichkeit: Daten sollten sowohl während der Übertragung als auch bei der Speicherung vor unbefugter Beobachtung oder Offenlegung geschützt werden.\n* Integrität: Daten sollten vor böswilliger Erstellung, Änderung oder Löschung durch unbefugte Angreifer geschützt werden.\n* Verfügbarkeit: Die Daten sollten für autorisierte Benutzer nach Bedarf verfügbar sein.\n\n## V8.1 Allgemeines\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.1.1** | Prüfen Sie, dass die Anwendung sensible Daten davor schützt, in Serverkomponenten wie Loadbalancern, Proxies u.ä. zwischengespeichert zu werden. | | ✓ | ✓ | 524 |\n| **8.1.2** | Prüfen Sie, dass alle serverseitigen temporären Kopien sensibler Daten vor unbefugtem Zugriff geschützt oder nach dem Zugriff des autorisierten Benutzers auf die sensiblen Daten bereinigt/invalidiert werden. | | ✓ | ✓ | 524 |\n| **8.1.3** | Prüfen Sie, dass die Anwendung die Anzahl der Parameter in einer Anfrage, wie z.B. versteckte Felder, Ajax-Variablen, Cookies und Header-Werte minimiert. | | ✓ | ✓ | 233 |\n| **8.1.4** | Prüfen Sie, dass die Anwendung eine abnormale Anzahl von Anfragen, z.B. nach IP, Benutzer, Gesamtzahl pro Stunde oder Tag o. ä., erkennt und Alarm auslöst. | | ✓ | ✓ | 770 |\n| **8.1.5** | Prüfen Sie, dass wichtige Daten regelmäßig gesichert werden und dass die Wiederherstellung regelmäßig geübt wird. | | | ✓ | 19 |\n| **8.1.6** | Prüfen Sie, dass die Backups sicher aufbewahrt werden, um zu verhindern, dass Daten gestohlen oder verfälscht werden. | | | ✓ | 19 |\n\n## V8.2 Clientseitiger Schutz\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.2.1** | Prüfen Sie, dass die Anwendung Anti-Caching Header sendet, damit sensible Daten in modernen Browsern nicht zwischengespeichert werden. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Prüfen Sie, dass die im clientseitigen Speicher (z. B. lokaler HTML5-Speicher, Sitzungsspeicher, IndexedDB oder Cookies) gespeicherten Daten keine sensiblen Daten enthalten. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Prüfen Sie, dass authentifizierte Daten aus dem clientseitigem Speicher, z. B. dem Browser-DOM, gelöscht werden, nachdem der Client geschlossen oder die Sitzung beendet wurde. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Personenbezogene Daten\n\nDieser Abschnitt trägt dazu bei, sensible Daten vor unbefugtem Erstellen, Lesen, Ändern oder Löschen zu schützen.\n\nVoraussetzung für die Umsetzung dieses Abschnittes ist die Einhaltung von V4-Zugriffskontrollmaßnahmen, insbesondere V4.2. So erfordert zum Beispiel der Schutz von personenbezogenen Daten vor unbefugten Veränderungen oder Offenlegung die Einhaltung von V4.2.1. Bitte halten Sie sich an diesen Abschnitt und an V4, um eine vollständige Abdeckung zu erreichen.\n\nHinweis: Datenschutzbestimmungen und -gesetze wie die EU-Datenschutzgrundverordnung oder die Australian Privacy Principles APP-11 wirken sich direkt darauf aus, wie die Speicherung, Nutzung und Übertragung von personenbezogenen Daten in der Anwendung umgesetzt werden muss. Dies reicht von einfachen Ratschlägen bis hin zu schweren Strafen. Bitte prüfen Sie Ihre lokalen Gesetze und Vorschriften und wenden Sie sich bei Bedarf an einen Datenschutzspezialisten.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.3.1** | Prüfen Sie, dass sensible Daten im HTTP-Textkörper oder in Headern an den Server gesendet werden, und dass die Query-String-Parameter aller HTTP-Requests keine sensiblen Daten enthalten. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Prüfen Sie, dass die Benutzer ihre Daten bei Bedarf entfernen oder exportieren können. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Prüfen Sie, dass die Benutzer in verständlicher Sprache über die Erfassung und Verwendung der bereitgestellten personenbezogenen Daten informiert werden und dass die Benutzer ihr Einverständnis zur Verwendung dieser Daten gegeben haben, bevor diese verwendet werden. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Prüfen Sie, dass alle von der Anwendung erstellten und verarbeiteten personenbezogenen Daten identifiziert wurden und dass eine Regelung für den Umgang mit diesen Daten vorhanden ist. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Prüfen Sie, dass bei Zugriff auf personenbezogene Daten geprüft wird - ohne die Daten selbst zu protokollieren - ob die Daten gemäß den einschlägigen Datenschutzrichtlinien erfasst werden oder ob eine Protokollierung des Zugriffs erforderlich ist. | | ✓ | ✓ | 532 |\n| **8.3.6** | Prüfen Sie, dass die im Speicher enthaltenen Informationen überschrieben werden, sobald sie nicht mehr benötigt werden, um Memory-Dump-Angriffe abzuschwächen. | | ✓ | ✓ | 226 |\n| **8.3.7** | Prüfen Sie, dass zu verschlüsselnde Informationen mit anerkannten Algorithmen verschlüsselt werden, die sowohl Vertraulichkeit als auch Integrität gewährleisten. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Prüfen Sie, dass personenbezogene Daten in Bezug auf die Datenspeicherung klassifiziert werden, so dass alte oder veraltete Daten automatisch, nach einem Zeitplan oder je nach Situation gelöscht werden können. | | ✓ | ✓ | 285 |\n\nWenn es um den Datenschutz geht, sollte man in erster Linie an die Massenextraktion oder -modifikation oder an eine übermäßige Nutzung denken. Viele Social-Media-Systeme erlauben beispielsweise nur das Hinzufügen von 100 neuen Freunden pro Tag, aber es ist nicht wichtig, aus welchem System diese Anfragen kommen. Eine Bankingplattform sollte vielleicht mehr als 5 Transaktionen pro Stunde blockieren, welche mehr als 1000 Euro an externe Institute überweisen. Jedes System hat sehr unterschiedliche Anforderungen. Deshalb muss man bei der Entscheidung, was „abnormal“ ist, das Bedrohungsmodell und das Geschäftsrisiko berücksichtigen. Wichtige Kriterien sind hierbei die Fähigkeit, solche abnormalen Massenaktionen zu erkennen, abzuwenden oder vorzugsweise zu blockieren.\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [Nutzen Sie die Website securityheaders.com, um Ihre Site zu testen.](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [Übersicht über die Datenschutz-Grundverordnung der Europäischen Union (DSGVO/ GDPR)](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:45.048576"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x17-V9-Communications.md", "content": "# V9 Kommunikation\n\n## Ziel\n\nEine verifizierte Anwendung erfüllt die folgenden High Level Anforderungen:\n\n* Unabhängig von der Brisanz der Daten wird bei der Übertragung stets TLS oder eine starke Verschlüsselung verwendet.\n* Es werden die aktuellsten Empfehlungen werden verwendet, ins Besondere:\n  * Konfigurationen der Algorithmen\n  * bevorzugt zu verwendende Algorithmen.\n* schwache oder bald veraltende Algorithmen werden am besten gar nicht, höchstens aber mit geringster Priorität genutzt\n* Veraltete oder unsichere Algorithmen werden deaktiviert.\n\nWeiterhin sollten Sie stets:\n\n* auf dem aktuellsten Stand bleiben, da sich die Empfehlungen zur sicheren TLS-Konfiguration häufig ändern. Dies kann auch auf Grund von katastrophalen Angriffen auf Algorithmen geschehen.\n* die aktuellsten Versionen der TLS-Testtools zur Prüfung der Konfiguration nutzen.\n* regelmäßig die Konfiguration testen, um sicherzustellen, dass die Sicherheit der Kommunikation jederzeit gewährleistet ist.\n\n## V9.1 Kommunikationssicherheit des Clients\n\nStellen Sie sicher, dass alle Nahrichten des Clients mit TLS 1.2 oder neuer verschlüsselt werden.\nNutzen Sie regelmäßig die aktuellen Testwerkzeuge, um die Clientkonfiguration zu testen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.1.1** | Prüfen Sie, dass der Client stets TLS-Verbindungen verwendet, das nicht auf unsichere oder unverschlüsselte Konfigurationen zurückfallen. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Prüfen Sie mit aktuellen TLS-Testtools, dass nur starke Algorithmen und Protokolle genutzt werden. Dabei sind die stärksten Algorithmen und neuesten Protokollversionen zu bevorzugen. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Prüfen Sie, dass nur die aktuell empfohlenen Versionen der TLS-Protokolle, also TLS 1.2 und TLS 1.3, genutzt werden. Die neueste Version ist dabei zu bevorzugen. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Sicherheit der Serverkommunikation\n\nServerkommunikation ist mehr als nur HTTP. Es müssen sichere Verbindungen zu und von anderen Systemen - wie Überwachungssysteme, Managementtools, Fernzugriff und ssh, Middleware, Datenbank, Mainframes, Partner- oder externe Quellsysteme eingerichtet werden. All diese müssen verschlüsselt werden, um zu verhindern, dass sie nach außen schwer aber nach innen kinderleicht abzufangen sind.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.2.1** | Prüfen Sie, dass Verbindungen zum und vom Server vertrauenswürdige TLS-Zertifikate verwenden. Werden intern generierte oder selbstsignierte Zertifikate verwendet, muss der Server so konfiguriert werden, dass er nur bestimmten internen CAs vertraut. Alle anderen müssen abgelehnt werden. | | ✓ | ✓ | 295 |\n| **9.2.2** | Prüfen Sie, dass eine verschlüsselte Kommunikation wie TLS für alle ein- und ausgehenden Verbindungen, einschließlich für Managementports, Überwachung, Authentifizierung, API- oder Webservicecalls, Datenbank-, Cloud-, serverlose, Mainframe-, externe und Partnerverbindungen verwendet wird. Der Server darf nicht auf unsichere oder unverschlüsselte Protokolle zurückgreifen. | | ✓ | ✓ | 319 |\n| **9.2.3** | Prüfen Sie, dass alle verschlüsselten Verbindungen zu externen Systemen, die sensible Informationen oder Funktionen beinhalten, authentifiziert sind. | | ✓ | ✓ | 287 |\n| **9.2.4** | Prüfen Sie, dass eine ordnungsgemäßer Zertifikatssperre wie z. B. das Online Certificate Status Protocol Stapling aktiviert und konfiguriert ist. | | ✓ | ✓ | 299 |\n| **9.2.5** | Prüfen Sie, dass TLS-Verbindungsfehler in das Backend protokolliert werden. | | | ✓ | 544 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Hinweise zu „Anerkannten TLS-Modi”:\n    * In der Vergangenheit bezog sich der ASVS auf den US-Standard FIPS 140. Als globaler Standard kann die Anwendung von US-Standards allerdings schwierig, widersprüchlich oder verwirrend sein.\n    * Eine bessere Methode, um die Einhaltung des Abschnittes 9.1 zu erreichen, wäre die Überprüfung von Leitfäden wie [Mozillas serverseitigem TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) oder die [Erstellung anerkannt sicherer Konfigurationen](https://mozilla.github.io/server-side-tls/ssl-config-generator/) und die Verwendung bekannter TLS-Evaluierungs-Tools wie Sslyze, verschiedener Schwachstellenscanner oder vertrauenswürdiger TLS-Online-Assessment Services, um ein gewünschtes Sicherheitsniveau zu erreichen. In Sicherheitstests sehen wir die fehlende Konformität zu diesem Abschnitt durch die Verwendung veralteter oder unsicherer Algorithmen, dem Fehlen einer perfekten Forward Secrecy, veralteten oder unsicheren SSL-Protokollen, schwachen bevorzugten Algorithmen usw.\n    * Für Deutschland veröffentlicht das BSI die [Technische Richtlinie TR-02102 Kryptographische Verfahren: Empfehlungen und Schlüssellängen](https://www.bsi.bund.de/DE/Themen/Unternehmen-und-Organisationen/Standards-und-Zertifizierung/Technische-Richtlinien/TR-nach-Thema-sortiert/tr02102/tr02102_node.html) als Richtlinie für die Verwendung von TLS sowie zur Nutzung sicherer Algorithmen und Schlüssellängen.\n", "timestamp": "2025-10-24T11:39:45.160089"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x18-V10-Malicious.md", "content": "# V10 Bösartiger Code\n\n## Ziel\n\nStellen Sie sicher, dass der Code die folgenden High Level Anforderungen erfüllt:\n\n* Böswillige Aktivitäten werden sicher und ordnungsgemäß behandelt, um den Rest der Anwendung nicht zu beeinträchtigen.\n* Es gibt keine Zeitbomben oder andere zeitbasierte Angriffe.\n* Es gibt kein „Phone Home“ zu böswilligen oder nicht autorisierten Zielen.\n* Es gibt keine Hintertüren, Ostereier, Salamitaktik-Angriffe, Rootkits oder nicht autorisierte Codes, die von einem Angreifer kontrolliert werden können.\n\nDas Feststellen der Abwesenheit bösartigen Codes ist der Negativbeweis, der unmöglich vollständig geführt werden kann. Es sollten alle Anstrengungen unternommen werden, um sicherzustellen, dass die Software keinen inhärenten bösartigen Code und keine unerwünschten Funktionen aufweist.\n\n## V10.1 Kontrollen der Code-Integrität\n\nDie beste Verteidigung gegen bösartigen Code ist der Wahlspruch „Vertrauen ist gut, Kontrolle ist besser“. Das Einbringen eines nicht autorisierten oder bösartigen Codes in eine Software ist in vielen Rechtsordnungen ein kriminelles Vergehen. Die Richtlinien zur Softwareentwicklung sollten auf die Sanktionen für das Einbringen bösartigen Codes deutlich hinweisen.\n\nLeitende Entwickler sollten regelmäßig die Eincheckvorgänge für den Code überprüfen, insbesondere diejenigen, die auf Zeit-, Eingabe-, Ausgabe- oder Netzwerkfunktionen zugreifen können.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.1.1** | Prüfen Sie, dass ein Codeanalyse-Tool verwendet wird, das potenziell bösartigen Code, wie Zeitfunktionen, unsichere Dateioperationen und Netzwerkverbindungen erkennen kann. | | | ✓ | 749 |\n\n## V10.2 Suche nach bösartigem Code\n\nBösartiger Code ist extrem selten und schwer zu erkennen. Eine manuelle, zeilenweise Überprüfung des Codes kann bei der Suche nach Logikbomben helfen, aber selbst die erfahrensten Codereviewer werden Schwierigkeiten haben, bösartigen Code zu finden, selbst wenn sie wissen, dass er existiert.\n\nDie Einhaltung dieses Abschnitts kann nicht ohne vollständigen Zugriff auf den Quellcode, einschließlich der Bibliotheken von Drittanbietern, geprüft werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.2.1** | Prüfen Sie, dass der Quellcode der Anwendung und die Bibliotheken von Drittanbietern keine Möglichkeiten zum Phone Home oder zur Datenerfassung enthalten. Wenn solche Funktionen vorhanden sind, holen Sie die Erlaubnis des Benutzers ein, bevor Daten gesammelt werden. | | ✓ | ✓ | 359 |\n| **10.2.2** | Prüfen Sie, dass die Anwendung keine unnötigen oder übermäßigen Genehmigungen für datenschutzrelevante Funktionen oder Sensoren wie Kontakte, Kameras, Mikrofone oder Standorte verlangt. | | ✓ | ✓ | 272 |\n| **10.2.3** | Prüfen Sie, dass der Quellcode der Anwendung und die Bibliotheken von Drittanbietern keine Hintertüren enthalten, wie z. B. hartcodierte oder zusätzliche undokumentierte Konten oder Schlüssel, Codeverschleierung, undokumentierte Binärblobs, Rootkits oder Anti-Debugging, unsichere Debuggingfunktionen oder andere veraltete, unsichere oder versteckte Funktionen, die bei Entdeckung böswillig verwendet werden könnten. | | | ✓ | 507 |\n| **10.2.4** | Prüfen Sie, dass der Quellcode der Anwendung und die Bibliotheken von Drittanbietern keine Zeitbomben enthalten, wenn sie nach datums- und zeitbezogenen Funktionen suchen. | | | ✓ | 511 |\n| **10.2.5** | Prüfen Sie, dass der Quellcode der Anwendung und die Bibliotheken von Drittanbietern keinen bösartigen Code wie Salamitaktik-Angriffe, logische Umgehungen oder Logikbomben enthalten. | | | ✓ | 511 |\n| **10.2.6** | Prüfen Sie, dass der Quellcode der Anwendung und die Bibliotheken von Drittanbietern keine Ostereier oder andere unerwünschte Funktionen enthalten. | | | ✓ | 507 |\n\n## V10.3 Integrität der Anwendung\n\nNach Bereitstellung einer Anwendung kann immer noch bösartiger Code eingefügt werden. Anwendungen müssen sich vor gängigen Angriffen wie die Ausführung unsignierten Codes aus nicht vertrauenswürdigen Quellen und die Übernahme von Subdomänen schützen.\n\nDie Einhaltung der Anforderungen dieses Abschnitts sind operativ und fortlaufend zu prüfen.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.3.1** | Prüfen Sie, dass Updates über sichere Kanäle bezogen und digital signiert werden müssen, wenn die Anwendung über eine automatische Client- oder Server Updatefunktion verfügt. Die digitale Signatur des Updates muss validiert werden, bevor das Update installiert wird. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Prüfen Sie, dass die Anwendung einen Integritätsschutz, wie Code Signing oder Subresource Integrity verwendet. Die Anwendung darf keinen Code aus nicht vertrauenswürdigen Quellen laden oder ausführen, wie z. B. das Laden von Includes, Modulen, Plugins, Codes oder Bibliotheken aus nicht vertrauenswürdigen Quellen oder dem Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Prüfen Sie, ob die Anwendung Schutz vor der Übernahme von Subdomänen bietet, wenn die Anwendung auf DNS-Einträge oder DNS-Subdomänen angewiesen ist, z. B. abgelaufene Domänennamen, veraltete DNS-Pointer oder CNAMEs, abgelaufene Projekte in öffentlichen Quellcoderepositories oder vorübergehende Cloud-APIs, serverlose Funktionen oder Storage Buckets (autogen-bucket-id.cloud.example.com) oder Ähnliches. Die von den Anwendungen verwendeten DNS-Namen sind regelmäßig auf Ablauf oder Änderung zu überprüfen. | ✓ | ✓ | ✓ | 350 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:45.260149"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x19-V11-BusLogic.md", "content": "# V11 Fachliche Funktionalität\n\n## Ziel\n\nStellen Sie sicher, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* Der Fluss der Geschäftslogik ist sequentiell: Er wird der Reihe nach verarbeitet und kann nicht umgangen werden.\n* Die Geschäftslogik enthält Grenzen zur Erkennung und Verhinderung automatisierter Angriffe, wie z. B. kontinuierliche kleine Geldtransfers oder das Hinzufügen von einer Million Freunden, einer nach dem anderen, etc.\n* Hochwertige Modelle der Geschäftslogik haben Missbrauchsfälle und böswillige Akteure in Betracht gezogen und sind gegen Spoofing, Manipulation, Abstreiten, Informationspreisgabe und die Erweiterung von Rechten immun.\n\n## V11.1 Sicherheit der fachlichen Funktionen\n\nDie Sicherheit der Geschäftslogik ist für jede Anwendung zu individuell, als dass dafür jemals eine einzige Checkliste erstellt werden könnte. Die Sicherheit der Geschäftslogik muss so konzipiert sein, dass sie vor voraussichtlichen externen Bedrohungen Schutz bietet - sie kann nicht durch Webanwendungsfirewalls oder sichere Kommunikation hinzugefügt werden. Wir empfehlen die Verwendung von Threat Modeling während der Designsprints, z.B. mit dem OWASP Cornucopia oder ähnlichen Tools.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **11.1.1** | Prüfen Sie, dass die Anwendung nur Geschäftslogikflüsse für denselben Benutzer in sequentieller Schrittfolge und ohne das Überspringen von Schritten verarbeitet. | ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Prüfen Sie, dass die Anwendung nur Abläufe der Geschäftslogik verarbeitet, wenn alle Schritte in realistischer menschlicher Zeit bearbeitet werden, d.h. die Transaktionen werden nicht zu schnell durch automatisierte Angreifer eingereicht. | ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Prüfen Sie, dass die Anwendung über angemessene Grenzen für bestimmte Geschäftsaktionen oder Transaktionen verfügt, die für jeden Benutzer korrekt durchgesetzt werden. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Prüfen Sie, dass die Anwendung über ausreichende Maßnahmen gegen automatische Nutzung verfügt, um Datenausleitung, übermäßige Anforderungen an die Geschäftslogik, übermäßige Dateiuploads oder DoS-Angriffe zu erkennen und sich dagegen zu schützen. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Prüfen Sie, ob die Anwendung Grenzen der Geschäftslogik oder eine Validierung zum Schutz vor wahrscheinlichen Geschäftsrisiken oder Bedrohungen aufweist, die mit Hilfe von Threat Modeling oder ähnlichen Methoden ermittelt wurden. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Prüfen Sie, dass die Anwendung nicht unter TOCTOU oder anderen Raceconditions für sensible Operationen leidet. | | ✓ | ✓ | 367 |\n| **11.1.7** | Prüfen Sie die Anwendungsmonitore auf ungewöhnliche Ereignisse oder Aktivitäten aus der Sicht der Geschäftslogik. Zum Beispiel auf Versuche, Aktionen durchzuführen, die außerhalb der Reihe sind, oder Aktionen, die ein normaler Benutzer niemals versuchen würde. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Prüfen Sie, dass die Anwendung über konfigurierbare Web Warnmeldungen verfügt, wenn automatisierte Angriffe oder ungewöhnliche Aktivitäten entdeckt werden. | | ✓ | ✓ | 390 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* Schutz gegen automatische Angriffe kann auf vielfältige Weise erreicht werden, z.B.: [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* Der [OWASP AppSensor](https://github.com/jtmelton/appsensor) kann auch bei der Erkennung und der Bewältigung von Angriffen helfen.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:45.399421"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x20-V12-Files-Resources.md", "content": "# V12 Dateien und andere Ressourcen\n\n## Ziel\n\nStellen Sie sicher, dass eine verifizierte Anwendung die folgenden High Level Anforderungen erfüllt:\n\n* nicht vertrauenswürdige Datendateien müssen angepasst und auf sichere Weise behandelt werden.\n* nicht vertrauenswürdige Datendateien, die aus nicht vertrauenswürdigen Quellen stammen, werden außerhalb des Webroots und mit eingeschränkten Berechtigungen gespeichert.\n\n## V12.1 Dateiupload\n\nObwohl Zip-Bomben hervorragend mit Penetrationstests getestet werden können, werden sie als L2 und höher eingestuft, um die Berücksichtigung von Design und Entwicklung durch sorgfältige manuelle Tests zu fördern und einen ungewollten DoS-Angriff durch automatische oder unqualifizierte manuelle Penetrationstests zu vermeiden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.1.1** | Prüfen Sie, dass die Anwendung keine großen Dateien akzeptiert, die den Speicher füllen oder einen DoS-Angriff verursachen könnten. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Prüfen Sie, dass die Anwendung gepackte Formate, wie z.B. zip, gz, docx oder odt vor dem Entpacken auf die maximal zulässige Filegröße und die maximale Anzahl Dateien überprüft. | | ✓ | ✓ | 409 |\n| **12.1.3** | Prüfen Sie, dass die Dateigröße und die maximale Anzahl von Dateien pro Benutzer limitiert wird, um sicherzustellen, dass ein einzelner Benutzer den Speicher nicht mit zu vielen oder übermäßig großen Dateien füllen kann. | | ✓ | ✓ | 770 |\n\n## V12.2 Dateiintegrität\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.2.1** | Prüfen Sie, dass Dateien aus nicht vertrauenswürdigen Quellen sowohl auf der Grundlage des Dateiinhalts als auch des erwarteten Typs validiert werden. | | ✓ | ✓ | 434 |\n\n## V12.3 Ausführbare Dateien\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.3.1** | Prüfen Sie, dass die vom Benutzer eingereichten Metadaten der Dateinamen nicht direkt vom Filesystem des Betriebssystems oder des Frameworks genutzt werden. Weiterhin ist eine URL-API zu verwenden, um vor Path Traversal zu schützen. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Prüfen Sie, dass die vom Benutzer eingereichten Metadaten der Dateinamen validiert oder ignoriert werden, um die Offenlegung, Erstellung, Aktualisierung oder Entfernung lokaler Dateien zu verhindern. | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Prüfen Sie, dass die vom Benutzer eingereichten Metadaten der Dateinamen validiert oder ignoriert werden, um die Offenlegung oder Ausführung von serverseitigen Dateien via Remote File Inclusion (RFI) oder Serverside Request Forgery (SSRF) Angriffen zu verhindern. | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Prüfen Sie, dass die Anwendung vor Reflective File Download (RFD) schützt, indem sie die vom Benutzer eingereichten Dateinamen in einem JSON-, JSONP- oder URL-Parameter validiert oder ignoriert. Der Content-Type Header der Antwort muss auf text/plain gesetzt werden, und der Content-Disposition Header muss einen festen Dateinamen haben. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Prüfen Sie, dass nicht vertrauenswürdige Dateimetadaten nicht direkt mit der System-API oder Bibliotheken verwendet werden, um vor OS Command Injection zu schützen. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Prüfen Sie, dass die Anwendung keine Funktionen aus nicht vertrauenswürdigen Quellen, wie z. B. nicht verifizierte Inhaltsverteilungsnetzwerke, JavaScript-Bibliotheken, node npm-Bibliotheken oder serverseitige DLLs, enthält und ausführt. | | ✓ | ✓ | 829 |\n\n## V12.4 Speicherung von Dateien\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.4.1** | Prüfen Sie, dass Dateien aus nicht vertrauenswürdigen Quellen mit eingeschränkten Berechtigungen und vorzugsweise mit starker Validierung außerhalb des Webroots gespeichert werden. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Prüfen Sie, dass Dateien aus nicht vertrauenswürdigen Quellen von Antivirenscannern gescannt werden, um das Hochladen bekannter bösartiger Inhalte zu verhindern. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Download von Dateien\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.5.1** | Prüfen Sie, dass die Webschicht so konfiguriert ist, dass nur Dateien mit bestimmten Dateierweiterungen bedient werden, um unbeabsichtigte Informations- und Quellcodelecks zu vermeiden. Beispielsweise sollten Sicherungsdateien (z.B. .bak), temporäre Arbeitsdateien (z.B. .swp), komprimierte Dateien (.zip, .tar, .gz, usw.) und andere von den Editoren üblicherweise verwendete Erweiterungen blockiert werden, sofern sie nicht erforderlich sind. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Prüfen Sie, dass direkte Anfragen an hochgeladene Dateien niemals als HTML/JavaScript-Inhalt ausgeführt werden. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 SSRF-Schutz\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.6.1** | Prüfen Sie, dass der Web- oder Anwendungsserver mit einer Whitelist von Ressourcen oder Systemen konfiguriert ist, an die der Server Anfragen senden oder Daten/Dateien laden kann. | ✓ | ✓ | ✓ | 918 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:45.477509"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x21-V13-API.md", "content": "# V13 API and Web Service\n\n## Ziel\n\nPrüfen Sie, dass eine verifizierte Anwendung, die vertrauenswürdige Serviceschicht-APIs verwendet - üblicherweise unter Verwendung von JSON oder XML oder GraphQL - über Folgendes verfügt:\n\n* Angemessene Authentifizierung, Session Management und Autorisierung aller Webdienste.\n* Eingabeprüfung aller Parameter, die von einer niedrigeren auf eine höhere Vertrauensstufe übergehen.\n* Effektive Sicherheitsmaßnahmen für alle API-Typen, einschließlich Cloud- und Serverlose API\n\nBitte lesen Sie dieses Kapitel in Kombination mit allen anderen Kapiteln derselben Stufe. Themen, wie z.B. Authentifizierung oder API-Session Management, werden hier nicht erneut aufgeführt.\n\n## V13.1 Allgemeine Sicherheit von Web Services\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.1.1** | Prüfen Sie, dass alle Komponenten die gleichen Parser und (Zeichen-)Codierungen nutzen, um Angriffe auf Basis unterschiedlichen URI- oder File-Parsings, wie SSRF oder RFI, zu verhindern. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [GELÖSCHT, DUPLIKAT VON 4.3.1] | | | | |\n| **13.1.3** | Prüfen Sie, dass API-URLs keine sensiblen Informationen wie den API-Schlüssel, Sessiontoken, etc. preisgeben. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Prüfen Sie, dass Berechtigungsentscheidungen sowohl an der URI, umgesetzt durch programmatische oder deklarative Sicherheit am Controller oder Router, als auch auf der Ressourcenebene, umgesetzt durch modellbasierte Berechtigungen, getroffen werden. | | ✓ | ✓ | 285 |\n| **13.1.5** | Prüfen Sie, dass Anfragen mit unerwarteten oder fehlenden Inhaltstypen mit entsprechenden Headern zurückgewiesen werden (HTTP-Antwortstatus 406 oder 415). | | ✓ | ✓ | 434 |\n\n## V13.2 RESTful Web Services\n\nDie Validierung des JSON-Schemas befindet sich im Entwurfsstadium der Standardisierung (siehe Referenzen). Wenn Sie die Verwendung der JSON-Schemavalidierung in Betracht ziehen, welche die Best Practice für RESTful-Webservices darstellt, sollten Sie die Verwendung dieser zusätzlichen Datenvalidierungsstrategien in Kombination mit der JSON-Schemavalidierung in Betracht ziehen:\n\n* Parsing-Validierung des JSON-Objekts, z. B. ob es fehlende oder zusätzliche Elemente gibt.\n* Validierung der Werte des JSON-Objekts mit Hilfe der üblichen Eingabeprüfungsmethoden, wie z. B. Prüfung auf Datentyp, Datenformat, Länge usw. und\n* formale JSON-Schemavalidierung.\n\nSobald der JSON-Schemavalidierungsstandard formalisiert ist, wird der ASVS seine Empfehlungen in diesem Bereich aktualisieren. Alle verwendeten JSON-Schemavalidierungsbibliotheken müssen sorgfältig überwacht werden, da sie regelmäßig aktualisiert werden müssen, bis der Standard formalisiert ist und Fehler in den Referenzimplementierungen behoben sind.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.2.1** | Prüfen Sie, dass aktivierte RESTful-HTTP-Methoden eine gültige Wahl für den Benutzer oder eine Aktion sind, wie z.B. verhindern, dass normale Benutzer DELETE oder PUT auf geschützte API oder Ressourcen anwenden. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Prüfen Sie, dass die JSON-Schemavalidierung vorhanden und verifiziert ist, bevor Sie eine Eingabe akzeptieren. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Prüfen Sie, dass RESTful-Webdienste, die Cookies verwenden, durch die Verwendung von mindestens einem oder mehrerer der folgenden Verfahren vor Cross Site Request Forgery geschützt sind: Double Submit Cookie Pattern, CSRF-Nonces oder Prüfungen des Origin-Request Headers. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [GELÖSCHT, DUPLIKAT VON 11.1.4] | | | | |\n| **13.2.5** | Prüfen Sie, dass die REST-Dienste explizit prüfen, ob der eingehende Contenttyp der erwartete ist, z.B. application/xml oder application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Prüfen Sie, dass die Message Header und die Nutzdaten vertrauenswürdig sind und während der Übertragung nicht verändert werden. Die Anforderung einer starken Verschlüsselung für den Transport (nur TLS) kann in vielen Fällen ausreichend sein, da sie sowohl die Vertraulichkeit als auch den Schutz der Integrität gewährleistet. Digitale Signaturen pro Nachricht können bei Hochsicherheitsanwendungen für zusätzliche Sicherheit beim Transportschutz sorgen, bringen aber zusätzliche Komplexität und Risiken mit sich, die gegen die Vorteile abzuwägen sind. | | ✓ | ✓ | 345 |\n\n## V13.3 SOAP Web Service\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.3.1** | Prüfen Sie, dass vor der Verarbeitung von Eingabedaten zuerst eine XSD-Schemavalidierung stattfindet, um ein korrekt geformtes XML-Dokument zu gewährleisten, gefolgt von der Validierung jedes Eingabefeldes. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Prüfen Sie, dass die Nutzdaten der Nachricht mit WS-Security signiert sind, um einen zuverlässigen Transport zwischen Client und Service zu gewährleisten. | | ✓ | ✓ | 345 |\n\nHinweis: Aufgrund von Problemen mit XXE-Angriffen auf DTDs sollte die DTD-Validierung nicht verwendet und die DTD-Frameworkauswertung gemäß der im Abschnitt V14-Konfiguration festgelegten Anforderungen deaktiviert werden.\n\n## V13.4 GraphQL\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.4.1** | Prüfen Sie, dass eine Query Whitelist oder eine Kombination von Begrenzung der Tiefe und Anzahl verwendet werden sollte, um einen DoS-Angriff von GraphQL oder Datenschichtausdrücken als Folge teurer, verschachtelter Abfragen zu verhindern. Für fortgeschrittenere Szenarien sollte die Abfragekostenanalyse verwendet werden. | | ✓ | ✓ | 770 |\n| **13.4.2** | Prüfen Sie, dass die Berechtigungen für die Datenschicht, z.B. GraphQL, in der Geschäftslogikschicht anstelle der Datenschicht umgesetzt ist. | | ✓ | ✓ | 285 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:45.555677"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x22-V14-Config.md", "content": "# V14 Konfiguration\n\n## Ziel\n\nStellen Sie sicher, dass eine geprüfte Anwendung mit den folgenden Merkmalen ausgestattet ist:\n\n* Eine sichere und automatisierbare Buildumgebung.\n* Ein sicheres Management von Drittanbieterbibliotheken, Abhängigkeiten und Konfigurationen, so dass veraltete oder unsichere Komponenten nicht in die Anwendung integriert werden.\n\nDie Konfiguration der Anwendung sollte „out of the box“ für den jeweils geplanten Einsatzzweck sicher sein.\n\n## V14.1 Build- und Deployprozess\n\nBuild Pipelines sind die Grundlage für wiederholbare Sicherheit. Jedes Mal, wenn etwas Unsicheres entdeckt wird, kann es im Quellcode, den Build- oder Deploymentskripten behoben und automatisch getestet werden. Wir befürworten nachdrücklich die Verwendung von Buildpipelines mit automatischen Sicherheits- und Abhängigkeitsprüfungen, die den Build ggf. unterbrechen, um zu verhindern, dass bekannte Sicherheitsprobleme in der Produktion angewendet werden. Unregelmäßig durchgeführte manuelle Schritte führen direkt zu vermeidbaren Sicherheitsfehlern.\n\nDa die Branche zu einem DevSecOps-Modell übergeht, ist es wichtig, die kontinuierliche Verfügbarkeit und Integrität der Bereitstellung und Konfiguration zu gewährleisten, um einen bekannten funktionierenden (known good) Zustand zu erreichen. In der Vergangenheit dauerte es Tage bis Monate, wenn ein System gehackt wurde, um nachzuweisen, dass kein weiteres Eindringen stattgefunden hatte. Heute, mit dem Aufkommen der softwaredefinierten Infrastruktur, schnellen A/B-Deployment ohne Ausfallzeiten und automatisierten, containerisierten Builds, ist es möglich, automatisch und kontinuierlich einen „known good“-Ersatz für jedes kompromittierte System zu erstellen, zu härten und einzusetzen.\n\nWenn noch traditionelle Modelle im Einsatz sind, müssen manuelle Schritte zur Härtung und Sicherung dieser Konfiguration erfolgen, damit die kompromittierten Systeme schnell durch hochintegrierte, sichere Systeme ersetzt werden können.\n\nUm die Anforderungen dieses Abschnitts einzuhalten, ist ein automatisiertes Buildsystem und der Zugriff auf Build- und Deploymentskripte erforderlich.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.1.1** | Prüfen Sie, dass die Build- und Deploymentprozesse auf sichere und wiederholbare Weise durchgeführt werden, z. B. durch CI-/CD-Automatisierung, automatisiertes Konfigurationsmanagement und automatisierte Deploymentskripte. | | ✓ | ✓ | |\n| **14.1.2** | Prüfen Sie, dass die Compilerflags so konfiguriert sind, dass sie alle verfügbaren Pufferüberlaufschutzmechanismen und Warnungen aktivieren, einschließlich der Stackrandomisierung, der Verhinderung der Datenausführung und des Buildabbruchs, wenn ein(e) unsichere(r) Pointer, Speicher, Formatstring, Integer- oder Stringoperationen gefunden wird. | | ✓ | ✓ | 120 |\n| **14.1.3** | Prüfen Sie, dass die Serverkonfiguration gemäß den Empfehlungen des verwendeten Anwendungsservers und Frameworks gehärtet wird. | | ✓ | ✓ | 16 |\n| **14.1.4** | Prüfen Sie, dass die Anwendung, die Konfiguration und alle Abhängigkeiten mit Hilfe automatisierter Deploymentskripte wieder installiert werden können, indem sie innerhalb eines angemessenen Zeitraums aus einem dokumentierten und getesteten Runbook erstellt oder aus Backups zeitnah wiederhergestellt werden können. | | ✓ | ✓ | |\n| **14.1.5** | Prüfen Sie, dass autorisierte Administratoren die Integrität aller sicherheitsrelevanten Konfigurationen überprüfen können, um Manipulationen zu erkennen. | | | ✓ | |\n\n## V14.2 Management von Abhängigkeiten\n\nDie Verwaltung von Abhängigkeiten ist für den sicheren Betrieb jeder Art von Anwendung von entscheidender Bedeutung. Das Versäumnis, veraltete oder unsichere Abhängigkeiten auf dem aktuellen Stand zu halten, ist die eigentliche Ursache für die bisher größten und teuersten Angriffe.\n\nHinweis: Auf Stufe 1 bezieht sich die Einhaltung von 14.2.1 auf Beobachtungen oder Feststellungen von Client- und anderen Bibliotheken und Komponenten und nicht auf die genauere statische Codeanalyse oder Abhängigkeitsanalyse zur Buildzeit. Diese genaueren Techniken könnten bei Bedarf durch Befragung festgestellt werden.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.2.1** | Prüfen Sie, dass alle Komponenten auf dem neuesten Stand sind, am besten mit einem Abhängigkeitsprüfer zur Build- oder Kompilierzeit. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Prüfen Sie, dass alle nicht benötigten Funktionen, Dokumentationen, Beispiele und Konfigurationen entfernt werden. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Prüfen Sie, dass die Integrität externen Inhaltes durch Subresource Integrity (SRI) überprüft wird, wenn Anwendungsassets wie JavaScript-Bibliotheken, CSS oder Web-Fonts extern, z.B. bei einem Content Delivery Network oder bei einem externen Anbieter, gehostet werden. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Prüfen Sie, dass Komponenten Dritter aus bekannten, vertrauenswürdigen und kontinuierlich gepflegten Repositories stammen. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Prüfen Sie, dass eine Softwarestückliste (Bill of Materials, SBOM) aller genutzten Bibliotheken von Drittanbietern geführt wird. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Prüfen Sie, dass die Angriffsfläche durch Sandboxing oder Einkapselung von Bibliotheken von Drittanbietern reduziert wird, damit die Anwendung nur die erforderliche Funktionalität erhält. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Offenlegung von Informationen\n\nKonfigurationen für die Produktion sollten gehärtet werden. So schützen sie gegen gängige Angriffe wie Debugkonsolen, und legen die Messlatte für Cross Site Scripting (XSS) und Remote File Inclusion (RFI) Angriffe höher. Triviale Schwachstellen bei der Informationserfassung, die das unwillkommene Kennzeichen vieler Penetrationstestreports sind, werden so beseitigt. Viele dieser Probleme werden selten als signifikantes Risiko eingestuft, sondern sind mit anderen Schwachstellen verkettet. Wenn diese Probleme nicht standardmäßig vorhanden sind, wird die Messlatte für einen erfolgreichen Angriff deutlich höher gelegt.\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.3.1** | [GELÖSCHT, DUPLIKAT VON 7.4.1] | | | | |\n| **14.3.2** | Prüfen Sie, dass die Debugmodi von Web- und Anwendungsserver sowie Anwendungsframework in der Produktion deaktiviert sind, um Sicherheitslücken durch Debugfunktionen oder Entwicklerkonsolen zu vermeiden. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Prüfen Sie, dass die HTTP-Header und HTTP-Antworten keine detaillierten Versionsinformationen von Systemkomponenten enthalten. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 HTTP Security Header\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.4.1** | Prüfen Sie, dass jede HTTP-Antwort einen Content Type Header enthält. Für die Content types text/*, /+xml oder application/xml sollten ein sicherer Zeichensatz (z. B. UTF-8, ISO 8859-1) angeben sein. Der Inhalt muss zum angegebenen Content Type Header passen. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Prüfen Sie, dass alle API-Antworten die Content-Disposition: attachment; filename=\"api.json\" Header oder einen anderen geeigneten Dateinamen für den Inhaltstyp enthalten. | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Prüfen Sie, dass ein Content Security Policy (CSP) Response Header vorhanden ist, die dazu beiträgt, die Auswirkungen von XSS-Angriffen wie HTML-, DOM-, JSON- und JavaScript-Injektionsschwachstellen abzuschwächen. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Prüfen Sie, dass alle Antworten X-Content-Type-Optionen: nosniff Header enthalten. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Prüfen Sie, dass ein HTTP Strict-Transport-Security Header in allen Antworten und für alle Unterdomänen enthalten ist, z. B. Strict-Transport-Security: max-age=15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Prüfen Sie, dass ein geeigneter Referrer-Policy Header enthalten ist, um das Veröffentlichen sensibler Informationen über den Referer Header zu vermeiden. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Prüfen Sie, dass der Inhalt einer Webanwendung nicht standardmäßig in Seiten Dritter eingebunden werden kann. Das Einbinden der exakten Ressourcen ist nur erlaubt, wenn nötig. Dabei sind passende Content-Security-Policy: frame-ancestors und X-Frame-Options Response Header zu nutzen. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Prüfung der HTTP Request Header\n\n| # | Beschreibung | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.5.1** | Prüfen Sie, dass der Anwendungsserver nur die von der Anwendung oder der API verwendeten HTTP-Methoden akzeptiert, einschließlich der Pre-Flight-OPTIONS. Alle ungültigen Request sollten ins Log geschrieben werden oder einen Alarm auslösen. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Prüfen Sie, dass der bereitgestellte Origin Header nicht für Authentifizierungs- oder Zugriffskontrollentscheidungen verwendet wird, da der Origin Header von einem Angreifer leicht geändert werden kann. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Prüfen Sie, dass der CORS-Access-Control-Allow-Origin Header eine strikte Whitelist mit vertrauenswürdigen Domains verwendet und den \"null\"-Ursprung nicht unterstützt. | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Prüfen Sie, dass HTTP-Header, die von einem vertrauenswürdigen Proxy oder SSO-Geräten, wie z. B. einem Bearer-Token, hinzugefügt wurden, von der Anwendung authentifiziert werden. | | ✓ | ✓ | 306 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* [Reflected File Download attacks](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf) zeigt, wie durch Hinzufügen der Content-Disposition und der \"filename\" Option in die API-Antwort viele Angriffe, die auf verschiedenen Interpretationen des MIME-Types durch Client und Server beruhen, unterbunden werden können.\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:45.636314"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x90-Appendix-A_Glossary.md", "content": "# Anhang A: Glossar\n\n* **2FA: Zwei-Faktor-Authentifizierung** - fügt eine zweite Authentifizierungsebene zu einer Kontoanmeldung hinzu, z.B. neben einer PIN („Wissen“) auch eine Chipkarte („Besitz“).\n* **Anwendungssicherheit** - Sicherheit auf Anwendungsebene konzentriert sich auf die Analyse von Komponenten, welche die Anwendungsschicht des Open Systems Interconnection Reference Model (OSI-Modell) bilden.\n* **ASLR: Addressspace Layout Randomisation** - Eine Technik, welche das Ausnutzen von Fehlern der Speicherverwaltung erschwert.\n* **Authentifizierung** - Der Nachweis der behaupteten Identität eines Anwendungsbenutzers.\n* **Authentifikator** - Code, der ein Kennwort, ein Token, einen MFA, eine föderierte Behauptung usw. authentifiziert.\n* **Automatisierte Verifizierung** - Die Verwendung von automatisierten Tools, die Schwachstellensignaturen verwenden, um Probleme zu finden.\n* **Bericht zur Verifizierung der Anwendungssicherheit** - Ein Bericht, der die Gesamtergebnisse und die unterstützende Analyse dokumentiert, die der Prüfer für eine bestimmte Anwendung erstellt hat.\n* **Black Box Test** - Es handelt sich um eine Softwaretestmethode, bei der die Funktion einer Anwendung untersucht wird, ohne in ihre internen Strukturen oder Abläufe zu blicken.\n* **Bösartiger Code** - Code, der während der Entwicklung einer Anwendung ohne Wissen des Anwendungseigentümers in diese eingeführt wird, und der die beabsichtigte Sicherheitsrichtlinie der Anwendung umgeht. Dies ist nicht dasselbe wie Malware wie z. B. ein Virus oder Wurm!\n* **BSI: Bundesamt für Sicherheit in der Informationstechnik** - Regierungsorganisation zur Verbesserung der Informationssicherheit in Deutschland\n* **CI / CD: Continuous Integration / Continuous Deployment** - Techniken um von der Softwareentwicklung bis zur Produktionseinführung zu automatisieren\n* **CORS: Cross Origin Resource Sharing** - erlaubt Webbrowsern Zugriffe auf andere Dienste außerhalb seiner eigenen Domain.\n* **CSP:**\n  * **Content Security Policy** - Sicherheitskonzept, das Einfügen von Daten in Webseiten verhindert.\n  * **Credential Service Provider** - Ein Dienst zur Verwaltung von Identitäten.\n* **CWE: Common Weakness Enumeration** - ist eine von der Community entwickelte Liste von allgemeinen Sicherheitsschwächen in Software. Sie dient als gemeinsame Sprache, als Messlatte für Softwaresicherheitstools und als Grundlage für die Identifizierung von Schwachstellen, deren Milderung und Prävention.\n* **DAST: Dynamic Application Security Testing** - Dynamische Anwendungssicherheitstests sind so konzipiert, dass sie Bedingungen erkennen, die auf eine Sicherheitslücke in einer Anwendung im laufenden Betrieb hindeuten.\n* **Design-Verifikation** - Die technische Bewertung der Sicherheitsarchitektur einer Anwendung.\n* **DoS: Denial of Service** - Ein Überlastungsangriff mit dem Ziel, die Verfügbarkeit der Anwendung oder deren Komponenten einzuschränken.\n* **Dynamische Verifikation** - Die Verwendung von automatisierten Tools, die Schwachstellensignaturen verwenden, um Probleme bei der Ausführung einer Anwendung zu finden.\n* **Eingabeprüfung** - Die Kanonisierung und Validierung von nicht vertrauenswürdigen Benutzereingaben.\n* **FIDO: Fast Identity Online** - Eine Gruppe von Standards zur Authentifikation, die verschiedene Authentifikationsverfahren, wie z.B. biometrische Verfahren, TPMs, USB-Token etc., definieren.\n* **GUID: Globally Unique Identifier** - eine eindeutige Referenznummer, die als Identifikator in der Software verwendet wird.\n* **Hardcodierte Schlüssel** - Kryptographische Schlüssel, die auf dem Dateisystem gespeichert werden, sei es in Form von Codes, Kommentaren oder Dateien.\n* **HSM: Hardware Security Module** - Zusatzhardware zur Schlüsselspeicherung oder Berechnung kryptografischer Algorithmen.\n* **HTTP: Hyper Text Transfer Protocol** - Ein Anwendungsprotokoll für verteilte, kollaborative, hypermediale Informationssysteme. Es ist die Grundlage der Datenkommunikation für das World Wide Web.\n* **Hibernate Query Language** - Eine dem SQL ähnliche Abfragesprache, die von der Hibernate ORM Bibliothek genutzt wird.\n* **Komponente** - eine in sich geschlossene Code-Einheit mit den zugehörigen Ein- und Ausgabeschnittstellen, die mit anderen Komponenten kommuniziert.\n* **Kryptografisches Modul** - Hardware, Software und/oder Firmware, die kryptografische Algorithmen umsetzt und kapselt und/oder kryptografische Schlüssel generiert.\n* **Malware** - Ausführbarer Code, der während der Laufzeit ohne Wissen des Anwendungsbenutzers oder ‑administrators in eine Anwendung eingeführt wird.\n* **MFA: Multiple Factor Authenticator** - Mehrfaktorauthentifikator, der zwei oder mehr Einzelfaktoren beinhaltet.\n* **ORM: Object Relational Mapping** - Eine Zuordnung von Daten in relationalen Datenbanken zu objektorientierten Programmcode.\n* **OS: Operating System** - Betriebssystem\n* **OTP: One Time Password** - Passwort zur einmaligen Verwendung\n* **OWASP: Open Web Application Security Project** - Eine weltweite, freie und offene Gemeinschaft, die sich mit der Verbesserung der Sicherheit von Anwendungssoftware befasst. Unsere Mission ist es, die Anwendungssicherheit sichtbar zu machen, damit Menschen und Organisationen fundierte Entscheidungen in Bezug auf Anwendungssicherheitsrisiken treffen können. Siehe: https://www.owasp.org/\n* **Padding Oracle Angriff** - Angriff auf Software zur Verschlüsselung, der mit Hilfe der aufgefüllten Blocks (Padding) Schlüssel errät.\n* **PBKDF2: Password Based Key Derivation Function 2** - Ein Algorithmus, der aus einem Passwort und einem Zufallswert einen kryptografischen Schlüssel ableitet\n* **Personenbezogene Daten** - sind Informationen, die allein oder zusammen mit anderen Informationen verwendet werden können, um eine einzelne Person zu identifizieren.\n* **PIE: Position Idependent Executeable** - Positionsunabhängig ausführbarer Code ist der Körper eines Maschinencodes, der, wenn er irgendwo im Primärspeicher abgelegt wird, unabhängig von seiner absoluten Adresse korrekt ausgeführt wird.\n* **PKI: Public Key Infrastructure** - verbindet öffentliche Schlüssel mit den jeweiligen Identitäten von Entitäten. Die Bindung wird durch einen Prozess der Registrierung und Ausgabe von Zertifikaten bei und durch eine Zertifizierungsstelle hergestellt.\n* **Positivliste** - Eine Liste zulässiger Daten oder Operationen, z.B. eine Liste von Zeichen, die Eingabeprüfung akzeptiert.\n* **PSTN: Public Switched Telephone Network** - Das ist das öffentliche Telefonnetz.\n* **RFI: Remote File Inclusion** - Angriffstechnik auf scriptbasierende Webanwendungen, bei der weitere, nicht autorisierte, Scripte zur Ausführung gebracht werden\n* **SAST: Static Appliction Security Testing** - Statische Anwendungssicherheitstests sind eine Reihe von Technologien zur Analyse von Anwendungsquellcode, Bytecode und Binärdateien in Bezug auf Codierungs- und Designbedingungen, die auf Sicherheitsschwachstellen hinweisen. SAST-Lösungen analysieren eine Anwendung von „innen nach außen“ in nicht laufenden Zustand.\n* **SDLC: Software Development Life Cycle** - Der Lebenszyklus der Softwareentwicklung ist der Prozess, der die Entwicklung von Software von den ersten Anforderungen bis zur Betriebsphase beschreibt.\n* **SBOM: Software Bill of Materials** - Softwarestücklisten deklarieren alle verwendeten Bibliotheken.\n* **SFA: Single Factor Authentication** - Einfaktorauthentifikator, beruht auf nur einem Faktor z.B. etwas, das Sie kennen (gespeicherte Geheimnisse, Passwörter, Passphrasen, PINs), etwas, das Sie sind (biometrische Merkmale) oder etwas, das Sie besitzen (OTP-Token, Chipkarte)\n* **Sicherheitsarchitektur** - Eine Abstraktion eines Anwendungsdesigns, die identifiziert und beschreibt, wo und wie Sicherheitsmaßnahmen verwendet werden, und auch den Ort und die Empfindlichkeit von Benutzer- und Anwendungsdaten identifiziert und beschreibt.\n* **Sicherheitskonfiguration** - Die Laufzeitkonfiguration einer Anwendung, die sich auf die Verwendung von Sicherheitsmaßnahmen auswirkt.\n* **Sicherheitsmaßnahme** - Eine Funktion oder Komponente, die eine Sicherheitsprüfung, z. B. eine Zugriffskontrollprüfung, durchführt, oder bei deren Aufruf ein Sicherheitseffekt, z. B. die Erstellung eines Auditdatensatzes, entsteht.\n* **SQL-Injektion** - Eine Injektionstechnik, bei der SQL-Anweisungen in den Datenstrom eingefügt werden.\n* **SSO-Authentifizierung** - Single Sign On - Ein Benutzer meldet sich bei einer Anwendung an und ist dann automatisch bei anderen Anwendungen angemeldet, ohne sich erneut authentifizieren zu müssen. Wenn Sie sich beispielsweise bei Google anmelden, werden Sie beim Zugriff auf andere Google-Dienste wie YouTube, Google Docs und Gmail automatisch angemeldet.\n* **SSRF: Server-Side Request Forgery** - Nutzt den anfälligen Server als Proxy um Informationen aus dessen Umgebung zu erlangen.\n* **Template Injection Angriff** - Webserver fügen per Template Engines Daten aus Datenquellen z.B. in Websites ein. Dazu nutzen sie Platzhalter u.a. Steuerelemente. Ungeprüft ausgeführte Nutzereingaben können diese Steuerelemente missbrauchen.\n* **Threat Modeling** - Eine Technik, immer raffiniertere Sicherheitsarchitekturen zu entwickeln, um Bedrohungsagenten, Sicherheitszonen, Sicherheitsmaßnahmen und wichtige technische und geschäftliche Ressourcen zu identifizieren.\n* **TLS: Transport Layer Security** - Kryptographische Protokolle, die Kommunikationssicherheit für eine Netzwerkverbindung bieten.\n* **TOCTOU**: Time of Check - Time of Use Race Condition - Die Zeitdifferenz zwischen Prüfung einer Eigenschaft und Nutzung könnte groß genug sein, um Änderungen der Eigenschaft zu erreichen. So könnte eine Datei zwischen Prüfung durch den Virenscanner und dem darauf folgenden Zugriff mit Schadsoftware verseucht werden.\n* **TOTP**: Time-based One-Time Password - Verfahren zum Erzeugen von Einmalpasswörten auf Basis der Uhrzeit\n* **TPM**: Trusted Platform Module - Zusatzchip, der ein System um grundlegende Sicherheitsfunktionen erweitert.\n* **U2F**: Universal 2nd Factor - Ein FIDO-Standard, der ein USB- oder NFC-Token als zweiten Authentisierungsfaktor einbindet.\n* **URI/URL/URL-Fragmente** - Ein Uniform Resource Identifier ist eine Zeichenkette, die zur Identifizierung eines Namens oder einer Web-Ressource verwendet wird. Ein Uniform Resource Locator wird oft als Verweis auf eine Ressource verwendet.\n* **Verifizierer**\n  * NIST: Eine Einheit, welche die Identität des Nutzers durch die Überprüfung seines Besitzes, Wissens oder Eigenschaften mittels eines Authentifizierungsprotokolls verifiziert. Zu diesem Zweck muss der Verifizierer möglicherweise auch die Anmeldedaten validieren, die Authentifikatoren mit der Kennung des Nutzers verbinden und ihren Status überprüfen.\n  * OWASP: Die Person oder das Team, die bzw. das eine Anwendung anhand der OWASP ASVS-Anforderungen überprüft.\n* **Verifizierung der Anwendungssicherheit** - Die technische Bewertung einer Anwendung in Bezug auf den OWASP ASVS.\n* **Whitelist** - zunehmend ungebräuchlicher Begriff, siehe **Positivliste**\n* **WYSIWYG: What You See Is What You Get** - Editoren u.ä. Software, die das Ergebnis sofort im finalen Design anzeigen.\n* **X.509-Zertifikat** - Ein X.509-Zertifikat ist ein digitales Zertifikat, das den allgemein anerkannten internationalen X.509 PKI Standard verwendet, um zu prüfen, dass ein öffentlicher Schlüssel zu der im Zertifikat enthaltenen Benutzer-, Computer- oder Service-Identität gehört.\n* **XSS: Cross Site Scripting** - Eine Sicherheitslücke, die typischerweise in Webanwendungen zu finden ist, und die das Einfügen von clientseitigen Skripten in den Inhalt ermöglicht.\n* **XXE: XML External Entity** - Ein Angriff auf XML Dokumente mit Hilfe externer Doctype-Definition.\n", "timestamp": "2025-10-24T11:39:45.740048"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x91-Appendix-B_References.md", "content": "# Anhang B: Referenzen\n\nDie folgenden OWASP-Projekte könnten für die Anwender des ASVS nützlich sein:\n\n## OWASP Kernprojekte\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## OWASP Cheat Sheet Series project\n\n[Das Cheat Sheet Projekt](https://owasp.org/www-project-cheat-sheets/) stellt für viele Bereiche eine Vielzahl von Hilfsmitteln bereit:\n\nDie Übersicht befindet sich unter: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Mobile Security Projekte\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## OWASP Internet of Things Projekte\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## OWASP Serverless Projekte\n\n1. OWASP Serverless Projekte: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Andere\n\nDie folgenden Webseiten außerhalb der OWASP könnten für die Nutzer des ASVS interessant sein:\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:45.825222"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/de/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/de/0x93-Appendix-C_IoT.md", "content": "# Appendix C: Internet of Things Verification Requirements\n\nDieser Abschnitt gehörte ursprünglich zum Hauptzweig, inzwischen hat das OWASP IoT-Team viel geleistet, so dass es keinen Sinn hat, zwei verschiedene Standards zu diesem Thema beizubehalten. Für die Version 4.0 verschieben wir diesen Abschnitt in den Anhang und empfehlen allen, lieber das OWASP IoT-Hauptprojekt zu verwenden.\n\n## Ziel\n\nEingebettete/IoT-Geräte sollten:\n\n* das selbe Maß an Sicherheitsmaßnahmen innerhalb des Geräts haben, wie es im Server zu finden ist. Sicherheitsmaßnahmen sollen in einer vertrauenswürdigen Umgebung durchgesetzt werden.\n* Sensible Daten, die auf dem Gerät gespeichert sind, sollten auf sichere Weise unter Verwendung von hardwaregestütztem Speicher gespeichert werden.\n* Alle vom Gerät übertragenen sensiblen Daten sollten auf der Transportschicht gesichert werden.\n\n## Anforderungen an die Prüfung\n\n| # | Description | L1 | L2 | L3 | Since |\n| --- | --- | --- | --- | -- | -- |\n| **C.1** | Prüfen Sie, dass die Debugging-Schnittstellen der Anwendungsschicht wie USB, UART und andere serielle Varianten deaktiviert oder durch ein komplexes Kennwort geschützt sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Prüfen Sie, dass kryptographische Schlüssel und Zertifikate für jedes einzelne Gerät eindeutig sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Prüfen Sie, dass Speicherschutzmaßnahmen wie ASLR und DEP durch das Betriebssystem aktiviert sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Prüfen Sie, dass On-Chip-Debugging-Schnittstellen wie JTAG oder SWD deaktiviert sind, oder dass der verfügbare Schutzmechanismus aktiviert und entsprechend konfiguriert ist. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Prüfen Sie, dass Trusted Execution implementiert und aktiviert ist, falls auf dem SoC oder der CPU des Geräts verfügbar. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Prüfen Sie, dass sensible Daten, private Schlüssel und Zertifikate sicher in einem Secure Element, TPM, TEE (Trusted Execution Environment) gespeichert oder durch starke Kryptographie geschützt sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Prüfen Sie, dass die Firmwareanwendungen Daten während der Übertragung auf der Transportschicht schützen. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Prüfen Sie, dass die Firmwareanwendungen die digitale Signatur der Serververbindungen validieren. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Prüfen Sie, dass drahtlose Kommunikationen gegenseitig authentifiziert sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Prüfen Sie, dass die drahtlose Kommunikation über einen verschlüsselten Kanal gesendet wird. | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Prüfen Sie, dass alle verbotenen C-Funktionen durch die entsprechenden sicheren gleichwertigen Funktionen ersetzt wird. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Prüfen Sie, dass jede Firmware ein automatisches Stücklistenmanagement führt, in der die Komponenten von Drittanbietern, die Versionierung und die veröffentlichten Schwachstellen katalogisiert sind. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Prüfen Sie, alle Codes, einschließlich der Binärdateien, Bibliotheken und Frameworks von Drittanbietern auf hartkodierte Anmeldedaten (Backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Prüfen Sie, dass die Anwendungs- und Firmware-Komponenten nicht für OS Command Injection anfällig sind, indem sie Shell Command Wrapper oder Skripte aufrufen, oder dass Sicherheitsmaßnahmen OS Command Injection verhindern. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Prüfen Sie, dass die Firmware-Anwendungen die digitale Signatur an einen oder mehrere vertrauenswürdige Server pinnt. | | ✓ | ✓ | 4.0 |\n| **C.16** | Prüfen Sie das Vorhandensein von Merkmalen zur Verhinderung oder Erkennung von Manipulationen am Gerät. | | ✓ | ✓ | 4.0 |\n| **C.17** | Prüfen Sie, dass alle verfügbaren Technologien zum Schutz des geistigen Eigentums, die vom Chiphersteller zur Verfügung gestellt werden, aktiviert sind. | | ✓ | ✓ | 4.0 |\n| **C.18** | Prüfen Sie, dass Sicherheitsmaßnahmen vorhanden sind, um ein Reverse Engineering der Firmware (z.B. Entfernen von ausführlichen Debugginginformationen) zu verhindern. | | ✓ | ✓ | 4.0 |\n| **C.19** | Prüfen Sie, dass das Gerät die Signatur des Bootimages vor dem Laden validiert. | | ✓ | ✓ | 4.0 |\n| **C.20** | Prüfen Sie, dass der Firmware-Aktualisierungsprozess nicht anfällig für TOCTOU Race Conditions ist. | | ✓ | ✓ | 4.0 |\n| **C.21** | Prüfen Sie, dass das Gerät Code Signing verwendet und Firmware-Upgrade-Dateien vor der Installation validiert. | | ✓ | ✓ | 4.0 |\n| **C.22** | Prüfen Sie, dass das Gerät nicht auf alte Versionen (Anti-Rollback) von gültiger Firmware zurückgestuft werden kann. | | ✓ | ✓ | 4.0 |\n| **C.23** | Prüfen Sie die Verwendung eines kryptographisch sicheren Zufallszahlengenerators auf einem eingebetteten Gerät, z.B. unter Verwendung von Hardware. | | ✓ | ✓ | 4.0 |\n| **C.24** | Prüfen Sie, ob die Firmware automatische Firmware-Updates nach einem vordefinierten Zeitplan durchführen kann. | | ✓ | ✓ | 4.0 |\n| **C.25** | Prüfen Sie, dass das Gerät Firmware und sensible Daten löscht, wenn eine Manipulation oder der Empfang einer ungültigen Nachricht festgestellt wird. | | | ✓ | 4.0 |\n| **C.26** | Prüfen Sie, dass nur Mikrocontroller verwendet werden, die das Deaktivieren von Debugging-Schnittstellen (z.B. JTAG, SWD) unterstützen. | | | ✓ | 4.0 |\n| **C.27** | Prüfen Sie, dass nur Mikrocontroller verwendet werden, die einen wesentlichen Schutz vor De-Capping- und Seitenkanal-Angriffen bieten. | | | ✓ | 4.0 |\n| **C.28** | Prüfen Sie, dass Leiterbahnen zur Übertragung sensibler Daten nicht auf den äußeren Schichten der Leiterplatte ausgesetzt sind. | | | ✓ | 4.0 |\n| **C.29** | Prüfen Sie, dass die Kommunikation zwischen den Chips, z. B. die Kommunikation von Haupt- und Tochterplatine, verschlüsselt ist. | | | ✓ | 4.0 |\n| **C.30** | Prüfen Sie, dass das Gerät Code Signing verwendet und den Code vor der Ausführung validiert. | | | ✓ | 4.0 |\n| **C.31** | Prüfen Sie, dass sensible Informationen, die im Speicher gehalten werden, mit Nullen überschrieben werden, sobald sie nicht mehr benötigt werden. | | | ✓ | 4.0 |\n| **C.32** | Prüfen Sie, dass die Firmware-Anwendungen Kernel-Container als Isolierung zwischen den Anwendungen verwenden. | | | ✓ | 4.0 |\n| **C.33** | Prüfen Sie, dass sichere Compilerflags wie -fPIE, -fstack-protector-all, -Wl,- z,noexecstack, -Wl,-z,noexecheap für Firmware-Builds konfiguriert sind. | | | ✓ | 4.0 |\n| **C.34** | Prüfen Sie, dass die Mikrocontroller mit Codeschutz konfiguriert sind (falls zutreffend). | | | ✓ | 4.0 |\n\n## Referenzen\n\nWeitere Informationen finden Sie unter:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:45.918207"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x01-Frontispiece.md", "content": "# Frontispiece\n\n## About the Standard\n\nThe Application Security Verification Standard is a list of application security requirements or tests that can be used by architects, developers, testers, security professionals, tool vendors, and consumers to define, build, test and verify secure applications.\n\n## Copyright and License\n\nVersion 4.0.3, October 2021\n\n![license](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. This document is released under the [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/). For any reuse or distribution, you must make clear to others the license terms of this work.\n\n## Project Leads\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Major Contributors\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Other Contributors and Reviewers\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\nIf a credit is missing from the 4.0.3 credit list above, please log a ticket at GitHub to be recognized in future updates. \n\nThe Application Security Verification Standard is built upon the shoulders of those involved from ASVS 1.0 in 2008 to 3.0 in 2016. Much of the structure and verification items that are still in the ASVS today were originally written by Mike Boberski, Jeff Williams and Dave Wichers, but there are many more contributors. Thank you to all those previously involved. For a comprehensive list of all those who have contributed to earlier versions, please consult each prior version.\n", "timestamp": "2025-10-24T11:39:48.486373"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x02-Preface.md", "content": "# Preface\n\nWelcome to the Application Security Verification Standard (ASVS) version 4.0. The ASVS is a community-driven effort to establish a framework of security requirements and controls that focus on defining the functional and non-functional security controls required when designing, developing and testing modern web applications and web services.\n\nVersion 4.0.3 is the third minor patch to v4.0 intended to fix spelling errors and make requirements clearer without making breaking changes such as materially changing requirements, strengthening requirements or adding requirements. However, some requirements may have been slightly weakened where we felt appropriate and some entirely redundant requirements have been removed (but without renumbering).\n\nASVS v4.0 is the culmination of community effort and industry feedback over the last decade. We have attempted to make it easier to adopt the ASVS for a variety of different use cases throughout any secure software development lifecycle.\n\nWe expect that there will most likely never be 100% agreement on the contents of any web application standard, including the ASVS. Risk analysis is always subjective to some extent, which creates a challenge when attempting to generalize in a one-size-fits-all standard. However, we hope that the latest updates made in this version are a step in the right direction, and enhance the concepts introduced in this critical industry standard.\n\n## What's new in 4.0\n\nThe most significant change in this version is the adoption of the NIST 800-63-3 Digital Identity Guidelines, introducing modern, evidence based, and advanced authentication controls. Although we expect  some pushback on aligning with an advanced authentication standard, we feel that it is essential for standards to be aligned, mainly when another well-regarded application security standard is evidence-based.\n\nInformation security standards should try to minimize the number of unique requirements, so that complying organizations do not have to decide on competing or incompatible controls. The OWASP Top 10 2017 and now the OWASP Application Security Verification Standard have now aligned with NIST 800-63 for authentication and session management. We encourage other standards-setting bodies to work with us, NIST, and others to come to a generally accepted set of application security controls to maximize security and minimize compliance costs.\n\nASVS 4.0 has been wholly renumbered from start to finish. The new numbering scheme allowed us to close up gaps from long-vanished chapters, and to allow us to segment longer chapters to minimize the number of controls that a developer or team have to comply. For example, if an application does not use JWT, the entire section on JWT in session management is not applicable.\n\nNew in 4.0 is a comprehensive mapping to the Common Weakness Enumeration (CWE), one of the most commonly desired feature requests we've had over the last decade. CWE mapping allows tool manufacturers and those using vulnerability management software to match up results from other tools and previous ASVS versions to 4.0 and later. To make room for the CWE entry, we've had to retire the \"Since\" column, which as we completely renumbered, makes less sense than in previous versions of the ASVS. Not every item in the ASVS has an associated CWE, and as CWE has a great deal of duplication, we've attempted to use the most commonly used rather than necessarily the closest match. Verification controls are not always mappable to equivalent weaknesses. We welcome ongoing discussion with the CWE community and information security field more generally on closing this gap.\n\nWe have worked to comprehensively meet and exceed the requirements for addressing the OWASP Top 10 2017 and the OWASP Proactive Controls 2018. As the OWASP Top 10 2017 is the bare minimum to avoid negligence, we have deliberately made all but specific logging Top 10 requirements Level 1 controls, making it easier for OWASP Top 10 adopters to step up to an actual security standard.\n\nWe set out to ensure that the ASVS 4.0 Level 1 is a comprehensive superset of PCI DSS 3.2.1 Sections 6.5, for application design, coding, testing, secure code reviews, and penetration tests. This necessitated covering buffer overflow and unsafe memory operations in V5, and unsafe memory-related compilation flags in V14, in addition to existing industry-leading application and web service verification requirements.\n\nWe have completed the shift of the ASVS from monolithic server-side only controls, to providing security controls for all modern applications and APIs. In the days of functional programming, server-less API, mobile, cloud, containers, CI/CD and DevSecOps, federation and more, we cannot continue to ignore modern application architecture. Modern applications are designed very differently to those built when the original ASVS was released in 2009. The ASVS must always look far into the future so that we provide sound advice for our primary audience - developers. We have clarified or dropped any requirement that assumes that applications are executed on systems owned by a single organization.\n\nDue to the size of the ASVS 4.0, as well as our desire to become the baseline ASVS for all other ASVS efforts, we have retired the mobile chapter, in favor of the Mobile Application Security Verification Standard (MASVS). The Internet of Things appendix will appear in a future IoT ASVS care of the OWASP Internet of Things Project. We have included an early preview of the IoT ASVS in Appendix C. We thank both the OWASP Mobile Team and OWASP IoT Project Team for their support of the ASVS, and look forward to working with them in the future to provide complementary standards.\n\nLastly, we have de-duped and retired less impactful controls. Over time, the ASVS started being a comprehensive set of controls, but not all controls are equal at producing secure software. This effort to eliminate low impact items could go further. In a future edition of the ASVS, the Common Weakness Scoring System (CWSS) will help prioritize further those controls which are truly important and those that should be retired.\n\nAs of version 4.0, the ASVS will focus solely on being the leading web apps and service standard, covering traditional and modern application architecture, and agile security practices and DevSecOps culture.\n", "timestamp": "2025-10-24T11:39:48.572636"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x03-Using-ASVS.md", "content": "# Using the ASVS\n\nASVS has two main goals:\n\n* to help organizations develop and maintain secure applications.\n* to allow security service vendors, security tools vendors, and consumers to align their requirements and offerings.\n\n## Application Security Verification Levels\n\nThe Application Security Verification Standard defines three security verification levels, with each level increasing in depth.\n\n* ASVS Level 1 is for low assurance levels, and is completely penetration testable\n* ASVS Level 2 is for applications that contain sensitive data, which requires protection and is the recommended level for most apps\n* ASVS Level 3 is for the most critical applications - applications that perform high value transactions, contain sensitive medical data, or any application that requires the highest level of trust.\n\nEach ASVS level contains a list of security requirements. Each of these requirements can also be mapped to security-specific features and capabilities that must be built into software by developers.\n\n![ASVS Levels](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"ASVS Levels\")\n\nFigure 1 - OWASP Application Security Verification Standard 4.0 Levels\n\nLevel 1 is the only level that is completely penetration testable using humans. All others require access to documentation, source code, configuration, and the people involved in the development process. However, even if L1 allows \"black box\" (no documentation and no source) testing to occur, it is not an effective assurance activity and should be actively discouraged. Malicious attackers have a great deal of time, most penetration tests are over within a couple of weeks. Defenders need to build in security controls, protect, find and resolve all weaknesses, and detect and respond to malicious actors in a reasonable time. Malicious actors have essentially infinite time and only require a single porous defense, a single weakness, or missing detection to succeed. Black box testing, often performed at the end of development, quickly, or not at all, is completely unable to cope with that asymmetry.\n\nOver the last 30+ years, black box testing has proven over and over again to miss critical security issues that led directly to ever more massive breaches. We strongly encourage the use of a wide range of security assurance and verification, including replacing penetration tests with source code led (hybrid) penetration tests at Level 1, with full access to developers and documentation throughout the development process. Financial regulators do not tolerate external financial audits with no access to the books, sample transactions, or the people performing the controls. Industry and governments must demand the same standard of transparency in the software engineering field.\n\nWe strongly encourage the use of security tools within the development process itself. DAST and SAST tools can be used continuously by the build pipeline to find easy to find security issues that should never be present.\n\nAutomated tools and online scans are unable to complete more than half of the ASVS without human assistance. If comprehensive test automation for each build is required, then a combination of custom unit and integration tests, along with build initiated online scans are used. Business logic flaws and access control testing is only possible using human assistance. These should be turned into unit and integration tests.\n\n## How to use this standard\n\nOne of the best ways to use the Application Security Verification Standard is to use it as a blueprint to create a Secure Coding Checklist specific to your application, platform or organization. Tailoring the ASVS to your use cases will increase the focus on the security requirements that are most important to your projects and environments.\n\n### Level 1 - First steps, automated, or whole of portfolio view\n\nAn application achieves ASVS Level 1 if it adequately defends against application security vulnerabilities that are easy to discover, and included in the OWASP Top 10 and other similar checklists.\n\nLevel 1 is the bare minimum that all applications should strive for. It is also useful as a first step in a multi-phase effort or when applications do not store or handle sensitive data and therefore do not need the more rigorous controls of Level 2 or 3. Level 1 controls can be checked either automatically by tools or simply manually without access to source code. We consider Level 1 the minimum required for all applications.\n\nThreats to the application will most likely be from attackers who are using simple and low effort techniques to identify easy-to-find and easy-to-exploit vulnerabilities. This is in contrast to a determined attacker who will spend focused energy to specifically target the application. If data processed by your application has high value, you would rarely want to stop at a Level 1 review.\n\n### Level 2 - Most applications\n\nAn application achieves ASVS Level 2 (or Standard) if it adequately defends against most of the risks associated with software today.\n\nLevel 2 ensures that security controls are in place, effective, and used within the application. Level 2 is typically appropriate for applications that handle significant business-to-business transactions, including those that process healthcare information, implement business-critical or sensitive functions, or process other sensitive assets, or industries where integrity is a critical facet to protect their business, such as the game industry to thwart cheaters and game hacks.\n\nThreats to Level 2 applications will typically be skilled and motivated attackers focusing on specific targets using tools and techniques that are highly practiced and effective at discovering and exploiting weaknesses within applications.\n\n### Level 3 - High value, high assurance, or high safety\n\nASVS Level 3 is the highest level of verification within the ASVS. This level is typically reserved for applications that require significant levels of security verification, such as those that may be found within areas of military, health and safety, critical infrastructure, etc.\n\nOrganizations may require ASVS Level 3 for applications that perform critical functions, where failure could significantly impact the organization's operations, and even its survivability. Example guidance on the application of ASVS Level 3 is provided below. An application achieves ASVS Level 3 (or Advanced) if it adequately defends against advanced application security vulnerabilities and also demonstrates principles of good security design.\n\nAn application at ASVS Level 3 requires more in depth analysis of architecture, coding, and testing than all the other levels. A secure application is modularized in a meaningful way (to facilitate resiliency, scalability, and most of all, layers of security), and each module (separated by network connection and/or physical instance) takes care of its own security responsibilities (defense in depth), that need to be properly documented. Responsibilities include controls for ensuring confidentiality (e.g. encryption), integrity (e.g. transactions, input validation), availability (e.g. handling load gracefully), authentication (including between systems), authorization, and auditing (logging).\n\n## Applying ASVS in Practice\n\nDifferent threats have different motivations. Some industries have unique information and technology assets and domain specific regulatory compliance requirements.\n\nOrganizations are strongly encouraged to look deeply at their unique risk characteristics based on the nature of their business, and based upon that risk and business requirements determine the appropriate ASVS level.\n\n## How to Reference ASVS Requirements\n\nEach requirement has an identifier in the format `<chapter>.<section>.<requirement>` where each element is a number, for example: `1.11.3`.\n- The `<chapter>` value corresponds to the chapter from which the requirement comes, for example: all `1.#.#` requirements are from the `Architecture` chapter.\n- The `<section>` value corresponds to the section within that chapter where the requirement appears, for example: all `1.11.#` requirements are in the `Business Logic Architecture` section of the `Architecture` chapter.\n- The `<requirement>` value identifies the specific requirement within the chapter and section, for example: `1.11.3` which as of version 4.0.3 of this standard is:\n\n> Verify that all high-value business logic flows, including authentication, session management and access control are thread safe and resistant to time-of-check and time-of-use race conditions.\n\nThe identifiers may change between versions of the standard therefore it is preferable that other documents, reports, or tools use the format: `v<version>-<chapter>.<section>.<requirement>`, where: 'version' is the ASVS version tag. For example: `v4.0.3-1.11.3` would be understood to mean specifically the 3rd requirement in the 'Business Logic Architecture' section of the 'Architecture' chapter from version 4.0.3. (This could be summarized as `v<version>-<requirement_identifier>`.)\n\nNote: The `v` preceding the version portion is to be lower case.\n\nIf identifiers are used without including the `v<version>` element then they should be assumed to refer to the latest Application Security Verification Standard content. Obviously as the standard grows and changes this becomes problematic, which is why writers or developers should include the version element.\n\nASVS requirement lists are made available in CSV, JSON, and other formats which may be useful for reference or programmatic use.\n", "timestamp": "2025-10-24T11:39:48.672695"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x04-Assessment_and_Certification.md", "content": "# Assessment and Certification\n\n## OWASP's Stance on ASVS Certifications and Trust Marks\n\nOWASP, as a vendor-neutral not-for-profit organization, does not currently certify any vendors, verifiers or software.\n\nAll such assurance assertions, trust marks, or certifications are not officially vetted, registered, or certified by OWASP, so an organization relying upon such a view needs to be cautious of the trust placed in any third party or trust mark claiming ASVS certification.\n\nThis should not inhibit organizations from offering such assurance services, as long as they do not claim official OWASP certification.\n\n## Guidance for Certifying Organizations\n\nThe Application Security Verification Standard can be used as an open book verification of the application, including open and unfettered access to key resources such as architects and developers, project documentation, source code, authenticated access to test systems (including access to one or more accounts in each role), particularly for L2 and L3 verifications.\n\nHistorically, penetration testing and secure code reviews have included issues “by exception” - that is only failed tests appear in the final report. A certifying organization must include in any report the scope of the verification (particularly if a key component is out of scope, such as SSO authentication), a summary of verification findings, including passed and failed tests, with clear indications of how to resolve the failed tests.\n\nCertain verification requirements may not be applicable to the application under test. For example, if you provide a stateless service layer API without a client implementation to your customers, many of the requirements in V3 Session Management are not directly applicable. In such cases, a certifying organization may still claim full ASVS compliance, but must clearly indicate in any report a reason for non-applicability of such excluded verification requirements.\n\nKeeping detailed work papers, screenshots or movies, scripts to reliably and repeatedly exploit an issue, and electronic records of testing, such as intercepting proxy logs and associated notes such as a cleanup list, is considered standard industry practice and can be really useful as proofs of the findings for the most doubtful developers. It is not sufficient to simply run a tool and report on the failures; this does not (at all) provide sufficient evidence that all issues at a certifying level have been tested and tested thoroughly. In case of dispute, there should be sufficient assurance evidence to demonstrate each and every verified requirement has indeed been tested.\n\n### Testing Method\n\nCertifying organizations are free to choose the appropriate testing method(s), but should indicate them in a report.\n\nDepending on the application under test and the verification requirement, different testing methods may be used to gain similar confidence in the results. For example, validating the effectiveness of an application's input verification mechanisms may either be analysed with a manual penetration test or by means of source code analyses.\n\n#### The Role of Automated Security Testing Tools\n\nThe use of automated penetration testing tools is encouraged to provide as much coverage as possible.\n\nIt is not possible to fully complete ASVS verification using automated penetration testing tools alone. Whilst a large majority of requirements in L1 can be performed using automated tests, the overall majority of requirements are not amenable to automated penetration testing.\n\nPlease note that the lines between automated and manual testing have blurred as the application security industry matures. Automated tools are often manually tuned by experts and manual testers often leverage a wide variety of automated tools.\n\n#### The Role of Penetration Testing\n\nIn version 4.0, we decided to make L1 completely penetration testable without access to source code, documentation, or developers. Two logging items, which are required to comply with OWASP Top 10 2017 A10, will require interviews, screenshots or other evidence collection, just as they do in the OWASP Top 10 2017. However, testing without access to necessary information is not an ideal method of security verification, as it misses out on the possibility of reviewing the source, identifying threats and missing controls, and performing a far more thorough test in a shorter timeframe. \n\nWhere possible, access to developers, documentation, code, and access to a test application with non-production data, is required when performing a L2 or L3 Assessment. Penetration testing done at these levels requires this level of access, which we call \"hybrid reviews\" or \"hybrid penetration tests\". \n\n## Other uses for the ASVS\n\nAside from being used to assess the security of an application, we have identified a number of other potential uses for the ASVS.\n\n### As Detailed Security Architecture Guidance\n\nOne of the more common uses for the Application Security Verification Standard is as a resource for security architects. The Sherwood Applied Business Security Architecture (SABSA) is missing a great deal of information that is necessary to complete a thorough application security architecture review. ASVS can be used to fill in those gaps by allowing security architects to choose better controls for common problems, such as data protection patterns and input validation strategies.\n\n### As a Replacement for Off-the-shelf Secure Coding Checklists\n\nMany organizations can benefit from adopting the ASVS, by choosing one of the three levels, or by forking ASVS and changing what is required for each application risk level in a domain specific way. We encourage this type of forking as long as traceability is maintained, so that if an app has passed requirement 4.1, this means the same thing for forked copies as the standard as it evolves.\n\n### As a Guide for Automated Unit and Integration Tests\n\nThe ASVS is designed to be highly testable, with the sole exception of architectural and malicious code requirements. By building unit and integration tests that test for specific and relevant fuzz and abuse cases, the application becomes nearly self-verifying with each and every build. For example, additional tests can be crafted for the test suite for a login controller, testing the username parameter for common default usernames, account enumeration, brute forcing, LDAP and SQL injection, and XSS. Similarly, a test on the password parameter should include common passwords, password length, null byte injection, removing the parameter, XSS, and more.\n\n### For Secure Development Training\n\nASVS can also be used to define characteristics of secure software. Many “secure coding” courses are simply ethical hacking courses with a light smear of coding tips. This may not necessarily help developers to write more secure code. Instead, secure development courses can use the ASVS with a strong focus on the proactive controls found in the ASVS, rather than the Top 10 negative things not to do.\n\n### As a Driver for Agile Application Security\n\nASVS can be used in an agile development process as a framework to define specific tasks that need to be implemented by the team to have a secure product. One approach might be: Starting with Level 1, verify the specific application or system according to ASVS requirements for the specified level, find what controls are missing and raise specific tickets/tasks in the backlog. This helps with prioritization of specific tasks (or grooming), and makes security visible in the agile process. This can also be used to prioritize auditing and reviewing tasks in the organization, where a specific ASVS requirement can be a driver for review, refactor or auditing for a specific team member and visible as \"debt\" in the backlog that needs to be eventually done.\n\n### As a Framework for Guiding the Procurement of Secure Software\n\nASVS is a great framework to help with secure software procurement or procurement of custom development services. The buyer can simply set a requirement that the software they wish to procure must be developed at ASVS level X, and request that the seller proves that the software satisfies ASVS level X. This works well when combined with the OWASP Secure Software Contract Annex\n", "timestamp": "2025-10-24T11:39:48.770866"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x10-V1-Architecture.md", "content": "# V1 Architecture, Design and Threat Modeling\n\n## Control Objective\n\nSecurity architecture has almost become a lost art in many organizations. The days of the enterprise architect have passed in the age of DevSecOps. The application security field must catch up and adopt agile security principles while re-introducing leading security architecture principles to software practitioners. Architecture is not an implementation, but a way of thinking about a problem that has potentially many different answers, and no one single \"correct\" answer. All too often, security is seen as inflexible and demanding that developers fix code in a particular way, when the developers may know a much better way to solve the problem. There is no single, simple solution for architecture, and to pretend otherwise is a disservice to the software engineering field.\n\nA specific implementation of a web application is likely to be revised continuously throughout its lifetime, but the overall architecture will likely rarely change but evolve slowly. Security architecture is identical - we need authentication today, we will require authentication tomorrow, and we will need it five years from now. If we make sound decisions today, we can save a lot of effort, time, and money if we select and re-use architecturally compliant solutions. For example, a decade ago, multi-factor authentication was rarely implemented.\n\nIf developers had invested in a single, secure identity provider model, such as SAML federated identity, the identity provider could be updated to incorporate new requirements such as NIST 800-63 compliance, while not changing the interfaces of the original application. If many applications shared the same security architecture and thus that same component, they all benefit from this upgrade at once. However, SAML will not always remain as the best or most suitable authentication solution - it might need to be swapped out for other solutions as requirements change. Changes like this are either complicated, so costly as to necessitate a complete re-write, or outright impossible without security architecture.\n\nIn this chapter, the ASVS covers off the primary aspects of any sound security architecture: availability, confidentiality, processing integrity, non-repudiation, and privacy. Each of these security principles must be built in and be innate to all applications. It is critical to \"shift left\", starting with developer enablement with secure coding checklists, mentoring and training, coding and testing, building, deployment, configuration, and operations, and finishing with follow up independent testing to assure that all of the security controls are present and functional. The last step used to be everything we did as an industry, but that is no longer sufficient when developers push code into production tens or hundreds of times a day. Application security professionals must keep up with agile techniques, which means adopting developer tools, learning to code, and working with developers rather than criticizing the project months after everyone else has moved on.\n\n## V1.1 Secure Software Development Lifecycle\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | Verify the use of a secure software development lifecycle that addresses security in all stages of development. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Verify the use of threat modeling for every design change or sprint planning to identify threats, plan for countermeasures, facilitate appropriate risk responses, and guide security testing. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Verify that all user stories and features contain functional security constraints, such as \"As a user, I should be able to view and edit my profile. I should not be able to view or edit anyone else's profile\" | | ✓ | ✓ | 1110 |\n| **1.1.4** | Verify documentation and justification of all the application's trust boundaries, components, and significant data flows. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Verify definition and security analysis of the application's high-level architecture and all connected remote services. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Verify implementation of centralized, simple (economy of design), vetted, secure, and reusable security controls to avoid duplicate, missing, ineffective, or insecure controls. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Verify availability of a secure coding checklist, security requirements, guideline, or policy to all developers and testers. | | ✓ | ✓ | 637 |\n\n## V1.2 Authentication Architecture\n\nWhen designing authentication, it doesn't matter if you have strong hardware enabled multi-factor authentication if an attacker can reset an account by calling a call center and answering commonly known questions. When proving identity, all authentication pathways must have the same strength.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | Verify the use of unique or special low-privilege operating system accounts for all application components, services, and servers. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Verify that communications between application components, including APIs, middleware and data layers, are authenticated. Components should have the least necessary privileges needed. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Verify that the application uses a single vetted authentication mechanism that is known to be secure, can be extended to include strong authentication, and has sufficient logging and monitoring to detect account abuse or breaches. | | ✓ | ✓ | 306 |\n| **1.2.4** | Verify that all authentication pathways and identity management APIs implement consistent authentication security control strength, such that there are no weaker alternatives per the risk of the application. | | ✓ | ✓ | 306 |\n\n## V1.3 Session Management Architecture\n\nThis is a placeholder for future architectural requirements.\n\n## V1.4 Access Control Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | Verify that trusted enforcement points, such as access control gateways, servers, and serverless functions, enforce access controls. Never enforce access controls on the client. | | ✓ | ✓ | 602 |\n| **1.4.2** | [DELETED, NOT ACTIONABLE] | | | | |\n| **1.4.3** | [DELETED, DUPLICATE OF 4.1.3] | | | | |\n| **1.4.4** | Verify the application uses a single and well-vetted access control mechanism for accessing protected data and resources. All requests must pass through this single mechanism to avoid copy and paste or insecure alternative paths. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Verify that attribute or feature-based access control is used whereby the code checks the user's authorization for a feature/data item rather than just their role. Permissions should still be allocated using roles. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Input and Output Architecture\n\nIn 4.0, we have moved away from the term \"server-side\" as a loaded trust boundary term. The trust boundary is still concerning - making decisions on untrusted browsers or client devices is bypassable. However, in mainstream architectural deployments today, the trust enforcement point has dramatically changed. Therefore, where the term \"trusted service layer\" is used in the ASVS, we mean any trusted enforcement point, regardless of location, such as a microservice, serverless API, server-side, a trusted API on a client device that has secure boot, partner or external APIs, and so on.\n\nThe \"untrusted client\" term here refers to client-side technologies that render the presentation layer, commonly refered to as 'front-end' technologies. The term \"serialization\" here not only refers to sending data over the wire like an array of values or taking and reading a JSON structure, but also passing complex objects which can contain logic.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | Verify that input and output requirements clearly define how to handle and process data based on type, content, and applicable laws, regulations, and other policy compliance. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Verify that serialization is not used when communicating with untrusted clients. If this is not possible, ensure that adequate integrity controls (and possibly encryption if sensitive data is sent) are enforced to prevent deserialization attacks including object injection. | | ✓ | ✓ | 502 |\n| **1.5.3** | Verify that input validation is enforced on a trusted service layer. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Verify that output encoding occurs close to or by the interpreter for which it is intended. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Cryptographic Architecture\n\nApplications need to be designed with strong cryptographic architecture to protect data assets as per their classification. Encrypting everything is wasteful, not encrypting anything is legally negligent. A balance must be struck, usually during architectural or high level design, design sprints or architectural spikes. Designing cryptography as you go or retrofitting it will inevitably cost much more to implement securely than simply building it in from the start.\n\nArchitectural requirements are intrinsic to the entire code base, and thus difficult to unit or integrate test. Architectural requirements require consideration in coding standards, throughout the coding phase, and should be reviewed during security architecture, peer or code reviews, or retrospectives.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | Verify that there is an explicit policy for management of cryptographic keys and that a cryptographic key lifecycle follows a key management standard such as NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Verify that consumers of cryptographic services protect key material and other secrets by using key vaults or API based alternatives. | | ✓ | ✓ | 320 |\n| **1.6.3** | Verify that all keys and passwords are replaceable and are part of a well-defined process to re-encrypt sensitive data. | | ✓ | ✓ | 320 |\n| **1.6.4** | Verify that the architecture treats client-side secrets--such as symmetric keys, passwords, or API tokens--as insecure and never uses them to protect or access sensitive data. | | ✓ | ✓ | 320 |\n\n## V1.7 Errors, Logging and Auditing Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | Verify that a common logging format and approach is used across the system. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Verify that logs are securely transmitted to a preferably remote system for analysis, detection, alerting, and escalation. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Data Protection and Privacy Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | Verify that all sensitive data is identified and classified into protection levels. | | ✓ | ✓ | |\n| **1.8.2** | Verify that all protection levels have an associated set of protection requirements, such as encryption requirements, integrity requirements, retention, privacy and other confidentiality requirements, and that these are applied in the architecture. | | ✓ | ✓ | |\n\n## V1.9 Communications Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | Verify the application encrypts communications between components, particularly when these components are in different containers, systems, sites, or cloud providers. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Verify that application components verify the authenticity of each side in a communication link to prevent person-in-the-middle attacks. For example, application components should validate TLS certificates and chains. | | ✓ | ✓ | 295 |\n\n## V1.10 Malicious Software Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | Verify that a source code control system is in use, with procedures to ensure that check-ins are accompanied by issues or change tickets. The source code control system should have access control and identifiable users to allow traceability of any changes. | | ✓ | ✓ | 284 |\n\n## V1.11 Business Logic Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | Verify the definition and documentation of all application components in terms of the business or security functions they provide. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Verify that all high-value business logic flows, including authentication, session management and access control, do not share unsynchronized state. | | ✓ | ✓ | 362 |\n| **1.11.3** | Verify that all high-value business logic flows, including authentication, session management and access control are thread safe and resistant to time-of-check and time-of-use race conditions. | | | ✓ | 367 |\n\n## V1.12 Secure File Upload Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [DELETED, DUPLICATE OF 12.4.1] | | | | |\n| **1.12.2** | Verify that user-uploaded files - if required to be displayed or downloaded from the application - are served by either octet stream downloads, or from an unrelated domain, such as a cloud file storage bucket. Implement a suitable Content Security Policy (CSP) to reduce the risk from XSS vectors or other attacks from the uploaded file. | | ✓ | ✓ | 646 |\n\n## V1.13 API Architecture\n\nThis is a placeholder for future architectural requirements.\n\n## V1.14 Configuration Architecture\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | Verify the segregation of components of differing trust levels through well-defined security controls, firewall rules, API gateways, reverse proxies, cloud-based security groups, or similar mechanisms. | | ✓ | ✓ | 923 |\n| **1.14.2** | Verify that binary signatures, trusted connections, and verified endpoints are used to deploy binaries to remote devices. | | ✓ | ✓ | 494 |\n| **1.14.3** | Verify that the build pipeline warns of out-of-date or insecure components and takes appropriate actions. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Verify that the build pipeline contains a build step to automatically build and verify the secure deployment of the application, particularly if the application infrastructure is software defined, such as cloud environment build scripts. | | ✓ | ✓ | |\n| **1.14.5** | Verify that application deployments adequately sandbox, containerize and/or isolate at the network level to delay and deter attackers from attacking other applications, especially when they are performing sensitive or dangerous actions such as deserialization. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Verify the application does not use unsupported, insecure, or deprecated client-side technologies such as NSAPI plugins, Flash, Shockwave, ActiveX, Silverlight, NACL, or client-side Java applets. | | ✓ | ✓ | 477 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:48.845430"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md", "content": "# V2 Authentication\n\n## Control Objective\n\nAuthentication is the act of establishing, or confirming, someone (or something) as authentic and that claims made by a person or about a device are correct, resistant to impersonation, and prevent recovery or interception of passwords.\n\nWhen the ASVS was first released, username + password was the most common form of authentication outside of high security systems. Multi-factor Authentication (MFA) was commonly accepted in security circles but rarely required elsewhere. As the number of password breaches increased, the idea that usernames are somehow confidential and passwords unknown, rendered many security controls untenable. For example, NIST 800-63 considers usernames and Knowledge Based Authentication (KBA) as public information, SMS and email notifications as [\"restricted\" authenticator types](https://pages.nist.gov/800-63-FAQ/#q-b1) , and passwords as pre-breached. This reality renders knowledge based authenticators, SMS and email recovery, password history, complexity, and rotation controls useless. These controls always have been less than helpful, often forcing users to come up with weak passwords every few months, but with the release of over 5 billion username and password breaches, it's time to move on.\n\nOf all the chapters in the ASVS, the authentication and session management chapters have changed the most. Adoption of effective, evidence-based leading practice will be challenging for many, and that's perfectly okay. We have to start the transition to a post-password future now.\n\n## NIST 800-63 - Modern, evidence-based authentication standard\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) is a modern, evidence-based standard, and represents the best advice available, regardless of applicability. The standard is helpful for all organizations all over the world but is particularly relevant to US agencies and those dealing with US agencies.\n\nNIST 800-63 terminology can be a little confusing at first, especially if you're only used to username + password authentication. Advancements in modern authentication are necessary, so we have to introduce terminology that will become commonplace in the future, but we do understand the difficulty in understanding until the industry settles on these new terms. We have provided a glossary at the end of this chapter to assist. We have rephrased many requirements to satisfy the intent of the requirement, rather than the letter of the requirement. For example, the ASVS uses the term \"password\" when NIST uses \"memorized secret\" throughout this standard.\n\nASVS V2 Authentication, V3 Session Management, and to a lesser extent, V4 Access Controls have been adapted to be a compliant subset of selected NIST 800-63b controls, focused around common threats and commonly exploited authentication weaknesses. Where full NIST 800-63 compliance is required, please consult NIST 800-63.\n\n### Selecting an appropriate NIST AAL Level\n\nThe Application Security Verification Standard has tried to map ASVS L1 to NIST AAL1 requirements, L2 to AAL2, and L3 to AAL3. However, the approach of ASVS Level 1 as \"essential\" controls may not necessarily be the correct AAL level to verify an application or API. For example, if the application is a Level 3 application or has regulatory requirements to be AAL3, Level 3 should be chosen in chapters V2 and V3 Session Management. The choice of NIST compliant Authentication Assertion Level (AAL) should be performed as per NIST 800-63b guidelines as set out in *Selecting AAL* in [NIST 800-63b Section 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Legend\n\nApplications can always exceed the current level's requirements, especially if modern authentication is on an application's roadmap. Previously, the ASVS has required mandatory MFA. NIST does not require mandatory MFA. Therefore, we have used an optional designation in this chapter to indicate where the ASVS encourages but does not require a control. The following keys are used throughout this standard:\n\n| Mark | Description |\n| :--: | :-- |\n| | Not required |\n| o | Recommended, but not required |\n| ✓ | Required |\n\n## V2.1 Password Security\n\nPasswords, called \"Memorized Secrets\" by NIST 800-63, include passwords, PINs, unlock patterns, pick the correct kitten or another image element, and passphrases. They are generally considered \"something you know\", and often used as single-factor authenticators. There are significant challenges to the continued use of single-factor authentication, including billions of valid usernames and passwords disclosed on the Internet, default or weak passwords, rainbow tables and ordered dictionaries of the most common passwords.\n\nApplications should strongly encourage users to enroll in multi-factor authentication, and should allow users to re-use tokens they already possess, such as FIDO or U2F tokens, or link to a credential service provider that provides multi-factor authentication.\n\nCredential Service Providers (CSPs) provide federated identity for users. Users will often have more than one identity with multiple CSPs, such as an enterprise identity using Azure AD, Okta, Ping Identity or Google, or consumer identity using Facebook, Twitter, Google, or WeChat, to name a just few common alternatives. This list is not an endorsement of these companies or services, but simply an encouragement for developers to consider the reality that many users have many established identities. Organizations should consider integrating with existing user identities, as per the risk profile of the CSP's strength of identity proofing. For example, it is unlikely a government organization would accept a social media identity as a login for sensitive systems, as it is easy to create fake or throw away identities, whereas a mobile game company may well need to integrate with major social media platforms to grow their active player base.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.1.1** | Verify that user set passwords are at least 12 characters in length (after multiple spaces are combined). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Verify that passwords of at least 64 characters are permitted, and that passwords of more than 128 characters are denied. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Verify that password truncation is not performed. However, consecutive multiple spaces may be replaced by a single space. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Verify that any printable Unicode character, including language neutral characters such as spaces and Emojis are permitted in passwords. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Verify users can change their password. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Verify that password change functionality requires the user's current and new password. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Verify that passwords submitted during account registration, login, and password change are checked against a set of breached passwords either locally (such as the top 1,000 or 10,000 most common passwords which match the system's password policy) or using an external API. If using an API a zero knowledge proof or other mechanism should be used to ensure that the plain text password is not sent or used in verifying the breach status of the password. If the password is breached, the application must require the user to set a new non-breached password. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Verify that a password strength meter is provided to help users set a stronger password. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Verify that there are no password composition rules limiting the type of characters permitted. There should be no requirement for upper or lower case or numbers or special characters. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Verify that there are no periodic credential rotation or password history requirements. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Verify that \"paste\" functionality, browser password helpers, and external password managers are permitted. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Verify that the user can choose to either temporarily view the entire masked password, or temporarily view the last typed character of the password on platforms that do not have this as built-in functionality. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nNote: The goal of allowing the user to view their password or see the last character temporarily is to improve the usability of credential entry, particularly around the use of longer passwords, passphrases, and password managers. Another reason for including the requirement is to deter or prevent test reports unnecessarily requiring organizations to override built-in platform password field behavior to remove this modern user-friendly security experience.\n\n## V2.2 General Authenticator Security\n\nAuthenticator agility is essential to future-proof applications. Refactor application verifiers to allow additional authenticators as per user preferences, as well as allowing retiring deprecated or unsafe authenticators in an orderly fashion.\n\nNIST considers email and SMS as [\"restricted\" authenticator types](https://pages.nist.gov/800-63-FAQ/#q-b1), and they are likely to be removed from NIST 800-63 and thus the ASVS at some point the future. Applications should plan a roadmap that does not require the use of email or SMS.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.2.1** | Verify that anti-automation controls are effective at mitigating breached credential testing, brute force, and account lockout attacks. Such controls include blocking the most common breached passwords, soft lockouts, rate limiting, CAPTCHA, ever increasing delays between attempts, IP address restrictions, or risk-based restrictions such as location, first login on a device, recent attempts to unlock the account, or similar. Verify that no more than 100 failed attempts per hour is possible on a single account. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Verify that the use of weak authenticators (such as SMS and email) is limited to secondary verification and transaction approval and not as a replacement for more secure authentication methods. Verify that stronger methods are offered before weak methods, users are aware of the risks, or that proper measures are in place to limit the risks of account compromise. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Verify that secure notifications are sent to users after updates to authentication details, such as credential resets, email or address changes, logging in from unknown or risky locations. The use of push notifications - rather than SMS or email - is preferred, but in the absence of push notifications, SMS or email is acceptable as long as no sensitive information is disclosed in the notification. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Verify impersonation resistance against phishing, such as the use of multi-factor authentication, cryptographic devices with intent (such as connected keys with a push to authenticate), or at higher AAL levels, client-side certificates. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Verify that where a Credential Service Provider (CSP) and the application verifying authentication are separated, mutually authenticated TLS is in place between the two endpoints. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Verify replay resistance through the mandated use of One-time Passwords (OTP) devices, cryptographic authenticators, or lookup codes. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Verify intent to authenticate by requiring the entry of an OTP token or user-initiated action such as a button press on a FIDO hardware key. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Authenticator Lifecycle\n\nAuthenticators are passwords, soft tokens, hardware tokens, and biometric devices. The lifecycle of authenticators is critical to the security of an application - if anyone can self-register an account with no evidence of identity, there can be little trust in the identity assertion. For social media sites like Reddit, that's perfectly okay. For banking systems, a greater focus on the registration and issuance of credentials and devices is critical to the security of the application.\n\nNote: Passwords are not to have a maximum lifetime or be subject to password rotation. Passwords should be checked for being breached, not regularly replaced.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.3.1** | Verify system generated initial passwords or activation codes SHOULD be securely randomly generated, SHOULD be at least 6 characters long, and MAY contain letters and numbers, and expire after a short period of time. These initial secrets must not be permitted to become the long term password. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Verify that enrollment and use of user-provided authentication devices are supported, such as a U2F or FIDO tokens. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Verify that renewal instructions are sent with sufficient time to renew time bound authenticators. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Credential Storage\n\nArchitects and developers should adhere to this section when building or refactoring code. This section can only be fully verified using source code review or through secure unit or integration tests. Penetration testing cannot identify any of these issues.\n\nThe list of approved one-way key derivation functions is detailed in NIST 800-63 B section 5.1.1.2, and in [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). The latest national or regional algorithm and key length standards can be chosen in place of these choices.\n\nThis section cannot be penetration tested, so controls are not marked as L1. However, this section is of vital importance to the security of credentials if they are stolen, so if forking the ASVS for an architecture or coding guideline or source code review checklist, please place these controls back to L1 in your private version.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.4.1** | Verify that passwords are stored in a form that is resistant to offline attacks. Passwords SHALL be salted and hashed using an approved one-way key derivation or password hashing function. Key derivation and password hashing functions take a password, a salt, and a cost factor as inputs when generating a password hash. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Verify that the salt is at least 32 bits in length and be chosen arbitrarily to minimize salt value collisions among stored hashes. For each credential, a unique salt value and the resulting hash SHALL be stored. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Verify that if PBKDF2 is used, the iteration count SHOULD be as large as verification server performance will allow, typically at least 100,000 iterations. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Verify that if bcrypt is used, the work factor SHOULD be as large as verification server performance will allow, with a minimum of 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Verify that an additional iteration of a key derivation function is performed, using a salt value that is secret and known only to the verifier. Generate the salt value using an approved random bit generator [SP 800-90Ar1] and provide at least the minimum security strength specified in the latest revision of SP 800-131A. The secret salt value SHALL be stored separately from the hashed passwords (e.g., in a specialized device like a hardware security module). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nWhere US standards are mentioned, a regional or local standard can be used in place of or in addition to the US standard as required.\n\n## V2.5 Credential Recovery\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.5.1** | Verify that a system generated initial activation or recovery secret is not sent in clear text to the user. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Verify password hints or knowledge-based authentication (so-called \"secret questions\") are not present. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Verify password credential recovery does not reveal the current password in any way. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Verify shared or default accounts are not present (e.g. \"root\", \"admin\", or \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Verify that if an authentication factor is changed or replaced, that the user is notified of this event. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Verify forgotten password, and other recovery paths use a secure recovery mechanism, such as time-based OTP (TOTP) or other soft token, mobile push, or another offline recovery mechanism. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Verify that if OTP or multi-factor authentication factors are lost, that evidence of identity proofing is performed at the same level as during enrollment. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Look-up Secret Verifier\n\nLook up secrets are pre-generated lists of secret codes, similar to Transaction Authorization Numbers (TAN), social media recovery codes, or a grid containing a set of random values. These are distributed securely to users. These lookup codes are used once, and once all used, the lookup secret list is discarded. This type of authenticator is considered \"something you have\".\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.6.1** | Verify that lookup secrets can be used only once. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Verify that lookup secrets have sufficient randomness (112 bits of entropy), or if less than 112 bits of entropy, salted with a unique and random 32-bit salt and hashed with an approved one-way hash. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Verify that lookup secrets are resistant to offline attacks, such as predictable values. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Out of Band Verifier\n\nIn the past, a common out of band verifier would have been an email or SMS containing a password reset link. Attackers use this weak mechanism to reset accounts they don't yet control, such as taking over a person's email account and re-using any discovered reset links. There are better ways to handle out of band verification.\n\nSecure out of band authenticators are physical devices that can communicate with the verifier over a secure secondary channel. Examples include push notifications to mobile devices. This type of authenticator is considered \"something you have\". When a user wishes to authenticate, the verifying application sends a message to the out of band authenticator via a connection to the authenticator directly or indirectly through a third party service. The message contains an authentication code (typically a random six digit number or a modal approval dialog). The verifying application waits to receive the authentication code through the primary channel and compares the hash of the received value to the hash of the original authentication code. If they match, the out of band verifier can assume that the user has authenticated.\n\nThe ASVS assumes that only a few developers will be developing new out of band authenticators, such as push notifications, and thus the following ASVS controls apply to verifiers, such as authentication API, applications, and single sign-on implementations. If developing a new out of band authenticator, please refer to NIST 800-63B &sect; 5.1.3.1.\n\nUnsafe out of band authenticators such as e-mail and VOIP are not permitted. PSTN and SMS authentication are currently \"restricted\" by NIST and should be deprecated in favor of push notifications or similar. If you need to use telephone or SMS out of band authentication, please see &sect; 5.1.3.3.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.7.1** | Verify that clear text out of band (NIST \"restricted\") authenticators, such as SMS or PSTN, are not offered by default, and stronger alternatives such as push notifications are offered first. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Verify that the out of band verifier expires out of band authentication requests, codes, or tokens after 10 minutes. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Verify that the out of band verifier authentication requests, codes, or tokens are only usable once, and only for the original authentication request. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Verify that the out of band authenticator and verifier communicates over a secure independent channel. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Verify that the out of band verifier retains only a hashed version of the authentication code. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Verify that the initial authentication code is generated by a secure random number generator, containing at least 20 bits of entropy (typically a six digital random number is sufficient). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 One Time Verifier\n\nSingle-factor One-time Passwords (OTPs) are physical or soft tokens that display a continually changing pseudo-random one-time challenge. These devices make phishing (impersonation) difficult, but not impossible. This type of authenticator is considered \"something you have\". Multi-factor tokens are similar to single-factor OTPs, but require a valid PIN code, biometric unlocking, USB insertion or NFC pairing or some additional value (such as transaction signing calculators) to be entered to create the final OTP.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.8.1** | Verify that time-based OTPs have a defined lifetime before expiring. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Verify that symmetric keys used to verify submitted OTPs are highly protected, such as by using a hardware security module or secure operating system based key storage. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **2.8.3** | Verify that approved cryptographic algorithms are used in the generation, seeding, and verification of OTPs. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Verify that time-based OTP can be used only once within the validity period. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Verify that if a time-based multi-factor OTP token is re-used during the validity period, it is logged and rejected with secure notifications being sent to the holder of the device. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Verify physical single-factor OTP generator can be revoked in case of theft or other loss. Ensure that revocation is immediately effective across logged in sessions, regardless of location. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Verify that biometric authenticators are limited to use only as secondary factors in conjunction with either something you have and something you know. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Cryptographic Verifier\n\nCryptographic security keys are smart cards or FIDO keys, where the user has to plug in or pair the cryptographic device to the computer to complete authentication. Verifiers send a challenge nonce to the cryptographic devices or software, and the device or software calculates a response based upon a securely stored cryptographic key.\n\nThe requirements for single-factor cryptographic devices and software, and multi-factor cryptographic devices and software are the same, as verification of the cryptographic authenticator proves possession of the authentication factor.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.9.1** | Verify that cryptographic keys used in verification are stored securely and protected against disclosure, such as using a Trusted Platform Module (TPM) or Hardware Security Module (HSM), or an OS service that can use this secure storage. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Verify that the challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Verify that approved cryptographic algorithms are used in the generation, seeding, and verification. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Service Authentication\n\nThis section is not penetration testable, so does not have any L1 requirements. However, if used in an architecture, coding or secure code review, please assume that software (just as Java Key Store) is the minimum requirement at L1. Clear text storage of secrets is not acceptable under any circumstances.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.10.1** | Verify that intra-service secrets do not rely on unchanging credentials such as passwords, API keys or shared accounts with privileged access. | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Verify that if passwords are required for service authentication, the service account used is not a default credential. (e.g. root/root or admin/admin are default in some services during installation). | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Verify that passwords are stored with sufficient protection to prevent offline recovery attacks, including local system access. | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Verify passwords, integrations with databases and third-party systems, seeds and internal secrets, and API keys are managed securely and not included in the source code or stored within source code repositories. Such storage SHOULD resist offline attacks. The use of a secure software key store (L1), hardware TPM, or an HSM (L3) is recommended for password storage. | | OS assisted | HSM | 798 | |\n\n## Additional US Agency Requirements\n\nUS Agencies have mandatory requirements concerning NIST 800-63. The Application Security Verification Standard has always been about the 80% of controls that apply to nearly 100% of apps, and not the last 20% of advanced controls or those that have limited applicability. As such, the ASVS is a strict subset of NIST 800-63, especially for IAL1/2 and AAL1/2 classifications, but is not sufficiently comprehensive, particularly concerning IAL3/AAL3 classifications.\n\nWe strongly urge US government agencies to review and implement NIST 800-63 in its entirety.\n\n## Glossary of terms\n\n| Term | Meaning |\n| -- | -- |\n| CSP | Credential Service Provider also called an Identity Provider |\n| Authenticator | Code that authenticates a password, token, MFA, federated assertion, and so on. |\n| Verifier | \"An entity that verifies the claimant's identity by verifying the claimant's possession and control of one or two authenticators using an authentication protocol. To do this, the verifier may also need to validate credentials that link the authenticator(s) to the subscriber's identifier and check their status\" |\n| OTP | One-time password |\n| SFA | Single-factor authenticators, such as something you know (memorized secrets, passwords, passphrases, PINs), something you are (biometrics, fingerprint, face scans), or something you have (OTP tokens, a cryptographic device such as a smart card), |\n| MFA | Multi-factor authentication, which includes two or more single factors |\n\n## References\n\nFor more information, see also:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:48.925297"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md", "content": "# V3 Session Management\n\n## Control Objective\n\nOne of the core components of any web-based application or stateful API is the mechanism by which it controls and maintains the state for a user or device interacting with it. Session management changes a stateless protocol to stateful, which is critical for differentiating different users or devices.\n\nEnsure that a verified application satisfies the following high-level session management requirements:\n\n* Sessions are unique to each individual and cannot be guessed or shared.\n* Sessions are invalidated when no longer required and timed out during periods of inactivity.\n\nAs previously noted, these requirements have been adapted to be a compliant subset of selected NIST 800-63b controls, focused around common threats and commonly exploited authentication weaknesses. Previous verification requirements have been retired, de-duped, or in most cases adapted to be strongly aligned with the intent of mandatory [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) requirements.\n\n## Security Verification Requirements\n\n## V3.1 Fundamental Session Management Security\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.1.1** | Verify the application never reveals session tokens in URL parameters. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Session Binding\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.2.1** | Verify the application generates a new session token on user authentication. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Verify that session tokens possess at least 64 bits of entropy. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Verify the application only stores session tokens in the browser using secure methods such as appropriately secured cookies (see section 3.4) or HTML 5 session storage. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Verify that session tokens are generated using approved cryptographic algorithms. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nTLS or another secure transport channel is mandatory for session management. This is covered off in the Communications Security chapter.\n\n## V3.3 Session Termination\n\nSession timeouts have been aligned with NIST 800-63, which permits much longer session timeouts than traditionally permitted by security standards. Organizations should review the table below, and if a longer time out is desirable based around the application's risk, the NIST value should be the upper bounds of session idle timeouts.\n\nL1 in this context is IAL1/AAL1, L2 is IAL2/AAL3, L3 is IAL3/AAL3. For IAL2/AAL2 and IAL3/AAL3, the shorter idle timeout is, the lower bound of idle times for being logged out or re-authenticated to resume the session.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.3.1** | Verify that logout and expiration invalidate the session token, such that the back button or a downstream relying party does not resume an authenticated session, including across relying parties. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | If authenticators permit users to remain logged in, verify that re-authentication occurs periodically both when actively used or after an idle period. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 days | 12 hours or 30 minutes of inactivity, 2FA optional | 12 hours or 15 minutes of inactivity, with 2FA | 613 | 7.2 |\n| **3.3.3** | Verify that the application gives the option to terminate all other active sessions after a successful password change (including change via password reset/recovery), and that this is effective across the application, federated login (if present), and any relying parties. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Verify that users are able to view and (having re-entered login credentials) log out of any or all currently active sessions and devices. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Cookie-based Session Management\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.4.1** | Verify that cookie-based session tokens have the 'Secure' attribute set. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Verify that cookie-based session tokens have the 'HttpOnly' attribute set. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Verify that cookie-based session tokens utilize the 'SameSite' attribute to limit exposure to cross-site request forgery attacks. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1275 | 7.1.1 |\n| **3.4.4** | Verify that cookie-based session tokens use the \"__Host-\" prefix so cookies are only sent to the host that initially set the cookie. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Verify that if the application is published under a domain name with other applications that set or use session cookies that might disclose the session cookies, set the path attribute in cookie-based session tokens using the most precise path possible. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Token-based Session Management\n\nToken-based session management includes JWT, OAuth, SAML, and API keys. Of these, API keys are known to be weak and should not be used in new code.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.5.1** | Verify the application allows users to revoke OAuth tokens that form trust relationships with linked applications. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Verify the application uses session tokens rather than static API secrets and keys, except with legacy implementations. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Verify that stateless session tokens use digital signatures, encryption, and other countermeasures to protect against tampering, enveloping, replay, null cipher, and key substitution attacks. | | ✓ | ✓ | 345 | |\n\n## V3.6 Federated Re-authentication\n\nThis section relates to those writing Relying Party (RP) or Credential Service Provider (CSP) code. If relying on code implementing these features, ensure that these issues are handled correctly.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.6.1** | Verify that Relying Parties (RPs) specify the maximum authentication time to Credential Service Providers (CSPs) and that CSPs re-authenticate the user if they haven't used a session within that period. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Verify that Credential Service Providers (CSPs) inform Relying Parties (RPs) of the last authentication event, to allow RPs to determine if they need to re-authenticate the user. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Defenses Against Session Management Exploits\n\nThere are a small number of session management attacks, some related to the user experience (UX) of sessions. Previously, based on ISO 27002 requirements, the ASVS has required blocking multiple simultaneous sessions. Blocking simultaneous sessions is no longer appropriate, not only as modern users have many devices or the app is an API without a browser session, but in most of these implementations, the last authenticator wins, which is often the attacker. This section provides leading guidance on deterring, delaying and detecting session management attacks using code.\n\n### Description of the half-open Attack\n\nIn early 2018, several financial institutions were compromised using what the attackers called \"half-open attacks\". This term has stuck in the industry. The attackers struck multiple institutions with different proprietary code bases, and indeed it seems different code bases within the same institutions. The half-open attack is exploiting a design pattern flaw commonly found in many existing authentication, session management and access control systems.\n\nAttackers start a half-open attack by attempting to lock, reset, or recover a credential. A popular session management design pattern re-uses user profile session objects/models between unauthenticated, half-authenticated (password resets, forgot username), and fully authenticated code. This design pattern populates a valid session object or token containing the victim's profile, including password hashes and roles. If access control checks in controllers or routers does not correctly verify that the user is fully logged in, the attacker will be able to act as the user. Attacks could include changing the user's password to a known value, update the email address to perform a valid password reset, disable multi-factor authentication or enroll a new MFA device, reveal or change API keys, and so on.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.7.1** | Verify the application ensures a full, valid login session or requires re-authentication or secondary verification before allowing any sensitive transactions or account modifications. | ✓ | ✓ | ✓ | 306 | |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:49.002513"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V4-Access-Control.md", "content": "# V4 Access Control\n\n## Control Objective\n\nAuthorization is the concept of allowing access to resources only to those permitted to use them. Ensure that a verified application satisfies the following high level requirements:\n\n* Persons accessing resources hold valid credentials to do so.\n* Users are associated with a well-defined set of roles and privileges.\n* Role and permission metadata is protected from replay or tampering.\n\n## Security Verification Requirements\n\n## V4.1 General Access Control Design\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.1.1** | Verify that the application enforces access control rules on a trusted service layer, especially if client-side access control is present and could be bypassed. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Verify that all user and data attributes and policy information used by access controls cannot be manipulated by end users unless specifically authorized. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Verify that the principle of least privilege exists - users should only be able to access functions, data files, URLs, controllers, services, and other resources, for which they possess specific authorization. This implies protection against spoofing and elevation of privilege. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [DELETED, DUPLICATE OF 4.1.3] | | | | |\n| **4.1.5** | Verify that access controls fail securely including when an exception occurs. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Operation Level Access Control\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.2.1** | Verify that sensitive data and APIs are protected against Insecure Direct Object Reference (IDOR) attacks targeting creation, reading, updating and deletion of records, such as creating or updating someone else's record, viewing everyone's records, or deleting all records. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Verify that the application or framework enforces a strong anti-CSRF mechanism to protect authenticated functionality, and effective anti-automation or anti-CSRF protects unauthenticated functionality. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Other Access Control Considerations\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.3.1** | Verify administrative interfaces use appropriate multi-factor authentication to prevent unauthorized use. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Verify that directory browsing is disabled unless deliberately desired. Additionally, applications should not allow discovery or disclosure of file or directory metadata, such as Thumbs.db, .DS_Store, .git or .svn folders. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Verify the application has additional authorization (such as step up or adaptive authentication) for lower value systems, and / or segregation of duties for high value applications to enforce anti-fraud controls as per the risk of application and past fraud. | | ✓ | ✓ | 732 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:49.131759"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Validation, Sanitization and Encoding\n\n## Control Objective\n\nThe most common web application security weakness is the failure to properly validate input coming from the client or the environment before directly using it without any output encoding. This weakness leads to almost all of the significant vulnerabilities in web applications, such as Cross-Site Scripting (XSS), SQL injection, interpreter injection, locale/Unicode attacks, file system attacks, and buffer overflows.\n\nEnsure that a verified application satisfies the following high-level requirements:\n\n* Input validation and output encoding architecture have an agreed pipeline to prevent injection attacks.\n* Input data is strongly typed, validated, range or length checked, or at worst, sanitized or filtered.\n* Output data is encoded or escaped as per the context of the data as close to the interpreter as possible.\n\nWith modern web application architecture, output encoding is more important than ever. It is difficult to provide robust input validation in certain scenarios, so the use of safer API such as parameterized queries, auto-escaping templating frameworks, or carefully chosen output encoding is critical to the security of the application.\n\n## V5.1 Input Validation\n\nProperly implemented input validation controls, using positive allow lists and strong data typing, can eliminate more than 90% of all injection attacks. Length and range checks can reduce this further. Building in secure input validation is required during application architecture, design sprints, coding, and unit and integration testing. Although many of these items cannot be found in penetration tests, the results of not implementing them are usually found in V5.3 - Output encoding and Injection Prevention Requirements. Developers and secure code reviewers are recommended to treat this section as if L1 is required for all items to prevent injections.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.1.1** | Verify that the application has defenses against HTTP parameter pollution attacks, particularly if the application framework makes no distinction about the source of request parameters (GET, POST, cookies, headers, or environment variables). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Verify that frameworks protect against mass parameter assignment attacks, or that the application has countermeasures to protect against unsafe parameter assignment, such as marking fields private or similar. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Verify that all input (HTML form fields, REST requests, URL parameters, HTTP headers, cookies, batch files, RSS feeds, etc) is validated using positive validation (allow lists). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Verify that structured data is strongly typed and validated against a defined schema including allowed characters, length and pattern (e.g. credit card numbers, e-mail addresses, telephone numbers, or validating that two related fields are reasonable, such as checking that suburb and zip/postcode match). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Verify that URL redirects and forwards only allow destinations which appear on an allow list, or show a warning when redirecting to potentially untrusted content. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Sanitization and Sandboxing\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.2.1** | Verify that all untrusted HTML input from WYSIWYG editors or similar is properly sanitized with an HTML sanitizer library or framework feature. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Verify that unstructured data is sanitized to enforce safety measures such as allowed characters and length. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Verify that the application avoids the use of eval() or other dynamic code execution features. Where there is no alternative, any user input being included must be sanitized or sandboxed before being executed. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Verify that the application protects against template injection attacks by ensuring that any user input being included is sanitized or sandboxed. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Verify that the application protects against SSRF attacks, by validating or sanitizing untrusted data or HTTP file metadata, such as filenames and URL input fields, and uses allow lists of protocols, domains, paths and ports. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Verify that the application sanitizes, disables, or sandboxes user-supplied Scalable Vector Graphics (SVG) scriptable content, especially as they relate to XSS resulting from inline scripts, and foreignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Verify that the application sanitizes, disables, or sandboxes user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Output Encoding and Injection Prevention\n\nOutput encoding close or adjacent to the interpreter in use is critical to the security of any application. Typically, output encoding is not persisted, but used to render the output safe in the appropriate output context for immediate use. Failing to output encode will result in an insecure, injectable, and unsafe application.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.3.1** | Verify that output encoding is relevant for the interpreter and context required. For example, use encoders specifically for HTML values, HTML attributes, JavaScript, URL parameters, HTTP headers, SMTP, and others as the context requires, especially from untrusted inputs (e.g. names with Unicode or apostrophes, such as ねこ or O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Verify that output encoding preserves the user's chosen character set and locale, such that any Unicode character point is valid and safely handled. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Verify that context-aware, preferably automated - or at worst, manual - output escaping protects against reflected, stored, and DOM based XSS. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Verify that data selection or database queries (e.g. SQL, HQL, ORM, NoSQL) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from database injection attacks. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Verify that where parameterized or safer mechanisms are not present, context-specific output encoding is used to protect against injection attacks, such as the use of SQL escaping to protect against SQL injection. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Verify that the application protects against JSON injection attacks, JSON eval attacks, and JavaScript expression evaluation. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Verify that the application protects against LDAP injection vulnerabilities, or that specific security controls to prevent LDAP injection have been implemented. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Verify that the application protects against Local File Inclusion (LFI) or Remote File Inclusion (RFI) attacks. | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Verify that the application protects against XPath injection or XML injection attacks. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nNote: Using parameterized queries or escaping SQL is not always sufficient; table and column names, ORDER BY and so on, cannot be escaped. The inclusion of escaped user-supplied data in these fields results in failed queries or SQL injection.\n\nNote: The SVG format explicitly allows ECMA script in almost all contexts, so it may not be possible to block all SVG XSS vectors completely. If SVG upload is required, we strongly recommend either serving these uploaded files as text/plain or using a separate user supplied content domain to prevent successful XSS from taking over the application.\n\n## V5.4 Memory, String, and Unmanaged Code\n\nThe following requirements will only apply when the application uses a systems language or unmanaged code.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.4.1** | Verify that the application uses memory-safe string, safer memory copy and pointer arithmetic to detect or prevent stack, buffer, or heap overflows. | | ✓ | ✓ | 120 |\n| **5.4.2** | Verify that format strings do not take potentially hostile input, and are constant. | | ✓ | ✓ | 134 |\n| **5.4.3** | Verify that sign, range, and input validation techniques are used to prevent integer overflows. | | ✓ | ✓ | 190 |\n\n## V5.5 Deserialization Prevention\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | Verify that serialized objects use integrity checks or are encrypted to prevent hostile object creation or data tampering. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Verify that the application correctly restricts XML parsers to only use the most restrictive configuration possible and to ensure that unsafe features such as resolving external entities are disabled to prevent XML eXternal Entity (XXE) attacks. | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Verify that deserialization of untrusted data is avoided or is protected in both custom code and third-party libraries (such as JSON, XML and YAML parsers). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Verify that when parsing JSON in browsers or JavaScript-based backends, JSON.parse is used to parse the JSON document. Do not use eval() to parse JSON. | ✓ | ✓ | ✓ | 95 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nFor more information on auto-escaping, please see:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nFor more information on deserialization, please see:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:49.234257"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md", "content": "# V6 Stored Cryptography\n\n## Control Objective\n\nEnsure that a verified application satisfies the following high level requirements:\n\n* All cryptographic modules fail in a secure manner and that errors are handled correctly.\n* A suitable random number generator is used.\n* Access to keys is securely managed.\n\n## V6.1 Data Classification\n\nThe most important asset is the data processed, stored or transmitted by an application. Always perform a privacy impact assessment to classify the data protection needs of any stored data correctly.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.1.1** | Verify that regulated private data is stored encrypted while at rest, such as Personally Identifiable Information (PII), sensitive personal information, or data assessed likely to be subject to EU's GDPR. | | ✓ | ✓ | 311 |\n| **6.1.2** | Verify that regulated health data is stored encrypted while at rest, such as medical records, medical device details, or de-anonymized research records. | | ✓ | ✓ | 311 |\n| **6.1.3** | Verify that regulated financial data is stored encrypted while at rest, such as financial accounts, defaults or credit history, tax records, pay history, beneficiaries, or de-anonymized market or research records. | | ✓ | ✓ | 311 |\n\n## V6.2 Algorithms\n\nRecent advances in cryptography mean that previously safe algorithms and key lengths are no longer safe or sufficient to protect data. Therefore, it should be possible to change algorithms.\n\nAlthough this section is not easily penetration tested, developers should consider this entire section as mandatory even though L1 is missing from most of the items.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.2.1** | Verify that all cryptographic modules fail securely, and errors are handled in a way that does not enable Padding Oracle attacks. | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Verify that industry proven or government approved cryptographic algorithms, modes, and libraries are used, instead of custom coded cryptography. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Verify that encryption initialization vector, cipher configuration, and block modes are configured securely using the latest advice. | | ✓ | ✓ | 326 |\n| **6.2.4** | Verify that random number, encryption or hashing algorithms, key lengths, rounds, ciphers or modes, can be reconfigured, upgraded, or swapped at any time, to protect against cryptographic breaks. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Verify that known insecure block modes (i.e. ECB, etc.), padding modes (i.e. PKCS#1 v1.5, etc.), ciphers with small block sizes (i.e. Triple-DES, Blowfish, etc.), and weak hashing algorithms (i.e. MD5, SHA1, etc.) are not used unless required for backwards compatibility. | | ✓ | ✓ | 326 |\n| **6.2.6** | Verify that nonces, initialization vectors, and other single use numbers must not be used more than once with a given encryption key. The method of generation must be appropriate for the algorithm being used. | | ✓ | ✓ | 326 |\n| **6.2.7** | Verify that encrypted data is authenticated via signatures, authenticated cipher modes, or HMAC to ensure that ciphertext is not altered by an unauthorized party. | | | ✓ | 326 |\n| **6.2.8** | Verify that all cryptographic operations are constant-time, with no 'short-circuit' operations in comparisons, calculations, or returns, to avoid leaking information. | | | ✓ | 385 |\n\n## V6.3 Random Values\n\nTrue Pseudo-random Number Generation (PRNG) is incredibly difficult to get right. Generally, good sources of entropy within a system will be quickly depleted if over-used, but sources with less randomness can lead to predictable keys and secrets.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.3.1** | Verify that all random numbers, random file names, random GUIDs, and random strings are generated using the cryptographic module's approved cryptographically secure random number generator when these random values are intended to be not guessable by an attacker. | | ✓ | ✓ | 338 |\n| **6.3.2** | Verify that random GUIDs are created using the GUID v4 algorithm, and a Cryptographically-secure Pseudo-random Number Generator (CSPRNG). GUIDs created using other pseudo-random number generators may be predictable. | | ✓ | ✓ | 338 |\n| **6.3.3** | Verify that random numbers are created with proper entropy even when the application is under heavy load, or that the application degrades gracefully in such circumstances. | | | ✓ | 338 |\n\n## V6.4 Secret Management\n\nAlthough this section is not easily penetration tested, developers should consider this entire section as mandatory even though L1 is missing from most of the items.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.4.1** | Verify that a secrets management solution such as a key vault is used to securely create, store, control access to and destroy secrets. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Verify that key material is not exposed to the application but instead uses an isolated security module like a vault for cryptographic operations. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:49.420472"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x15-V7-Error-Logging.md", "content": "# V7 Error Handling and Logging\n\n## Control Objective\n\nThe primary objective of error handling and logging is to provide useful information for the user, administrators, and incident response teams. The objective is not to create massive amounts of logs, but high quality logs, with more signal than discarded noise.\n\nHigh quality logs will often contain sensitive data, and must be protected as per local data privacy laws or directives. This should include:\n\n* Not collecting or logging sensitive information unless specifically required.\n* Ensuring all logged information is handled securely and protected as per its data classification.\n* Ensuring that logs are not stored forever, but have an absolute lifetime that is as short as possible.\n\nIf logs contain private or sensitive data, the definition of which varies from country to country, the logs become some of the most sensitive information held by the application and thus very attractive to attackers in their own right.\n\nIt is also important to ensure that the application fails securely and that errors do not disclose unnecessary information.\n\n## V7.1 Log Content\n\nLogging sensitive information is dangerous - the logs become classified themselves, which means they need to be encrypted, become subject to retention policies, and must be disclosed in security audits. Ensure only necessary information is kept in logs, and certainly no payment, credentials (including session tokens), sensitive or personally identifiable information.\n\nV7.1 covers OWASP Top 10 2017:A10. As 2017:A10 and this section are not penetration testable, it's important for:\n\n* Developers to ensure full compliance with this section, as if all items were marked as L1\n* Penetration testers to validate full compliance of all items in V7.1 via interview, screenshots, or assertion\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.1.1** | Verify that the application does not log credentials or payment details. Session tokens should only be stored in logs in an irreversible, hashed form. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Verify that the application does not log other sensitive data as defined under local privacy laws or relevant security policy. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Verify that the application logs security relevant events including successful and failed authentication events, access control failures, deserialization failures and input validation failures. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Verify that each log event includes necessary information that would allow for a detailed investigation of the timeline when an event happens. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Log Processing\n\nTimely logging is critical for audit events, triage, and escalation. Ensure that the application's logs are clear and can be easily monitored and analyzed either locally or log shipped to a remote monitoring system.\n\nV7.2 covers OWASP Top 10 2017:A10. As 2017:A10 and this section are not penetration testable, it's important for:\n\n* Developers to ensure full compliance with this section, as if all items were marked as L1\n* Penetration testers to validate full compliance of all items in V7.2 via interview, screenshots, or assertion\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.2.1** | Verify that all authentication decisions are logged, without storing sensitive session tokens or passwords. This should include requests with relevant metadata needed for security investigations. | | ✓ | ✓ | 778 |\n| **7.2.2** | Verify that all access control decisions can be logged and all failed decisions are logged. This should include requests with relevant metadata needed for security investigations. | | ✓ | ✓ | 285 |\n\n## V7.3 Log Protection\n\nLogs that can be trivially modified or deleted are useless for investigations and prosecutions. Disclosure of logs can expose inner details about the application or the data it contains. Care must be taken when protecting logs from unauthorized disclosure, modification or deletion.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.3.1** | Verify that all logging components appropriately encode data to prevent log injection. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [DELETED, DUPLICATE OF 7.3.1] | | | | |\n| **7.3.3** | Verify that security logs are protected from unauthorized access and modification. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Verify that time sources are synchronized to the correct time and time zone. Strongly consider logging only in UTC if systems are global to assist with post-incident forensic analysis. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nNote: Log encoding (7.3.1) is difficult to test and review using automated dynamic tools and penetration tests, but architects, developers, and source code reviewers should consider it an L1 requirement.\n\n## V7.4 Error Handling\n\nThe purpose of error handling is to allow the application to provide security relevant events for monitoring, triage and escalation. The purpose is not to create logs. When logging security related events, ensure that there is a purpose to the log, and that it can be distinguished by SIEM or analysis software.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.4.1** | Verify that a generic message is shown when an unexpected or security sensitive error occurs, potentially with a unique ID which support personnel can use to investigate. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Verify that exception handling (or a functional equivalent) is used across the codebase to account for expected and unexpected error conditions. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Verify that a \"last resort\" error handler is defined which will catch all unhandled exceptions. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nNote: Certain languages, such as Swift and Go - and through common design practice - many functional languages, do not support exceptions or last resort event handlers. In this case, architects and developers should use a pattern, language, or framework friendly way to ensure that applications can securely handle exceptional, unexpected, or security-related events.\n\n## References\n\nFor more information, see also:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:49.493948"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x16-V8-Data-Protection.md", "content": "# V8 Data Protection\n\n## Control Objective\n\nThere are three key elements to sound data protection: Confidentiality, Integrity and Availability (CIA). This standard assumes that data protection is enforced on a trusted system, such as a server, which has been hardened and has sufficient protections.\n\nApplications have to assume that all user devices are compromised in some way. Where an application transmits or stores sensitive information on insecure devices, such as shared computers, phones and tablets, the application is responsible for ensuring data stored on these devices is encrypted and cannot be easily illicitly obtained, altered or disclosed.\n\nEnsure that a verified application satisfies the following high level data protection requirements:\n\n* Confidentiality: Data should be protected from unauthorized observation or disclosure both in transit and when stored.\n* Integrity: Data should be protected from being maliciously created, altered or deleted by unauthorized attackers.\n* Availability: Data should be available to authorized users as required.\n\n## V8.1 General Data Protection\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.1.1** | Verify the application protects sensitive data from being cached in server components such as load balancers and application caches. | | ✓ | ✓ | 524 |\n| **8.1.2** | Verify that all cached or temporary copies of sensitive data stored on the server are protected from unauthorized access or purged/invalidated after the authorized user accesses the sensitive data. | | ✓ | ✓ | 524 |\n| **8.1.3** | Verify the application minimizes the number of parameters in a request, such as hidden fields, Ajax variables, cookies and header values. | | ✓ | ✓ | 233 |\n| **8.1.4** | Verify the application can detect and alert on abnormal numbers of requests, such as by IP, user, total per hour or day, or whatever makes sense for the application. | | ✓ | ✓ | 770 |\n| **8.1.5** | Verify that regular backups of important data are performed and that test restoration of data is performed. | | | ✓ | 19 |\n| **8.1.6** | Verify that backups are stored securely to prevent data from being stolen or corrupted. | | | ✓ | 19 |\n\n## V8.2 Client-side Data Protection\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.2.1** | Verify the application sets sufficient anti-caching headers so that sensitive data is not cached in modern browsers. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Verify that data stored in browser storage (such as localStorage, sessionStorage, IndexedDB, or cookies) does not contain sensitive data. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Sensitive Private Data\n\nThis section helps protect sensitive data from being created, read, updated, or deleted without authorization, particularly in bulk quantities.\n\nCompliance with this section implies compliance with V4 Access Control, and in particular V4.2. For example, to protect against unauthorized updates or disclosure of sensitive personal information requires adherence to V4.2.1. Please comply with this section and V4 for full coverage.\n\nNote: Privacy regulations and laws, such as the Australian Privacy Principles APP-11 or GDPR, directly affect how applications must approach the implementation of storage, use, and transmission of sensitive personal information. This ranges from severe penalties to simple advice. Please consult your local laws and regulations, and consult a qualified privacy specialist or lawyer as required.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.3.1** | Verify that sensitive data is sent to the server in the HTTP message body or headers, and that query string parameters from any HTTP verb do not contain sensitive data. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Verify that users have a method to remove or export their data on demand. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Verify that users are provided clear language regarding collection and use of supplied personal information and that users have provided opt-in consent for the use of that data before it is used in any way. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Verify that all sensitive data created and processed by the application has been identified, and ensure that a policy is in place on how to deal with sensitive data. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Verify accessing sensitive data is audited (without logging the sensitive data itself), if the data is collected under relevant data protection directives or where logging of access is required. | | ✓ | ✓ | 532 |\n| **8.3.6** | Verify that sensitive information contained in memory is overwritten as soon as it is no longer required to mitigate memory dumping attacks, using zeroes or random data. | | ✓ | ✓ | 226 |\n| **8.3.7** | Verify that sensitive or private information that is required to be encrypted, is encrypted using approved algorithms that provide both confidentiality and integrity. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Verify that sensitive personal information is subject to data retention classification, such that old or out of date data is deleted automatically, on a schedule, or as the situation requires. | | ✓ | ✓ | 285 |\n\nWhen considering data protection, a primary consideration should be around bulk extraction or modification or excessive usage. For example, many social media systems only allow users to add 100 new friends per day, but which system these requests came from is not important. A banking platform might wish to block more than 5 transactions per hour transferring more than 1000 euro of funds to external institutions. Each system's requirements are likely to be very different, so deciding on \"abnormal\" must consider the threat model and business risk. Important criteria are the ability to detect, deter, or preferably block such abnormal bulk actions.\n\n## References\n\nFor more information, see also:\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:49.624605"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md", "content": "# V9 Communication\n\n## Control Objective\n\nEnsure that a verified application meets the following high level requirements:\n\n* Require TLS or strong encryption, independent of sensitivity of the content.\n* Follow the latest guidance, including:\n  * Configuration advice\n  * Preferred algorithms and ciphers\n* Avoid weak or soon to be deprecated algorithms and ciphers, except as a last resort\n* Disable deprecated or known insecure algorithms and ciphers.\n\nWithin these requirements:\n\n* Stay current with recommended industry advice on secure TLS configuration, as it changes frequently (often due to catastrophic breaks in existing algorithms and ciphers).\n* Use the most recent versions of TLS configuration review tools to configure the preferred order and algorithm selection.\n* Check your configuration periodically to ensure that secure communication is always present and effective.\n\n## V9.1 Client Communication Security\n\nEnsure all client messages are sent over encrypted networks, using TLS 1.2 or later.\nUse up to date tools to review the client configuration on a regular basis.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.1.1** | Verify that TLS is used for all client connectivity, and does not fall back to insecure or unencrypted communications. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Verify using up to date TLS testing tools that only strong cipher suites are enabled, with the strongest cipher suites set as preferred. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Verify that only the latest recommended versions of the TLS protocol are enabled, such as TLS 1.2 and TLS 1.3. The latest version of the TLS protocol should be the preferred option. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Server Communication Security\n\nServer communications are more than just HTTP. Secure connections to and from other systems, such as monitoring systems, management tools, remote access and ssh, middleware, database, mainframes, partner or external source systems &mdash; must be in place. All of these must be encrypted to prevent \"hard on the outside, trivially easy to intercept on the inside\".\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.2.1** | Verify that connections to and from the server use trusted TLS certificates. Where internally generated or self-signed certificates are used, the server must be configured to only trust specific internal CAs and specific self-signed certificates. All others should be rejected. | | ✓ | ✓ | 295 |\n| **9.2.2** | Verify that encrypted communications such as TLS is used for all inbound and outbound connections, including for management ports, monitoring, authentication, API, or web service calls, database, cloud, serverless, mainframe, external, and partner connections. The server must not fall back to insecure or unencrypted protocols. | | ✓ | ✓ | 319 |\n| **9.2.3** | Verify that all encrypted connections to external systems that involve sensitive information or functions are authenticated. | | ✓ | ✓ | 287 |\n| **9.2.4** | Verify that proper certification revocation, such as Online Certificate Status Protocol (OCSP) Stapling, is enabled and configured. | | ✓ | ✓ | 299 |\n| **9.2.5** | Verify that backend TLS connection failures are logged. | | | ✓ | 544 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Notes on “Approved modes of TLS”:\n    * In the past, the ASVS referred to the US standard FIPS 140-2, but as a global standard, applying US standards can be difficult, contradictory, or confusing to apply.\n    * A better method of achieving compliance with section 9.1 would be to review guides such as [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) or [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/), and use known and up to date TLS evaluation tools to obtain a desired level of security.\n", "timestamp": "2025-10-24T11:39:49.698318"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x18-V10-Malicious.md", "content": "# V10 Malicious Code\n\n## Control Objective\n\nEnsure that code satisfies the following high level requirements:\n\n* Malicious activity is handled securely and properly to not affect the rest of the application.\n* Does not have time bombs or other time-based attacks.\n* Does not \"phone home\" to malicious or unauthorized destinations.\n* Does not have back doors, Easter eggs, salami attacks, rootkits, or unauthorized code that can be controlled by an attacker.\n\nFinding malicious code is proof of the negative, which is impossible to completely validate. Best efforts should be undertaken to ensure that the code has no inherent malicious code or unwanted functionality.\n\n## V10.1 Code Integrity\n\nThe best defense against malicious code is \"trust, but verify\". Introducing unauthorized or malicious code into code is often a criminal offence in many jurisdictions. Policies and procedures should make sanctions regarding malicious code clear.\n\nLead developers should regularly review code check-ins, particularly those that might access time, I/O, or network functions.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.1.1** | Verify that a code analysis tool is in use that can detect potentially malicious code, such as time functions, unsafe file operations and network connections. | | | ✓ | 749 |\n\n## V10.2 Malicious Code Search\n\nMalicious code is extremely rare and is difficult to detect. Manual line by line code review can assist looking for logic bombs, but even the most experienced code reviewer will struggle to find malicious code even if they know it exists.\n\nComplying with this section is not possible without complete access to source code, including third-party libraries.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.2.1** | Verify that the application source code and third party libraries do not contain unauthorized phone home or data collection capabilities. Where such functionality exists, obtain the user's permission for it to operate before collecting any data. | | ✓ | ✓ | 359 |\n| **10.2.2** | Verify that the application does not ask for unnecessary or excessive permissions to privacy related features or sensors, such as contacts, cameras, microphones, or location. | | ✓ | ✓ | 272 |\n| **10.2.3** | Verify that the application source code and third party libraries do not contain back doors, such as hard-coded or additional undocumented accounts or keys, code obfuscation, undocumented binary blobs, rootkits, or anti-debugging, insecure debugging features, or otherwise out of date, insecure, or hidden functionality that could be used maliciously if discovered. | | | ✓ | 507 |\n| **10.2.4** | Verify that the application source code and third party libraries do not contain time bombs by searching for date and time related functions. | | | ✓ | 511 |\n| **10.2.5** | Verify that the application source code and third party libraries do not contain malicious code, such as salami attacks, logic bypasses, or logic bombs. | | | ✓ | 511 |\n| **10.2.6** | Verify that the application source code and third party libraries do not contain Easter eggs or any other potentially unwanted functionality. | | | ✓ | 507 |\n\n## V10.3 Application Integrity\n\nOnce an application is deployed, malicious code can still be inserted. Applications need to protect themselves against common attacks, such as executing unsigned code from untrusted sources and subdomain takeovers.\n\nComplying with this section is likely to be operational and continuous.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.3.1** | Verify that if the application has a client or server auto-update feature, updates should be obtained over secure channels and digitally signed. The update code must validate the digital signature of the update before installing or executing the update. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Verify that the application employs integrity protections, such as code signing or subresource integrity. The application must not load or execute code from untrusted sources, such as loading includes, modules, plugins, code, or libraries from untrusted sources or the Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Verify that the application has protection from subdomain takeovers if the application relies upon DNS entries or DNS subdomains, such as expired domain names, out of date DNS pointers or CNAMEs, expired projects at public source code repos, or transient cloud APIs, serverless functions, or storage buckets (*autogen-bucket-id*.cloud.example.com) or similar. Protections can include ensuring that DNS names used by applications are regularly checked for expiry or change. | ✓ | ✓ | ✓ | 350 |\n\n## References\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:49.819429"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x19-V11-BusLogic.md", "content": "# V11 Business Logic\n\n## Control Objective\n\nEnsure that a verified application satisfies the following high level requirements:\n\n* The business logic flow is sequential, processed in order, and cannot be bypassed.\n* Business logic includes limits to detect and prevent automated attacks, such as continuous small funds transfers, or adding a million friends one at a time, and so on.\n* High value business logic flows have considered abuse cases and malicious actors, and have protections against spoofing, tampering, information disclosure, and elevation of privilege attacks.\n\n## V11.1 Business Logic Security\n\nBusiness logic security is so individual to every application that no one checklist will ever apply. Business logic security must be designed in to protect against likely external threats - it cannot be added using web application firewalls or secure communications. We recommend the use of threat modeling during design sprints, for example using the OWASP Cornucopia or similar tools.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **11.1.1** | Verify that the application will only process business logic flows for the same user in sequential step order and without skipping steps.| ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Verify that the application will only process business logic flows with all steps being processed in realistic human time, i.e. transactions are not submitted too quickly.| ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Verify the application has appropriate limits for specific business actions or transactions which are correctly enforced on a per user basis. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Verify that the application has anti-automation controls to protect against excessive calls such as mass data exfiltration, business logic requests, file uploads or denial of service attacks. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Verify the application has business logic limits or validation to protect against likely business risks or threats, identified using threat modeling or similar methodologies. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Verify that the application does not suffer from \"Time Of Check to Time Of Use\" (TOCTOU) issues or other race conditions for sensitive operations. | | ✓ | ✓ | 367 |\n| **11.1.7** | Verify that the application monitors for unusual events or activity from a business logic perspective. For example, attempts to perform actions out of order or actions which a normal user would never attempt. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Verify that the application has configurable alerting when automated attacks or unusual activity is detected. | | ✓ | ✓ | 390 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* Anti-automation can be achieved in many ways, including the use of [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) can also help with Attack Detection and Response.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:49.908604"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x20-V12-Files-Resources.md", "content": "# V12 Files and Resources\n\n## Control Objective\n\nEnsure that a verified application satisfies the following high level requirements:\n\n* Untrusted file data should be handled accordingly and in a secure manner.\n* Untrusted file data obtained from untrusted sources are stored outside the web root and with limited permissions.\n\n## V12.1 File Upload\n\nAlthough zip bombs are eminently testable using penetration testing techniques, they are considered L2 and above to encourage design and development consideration with careful manual testing, and to avoid automated or unskilled manual penetration testing of a denial of service condition.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.1.1** | Verify that the application will not accept large files that could fill up storage or cause a denial of service. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Verify that the application checks compressed files (e.g. zip, gz, docx, odt) against maximum allowed uncompressed size and against maximum number of files before uncompressing the file. | | ✓ | ✓ | 409 |\n| **12.1.3** | Verify that a file size quota and maximum number of files per user is enforced to ensure that a single user cannot fill up the storage with too many files, or excessively large files. | | ✓ | ✓ | 770 |\n\n## V12.2 File Integrity\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.2.1** | Verify that files obtained from untrusted sources are validated to be of expected type based on the file's content. | | ✓ | ✓ | 434 |\n\n## V12.3 File Execution\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.3.1** | Verify that user-submitted filename metadata is not used directly by system or framework filesystems and that a URL API is used to protect against path traversal. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure, creation, updating or removal of local files (LFI). | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure or execution of remote files via Remote File Inclusion (RFI) or Server-side Request Forgery (SSRF) attacks. | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Verify that the application protects against Reflective File Download (RFD) by validating or ignoring user-submitted filenames in a JSON, JSONP, or URL parameter, the response Content-Type header should be set to text/plain, and the Content-Disposition header should have a fixed filename. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Verify that untrusted file metadata is not used directly with system API or libraries, to protect against OS command injection. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Verify that the application does not include and execute functionality from untrusted sources, such as unverified content distribution networks, JavaScript libraries, node npm libraries, or server-side DLLs. | | ✓ | ✓ | 829 |\n\n## V12.4 File Storage\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.4.1** | Verify that files obtained from untrusted sources are stored outside the web root, with limited permissions. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Verify that files obtained from untrusted sources are scanned by antivirus scanners to prevent upload and serving of known malicious content. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 File Download\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.5.1** | Verify that the web tier is configured to serve only files with specific file extensions to prevent unintentional information and source code leakage. For example, backup files (e.g. .bak), temporary working files (e.g. .swp), compressed files (.zip, .tar.gz, etc) and other extensions commonly used by editors should be blocked unless required. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Verify that direct requests to uploaded files will never be executed as HTML/JavaScript content. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 SSRF Protection\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.6.1** | Verify that the web or application server is configured with an allow list of resources or systems to which the server can send requests or load data/files from. | ✓ | ✓ | ✓ | 918 |\n\n## References\n\nFor more information, see also:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:50.004357"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x21-V13-API.md", "content": "# V13 API and Web Service\n\n## Control Objective\n\nEnsure that a verified application that uses trusted service layer APIs (commonly using JSON or XML or GraphQL) has:\n\n* Adequate authentication, session management and authorization of all web services.\n* Input validation of all parameters that transit from a lower to higher trust level.\n* Effective security controls for all API types, including cloud and Serverless API\n\nPlease read this chapter in combination with all other chapters at this same level; we no longer duplicate authentication or API session management concerns.\n\n## V13.1 Generic Web Service Security\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.1.1** | Verify that all application components use the same encodings and parsers to avoid parsing attacks that exploit different URI or file parsing behavior that could be used in SSRF and RFI attacks. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [DELETED, DUPLICATE OF 4.3.1] | | | | |\n| **13.1.3** | Verify API URLs do not expose sensitive information, such as the API key, session tokens etc. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Verify that authorization decisions are made at both the URI, enforced by programmatic or declarative security at the controller or router, and at the resource level, enforced by model-based permissions. | | ✓ | ✓ | 285 |\n| **13.1.5** | Verify that requests containing unexpected or missing content types are rejected with appropriate headers (HTTP response status 406 Unacceptable or 415 Unsupported Media Type). | | ✓ | ✓ | 434 |\n\n## V13.2 RESTful Web Service\n\nJSON schema validation is in a draft stage of standardization (see references). When considering using JSON schema validation, which is best practice for RESTful web services, consider using these additional data validation strategies in combination with JSON schema validation:\n\n* Parsing validation of the JSON object, such as if there are missing or extra elements.\n* Validation of the JSON object values using standard input validation methods, such as data type, data format, length, etc.\n* and formal JSON schema validation.\n\nOnce the JSON schema validation standard is formalized, ASVS will update its advice in this area. Carefully monitor any JSON schema validation libraries in use, as they will need to be updated regularly until the standard is formalized and bugs are ironed out of reference implementations.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.2.1** | Verify that enabled RESTful HTTP methods are a valid choice for the user or action, such as preventing normal users using DELETE or PUT on protected API or resources. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Verify that JSON schema validation is in place and verified before accepting input. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Verify that RESTful web services that utilize cookies are protected from Cross-Site Request Forgery via the use of at least one or more of the following: double submit cookie pattern, CSRF nonces, or Origin request header checks. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [DELETED, DUPLICATE OF 11.1.4] | | | | |\n| **13.2.5** | Verify that REST services explicitly check the incoming Content-Type to be the expected one, such as application/xml or application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Verify that the message headers and payload are trustworthy and not modified in transit. Requiring strong encryption for transport (TLS only) may be sufficient in many cases as it provides both confidentiality and integrity protection. Per-message digital signatures can provide additional assurance on top of the transport protections for high-security applications but bring with them additional complexity and risks to weigh against the benefits. | | ✓ | ✓ | 345 |\n\n## V13.3 SOAP Web Service\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.3.1** | Verify that XSD schema validation takes place to ensure a properly formed XML document, followed by validation of each input field before any processing of that data takes place. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Verify that the message payload is signed using WS-Security to ensure reliable transport between client and service. | | ✓ | ✓ | 345 |\n\nNote: Due to issues with XXE attacks against DTDs, DTD validation should not be used, and framework DTD evaluation disabled as per the requirements set out in V14 Configuration.\n\n## V13.4 GraphQL\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.4.1** | Verify that a query allow list or a combination of depth limiting and amount limiting is used to prevent GraphQL or data layer expression Denial of Service (DoS) as a result of expensive, nested queries. For more advanced scenarios, query cost analysis should be used. | | ✓ | ✓ | 770 |\n| **13.4.2** | Verify that GraphQL or other data layer authorization logic should be implemented at the business logic layer instead of the GraphQL layer. | | ✓ | ✓ | 285 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:50.118228"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x22-V14-Config.md", "content": "# V14 Configuration\n\n## Control Objective\n\nEnsure that a verified application has:\n\n* A secure, repeatable, automatable build environment.\n* Hardened third party library, dependency and configuration management such that out of date or insecure components are not included by the application.\n\nConfiguration of the application out of the box should be safe to be on the Internet, which means a safe out of the box configuration.\n\n## V14.1 Build and Deploy\n\nBuild pipelines are the basis for repeatable security - every time something insecure is discovered, it can be resolved in the source code, build or deployment scripts, and tested automatically. We are strongly encouraging the use of build pipelines with automatic security and dependency checks that warn or break the build to prevent known security issues being deployed into production. Manual steps performed irregularly directly leads to avoidable security mistakes.\n\nAs the industry moves to a DevSecOps model, it is important to ensure the continued availability and integrity of deployment and configuration to achieve a \"known good\" state. In the past, if a system was hacked, it would take days to months to prove that no further intrusions had taken place. Today, with the advent of software defined infrastructure, rapid A/B deployments with zero downtime, and automated containerized builds, it is possible to automatically and continuously build, harden, and deploy a \"known good\" replacement for any compromised system.\n\nIf traditional models are still in place, then manual steps must be taken to harden and back up that configuration to allow the compromised systems to be quickly replaced with high integrity, uncompromised systems in a timely fashion.\n\nCompliance with this section requires an automated build system, and access to build and deployment scripts.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.1.1** | Verify that the application build and deployment processes are performed in a secure and repeatable way, such as CI / CD automation, automated configuration management, and automated deployment scripts. | | ✓ | ✓ | |\n| **14.1.2** | Verify that compiler flags are configured to enable all available buffer overflow protections and warnings, including stack randomization, data execution prevention, and to break the build if an unsafe pointer, memory, format string, integer, or string operations are found. | | ✓ | ✓ | 120 |\n| **14.1.3** | Verify that server configuration is hardened as per the recommendations of the application server and frameworks in use. | | ✓ | ✓ | 16 |\n| **14.1.4** | Verify that the application, configuration, and all dependencies can be re-deployed using automated deployment scripts, built from a documented and tested runbook in a reasonable time, or restored from backups in a timely fashion. | | ✓ | ✓ | |\n| **14.1.5** | Verify that authorized administrators can verify the integrity of all security-relevant configurations to detect tampering. | | | ✓ | |\n\n## V14.2 Dependency\n\nDependency management is critical to the safe operation of any application of any type. Failure to keep up to date with outdated or insecure dependencies is the root cause of the largest and most expensive attacks to date.\n\nNote: At Level 1, 14.2.1 compliance relates to observations or detections of client-side and other libraries and components, rather than the more accurate build-time static code analysis or dependency analysis. These more accurate techniques could be discoverable by interview as required.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.2.1** | Verify that all components are up to date, preferably using a dependency checker during build or compile time. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Verify that all unneeded features, documentation, sample applications and configurations are removed. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Verify that if application assets, such as JavaScript libraries, CSS or web fonts, are hosted externally on a Content Delivery Network (CDN) or external provider, Subresource Integrity (SRI) is used to validate the integrity of the asset. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Verify that third party components come from pre-defined, trusted and continually maintained repositories. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Verify that a Software Bill of Materials (SBOM) is maintained of all third party libraries in use. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Verify that the attack surface is reduced by sandboxing or encapsulating third party libraries to expose only the required behaviour into the application. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Unintended Security Disclosure\n\nConfigurations for production should be hardened to protect against common attacks, such as debug consoles, raise the bar for Cross-site Scripting (XSS) and Remote File Inclusion (RFI) attacks, and to eliminate trivial information discovery \"vulnerabilities\" that are the unwelcome hallmark of many penetration testing reports. Many of these issues are rarely rated as a significant risk, but they are chained together with other vulnerabilities. If these issues are not present by default, it raises the bar before most attacks can succeed.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.3.1** | [DELETED, DUPLICATE OF 7.4.1] | | | | |\n| **14.3.2** | Verify that web or application server and application framework debug modes are disabled in production to eliminate debug features, developer consoles, and unintended security disclosures. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Verify that the HTTP headers or any part of the HTTP response do not expose detailed version information of system components. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 HTTP Security Headers\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.4.1** | Verify that every HTTP response contains a Content-Type header. Also specify a safe character set (e.g., UTF-8, ISO-8859-1) if the content types are text/*, /+xml and application/xml. Content must match with the provided Content-Type header. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Verify that all API responses contain a Content-Disposition: attachment; filename=\"api.json\" header (or other appropriate filename for the content type). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Verify that a Content Security Policy (CSP) response header is in place that helps mitigate impact for XSS attacks like HTML, DOM, JSON, and JavaScript injection vulnerabilities. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Verify that all responses contain a X-Content-Type-Options: nosniff header. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Verify that a Strict-Transport-Security header is included on all responses and for all subdomains, such as Strict-Transport-Security: max-age=15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Verify that a suitable Referrer-Policy header is included to avoid exposing sensitive information in the URL through the Referer header to untrusted parties. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Verify that the content of a web application cannot be embedded in a third-party site by default and that embedding of the exact resources is only allowed where necessary by using suitable Content-Security-Policy: frame-ancestors and X-Frame-Options response headers. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 HTTP Request Header Validation\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.5.1** | Verify that the application server only accepts the HTTP methods in use by the application/API, including pre-flight OPTIONS, and logs/alerts on any requests that are not valid for the application context. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Verify that the supplied Origin header is not used for authentication or access control decisions, as the Origin header can easily be changed by an attacker. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Verify that the Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header uses a strict allow list of trusted domains and subdomains to match against and does not support the \"null\" origin. | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Verify that HTTP headers added by a trusted proxy or SSO devices, such as a bearer token, are authenticated by the application. | | ✓ | ✓ | 306 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering]( https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Adding Content-Disposition to API responses helps prevent many attacks based on misunderstanding on the MIME type between client and server, and the \"filename\" option specifically helps prevent [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:50.230673"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x90-Appendix-A_Glossary.md", "content": "# Appendix A: Glossary\n\n- **Address Space Layout Randomization** (ASLR) – A technique to make exploiting memory corruption bugs more difficult.\n- **Allow list** – A list of permitted data or operations, for example a list of characters that are allowed to perform input validation.\n- **Application Security** – Application-level security focuses on the analysis of components that comprise the application layer of the Open Systems Interconnection Reference Model (OSI Model), rather than focusing on for example the underlying operating system or connected networks.\n- **Application Security Verification** – The technical assessment of an application against the OWASP ASVS.\n- **Application Security Verification Report** – A report that documents the overall results and supporting analysis produced by the verifier for a particular application.\n- **Authentication** – The verification of the claimed identity of an application user.\n- **Automated Verification** – The use of automated tools (either dynamic analysis tools, static analysis tools, or both) that use vulnerability signatures to find problems.\n- **Black box testing** – It is a method of software testing that examines the functionality of an application without peering into its internal structures or workings.\n- **Component** – a self-contained unit of code, with associated disk and network interfaces that communicates with other components.\n- **Cross-Site Scripting** (XSS) – A security vulnerability typically found in web applications allowing the injection of client-side scripts into content.\n- **Cryptographic module** – Hardware, software, and/or firmware that implements cryptographic algorithms and/or generates cryptographic keys.\n- **Common Weakness Enumeration** (CWE) - A community-developed list of common software security weaknesses. It serves as a common language, a measuring stick for software security tools, and as a baseline for weakness identification, mitigation, and prevention efforts.\n- **Design Verification** – The technical assessment of the security architecture of an application.\n- **Dynamic Application Security Testing** (DAST) - Technologies are designed to detect conditions indicative of a security vulnerability in an application in its running state.\n- **Dynamic Verification** – The use of automated tools that use vulnerability signatures to find problems during the execution of an application.\n- **Fast IDentity Online** (FIDO) - A set of authentication standards which allow a variety of different authentication methods to be used including biometrics, Trusted Platform Modules (TPMs), USB security tokens, etc.\n- **Globally Unique Identifier** (GUID) – a unique reference number used as an identifier in software.\n- **Hyper Text Transfer Protocol** (HTTPS) – An application protocol for distributed, collaborative, hypermedia information systems. It is the foundation of data communication for the World Wide Web.\n- **Hardcoded keys** – Cryptographic keys which are stored on the filesystem, be it in code, comments or files.\n- **Hardware Security Module** (HSM) - Hardware component which is able to store cryptographic keys and other secrets in a protected manner.\n- **Hibernate Query Language** (HQL) - A query language that is similar in appearance to SQL used by the Hibernate ORM library. \n- **Input Validation** – The canonicalization and validation of untrusted user input.\n- **Malicious Code** – Code introduced into an application during its development unbeknownst to the application owner, which circumvents the application's intended security policy. Not the same as malware such as a virus or worm!\n- **Malware** – Executable code that is introduced into an application during runtime without the knowledge of the application user or administrator.\n- **Open Web Application Security Project** (OWASP) – The Open Web Application Security Project (OWASP) is a worldwide free and open community focused on improving the security of application software. Our mission is to make application security \"visible,\" so that people and organizations can make informed decisions about application security risks. See: https://www.owasp.org/\n- **One-time Password** (OTP) - A password which is uniquely generated to be used on a single occasion.\n- **Object-relational Mapping** (ORM) - A system used to allow a relational/table-based database to be referenced and queried within an application program using an application-compatible object model.\n- **Password-Based Key Derivation Function 2** (PBKDF2) - A special one-way algorithm used to create a strong cryptographic key from an input text (such as a password) and an additional random salt value and can therefore be used make it harder to crack a password offline if the resulting value is stored instead of the original password.\n- **Personally Identifiable Information** (PII) - is information that can be used on its own or with other information to identify, contact, or locate a single person, or to identify an individual in context.\n- **Position-independent executable** (PIE) - A body of machine code that, being placed somewhere in the primary memory, executes properly regardless of its absolute address.\n- **Public Key Infrastructure** (PKI) - An arrangement that binds public keys with respective identities of entities. The binding is established through a process of registration and issuance of certificates at and by a certificate authority (CA).\n- **Public Switched Telephone Network** (PSTN) - The traditional telephone network including both fixed-line telephones and mobile telephones.\n- **Relying Party** (RP) - Generally an application which is relying on a user having authenticated against a separate authentication provider. The application is relying on some sort of token or set of signed assertions provided by that authentication provider to trust that the user is who they say they are.\n- **Static application security testing** (SAST) - A set of technologies designed to analyze application source code, byte code and binaries for coding and design conditions that are indicative of security vulnerabilities. SAST solutions analyze an application from the “inside out” in a non-running state.\n- **Software development lifecycle** (SDLC) - The step by step process by which software is developed going from the initial requirements to deployment and maintainance.\n- **Security Architecture** – An abstraction of an application's design that identifies and describes where and how security controls are used, and also identifies and describes the location and sensitivity of both user and application data.\n- **Security Configuration** – The runtime configuration of an application that affects how security controls are used.\n- **Security Control** – A function or component that performs a security check (e.g. an access control check) or when called results in a security effect (e.g. generating an audit record).\n- **Server-side Request Forgery** (SSRF) - An attack which abuses functionality on the server to read or update internal resources by supplying or modifying a URL which the code running on the server will read or submit data to.\n- **Single Sign-on Authentication** (SSO) - This occurs when a user logs into one application and is then automatically logged in to other applications without having to re-authenticate. For example, when you login to Google, when accessing other Google services such as YouTube, Google Docs, and Gmail you will be automatically logged in.\n- **SQL Injection** (SQLi) – A code injection technique used to attack data driven applications, in which malicious SQL statements are inserted into an entry point.\n- **SVG** - Scalable Vector Graphics\n- **Time-based OTP** - A method of generating an OTP where the current time acts as part of the algorithm to generate the password.\n- **Threat Modeling** - A technique consisting of developing increasingly refined security architectures to identify threat agents, security zones, security controls, and important technical and business assets.\n- **Transport Layer Security** (TLS) – Cryptographic protocols that provide communication security over a network connection\n- **Trusted Platform Module** (TPM) - A type of HSM which is usually attached to a larger hardware component such as a motherboard and acts as the \"root of trust\" for that system.\n- **Two-factor authentication** (2FA) - This adds a second level of authentication to an account log-in.\n- **Universal 2nd Factor** (U2F) - One of the standards created by FIDO specifically for allowing a USB or NFC security key to be used as a 2nd authentication factor.\n- **URI/URL/URL fragments** – A Uniform Resource Identifier is a string of characters used to identify a name or a web resource. A Uniform Resource Locator is often used as a reference to a resource.\n- **Verifier** – The person or team that is reviewing an application against the OWASP ASVS requirements.\n- **What You See Is What You Get** (WYSIWYG) - A type of rich content editor which shows how the content will actually look when rendered rather than showing the coding used to govern the rendering.\n- **X.509 Certificate** – An X.509 certificate is a digital certificate that uses the widely accepted international X.509 public key infrastructure (PKI) standard to verify that a public key belongs to the user, computer or service identity contained within the certificate.\n- **XML eXternal Entity** (XXE) - A type of XML entity that can access local or remote content via a declared system identifier. This may load to various injection attacks.", "timestamp": "2025-10-24T11:39:50.350812"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x91-Appendix-B_References.md", "content": "# Appendix B: References\n\nThe following OWASP projects are most likely to be useful to users/adopters of this standard:\n\n## OWASP Core Projects\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n##  OWASP Cheat Sheet Series project\n\n[This project](https://owasp.org/www-project-cheat-sheets/) has a number of cheat sheets which will be relevant for different topics in the ASVS.\n\nThere is a mapping to the ASVS which can be found here: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Mobile Security Related Projects\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## OWASP Internet of Things related projects\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## OWASP Serverless projects\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Others\n\nSimilarly, the following web sites are most likely to be useful to users/adopters of this standard\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:50.421628"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/en/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x93-Appendix-C_IoT.md", "content": "# Appendix C: Internet of Things Verification Requirements\n\nThis chapter was originally in the main branch, but with the work that the OWASP IoT team has done, it doesn't make sense to maintain two different threads on the subject. For the 4.0 release, we are moving this to the Appendix, and urge all who require this, to rather use the main [OWASP IoT project](https://owasp.org/www-project-internet-of-things/)\n\n## Control Objective\n\nEmbedded/IoT devices should:\n\n* Have the same level of security controls within the device as found in the server, by enforcing security controls in a trusted environment.\n* Sensitive data stored on the device should be done so in a secure manner using hardware backed storage such as secure elements.\n* All sensitive data transmitted from the device should utilize transport layer security.\n\n## Security Verification Requirements\n\n| # | Description | L1 | L2 | L3 | Since |\n| --- | --- | --- | --- | -- | -- |\n| **C.1** | Verify that application layer debugging interfaces such USB, UART, and other serial variants are disabled or protected by a complex password. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Verify that cryptographic keys and certificates are unique to each individual device. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Verify that memory protection controls such as ASLR and DEP are enabled by the embedded/IoT operating system, if applicable. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Verify that on-chip debugging interfaces such as JTAG or SWD are disabled or that available protection mechanism is enabled and configured appropriately. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Verify that trusted execution is implemented and enabled, if available on the device SoC or CPU. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Verify that sensitive data, private keys and certificates are stored securely in a Secure Element, TPM, TEE (Trusted Execution Environment), or protected using strong cryptography. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Verify that the firmware apps protect data-in-transit using transport layer security. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Verify that the firmware apps validate the digital signature of server connections. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Verify that wireless communications are mutually authenticated. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Verify that wireless communications are sent over an encrypted channel.  | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Verify that any use of banned C functions are replaced with the appropriate safe equivalent functions. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Verify that each firmware maintains a software bill of materials cataloging third-party components, versioning, and published vulnerabilities. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Verify all code including third-party binaries, libraries, frameworks are reviewed for hardcoded credentials (backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Verify that the application and firmware components are not susceptible to OS Command Injection by invoking shell command wrappers, scripts, or that security controls prevent OS Command Injection. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Verify that the firmware apps pin the digital signature to a trusted server(s). |  | ✓ | ✓ | 4.0 |\n| **C.16** | Verify the presence of tamper resistance and/or tamper detection features. |  | ✓ | ✓ | 4.0 |\n| **C.17** | Verify that any available Intellectual Property protection technologies provided by the chip manufacturer are enabled. |  | ✓ | ✓ | 4.0 |\n| **C.18** | Verify security controls are in place to hinder firmware reverse engineering (e.g., removal of verbose debugging symbols). |  | ✓ | ✓ | 4.0 |\n| **C.19** | Verify the device validates the boot image signature before loading. |  | ✓ | ✓ | 4.0 |\n| **C.20** | Verify that the firmware update process is not vulnerable to time-of-check vs time-of-use attacks. |  | ✓ | ✓ | 4.0 |\n| **C.21** | Verify the device uses code signing and validates firmware upgrade files before installing. |  | ✓ | ✓ | 4.0 |\n| **C.22** | Verify that the device cannot be downgraded to old versions (anti-rollback) of valid firmware. |  | ✓ | ✓ | 4.0 |\n| **C.23** | Verify usage of cryptographically secure pseudo-random number generator on embedded device (e.g., using chip-provided random number generators). |  | ✓ | ✓ | 4.0 |\n| **C.24** | Verify that firmware can perform automatic firmware updates upon a predefined schedule. |  | ✓ | ✓ | 4.0 |\n| **C.25** | Verify that the device wipes firmware and sensitive data upon detection of tampering or receipt of invalid message. |  |  | ✓ | 4.0 |\n| **C.26** | Verify that only micro controllers that support disabling debugging interfaces (e.g. JTAG, SWD) are used. |  |  | ✓ | 4.0 |\n| **C.27** | Verify that only micro controllers that provide substantial protection from de-capping and side channel attacks are used. |  |  | ✓ | 4.0 |\n| **C.28** | Verify that sensitive traces are not exposed to outer layers of the printed circuit board. |  |  | ✓ | 4.0 |\n| **C.29** | Verify that inter-chip communication is encrypted (e.g. Main board to daughter board communication). |  |  | ✓ | 4.0 |\n| **C.30** | Verify the device uses code signing and validates code before execution. |  |  | ✓ | 4.0 |\n| **C.31** | Verify that sensitive information maintained in memory is overwritten with zeros as soon as it is no longer required. |  |  | ✓ | 4.0 |\n| **C.32** | Verify that the firmware apps utilize kernel containers for isolation between apps. |  |  | ✓ | 4.0 |\n| **C.33** | Verify that secure compiler flags such as -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap are configured for firmware builds. |  |  | ✓ | 4.0 |\n| **C.34** | Verify that micro controllers are configured with code protection (if applicable). |  |  | ✓ | 4.0 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:50.546560"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x01-Frontispiece.md", "content": "# Frontispicio\n\n## Acerca del Estándar\n\nEl Estándar de Verificación de Seguridad en Aplicaciones (ASVS; por sus siglas en inglés) es una lista de requisitos o pruebas de seguridad en aplicaciones que puede ser utilizado por arquitectos, desarrolladores, probadores, profesionales de la seguridad, proveedores de herramientas y consumidores para definir, construir, probar y verificar aplicaciones seguras.\n\n## Derechos de Autor y Licencia\n\nVersion 4.0.3, Octubre 2021\n\n![license](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. Este documento se publica bajo el [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/). Para cualquier reutilización o distribución, debe dejar claro a otros los términos de licencia de este trabajo.\n\n## Líderes de Proyecto\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Principales Colaboradores\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Otros Colaboradores y Revisores\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\nSi falta un crédito en la lista de créditos de la 4.0.3 que aparece arriba, registre un ticket en GitHub para que se le reconozca en futuras actualizaciones.\n\nEl Estándar de Verificación de Seguridad de Aplicaciones está construido sobre los hombros de aquellos que participaron desde el ASVS 1.0 en 2008 hasta el 3.0 en 2016. Gran parte de la estructura y de los elementos de verificación que todavía están en el ASVS hoy fueron escritos originalmente por Mike Boberski, Jeff Williams y Dave Wichers, pero hay muchos más contribuyentes. Gracias a todos los que han participado anteriormente. Para obtener una lista completa de todos aquellos que han contribuido a versiones anteriores, por favor consulte cada versión anterior.\n", "timestamp": "2025-10-24T11:39:50.930892"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x02-Preface.md", "content": "# Prefacio\n\nBienvenido al Estándar de Verificación de Seguridad en Aplicaciones (ASVS; por sus siglas en inglés) versión 4.0. El ASVS es un esfuerzo impulsado por la comunidad para establecer un marco de requisitos y controles de seguridad que se centran en definir los controles de seguridad funcionales y no funcionales requeridos al diseñar, desarrollar y probar aplicaciones web y servicios web modernos.\n\nLa versión 4.0.3 es el tercer parche menor de la v4.0 destinado a corregir errores ortográficos y hacer que los requisitos sean más claros sin realizar cambios importantes como requisitos que cambien materialmente, fortalecer los requisitos o agregar requisitos. Sin embargo, es posible que algunos requisitos se hayan debilitado ligeramente cuando nos pareció apropiado y se han eliminado algunos requisitos completamente redundantes (pero sin volver a numerarlos).\n\nASVS v4.0 es la culminación del esfuerzo de la comunidad y los comentarios de lecciones aprendidas en la industria durante la última década. Hemos intentado facilitar la adopción de ASVS para una variedad de diferentes casos de uso a lo largo de cualquier ciclo de vida de desarrollo de software seguro.\n\nLo más probable es que nunca haya un acuerdo del 100% sobre los contenidos de cualquier estándar de aplicación web, incluido el ASVS. El análisis de riesgo es siempre subjetivo hasta cierto punto, lo que crea un desafío cuando se intenta generalizar en un estándar único para todos. Sin embargo, esperamos que las últimas actualizaciones realizadas en esta versión sean un paso en la dirección correcta y mejoren los conceptos introducidos en este estándar crítico de la industria.\n\n## Novedades en la Versión 4.0\n\nEl cambio más significativo en esta versión es la adopción de las Pautas de identidad digital NIST 800-63-3, que introducen controles de autenticación avanzados, modernos y basados en evidencia. Aunque esperamos cierto retroceso en la alineación con un estándar de autenticación avanzado, creemos que es esencial que los estándares estén alineados, principalmente cuando otro estándar de seguridad de aplicaciones bien considerado se basa en evidencia.\n\nLos estándares de seguridad de la información deben tratar de minimizar el número de requisitos únicos, de modo que las organizaciones que cumplen los requisitos no tengan que decidir sobre controles similares o incompatibles. El OWASP Top 10 2017 y ahora el Estándar De Verificación De Seguridad De Aplicaciones, se han alineado con NIST 800-63 para la autenticación y administración de sesiones. Alentamos a otros organismos que establecen estándares a trabajar con nosotros, NIST y otros para llegar a un conjunto generalmente aceptado de controles de seguridad de aplicaciones para maximizar la seguridad y minimizar los costos de cumplimiento.\n\nASVS 4.0 ha sido completamente renumerado de principio a fin. El nuevo esquema de numeración nos permitió eliminar brechas de capítulos desaparecidos hace mucho tiempo y permitirnos segmentar capítulos más largos para minimizar la cantidad de controles que un desarrollador o equipo debe cumplir. Por ejemplo, si una aplicación no utiliza JWT, la sección completa sobre JWT en la gestión de sesiones no es aplicable.\n\nLo nuevo en la versión 4.0 es un mapeo completo hacia la enumeración de debilidades comunes (CWE; por sus siglas en inglés), una de las solicitudes de mejora más pedida durante la última década. El mapeo CWE permite a los fabricantes de herramientas y aquellos que usan software de administración de vulnerabilidades comparar los resultados de otras herramientas y versiones anteriores de ASVS con 4.0 y posteriores. Para dejar espacio para la entrada CWE, hemos tenido que retirar la columna \"Desde\", que ahora que cambiamos la numeración por completo, tiene menos sentido que en versiones anteriores de ASVS. No todos los elementos del ASVS tienen un CWE asociado y, dado que CWE tiene una gran cantidad de duplicaciones, hemos intentado asociar el más utilizado en lugar de necesariamente el más cercano. Los controles de verificación no siempre se pueden asignar a debilidades equivalentes. Agradecemos la discusión en curso con la comunidad de CWE y el campo de la seguridad de la información en general sobre cómo cerrar esta brecha.\n\nHemos trabajado para cumplir y superar de manera integral los requisitos del OWASP Top 10 2017 y del OWASP Proactive Controls 2018. Dado que el OWASP Top 10 2017 es el mínimo indispensable para evitar negligencias, deliberadamente hemos hecho todo excepto los controles nivel 1 de los requisitos del Top 10, lo que facilita a los adoptadores del OWASP Top 10 avanzar a un estándar de seguridad real.\n\nQuisimos asegurarnos de que el ASVS 4.0 Nivel 1 sea un superconjunto completo de PCI DSS 3.2.1 Secciones 6.5, para el diseño de aplicaciones, codificación, pruebas, revisiones de código seguro y pruebas de penetración. Esto requería cubrir el desbordamiento del búfer y las operaciones de memoria inseguras en V5, y los indicadores de compilación relacionados con la memoria insegura en V14, además de los requisitos de verificación de servicios web y aplicaciones líderes en la industria.\n\nCambiamos los controles ASVS monolíticos y solo del lado del servidor, a los nuevos controles de seguridad para todas las aplicaciones y API modernas. En los días de la programación funcional, serverless API, dispositivos móviles, nube, contenedores, CI/CD y DevSecOps, federación y más, no podemos seguir ignorando la arquitectura de aplicaciones moderna. Las aplicaciones modernas están diseñadas de manera muy diferente a las creadas cuando se lanzó el ASVS original en 2009. El ASVS siempre debe mirar hacia el futuro para poder brindar buenos consejos a nuestra audiencia principal: los desarrolladores. Hemos aclarado o eliminado cualquier requisito que suponga que las aplicaciones se ejecutan en sistemas propiedad de una sola organización.\n\nDebido al tamaño del ASVS 4.0, así como a nuestro deseo de convertirlo en la línea base, para todos los demás esfuerzos de ASVS, hemos retirado el capítulo de \"Móviles\" en apoyo al Estándar de Verificación de Seguridad de Aplicaciones Móviles (MASVS; por sus siglas en inglés). El anexo de IoT (Internet de las cosas) se sumará a un futuro “IoT ASVS” dentro del Proyecto de Internet de las Cosas de OWASP. Hemos incluido una vista previa de IoT ASVS en el Apéndice C. Agradecemos tanto al Equipo de OWASP Mobile, como al Equipo de Proyecto de IoT de OWASP por su apoyo al ASVS, y esperamos trabajar con ellos a futuro para proporcionar estándares complementarios.\n\nPor último, hemos eliminado y retirado controles menos impactantes. Con el tiempo, ASVS comenzó a ser un conjunto completo de controles, pero no todos los controles son igual de importantes para producir software seguro. Este esfuerzo por eliminar los elementos de bajo impacto podría ir más allá. En una futura edición del ASVS, el Sistema de Puntuación de Debilidad Común (CWSS; por sus siglas en inglés) ayudará a priorizar aún más los controles que son realmente importantes y los que deberían retirarse.\n\nA partir de la versión 4.0, ASVS se centrará únicamente en ser el estándar de servicios y aplicaciones web líder, cubriendo la arquitectura de aplicaciones tradicional y moderna, y las prácticas de seguridad ágiles y la cultura DevSecOps.\n", "timestamp": "2025-10-24T11:39:51.045434"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x03-Using-ASVS.md", "content": "# Usando ASVS\n\nASVS tiene dos objetivos principales:\n\n* Ayudar a las organizaciones a desarrollar y mantener aplicaciones seguras.\n* Permitir que los proveedores de servicios de seguridad, los proveedores de herramientas de seguridad y los consumidores alineen sus requisitos y ofertas.\n\n## Niveles de ASVS\n\nEl estándar de verificación de seguridad de aplicaciones define tres niveles de verificación de seguridad, con cada nivel aumentando en profundidad.\n\n* ASVS Nivel 1 es para bajos niveles de garantía, y es completamente comprobable con pentesting.\n* ASVS Nivel 2 es para aplicaciones que contienen datos confidenciales, que requiere protección y es el nivel recomendado para la mayoría de las aplicaciones.\n* ASVS Nivel 3 es para las aplicaciones más críticas - aplicaciones que realizan transacciones de alto valor, contienen datos médicos sensibles, o cualquier aplicación que requiere el más alto nivel de confianza.\n\nCada nivel ASVS contiene una lista de requisitos de seguridad. Cada uno de estos requisitos también se puede asignar a características y capacidades específicas de seguridad que los desarrolladores deben integrar en el software.\n\n![Niveles de ASVS](../images/asvs_40_levels.png \"Niveles de ASVS\")\n\nFigura 1 - Niveles de OWASP ASVS 4.0\n\nEl nivel 1 (L1) es el único nivel que es completamente comprobable de penetración usando humanos. Todos los demás requieren acceso a la documentación, el código fuente, la configuración y las personas involucradas en el proceso de desarrollo. Sin embargo, incluso si L1 permite que se realicen pruebas de \"caja negra\" (sin documentación ni fuente), no es una actividad de garantía eficaz y debe desalentarse activamente. Los atacantes malintencionados tienen mucho tiempo, la mayoría de las pruebas de penetración han terminado en un par de semanas. Los defensores necesitan crear controles de seguridad, proteger, encontrar y resolver todas las debilidades, y detectar y responder a actores malintencionados en un tiempo razonable. Los actores malintencionados tienen tiempo esencialmente infinito y sólo necesitan una defensa porosa, una sola debilidad, o falta de detección para tener éxito. Las pruebas de caja negra, que a menudo se realizan al final del desarrollo, se realizan rápidamente, y son completamente incapaces de hacer frente a esa asimetría.\n\nDurante los últimos 30+ años, las pruebas de cajas negras han demostrado una y otra vez perderse problemas críticos de seguridad que llevaron directamente a brechas cada vez más masivas. Recomendamos encarecidamente el uso de una amplia gama de garantías y verificación de seguridad, incluida la sustitución de pruebas de penetración por pruebas de penetración dirigidas por código fuente (híbrido) en el nivel 1, con acceso completo a los desarrolladores y documentación durante todo el proceso de desarrollo. Los reguladores financieros no toleran auditorías financieras externas sin acceso a los libros, transacciones de muestra o a las personas que realizan los controles. La industria y los gobiernos deben exigir el mismo estándar de transparencia en el campo de la ingeniería de software.\n\nRecomendamos encarecidamente el uso de herramientas de seguridad dentro del proceso de desarrollo. Las herramientas DAST y SAST se pueden utilizar continuamente por el canal de construcción para detectar problemas de seguridad fáciles de encontrar que nunca deben estar presentes.\n\nLas herramientas automatizadas y los escaneos en línea sólo pueden completar casi la mitad del ASVS sin asistencia humana. Si se requiere una automatización de pruebas completa para cada compilación, se usa una combinación de pruebas de unidad personalizadas e integración, junto con escaneos en línea iniciados por la compilación. Los defectos de lógica empresarial y las pruebas de control de acceso solo son posibles mediante la asistencia humana. Estos deben convertirse en pruebas unitarias y de integración.\n\n## Cómo usar este estándar\n\nUna de las mejores maneras de utilizar el estándar de verificación de seguridad en aplicaciones es usarlo como un plano-guía para crear una lista de comprobación de codificación segura específica para su aplicación, plataforma u organización. Adaptar el ASVS a sus casos de uso aumentará el enfoque en los requisitos de seguridad que son más importantes para sus proyectos y entornos.\n\n### Nivel 1 (L1) - Primeros pasos, vista automatizada o completa de la cartera\n\nUna aplicación alcanza ASVS Nivel 1 si logra defenderse contra vulnerabilidades de seguridad de aplicaciones que son fáciles de descubrir, e incluido el Top 10 de OWASP y otras listas de comprobación similares.\n\nEl nivel 1 es el mínimo por el que todas las aplicaciones deben esforzarse. También es útil como primer paso en un esfuerzo multifáses o cuando las aplicaciones no almacenan ni manejan datos confidenciales y, por lo tanto, no necesitan los controles más rigurosos de Nivel 2 o 3. Los controles de nivel 1 se pueden comprobar automáticamente mediante herramientas o simplemente manualmente sin acceso al código fuente. Consideramos el Nivel 1 el mínimo requerido para todas las aplicaciones.\n\nLas amenazas a la aplicación probablemente serán de atacantes que utilizan técnicas simples y de bajo esfuerzo para identificar vulnerabilidades fáciles de encontrar y fáciles de explotar. Esto contrasta con un atacante determinado que gastará energía enfocada para apuntar específicamente a la aplicación. Si los datos procesados por su aplicación tienen un alto valor, rara vez querrá detenerse en una revisión de Nivel 1.\n\n### Nivel 2 (L2) - Para la mayoría de las aplicaciones\n\nUna aplicación alcanza ASVS Nivel 2 (o Estándar) si se defiende adecuadamente contra la mayoría de los riesgos asociados con el software hoy en día.\n\nEl nivel 2 garantiza que los controles de seguridad estén en su lugar, sean eficaces y se utilicen dentro de la aplicación. El nivel 2 suele ser adecuado para aplicaciones que manejan importantes transacciones de negocio-a-negocio, incluidas aquellas que procesan información de atención médica, y/o implementan funciones críticas para el negocio, o procesan otros activos sensibles, o industrias donde la integridad es una faceta crítica para proteger su negocio, como la industria de juegos para frustrar a los tramposos y game hacks.\n\nLas amenazas a las aplicaciones de nivel 2 suelen ser atacantes calificados y motivados que se centran en objetivos específicos utilizando herramientas y técnicas, que son altamente practicadas y eficaces para descubrir y explotar las debilidades dentro de las aplicaciones.\n\n### Nivel 3 (L3) - Alto valor, alta garantía o alta seguridad\n\nASVS Nivel 3 es el nivel más alto de verificación dentro del ASVS. Este nivel se reserva normalmente para aplicaciones que requieren niveles significativos de verificación de seguridad, como los que se pueden encontrar dentro de áreas de militar, salud y seguridad, infraestructura crítica, etc.\n\nLas organizaciones pueden requerir ASVS Nivel 3 para aplicaciones que realizan funciones críticas, donde el error podría afectar significativamente las operaciones de la organización, e incluso su supervivencia. A continuación se proporcionan instrucciones de ejemplo sobre la aplicación del nivel 3 de ASVS. Una aplicación alcanza ASVS Nivel 3 (o Avanzado) si se defiende adecuadamente contra vulnerabilidades avanzadas de seguridad de aplicaciones y también demuestra principios de buen diseño de seguridad.\n\nUna aplicación en ASVS Nivel 3 requiere un análisis más detallado de la arquitectura, la codificación y las pruebas que todos los demás niveles. Una aplicación segura se modulariza de una manera significativa (para facilitar la resiliencia, la escalabilidad y, sobre todo, las capas de seguridad), y cada módulo (separado por conexión de red y/o instancia física) se encarga de sus propias responsabilidades de seguridad (defensa en profundidad), que deben documentarse correctamente. Las responsabilidades incluyen controles para garantizar la confidencialidad (por ejemplo, cifrado), integridad (por ejemplo, transacciones, validación de entradas), disponibilidad (por ejemplo, manejo correcto de la carga), autenticación (incluidos entre sistemas), autorización y auditoría (registros de log).\n\n## Aplicando ASVS en la Práctica\n\nDiferentes amenazas tienen diferentes motivaciones. Algunas industrias tienen activos únicos de información y tecnología y requisitos de cumplimiento normativo específicos del dominio.\n\nSe recomienda encarecidamente a las organizaciones que examinen profundamente sus características de riesgo únicas en función de la naturaleza de su negocio, y sobre la base de que los requisitos de riesgo y de negocio determinan el nivel adecuado de ASVS.\n\n## Cómo Hacer Referencia a los Requisitos de ASVS\n\nCada requisito tiene un identificador en el formato `<chapter>.<section>.<requirement>` donde cada elemento es un número, por ejemplo: `1.11.3`.\n- El elemento `<chapter>` corresponde al capítulo del que proviene el requisito, por ejemplo: todos los requisitos de `1.#.#` son del capítulo de `Arquitectura`.\n- El elemento `<section>` corresponde a la sección dentro de ese capítulo donde aparece el requisito, por ejemplo: todos los requisitos de `1.11.#` están en la sección `Arquitectura de la Lógica del Negocio`, del capítulo de `Arquitectura`.\n- El elemento `<requirement>` identifica el requisito específico dentro del capítulo y la sección, por ejemplo: `1.11.3` que a partir de la versión 4.0.3 del presente estándar es:\n\n> Compruebe que todos los flujos de lógica de negocio de alto valor, incluida la autenticación, la administración de sesiones y el control de acceso, sean seguros para subprocesos y resistentes a las condiciones de tiempo de comprobación y tiempo de uso.\n\nLos identificadores pueden cambiar entre las versiones de la norma, por lo que es preferible que otros documentos, informes o herramientas utilicen el formato: `v<version>-<chapter>.<section>.<requirement>`, donde: 'versión' es la etiqueta de la versión ASVS. Por ejemplo: `v4.0.3-1.11.3` se entendería que significa específicamente el 3er requisito en la sección \"Arquitectura de la Lógica del Negocio\" del capítulo \"Arquitectura\" de la versión 4.0.3. (Esto podría resumirse como `v<version>-<requirement_identifier>`)\n\nNota: La `v` que precede a la parte de la versión debe estar en minúsculas.\n\nSi se utilizan identificadores sin incluir el `v<version>`, se debe suponer que hacen referencia al contenido más reciente del estándar de verificación de seguridad en aplicaciones. Obviamente, a medida que el estándar crece y cambia esto se vuelve problemático, por lo que los escritores o desarrolladores deben incluir el elemento de versión.\n\nLas listas de requisitos de ASVS están disponibles en CSV, JSON y otros formatos que pueden ser útiles para el uso de referencia o mediante programación.\n", "timestamp": "2025-10-24T11:39:51.142929"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x04-Assessment_and_Certification.md", "content": "# Evaluación y Certificación\n\n## Postura de OWASP sobre Certificaciones ASVS y Marcas de Confianza\n\nOWASP, como una organización neutral para el proveedor sin fines de lucro, actualmente no certifica ningún proveedor, verificador o software.\n\nTodas esas afirmaciones de garantía, marcas de confianza o certificaciones no son examinadas, registradas o certificadas oficialmente por OWASP, por lo que una organización que se base en esa opinión debe tener cuidado con la confianza depositada en cualquier tercero o marca de confianza que reclame la certificación ASVS.\n\nEsto no debe impedir que las organizaciones ofrezcan tales servicios de garantía, siempre y cuando no reclamen la certificación oficial de OWASP.\n\n## Orientación para las Organizaciones Certificadoras\n\nASVS se puede utilizar como una verificación de libro abierto de la aplicación, incluido el acceso abierto y sin restricciones a recursos clave como arquitectos, desarrolladores, documentación del proyecto, código fuente, acceso autenticado a sistemas de prueba (incluido el acceso a una o más cuentas en cada rol), especialmente para verificaciones de nivel L2 y L3.\n\nHistóricamente, las pruebas de penetración y las revisiones de código seguro han incluido cuestiones \"por excepción\", es decir, las pruebas fallidas aparecen en el informe final. Una organización certificadora debe incluir en cualquier informe el alcance de la verificación (especialmente si un componente clave está fuera del ámbito, como la autenticación SSO), un resumen de los resultados de la verificación, incluidas las pruebas pasadas y erróneas, con indicaciones claras de cómo resolver las pruebas con errores.\n\nCiertos requisitos de verificación pueden no ser aplicables al software bajo prueba. Por ejemplo, si proporciona una API de capa de servicio stateless sin una implementación de cliente a sus consumidores, muchos de los requisitos de V3 Administración de Sesiones no son directamente aplicables. En tales casos, una organización certificadora todavía puede reclamar el cumplimiento completo de ASVS, pero debe indicar claramente en cualquier informe una razón para la inaplicabilidad de dichos requisitos de verificación excluidos.\n\nMantener documentos de trabajo detallados, capturas de pantalla o películas, guiones para explotar de forma fiable y repetidamente un problema, y registros electrónicos de pruebas, como interceptar registros de proxy y notas asociadas, como una lista de limpieza, se considera práctica estándar de la industria y puede ser realmente útil como pruebas de los hallazgos para los desarrolladores más dudosos. No basta con simplemente ejecutar una herramienta e informar sobre los errores; esto no proporciona (en absoluto) pruebas suficientes de que todas las cuestiones a nivel de certificación han sido probadas y probadas a fondo. En caso de controversia, debe haber pruebas de garantía suficientes para demostrar que todos y cada uno de los requisitos verificados han sido probados.\n\n### Método de Pruebas\n\nLas organizaciones de certificación son libres de elegir los métodos de prueba adecuados, pero deben indicarlas en un informe.\n\nDependiendo de la aplicación sometida a prueba y del requisito de verificación, se pueden utilizar diferentes métodos de prueba para obtener una confianza similar en los resultados. Por ejemplo, la validación de la eficacia de los mecanismos de verificación de entrada de una aplicación puede analizarse con una prueba de penetración manual o mediante análisis de código fuente.\n\n#### El Rol de las Herramientas Automatizadas de Pruebas de Seguridad\n\nSe recomienda el uso de herramientas de pruebas de penetración automatizadas para proporcionar la mayor cobertura posible.\n\nNo es posible completar en su totalidad la verificación de ASVS utilizando solo herramientas de pruebas de penetración automatizadas. Si bien una gran mayoría de los requisitos en N1 se pueden realizar mediante pruebas automatizadas, la mayoría general de los requisitos no son susceptibles a las pruebas de penetración automatizadas.\n\nTenga en cuenta que las líneas entre las pruebas automatizadas y manuales se han difuminado a medida que la industria de seguridad de aplicaciones madura. Las herramientas automatizadas a menudo son ajustadas manualmente por expertos y los probadores manuales a menudo aprovechan una amplia variedad de herramientas automatizadas.\n\n#### El rol de las Pruebas de Penetración\n\nEn la versión 4.0, decidimos hacer L1 completamente verificable con pruebas de penetración sin acceso al código fuente, documentación o desarrolladores. Dos elementos de logging, que están obligados a cumplir con OWASP Top 10 2017 A10, requerirán entrevistas, capturas de pantalla u otra captura de evidencia, al igual que lo hacen en el Top 10 2017 de OWASP. Sin embargo, las pruebas sin acceso a la información necesaria no son un método ideal de verificación de seguridad, ya que pierde la posibilidad de revisar el origen, identificar las amenazas y los controles que faltan, y realizar una prueba mucho más exhaustiva en un plazo más corto.\n\nSiempre que sea posible, se requiere acceso a los desarrolladores, documentación, código y acceso a una aplicación de prueba con datos que no sean de producción al realizar una evaluación L2 o L3. Las pruebas de penetración realizadas a estos niveles requieren este nivel de acceso, que llamamos \"revisiones híbridas\" o \"pruebas de penetración híbrida\".\n\n## Otros usos para ASVS\n\nAdemás de utilizarse para evaluar la seguridad de una aplicación, hemos identificado una serie de otros usos potenciales para ASVS.\n\n### Como una Guía Detallada de la Arquitectura de Seguridad\n\nUno de los usos más comunes para el estándar de verificación de seguridad en aplicaciones es como un recurso para los arquitectos de seguridad. A la arquitectura de seguridad empresarial aplicada de Sherwood (SABSA) le falta una gran cantidad de información que es necesaria para completar una revisión exhaustiva de la arquitectura de seguridad en aplicaciones. ASVS se puede utilizar para llenar esas lagunas al permitir que los arquitectos de seguridad elijan mejores controles para problemas comunes, como patrones de protección de datos y estrategias de validación de entradas.\n\n### Como un Reemplazo de Listas de Verificación de Codificación Segura Listas para Usar\n\nMuchas organizaciones pueden beneficiarse de la adopción de ASVS, eligiendo uno de los tres niveles, o bifurcando ASVS y cambiando lo que se requiere para cada nivel de riesgo de aplicación de una manera específica del dominio. Animamos a este tipo de bifurcación siempre y cuando se mantenga la trazabilidad, de modo que si una aplicación ha pasado el requisito 4.1, esto significa lo mismo para las copias bifurcadas que el estándar a medida que evoluciona.\n\n### Como una Guía para Pruebas Automatizadas de Unidad e Integración\n\nEl ASVS está diseñado para ser altamente comprobable, con la única excepción de los requisitos de código arquitectónico y malicioso. Mediante la creación de pruebas de unidad e integración que prueban casos de fuzz y abuso específicos y relevantes, la aplicación se vuelve casi autocomprobación con todas y cada una de las compilaciones. Por ejemplo, se pueden crear pruebas adicionales para el conjunto de pruebas para un controlador de inicio de sesión, probando el parámetro username para los nombres de usuario predeterminados comunes, la enumeración de la cuenta, el forzamiento bruto, la inyección LDAP y SQL, y XSS. Del mismo modo, una prueba en el parámetro de contraseña debe incluir contraseñas comunes, longitud de contraseña, inyección de bytes nulos, eliminación del parámetro, XSS y más.\n\n### Para la Formación en Desarrollo Seguro\n\nASVS también se puede utilizar para definir las características del software seguro. Muchos cursos de \"codificación segura\" son simplemente cursos de hacking ético con un ligero barniz de tips de codificación. Esto no necesariamente ayuda a los desarrolladores a escribir código más seguro. En su lugar, los cursos de desarrollo seguro pueden utilizar el ASVS con un fuerte enfoque en los controles proactivos que provee, en lugar de las 10 cosas negativas que no se deben hacer.\n\n### Como un Conductor para la Seguridad de Aplicaciones Ágiles\n\nASVS se puede utilizar en un proceso de desarrollo ágil como framework para definir tareas específicas que el equipo debe implementar para tener un producto seguro. Un enfoque podría ser: A partir del nivel 1, compruebe la aplicación o el sistema específico según los requisitos de ASVS para el nivel especificado, busque qué controles faltan y genere tickets/tareas específicas en el \"backlog\". Esto ayuda a priorizar tareas específicas (o refinamiento) y hace que la seguridad sea visible en el proceso ágil. Esto también se puede utilizar para priorizar las tareas de auditoría y revisión en la organización, donde un requisito específico de ASVS puede ser un impulsor para la revisión, refactorización o auditoría para un miembro específico del equipo y visible como \"deuda\" en el backlog que debe ser hecho eventualmente.\n\n### Como Marco de Trabajo para Orientar la Adquisición de Software Seguro\n\nASVS es un gran marco para ayudar con la adquisición segura de software o la adquisición de servicios de desarrollo personalizados. El comprador puede simplemente establecer un requisito de que el software que desea adquirir debe desarrollarse en el nivel X de ASVS, y solicitar que el vendedor demuestre que el software cumple con el nivel X de ASVS. Esto funciona bien cuando se combina con el anexo OWASP del contrato de software seguro.\n", "timestamp": "2025-10-24T11:39:51.310176"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x10-V1-Architecture.md", "content": "# V1 Arquitectura, Diseño y Modelado de Amenazas\n\n## Objetivo de Control\n\nLa arquitectura de seguridad casi se ha convertido en un arte perdido en muchas organizaciones. Los días del arquitecto empresarial han pasado en la era de DevSecOps. El campo de la seguridad de las aplicaciones debe ponerse al día y adoptar principios de seguridad ágiles, al tiempo que reintroduce los principios de arquitectura de seguridad líderes a los profesionales del software. La arquitectura no es una implementación, sino una forma de pensar sobre un problema que tiene potencialmente muchas respuestas diferentes, y no solo una respuesta \"correcta\". Con demasiada frecuencia, la seguridad se ve como inflexible y exigente que los desarrolladores corrijan el código de una manera particular, cuando los desarrolladores pueden conocer una manera mucho mejor de resolver el problema. No hay una solución única y sencilla para la arquitectura, y pretender lo contrario es un flaco favor al campo de la ingeniería de software.\n\nEs probable que una implementación específica de una aplicación web se revise continuamente a lo largo de su vida útil, pero es probable que la arquitectura general rara vez cambie, pero evoluciona lentamente. La arquitectura de seguridad es idéntica: necesitamos autenticación hoy, necesitaremos autenticación mañana y la necesitaremos dentro de cinco años. Si tomamos decisiones acertadas hoy en día, podemos ahorrar mucho esfuerzo, tiempo y dinero si seleccionamos y reutilizamos soluciones que cumplen con la arquitectura. Por ejemplo, hace una década, la autenticación multifactor rara vez se implementaba.\n\nSi los desarrolladores hubieran invertido en un único modelo de proveedor de identidad seguro, como la identidad federada SAML, el proveedor de identidades podría actualizarse para incorporar nuevos requisitos, como el cumplimiento de NIST 800-63, sin cambiar las interfaces de la aplicación original. Si muchas aplicaciones compartían la misma arquitectura de seguridad y, por lo tanto, ese mismo componente, todas se benefician de esta actualización a la vez. Sin embargo, SAML no siempre permanecerá como la mejor o más adecuada solución de autenticación: es posible que deba intercambiarse para otras soluciones a medida que cambian los requisitos. Cambios como este son complicados y costosos como para requerir una reescritura completa, o totalmente imposible sin arquitectura de seguridad.\n\nEn este capítulo, el ASVS cubre los aspectos principales de cualquier arquitectura de seguridad sólida: disponibilidad, confidencialidad, integridad del procesamiento, no repudio y privacidad. Cada uno de estos principios de seguridad debe estar integrado y ser innato para todas las aplicaciones. Es fundamental \"desplazar a la izquierda\", comenzando con la habilitación del desarrollador con listas de verificación de codificación seguras, tutoría y capacitación, codificación y pruebas, creación, implementación, configuración y operaciones, y terminando con pruebas independientes de seguimiento para asegurar que todos los controles de seguridad están presentes y funcionales. El último paso solía ser todo lo que hacíamos como industria, pero ya no es suficiente cuando los desarrolladores insertan código en producción decenas o cientos de veces al día. Los profesionales de la seguridad de las aplicaciones deben mantenerse al día con técnicas ágiles, lo que significa adoptar herramientas de desarrollo, aprender a codificar, y trabajar con desarrolladores en lugar de criticar el proyecto meses después de que todos los demás siguieron adelante.\n\n## V1.1 Ciclo de Vida de Desarrollo de Software Seguro\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | Verifique el uso de un ciclo de vida de desarrollo de software seguro que aborde la seguridad en todas las etapas del desarrollo. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Verifique el uso del modelado de amenazas para cada cambio de diseño o planificación de sprint para identificar amenazas, planificar contramedidas, facilitar respuestas de riesgo adecuadas y guiar las pruebas de seguridad. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Verifique que todas las historias y características de usuario contienen restricciones de seguridad funcionales, como por ejemplo: \"Como usuario, debería poder ver y editar mi perfil. No debería ser capaz de ver o editar el perfil de nadie más\" | | ✓ | ✓ | 1110 |\n| **1.1.4** | Verifique la documentación y la justificación de todos los límites de confianza, componentes y flujos de datos significativos de la aplicación. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Verifique la definición y el análisis de seguridad de la arquitectura de alto nivel de la aplicación y todos los servicios remotos conectados. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Verifique la implementación de controles de seguridad centralizados, simples (economía del diseño), comprobados, seguros y reutilizables para evitar controles duplicados, faltantes, ineficaces o inseguros. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Verifique la disponibilidad de una lista de comprobación de codificación segura, requisitos de seguridad, directriz o directiva para todos los desarrolladores y evaluadores. | | ✓ | ✓ | 637 |\n\n## V1.2 Arquitectura de Autenticación\n\nAl diseñar la autenticación, no importa si tiene una autenticación multifactor habilitada para hardware fuerte si un atacante puede restablecer una cuenta llamando a un centro de llamadas y respondiendo a preguntas conocidas. Al probar la identidad, todas las vías de autenticación deben tener la misma fuerza.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | Verifique el uso de cuentas de sistema operativo únicas o especiales con privilegios bajos para todos los componentes, servicios y servidores de la aplicación. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Verifique que las comunicaciones entre los componentes de la aplicación, incluidas las API, el middleware y las capas de datos, se autentican. Los componentes deben tener los mínimos privilegios necesarios. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Verifique que la aplicación utiliza un único mecanismo de autenticación comprobado que se sabe que es seguro, se puede ampliar para incluir una autenticación segura y tiene suficiente logging y supervisión para detectar abuso de cuenta o brechas. | | ✓ | ✓ | 306 |\n| **1.2.4** | Verifique que todas las vías de autenticación y las API de administración de identidades implementan una fortaleza coherente del control de seguridad de autenticación, de modo que no haya alternativas más débiles por el riesgo de la aplicación. | | ✓ | ✓ | 306 |\n\n## V1.3 Arquitectura de Gestión de Sesiones\n\nEste es un marcador de posición para los requisitos arquitectónicos futuros.\n\n## V1.4 Arquitectura de Control de Acceso\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | Verifique que los puntos de cumplimiento de confianza, tales como puertas de enlace de control de acceso, servidores y funciones serverless, exijan controles de acceso. Nunca aplique controles de acceso en el cliente. | | ✓ | ✓ | 602 |\n| **1.4.2** | [ELIMINADO, NO ACCIONABLE] | | | | |\n| **1.4.3** | [ELIMINADO, DUPLICADO CON 4.1.3] | | | | |\n| **1.4.4** | Verifique que la aplicación utilice un mecanismo de control de acceso único y bien comprobado para acceder a datos y recursos protegidos. Todas las solicitudes deben pasar por este único mecanismo para evitar copiar y pegar o rutas alternativas inseguras. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Verifique que se utiliza el control de acceso basado en atributos o entidades mediante el cual el código comprueba la autorización del usuario para un elemento de característica o datos en lugar de solo su rol. Los permisos deben asignarse mediante roles. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Arquitectura de Entradas y Salidas\n\nEn 4.0, nos hemos alejado del término \"server-side\" como un término límite de confianza cargado. El límite de confianza sigue siendo relativo a - tomar decisiones sobre navegadores que no son de confianza o dispositivos cliente que son \"bypassable\". Sin embargo, en las implementaciones arquitectónicas convencionales de hoy en día, el punto de aplicación de la confianza ha cambiado drásticamente. Por lo tanto, cuando el término \"trusted service layer\" se utiliza en el ASVS, nos referimos a cualquier punto de aplicación de confianza, independientemente de la ubicación, como un microservicio, serverless API, server-side, una API de confianza en un dispositivo cliente que tiene secure boot, partner o API externas, etc.\n\nEl término \"untrusted client\" aquí se refiere a las tecnologías del lado del cliente que representan la capa de presentación, comúnmente referida como tecnologías 'front-end'. El término \"serialization\" aquí no sólo se refiere a enviar datos a través de las comunicaciones, como una matriz de valores o tomar y leer una estructura JSON, sino también pasar objetos complejos que pueden contener lógica.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | Verifique que los requisitos de entrada y salida definan claramente cómo manejar y procesar datos en función del tipo, contenido y las leyes, regulaciones y otras leyes aplicables, reglamentos y otras normas de cumplimiento de políticas. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Verifique que no se usa serialización al comunicarse con clientes que no son de confianza. Si esto no es posible, asegúrese de que se apliquen controles de integridad adecuados (y posiblemente cifrado si se envían datos confidenciales) para evitar ataques de deserialización, incluida la inyección de objetos. | | ✓ | ✓ | 502 |\n| **1.5.3** | Verifique que la validación de datos de entrada (input) se aplica en una capa de servicio de confianza. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Verifique que la codificación de salida (output encode) se produce cerca o en el intérprete para el que está destinada. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Arquitectura Criptográfica\n\nLas aplicaciones deben diseñarse con una arquitectura criptográfica sólida para proteger los activos de datos según su clasificación. Cifrar todo es un desperdicio, no cifrar nada es una negligencia legal. Se debe lograr un equilibrio, generalmente durante el diseño arquitectónico o de alto nivel, los \"sprints\" de diseño o los \"spikes\" arquitectónicos. Diseñar criptografía sobre la marcha o modernizarla inevitablemente costará mucho más implementar de forma segura que simplemente construirla desde el principio.\n\nLos requisitos arquitectónicos son intrínsecos a toda la base de código y, por lo tanto, son difíciles de unir o integrar la prueba. Los requisitos arquitectónicos requieren consideración en los estándares de codificación, a lo largo de la fase de codificación, y deben revisarse durante la arquitectura de seguridad, las revisiones de pares o código, o las retrospectivas.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | Verifique que existe una política explícita para la administración de claves criptográficas y que un ciclo de vida de clave criptográfica sigue un estándar de administración de claves como NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Verifique que los consumidores de servicios criptográficos protegen el material clave y otros secretos mediante el uso de almacenes de claves o alternativas basadas en API. | | ✓ | ✓ | 320 |\n| **1.6.3** | Verifique que todas las claves y contraseñas son reemplazables y forman parte de un proceso bien definido para volver a cifrar los datos confidenciales. | | ✓ | ✓ | 320 |\n| **1.6.4** | Verifique que la arquitectura trata los secretos del lado cliente (como claves simétricas, contraseñas o tokens de API) como inseguros y nunca los usa para proteger o acceder a datos confidenciales. | | ✓ | ✓ | 320 |\n\n## V1.7 Arquitectura de Errores, Logging y Auditoría\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | Verifique que se utilice un formato común y un enfoque de logging en todo el sistema. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Verifique que los registros de log se transmitan de forma segura a un sistema preferentemente remoto para análisis, detección, alertas y escalamiento. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Arquitectura de Protección de Datos y Privacidad\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | Verifique que todos los datos confidenciales se identifiquen y clasifiquen en niveles de protección. | | ✓ | ✓ | |\n| **1.8.2** | Verifique que todos los niveles de protección tienen un conjunto asociado de requisitos de protección, como los requisitos de cifrado, los requisitos de integridad, la retención, la privacidad y otros requisitos de confidencialidad, y que estos se aplican en la arquitectura. | | ✓ | ✓ | |\n\n## V1.9 Arquitectura de Comunicaciones\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | Verifique que la aplicación cifra las comunicaciones entre componentes, especialmente cuando estos componentes se encuentran en contenedores, sistemas, sitios o proveedores de nube diferentes. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Verifique que los componentes de la aplicación verifiquen la autenticidad de cada lado en un vínculo de comunicación para evitar ataques de \"persona en el medio\". Por ejemplo, los componentes de la aplicación deben validar certificados y cadenas TLS. | | ✓ | ✓ | 295 |\n\n## V1.10 Arquitectura de Software Malicioso\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | Verifique que un sistema de control de código fuente está en uso, con procedimientos para garantizar que los check-ins están respaldados tickets de issues o solicitudes de cambio. El sistema de control de código fuente debe tener control de acceso y usuarios identificables para permitir la trazabilidad de cualquier cambio. | | ✓ | ✓ | 284 |\n\n## V1.11 Arquitectura de la Lógica de Negocio\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | Verifique la definición y documentación de todos los componentes de la aplicación en términos de las funciones de negocio o de seguridad que proporcionan. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Verifique que todos los flujos de lógica de negocio de alto valor, incluida la autenticación, la administración de sesiones y el control de acceso, no compartan estados no sincronizados. | | ✓ | ✓ | 362 |\n| **1.11.3** | Verifique que todos los flujos de lógica de negocio de alto valor, incluida la autenticación, la administración de sesiones y el control de acceso, sean seguros para subprocesos y resistentes a condiciones de carrera time-of-check y time-of-use (race conditions). | | | ✓ | 367 |\n\n## V1.12 Arquitectura de Carga Segura de Archivos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [ELIMINADO, DUPLICADO CON 12.4.1] | | | | |\n| **1.12.2** | Verifique que los archivos subidos por el usuario, -si es necesario que se muestren o descarguen desde la aplicación-, se hace mediante descargas de secuencias de octetos o desde un dominio no relacionado, como un almacenamiento de archivos en la nube. Implemente una directiva de seguridad de contenido (CSP) adecuada para reducir el riesgo de vectores XSS u otros ataques desde el archivo cargado. | | ✓ | ✓ | 646 |\n\n## V1.13 Arquitectura de API\n\nEste es un marcador de posición para los requisitos arquitectónicos futuros.\n\n## V1.14 Arquitectura de Configuración\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | Verifique la segregación de componentes de diferentes niveles de confianza a través de controles de seguridad bien definidos, reglas de corta fuego, pasarelas de API, proxies reversos, grupos de seguridad basados en nube, o mecanismos similares. | | ✓ | ✓ | 923 |\n| **1.14.2** | Verifique que las firmas binarias, las conexiones de confianza y los puntos de conexión verificados se usan para el despliegue de archivos binarios a dispositivos remotos. | | ✓ | ✓ | 494 |\n| **1.14.3** | Verifique que el canal de compilación advierte de componentes obsoletos o inseguros y realiza las acciones adecuadas. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Verifique que el canal de compilación contiene un paso para compilar y comprobar automáticamente el despliegue seguro de la aplicación, especialmente si la infraestructura de la aplicación está definida por software, como los scripts de compilación del entorno en la nube. | | ✓ | ✓ | |\n| **1.14.5** | Verifique que los despliegues de aplicaciones sean en sandbox, contenedores y/o aislados a nivel de red para retrasar e impedir que los atacantes vulneren otras aplicaciones, especialmente cuando realizan acciones sensibles o peligrosas, como la deserialización. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Verifique que la aplicación no utiliza tecnologías del lado cliente no compatibles, inseguras o en desuso, como NSAPI plugins, Flash, Shockwave, ActiveX, Silverlight, NACL o client-side java applets. | | ✓ | ✓ | 477 |\n\n## Referencias\n\nPara obtener más información, consulte también:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:51.413471"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x11-V2-Authentication.md", "content": "# V2 Autenticación\n\n## Objetivo de Control\n\nLa autenticación es el acto de establecer, o confirmar, a alguien (o algo) como auténtico y que las afirmaciones hechas por una persona o sobre un dispositivo son correctas, resistentes a la suplantación e impiden la recuperación o interceptación de contraseñas.\n\nCuando el ASVS fue lanzado por primera vez, \"username + password\" era la forma más común de autenticación fuera de los sistemas de alta seguridad. La autenticación multifactor (MFA) se aceptaba comúnmente en los círculos de seguridad, pero rara vez se requería en otros lugares. A medida que aumentaba el número de violación de contraseñas, la idea de que los nombres de usuario son de alguna manera confidenciales y las contraseñas desconocidas, hizo que muchos controles de seguridad fueran insostenibles. Por ejemplo, NIST 800-63 considera los nombres de usuario y la autenticación basada en conocimientos (KBA) como información pública, SMS y notificaciones por correo electrónico como [\"restricted\" authenticator types](https://pages.nist.gov/800-63-FAQ/#q-b1), y contraseñas como pre-violadas. Esta realidad hace que los autenticadores basados en el conocimiento, la recuperación de SMS y correo electrónico, el historial de contraseñas, la complejidad y los controles de rotación sean inútiles. Estos controles siempre han sido menos que útiles, a menudo obligando a los usuarios a llegar a contraseñas débiles cada pocos meses, pero con el lanzamiento de más de 5 billones de filtraciones de \"username + password\", es el momento de seguir adelante.\n\nDe todas los capítulos del ASVS, los que más cambiaron son Autenticación y Administración de sesiones. La adopción de una práctica moderna, efectiva y basada en evidencia será un desafío para muchos, y eso está perfectamente bien. Tenemos que comenzar ahora la transición a un futuro post-contraseña.\n\n## NIST 800-63 - Estándar de autenticación moderno basado en evidencia\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) es un estándar moderno basado en la evidencia, y representa el mejor consejo disponible, independientemente de la aplicabilidad. El estándar es útil para todas las organizaciones de todo el mundo, pero es particularmente relevante para las agencias estadounidenses y para quienes trabajen con las agencias estadounidenses.\n\nLa terminología NIST 800-63 puede ser un poco confusa al principio, especialmente si solo estás acostumbrado a la autenticación de \"username + password\". Los avances en la autenticación moderna son necesarios, por lo que tenemos que introducir terminología que se convertirá en algo común en el futuro, pero entendemos la dificultad de entender hasta que la industria se asiente en estos nuevos términos. Se proporciona un glosario al final de este capítulo para mayor detalle. Hemos reformulado muchos requisitos para satisfacer la intención del requisito, en lugar de sólo su letra. Por ejemplo, el ASVS utiliza el término \"contraseña\" cuando NIST utiliza \"secreto memorizado\" en todo el estándar.\n\nASVS V2 Autenticación, V3 Administración de sesiones, y en menor medida, V4 Controles de acceso se han adaptado para que sean un subconjunto compatible de controles NIST 800-63b seleccionados, centrados en amenazas comunes y debilidades de autenticación comúnmente explotadas. Cuando se requiera el cumplimiento completo del NIST 800-63, consulte NIST 800-63.63.\n\n### Seleccionando un nivel adecuado de NIST AAL\n\nASVS ha intentado mapear ASVS L1 con los requisitos NIST AAL1, N2 a AAL2, y L3 a AAL3. Sin embargo, el enfoque de ASVS Level 1 como controles \"esenciales\" puede no ser necesariamente el nivel AAL correcto para verificar una aplicación o API. Por ejemplo, si la aplicación es una aplicación de nivel 3 o tiene requisitos reglamentarios para ser AAL3, el nivel 3 debe elegirse en los capítulos V2 y V3 Administración de sesiones. La elección del nivel de afirmación de autenticación (AAL; Por sus siglas en inglés) compatible con NIST se debe realizar según las pautas NIST 800-63b como se establece en *Seleccionando AAL* en [NIST 800-63b Section 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Leyenda\n\nLas aplicaciones siempre pueden exceder los requisitos del nivel actual, especialmente si la autenticación moderna está en el roadmap de una aplicación. Anteriormente, el ASVS requería MFA obligatorio. NIST no requiere MFA obligatorio. Por lo tanto, hemos utilizado una designación opcional en este capítulo para indicar dónde el ASVS alienta pero no requiere un control. Las siguientes claves se utilizan en todo este estándar:\n\n| Marcado | Descripción |\n| :--: | :-- |\n| | No requerido |\n| o | Recomendado, pero no requerido |\n| ✓ | Requerido |\n\n## V2.1 Seguridad de Contraseña\n\nLas contraseñas, llamadas \"Secretos memorizados\" por NIST 800-63, incluyen contraseñas, PIN, patrones de desbloqueo, elegir el gatito correcto u otro elemento de imagen y frases de contraseña. Generalmente se consideran \"algo que sabes\", y a menudo se utilizan como autenticadores de un solo factor. Hay desafíos significativos para el uso continuo de la autenticación de un solo factor, incluyendo miles de millones de nombres de usuario y contraseñas válidos divulgados en Internet, contraseñas predeterminadas o débiles, tablas arcoíris y diccionarios ordenados de las contraseñas más comunes.\n\nLas aplicaciones deben incentivar el uso de autenticación multifactor y deben permitir a los usuarios re-usar los tokens que ya poseen, como tokens FIDO o U2F, o vincular a un proveedor de servicios de credenciales que proporcione autenticación multifactor.\n\nLos proveedores de servicios de credenciales (CSPs; Por sus siglas en inglés) proporcionan identidad federada a los usuarios. Los usuarios a menudo tendrán más de una identidad con varios CSP, como una identidad empresarial con Azure AD, Okta, Ping Identity o Google, o la identidad del consumidor mediante Facebook, Twitter, Google o WeChat, por nombrar solo algunas alternativas comunes. Esta lista no es un respaldo de estas empresas o servicios, sino simplemente un estímulo para que los desarrolladores consideren la realidad de que muchos usuarios tienen muchas identidades establecidas. Las organizaciones deben considerar la integración con las identidades de usuario existentes, según el perfil de riesgo de la prueba de identidad del CSP. Por ejemplo, es poco probable que una organización gubernamental acepte una identidad de las redes sociales como un inicio de sesión para sistemas sensibles, ya que es fácil crear identidades falsas o desechadas, mientras que una compañía de juegos móviles bien puede necesitar integrarse con las principales plataformas de medios sociales para hacer crecer su base de jugadores activos.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.1.1** | Verifique que las contraseñas del usuarios tienen al menos 12 caracteres de longitud (después de combinar varios espacios). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Verifique que se permitan contraseñas de al menos 64 caracteres y que se denieguen contraseñas de más de 128 caracteres. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Verifique que no se realiza el truncamiento de contraseña. Sin embargo, varios espacios consecutivos pueden ser reemplazados por un solo espacio. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Verifique que cualquier carácter Unicode imprimible, incluidos los caracteres neutros del idioma, como espacios y Emojis esté permitido en las contraseñas. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Verifique que los usuarios pueden cambiar su contraseña. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Verifique que la funcionalidad de cambio de contraseña requiere la contraseña actual y nueva del usuario. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Verifique que las contraseñas enviadas durante el registro de la cuenta, el inicio de sesión y el cambio de contraseña se comprueban localmente contra un conjunto de contraseñas filtradas (como las 1,000 o 10,000 contraseñas más comunes que coinciden con la directiva de contraseñas del sistema) o mediante una API externa. Si se utiliza una API, una prueba de zero knowledge u otro mecanismo, asegúrese que la contraseña en texto plano no se envía ni se utiliza para verificar el estado de filtración de la contraseña. Si la contraseña esta filtrada, la aplicación debe exigir al usuario que establezca una nueva contraseña no filtrada. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Verifique que se proporciona un medidor de fortaleza de la contraseña para ayudar a los usuarios a establecer una contraseña más segura. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Verifique que no hay reglas de composición de contraseñas que limiten el tipo de caracteres permitidos. No debe haber ningún requisito para mayúsculas o minúsculas o números o caracteres especiales. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Verifique que no haya rotación periódica de credenciales o solicitud del historial de contraseñas. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Verifique que se permite la funcionalidad \"pegar\", las aplicaciones auxiliares de contraseñas del browser y los administradores externos de contraseñas. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Verifique que el usuario puede elegir entre ver temporalmente toda la contraseña enmascarada o ver temporalmente el último caracter escrito de la contraseña en plataformas que no tienen esto como funcionalidad integrada. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nNota: El objetivo de permitir que el usuario vea su contraseña o vea el último carácter temporalmente es mejorar la facilidad de uso de la entrada de credenciales, especialmente en torno al uso de contraseñas más largas, frases de contraseña y administradores de contraseñas. Otra razón para incluir el requisito es para limitar o impedir informes de prueba que sugieren innecesariamente que las organizaciones invaliden el comportamiento de campo de contraseña de plataforma integrada para eliminar esta experiencia de seguridad moderna y fácil de usar.\n\n## V2.2 Seguridad General del Autenticador\n\nLa agilidad del autenticador es esencial para aplicaciones preparadas para el futuro. Refactorice los verificadores de aplicaciones para permitir autenticadores adicionales según las preferencias del usuario, así como permitir la retirada de autenticadores obsoletos o inseguros de forma ordenada.\n\nNIST considera el email y el SMS como [autenticadores de tipo \"restringido\"](https://pages.nist.gov/800-63-FAQ/#q-b1), y es probable que sean eliminados del NIST 800-63 y por lo tanto el ASVS en algún momento el futuro. Las aplicaciones deben planificar un roadmap que no requiera el uso de correo electrónico o SMS.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.2.1** | Verifique que los controles anti-automatización son efectivos para mitigar las pruebas de credenciales filtradas, fuerza bruta y ataques de bloqueo de cuentas. Estos controles incluyen el bloqueo de las contraseñas filtradas más comunes, bloqueos suaves, limitación de velocidad, CAPTCHA, retrasos cada vez mayores entre intentos, restricciones de direcciones IP o restricciones basadas en riesgos, como la ubicación, el primer inicio de sesión en un dispositivo, los intentos recientes de desbloquear la cuenta o similares. Verifique que no sea posible realizar más de 100 intentos fallidos por hora en una sola cuenta. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Verifique que el uso de autenticadores débiles (como SMS y correo electrónico) se limita a la verificación secundaria y la aprobación de transacciones y no como un reemplazo para métodos de autenticación más seguros. Verifique que se ofrezcan métodos más fuertes y no métodos débiles, que los usuarios sean conscientes de los riesgos o que se tomen las medidas adecuadas para limitar los riesgos de compromiso de la cuenta. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Verifique que las notificaciones seguras se envían a los usuarios después de las actualizaciones de los detalles de autenticación, como restablecimientos de credenciales, cambios de correo electrónico o dirección, inicio de sesión desde ubicaciones desconocidas o de riesgo. Se prefiere el uso de notificaciones push - en lugar de SMS o correo electrónico - , pero en ausencia de notificaciones push, SMS o correo electrónico es aceptable siempre y cuando no se divulgue información confidencial en la notificación. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Verifique la resistencia a la suplantación contra el phishing, como el uso de la autenticación multifactor, los dispositivos criptográficos con intención (como las claves conectadas con un push para autenticarse) o en niveles AAL más altos, certificados del lado cliente. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Verifique que donde se separan un proveedor de servicios de credenciales (CSP) y la aplicación que comprueba la autenticación, el TLS mutuamente autenticado está en su lugar entre los dos endpoints. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Verifique la resistencia a la reproducción mediante el uso obligatorio de dispositivos de one-time password (OTP), autenticadores criptográficos o códigos de búsqueda. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Verifique la intención de autenticarse exigiendo la entrada de un token de OTP o una acción iniciada por el usuario, como una pulsación de botón en un teclado de hardware FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Ciclo de Vida del Autenticador\n\nLos autenticadores son contraseñas, tokens de software, tokens de hardware y dispositivos biométricos. El ciclo de vida de los autenticadores es fundamental para la seguridad de una aplicación: si alguien puede registrar automáticamente una cuenta sin evidencia de identidad, puede haber poca confianza en la aserción de identidad. Para sitios de redes sociales como Reddit, está perfectamente bien. Para los sistemas bancarios, un mayor enfoque en el registro y la emisión de credenciales y dispositivos es fundamental para la seguridad de la aplicación.\n\nNota: Las contraseñas no deben tener una duración máxima ni estar sujetas a la rotación de contraseñas. Las contraseñas deben comprobarse si han sido filtradas, no pedir que se reemplacen regularmente.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.3.1** | Verifique que las contraseñas iniciales o los códigos de activación generados por el sistema DEBEN ser generados de forma aleatoreamente segura, DEBE tener al menos 6 caracteres de largo y PUEDE contener letras y números, y expirar después de un corto período de tiempo. Estos secretos iniciales no deben permitirse su re-utilización para convertirse en la contraseña a largo plazo. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Verifique que se admite la inscripción y el uso de dispositivos de autenticación proporcionados por el suscriptor, como tokens U2F o FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Verifique que las instrucciones de renovación se envían con tiempo suficiente para renovar los autenticadores con límite de tiempo. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Almacenamiento de Credenciales\n\nLos arquitectos y desarrolladores deben adherirse a esta sección al crear o refactorizar código. Esta sección solo se puede verificar completamente mediante la revisión del código fuente o mediante pruebas de unidad o integración seguras. Las pruebas de penetración no pueden identificar ninguno de estos problemas.\n\nLa lista de funciones de derivación aprobadas de one-way key se detalla en la sección 5.1.1.2 del NIST 800-63 B, y en [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). El último algoritmo nacional o regional y los estándares de longitud de clave se pueden elegir en lugar de estas opciones.\n\nEsta sección no se puede probar en penetración, por lo que los controles no se marcan como L1. Sin embargo, esta sección es de vital importancia para la seguridad de las credenciales si son robadas, por lo que si bifurca el ASVS para una arquitectura o directriz de codificación o lista de comprobación de revisión de código fuente, coloque estos controles de nuevo en L1 en su versión privada.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.4.1** | Verifique que las contraseñas se almacenan en un forma tal que resisten ataques sin conexión. Las contraseñas DEBERÁN usar hash con salto mediante una derivación de llave de una sola vía aprobada o función de hash de contraseña. Las funciones derivación de llave y hash de contraseñas toman una contraseña, una salto y un factor de costo como entradas al generar un hash de contraseña. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Verifique que el salto tiene al menos 32 bits de longitud y que se elige arbitrariamente para minimizar las colisiones de valor de salto entre los hashes almacenados. Para cada credencial, se DEBE almacenar un único valor de salto y el hash resultante. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Verifique que si se utiliza PBKDF2, el recuento de iteraciones DEBE ser tan grande como el rendimiento del servidor de verificación lo permita, normalmente de al menos 100,000 iteraciones. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Verifique que si se utiliza bcrypt, el factor de trabajo DEBE ser tan grande como lo permita el rendimiento del servidor de verificación, con un mínimo de 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Verifique que se realiza una iteración adicional de una función de derivación de claves, utilizando un valor de salto que es secreto y que solo conoce el verificador. Genere el valor de salto utilizando un generador de bits aleatorios aprobado [SP 800-90Ar1] y proporcione al menos la fuerza de seguridad mínima especificada en la última revisión del SP 800-131A. El valor secreto del salto se almacenará por separado de las contraseñas hash (p. ej., en un dispositivo especializado como un módulo de seguridad de hardware). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nCuando se mencionan las normas estadounidenses, se puede utilizar una norma regional o local en lugar de la norma estadounidense o además de la norma estadounidense según sea necesario.\n\n## V2.5 Recuperación de Credenciales\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.5.1** | Verifique que un secreto de activación o recuperación inicial generado por el sistema no se envíe en texto claro al usuario. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Verificar sugerencias de contraseña o autenticación basada en conocimientos (las llamadas \"preguntas secretas\") no están presentes. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Verificar la recuperación de credenciales de contraseña no revela la contraseña actual de ninguna manera. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Verificar que las cuentas compartidas o predeterminadas no estén presentes (por ejemplo. \"root\", \"admin\", o \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Verifique que si se cambia o reemplaza un factor de autenticación, se notifica al usuario de este evento. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Verifique la contraseña olvidada y otras rutas de recuperación utilizan un mecanismo de recuperación seguro, como OTP basado en el tiempo (TOTP) u otro token de software, mobile push u otro mecanismo de recuperación sin conexión. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Verifique que si se pierden factores de autenticación OTP o multifactor, esa evidencia de prueba de identidad se realiza al mismo nivel que durante la inscripción. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Verificador de Secretos de Look-up\n\nSecretos de Look up (secretos de búsqueda) son listas generadas previamente de códigos secretos, similares a los números de autorización de transacción (TAN), los códigos de recuperación de redes sociales o una cuadrícula que contiene un conjunto de valores aleatorios. Estos se distribuyen de forma segura a los usuarios. Estos códigos de búsqueda se utilizan una vez y, una vez que se utilizan todos, se descarta la lista secreta de búsqueda. Este tipo de autenticador se considera \"algo que tienes\".\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.6.1** | Verifique que los secretos de búsqueda solo se pueden usar una vez. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Verifique que los secretos de búsqueda tengan suficiente aleatoriedad (112 bits de entropía), o si menos de 112 bits de entropía, saltados con un única y aleatoria salto de 32 bits y hasheado con un hash aprobado de una sola vía. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Verifique que los secretos de búsqueda son resistentes a los ataques sin conexión, como los valores predecibles. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Verificador Fuera de Banda\n\nEn el pasado, un verificador fuera de banda común habría sido un correo electrónico o SMS que contiene un enlace de restablecimiento de contraseña. Los atacantes utilizan este mecanismo débil para restablecer las cuentas que aún no controlan, como tomar el control de la cuenta de correo electrónico de una persona y volver a usar los vínculos de restablecimiento descubiertos. Hay mejores maneras de manejar la verificación fuera de banda.\n\nLos autenticadores seguros fuera de banda son dispositivos físicos que pueden comunicarse con el verificador a través de un canal secundario seguro. Algunos ejemplos son las notificaciones push a dispositivos móviles. Este tipo de autenticador se considera \"algo que tienes\". Cuando un usuario desea autenticarse, la aplicación de verificación envía un mensaje al autenticador fuera de banda a través de una conexión al autenticador directa o indirectamente a través de un servicio de terceros. El mensaje contiene un código de autenticación (normalmente un número aleatorio de seis dígitos o un cuadro de diálogo de aprobación modal). La aplicación de comprobación espera a recibir el código de autenticación a través del canal principal y compara el hash del valor recibido con el hash del código de autenticación original. Si coinciden, el verificador fuera de banda puede suponer que el usuario se ha autenticado.\n\nASVS asume que sólo unos pocos desarrolladores desarrollarán nuevos autenticadores fuera de banda, como notificaciones push, y por lo tanto los siguientes controles ASVS se aplican a los verificadores, como la API de autenticación, las aplicaciones y las implementaciones de inicio de sesión único. Si está desarrollando un nuevo autenticador fuera de banda, por favor refiérase a NIST 800-63B &sect; 5.1.3.1.\n\nNo se permiten autenticadores inseguros fuera de banda, como el correo electrónico y VoIP. La autenticación RTC y SMS está actualmente \"restringida\" por NIST y debe estar en desuso en favor de las notificaciones push o similares. Si necesita utilizar la autenticación telefónica o sms fuera de banda, por favor consulte &sect; 5.1.3.3.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.7.1** | Verifique que los autenticadores de texto sin cifrar fuera de banda tales como PSTN o SMS (\"restringido por NIST\") no se ofrecen de forma predeterminada, y que en primer lugar se ofrecen alternativas más sólidas, como las notificaciones push. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Verifique que el verificador fuera de banda expira después de 10 minutos, fuera de las solicitudes de autenticación de banda, códigos o tokens. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Verifique que las solicitudes de autenticación, los códigos o los tokens de verificador fuera de banda solo se pueden usar una vez y solo para la solicitud de autenticación original. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Verifique que el autenticador y el verificador fuera de banda se comuniquen a través de un canal independiente seguro. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Verifique que el verificador fuera de banda conserva solo una versión hasheada del código de autenticación. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Verifique que el código de autenticación inicial sea generado por un generador de números aleatorios seguro, que contiene al menos 20 bits de entropía (normalmente un número aleatorio digital de seis es suficiente). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 Verificador de Una Sola Vez\n\nLas contraseñas de una sola vez de un solo factor (OTPs) son tokens físicos o flexibles que muestran un desafío pseudoaleatorio que cambia continuamente. Estos dispositivos hacen que el phishing (suplantación) sea difícil, pero no imposible. Este tipo de autenticador se considera \"algo que tienes\". Los tokens multifactor son similares a los OTP de un solo factor, pero requieren un código PIN válido, desbloqueo biométrico, inserción USB o emparejamiento NFC o algún valor adicional (como calculadoras de firma de transacciones) que se introduzcan para crear el OTP final.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.8.1** | Verifique que los OTP basados en el tiempo tienen una duración definida antes de expirar. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Verifique que las claves simétricas utilizadas para comprobar los OTP enviados están altamente protegidas, por ejemplo, mediante el uso de un módulo de seguridad de hardware o almacenamiento seguro de claves basadas en el sistema operativo. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **2.8.3** | Verifique que los algoritmos criptográficos aprobados se utilizan en la generación, siembra y verificación de OTP. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Verifique que el OTP basado en el tiempo se pueda utilizar solamente una vez dentro del período de validez. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Verifique que si se reutiliza un token OTP multifactor basado en el tiempo durante el período de validez, se registra en logs y se rechaza con notificación segura enviada al titular del dispositivo. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Verifique que el generador OTP de un solo factor físico pueda ser revocado en caso de robo u otra pérdida. Asegúrese de que la revocación es efectiva inmediatamente en todas las sesiones iniciadas, independientemente de la ubicación. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Verifique que los autenticadores biométricos se limitan a usarlos solo como factores secundarios junto con algo que Ud. tiene y algo que Ud. sabe. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Verificador Criptográfico\n\nLas claves de seguridad criptográficas son tarjetas inteligentes o claves FIDO, donde el usuario tiene que conectar o emparejar el dispositivo criptográfico al equipo para completar la autenticación. Los verificadores envían un mensaje de desafío a los dispositivos o software criptográficos, y el dispositivo o software calcula una respuesta basada en una clave criptográfica almacenada de forma segura.\n\nLos requisitos para los dispositivos y software criptográficos de un solo factor, y los dispositivos y software criptográficos multifactor son los mismos, ya que la verificación del autenticador criptográfico demuestra la posesión del factor de autenticación.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.9.1** | Verifique que las claves criptográficas utilizadas en la verificación se almacenan de forma segura y protegidas contra la divulgación, como el uso de un módulo de plataforma segura (TPM) o un módulo de seguridad de hardware (HSM) o un servicio de sistema operativo que puede utilizar este almacenamiento seguro. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Verifique que el mensaje de desafío tenga al menos 64 bits de longitud y sea estadísticamente único o sea único a lo largo de la vida útil del dispositivo criptográfico. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Verifique que se utilizan algoritmos criptográficos aprobados en la generación, la semilla y la verificación. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Autenticación de Servicio\n\nEsta categoría no es comprobable con test de penetración, por lo que no tiene ningún requisito L1. Sin embargo, si se utiliza en una arquitectura, codificación o revisión de código segura, suponga que el software (al igual que Java Key Store) es el requisito mínimo en L1. El almacenamiento de texto claro de los secretos no es aceptable bajo ninguna circunstancia.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.10.1** | Verifique que los secretos dentro del servicio no se basan en credenciales invariables, como contraseñas, claves de API o cuentas compartidas con acceso con privilegios. | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Verifique que si las contraseñas son necesarias para la autenticación de servicio, la cuenta de servicio utilizada no es una credencial predeterminada. (p. ej., root/root o admin/admin son predeterminados en algunos servicios durante la instalación). | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Verifique que las contraseñas se almacenan con suficiente protección para evitar ataques de recuperación sin conexión, incluido el acceso al sistema local. | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Verifique que las contraseñas, las integraciones con bases de datos y sistemas de terceros, las semillas y los secretos internos y las claves de API se administran de forma segura y no se incluyen en el código fuente ni se almacenan en los repositorios de código fuente. Dicho almacenamiento DEBE resistir ataques fuera de línea. Se recomienda el uso de un almacén de claves de software seguro (L1), TPM de hardware o un HSM (L3) para el almacenamiento de contraseñas. | | OS assisted | HSM | 798 | |\n\n## Requisitos Adicionales de Agencias de EE.UU.\n\nLas agencias de EEUU tienen requisitos obligatorios relativos al NIST 800-63. ASVS siempre ha sido casi el 80% de los controles que se aplican a casi el 100% de las aplicaciones, y no el último 20% de los controles avanzados o aquellos que tienen una aplicabilidad limitada. Como tal, el ASVS es un subconjunto estricto de NIST 800-63, especialmente para las clasificaciones IAL1/2 y AAL1/2, pero no es lo suficientemente completo, especialmente en lo que respecta a las clasificaciones IAL3/AAL3.\n\nInstamos encarecidamente a las agencias de EEUU a que revisen e implementen NIST 800-63 en su totalidad.\n\n## Glosario de términos\n\n| Termino | Significado |\n| -- | -- |\n| CSP | Proveedor de servicios de credenciales también llamado proveedor de identidades |\n| Authenticator | Código que autentica una contraseña, un token, MFA, una aserción federada, etc. |\n| Verifier | \"Una entidad que verifica la identidad del reclamante verificando la posesión y el control del reclamante de uno o dos autenticadores mediante un protocolo de autenticación. Para ello, es posible que el verificador también necesite validar las credenciales que vinculan el autenticador con el identificador del suscriptor y comprobar su estado\" |\n| OTP | Contraseña de una sola vez |\n| SFA | Autenticadores de un solo factor, como algo que conoces (secretos memorizados, contraseñas, frases de contraseña, PIN), algo que eres (biometría, huellas dactilares, escaneos faciales) o algo que tienes (tokens OTP, un dispositivo criptográfico como una tarjeta inteligente) |\n| MFA | Autenticación multifactor, que incluye dos o más factores individuales |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:51.500868"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x12-V3-Session-management.md", "content": "# V3 Gestión de sesiones\n\n## Objetivo de Control\n\nUno de los componentes principales de cualquier aplicación basada en web o stateful API es el mecanismo por el cual controla y mantiene el estado de un usuario o dispositivo que interactúa con él. La gestión de sesiones cambia un protocolo sin estado (stateless) a uno con estado (stateful), lo que es fundamental para diferenciar diferentes usuarios o dispositivos.\n\nAsegúrese de que una aplicación verificada cumple los siguientes requisitos de gestión de sesiones de alto nivel:\n\n* Las sesiones son únicas para cada individuo y no se pueden adivinar ni compartir.\n* Las sesiones se invalidan cuando ya no son necesarias y se agota el tiempo de espera durante los períodos de inactividad.\n\nComo se ha señalado anteriormente, estos requisitos se han adaptado para ser un subconjunto compatible de controles NIST 800-63b seleccionados, centrados en amenazas comunes y debilidades de autenticación comúnmente explotadas. Los requisitos de verificación anteriores han sido retirados, eliminado redundancias, o en la mayoría de los casos, adaptados para estar fuertemente alineados con los requisitos obligatorios de [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n## Requisitos de Verificación de Seguridad\n\n## V3.1 Seguridad Fundamental en la Gestión de Sesiones\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.1.1** | Verifique que la aplicación nunca revela tokens de sesión en parámetros de dirección URL. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Binding de Sesión\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.2.1** | Verifique que la aplicación genera un nuevo token de sesión en la autenticación de usuario. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Verifique que los tokens de sesión posean al menos 64 bits de entropía. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Verifique que la aplicación solo almacena tokens de sesión en el navegador mediante métodos seguros, como proteger las cookies adecuadamente (consulte la sección 3.4) o el almacenamiento de sesión en HTML 5. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Verifique que los tokens de sesión se generan mediante algoritmos criptográficos aprobados. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nTLS u otro canal de transporte seguro es obligatorio para la gestión de sesiones. Esto se trata en el capítulo Seguridad de las comunicaciones.\n\n## V3.3 Terminación de Sesión\n\nLos tiempos de espera de sesión se han alineado con NIST 800-63, lo que permite tiempos de espera de sesión mucho más largos de lo permitido tradicionalmente por los estándares de seguridad. Las organizaciones deben revisar la tabla siguiente y, si es deseable un tiempo de espera más largo en función del riesgo de la aplicación, el valor NIST debe ser los límites superiores de los tiempos de espera de inactividad de sesión.\n\nL1 en este contexto es IAL1/AAL1, L2 es IAL2/AAL3, L3 es IAL3/AAL3. Para IAL2/AAL2 e IAL3/AAL3, el tiempo de espera de inactividad más corto es, el límite inferior de los tiempos de inactividad para ser cerrado o re-autenticado para reanudar la sesión.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.3.1** | Verifique que el cierre de sesión y la expiración invalidan el token de sesión, de modo que el botón \"Atrás\" o un usuario de confianza posterior no reanude una sesión autenticada, incluso entre los usuarios de confianza. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Si los autenticadores permiten a los usuarios permanecer conectados, compruebe que la re-autenticación se produce periódicamente tanto cuando se utiliza activamente o después de un período de inactividad. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 días | 12 horas o 30 minutos de inactividad, 2FA opcional | 12 horas o 15 minutos de inactividad, con 2FA | 613 | 7.2 |\n| **3.3.3** | Verifique que la aplicación ofrece la opción de terminar todas las demás sesiones activas después de un cambio de contraseña correcto (incluido el cambio mediante el restablecimiento/recuperación de contraseña), y que esto es efectivo en toda la aplicación, el inicio de sesión federado (si está presente) y cualquier usuario de confianza. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Verifique que los usuarios pueden ver y (habiendo vuelto a introducir las credenciales de inicio de sesión) cerrar sesión en cualquiera o todas las sesiones y dispositivos activos actualmente. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Gestión de Sesión Basada en Cookie\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.4.1** | Verifique que los tokens de sesión basados en cookies tengan el atributo 'Secure' establecido. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Verifique que los tokens de sesión basados en cookies tienen el atributo 'HttpOnly' establecido. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Verifique que los tokens de sesión basados en cookies utilizan el atributo 'SameSite' para limitar la exposición a ataques de falsificación de solicitudes entre sitios. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | Verifique que los tokens de sesión basados en cookies utilizan el prefijo \"__Host-\" para que las cookies solo se envíen al host que configuró inicialmente la cookie. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Verifique que si la aplicación se publica bajo un nombre de dominio con otras aplicaciones que establecen o usan cookies de sesión que podrían revelar las cookies de sesión, establezca el atributo de ruta en tokens de sesión basados en cookies utilizando la ruta más precisa posible. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Administración de Sesiones Basada en Tokens\n\nLa gestión de sesiones basada en tokens incluye JWT, OAuth, SAML y API keys. De estos, se sabe que las API keys son débiles y no se deben usar en código nuevo.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.5.1** | Verifique que la aplicación permite a los usuarios revocar tokens de OAuth que forman relaciones de confianza con aplicaciones vinculadas. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Verifique que la aplicación utiliza tokens de sesión en lugar de claves y secretos de API estáticos, excepto con implementaciones heredadas. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Verifique que los tokens de sesión sin estado utilizan firmas digitales, cifrado y otras contramedidas para protegerse contra ataques de manipulación, envolvente, reproducción, cifrado nulo y sustitución de claves. | | ✓ | ✓ | 345 | |\n\n## V3.6 Reautenticación Federada\n\nEsta sección se relaciona con aquellos que escriben el código de Partes de confianza (RP) o proveedores de servicios de credenciales (CSP). Si confía en el código que implementa estas características, asegúrese de que estos problemas se manejen correctamente.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.6.1** | Verifique que las partes de confianza (RP) especifiquen el tiempo máximo de autenticación para los proveedores de servicios de credenciales (CSP) y que los CSP vuelvan a autenticar al usuario si no han utilizado una sesión dentro de ese período. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Verifique que los proveedores de servicios de credenciales (CSP) informan a las partes de confianza (RP) del último evento de autenticación, para permitir que los RP determinen si necesitan volver a autenticar al usuario. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Defensas Contra las Vulnerabilidades de Gestión de Sesiones\n\nHay un pequeño número de ataques de gestión de sesiones, algunos relacionados con la experiencia del usuario (UX) de las sesiones. Anteriormente, sobre la base de los requisitos ISO 27002, el ASVS ha requerido bloquear varias sesiones simultáneas. El bloqueo de sesiones simultáneas ya no es adecuado, no sólo porque los usuarios modernos tienen muchos dispositivos o la aplicación es una API sin una sesión de navegador, pero en la mayoría de estas implementaciones, el último autenticador gana, que a menudo es el atacante. En esta categoría se proporcionan instrucciones principales sobre cómo disuadir, retrasar y detectar ataques de gestión de sesiones mediante código.\n\n### Descripción del Ataque semi-abierto\n\nA principios de 2018, varias instituciones financieras se vieron comprometidas usando lo que los atacantes llamaron \"ataques semi abiertos\". Este término se ha atascado en la industria. Los atacantes golpearon múltiples instituciones con diferentes bases de código propietario, y de hecho parece diferentes bases de código dentro de las mismas instituciones. El ataque semi-abierto explota un defecto de patrón de diseño que se encuentra comúnmente en muchos sistemas existentes de autenticación, gestión de sesiones y control de acceso.\n\nLos atacantes inician un ataque semi-abierto al intentar bloquear, restablecer o recuperar una credencial. Un patrón de diseño de gestión de sesiones popular reutiliza los objetos/modelos de sesión de perfil de usuario entre objetos/modelos no autenticados y autenticados a semi-autorizado (restablecimiento de contraseña, nombre de usuario olvidado) y código totalmente autenticado. Este patrón de diseño rellena un objeto de sesión o token válido que contiene el perfil de la víctima, incluidos los roles y hashes de contraseña. Si las comprobaciones de control de acceso en controladores o routers no comprueban correctamente que el usuario ha iniciado sesión por completo, el atacante podrá actuar como si fuera el usuario. Los ataques podrían incluir cambiar la contraseña del usuario a un valor conocido, actualizar la dirección de correo electrónico para realizar un restablecimiento de contraseña válido, deshabilitar la autenticación multifactor o inscribir un nuevo dispositivo MFA, revelar o cambiar claves de API, etc.\n\n| # | Descripción | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.7.1** | Verifique que la aplicación garantiza una sesión de inicio de sesión completa y válida o requiere una re-autenticación o verificación secundaria antes de permitir cualquier transacción confidencial o modificaciones de la cuenta. | ✓ | ✓ | ✓ | 306 | |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:51.635168"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x12-V4-Access-Control.md", "content": "# V4 Control de Acceso\n\n## Objetivo de Control\n\nLa autorización es el concepto de permitir el acceso a los recursos solo a aquellos a los que se les permite utilizarlos. Asegúrese de que una aplicación verificada cumple los siguientes requisitos de alto nivel:\n\n* Las personas que acceden a los recursos tienen credenciales válidas para hacerlo.\n* Los usuarios están asociados a un conjunto bien definido de roles y privilegios.\n* Los metadatos de roles y permisos están protegidos contra la reproducción o la manipulación.\n\n## Requisitos de Verificación de Seguridad\n\n## V4.1 Diseño de Control de Acceso General\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.1.1** | Verifique que la aplicación aplica las reglas de control de acceso en una capa de servicio de confianza, especialmente si el control de acceso del lado cliente está presente y podría ser bypaseado. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Verifique que todos los atributos de usuario y datos y la información de directiva utilizada por los controles de acceso no pueden ser manipulados por los usuarios finales a menos que se autorice específicamente. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Verifique que existe el principio de privilegios mínimos: los usuarios solo deben poder acceder a funciones, archivos de datos, direcciones URL, controladores, servicios y otros recursos, para los que poseen una autorización específica. Esto implica protección contra la suplantación y elevación de privilegios. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [ELIMINADO, DUPLICADO DE 4.1.3] | | | | |\n| **4.1.5** | Verifique que los controles de acceso fallan de forma segura, incluso cuando se produce una excepción. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Control de Acceso a Nivel de Operación\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.2.1** | Verifique que los datos confidenciales y las API están protegidos contra ataques de referencia insegura directa de objetos (IDOR; por sus siglas en inglés) dirigidos a la creación, lectura, actualización y eliminación de registros, como la creación o actualización del registro de otra persona, la visualización de los registros de todos o la eliminación de todos los registros. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Verifique que la aplicación o el framework aplica un mecanismo anti-CSRF seguro para proteger la funcionalidad autenticada, y eficaz anti-automatización o anti-CSRF protege la funcionalidad no autenticada. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Otras Consideraciones de Control de Acceso\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.3.1** | Verifique que las interfaces administrativas utilicen la autenticación multifactor adecuada para evitar el uso no autorizado. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Verifique que la exploración de directorios está deshabilitada a menos que se desee deliberadamente. Además, las aplicaciones no deben permitir la detección o divulgación de metadatos de archivos o directorios, como Thumbs.db, .DS_Store, .git o .svn. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Verifique que la aplicación tiene autorización adicional (como la autenticación paso a paso o adaptativa) para sistemas de menor valor y/ o segregación de tareas para aplicaciones de alto valor para aplicar controles antifraude según el riesgo de aplicación y fraudes previos. | | ✓ | ✓ | 732 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:51.705217"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Validación, Desinfección y Codificación\n\n## Objetivo de Control\n\nLa debilidad más común de la seguridad de la aplicación web es la falta de validación adecuada de la entrada procedente del cliente o del entorno antes de usarla directamente sin ninguna codificación de salida (output encoding). Esta debilidad conduce a casi todas las vulnerabilidades significativas en aplicaciones web, como el scripting entre sitios (XSS), la inyección de SQL, la inyección del intérprete, los ataques de configuración regional/Unicode, los ataques del sistema de archivos y los desbordamientos de búfer.\n\nAsegúrese de que una aplicación verificada cumple los siguientes requisitos de alto nivel:\n\n* La validación de entrada y la arquitectura de codificación de salida tienen un canal acordado para evitar ataques de inyección.\n* Los datos de entrada están fuertemente tipados, validados, de rango o longitud comprobados, o en el peor de los casos, desinfectados o filtrados.\n* Los datos de salida se codifican o escapan según el contexto de los datos lo más cerca posible del intérprete.\n\nCon la arquitectura moderna de aplicaciones web, la codificación de salida es más importante que nunca. Es difícil proporcionar una validación de entrada sólida en determinados escenarios, por lo que el uso de una API más segura, como consultas parametrizadas, frameworks de plantillas de auto-escaping automático o codificación de salida cuidadosamente elegida, es fundamental para la seguridad de la aplicación.\n\n## V5.1 Validación de Entrada\n\nControles de validación de entrada implementados correctamente, utilizando listas de permisos positivas y un fuerte tipado de datos, puede eliminar más del 90% de todos los ataques de inyección. Las comprobaciones de longitud y rango pueden reducir esto aún más. Se requiere la creación de validación de entrada segura durante la arquitectura de la aplicación, los sprints de diseño, la codificación y las pruebas de unidad e integración. Aunque muchos de estos elementos no se pueden encontrar en las pruebas de penetración, los resultados de no implementarlos se encuentran generalmente en V5.3 - Codificación de Salida y Requisitos de Prevención de Inyección. Se recomienda a los desarrolladores y revisores de código seguro que traten esta sección como si se requiriera L1 para todos los elementos para prevenir inyecciones.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.1.1** | Verifique que la aplicación tiene defensas contra los ataques de contaminación de parámetros HTTP, especialmente si el marco de la aplicación no hace ninguna distinción sobre el origen de los parámetros de solicitud (GET, POST, cookies, encabezados o variables de entorno). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Verifique que los frameworks protegen contra ataques de asignación de parámetros masivos o que la aplicación tiene contramedidas para proteger contra la asignación de parámetros no seguros, como marcar campos privados o similares. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Verifique que todas las entradas (campos de formulario HTML, solicitudes REST, parámetros de URL, encabezados HTTP, cookies, archivos por lotes, fuentes RSS, etc.) se validan mediante validación positiva (lista de permitidos). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Verifique que las estructuras de datos están fuertemente tipados y validados con un esquema definido que incluya caracteres permitidos, longitud y patrón (p. ej., números de tarjeta de crédito, direcciones de correo electrónico, números de teléfono, o validar que dos campos relacionados son razonables, como comprobar que el suburbio y el código postal coinciden). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Verifique que las redirecciones y reenvíos de URL solo permiten destinos que aparecen en una lista de permitidos, o muestra una advertencia al redirigir a contenido potencialmente no confiable. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Requisitos de Sanitización y Sandboxing\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.2.1** | Verifique que todas las entradas HTML que no son de confianza de los editores WYSIWYG o similares se sanitizan correctamente con una biblioteca de sanitización HTML o una función de marco de trabajo. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Verifique que los datos no estructurados están sanitizados para aplicar medidas de seguridad, como caracteres permitidos y longitud. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Verifique que la aplicación sanitiza la entrada del usuario antes de pasar a los sistemas de correo para protegerse contra la inyección SMTP o IMAP. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Verifique que la aplicación evita el uso de eval() u otras características de ejecución de código dinámico. Cuando no hay alternativa, cualquier entrada de usuario debe sanitizarse, y ponerlo en sandbox antes de ejecutarse. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Verifique que la aplicación protege contra ataques de inyección de plantilla asegurándose que cualquier entrada de usuario que se incluya está sanitizada o en un lugar controlado. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Verifique que la aplicación protege contra ataques SSRF, validando o desinfectando datos que no son de confianza o metadatos de archivos HTTP, como nombres de archivo y campos de entrada de URL, y utiliza listas de protocolos permitidos, dominios, rutas de acceso y puertos. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Verifique que la aplicación desinfecta, deshabilita o pone en sandbox el contenido proporcionado por el usuario, con scripts de gráficos vectoriales escalables (SVG; por sus siglas en inglés) especialmente en lo que se refiere a XSS resultante de scripts en línea y foreignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Verifique que la aplicación desinfecta, deshabilita o pone en sandbox el contenido proporcionado por el usuario, con expresiones en lenguaje de plantilla o script como Markdown, CSS o las hojas de estilo XSL, BBCode o similares. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Codificación de Salida y Prevención de Inyección\n\nLa codificación de salida cercana o adyacente al intérprete en uso es fundamental para la seguridad de cualquier aplicación. Normalmente, la codificación de salida no se conserva, pero se usa para hacer que la salida sea segura en el contexto de salida adecuado para su uso inmediato. Si no se codifica la salida, se producirá una aplicación insegura, inyectable e insegura.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.3.1** | Verifique que la codificación de salida es relevante para el intérprete y el contexto requerido. Por ejemplo, utilice codificadores específicamente para valores HTML, atributos HTML, JavaScript, parámetros de URL, encabezados HTTP, SMTP y otros según lo requiera el contexto, especialmente a partir de entradas que no sean de confianza (por ejemplo, nombres con Unicode o apóstrofes, como ねこ u O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Verifique que la codificación de salida conserva el juego de caracteres y la configuración regional elegidos por el usuario, de modo que cualquier punto de caracteres Unicode sea válido y se maneje de forma segura. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Verifique que el escape de salida basado en contexto, preferiblemente automatizado - o en el peor de los casos, manual - protege contra XSS reflejado, almacenado y basado en DOM. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Verifique que la selección de datos o las consultas de base de datos (por ejemplo, SQL, HQL, ORM, NoSQL) utilizan consultas parametrizadas, ORM, marcos de entidades o están protegidas de los ataques de inyección de base de datos. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Verifique donde los mecanismos parametrizados o más seguros no están presentes, la codificación de la salida en el contexto específico se utiliza para proteger contra ataques de inyección, como el uso de escape SQL para proteger contra la inyección SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Verifique que la aplicación protege contra ataques de inyección de JSON, ataques de \"eval\" en JSON y evaluación de expresiones de JavaScript. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Verifique que la aplicación protege contra vulnerabilidades de inyección LDAP o que se han implementado controles de seguridad específicos para evitar la inyección LDAP. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Verifique que la aplicación protege contra la inyección de comandos del sistema operativo y que las llamadas al sistema operativo utilizan consultas de sistema operativo parametrizadas o utilicen codificación de salida de línea de comandos contextual. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Verifique que la aplicación protege contra ataques de inclusión de archivos locales (LFI) o de inclusión remota de archivos (RFI). | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Verifique que la aplicación protege contra ataques de inyección XPath o de inyección XML. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nNota: El uso de consultas parametrizadas o el escape de SQL no siempre es suficiente; los nombres de tabla y columna, ORDER BY, etc., no se pueden escapar. La inclusión de datos proporcionados por el usuario con escape en estos campos da como resultado consultas con errores o inyección SQL.\n\nNota: El formato SVG permite explícitamente el script ECMA en casi todos los contextos, por lo que puede que no sea posible bloquear todos los vectores SVG XSS completamente. Si se requiere la carga SVG, se recomienda encarecidamente que se sirvan estos archivos cargados como texto/sin formato o que utilicen un dominio de contenido proporcionado por un usuario independiente para evitar que un XSS exitoso tome el control de la aplicación.\n\n## V5.4 Memoria, Cadena y Código No Administrado\n\nLos siguientes requisitos solo se aplicarán cuando la aplicación utilice un lenguaje de sistemas o código no administrado.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.4.1** | Verifique que la aplicación utiliza cadenas de memoria segura, copia de memoria más segura y aritmética de puntero para detectar o evitar desbordamientos de pila, búffer o heap. | | ✓ | ✓ | 120 |\n| **5.4.2** | Verifique que las cadenas de formato no toman entradas potencialmente hostiles y son constantes. | | ✓ | ✓ | 134 |\n| **5.4.3** | Verifique que se utilizan técnicas de validación de signos, intervalos y entradas para evitar desbordamientos de enteros. | | ✓ | ✓ | 190 |\n\n## V5.5 Prevención de Deserialización\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | Verifique que los objetos serializados utilizan comprobaciones de integridad o están cifrados para evitar la creación de objetos hostiles o la manipulación de datos. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Verifique que la aplicación restringe correctamente los analizadores XML para que solo usen la configuración más restrictiva posible y para asegurarse de que las características no seguras, como la resolución de entidades externas, están deshabilitadas para evitar ataques XML eXternal Entity (XXE). | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Verifique que la deserialización de datos que no son de confianza se evita o está protegida tanto en código personalizado como en bibliotecas de terceros (como analizadores JSON, XML y YAML). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Verifique que al analizar JSON en exploradores o backends basados en JavaScript, JSON.parse se utiliza para analizar el documento JSON. No utilice eval() para analizar JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nPara obtener más información sobre el escape automático, consulte:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Template Security](https://angular.io/guide/template-syntax#content-security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nPara obtener más información sobre la deserialización, consulte:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:51.829186"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x14-V6-Cryptography.md", "content": "# V6 Criptografía almacenada\n\n## Objetivo de Control\n\nAsegúrese que una aplicación verificada cumple los siguientes requisitos de alto nivel:\n\n* Todos los módulos criptográficos fallan de forma segura y que los errores se gestionan correctamente.\n* Se utiliza un generador de números aleatorios adecuado.\n* El acceso a las claves se administra de forma segura.\n\n## V6.1 Clasificación de Datos\n\nEl activo más importante son los datos procesados, almacenados o transmitidos por una aplicación. Realice siempre una evaluación de impacto en la privacidad para clasificar correctamente las necesidades de protección de datos de los datos almacenados.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.1.1** | Verifique que los datos privados regulados se almacenan cifrados mientras están en reposo, como información de identificación personal (PII), información personal confidencial o datos evaluados que puedan estar sujetos al RGPD de la UE. | | ✓ | ✓ | 311 |\n| **6.1.2** | Verifique que los datos de salud regulados se almacenen cifrados mientras están en reposo, como registros médicos, detalles de dispositivos médicos o registros de investigación anonimizados. | | ✓ | ✓ | 311 |\n| **6.1.3** | Verifique que los datos financieros regulados se almacenen cifrados mientras están en reposo, como cuentas financieras, impagos o historial de crédito, registros fiscales, historial de pagos, beneficiarios o registros de mercado o de investigación anonimizados. | | ✓ | ✓ | 311 |\n\n## V6.2 Algoritmos\n\nLos avances recientes en criptografía significan que los algoritmos y longitudes de clave previamente seguros ya no son seguros o suficientes para proteger los datos. Por lo tanto, debe ser posible cambiar algoritmos.\n\nAunque esta sección no es fácil de demostrar con prueba de penetración, los desarrolladores deben considerar toda esta sección como obligatoria aunque L1 falta en la mayoría de los elementos.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.2.1** | Verifique que todos los módulos criptográficos fallan de forma segura y que los errores se gestionan de forma que no se habiliten los ataques \"Padding Oracle\". | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Verifique que se utilicen algoritmos, modos y bibliotecas criptográficas probados por la industria o aprobados por el gobierno, en lugar de criptografía codificada personalizada. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Verifique que los modos de vector de inicialización de cifrado, configuración de cifrado y bloque están configurados de forma segura mediante los últimos consejos vigentes. | | ✓ | ✓ | 326 |\n| **6.2.4** | Verifique que los algoritmos de número aleatorio, cifrado o hash, longitudes de clave, rondas, cifrados o modos, se puedan reconfigurar, actualizar o intercambiar en cualquier momento, para protegerse contra ruptura criptográficas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Verifique que los modos de bloque inseguros conocidos (i.e., ECB, etc.), los modos de relleno (i.e. PKCS#1 v1.5, etc.), los cifrados con tamaños de bloque pequeños (i.e. Triple-DES, Blowfish, etc.), y los algoritmos de hashing débiles (i.e. MD5, SHA1, etc.) no se utilizan a menos que sea necesario para la compatibilidad con versiones anteriores. | | ✓ | ✓ | 326 |\n| **6.2.6** | Verifique que los \"nonces\", los vectores de inicialización y otros números de uso único no se deben usar más de una vez con una clave de cifrado determinada. El método de generación debe ser adecuado para el algoritmo que se está utilizando. | | ✓ | ✓ | 326 |\n| **6.2.7** | Verifique que los datos cifrados se autentiquen a través de firmas, modos de cifrado autenticados, o HMAC para asegurarse de que el texto cifrado no sea alterado por una parte no autorizada. | | | ✓ | 326 |\n| **6.2.8** | Verifique que todas las operaciones criptográficas son de tiempo constante, sin operaciones de \"cortocircuito\" en comparaciones, cálculos o devoluciones, para evitar fugas de información. | | | ✓ | 385 |\n\n## V6.3 Valores Aleatorios\n\nTrue Pseudo-random Number Generation (PRNG) es increíblemente difícil de hacer bien. Generalmente, las buenas fuentes de entropía dentro de un sistema se agotarán rápidamente si se utilizan en exceso, pero las fuentes con menos aleatoriedad pueden conducir a claves y secretos predecibles.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.3.1** | Verifique que todos los números aleatorios, nombres de archivo aleatorios, GUID aleatorios y cadenas aleatorias se generan utilizando el generador de números aleatorios criptográficamente seguro aprobado por el módulo criptográfico cuando estos valores aleatorios están destinados a no ser adivinables por un atacante. | | ✓ | ✓ | 338 |\n| **6.3.2** | Verifique que los GUID aleatorios se crean mediante el algoritmo GUID v4 y un generador de números pseudoaleatorio (CSPRNG) criptográficamente seguro. Los GUID creados con otros generadores de números pseudoaleatorios pueden ser predecibles. | | ✓ | ✓ | 338 |\n| **6.3.3** | Verifique que los números aleatorios se crean con la entropía adecuada incluso cuando la aplicación está bajo carga pesada, o que la aplicación se degrada correctamente en tales circunstancias. | | | ✓ | 338 |\n\n## V6.4 Gestión de Secretos\n\nAunque esta sección no se desmuestra facilmente con prueba de penetración, los desarrolladores deben considerar toda esta sección como obligatoria, aunque L1 falta en la mayoría de los elementos.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.4.1** | Verifique que una solución de gestión de secretos, como un almacén de claves, se utiliza para crear, almacenar, controlar el acceso y destruir secretos de forma segura. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Verifique que el material de claves no está expuesto a la aplicación, sino que utiliza un módulo de seguridad aislado como un almacén para operaciones criptográficas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:51.973273"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x15-V7-Error-Logging.md", "content": "# V7 Manejo y Registro de Errores\n\n## Objetivo de Control\n\nEl objetivo principal del control y registro de errores es proporcionar información útil para el usuario, los administradores y los equipos de respuesta a incidentes. El objetivo no es crear cantidades masivas de registros, sino registros de alta calidad, con más señal que el ruido descartado.\n\nLos registros de alta calidad a menudo contendrán datos confidenciales y deben protegerse según las leyes o directivas locales de privacidad de datos. Esto debe incluir:\n\n* No recopilar o registrar información confidencial a menos que sea específicamente necesario.\n* Garantizar que toda la información registrada se maneje de forma segura y protegida según su clasificación de datos.\n* Asegurarse de que los registros no se almacenan para siempre, pero tienen una duración absoluta que es lo más corta posible.\n\nSi los registros contienen datos privados o confidenciales, la definición de cuyos varían de un país a otro, los registros se convierten en parte de la información más sensible de la aplicación y, por lo tanto, son muy atractivos para los atacantes por derecho propio.\n\nTambién es importante asegurarse de que la aplicación falla de forma segura y que los errores no revelan información innecesaria.\n\n## V7.1 Contenido de Registro de Log\n\nEl registro de log de información confidencial es peligroso: los registros se clasifican a sí mismos, lo que significa que deben cifrarse, estar sujetos a políticas de retención y deben divulgarse en las auditorías de seguridad. Asegúrese de que solo la información necesaria se mantiene en logs, y ciertamente no se registre información de pagos, credenciales (incluidos los tokens de sesión), información confidencial o de identificación personal.\n\nV7.1 cubre OWASP Top 10 2017:A10. Como 2017:A10 y esta sección no son comprobables por prueba de penetración, es importante para:\n\n* Desarrolladores para asegurar el cumplimiento total de esta sección, como si todos los elementos estuvieran marcados como L1.\n* Probadores de penetración para validar el cumplimiento total de todos los elementos en V7.1 a través de entrevistas, capturas de pantalla o aserción.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.1.1** | Verifique que la aplicación no registra las credenciales ni los detalles de pago. Los tokens de sesión solo deben almacenarse en registros de forma irreversible y hasheados. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Verifique que la aplicación no registra otros datos confidenciales tal como se definen en las leyes de privacidad locales o la política de seguridad pertinente. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Verifique que la aplicación registra eventos relevantes para la seguridad, incluidos los eventos de autenticación correctos y con errores, los errores de control de acceso, los errores de deserialización y los errores de validación de entrada. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Verifique que cada evento de registro incluye la información necesaria que permitiría una investigación detallada de la escala de tiempo cuando se produce un evento. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Procesamiento del Log\n\nEl registro oportuno es fundamental para los eventos de auditoría, el triage y la escalada. Asegúrese de que los registros de la aplicación sean claros y se puedan monitorear y analizar fácilmente, ya sea localmente o el registro se envíe a un sistema de monitoreo remoto.\n\nV7.2 cubre OWASP Top 10 2017:A10. Como 2017:A10 y esta sección no son comprobables por prueba de penetración, es importante para:\n\n* Desarrolladores para asegurar el cumplimiento total de esta categoría, como si todos los elementos estuvieran marcados como L1.\n* Probadores de penetración para validar el cumplimiento completo de todos los elementos en V7.2 a través de entrevistas, capturas de pantalla o aserción.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.2.1** | Verifique que se registran todas las decisiones de autenticación, sin almacenar tokens o contraseñas de sesión confidenciales. Esto debe incluir solicitudes con los metadatos relevantes necesarios para las investigaciones de seguridad. | | ✓ | ✓ | 778 |\n| **7.2.2** | Verifique que se pueden registrar todas las decisiones de control de acceso y que se registran todas las decisiones erróneas. Esto debe incluir solicitudes con los metadatos pertinentes necesarios para las investigaciones de seguridad. | | ✓ | ✓ | 285 |\n\n## V7.3 Protección de Logs\n\nLos registros que se pueden modificar o eliminar trivialmente son inútiles para investigaciones y procesamientos. La divulgación de registros puede exponer detalles internos sobre la aplicación o los datos que contiene. Se debe tener cuidado al proteger los registros de la divulgación, modificación o eliminación no autorizadas.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.3.1** | Verifique que todos los componentes de registro codifiquen adecuadamente los datos para evitar la inyección de registros. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [ELIMINADO, DUPLICADO DE 7.3.1] | | | | |\n| **7.3.3** | Verifique que los registros de seguridad están protegidos contra el acceso y la modificación no autorizados. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Verifique que la fuente donde se lee el tiempo están sincronizados con la hora y la zona horaria correctas. Considere firmemente el registro solo en UTC si los sistemas son globales para ayudar con el análisis forense posterior al incidente. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nNota: La codificación de registros (7.3.1) es difícil de probar y revisar mediante herramientas dinámicas automatizadas y pruebas de penetración, pero los arquitectos, desarrolladores y revisores de código fuente deben considerarlo un requisito de L1.\n\n## V7.4 Control de Errores\n\nEl propósito del control de errores es permitir que la aplicación proporcione eventos relevantes para la seguridad para el monitoreo, el triage y la escalada. El propósito no es crear registros. Al registrar eventos relacionados con la seguridad, asegúrese de que hay un propósito para el registro y que se puede distinguir por SIEM o software de análisis.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.4.1** | Verifique que se muestra un mensaje genérico cuando se produce un error inesperado o sensible a la seguridad, potencialmente con un identificador único que el personal de soporte técnico puede usar para investigar. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Verifique que el control de excepciones (o un equivalente funcional) se utiliza en todo el código base para tener en cuenta las condiciones de error esperadas e inesperadas. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Verifique que se define un controlador de errores de \"último recurso\" que detectará todas las excepciones no controladas. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nNota: Ciertos lenguajes, como Swift and Go - y a través de la práctica de diseño común - muchos lenguajes funcionales, no admiten excepciones o controladores de eventos de último recurso. En este caso, los arquitectos y desarrolladores deben usar una forma amigable de patrón, lenguaje o framework para garantizar que las aplicaciones puedan controlar de forma segura eventos excepcionales, inesperados o relacionados con la seguridad.\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:52.090381"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x16-V8-Data-Protection.md", "content": "# V8 Protección de Datos\n\n## Objetivo de Control\n\nHay tres elementos clave para una protección de datos sólida: Confidencialidad, Integridad y Disponibilidad (CIA; por sus siglas en inglés). Este estándar supone que la protección de datos se aplica en un sistema de confianza, como un servidor, que se ha reforzado y tiene suficientes protecciones.\n\nLas aplicaciones tienen que asumir que todos los dispositivos de usuario están comprometidos de alguna manera. Cuando una aplicación transmite o almacena información confidencial en dispositivos inseguros, como ordenadores compartidos, teléfonos y tabletas, la aplicación es responsable de garantizar que los datos almacenados en estos dispositivos estén cifrados y no puedan obtenerse, modificarse o divulgarse de forma ilícita.\n\nAsegúrese de que una aplicación verificada cumple los siguientes requisitos de protección de datos de alto nivel:\n\n* Confidencialidad: Los datos deben protegerse de la observación o divulgación no autorizada tanto en tránsito como cuando se almacenan.\n* Integridad: Los datos deben protegerse de ser creados, alterados o eliminados maliciosamente por atacantes no autorizados.\n* Disponibilidad: los datos deben estar disponibles para los usuarios autorizados según sea necesario.\n\n## V8.1 Protección General de Datos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.1.1** | Verifique que la aplicación protege los datos confidenciales de la caché en componentes del servidor, como balanceadores de carga y cachés de aplicaciones. | | ✓ | ✓ | 524 |\n| **8.1.2** | Verifique que todas las copias almacenadas en caché o temporales de datos confidenciales almacenados en el servidor están protegidas contra el acceso no autorizado o purgadas/invalidadas después de que el usuario autorizado acceda a los datos confidenciales. | | ✓ | ✓ | 524 |\n| **8.1.3** | Verifique que la aplicación minimiza el número de parámetros de una solicitud, como campos ocultos, variables Ajax, cookies y valores de encabezado. | | ✓ | ✓ | 233 |\n| **8.1.4** | Verifique que la aplicación puede detectar y alertar sobre números anormales de solicitudes, como por IP, usuario, total por hora o día, o lo que tenga sentido para la aplicación. | | ✓ | ✓ | 770 |\n| **8.1.5** | Verifique que se realizan copias de seguridad periódicas de datos importantes y que se realizan pruebas de la restauración de datos. | | | ✓ | 19 |\n| **8.1.6** | Verifique que las copias de seguridad se almacenan de forma segura para evitar que los datos sean robados o se dañen. | | | ✓ | 19 |\n\n## V8.2 Protección de datos del lado del cliente\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.2.1** | Verifique que la aplicación establece suficientes encabezados anti-almacenamiento en caché para que los datos confidenciales no se almacenen en caché en los navegadores modernos. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Verifique que los datos almacenados en el almacenamiento del navegador (como localStorage, sessionStorage, IndexedDB o cookies) no contengan datos confidenciales. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Verifique que los datos autenticados se borran del almacenamiento del cliente, como el DOM del explorador, después de que se termine el cliente o la sesión. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Datos Privados Confidenciales\n\nEsta sección ayuda a proteger los datos confidenciales de la creación, lectura, actualización o eliminación sin autorización, especialmente en cantidades masivas.\n\nEl cumplimiento de esta sección implica el cumplimiento del control de acceso V4 y, en particular, del V4.2. Por ejemplo, para protegerse contra actualizaciones no autorizadas o divulgación de información personal confidencial requiere el cumplimiento de V4.2.1. Por favor, cumpla con esta categoría y V4 para la cobertura completa.\n\nNota: Las regulaciones y leyes de privacidad, como los Principios de Privacidad de Australia APP-11 o GDPR, afectan directamente a la forma en que las aplicaciones deben abordar la implementación del almacenamiento, el uso y la transmisión de información personal confidencial. Esto va desde sanciones severas hasta simples consejos. Consulte sus leyes y regulaciones locales y consulte a un especialista en privacidad o abogado calificado según sea necesario.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.3.1** | Verifique que los datos confidenciales se envían al servidor en el cuerpo o encabezados del mensaje HTTP y que los parámetros de cadena de consulta de cualquier verbo HTTP no contienen datos confidenciales. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Verifique que los usuarios tienen un método para eliminar o exportar sus datos sobre demanda (on demand). | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Verifique que se proporciona a los usuarios un lenguaje claro con respecto a la recopilación y el uso de la información personal suministrada y que los usuarios han proporcionado el consentimiento de aceptación para el uso de esos datos antes de que se utilicen de alguna manera. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Verifique que se han identificado todos los datos confidenciales creados y procesados por la aplicación, y asegúrese de que existe una política sobre cómo tratar los datos confidenciales. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Verifique que el acceso a los datos confidenciales se audita (sin registrar los datos confidenciales en sí), si los datos se recopilan en las directivas de protección de datos pertinentes o donde se requiere el registro del acceso. | | ✓ | ✓ | 532 |\n| **8.3.6** | Verifique que la información confidencial contenida en la memoria se sobrescribe tan pronto como ya no sea necesaria para mitigar los ataques de volcado de memoria, utilizando ceros o datos aleatorios. | | ✓ | ✓ | 226 |\n| **8.3.7** | Verifique que la información confidencial o privada que se requiere que se cifre, se cifra mediante algoritmos aprobados que proporcionan confidencialidad e integridad. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Verifique que la información personal confidencial está sujeta a la clasificación de retención de datos, de forma que los datos antiguos o desactualizados se eliminen automáticamente, según una programación o según la situación lo requiera. | | ✓ | ✓ | 285 |\n\nAl considerar la protección de datos, una consideración principal debe ser la extracción masiva o la modificación o el uso excesivo. Por ejemplo, muchos sistemas de redes sociales solo permiten a los usuarios agregar 100 nuevos amigos por día, pero el sistema del que provienen estas solicitudes no es importante. Una plataforma bancaria podría querer bloquear más de 5 transacciones por hora transfiriendo más de 1000 euros de fondos a instituciones externas. Es probable que los requisitos de cada sistema sean muy diferentes, por lo que decidirse por \"anormal\" debe tener en cuenta el modelo de amenaza y el riesgo empresarial. Los criterios importantes son la capacidad de detectar, disuadir o preferentemente bloquear tales acciones masivas anormales.\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:52.175788"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x17-V9-Communications.md", "content": "# V9 Comunicación\n\n## Objetivo de Control\n\nAsegúrese de que una aplicación verificada cumpla con los siguientes requisitos de alto nivel:\n\n* Requiere TLS o cifrado fuerte, independientemente de la sensibilidad del contenido.\n* Siga la guía más reciente, que incluye:\n  * Consejos de configuración\n  * Algoritmos y cifrados preferidos\n* Evite los algoritmos y cifrados débiles o que pronto quedarán obsoletos, excepto como último recurso\n* Deshabilite los algoritmos en desuso, o que se sabe son de cifrado inseguro.\n\nDentro de estos requisitos:\n\n* Manténgase actualizado con los consejos recomendados por la industria sobre la configuración segura de TLS, ya que cambia con frecuencia (a menudo debido a fallas catastróficas en los algoritmos y cifrados existentes).\n* Utilice las versiones más recientes de las herramientas de revisión de la configuración de TLS para configurar el orden preferido y la selección de algoritmos.\n* Verifique su configuración periódicamente para asegurarse de que la comunicación segura esté siempre presente y sea efectiva.\n\n## V9.1 Seguridad de la Comunicación del Cliente\n\nAsegúrese de que todos los mensajes de los clientes se envíen a través de redes cifradas, utilizando TLS 1.2 o posterior.\nUtilice herramientas actualizadas para revisar la configuración del cliente de forma regular.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.1.1** | Verifique que TLS se utilice para toda la conectividad del cliente y que no recurra a comunicaciones inseguras o no cifradas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Verifique con herramientas de prueba TLS actualizadas que solo estén habilitados los conjuntos de cifrado fuertes, con los conjuntos de cifrado más fuertes configurados como preferidos. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Verifique que solo estén habilitadas las últimas versiones recomendadas del protocolo TLS, como TLS 1.2 y TLS 1.3. La última versión del protocolo TLS debería ser la opción preferida. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Seguridad de la Comunicación del Servidor\n\nLas comunicaciones de servidor son algo más que HTTP. Las conexiones seguras hacia y desde otros sistemas, como sistemas de supervisión, herramientas de administración, acceso remoto y ssh, middleware, bases de datos, mainframes, sistemas de origen externo o de socios, deben estar en su lugar. Todos estos deben ser cifrados para evitar \"dureza exterior, trivialmente fácil de interceptar en el interior\".\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.2.1** | Verifique que las conexiones hacia y desde el servidor utilizan certificados TLS de confianza. Cuando se utilizan certificados generados internamente o autofirmados, el servidor debe configurarse para que solo confíe en las CA internas específicas y en los certificados autofirmados específicos. Todos los demás deben ser rechazados. | | ✓ | ✓ | 295 |\n| **9.2.2** | Verifique que las comunicaciones cifradas, como TLS, se utilizan para todas las conexiones entrantes y salientes, incluidos los puertos de administración, monitoreo, la autenticación, la API o las llamadas a servicios web, la base de datos, la nube, el serverless, el mainframe, ya sean externos o de conexiones de asociados. El servidor no debe volver a protocolos inseguros o no cifrados. | | ✓ | ✓ | 319 |\n| **9.2.3** | Verifique que se autentican todas las conexiones cifradas a sistemas externos que implican información o funciones confidenciales. | | ✓ | ✓ | 287 |\n| **9.2.4** | Verifique que la adecuada revocación de certificación, como la comprobación de Online Certificate Status Protocol (OCSP), esté habilitada y configurada. | | ✓ | ✓ | 299 |\n| **9.2.5** | Verifique que se hace logging de errores de conexión TLS de back-end. | | | ✓ | 544 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Notas sobre \"Modos aprobados de TLS\":\n    * En el pasado, la ASVS se refería al estándar estadounidense FIPS 140-2, pero como estándar global, aplicar los estándares estadounidenses puede ser difícil, contradictorio o confuso de aplicar.\n    * Un mejor método para lograr el cumplimiento de la sección 9.1 sería revisar guías como [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) o [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/), y utilice herramientas de evaluación de TLS conocidas y actualizadas para obtener el nivel de seguridad deseado.\n", "timestamp": "2025-10-24T11:39:52.299043"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x18-V10-Malicious.md", "content": "# V10 Código Malicioso\n\n## Objetivo de Control\n\nAsegúrese de que el código cumple los siguientes requisitos de alto nivel:\n\n* La actividad maliciosa se controla de forma segura y adecuada para no afectar al resto de la aplicación.\n* No tiene bombas de tiempo u otros ataques basados en el tiempo.\n* No permite \"llamar a casa\" a destinos maliciosos o no autorizados.\n* No tiene puertas traceras, huevos de pascua, salami attacks, rootkits o código no autorizado que pueda ser controlado por un atacante.\n\nEncontrar código malicioso es una prueba de lo negativo, que es imposible de validar por completo. Se deben realizar los mejores esfuerzos para asegurarse de que el código fuente no contiene código malicioso o funcionalidades no deseadas.\n\n## V10.1 Integridad de Código\n\nLa mejor defensa contra el código malintencionado es \"confiar, pero verificar\". Introducir código no autorizado o malicioso en el código fuente es a menudo un delito en muchas jurisdicciones. Las políticas y procedimientos deben dejar claras las sanciones relativas al código malintencionado.\n\nLos lideres de áreas de desarrolladores deben revisar regularmente las comprobaciones de código, especialmente aquellas que podrían tener acceso a las funciones de tiempo, I/O o funciones de red.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.1.1** | Verifique que se está utilizando una herramienta de análisis de código que puede detectar código potencialmente malintencionado, como funciones de tiempo, operaciones de archivos no seguras y conexiones de red. | | | ✓ | 749 |\n\n## V10.2 Búsqueda de Código Malicioso\n\nEl código malicioso es extremadamente raro y es difícil de detectar. La revisión manual línea por línea de código puede ayudar a buscar bombas lógicas, pero incluso el revisor de código más experimentado tendrá problemas para encontrar código malicioso, incluso si supiera que existe.\n\nCumplir con esta sección no es posible sin acceso completo al código fuente, incluidas las bibliotecas de terceros.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.2.1** | Verifique que el código fuente de la aplicación y las bibliotecas de terceros no contienen capacidades no autorizadas de recopilación de datos o de \"llamadas a casa\". Cuando detecte dicha funcionalidad, obtenga el permiso explicito del usuario para que sea operado así, antes de recopilar cualquier dato. | | ✓ | ✓ | 359 |\n| **10.2.2** | Verifique que la aplicación no solicite permisos innecesarios o excesivos para funciones o sensores relacionados con la privacidad, como contactos, cámaras, micrófonos o ubicación. | | ✓ | ✓ | 272 |\n| **10.2.3** | Verifique que el código fuente de la aplicación y las bibliotecas de terceros no contienen puertas traseras, como cuentas, claves o código ofuscado, blobs binarios no documentados, rootkits o anti-depuración, características de depuración inseguras o de otro modo funcionalidades desactualizadas, inseguras u ocultas que podrían usarse maliciosamente si se descubren. | | | ✓ | 507 |\n| **10.2.4** | Verifique que el código fuente de la aplicación y las bibliotecas de terceros no contienen bombas de tiempo mediante la búsqueda de funciones relacionadas con la fecha y la hora. | | | ✓ | 511 |\n| **10.2.5** | Verifique que el código fuente de la aplicación y las bibliotecas de terceros no contienen código malintencionado, como salami attacks, logic bypasses o bombas lógicas. | | | ✓ | 511 |\n| **10.2.6** | Verifique que el código fuente de la aplicación y las bibliotecas de terceros no contienen huevos de pascua ni ninguna otra funcionalidad potencialmente no deseada. | | | ✓ | 507 |\n\n## V10.3 Integridad de Aplicación\n\nUna vez que se implementa una aplicación, todavía se puede insertar código malintencionado. Las aplicaciones deben protegerse contra ataques comunes, como la ejecución de código sin firmar desde orígenes que no son de confianza y tomas de control de subdominios.\n\nCumplir con esta categoría, es probable que sea una tarea operativa y continua.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.3.1** | Verifique si la aplicación tiene una característica de actualización automática de cliente o servidor, las actualizaciones deben obtenerse a través de canales seguros y firmados digitalmente. El código de actualización debe validar la firma digital de la actualización antes de instalar o ejecutar la actualización. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Verifique que la aplicación emplea protecciones de integridad, como la firma de código o la integridad de subrecursos. La aplicación no debe cargar ni ejecutar código de fuentes que no sean de confianza, como la carga de includes, plugins, módulos, código o bibliotecas de fuentes que no sean de confianza o de Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Verifique que la aplicación tiene protección contra takeovers de subdominios si la aplicación se basa en entradas DNS o subdominios DNS, como nombres de dominio expirados, punteros DNS obsoletos o CNAME, proyectos expirados en repositorios de código fuente públicos o API de nube transitorias, funciones serverless o buckets de almacenamiento (*autogen-bucket-id*.cloud.example.com) o similares. Las protecciones pueden incluir asegurarse de que los nombres DNS utilizados por las aplicaciones se comprueban regularmente para comprobar su caducidad o cambio. | ✓ | ✓ | ✓ | 350 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:52.411678"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x19-V11-BusLogic.md", "content": "# V11 Lógica de Negocio\n\n## Objetivo de Control\n\nAsegúrese de que una aplicación verificada cumple los siguientes requisitos de alto nivel:\n\n* El flujo de lógica de negocios es secuencial, se procesa en orden y no se puede omitir.\n* La lógica empresarial incluye límites para detectar y prevenir ataques automatizados, como transferencias continuas de montos pequeños, o agregar un millón de amigos de uno en uno, etc.\n* Los flujos de lógica de negocios de alto valor han considerado casos de abuso y actores malintencionados, y tienen protecciones contra la suplantación, manipulación, divulgación de información y ataques de elevación de privilegios.\n\n## V11.1 Seguridad de la Lógica de Negocio\n\nLa seguridad de la lógica de negocio es tan individual en todas las aplicaciones, que ningún checklist se puede aplicar. La seguridad de la lógica empresarial debe diseñarse para proteger contra amenazas externas probables: no se puede agregar mediante firewalls de aplicaciones web ni comunicaciones seguras. Recomendamos el uso de modelado de amenazas durante los sprints de diseño, por ejemplo, utilizando la herramienta Cornucopia OWASP o herramientas similares.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **11.1.1** | Verificar que la aplicación solo procesará flujos de la lógica de negocio para el mismo usuario en orden de pasos secuenciales y sin omitir pasos.| ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Verificar que la aplicación solo procesará flujos de lógica de negocios con todos los pasos que se procesan en tiempo humano realista, es decir, las transacciones no se envían demasiado rápido.| ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Verificar que la aplicación tiene límites adecuados para acciones o transacciones de negocio específicas, y que se aplican correctamente con base en los usuarios. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Verifique que la aplicación tenga controles anti-automatización para proteger contra llamadas excesivas, como exfiltración masiva de datos, solicitudes de lógica empresarial, carga de archivos o ataques de denegación de servicio. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Verificar que la aplicación tiene límites de lógica empresarial o validación para protegerse contra riesgos o amenazas empresariales probables, identificados mediante el modelado de amenazas o metodologías similares. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Verifique que la aplicación no tenga problemas de \"Time Of Check to Time Of Use\" (TOCTOU) u otras race conditions para operaciones sensibles. | | ✓ | ✓ | 367 |\n| **11.1.7** | Verificar que la aplicación supervisa eventos o actividades inusuales desde una perspectiva de lógica de negocios. Por ejemplo, los intentos de realizar acciones fuera de servicio o acciones que un usuario normal nunca intentaría. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Verificar que la aplicación tiene alertas configurables cuando se detectan ataques automatizados o actividad inusual. | | ✓ | ✓ | 390 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* Anti-automation can be achieved in many ways, including the use of [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) can also help with Attack Detection and Response.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:52.481514"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x20-V12-Files-Resources.md", "content": "# V12 Archivos y Recursos\n\n## Objetivo de Control\n\nAsegúrese de que una aplicación verificada cumple los siguientes requisitos de alto nivel:\n\n* Los datos de archivo que no son de confianza deben manejarse en consecuencia de una manera segura.\n* Los datos de archivos que no son de confianza obtenidos de fuentes no confiables se almacenan fuera de la raíz web y con permisos limitados.\n\n## V12.1 Carga de Archivos\n\nAunque las bombas zip son eminentemente comprobables utilizando técnicas de prueba de penetración, se consideran L2 y superiores para fomentar la consideración de diseño y desarrollo con pruebas manuales cuidadosas, y para evitar pruebas de penetración automatizadas o del tipo manual pero no calificadas de una condición de denegación de servicio.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.1.1** | Verifique que la aplicación no aceptará archivos grandes que puedan llenar el almacenamiento o provocar una denegación de servicio. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Verifique que la aplicación compruebe los archivos comprimidos (p. ej. zip, gz, docx, odt) contra el tamaño máximo sin comprimir permitido y con el número máximo de archivos antes de descomprimir el archivo. | | ✓ | ✓ | 409 |\n| **12.1.3** | Verifique que se aplica una cuota de tamaño de archivo y un número máximo de archivos por usuario para asegurarse de que un solo usuario no puede llenar el almacenamiento con demasiados archivos o archivos excesivamente grandes. | | ✓ | ✓ | 770 |\n\n## V12.2 Integridad de Archivos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.2.1** | Verifique que los archivos obtenidos de orígenes que no son de confianza se validan para que sean del tipo esperado en función del contenido del archivo. | | ✓ | ✓ | 434 |\n\n## V12.3 Ejecución de Archivos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.3.1** | Verifique que los metadatos del nombre de archivo enviados por el usuario no se utilizan directamente por los sistemas de archivos del sistema o del marco de trabajo y que se utiliza una API de dirección URL para proteger contra el recorrido de ruta de acceso. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Verifique que los metadatos del nombre de archivo enviados por el usuario se validan o ignoran para evitar la divulgación, creación, actualización o eliminación de archivos locales (LFI). | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Verifique que los metadatos del nombre de archivo enviados por el usuario se validan o omiten para evitar la divulgación o ejecución de archivos remotos a través de ataques de inclusión remota de archivos (RFI) o falsificación de solicitudes del lado del servidor (SSRF). | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Verifique que la aplicación protege contra la descarga de archivos reflectantes (RFD) validando o ignorando los nombres de archivo enviados por el usuario en un parámetro JSON, JSONP o URL, el encabezado Content-Type de respuesta debe establecerse en text/plain y el encabezado Content-Disposition debe tener un nombre de archivo fijo. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Verifique que los metadatos de archivos que no son de confianza no se utilizan directamente con la API del sistema o las bibliotecas, para proteger contra la inyección de comandos del sistema operativo. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Verifique que la aplicación no incluye ni ejecuta funcionalidad desde orígenes que no son de confianza, como redes de distribución de contenido no verificadas, bibliotecas de JavaScript, bibliotecas node npm o archivos DLL server-side. | | ✓ | ✓ | 829 |\n\n## V12.4 Almacenamiento de Archivos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.4.1** | Verifique que los archivos obtenidos de fuentes no confiables se almacenen fuera de la raíz web, con permisos limitados. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Verifique que los escáneres antivirus analicen los archivos obtenidos de fuentes no confiables para evitar la carga y el servicio de contenido malicioso conocido. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Descarga de Archivos\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.5.1** | Verifique que la capa web está configurado para transmitir solo archivos con extensiones específicas, para evitar la filtración accidental de información o código fuente. Por ejemplo, los archivos de copia de seguridad (p. ej. .bak), los archivos de trabajo temporales (p. ej. .swp), los archivos comprimidos (.zip, .tar.gz, etc.) y otras extensiones utilizadas comúnmente por los editores deben bloquearse a menos que sea necesario. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Verifique que las solicitudes directas a los archivos cargados nunca se ejecutarán como contenido HTML/JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 Protección SSRF\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.6.1** | Verifique que el servidor web o de aplicaciones está configurado con una lista de permisos de recursos o sistemas a los que el servidor puede enviar solicitudes o cargar datos o archivos. | ✓ | ✓ | ✓ | 918 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:52.610523"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x21-V13-API.md", "content": "# V13 API y Servicios Web\n\n## Objetivo de Control\n\nAsegúrese de que una aplicación verificada que utiliza APIs de capa de servicio de confianza (normalmente mediante JSON o XML o GraphQL) tiene:\n\n* Autenticación adecuada, gestión de sesiones y autorización de todos los servicios web.\n* Validación de entrada de todos los parámetros que transitan de un nivel de confianza inferior a superior.\n* Controles de seguridad eficaces para todos los tipos de API, incluida la nube y los Serverless API\n\nLea este capítulo en combinación con todos los demás capítulos de este mismo nivel; ya no duplicamos los problemas de autenticación o administración de sesiones de API.\n\n## V13.1 Seguridad Genérica de Servicios Web\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.1.1** | Verifique que todos los componentes de la aplicación utilizan las mismas codificaciones y analizadores para evitar el análisis de ataques que explotan un comportamiento de análisis de archivos o URI diferente que se podría usar en ataques SSRF y RFI. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [DELETED, DUPLICATE OF 4.3.1] | | | | |\n| **13.1.3** | Verifique que las direcciones URL de la API no exponen información confidencial, como API keys, los tokens de sesión, etc. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Verifique que las decisiones de autorización se toman en el URI, se aplican mediante seguridad programática o declarativa en el controlador o enrutador, y en el nivel de recursos, se aplican mediante permisos basados en modelos. | | ✓ | ✓ | 285 |\n| **13.1.5** | Verifique que las solicitudes que contienen tipos de contenido inesperados o contenido que falta se rechazan con encabezados adecuados (estado de respuesta HTTP 406 Inaceptable o 415 Tipo de medio no compatible). | | ✓ | ✓ | 434 |\n\n## V13.2 Servicio Web RESTful\n\nLa validación del esquema JSON se encuentra en una etapa preliminar de estandarización (ver referencias). Cuando considere usar la validación del esquema JSON, que es la mejor práctica para los servicios web RESTful, considere usar estas estrategias de validación de datos adicionales en combinación con la validación del esquema JSON:\n\n* Análisis de la validación del objeto JSON, ya sea que faltan elementos o hay elementos adicionales.\n* Validación de los valores de objeto JSON mediante métodos de validación de entrada estándar, como el tipo de datos, el formato de datos, la longitud, etc.\n* y la validación formal del esquema JSON.\n\nUna vez que se formalice el estándar de validación de esquemas JSON, ASVS actualizará sus consejos en esta área. Supervise cuidadosamente las bibliotecas de validación de esquemas JSON en uso, ya que tendrán que actualizarse periódicamente hasta que se formalice el estándar y se eliminan los errores de las implementaciones de referencia.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.2.1** | Verifique que los métodos HTTP RESTful habilitados son una opción válida para el usuario o la acción, como impedir que los usuarios normales usen DELETE o PUT en recursos o API protegidos. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Verifique que la validación del esquema JSON está en su lugar y se comprueba antes de aceptar la entrada. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Verifique que los servicios web RESTful que utilizan cookies están protegidos contra la falsificación de solicitudes entre sitios, mediante el uso de una o más de las siguientes formas: patrón de cookies de doble envío, \"nonces\" CSRF o comprobaciones de encabezado de solicitud de origen. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [DELETED, DUPLICATE OF 11.1.4] | | | | |\n| **13.2.5** | Verifique que los servicios REST comprueben explícitamente que el tipo de contenido entrante sea el esperado, como application/xml o application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Verifique que los encabezados de mensaje y la carga útil (payload) son confiables y no se modifican en tránsito. Requerir un cifrado seguro para el transporte (solo TLS) puede ser suficiente en muchos casos, ya que proporciona confidencialidad y protección de integridad. Las firmas digitales por cada mensaje pueden proporcionar una garantía adicional sobre las protecciones de transporte para aplicaciones de alta seguridad, pero conllevan complejidad y riesgos adicionales para compensar los beneficios. | | ✓ | ✓ | 345 |\n\n## V13.3 Servicio Web SOAP\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.3.1** | Verifique que la validación del esquema XSD tiene lugar para garantizar un documento XML formado correctamente, seguido de la validación de cada campo de entrada antes de que se realice cualquier procesamiento de esos datos. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Verifique que el payload del mensaje está firmada mediante WS-Security para garantizar un transporte fiable entre el cliente y el servicio. | | ✓ | ✓ | 345 |\n\nNota: Debido a los problemas con los ataques XXE contra los DTD, la validación DTD no se debe utilizar, y debe deshabilitar la evaluación DTD del framework, según los requisitos establecidos en la configuración V14.\n\n## V13.4 GraphQL\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.4.1** | Verifique que se utiliza una lista de permisos de consulta o una combinación de limitación de profundidad y limitación de cantidad para evitar que GraphQL o la expresión de la capa de datos provoque una denegación de servicio (DoS) como resultado de costosas consultas anidadas. Para escenarios más avanzados, se debe usar el análisis de costos de consulta. | | ✓ | ✓ | 770 |\n| **13.4.2** | Verifique que GraphQL u otra lógica de autorización de capa de datos podría implementarse en la capa de lógica de negocio en lugar de la capa GraphQL. | | ✓ | ✓ | 285 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:52.668943"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x22-V14-Config.md", "content": "# V14 Configuración\n\n## Objetivo de Control\n\nAsegúrese de que una aplicación verificada tiene:\n\n* Un entorno de compilación seguro, repetible y automatizable.\n* La aplicación no incluye la biblioteca de terceros reforzada, la dependencia y la administración de la configuración, de modo que la aplicación no incluya componentes obsoletos o no seguros.\n\nLa configuración de la aplicación \"desde fábrica\" debe ser segura para estar en Internet, lo que significa una configuración segura desde la caja.\n\n## V14.1 Compilación y Despliegue\n\nLas pipelines de compilación son la base para la seguridad repetible - cada vez que se detecta algo inseguro, se puede resolver en el código fuente, compilar o desplegar scripts y probarse automáticamente. Enfatizamos el uso de pipelines de compilación con comprobaciones automáticas de seguridad y chequeo de dependencia que alerten o interrumpen la compilación para evitar que los problemas de seguridad conocidos se implementen en producción. Los pasos manuales realizados de forma irregular directamente conducen a errores de seguridad evitables.\n\nA medida que la industria se encamina hacia un modelo DevSecOps, es importante garantizar la disponibilidad continua y la integridad de la implementación y la configuración para lograr un estado \"bueno conocido\". En el pasado, si un sistema fuera hackeado, tardaría días o meses en demostrar que no se habían producido más intrusiones. Hoy en día, con la llegada de la infraestructura definida por software, las implementaciones rápidas de A/B con zero downtime y las compilaciones automatizadas en contenedores, es posible compilar, hardenizar y desplegar continuamente un reemplazo \"bueno conocido\" para cualquier sistema comprometido.\n\nSi aún persisten modelos tradicionales, se deben tomar medidas manuales para hardenizar y hacer una copia de seguridad de esa configuración para permitir que los sistemas comprometidos se reemplacen rápidamente por sistemas de alta integridad y sin compromisos, de manera oportuna.\n\nEl cumplimiento de esta categoria ASVS requiere un sistema de compilación automatizado y acceso a scripts de compilación e implementación.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.1.1** | Verifique que los procesos de compilación y despliegue de aplicaciones se realizan de forma segura y repetible, como la automatización de CI/CD, la administración de configuración automatizada y los scripts de despliegue automatizado. | | ✓ | ✓ | |\n| **14.1.2** | Verifique que los indicadores del compilador están configurados para habilitar todas las protecciones y advertencias de desbordamiento de búfer disponibles, incluida la aleatorización de la pila, la prevención de la ejecución de datos y para interrumpir la compilación si se encuentra un puntero no seguro, memoria, cadena de formato, entero u operaciones de cadena. | | ✓ | ✓ | 120 |\n| **14.1.3** | Verifique que la configuración del servidor está hardenizada según las recomendaciones del servidor de aplicaciones y los framewors en uso. | | ✓ | ✓ | 16 |\n| **14.1.4** | Verifique que la aplicación, la configuración y todas las dependencias se pueden volver a implementar mediante scripts de implementación automatizada, crearse a partir de un runbook documentado y probado en un tiempo razonable o restaurarse a partir de copias de seguridad de forma oportuna. | | ✓ | ✓ | |\n| **14.1.5** | Verifique que los administradores autorizados pueden verificar la integridad de todas las configuraciones relevantes para la seguridad para detectar una posible manipulación. | | | ✓ | |\n\n## V14.2 Dependencias\n\nLa administración de dependencias es fundamental para el funcionamiento seguro de cualquier aplicación de cualquier tipo. No mantenerse al día con dependencias obsoletas o inseguras es la causa raíz de los ataques más grandes y costosos hasta la fecha.\n\nNota: En el nivel 1, el cumplimiento 14.2.1 se relaciona con observaciones o detecciones de bibliotecas y componentes del lado cliente y otros, en lugar del análisis de código estático en tiempo de compilación o análisis de dependencia más preciso. Estas técnicas más precisas podrían ser detectables por entrevistas, según sea necesario.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.2.1** | Verifique que todos los componentes estén actualizados, preferiblemente utilizando un comprobador de dependencias durante el tiempo de compilación. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Verifique que se eliminen todas las funciones, documentación, aplicaciones de muestra y configuraciones innecesarias. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Verifique que si los activos de la aplicación, como bibliotecas JavaScript, fuentes CSS o web, se hospedan externamente en una red de entrega de contenido (CDN) o un proveedor externo, se usa la integridad de subrecursos (SRI) para validar la integridad del activo. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Verifique que los componentes de terceros provienen de repositorios predefinidos, de confianza y mantenidos continuamente. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Verifique que se mantenga una Lista de materiales de software (SBOM; por sus siglas en inglés) de todas las bibliotecas de terceros en uso. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Verifique que la superficie de ataque se reduce mediante sandboxing o encapsular bibliotecas de terceros para exponer solo el comportamiento necesario en la aplicación. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Divulgación de Seguridad Involuntaria\n\nLas configuraciones para la producción deben endurecerse contra ataques comunes, como consolas de depuración, elevar el nivel de defensa contra los ataques de secuencias de comandos entre sitios (XSS) e inclusión remota de archivos (RFI) y eliminar las \"vulnerabilidades\" de detección de información trivial que son el sello no deseado de muchos informes de pruebas de penetración. Muchos de estos problemas rara vez se clasifican como un riesgo significativo, pero se encadenan junto con otras vulnerabilidades. Si estos problemas no están presentes de forma predeterminada, se debe elevar el nivel de defensa antes de que la mayoría de los ataques puedan realizarse exitosamente.\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.3.1** | [ELIMINADO, DUPLICADO DE 7.4.1] | | | | |\n| **14.3.2** | Verifique que los modos de depuración del servidor web o de aplicaciones y del framework de aplicaciones están deshabilitados en producción para eliminar las características de depuración, las consolas de desarrollador y las divulgaciones de seguridad no deseadas. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Verifique que los encabezados HTTP o cualquier parte de la respuesta HTTP no exponen información detallada de la versión de los componentes del sistema. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 Encabezados de Seguridad HTTP\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.4.1** | Verifique que cada respuesta HTTP contenga un encabezado de tipo de contenido. También especifique un conjunto de caracteres seguro (p. ej., UTF-8, ISO-8859-1) si los tipos de contenido son texto/*, /+xml y aplicación/xml. El contenido debe coincidir con el encabezado de tipo de contenido proporcionado. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Verifique que todas las respuestas de API contienen un encabezado Content-Disposition: attachment; filename=\"api.json\" (u otro nombre de archivo apropiado para el tipo de contenido). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Verifique que existe un encabezado de respuesta de Directiva de Seguridad de Contenido (CSP) que ayuda a mitigar el impacto de los ataques XSS como vulnerabilidades de inyección de HTML, DOM, JSON y JavaScript. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Verifique que todas las respuestas contienen un encabezado X-Content-Type-Options: nosniff. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Verifique que se incluye un encabezado Strict-Transport-Security en todas las respuestas y para todos los subdominios, como Strict-Transport-Security: max-age-15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Verifique que se incluya adecuadamente un encabezado de Referrer-Policy para evitar exponer información confidencial en la URL a través del encabezado de referencia a partes que no son de confianza. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Verifique que el contenido de una aplicación web no se puede incrustar en un sitio de terceros de forma predeterminada y que la inserción de los recursos exactos solo se permite cuando sea necesario mediante el uso adecuado de Content-Security-Polic: frame-ancestors y encabezados de respuesta X-Frame-Options. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Validación de Encabezado de Solicitud HTTP\n\n| # | Descripción | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.5.1** | Verifique que el servidor de aplicaciones solo acepta los métodos HTTP que utiliza la aplicación/API, incluidas las pre-flight OPTIONS, y los Logs/alertas en cualquier solicitud que no sea válida para el contexto de la aplicación. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Verifique que el encabezado Origin proporcionado no se utiliza para las decisiones de autenticación o control de acceso, ya que un atacante puede cambiar fácilmente el encabezado Origin. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Verifique que el encabezado Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin utiliza una estricta lista de permisos de dominios y subdominios de confianza para que coincidan entre si, y no se permita el origen \"nulo\". | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Verifique que la aplicación autentica los encabezados HTTP agregados por un proxy de confianza o dispositivos SSO, como un token de portador. | | ✓ | ✓ | 306 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering]( https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Adding Content-Disposition to API responses helps prevent many attacks based on misunderstanding on the MIME type between client and server, and the \"filename\" option specifically helps prevent [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:52.741509"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x90-Appendix-A_Glossary.md", "content": "# Apéndice A: Glosario\n\n- **Randomnización del diseño del espacio de direcciones** (ASLR) - Una técnica para dificultar la explotación de errores de corrupción de memoria.\n- **Lista de permitidos** - Una lista de datos u operaciones permitidas, por ejemplo, una lista de caracteres que pueden realizar la validación de entrada.\n- **Seguridad de la aplicación** - La seguridad a nivel de aplicación se centra en el análisis de los componentes que componen la capa de aplicación del modelo de referencia de interconexión de sistemas abiertos (modelo OSI), en lugar de centrarse, por ejemplo, en el sistema operativo subyacente o las redes conectadas.\n- **Verificación de seguridad de aplicaciones** - La evaluación técnica de una solicitud contra el ASVS de OWASP.\n- **Informe de Verificación de Seguridad en la aplicación** - Un informe que documenta los resultados generales y el análisis de soporte generado por el verificador para una aplicación determinada.\n- **Autenticación** - La verificación de la identidad reclamada de un usuario de la aplicación.\n- **Verificación Automatizada** - El uso de herramientas automatizadas (ya sea herramientas de análisis dinámico, herramientas de análisis estático o ambas) que utilizan firmas de vulnerabilidad para encontrar problemas.\n- **Prueba de Caja Negra** - Es un método de prueba de software que examina la funcionalidad de una aplicación sin mirar sus estructuras internas o su funcionamiento.\n- **Componente** - Una unidad de código autónoma, con interfaces de disco y de red asociadas que se comunica con otros componentes.\n- **Cross-Site Scripting** (XSS) - Una vulnerabilidad de seguridad que se encuentra típicamente en las aplicaciones web y que permite la inyección de scripts del lado del cliente en el contenido.\n- **Módulo criptográfico** - Hardware, software y/o firmware que implementa algoritmos criptográficos y/o genera claves criptográficas.\n- **Enumeración de debilidades comunes** (CWE) - Lista desarrollada por la comunidad, con las debilidades comunes de seguridad de software. Sirve como un lenguaje común, una vara de medir para las herramientas de seguridad de software, y como una línea base para la identificación de debilidades, la mitigación y los esfuerzos de prevención.\n- **Verificación del diseño** - La evaluación técnica de la arquitectura de seguridad de una aplicación.\n- **Prueba de seguridad de aplicaciones dinámicas** (DAST) - Las tecnologías están diseñadas para detectar las condiciones indicativas de una vulnerabilidad de seguridad en una aplicación en su estado de ejecución.\n- **Verificación dinámica** - El uso de herramientas automatizadas que utilizan firmas de vulnerabilidad para encontrar problemas durante la ejecución de una aplicación.\n- **Fast IDentity Online** (FIDO) - Conjunto de normas de autenticación que permiten utilizar una variedad de métodos de autenticación diferentes, como la biometría, los módulos de plataformas de confianza (TPM), los tokens de seguridad USB, etc.\n- **Identificador globalmente único** (GUID) - Un número de referencia único utilizado como identificador en el software.\n- **Protocolo de transferencia de hipertexto** (HTTPS) - Un protocolo de aplicación para sistemas de información hipermedia distribuidos y en colaboración. Es la base de la comunicación de datos para la World Wide Web.\n- **Claves en código duro** - Claves criptográficas que se almacenan en el sistema de archivos, ya sea en código, comentarios o archivos.\n- **Módulo de seguridad de hardware** (HSM) - Componente de hardware que puede almacenar claves criptográficas y otros secretos de forma protegida.\n- **Hibernate Query Language** (HQL) - Lenguaje de consulta de apariencia similar al SQL utilizado por la biblioteca de Hibernate ORM.\n- **Validación de entrada** - La canonicalización y validación de entradas de usuario que no son de confianza.\n- **Código malicioso** - Código introducido en una aplicación durante su desarrollo sin saberlo el propietario de la aplicación, que elude la directiva de seguridad prevista de la aplicación. No es lo mismo que un malware, asi como un virus es diferente de un gusano!\n- **Malware** - Código ejecutable que se introduce en una aplicación durante el tiempo de ejecución sin el conocimiento del usuario o administrador de la aplicación.\n- **Open Web Application Security Project** (OWASP) - La fundación OWASP es una comunidad abierta y libre en todo el mundo centrada en mejorar la seguridad de las aplicaciones de software. Nuestra misión es hacer que la seguridad de las aplicaciones sea \"visible\", para que las personas y las organizaciones puedan tomar decisiones informadas sobre los riesgos de seguridad de las aplicaciones. Ver: [https://www.owasp.org/](https://www.owasp.org/)\n- **Contraseña de un solo uso** (OTP) - Una contraseña que se genera de manera única para ser usada en una sola ocasión.\n- **Mapeo Objeto-Relación** (ORM) - Un sistema utilizado para permitir que una base de datos relacional/basada en tablas sea referenciada y consultada dentro de un programa de aplicación usando un modelo de objeto compatible con la aplicación.\n- **Password-Based Key Derivation Function 2** (PBKDF2) - Algoritmo especial unidireccional utilizado para crear una clave criptográfica robusta a partir de un texto de entrada (como una contraseña) y un valor de “salto” aleatorio adicional y que, por lo tanto, puede utilizarse para dificultar el descifrado de una contraseña fuera de línea si el valor resultante se almacena en lugar de la contraseña original.\n- **Información de identificación personal** (PII) - Es la información que puede utilizarse por sí sola o junto con otra información para identificar, contactar o localizar a una sola persona, o para identificar a un individuo en un contexto.\n- **Position-independent executable** (PIE) - Un cuerpo de código máquina que, al ser colocado en algún lugar de la memoria primaria, se ejecuta correctamente independientemente de su dirección absoluta.\n- **Infraestructura de Clave Pública** (PKI) - Un arreglo que vincula las claves públicas con las respectivas identidades de las entidades. La vinculación se establece mediante un proceso de registro y emisión de certificados en y por una autoridad de certificación (CA).\n- **Red telefónica pública conmutada** (PSTN) - La red telefónica tradicional que incluye tanto teléfonos de línea fija como móviles.\n- **Relying Party** (RP) - Generalmente una aplicación que se basa en que un usuario se ha autenticado contra un proveedor de autenticación independiente. La aplicación se basa en algún tipo de token o conjunto de afirmaciones firmadas proporcionadas por ese proveedor de autenticación para confiar en que el usuario es quien dice ser.\n- **Pruebas de seguridad de aplicaciones estáticas** (SAST) - Un conjunto de tecnologías diseñadas para analizar el código fuente de la aplicación, el código de bytes y los binarios para la codificación y las condiciones de diseño que son indicativos de vulnerabilidades de seguridad. Las soluciones SAST analizan una aplicación desde \"adentro hacia afuera\" en un estado de \"no ejecución\".\n- **Ciclo de vida del desarrollo de software** (SDLC) - El proceso paso a paso por el cual el software es desarrollado yendo desde los requerimientos iniciales hasta el despliegue y mantenimiento.\n- **Arquitectura de seguridad** - Una abstracción del diseño de una aplicación que identifica y describe dónde y cómo se utilizan los controles de seguridad, y también identifica y describe la ubicación y la sensibilidad de los datos tanto del usuario como de la aplicación.\n- **Configuración de seguridad** - La configuración en tiempo de ejecución de una aplicación que afecta a la forma en que se utilizan los controles de seguridad.\n- **Control de seguridad** - Una función o componente que realiza una comprobación de seguridad (por ejemplo, una comprobación de control de acceso) o cuando una ejecución resulta en un efecto de seguridad (por ejemplo, la generación de un registro de auditoría).\n- **Falsificación de Peticiones del Lado del Servidor** (SSRF) - Un ataque que abusa de la funcionalidad del servidor para leer o actualizar los recursos internos suministrando o modificando una URL que el código que se ejecuta en el servidor leerá o a la que enviará datos.\n- **Autenticación de inicio de sesión único** (SSO) - Esto ocurre cuando un usuario se conecta a una aplicación y luego se conecta automáticamente a otras aplicaciones sin tener que volver a autenticarse. Por ejemplo, cuando se inicia la sesión en Google, al acceder a otros servicios de Google como YouTube, Google Docs y Gmail se iniciará la sesión automáticamente.\n- **Inyección SQL** (SQLi) - Técnica de inyección de código utilizada para atacar aplicaciones basadas en datos, en la que se insertan sentencias SQL maliciosas en un punto de entrada.\n- **SVG** - Gráficos vectoriales escalables\n- **OTP basado en el tiempo** (TOTP) - Método de generación de un OTP en el que el tiempo actual actúa como parte del algoritmo para generar la contraseña.\n- **Modelado de amenazas** - Técnica que consiste en desarrollar arquitecturas de seguridad cada vez más refinadas para identificar agentes de amenazas, zonas de seguridad, controles de seguridad y activos técnicos y comerciales importantes.\n- **Seguridad de la capa de transporte** (TLS) - Protocolos criptográficos que proporcionan seguridad a las comunicaciones a través de una conexión de red.\n- **Módulo de Plataforma de Confianza** (TPM) - Un tipo de HSM que suele estar conectado a un componente de hardware más grande como una placa madre y actúa como la \"raíz de la confianza\" para ese sistema.\n- **Autenticación de dos factores** (2FA) - Esto agrega un segundo nivel de autenticación al inicio de un login en una cuenta.\n- **2do Factor Universal** (U2F) - Una de las normas creadas por FIDO específicamente para permitir el uso de una llave de seguridad USB o NFC como 2do factor de autenticación.\n- **Fragmentos de URI/URL/URL** - Un Identificador Uniforme de Recursos es una cadena de caracteres utilizada para identificar un nombre o un recurso web. Un Localizador Uniforme de Recursos se utiliza a menudo como referencia a un recurso.\n- **Verificador** - La persona o equipo que está revisando una aplicación contra los requerimientos de OWASP ASVS.\n- **Lo que ves es lo que obtienes** (WYSIWYG) - Un tipo de editor de contenido enriquecido que muestra cómo se verá realmente el contenido cuando se renderice en lugar de mostrar la codificación usada para gobernar la renderización.\n- **Certificado X.509** - Un certificado X.509 es un certificado digital que utiliza la norma internacional de infraestructura de clave pública (PKI) X.509, ampliamente aceptada, para verificar que una clave pública pertenece a la identidad del usuario, la computadora o el servicio contenido en el certificado.\n- **Entidad eXterna XML** (XXE) - Un tipo de entidad XML que puede acceder al contenido local o remoto mediante un identificador de sistema declarado. Esto puede cargarse a varios ataques de inyección.\n", "timestamp": "2025-10-24T11:39:52.869575"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x91-Appendix-B_References.md", "content": "# Apéndice B: Referencias\n\nEs más probable que los siguientes proyectos de OWASP sean útiles para los usuarios/adoptantes de esta norma:\n\n## Principales Proyectos OWASP\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## OWASP Cheat Sheet Series project\n\n[Este proyecto](https://owasp.org/www-project-cheat-sheets/) tiene una serie de hojas de trucos que serán relevantes para diferentes temas en el ASVS.\n\nHay un mapping entre cheat sheet y ASVS, que se puede encontrar aquí : [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Proyectos relacionados con la seguridad de móviles\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Proyectos de OWASP relacionados con el Internet de las cosas\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Proyectos OWASP Serverless\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Otros\n\nDel mismo modo, es más probable que los siguientes sitios web sean útiles para los usuarios/adoptantes de este estándar\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:53.018761"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/es/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/es/0x93-Appendix-C_IoT.md", "content": "# Apéndice C: Requisitos de verificación de Internet de las cosas\n\nEsta capítulo estaba originalmente en la rama principal, pero con el trabajo que el equipo de IoT de OWASP ha realizado, no tiene sentido mantener dos subprocesos diferentes en el tema. Para la versión 4.0, estamos trasladando esto al Apéndice, e instamos a todos los que lo requieran, a utilizar más bien el proyecto principal de [OWASP IoT project](https://owasp.org/www-project-internet-of-things/)\n\n## Objetivo de Control\n\nLos dispositivos integrados/IoT deben:\n\n* Tener el mismo nivel de controles de seguridad dentro del dispositivo que se encuentra en el servidor, aplicando controles de seguridad en un entorno de confianza.\n* Los datos confidenciales almacenados en el dispositivo deben realizarse de forma segura mediante el almacenamiento respaldado por hardware, como elementos seguros.\n* Todos los datos confidenciales transmitidos desde el dispositivo deben utilizar la seguridad de la capa de transporte.\n\n## Requisitos de verificación de seguridad\n\n| # | Description | L1 | L2 | L3 | Desde |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **C.1** | Verifique que las interfaces de depuración de capa de aplicación, como USB, UART y otras variantes seriales, estén deshabilitadas o protegidas por una contraseña compleja. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Verifique que las claves criptográficas y los certificados son únicos para cada dispositivo individual. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Verifique que los controles de protección de memoria como ASLR y DEP están habilitados por el sistema operativo integrado/IoT, si procede. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Verifique que las interfaces de depuración en chip como JTAG o SWD estén deshabilitadas o que el mecanismo de protección disponible esté habilitado y configurado adecuadamente. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Verifique que la ejecución de confianza está implementada y habilitada, si está disponible en el SoC o CPU del dispositivo. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Verifique que los datos confidenciales, las claves privadas y los certificados se almacenan de forma segura en un elemento seguro, TPM, TEE (Trusted Execution Environment) o se protegen mediante criptografía segura. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Verifique que las aplicaciones de firmware protegen los datos en tránsito mediante la seguridad de la capa de transporte. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Verifique que las aplicaciones de firmware validan la firma digital de las conexiones de servidor. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Verifique que las comunicaciones inalámbricas se autentiquen mutuamente. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Verifique que las comunicaciones inalámbricas se envíen a través de un canal cifrado. | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Verifique que cualquier uso de funciones C prohibidas se sustituye por las funciones equivalentes seguras adecuadas. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Verifique que cada firmware mantiene una lista de materiales de software que cataloga componentes de terceros, control de versiones y vulnerabilidades publicadas. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Verifique que todo el código, incluidos los archivos binarios de terceros, las bibliotecas y los marcos de trabajo, se revisen para las credenciales codificadas de forma hardcoded (backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Verifique que la aplicación y los componentes de firmware no son susceptibles a la inyección de comandos del sistema operativo invocando contenedores de comandos de shell, scripts o que los controles de seguridad impiden la inyección de comandos del sistema operativo. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Verifique que las aplicaciones de firmware anclan la firma digital a un servidor de confianza. | | ✓ | ✓ | 4.0 |\n| **C.16** | Verifique la presencia de la resistencia a la manipulación y/o las características de detección de manipulaciones. | | ✓ | ✓ | 4.0 |\n| **C.17** | Verifique que las tecnologías de protección de propiedad intelectual disponibles proporcionadas por el fabricante del chip estén habilitadas. | | ✓ | ✓ | 4.0 |\n| **C.18** | Verifique que los controles de seguridad estén en su lugar para obstaculizar la ingeniería inversa del firmware (por ejemplo, remueva los símbolos de depuración detallados). | | ✓ | ✓ | 4.0 |\n| **C.19** | Verifique que el dispositivo valide la firma de la imagen de arranque antes de cargarla. | | ✓ | ✓ | 4.0 |\n| **C.20** | Verifique que el proceso de actualización del firmware no es vulnerable a los ataques de tiempo de comprobación frente a los ataques de time-of-check vs time-of-use. | | ✓ | ✓ | 4.0 |\n| **C.21** | Verifique que el dispositivo utiliza la firma de código y valida los archivos de actualización de firmware antes de instalar. | | ✓ | ✓ | 4.0 |\n| **C.22** | Verifique que el dispositivo no se pueda degradar a las versiones antiguas (anti-rollback) del firmware válido. | | ✓ | ✓ | 4.0 |\n| **C.23** | Verifique el uso del generador de números pseudoaleatorios criptográficamente seguro en un dispositivo integrado (p. ej., utilizando generadores de números aleatorios proporcionados por chip). | | ✓ | ✓ | 4.0 |\n| **C.24** | Verifique que el firmware pueda realizar actualizaciones automáticas de firmware según una programación predefinida. | | ✓ | ✓ | 4.0 |\n| **C.25** | Verifique que el dispositivo borra el firmware y los datos confidenciales al detectar la manipulación o la recepción de mensajes no válidos. | | | ✓ | 4.0 |\n| **C.26** | Verifique que solo se utilicen microcontroladores que admitan la desactivación de interfaces de depuración (por ejemplo, JTAG, SWD). | | | ✓ | 4.0 |\n| **C.27** | Verifique que solo se utilizan microcontroladores que proporcionan una protección sustancial contra ataques de des encapsulación (decapping) y de canal lateral. | | | ✓ | 4.0 |\n| **C.28** | Verifique que las trazas sensibles no estén expuestas a las capas externas. | | | ✓ | 4.0 |\n| **C.29** | Verifique que la comunicación entre chips esté cifrada (p. ej., comunicación de la placa principal a la placa hija). | | | ✓ | 4.0 |\n| **C.30** | Verifique que el dispositivo usa código firmado y valida el código antes de la ejecución. | | | ✓ | 4.0 |\n| **C.31** | Verifique que la información confidencial mantenida en la memoria se sobrescribe con ceros tan pronto como ya no sea necesaria. | | | ✓ | 4.0 |\n| **C.32** | Verifique que las aplicaciones de firmware utilizan contenedores de kernel para el aislamiento entre aplicaciones. | | | ✓ | 4.0 |\n| **C.33** | Verifique que los indicadores seguros del compilador como -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap están configurados para compilaciones de firmware. | | | ✓ | 4.0 |\n| **C.34** | Verifique que los microcontroladores estén configurados con protección de código (si corresponde). | | | ✓ | 4.0 |\n\n## Referencias\n\nPara obtener más información, véase también:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:53.218317"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x01-Frontispiece.md", "content": "# Frontispice\n\n## À propos de la norme\n\nLe référentiel de vérification de la sécurité des applications est une liste d'exigences ou de tests de sécurité des applications qui peut être utilisée par les architectes, les développeurs, les testeurs, les professionnels de la sécurité, les fournisseurs d'outils et les utilisateurs pour définir, construire, tester et vérifier des applications sécurisées.\n\n## Copyright et licence\n\nVersion 4.0.3, Octobre 2021\n\n![license](../images/license.png)\n\nCopyright © 2008-2022 La Fondation OWASP. Ce document est publié sous la [licence Creative Commons Attribution ShareAlike 3.0](https://creativecommons.org/licenses/by-sa/3.0/). Pour toute réutilisation ou distribution, vous devez indiquer clairement aux autres les termes de la licence de ce travail.\n\n## Chefs de projet\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Principaux contributeurs\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Contributeurs et relecteurs\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\nS'il manque un crédit dans la liste des crédits 4.0.3 ci-dessus, veuillez enregistrer un ticket sur GitHub pour être reconnu dans les futures mises à jour.\n\nLe référentiel de vérification de la sécurité des applications repose sur les épaules des personnes concernées, de ASVS 1.0 en 2008 à 3.0 en 2016. Une grande partie de la structure et des éléments de vérification qui sont encore dans l'ASVS aujourd'hui ont été écrits à l'origine par Mike Boberski, Jeff Williams et Dave Wichers, mais il y a beaucoup plus de contributeurs. Merci à tous ceux qui y ont participé précédemment. Pour une liste complète de tous ceux qui ont contribué aux versions précédentes, veuillez consulter chaque version antérieure.\n", "timestamp": "2025-10-24T11:39:53.681123"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x02-Preface.md", "content": "# Préface\n\nBienvenue dans la version 4.0 du référentiel de vérification de la sécurité des applications (ASVS). L'ASVS est un effort communautaire visant à établir un cadre d'exigences et de contrôles de sécurité qui se concentre sur la définition des contrôles de sécurité fonctionnels et non fonctionnels requis lors de la conception, du développement et du test d'applications et de services web modernes.\n\nLa version 4.0.3 est la troisième mise à jour mineure de la v4.0 destinée à corriger les erreurs d'orthographe et à rendre les exigences plus claires sans modifier les exigences ou ajouter/supprimer des exigences.\n\nL'ASVS v4.0 est l'aboutissement des efforts de la communauté et des réactions de l'industrie au cours de la dernière décennie. Nous avons tenté de faciliter l'adoption de l'ASVS pour une variété de cas d'utilisation différents tout au long du cycle de vie du développement de logiciels sécurisés.\n\nNous pensons qu'il n'y aura très probablement jamais un accord à 100% sur le contenu de n'importe quel standard d'application web, y compris l'ASVS. L'analyse des risques est toujours subjective dans une certaine mesure, ce qui constitue un défi lorsque l'on tente de généraliser dans une norme unique. Cependant, nous espérons que les dernières mises à jour effectuées dans cette version sont un pas dans la bonne direction, et qu'elles améliorent les concepts introduits dans cette norme industrielle essentielle.\n\n## Quoi de neuf dans la version 4.0\n\nLe changement le plus important dans cette version est l'adoption des directives NIST 800-63-3 sur l'identité numérique, introduisant des contrôles d'authentification modernes, basés sur des preuves et avancés. Bien que nous nous attendions à un certain recul sur l'alignement avec une norme d'authentification avancée, nous estimons qu'il est essentiel que les normes soient alignées, principalement lorsqu'une autre norme de sécurité des applications bien considérée est fondée sur des preuves.\n\nLes normes de sécurité de l'information devraient essayer de minimiser le nombre d'exigences uniques, afin que les organisations qui s'y conforment n'aient pas à décider de contrôles concurrents ou incompatibles. Le Top 10 2017 de l'OWASP et maintenant la norme de vérification de la sécurité des applications de l'OWASP sont désormais alignés sur la norme NIST 800-63 pour l'authentification et la gestion des sessions. Nous encourageons les autres organismes de normalisation à travailler avec nous, le NIST et d'autres organismes pour parvenir à un ensemble généralement accepté de contrôles de sécurité des applications afin de maximiser la sécurité et de minimiser les coûts de mise en conformité.\n\nASVS 4.0 a été entièrement renuméroté du début à la fin. Le nouveau schéma de numérotation nous a permis de combler les lacunes de chapitres disparus depuis longtemps, et de segmenter les chapitres plus longs afin de minimiser le nombre de contrôles auxquels un développeur ou une équipe doit se conformer. Par exemple, si une application n'utilise pas JWT, toute la section sur JWT dans la gestion des sessions n'est pas applicable.\n\nLa nouveauté de la version 4.0 est une mise en correspondance complète avec le Common Weakness Enumeration (CWE), l'une des demandes de fonctionnalités les plus souvent souhaitées que nous avons eues au cours de la dernière décennie. Le mappage CWE permet aux fabricants d'outils et à ceux qui utilisent un logiciel de gestion des vulnérabilités de faire correspondre les résultats d'autres outils et des versions ASVS précédentes à la version 4.0 et aux versions ultérieures. Pour faire place à l'entrée CWE, nous avons dû retirer la colonne \"Depuis\", qui, comme nous l'avons complètement renumérotée, est moins logique que dans les versions précédentes de l'ASVS. Tous les éléments de l'ASVS ne sont pas associés à une CWE, et comme la CWE comporte de nombreux doublons, nous avons essayé d'utiliser la correspondance la plus courante plutôt que la plus proche. Les contrôles de vérification ne peuvent pas toujours être mis en correspondance avec des faiblesses équivalentes. Nous nous félicitons des discussions en cours avec la communauté du CWE et, plus généralement, avec le secteur de la sécurité de l'information, en vue de combler cette lacune.\n\nNous nous sommes efforcés de satisfaire, voire de dépasser, les exigences relatives au Top 10 de l'OWASP 2017 et aux contrôles proactifs de l'OWASP 2018. Comme le Top 10 2017 de l'OWASP est le strict minimum pour éviter toute négligence, nous avons délibérément fait tous les contrôles de niveau 1, sauf les contrôles spécifiques de journalisation des exigences du Top 10, ce qui permet aux adoptants du Top 10 de l'OWASP de passer plus facilement à une norme de sécurité réelle.\n\nNous avons voulu faire en sorte que l'ASVS 4.0 Niveau 1 soit un sur-ensemble complet des sections 6.5 de la norme PCI DSS 3.2.1, pour la conception d'applications, le codage, les tests, les examens de code sécurisé et les tests de pénétration. Cela a nécessité de couvrir les débordements de mémoire tampon et les opérations de mémoire non sécurisées dans la version 5, et les drapeaux de compilation liés à la mémoire non sécurisée dans la version 14, en plus des exigences de vérification des applications et des services web déjà en vigueur dans le secteur.\n\nNous avons achevé le passage de l'ASVS des contrôles monolithiques côté serveur uniquement, à la fourniture de contrôles de sécurité pour toutes les applications et API modernes. À l'époque de la programmation fonctionnelle, des API sans serveur, des mobiles, du cloud, des conteneurs, des CI/CD et des DevSecOps, de la fédération et bien d'autres choses encore, nous ne pouvons pas continuer à ignorer l'architecture moderne des applications. Les applications modernes sont conçues de manière très différente de celles construites lors de la sortie du premier ASVS en 2009. L'ASVS doit toujours être tournée vers l'avenir afin de fournir des conseils judicieux à notre public principal, les développeurs. Nous avons clarifié ou supprimé toute exigence qui suppose que les applications sont exécutées sur des systèmes appartenant à une seule organisation.\n\nEn raison de la taille de l'ASVS 4.0, ainsi que de notre désir de devenir l'ASVS de référence pour tous les autres efforts de l'ASVS, nous avons retiré la section mobile, en faveur de la norme MASVS (Mobile Application Security Verification Standard). L'appendice \"Internet of Things\" apparaîtra dans un futur IoT ASVS du projet \"Internet of Things\" de l'OWASP. Nous avons inclus un premier aperçu de l'IoT ASVS dans l'annexe C. Nous remercions l'équipe mobile de l'OWASP et l'équipe du projet IoT de l'OWASP pour leur soutien à l'ASVS, et nous nous réjouissons de travailler avec elles à l'avenir pour fournir des normes complémentaires.\n\nEnfin, nous avons supprimé et retiré les contrôles ayant moins d'impact. Avec le temps, l'ASVS a commencé à être un ensemble complet de contrôles, mais tous les contrôles ne sont pas égaux pour produire des logiciels sécurisés. Cet effort visant à éliminer les éléments à faible impact pourrait aller plus loin. Dans une prochaine édition de l'ASVS, le système de notation des faiblesses communes (CWSS) permettra de hiérarchiser davantage les contrôles qui sont vraiment importants et ceux qui devraient être retirés.\n\nÀ partir de la version 4.0, l'ASVS se concentrera uniquement sur le fait d'être le principal standard de services et d'applications web, couvrant l'architecture traditionnelle et moderne des applications, ainsi que les pratiques de sécurité agiles et la culture DevSecOps.\n", "timestamp": "2025-10-24T11:39:53.807612"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x03-Using-ASVS.md", "content": "# Utiliser l'ASVS\n\nL'ASVS a deux objectifs principaux :\n\n* aider les organisations à développer et à maintenir des applications sécurisées.\n* permettre aux fournisseurs de services de sécurité, aux vendeurs d'outils de sécurité et aux consommateurs d'aligner leurs exigences et leurs offres.\n\n## Niveaux de vérification de la sécurité des applications\n\nLa norme de vérification de la sécurité des applications définit trois niveaux de vérification de la sécurité, chacun d'eux étant plus approfondi.\n\n* Le niveau 1 de l'ASVS est destiné aux niveaux d'assurance faibles, et peut être testé via des tests d'intrusions classiques.\n* Le niveau 2 de l'ASVS est destiné aux applications qui contiennent des données sensibles, ce qui nécessite une protection et constitue le niveau recommandé pour la plupart des applications\n* Le niveau 3 de l'ASVS est destiné aux applications les plus critiques - les applications qui effectuent des transactions de grande valeur, qui contiennent des données médicales sensibles, ou toute application qui requiert le plus haut niveau de confiance.\n\nChaque niveau ASVS contient une liste d'exigences de sécurité. Chacune de ces exigences peut également être mise en correspondance avec des caractéristiques et des capacités de sécurité spécifiques qui doivent être intégrées dans les logiciels par les développeurs.\n\n![Niveaux ASVS](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"Niveau ASVS\")\n\nFigure 1 - Niveaux de vérification de la sécurité des applications OWASP 4.0\n\nLe niveau 1 est le seul qui soit entièrement adéquat pour des tests d'intrusions faits par des humains. Tous les autres niveaux nécessitent l'accès à la documentation, au code source, à la configuration et aux personnes impliquées dans le processus de développement. Cependant, même si le niveau 1 permet de réaliser des tests de \"boîte noire\" (pas de documentation et pas de source), ce n'est pas une activité d'assurance efficace et doit être activement découragé. Les attaquants malveillants ont beaucoup de temps, la plupart des tests d'intrusions  sont terminés en quelques semaines. Les défenseurs doivent mettre en place des contrôles de sécurité, protéger, trouver et résoudre toutes les faiblesses, et détecter et répondre aux acteurs malveillants dans un délai raisonnable. Les acteurs malveillants disposent essentiellement d'un temps infini et n'ont besoin que d'une seule défense poreuse, d'une seule faiblesse ou d'une détection manquante pour réussir. Les tests de la boîte noire, souvent effectués en fin de développement, rapidement ou pas du tout, sont totalement incapables de faire face à cette asymétrie.\n\nAu cours des 30 dernières années, les tests en boîte noire ont prouvé à maintes reprises qu'ils passaient à côté de problèmes de sécurité critiques qui ont directement conduit à des violations de plus en plus massives. Nous encourageons vivement l'utilisation d'un large éventail de mesures d'assurance et de vérification de la sécurité, notamment le remplacement des tests d'intrusions par des tests d'intrusions (hybrides) de niveau 1 basés sur le code source, avec un accès complet aux développeurs et à la documentation tout au long du processus de développement. Les régulateurs financiers ne tolèrent pas les audits financiers externes sans accès aux livres, aux échantillons de transactions ou aux personnes effectuant les contrôles. L'industrie et les gouvernements doivent exiger le même niveau de transparence dans le domaine du génie logiciel.\n\nNous encourageons fortement l'utilisation d'outils de sécurité, mais dans le cadre du processus de développement lui-même, tels que les outils DAST et SAST utilisés en permanence par le pipeline de construction pour trouver facilement des problèmes de sécurité qui ne devraient jamais être présents.\n\nLes outils automatisés et les scanners en ligne ne permettent pas de réaliser plus de la moitié des contrôles ASVS sans assistance humaine. Si une automatisation complète des tests pour chaque construction est nécessaire, on utilise alors une combinaison de tests unitaires et d'intégration personnalisés, ainsi que des scans en ligne initiés par la construction. Les failles de la logique métier et les tests de contrôle d'accès ne sont possibles qu'avec l'aide d'une personne. Ces tests doivent être transformés en tests unitaires et d'intégration.\n\n## Comment utiliser ce document\n\nL'une des meilleures façons d'utiliser le référentiel de vérification de la sécurité des applications est de l'utiliser comme plan directeur pour créer une liste de contrôle de codage sécurisé spécifique à votre application, plate-forme ou organisation. En adaptant l'ASVS à vos cas d'utilisation, vous pourrez mieux vous concentrer sur les exigences de sécurité les plus importantes pour vos projets et vos environnements.\n\n### Niveau 1 - Premières étapes, automatisation, ou vue de l'ensemble du portefeuille\n\nUne application atteint le niveau 1 de l'ASVS si elle se défend de manière adéquate contre les vulnérabilités de sécurité des applications qui sont faciles à découvrir, et qui figurent dans le Top 10 de l'OWASP et d'autres listes de contrôle similaires.\n\nLe niveau 1 est le strict minimum que toutes les applications devraient s'efforcer d'atteindre. Il est également utile comme première étape dans un effort en plusieurs phases ou lorsque les applications ne stockent pas ou ne traitent pas de données sensibles et n'ont donc pas besoin des contrôles plus rigoureux du niveau 2 ou 3. Les contrôles de niveau 1 peuvent être vérifiés soit automatiquement par des outils, soit simplement manuellement sans accès au code source. Nous considérons que le niveau 1 est le minimum requis pour toutes les applications.\n\nLes menaces pour l'application proviendront très probablement d'attaquants qui utilisent des techniques simples et peu exigeantes pour identifier des vulnérabilités faciles à trouver et à exploiter. En revanche, un attaquant déterminé dépensera une énergie considérable pour cibler spécifiquement l'application. Si les données traitées par votre application ont une valeur élevée, vous voudrez rarement vous arrêter à un examen de niveau 1.\n\n### Niveau 2 - La majorité des applications\n\nUne application atteint le niveau 2 (ou norme) de l'ASVS si elle se défend adéquatement contre la plupart des risques associés aux logiciels d'aujourd'hui.\n\nLe niveau 2 garantit que les contrôles de sécurité sont en place, efficaces et utilisés au sein de l'application. Le niveau 2 est généralement approprié pour les applications qui traitent des transactions interentreprises importantes, y compris celles qui traitent des informations sur les soins de santé, mettent en œuvre des fonctions critiques ou sensibles, traitent d'autres actifs sensibles, ou les secteurs où l'intégrité est une facette essentielle pour protéger leur activité, comme le secteur des jeux pour contrecarrer les tricheurs et les pirates.\n\nLes menaces pesant sur les applications de niveau 2 seront généralement des attaquants compétents et motivés qui se concentrent sur des cibles spécifiques en utilisant des outils et des techniques très pratiques et efficaces pour découvrir et exploiter les faiblesses des applications.\n\n### Niveau 3 - Haute valeur, haute assurance ou haute sécurité\n\nLe niveau 3 de l'ASVS est le plus haut niveau de vérification au sein de l'ASVS. Ce niveau est généralement réservé aux applications qui nécessitent des niveaux de vérification de sécurité importants, comme celles qui peuvent se trouver dans les domaines de l'armée, de la santé et de la sécurité, des infrastructures critiques, etc.\n\nLes organisations peuvent exiger le niveau 3 de l'ASVS pour les applications qui remplissent des fonctions critiques, où une défaillance pourrait avoir un impact significatif sur les opérations de l'organisation, et même sur sa capacité de survie. Des exemples de conseils sur l'application de l'ASVS niveau 3 sont fournis ci-dessous. Une application atteint le niveau 3 ASVS (ou avancé) si elle se défend de manière adéquate contre les vulnérabilités de sécurité des applications avancées et si elle démontre également les principes d'une bonne conception de la sécurité.\n\nUne application au niveau 3 ASVS nécessite une analyse plus approfondie de l'architecture, du code et des tests que tous les autres niveaux. Une application sécurisée est modulaire de manière significative (pour faciliter la résilience, l'évolutivité et, surtout, les couches de sécurité), et chaque module (séparé par une connexion réseau et/ou une instance physique) prend en charge ses propres responsabilités en matière de sécurité (défense en profondeur), qui doivent être correctement documentés. Les responsabilités comprennent des contrôles pour garantir la confidentialité (par exemple, le cryptage), l'intégrité (par exemple, les transactions, la validation des entrées), la disponibilité (par exemple, gérer la charge avec élégance), l'authentification (y compris entre les systèmes), la non-répudiation, l'autorisation et l'audit (journalisation).\n\n## Application de l'ASVS en pratique\n\nLes différentes menaces ont des motivations différentes. Certains secteurs d'activité disposent d'atouts uniques en matière d'information et de technologie et ont des exigences de conformité réglementaire spécifiques à leur domaine.\n\nLes organisations sont fortement encouragées à examiner en profondeur leurs caractéristiques de risque uniques en fonction de la nature de leur activité, et à déterminer le niveau ASVS approprié en fonction de ce risque et des exigences commerciales.\n\n## Comment se référencer aux exigences ASVS\n\nChaque exigence a un identifiant au format `<chapitre>.<section>.<exigence>` où chaque élément est un nombre, par exemple : `1.11.3`.\n- La valeur `<chapitre>` correspond au chapitre d'où provient l'exigence, par exemple : toutes les exigences `1.#.#` sont issues du chapitre `Architecture`.\n- La valeur `<section>` correspond à la section de ce chapitre où l'exigence apparaît, par exemple : toutes les exigences `1.11.#` se trouvent dans la section `Business Logic Architecture` du chapitre `Architecture`.\n- La valeur `<requirement>` identifie l'exigence spécifique dans le chapitre et la section, par exemple : `1.11.3` qui, à partir de la version 4.0.3 de cette norme, est :\n\n> Vérifier que tous les flux de logique métier de grande valeur, y compris l'authentification, la gestion de session et le contrôle d'accès, sont sécurisés et résistants aux conditions de concurrence (\"race condition\") au temps de contrôle et au temps d'utilisation.\n\nLes identifiants peuvent changer entre les versions de la norme, il est donc préférable que d'autres documents, rapports ou outils utilisent le format : `v<version>-<chapter>.<section>.<requirement>`, où : 'version' est la balise de version ASVS. Par exemple : `v4.0.3-1.11.3` serait compris comme signifiant spécifiquement la 3ème exigence dans la section 'Business Logic Architecture' du chapitre 'Architecture' de la version 4.0.3. (Cela pourrait être résumé comme `v<version>-<requirement_identifier>`.)\n\nRemarque : Le `v` précédant la partie version doit être en minuscule.\n\nSi les identifiants sont utilisés sans inclure l'élément `v<version>`, ils doivent être supposés faire référence au dernier contenu de la norme de vérification de la sécurité des applications. De toute évidence, à mesure que la norme se développe et change, cela devient problématique, c'est pourquoi les rédacteurs ou les développeurs doivent inclure l'élément de version.\n\nLes listes d'exigences ASVS sont mises à disposition au format CSV, JSON et d'autres formats qui peuvent être utiles pour une utilisation de référence ou de programmation.\n", "timestamp": "2025-10-24T11:39:53.881847"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x04-Assessment_and_Certification.md", "content": "# Évaluation et certification\n\n## Position de l'OWASP sur les certifications et marques de confiance ASVS\n\nL'OWASP, en tant qu'organisation à but non lucratif neutre, ne certifie actuellement aucun vendeur, vérificateur ou logiciel.\n\nToutes ces assertions d'assurance, marques de confiance ou certifications ne sont pas officiellement vérifiées, enregistrées ou certifiées par l'OWASP, de sorte qu'une organisation qui s'appuie sur ce point de vue doit être prudente quant à la confiance placée dans une tierce partie ou une marque de confiance revendiquant la certification ASVS.\n\nCela ne devrait pas empêcher les organisations d'offrir de tels services d'assurance, tant qu'elles ne revendiquent pas la certification officielle de l'OWASP.\n\n## Directives pour les organismes de certification\n\nLa norme de vérification de la sécurité des applications peut être utilisée comme une vérification à livre ouvert de l'application, comprenant un accès ouvert et sans entrave aux ressources clés telles que les architectes et les développeurs, la documentation du projet, le code source, l'accès authentifié aux systèmes de test (y compris l'accès à un ou plusieurs comptes dans chaque rôle), en particulier pour les vérifications de L2 et L3.\n\nHistoriquement, les tests de pénétration et les examens de code sécurisé ont inclus des questions \"par exception\" - c'est-à-dire que seuls les tests échoués apparaissent dans le rapport final. Un organisme de certification doit inclure dans tout rapport la portée de la vérification (en particulier si un élément clé est hors de portée, comme l'authentification du SSO), un résumé des résultats de la vérification, y compris les tests réussis et les tests échoués, avec des indications claires sur la manière de résoudre les tests échoués.\n\nCertaines exigences de vérification peuvent ne pas être applicables à l'application testée. Par exemple, si vous fournissez à vos clients une API de couche de service sans état sans implémentation client, de nombreuses exigences de la gestion de session V3 ne sont pas directement applicables. Dans de tels cas, un organisme de certification peut toujours prétendre à une conformité totale aux ASVS, mais doit clairement indiquer dans tout rapport une raison de non-applicabilité de ces exigences de vérification exclues.\n\nLa conservation de documents de travail détaillés, de captures d'écran ou de films, de scripts permettant d'exploiter un problème de manière fiable et répétée, ainsi que d'enregistrements électroniques des tests, tels que l'interception de journaux de proxy et de notes associées comme une liste de nettoyage, est considérée comme une pratique standard de l'industrie et peut être vraiment utile comme preuve des résultats pour les développeurs les plus douteux. Il ne suffit pas de faire fonctionner un outil et de signaler les échecs ; cela ne prouve pas (du tout) que tous les problèmes à un niveau de certification ont été testés et éprouvés de manière approfondie. En cas de litige, il doit y avoir suffisamment de preuves d'assurance pour démontrer que chaque exigence vérifiée a bien été testée.\n\n### Méthode de test\n\nLes organismes certificateurs sont libres de choisir la ou les méthodes d'essai appropriées, mais doivent les indiquer dans un rapport.\n\nSelon l'application testée et l'exigence de vérification, différentes méthodes de test peuvent être utilisées pour obtenir une confiance similaire dans les résultats. Par exemple, la validation de l'efficacité des mécanismes de vérification des entrées d'une application peut être analysée soit par un test d'intrusion manuel, soit par des analyses du code source.\n\n#### Le rôle des outils de test de sécurité automatisés\n\nL'utilisation d'outils automatisés de test de pénétration est encouragée afin d'assurer une couverture aussi large que possible.\n\nIl n'est pas possible d'effectuer une vérification complète de l'ASVS en utilisant uniquement des outils de test de pénétration automatisés. Alors qu'une grande majorité des exigences de la L1 peuvent être réalisées à l'aide de tests automatisés, la majorité globale des exigences ne se prête pas à l'utilisation de tests d'intrusion automatisés.\n\nVeuillez noter que les limites entre les tests automatisés et manuels se sont estompées au fur et à mesure que le secteur de la sécurité des applications a évolué. Les outils automatisés sont souvent réglés manuellement par des experts et les testeurs manuels utilisent souvent une grande variété d'outils automatisés.\n\n#### Le rôle des tests de pénétration\n\nDans la version 4.0, nous avons décidé de rendre la L1 entièrement testable par pénétration sans accès au code source, à la documentation ou aux développeurs. Deux éléments d'enregistrement, qui doivent être conformes au Top 10 2017 A10 de l'OWASP, nécessiteront des entretiens, des captures d'écran ou d'autres collectes de preuves, tout comme dans le Top 10 2017 de l'OWASP. Cependant, les tests sans accès aux informations nécessaires ne constituent pas une méthode idéale de vérification de la sécurité, car ils laissent de côté la possibilité d'examiner la source, d'identifier les menaces et les contrôles manquants, et de réaliser un test beaucoup plus approfondi dans un délai plus court.\n\nDans la mesure du possible, l'accès aux développeurs, à la documentation, au code et l'accès à une application de test avec des données de non-production, est nécessaire lors de l'exécution d'une évaluation de niveau 2 ou 3. Les tests de pénétration effectués à ces niveaux nécessitent ce niveau d'accès, que nous appelons \"examens hybrides\" ou \"tests de pénétration hybrides\".\n\n## Autres utilisations de l'ASVS\n\nEn plus de servir à l'évaluation de la sécurité d'une application, nous avons identifié plusieurs autres potentielles utilisations de l'ASVS.\n\n### En tant que conseils détaillés sur l'architecture de sécurité\n\nL'une des utilisations les plus courantes de la norme de vérification de la sécurité des applications est en tant que ressource pour les architectes de sécurité. Il manque au modèle Sherwood Applied Business Security Architecture (SABSA) une grande quantité d'informations nécessaires pour effectuer un examen approfondi de l'architecture de sécurité des applications. ASVS peut être utilisé pour combler ces lacunes en permettant aux architectes de sécurité de choisir de meilleurs contrôles pour les problèmes courants, tels que les modèles de protection des données et les stratégies de validation des entrées.\n\n### En remplacement des listes de contrôle de codage sécurisé prêtes à l'emploi\n\nDe nombreuses organisations peuvent bénéficier de l'adoption de l'ASVS, en choisissant l'un des trois niveaux, ou en forkant ASVS et en modifiant ce qui est requis pour chaque niveau de risque d'application d'une manière spécifique au domaine. Nous encourageons ce type de forking tant que la traçabilité est maintenue, de sorte que si une application a satisfait à l'exigence 4.1, cela signifie la même chose pour les copies forkées que la norme au fur et à mesure de son évolution.\n\n### Guide pour les tests unitaires et d'intégration automatisés\n\nL'ASVS est conçu pour être hautement testable, à la seule exception des exigences en matière d'architecture et de code malveillant. Grâce à des tests unitaires et d'intégration qui permettent de détecter des variantes et des cas d'abus spécifiques et pertinents, l'application se vérifie pratiquement d'elle-même à chaque nouvelle itération. Par exemple, des tests supplémentaires peuvent être élaborés pour la suite de tests d'un contrôleur de connexion, en testant le paramètre de nom d'utilisateur pour les noms d'utilisateur communs par défaut, l'énumération des comptes, l'énumération exhaustive (brute-force), l'injection LDAP et SQL, et XSS. De plus, un test sur le paramètre du mot de passe devrait inclure les mots de passe communs, la longueur du mot de passe, l'injection d'octets nuls, la suppression du paramètre, XSS, et plus encore.\n\n### Pour la formation au développement sécurisé\n\nL'ASVS peut également être utilisé pour définir les caractéristiques des logiciels sécurisés. De nombreux cours de \"codage sécurisé\" sont simplement des cours de piratage éthique avec une légère trace de conseils de codage. Cela n'aide pas nécessairement les développeurs à écrire un code plus sûr. Les cours de développement sécurisé peuvent plutôt utiliser l'ASVS en mettant l'accent sur les contrôles proactifs qu'il contient, plutôt que sur les dix principales erreurs à ne pas faire.\n\n### En tant que pilote pour la sécurité des applications agiles\n\nL'ASVS peut être utilisé dans un processus de développement agile comme cadre pour définir les tâches spécifiques qui doivent être mises en œuvre par l'équipe pour avoir un produit sécurisé. Une approche pourrait être : En commençant par le niveau 1, vérifier l'application ou le système spécifique selon les exigences de l'ASVS pour le niveau spécifié, trouver les contrôles manquants et soulever des tickets/tâches spécifiques dans le backlog. Cela permet de hiérarchiser les tâches spécifiques (ou grooming) et de rendre la sécurité visible dans le processus agile. Cela peut également être utilisé pour hiérarchiser les tâches d'audit et de révision dans l'organisation, où une exigence ASVS spécifique peut être un moteur de révision, de remaniement ou d'audit pour un membre spécifique de l'équipe et être visible en tant que \"dette\" dans le backlog qui doit finalement être fait.\n\n### Comme cadre pour guider l'acquisition de logiciels sécurisés\n\nL'ASVS est un cadre idéal pour aider à sécuriser l'acquisition de logiciels ou de services de développement personnalisés. L'acheteur peut simplement exiger que le logiciel qu'il souhaite acquérir soit développé au niveau X de l'ASVS, et demander au vendeur de prouver que le logiciel satisfait au niveau X de l'ASVS. Cette procédure fonctionne bien lorsqu'elle est combinée avec l'annexe du contrat de logiciel sécurisé de l'OWASP.\n", "timestamp": "2025-10-24T11:39:54.013187"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x10-V1-Architecture.md", "content": "# V1 Architecture, conception et exigences en matière de modélisation des menaces\n\n## Objectif de contrôle\n\nL'architecture de sécurité est presque devenue un art perdu dans de nombreuses organisations. Les jours de l'architecte d'entreprise sont passés à l'ère des DevSecOps. Le domaine de la sécurité des applications doit rattraper son retard et adopter des principes de sécurité agiles tout en réintroduisant les principes de l'architecture de sécurité de pointe auprès des praticiens du logiciel. L'architecture n'est pas une implémentation, mais une façon de penser à un problème qui peut avoir plusieurs réponses différentes, et pas une seule réponse \"correcte\". Trop souvent, la sécurité est considérée comme rigide et exige que les développeurs corrigent le code d'une manière particulière, alors qu'ils connaissent peut-être un bien meilleur moyen de résoudre le problème. Il n'existe pas de solution unique et simple pour l'architecture, et prétendre le contraire est un mauvais service rendu au domaine du génie logiciel.\n\nUne implémentation spécifique d'une application web est susceptible d'être révisée continuellement tout au long de sa vie, mais l'architecture globale ne changera probablement que rarement, mais évoluera lentement. L'architecture de sécurité est identique - nous avons besoin d'une authentification aujourd'hui, nous en aurons besoin demain, et nous en aurons besoin dans cinq ans. Si nous prenons des décisions judicieuses aujourd'hui, nous pouvons économiser beaucoup d'efforts, de temps et d'argent si nous sélectionnons et réutilisons des solutions conformes à l'architecture. Par exemple, il y a dix ans, l'authentification multifactorielle était rarement mise en œuvre.\n\nSi les développeurs avaient investi dans un modèle de fournisseur d'identité unique et sécurisé, tel que l'identité fédérée SAML, le fournisseur d'identité pourrait être mis à jour pour intégrer de nouvelles exigences telles que la conformité NIST 800-63, sans pour autant modifier les interfaces de l'application d'origine. Si de nombreuses applications partageaient la même architecture de sécurité et donc le même composant, elles bénéficient toutes de cette mise à jour en même temps. Toutefois, SAML ne restera pas toujours la meilleure ou la plus appropriée des solutions d'authentification - il pourrait être nécessaire de le remplacer par d'autres solutions au fur et à mesure que les exigences changent. De telles modifications sont soit compliquées, si coûteuses qu'elles nécessitent une réécriture complète, soit carrément impossibles sans architecture de sécurité.\n\nDans ce chapitre, l'ASVS couvre les principaux aspects de toute architecture de sécurité solide : disponibilité, confidentialité, intégrité du traitement, non-répudiation et respect de la vie privée. Chacun de ces principes de sécurité doit être intégré et inné à toutes les applications. Il est essentiel de \"tourner à gauche\", en commençant par l'habilitation des développeurs avec des listes de contrôle de codage sécurisé, le mentorat et la formation, le codage et les tests, la construction, le déploiement, la configuration et les opérations, et en terminant par des tests indépendants de suivi pour s'assurer que tous les contrôles de sécurité sont présents et fonctionnels. La dernière étape était autrefois tout ce que nous faisions en tant qu'industrie, mais cela ne suffit plus lorsque les développeurs mettent le code en production des dizaines ou des centaines de fois par jour. Les professionnels de la sécurité des applications doivent se tenir au courant des techniques agiles, ce qui signifie adopter les outils des développeurs, apprendre à coder et travailler avec eux plutôt que de critiquer le projet des mois après que tout le monde est passé à autre chose.\n\n## V1.1 Exigences relatives au cycle de vie du développement de logiciels sécurisés\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | Vérifier l'utilisation d'un cycle de développement de logiciel sécurisé qui prend en compte la sécurité à tous les stades du développement. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Vérifier l'utilisation de la modélisation des menaces pour chaque modification de conception ou planification de sprint afin d'identifier les menaces, de planifier les contre-mesures, de faciliter les réponses appropriées aux risques et d'orienter les tests de sécurité. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Vérifiez que toutes les récits utilisateurs et les fonctionnalités contiennent des contraintes de sécurité fonctionnelles, telles que \"En tant qu'utilisateur, je devrais pouvoir consulter et modifier mon profil. Je ne devrais pas pouvoir voir ou modifier le profil de quelqu'un d'autre\" | | ✓ | ✓ | 1110 |\n| **1.1.4** | Vérifier la documentation et la justification de toutes les frontières de confiance de la demande, de ses composantes et des flux de données importants. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Vérifier la définition et l'analyse de sécurité de l'architecture de haut niveau de l'application et de tous les services à distance connectés. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Vérifier la mise en œuvre de contrôles de sécurité centralisés, simples (économie de conception), vérifiés, sécurisés et réutilisables pour éviter les contrôles en double, manquants, inefficaces ou peu sûrs. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Vérifier que tous les développeurs et testeurs disposent d'une liste de contrôle de codage sécurisé, d'exigences de sécurité, de lignes directrices ou de politiques. | | ✓ | ✓ | 637 |\n\n## V1.2 Exigences architecturales d'authentification\n\nLors de la conception de l'authentification, il importe peu que vous disposiez d'un matériel solide permettant une authentification multifactorielle si un attaquant peut réinitialiser un compte en appelant un centre d'appel et en répondant à des questions courantes. Lors de la vérification de l'identité, toutes les méthodes d'authentification doivent avoir la même force.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | Vérifier que les communications entre les composants de l'application, y compris les API, les intergiciels et les couches de données, sont authentifiées et utilisent des comptes utilisateurs individuels. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Vérifiez que les communications entre les composants de l'application, y compris les API, le middleware et les couches de données, sont authentifiées. Les composants doivent avoir les privilèges les moins nécessaires possibles. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Vérifier que toutes les méthodes d'authentification et les API de gestion de l'identité mettent en œuvre un contrôle de sécurité de l'authentification cohérent, de sorte qu'il n'y ait pas d'alternatives plus faibles par rapport au risque de l'application. | | ✓ | ✓ | 306 |\n| **1.2.4** | Vérifiez que toutes les voies d'authentification et les API de gestion des identités implémentent une force de contrôle de sécurité d'authentification cohérente, de sorte qu'il n'y ait pas d'alternative plus faible en fonction du risque de l'application. | | ✓ | ✓ | 306 |\n\n## V1.3 Exigences architecturales pour la gestion des sessions\n\nIl s'agit d'un point de repère pour les futures exigences architecturales.\n\n## V1.4 Exigences architecturales en matière de contrôle d'accès\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | Vérifiez que des points d'application de confiance tels que les passerelles de contrôle d'accès, les serveurs et les fonctions sans serveur font respecter les contrôles d'accès. N'imposez jamais de contrôles d'accès au client. | | ✓ | ✓ | 602 |\n| **1.4.2** | [SUPPRIMÉ, NON FAISABLE] | | | | |\n| **1.4.3** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 4.1.3] | | | | |\n| **1.4.4** | Vérifiez que l'application utilise un mécanisme de contrôle d'accès unique et bien contrôlé pour accéder aux données et ressources protégées. Toutes les requêtes doivent passer par ce mécanisme unique pour éviter les copier-coller ou les chemins alternatifs non sécurisés. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Vérifiez que le contrôle d'accès basé sur les attributs ou les caractéristiques est utilisé, c'est-à-dire que le code vérifie l'autorisation de l'utilisateur pour une caractéristique ou une donnée plutôt que son seul rôle. Les autorisations doivent tout de même être attribuées à l'aide de rôles. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Exigences architecturales d'entrée et de sortie\n\nDans la version 4.0, nous avons abandonné le terme \"côté serveur\" ayant la connotation de limite de confiance. La limite de confiance est toujours un  enjeu - il est possible de contourner les décisions prises sur des navigateurs ou des appareils clients non fiables. Cependant, dans les déploiements architecturaux courants d'aujourd'hui, le point d'application de la confiance a considérablement changé. Par conséquent, lorsque le terme \"couche de service de confiance\" est utilisé dans l'ASVS, nous entendons par là tout point d'application de confiance, quel que soit son emplacement, tel qu'un microservice, un API sans serveur, côté serveur, un API de confiance sur un périphérique client qui a un démarrage sécurisé, des API partenaires ou externes, etc. \n\nLe terme « client non approuvé » fait ici référence aux technologies côté client qui restituent la couche de présentation, communément appelées technologies « front-end ». Le terme « sérialisation » ici ne se réfère pas seulement à l'envoi de données comme un tableau de valeurs ou à la prise et à la lecture d'une structure JSON, mais également au passage d'objets complexes qui peuvent contenir de la logique.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | Vérifier que les exigences en matière d'entrée et de sortie définissent clairement la manière de traiter et d'exploiter les données en fonction du type, du contenu et de la conformité aux lois, règlements et autres politiques applicables.  | | ✓ | ✓ | 1029 |\n| **1.5.2** | Vérifiez que la sérialisation n'est pas utilisée lorsque vous communiquez avec des clients non fiables. Si cela n'est pas possible, assurez-vous que des contrôles d'intégrité adéquats (et éventuellement un chiffrement si des données sensibles sont envoyées) sont appliqués pour empêcher les attaques de désérialisation, y compris l'injection d'objets. | | ✓ | ✓ | 502 |\n| **1.5.3** | Vérifiez que la validation des entrées est appliquée sur une couche de service de confiance. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Vérifiez que l'encodage de sortie se fait à proximité ou par l'interprète auquel il est destiné. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Exigences en matière d'architecture cryptographique\n\nLes applications doivent être conçues avec une architecture cryptographique solide pour protéger les données selon leur classification. Tout chiffrer est un gaspillage, ne rien chiffrer est une négligence légale. Un équilibre doit être trouvé, généralement lors de la conception architecturale ou de haut niveau, des sprints de conception ou des pics architecturaux. Concevoir la cryptographie au fur et à mesure ou l'adapter coûtera inévitablement beaucoup plus cher à mettre en œuvre de manière sécurisée que de l'intégrer dès le départ.\n\nLes exigences architecturales sont intrinsèques au code, et donc difficiles à unifier ou à intégrer dans les tests. Les exigences architecturales doivent être prises en compte dans les normes de codage, tout au long de la phase de codage, et doivent être examinées au cours de l'architecture de sécurité, des revues du code par les pairs, ou des rétrospectives.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | Vérifier qu'il existe une politique explicite de gestion des clés cryptographiques et que le cycle de vie d'une clé cryptographique suit une norme de gestion des clés telle que NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Vérifier que les consommateurs de services cryptographiques protègent les clés et autres secrets en utilisant des coffres-forts de clés ou des alternatives basées sur l'API. | | ✓ | ✓ | 320 |\n| **1.6.3** | Vérifiez que toutes les clés et tous les mots de passe sont remplaçables et font partie d'un processus bien défini de rechiffrement des données sensibles. | | ✓ | ✓ | 320 |\n| **1.6.4** | Vérifiez que l'architecture traite les secrets côté client, tels que les clés symétriques, les mots de passe ou les jetons d'API, comme non sécurisés et ne les utilise jamais pour protéger ou accéder à des données sensibles. | | ✓ | ✓ | 320 |\n\n## V1.7 Erreurs, enregistrement et vérification des exigences architecturales\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | Vérifier qu'un format de journalisation commun soit utilisé dans le système.  ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Vérifiez que les journaux sont transmis de manière sécurisée à un système de préférence distant pour analyse, détection, alerte et escalade. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Exigences architecturales en matière de protection des données et de la vie privée\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | Vérifier que toutes les données sensibles sont identifiées et classées en niveaux de protection. | | ✓ | ✓ | |\n| **1.8.2** | Vérifier que tous les niveaux de protection sont associés à un ensemble d'exigences de protection, telles que des exigences de chiffrement, d'intégrité, de conservation, de respect de la vie privée et d'autres exigences de confidentialité, et que celles-ci sont appliquées dans l'architecture. | | ✓ | ✓ | |\n\n## V1.9 Exigences en matière d'architecture des communications\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | Vérifier que l'application chiffre les communications entre les composants, en particulier lorsque ces composants se trouvent dans des conteneurs, systèmes, sites ou fournisseurs de cloud différents. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Vérifier que les composants de l'application vérifient l'authenticité de chaque partie d'un lien de communication afin de prévenir les attaques de type \"man-in-the-middle\". Par exemple, les composants d'application doivent valider les certificats et les chaînes TLS. | | ✓ | ✓ | 295 |\n\n## V1.10 Exigences en matière d'architecture des logiciels malveillants\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | Vérifier qu'un système de contrôle du code source est utilisé, avec des procédures pour s'assurer que les enregistrements sont accompagnés de tickets d'émission ou de modification. Le système de contrôle du code source doit disposer d'un contrôle d'accès et d'utilisateurs identifiables pour permettre la traçabilité de toute modification. | | ✓ | ✓ | 284 |\n\n## V1.11 Exigences en matière d'architecture de la logique d'entreprise\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | Vérifier la définition et la documentation de tous les composants de l'application en ce qui concerne la logique métier ou de sécurité qu'ils fournissent. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Vérifiez que tous les flux de logique métier de grande valeur, y compris l'authentification, la gestion de session et le contrôle d'accès, ne partagent pas un état non synchronisé. | | ✓ | ✓ | 362 |\n| **1.11.3** | Vérifier que tous les flux de logique métier de grande valeur, y compris l'authentification, la gestion de session et le contrôle d'accès, sont sécurisés et résistants aux conditions de concurrence (\"race condition\") au temps de contrôle et au temps d'utilisation. | | | ✓ | 367 |\n\n## V1.12 Téléchargement de fichiers sécurisés Exigences architecturales\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 12.4.1] | | | | |\n| **1.12.2** | Vérifiez que les fichiers envoyés par l'utilisateur - s'ils doivent être affichés ou téléchargés à partir de l'application - sont servis par des téléchargements en flux d'octets, ou à partir d'un domaine sans rapport, comme un compartiment de stockage de fichiers en nuage. Mettre en œuvre une politique de sécurité du contenu (CSP) appropriée pour réduire le risque de vecteurs XSS ou d'autres attaques provenant du fichier téléchargé. | | ✓ | ✓ | 646 |\n\n## V1.13 Exigences architecturales de l'API\n\nIl s'agit d'un espace réservé pour les futures exigences architecturales.\n\n## V1.14 Configuration des exigences architecturales\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | Vérifiez la séparation des composants de différents niveaux de confiance via des contrôles de sécurité bien définis, des règles de pare-feu, des passerelles API, des proxys inverses, des groupes de sécurité basés sur le cloud ou des mécanismes similaires. | | ✓ | ✓ | 923 |\n| **1.14.2** | Vérifier que les signatures binaires, les connexions de confiance et les nœuds vérifiés sont utilisés pour déployer des binaires sur des dispositifs distants. | | ✓ | ✓ | 494 |\n| **1.14.3** | Vérifier que le pipeline de construction signale les composants obsolètes ou peu sûrs et prend les mesures appropriées. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Vérifiez que le pipeline de construction contient une étape de génération pour générer automatiquement et vérifier le déploiement sécurisé de l'application, en particulier si l'infrastructure de l'application est définie par logiciel, comme les scripts de génération d'environnement cloud. | | ✓ | ✓ | |\n| **1.14.5** | Vérifiez que les déploiements d'applications sont correctement mis en bac à sable, conteneurisés et/ou isolés au niveau du réseau pour retarder et dissuader les attaquants d'attaquer d'autres applications, en particulier lorsqu'ils effectuent des actions sensibles ou dangereuses telles que la désérialisation. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Vérifier que l'application n'utilise pas de technologies côté client non prises en charge, non sécurisées ou obsolètes telles que les plug-ins NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL ou des applets Java côté client. | | ✓ | ✓ | 477 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:54.169056"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x11-V2-Authentication.md", "content": "# V2 Authentification\n\n## Objectif de contrôle\n\nL'authentification est l'acte qui consiste à établir ou à confirmer qu'une personne (ou quelque chose) est authentique et que les affirmations faites par une personne ou au sujet d'un dispositif sont correctes, résistantes à l'usurpation d'identité et empêchent la récupération ou l'interception des mots de passe.\n\nLorsque l'ASVS a été publiée pour la première fois, le nom d'utilisateur + mot de passe était la forme d'authentification la plus courante en dehors des systèmes de haute sécurité. L'authentification à facteurs multiples (MFA) était communément acceptée dans les cercles de sécurité mais rarement requise ailleurs. Avec l'augmentation du nombre de brèches de mots de passe, l'idée que les noms d'utilisateur sont en quelque sorte confidentiels et les mots de passe inconnus, a rendu de nombreux contrôles de sécurité inefficaces. Par exemple, le NIST 800-63 considère les noms d'utilisateur et l'authentification basée sur la connaissance (KBA) comme des informations publiques, les notifications par SMS et par courrier électronique comme des [types d'authentificateurs \"restreints\"](https://pages.nist.gov/800-63-FAQ/#q-b1), et les mots de passe comme des préviolations. Cette réalité rend inutiles les authentificateurs basés sur la connaissance, la récupération de SMS et de courriels, l'historique des mots de passe, la complexité et les contrôles de rotation. Ces contrôles ont toujours été peu utiles, obligeant souvent les utilisateurs à trouver des mots de passe faibles tous les quelques mois, mais avec la publication de plus de 5 milliards de violations de noms d'utilisateur et de mots de passe, il est temps de passer à autre chose.\n\nDe toutes les sections de l'ASVS, ce sont les chapitres sur l'authentification et la gestion des sessions qui ont le plus changé. L'adoption de pratiques de pointe efficaces et fondées sur des preuves sera un défi pour beaucoup, et c'est tout à fait normal. Nous devons commencer dès maintenant la transition vers un avenir post-mot de passe.\n\n## NIST 800-63 - Norme d'authentification moderne et fondée sur des preuves\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) est une norme moderne, basée sur des preuves, et représente le meilleur conseil disponible, indépendamment de son applicabilité. La norme est utile à toutes les organisations du monde entier, mais elle est particulièrement pertinente pour les agences américaines et celles qui traitent avec des agences américaines.\n\nLa terminologie de la norme NIST 800-63 peut être un peu déroutante au début, surtout si vous n'êtes habitué qu'à l'authentification par nom d'utilisateur + mot de passe. Des progrès en matière d'authentification moderne sont nécessaires, nous devons donc introduire une terminologie qui deviendra courante à l'avenir, mais nous comprenons la difficulté de compréhension jusqu'à ce que l'industrie s'habitue à ces nouveaux termes. Nous avons fourni un glossaire à la fin de ce chapitre pour vous aider. Nous avons reformulé de nombreuses exigences afin de satisfaire l'intention, plutôt que sa forme. Par exemple, l'ASVS utilise le terme \"mot de passe\" alors que le NIST utilise \"secret mémorisé\" tout au long de cette norme.\n\nL'authentification ASVS V2, la gestion de session V3 et, dans une moindre mesure, les contrôles d'accès V4 ont été adaptés pour constituer un sous-ensemble conforme de certains contrôles NIST 800-63b, axés sur les menaces communes et les faiblesses d'authentification couramment exploitées. Lorsque la conformité totale à la norme NIST 800-63 est requise, veuillez consulter la norme NIST 800-63.\n\n### Sélection d'un niveau NIST AAL approprié\n\nLa norme de vérification de la sécurité des applications a tenté de faire correspondre les exigences ASVS L1 à celles du NIST AAL1, L2 à AAL2, et L3 à AAL3. Cependant, l'approche du niveau 1 ASVS en tant que contrôles \"essentiels\" n'est pas nécessairement le niveau AAL correct pour vérifier une application ou une API. Par exemple, si l'application est une application de niveau 3 ou a des exigences réglementaires pour être AAL3, le niveau 3 doit être choisi dans les sections V2 et V3 Gestion des sessions. Le choix du niveau d'affirmation d'authentification (AAL) conforme aux normes NIST doit être effectué conformément aux directives NIST 800-63b, comme indiqué dans la section *Selecting AAL* du [NIST 800-63b Section 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Légende\n\nLes applications peuvent toujours dépasser les exigences du niveau actuel, surtout si l'authentification moderne figure sur la feuille de route d'une application. Auparavant, l'ASVS exigeait une AMF obligatoire. Le NIST n'exige pas de MFA obligatoire. C'est pourquoi nous avons utilisé une désignation optionnelle dans ce chapitre pour indiquer les cas où l'ASVS encourage mais n'exige pas de contrôle. Les clés suivantes sont utilisées tout au long de cette norme :\n\n| Marque | Description |\n| :---: | :---: |\n| | Non requis |\n| o | Recommandé, mais pas obligatoire |\n| ✓ | Obligatoire |\n\n## V2.1 Exigences en matière de sécurité des mots de passe\n\nLes mots de passe, appelés \"Memorized Secrets\" par NIST 800-63, comprennent les mots de passe, les codes PIN, les motifs de déverrouillage, le choix du bon chaton ou d'un autre élément d'image, et les phrases de passe. Ils sont généralement considérés comme \"quelque chose que vous savez\" et sont souvent utilisés comme des authentificateurs à facteur unique. L'utilisation continue de l'authentification à un facteur unique pose des problèmes importants, notamment les milliards de noms d'utilisateur et de mots de passe valides divulgués sur l'internet, les mots de passe par défaut ou faibles, les tables arc-en-ciel et les dictionnaires ordonnés des mots de passe les plus courants.\n\nLes applications devraient fortement encourager les utilisateurs à s'inscrire à l'authentification multi-facteurs, et devraient permettre aux utilisateurs de réutiliser les jetons qu'ils possèdent déjà, tels que les jetons FIDO ou U2F, ou de se relier à un fournisseur de services d'accréditation qui fournit une authentification multi-facteurs.\n\nLes fournisseurs de services d'accréditation (CSP) fournissent une identité fédérée aux utilisateurs. Les utilisateurs auront souvent plus d'une identité avec plusieurs CSP, comme une identité d'entreprise utilisant Azure AD, Okta, Ping Identity ou Google, ou une identité de consommateur utilisant Facebook, Twitter, Google ou WeChat, pour ne citer que quelques alternatives courantes. Cette liste n'est pas une approbation de ces entreprises ou services, mais simplement un encouragement pour les développeurs à prendre en compte la réalité que de nombreux utilisateurs ont plusieurs identités établies. Les organisations devraient envisager de s'intégrer aux identités des utilisateurs existants, conformément au profil de risque de la force du CSP en matière de vérification d'identité. Par exemple, il est peu probable qu'une organisation gouvernementale accepte une identité de média social comme identifiant pour des systèmes sensibles, car il est facile de créer de fausses identités ou de jeter des identités, alors qu'une société de jeux pour mobiles pourrait bien avoir besoin de s'intégrer aux principales plateformes de médias sociaux pour accroître sa base de joueurs actifs.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.1.1** | Vérifiez que les mots de passe définis par l'utilisateur comportent au moins 12 caractères (après avoir combiné plusieurs espaces). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Vérifiez que les mots de passe de 64 caractères ou plus sont autorisés, mais pas au delà de 128 caractères. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Vérifiez que le mot de passe n'est pas tronqué. Toutefois, des espaces multiples consécutifs peuvent être remplacés par un seul espace. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Vérifiez que tous les caractères Unicode imprimables, y compris les caractères neutres comme les espaces et les Emojis, sont autorisés dans les mots de passe. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Vérifier que les utilisateurs peuvent changer leur mot de passe. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Vérifiez que la fonctionnalité de changement de mot de passe nécessite le mot de passe actuel et le nouveau mot de passe de l'utilisateur. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Vérifiez que les mots de passe soumis lors de l'enregistrement du compte, de la connexion et du changement de mot de passe sont comparés à un ensemble de mots de passe violés, soit localement (comme les 1 000 ou 10 000 mots de passe les plus courants qui correspondent à la politique de mot de passe du système), soit en utilisant une API externe. En cas d'utilisation d'une API, une preuve de connaissance nulle ou un autre mécanisme doit être utilisé pour garantir que le mot de passe en texte clair n'est pas envoyé ou utilisé pour vérifier l'état de violation du mot de passe. Si le mot de passe est violé, l'application doit demander à l'utilisateur de définir un nouveau mot de passe non violé. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Vérifiez qu'un compteur de force de mot de passe est fourni pour aider les utilisateurs à définir un mot de passe plus fort. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Vérifiez qu'il n'existe pas de règles de composition des mots de passe limitant le type de caractères autorisés. Il ne doit pas y avoir restrictions sur l'utilisation de majuscules ou de minuscules, de chiffres ou de caractères spéciaux. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Vérifiez qu'il n'y a pas d'exigences en matière de rotation périodique du mot de passe ou d'historique des mots de passe. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Vérifiez que la fonction \"coller\", les aides de mot de passe du navigateur et les gestionnaires de mots de passe externes sont autorisés. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Vérifiez que l'utilisateur peut choisir soit de visualiser temporairement la totalité du mot de passe masqué, soit de visualiser temporairement le dernier caractère tapé du mot de passe sur les plateformes qui n'ont pas cette fonctionnalité en natif. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nNote : L'objectif de permettre à l'utilisateur de visualiser son mot de passe ou de voir temporairement le dernier caractère est d'améliorer la facilité d'utilisation de la saisie des données d'identification, notamment en ce qui concerne l'utilisation de mots de passe plus longs, de phrases de passe et de gestionnaires de mots de passe. Une autre raison d'inclure cette exigence est de dissuader ou d'empêcher les rapports de test exigeant inutilement des organisations de passer outre le comportement du champ de mot de passe de la plate-forme native pour supprimer cette expérience de sécurité moderne et conviviale.\n\n## V2.2 Exigences générales relatives aux authentificateurs\n\nL'agilité des authentificateurs est essentielle pour que les applications soient à l'épreuve du temps. Les vérificateurs d'applications Refactor permettent d'ajouter des authentificateurs supplémentaires en fonction des préférences de l'utilisateur, et de mettre à la retraite de manière ordonnée les authentificateurs obsolètes ou dangereux.\n\nLe NIST considère le courrier électronique et les SMS comme des [types d'authentificateurs \"restreints\"](https://pages.nist.gov/800-63-FAQ/#q-b1), et il est probable qu'ils soient retirés du NIST 800-63 et donc de l'ASVS à un moment donné dans le futur. Les applications devraient prévoir une feuille de route qui ne nécessite pas l'utilisation du courrier électronique ou des SMS.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.2.1** | Vérifiez que les contrôles anti-automatisation sont efficaces pour atténuer les attaques par violation des tests d'accréditation, par énumération exhaustive (brute-force) et par verrouillage de compte. Ces contrôles comprennent le blocage des mots de passe les plus courants, les verrouillages progressifs, la limitation de débit, les CAPTCHA, les délais toujours plus longs entre les tentatives, les restrictions d'adresse IP ou les restrictions basées sur le risque tel que l'emplacement, la première connexion sur un appareil, les tentatives récentes de déverrouillage du compte, ou autres. Vérifiez qu'il n'y a pas plus de 100 tentatives infructueuses par heure sur un seul compte. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Vérifier que l'utilisation d'authentificateurs faibles (tels que les SMS et les e-mails) se limite à la vérification secondaire et à l'approbation des transactions et ne remplace pas les méthodes d'authentification plus sûres. Vérifiez que les méthodes plus fortes sont proposées avant les méthodes faibles, que les utilisateurs sont conscients des risques, ou que des mesures appropriées sont en place pour limiter les risques de compromission du compte. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Vérifier que des notifications sécurisées sont envoyées aux utilisateurs après la mise à jour des détails d'authentification, tels que la réinitialisation de l'identifiant, le changement d'adresse électronique ou d'adresse, la connexion à partir d'un lieu inconnu ou risqué. L'utilisation de notifications \"push\" - plutôt que de SMS ou d'e-mail - est préférable, mais en l'absence de notifications \"push\", les SMS ou les e-mails sont acceptables tant qu'aucune information sensible n'est divulguée dans la notification. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Vérifier la résistance à l'usurpation d'identité contre le phishing, comme l'utilisation de l'authentification multi-facteurs, les dispositifs cryptographiques avec intention (comme les clés connectées avec un \"push to authenticate\"), ou à des niveaux AAL supérieurs, les certificats côté client. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Vérifier que lorsqu'un fournisseur de services d'accréditation (CSP) et l'application vérifiant l'authentification sont séparés, un TLS mutuellement authentifié est en place entre les deux points terminaux. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Vérifier la résistance aux attaques de rejeu par l'utilisation obligatoire de dispositifs OTP, d'authentificateurs cryptographiques ou de codes de consultation. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Vérifier l'intention d'authentification en exigeant l'entrée d'un jeton OTP ou une action initiée par l'utilisateur telle qu'une pression sur un bouton d'une clé matérielle FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Exigences relatives au cycle de vie des authentificateurs\n\nLes authentificateurs sont les mots de passe, les jetons logiciels, les jetons matériels et les dispositifs biométriques. Le cycle de vie des authentificateurs est essentiel pour la sécurité d'une application - si quelqu'un peut s'enregistrer lui-même sur un compte sans preuve d'identité, il ne peut guère faire confiance à l'affirmation de son identité. Pour les sites de médias sociaux comme Reddit, c'est tout à fait normal. Pour les systèmes bancaires, il est essentiel de mettre davantage l'accent sur l'enregistrement et la délivrance de justificatifs d'identité et de dispositifs pour assurer la sécurité de l'application.\n\nRemarque : les mots de passe ne doivent pas avoir une durée de vie maximale ni être soumis à une rotation. Les mots de passe doivent être vérifiés et non remplacés régulièrement.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.3.1** | Vérifier que les mots de passe ou codes d'activation initiaux générés par le système DOIVENT être générés de manière aléatoire et sécurisée, DOIVENT comporter au moins 6 caractères, PEUVENT contenir des lettres et des chiffres, et expirent après une courte période de temps. Ces secrets initiaux ne doivent pas être autorisés à devenir le mot de passe à long terme. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Vérifiez que l'inscription et l'utilisation de dispositifs d'authentification fournis par l'abonné sont prises en charge, comme les jetons U2F ou FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Vérifier que les instructions de renouvellement sont envoyées suffisamment tôt pour renouveler les authentificateurs à durée déterminée. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Exigences en matière de stockage des identifiants\n\nLes architectes et les développeurs doivent se conformer à cette section lorsqu'ils construisent ou remanient du code. Cette section ne peut être entièrement vérifiée qu'en utilisant la révision du code source ou par des tests unitaires ou d'intégration sécurisés. Les tests d'intrusions ne peuvent pas identifier l'un de ces problèmes.\n\nLa liste des fonctions de dérivation de clés à sens unique approuvées est détaillée dans la section 5.1.1.2 de la norme NIST 800-63 B, et dans [BSI Kryptographische Verfahren : Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). Ces choix peuvent être remplacés par les derniers algorithmes nationaux ou régionaux et les dernières normes de longueur de clé.\n\nCette section ne peut pas être soumise à un test de pénétration, les contrôles ne sont donc pas marqués comme L1. Cependant, cette section est d'une importance vitale pour la sécurité des données d'identifications en cas de vol. Si vous bifurquez l'ASVS pour une directive sur l'architecture ou le codage ou une liste de contrôle pour l'examen du code source, veuillez replacer ces contrôles en L1 dans votre version privée.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.4.1** | Vérifiez que les mots de passe sont stockés sous une forme qui résiste aux attaques hors ligne. Les mots de passe DOIVENT être salés et hachés à l'aide d'une fonction approuvée de dérivation de clé ou de hachage de mot de passe à sens unique. Les fonctions de dérivation de clé et de hachage de mot de passe prennent un mot de passe, un sel et un facteur de coût en entrée pour générer un hachage de mot de passe. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Vérifiez que le sel a une longueur d'au moins 32 bits et qu'il est choisi arbitrairement pour minimiser les collisions de la valeur du sel parmi les hashs stockés. Pour chaque authentifiant, une valeur de sel unique et le hachage qui en résulte DOIVENT être stockés. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Vérifiez que si le PBKDF2 est utilisé, le nombre d'itérations DOIT être aussi important que les performances du serveur de vérification le permettent, généralement au moins 100 000 itérations. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Vérifiez que si bcrypt est utilisé, le facteur de travail DOIT être aussi important que les performances du serveur de vérification le permettent, généralement au moins 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Vérifier qu'une itération supplémentaire d'une fonction de dérivation clé est effectuée, en utilisant une valeur de sel qui est secrète et connue uniquement du vérificateur. Générer la valeur de sel en utilisant un générateur de bits aléatoires approuvé [SP 800-90Ar1] et fournir au moins la sécurité minimale spécifiée dans la dernière révision de la norme SP 800-131A. La valeur de sel secrète DOIT être stockée séparément des mots de passe hachés (par exemple, dans un dispositif spécialisé comme un module de sécurité matériel). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nLorsque des normes américaines sont mentionnées, une norme régionale ou locale peut être utilisée à la place ou en plus de la norme américaine, selon les besoins.\n\n## V2.5 Exigences en matière de récupération des identifiants\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.5.1** | Vérifiez qu'un secret d'activation initiale ou de récupération généré par le système n'est pas envoyé en clair à l'utilisateur.  ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Vérifier que les indices de mot de passe ou l'authentification basée sur la connaissance (dites \"questions secrètes\") ne sont pas présents. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Vérifiez que la récupération du mot de passe ne révèle en aucune façon le mot de passe actuel. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Vérifiez que les comptes partagés ou par défaut ne sont pas présents (par exemple \"root\", \"admin\" ou \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Vérifier que si un facteur d'authentification est modifié ou remplacé, l'utilisateur est informé de cet événement. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Vérifier les mots de passe oubliés, et les autres chemins de récupération utilisent un mécanisme de récupération sécurisé, tel que TOTP ou autre soft token, mobile push, ou un autre mécanisme de récupération hors ligne. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Vérifier qu'en cas de perte des facteurs d'authentification OTP ou multi-facteurs, la preuve d'identité est effectuée au même niveau que lors de l'inscription. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Exigences relatives aux vérificateurs des secrets\n\nLes tables d'authentifications secrètes sont des listes pré-générées de codes secrets, similaires aux numéros d'autorisation de transaction (TAN), aux codes de récupération des médias sociaux ou à une grille contenant un ensemble de valeurs aléatoires. Ils sont distribués aux utilisateurs en toute sécurité. Ces codes de recherche sont utilisés une fois, et une fois qu'ils sont tous utilisés, la liste secrète de recherche est jetée. Ce type d'authentificateur est considéré comme \"quelque chose que vous avez\".\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.6.1** | Vérifiez que les secrets de la table d'authentification ne peuvent être utilisés qu'une seule fois. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Vérifiez que les secrets de la table d'authentification ont un caractère aléatoire suffisant (112 bits d'entropie) ou, s'ils ont moins de 112 bits d'entropie, qu'ils sont salés avec un sel unique et aléatoire de 32 bits et hachés avec un hachage unidirectionnel approuvé. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Vérifiez que les secrets de la table d'authentification résistent aux attaques hors ligne, comme les valeurs prévisibles. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Exigences relatives aux vérificateurs hors bande\n\nDans le passé, un vérificateur hors bande courant aurait été un courriel ou un SMS contenant un lien de réinitialisation de mot de passe. Les attaquants utilisent ce faible mécanisme pour réinitialiser des comptes qu'ils ne contrôlent pas encore, par exemple en prenant le compte de courrier électronique d'une personne et en réutilisant tout lien de réinitialisation découvert. Il existe de meilleurs moyens de gérer la vérification hors bande.\n\nLes authentificateurs hors bande sécurisés sont des dispositifs physiques qui peuvent communiquer avec le vérificateur par un canal secondaire sécurisé. Les notifications \"push\" vers les appareils mobiles en sont des exemples. Ce type d'authentificateur est considéré comme \"quelque chose que vous avez\". Lorsqu'un utilisateur souhaite s'authentifier, l'application de vérification envoie un message à l'authentificateur hors bande via une connexion à l'authentificateur directement ou indirectement par le biais d'un service tiers. Le message contient un code d'authentification (généralement un nombre aléatoire de six chiffres ou un dialogue d'approbation modale). L'application de vérification attend de recevoir le code d'authentification par le canal principal et compare le hachage de la valeur reçue au hachage du code d'authentification original. En cas de correspondance, le vérificateur hors bande peut supposer que l'utilisateur s'est authentifié.\n\nL'ASVS suppose que seuls quelques développeurs développeront de nouveaux authentificateurs hors bande, tels que les notifications \"push\", et donc que les contrôles suivants de l'ASVS s'appliquent aux vérificateurs, tels que l'API d'authentification, les applications et les mises en œuvre de l'authentification unique. Si vous développez un nouvel authentificateur hors bande, veuillez vous référer à NIST 800-63B  5.1.3.1.\n\nLes authentificateurs hors bande dangereux tels que le courrier électronique et la voix sur IP ne sont pas autorisés. Les authentifications PSTN et SMS sont actuellement \"restreintes\" par le NIST et devraient être interdites au profit des notifications \"push\" ou similaires. Si vous devez utiliser l'authentification hors bande par téléphone ou SMS, veuillez consulter  5.1.3.3.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.7.1** | Vérifiez que les authentificateurs de texte en clair hors bande (NIST \"restreint\"), tels que les SMS ou le PSTN, ne sont pas proposés par défaut, et que des alternatives plus fortes, telles que les notifications \"push\", sont proposées en premier lieu. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Vérifiez que le vérificateur hors bande expire les demandes d'authentification, les codes ou les jetons hors bande après 10 minutes. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Vérifiez que les demandes d'authentification, codes ou jetons hors bande du vérificateur ne sont utilisables qu'une seule fois, et uniquement pour la demande d'authentification originale. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Vérifier que l'authentificateur et le vérificateur hors bande communiquent sur un canal indépendant sécurisé. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Vérifiez que le vérificateur hors bande ne conserve qu'une version hachée du code d'authentification. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Vérifiez que le code d'authentification initial est généré par un générateur de nombres aléatoires sécurisé, contenant au moins 20 bits d'entropie (en général, un nombre aléatoire de six chiffres est suffisant). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 Exigences relatives aux vérificateurs uniques à facteur unique ou à facteurs multiples\n\nLes mots de passe à usage unique (OTP) sont des jetons physiques ou logiciels qui affichent un défi pseudo-aléatoire à usage unique en constante évolution. Ces dispositifs rendent le phishing (usurpation d'identité) difficile, mais pas impossible. Ce type d'authentifiant est considéré comme \"quelque chose que vous avez\". Les jetons multi-facteurs sont similaires aux OTP à facteur unique, mais nécessitent un code PIN valide, un déverrouillage biométrique, une insertion USB ou un appariement NFC ou une valeur supplémentaire (comme les calculatrices de signature de transaction) à saisir pour créer l'OTP final.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.8.1** | Vérifier que les OTP basées sur le temps ont une durée de vie définie avant d'expirer. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Vérifier que les clés symétriques utilisées pour vérifier les OTP soumises sont hautement protégées, par exemple en utilisant un module de sécurité matériel ou un stockage de clés basé sur un système d'exploitation sécurisé. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **2.8.3** | Vérifier que des algorithmes cryptographiques approuvés sont utilisés dans la génération, dans la préparation et dans la vérification des OTP. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Vérifiez que l'OTP basé sur le temps ne peut être utilisé qu'une seule fois pendant la période de validité. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Vérifier que si un jeton OTP multi-facteur basé sur le temps est réutilisé pendant la période de validité, il est enregistré et rejeté avec des notifications sécurisées envoyées au détenteur du dispositif. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Vérifier que le générateur OTP physique à facteur unique peut être révoqué en cas de vol ou autre perte. S'assurer que la révocation est immédiatement effective pour toutes les sessions connectées, quel que soit le lieu. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Vérifiez que les authentificateurs biométriques sont limités à une utilisation en tant que facteurs secondaires en conjonction avec quelque chose que vous avez et quelque chose que vous connaissez. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Exigences relatives aux vérificateurs de logiciels et d'appareils cryptographiques\n\nLes clés de sécurité cryptographiques sont des cartes à puce ou des clés FIDO, où l'utilisateur doit brancher ou apparier le dispositif cryptographique à l'ordinateur pour compléter l'authentification. Les vérificateurs envoient un défi aux dispositifs ou logiciels cryptographiques, et le dispositif ou le logiciel calcule une réponse basée sur une clé cryptographique stockée en toute sécurité.\n\nLes exigences relatives aux dispositifs et logiciels cryptographiques à facteur unique et aux dispositifs et logiciels cryptographiques à facteurs multiples sont les mêmes, car la vérification de l'authentificateur cryptographique prouve la possession du facteur d'authentification.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.9.1** | Vérifier que les clés cryptographiques utilisées dans la vérification sont stockées de manière sûre et protégées contre la divulgation, par exemple en utilisant un TPM ou un HSM, ou un service OS qui peut utiliser ce stockage sécurisé. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Vérifiez que le nonce de défi est d'une longueur d'au moins 64 bits, et statistiquement unique ou non pendant la durée de vie du dispositif cryptographique. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Vérifier que des algorithmes cryptographiques approuvés sont utilisés dans la génération, la préparation et la vérification. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Exigences d'authentification des services\n\nCette section n'est pas testable par tests d'intrusions, et n'a donc aucune exigence de L1. Toutefois, si elle est utilisée dans une architecture, un codage ou une révision de code sécurisé, veuillez supposer que le logiciel (tout comme le Java Key Store) est l'exigence minimale de la L1. Le stockage de secrets en texte clair n'est en aucun cas acceptable.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.10.1** | Vérifiez que les secrets d'intégration ne reposent pas sur des mots de passe immuables, tels que les clés API ou les comptes privilégiés partagés. | | OS assisté | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Vérifiez que si des mots de passe sont requis pour l'authentification des services, le compte de service utilisé n'est pas un identifiant par défaut. (par exemple, root/root ou admin/admin sont utilisés par défaut dans certains services lors de l'installation). | | OS assisté | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Vérifiez que les mots de passe sont stockés avec une protection suffisante pour empêcher les attaques de récupération hors ligne, y compris l'accès au système local. | | OS assisté | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Vérifier que les mots de passe, les intégrations avec les bases de données et les systèmes tiers, les seeds et les secrets internes, ainsi que les clés API sont gérés de manière sécurisée et ne sont pas inclus dans le code source ou stockés dans des dépôts de code source. Ce type de stockage DEVRAIT résister aux attaques hors ligne. L'utilisation d'un stockage de clés logiciel sécurisé (L1), d'un module de plate-forme de confiance (TPM) ou d'un module de sécurité matériel (L3) est recommandée pour le stockage des mots de passe. | | OS assisté | HSM | 798 | |\n\n## Exigences supplémentaires des agences américaines\n\nLes agences américaines ont des exigences obligatoires concernant le NIST 800-63. La norme de vérification de la sécurité des applications a toujours été d'environ 80% des contrôles qui s'appliquent à près de 100% des applications, et non les derniers 20% des contrôles avancés ou ceux qui ont une applicabilité limitée. En tant que telle, l'ASVS est un sous-ensemble strict de la norme NIST 800-63, en particulier pour les classifications IAL1/2 et AAL1/2, mais elle n'est pas suffisamment complète, notamment en ce qui concerne les classifications IAL3/AAL3.\n\nNous demandons instamment aux agences gouvernementales américaines de revoir et de mettre en œuvre la norme NIST 800-63 dans son intégralité.\n\n## Glossaire des termes\n\n| Terme | Signification |\n| --- | --- |\n| CSP | Credential Service Provider également appelé fournisseur d'identité |\n| Authenticator | Code qui authentifie un mot de passe, un jeton, un MFA, une affirmation fédérée, etc. |\n| Vérificateur | \"Entité qui vérifie l'identité du demandeur en vérifiant la possession et le contrôle par le demandeur d'un ou deux authentificateurs au moyen d'un protocole d'authentification. Pour ce faire, le vérificateur peut également avoir besoin de valider les références qui lient le ou les authentificateurs à l'identifiant de l'abonné et vérifier leur statut\" |\n| OTP | Mot de passe unique |\n| SFA | Les authentificateurs à facteur unique, tels que quelque chose que vous connaissez (secrets mémorisés, mots de passe, phrases de passe, codes PIN), quelque chose que vous êtes (biométrie, empreintes digitales, scanners du visage), ou quelque chose que vous avez (jetons OTP, un dispositif cryptographique tel qu'une carte à puce), |\n| MFA | Authentification multi-facteurs, qui comprend deux ou plusieurs facteurs uniques |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:54.287665"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x12-V3-Session-management.md", "content": "# V3 Exigences de vérification de la gestion des sessions\n\n## Objectif de contrôle\n\nL'une des composantes essentielles de toute application web ou API à état est le mécanisme par lequel elle contrôle et maintient l'état pour un utilisateur ou un dispositif qui interagit avec elle. La gestion de session transforme un protocole sans état en protocole avec état, ce qui est essentiel pour différencier les différents utilisateurs ou appareils.\n\nAssurez-vous qu'une application vérifiée satisfait aux exigences de gestion de session de haut niveau suivantes :\n\n* Les sessions sont uniques à chaque individu et ne peuvent être devinées ou partagées.\n* Les sessions sont invalidées lorsqu'elles ne sont plus nécessaires et sont interrompues pendant les périodes d'inactivité.\n\nComme indiqué précédemment, ces exigences ont été adaptées pour constituer un sous-ensemble conforme de contrôles NIST 800-63b sélectionnés, axés sur les menaces communes et les faiblesses d'authentification couramment exploitées. Les exigences de vérification précédentes ont été supprimées, réduites ou, dans la plupart des cas, adaptées pour être fortement alignées sur l'intention des exigences obligatoires [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n## Exigences de vérification de sécurité\n\n## V3.1 Exigences fondamentales en matière de gestion des sessions\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.1.1** | Vérifiez que l'application ne révèle jamais les jetons de session dans les paramètres d'URL ou les messages d'erreur.  | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Exigences contraignantes de la session\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.2.1** | Vérifiez que l'application génère un nouveau jeton de session sur l'authentification de l'utilisateur. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Vérifiez que les jetons de session possèdent au moins 64 bits d'entropie. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Vérifiez que l'application ne stocke que des jetons de session dans le navigateur en utilisant des méthodes sûres telles que les cookies correctement sécurisés (voir section 3.4) ou le stockage de session HTML 5. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Vérifiez que les jetons de session sont générés à l'aide d'algorithmes cryptographiques approuvés. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nLe TLS ou un autre canal de transport sécurisé est obligatoire pour la gestion des sessions. Cette question est traitée dans le chapitre sur la sécurité des communications.\n\n## V3.3 Exigences en matière de déconnexion et de temporisation des sessions\n\nLes durées de session ont été alignées sur la norme NIST 800-63, qui autorise des durées de session beaucoup plus longues que celles traditionnellement autorisées par les normes de sécurité. Les organisations doivent examiner le tableau ci-dessous, et si un délai plus long est souhaitable en fonction du risque de l'application, la valeur NIST doit être la limite supérieure des délais d'inactivité de la session.\n\nDans ce contexte, la valeur L1 est IAL1/AAL1, la valeur L2 est IAL2/AAL3, la valeur L3 est IAL3/AAL3. Pour IAL2/AAL2 et IAL3/AAL3, le délai d'inactivité le plus court est la limite inférieure des délais d'inactivité pour être déconnecté ou ré-authentifié pour reprendre la session.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.3.1** | Vérifiez que la déconnexion et l'expiration invalident le jeton de session, de sorte que le bouton de retour ou une partie de confiance en aval ne reprenne pas une session authentifiée, y compris entre les parties de confiance. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Si les authentificateurs permettent aux utilisateurs de rester connectés, vérifiez que la ré-authentification a lieu périodiquement, que ce soit en cas d'utilisation active ou après une période d'inactivité. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 jours | 12 heures ou 30 minutes d'inactivité, 2FA facultatif | 12 heures ou 15 minutes d'inactivité, avec 2FA | 613 | 7.2 |\n| **3.3.3** | Vérifiez que l'application offre la possibilité de mettre fin à toutes les autres sessions actives après un changement de mot de passe réussi (y compris le changement par réinitialisation/récupération du mot de passe), et que cette option est effective dans toute l'application, la connexion fédérée (si elle existe) et toute partie qui se fie à elle. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Vérifiez que les utilisateurs sont en mesure de consulter et (après avoir saisi à nouveau leurs identifiants de connexion) de se déconnecter d'une ou de toutes les sessions et de tous les dispositifs actuellement actifs. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Gestion de session basée sur les cookies\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.4.1** | Vérifiez que les jetons de session basés sur des cookies ont l'attribut 'Secure'. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Vérifiez que les jetons de session basés sur des cookies ont l'attribut 'HttpOnly'. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Vérifiez que les jetons de session basés sur des cookies utilisent l'attribut 'SameSite' pour limiter l'exposition aux attaques de contrefaçon par requête intersite. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1275 | 7.1.1 |\n| **3.4.4** | Vérifiez que les jetons de session basés sur les cookies utilisent le préfixe \"__Host-\" (voir références) pour assurer la confidentialité des cookies de session. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Vérifiez que si la demande est publiée sous un nom de domaine avec d'autres applications qui définissent ou utilisent des cookies de session susceptibles de les remplacer ou de les divulguer, définissez l'attribut de chemin dans les jetons de session basés sur les cookies en utilisant le chemin le plus précis possible. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Gestion de session à jetons\n\nLa gestion des sessions basée sur des jetons comprend les clés JWT, OAuth, SAML et API. Parmi celles-ci, les clés API sont connues pour être faibles et ne doivent pas être utilisées dans un nouveau code.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.5.1** | Vérifiez que l'application permet aux utilisateurs de révoquer les jetons OAuth qui forment des relations d'approbation avec les applications liées.  | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Vérifiez que l'application utilise des jetons de session plutôt que des secrets et des clés d'API statiques, sauf dans le cas d'anciennes implémentations (legacy). | | ✓ | ✓ | 798 | |\n| **3.5.3** | Vérifiez que les jetons de session sans état utilisent les signatures numériques, le chiffrement et d'autres contre-mesures pour se protéger contre les attaques par altération, mise sous enveloppe, rediffusion, chiffrement nul et substitution de clé. | | ✓ | ✓ | 345 | |\n\n## V3.6 Re-authentification d'une fédération ou d'une assertion\n\nCette section concerne les personnes qui écrivent le code de la partie de relais (RP) ou du fournisseur de services d'accréditation (CSP). Si vous comptez sur un code mettant en œuvre ces caractéristiques, assurez-vous que ces questions sont traitées correctement.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.6.1** | Vérifier que les parties qui se fient à la procédure précisent le délai maximal d'authentification aux fournisseurs de services d'authentification (CSP) et que ces derniers ré-authentifient l'abonné s'ils n'ont pas utilisé de session pendant cette période. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Vérifier que les fournisseurs de services d'accréditation (CSP) informent les parties ayant fait confiance au dernier événement d'authentification, afin de permettre aux RP de déterminer s'ils doivent ré-authentifier l'utilisateur. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Défenses contre l'exploitation de la gestion des sessions\n\nIl existe un petit nombre d'attaques de gestion de session, dont certaines sont liées à l'expérience utilisateur (UX) des sessions. Auparavant, sur la base des exigences de la norme ISO 27002, l'ASVS exigeait le blocage de plusieurs sessions simultanées. Le blocage de sessions simultanées n'est plus approprié, non seulement parce que les utilisateurs modernes disposent de nombreux appareils ou que l'application est une API sans session de navigateur, mais aussi parce que dans la plupart de ces implémentations, le dernier authentificateur gagne, qui est souvent l'attaquant. Cette section fournit des conseils de premier plan sur la dissuasion, le retard et la détection des attaques de gestion de session à l'aide de code.\n\n### Description de l'attaque semi-ouverte\n\nAu début de 2018, plusieurs institutions financières ont été compromises par ce que les attaquants ont appelé des \"attaques à demi ouvertes\". Ce terme est resté dans l'industrie. Les attaquants ont frappé plusieurs institutions avec des bases de code propriétaires différentes, et en effet il semble que les bases de code soient différentes au sein des mêmes institutions. L'attaque semi-ouverte exploite un défaut de conception communément rencontré dans de nombreux systèmes d'authentification, de gestion de session et de contrôle d'accès existants.\n\nLes attaquants lancent une attaque à demi-ouverte en essayant de verrouiller, de réinitialiser ou de récupérer un justificatif d'identité. Un modèle de gestion de session très répandu réutilise les objets/modèles de session de profil utilisateur entre le code non authentifié, semi-authentifié (réinitialisation du mot de passe, nom d'utilisateur oublié) et entièrement authentifié. Ce modèle remplit un objet de session ou un jeton valide contenant le profil de la victime, y compris les hachages de mots de passe et les rôles. Si les contrôles d'accès dans les contrôleurs ou les routeurs ne vérifient pas correctement que l'utilisateur est bien connecté, l'attaquant pourra agir en tant qu'utilisateur. Les attaques peuvent inclure la modification du mot de passe de l'utilisateur à une valeur connue, la mise à jour de l'adresse électronique pour effectuer une réinitialisation de mot de passe valide, la désactivation de l'authentification multifactorielle ou l'inscription d'un nouveau dispositif d'AMF, la révélation ou la modification des clés API, etc.\n\n| # | Description | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.7.1** | Vérifier que l'application garantit une session de connexion complète et valide ou exige une nouvelle authentification ou une vérification secondaire avant d'autoriser toute transaction sensible ou modification de compte. | ✓ | ✓ | ✓ | 306 | |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:54.401553"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x12-V4-Access-Control.md", "content": "# V4 Exigences de vérification du contrôle d'accès\n\n## Objectif de contrôle\n\nL'autorisation est le concept qui consiste à ne permettre l'accès aux ressources qu'à ceux qui sont autorisés à les utiliser. Assurez-vous qu'une application vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* Les personnes qui accèdent aux ressources possèdent une autorisation valide pour le faire.\n* Les utilisateurs sont associés à un ensemble bien défini de rôles et de privilèges.\n* Les métadonnées relatives aux rôles et aux autorisations sont protégées contre toute rediffusion ou altération.\n\n## Exigences de vérification de la sécurité\n\n## V4.1 Conception générale du contrôle d'accès\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.1.1** | Vérifiez que l'application applique les règles de contrôle d'accès sur une couche de service de confiance, en particulier si le contrôle d'accès côté client est présent et pourrait être contourné. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Vérifier que tous les attributs des utilisateurs et des données et les informations sur les politiques utilisées par les contrôles d'accès ne peuvent être manipulés par les utilisateurs finaux, sauf autorisation spécifique. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Vérifier que le principe du moindre privilège existe - les utilisateurs ne doivent pouvoir accéder qu'aux fonctions, fichiers de données, URL, contrôleurs, services et autres ressources pour lesquels ils possèdent une autorisation spécifique. Cela implique une protection contre l'usurpation et l'élévation des privilèges. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 4.1.3] | | | | |\n| **4.1.5** | Vérifier que les contrôles d'accès échouent de manière sûre, y compris lorsqu'une exception se produit. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Contrôle d'accès au niveau des opérations\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.2.1** | Vérifier que les données sensibles et les API sont protégées contre les attaques par référence directe à un objet (IDOR) non sécurisées visant la création, la lecture, la mise à jour et la suppression d'enregistrements, telles que la création ou la mise à jour de l'enregistrement de quelqu'un d'autre, la consultation de tous les enregistrements ou la suppression de tous les enregistrements. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Vérifiez que l'application ou le cadriciel applique un mécanisme anti-CSRF fort pour protéger les fonctionnalités authentifiées, et qu'une anti-automation ou un anti-CSRF efficace protège les fonctionnalités non authentifiées. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Autres considérations relatives au contrôle d'accès\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.3.1** | Vérifier que les interfaces administratives utilisent une authentification multifactorielle appropriée pour empêcher toute utilisation non autorisée. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Vérifiez que la navigation dans les répertoires est désactivée, sauf si vous le souhaitez délibérément. En outre, les applications ne doivent pas permettre la découverte ou la divulgation de métadonnées de fichiers ou de répertoires, tels que les dossiers Thumbs.db, .DS_Store, .git ou .svn. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Vérifier que la demande dispose d'une autorisation supplémentaire (telle qu'une authentification renforcée ou adaptative) pour les systèmes à faible valeur, et/ou d'une séparation des tâches pour les demandes à valeur élevée afin de faire appliquer les contrôles anti-fraude en fonction du risque de fraude de la demande et de la fraude passée. | | ✓ | ✓ | 732 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:54.525918"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Exigences de validation, d'assainissement et de vérification de l'encodage\n\n## Objectif de contrôle\n\nLa faiblesse la plus courante en matière de sécurité des applications web est l'incapacité à valider correctement les données provenant du client ou de l'environnement avant de les utiliser directement sans aucun encodage de sortie. Cette faiblesse est à l'origine de presque toutes les vulnérabilités importantes des applications web, telles que le Cross-Site Scripting (XSS), l'injection SQL, l'injection d'interpréteur, les attaques locales/Unicode, les attaques de système de fichiers et les débordements de mémoire tampon.\n\nAssurez-vous qu'une application vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* La validation des entrées et l'architecture de codage des sorties ont un pipeline convenu pour prévenir les attaques par injection.\n* Les données d'entrée sont fortement typées, validées, vérifiées en plage ou en longueur ou au pire, aseptisées ou filtrées.\n* Les données de sortie sont codées ou échappées selon le contexte des données, aussi près que possible de l'interpréteur.\n\nAvec l'architecture moderne des applications web, l'encodage des données de sortie est plus important que jamais. Il est difficile de fournir une validation robuste des entrées dans certains scénarios, de sorte que l'utilisation d'API plus sûres telles que les requêtes paramétrées, les frameworks de modélisation d'échappement automatique ou un encodage de sortie soigneusement choisi sont essentiels pour la sécurité de l'application.\n\n## V5.1 Exigences de validation des entrées\n\nDes contrôles de validation des entrées correctement mis en œuvre, utilisant une liste d'autorisation positive et un fort typage des données, peuvent éliminer plus de 90 % de toutes les attaques par injection. Les contrôles de longueur et de portée peuvent encore réduire ce phénomène. Il est nécessaire de mettre en place une validation d'entrée sécurisée pendant l'architecture de l'application, les sprints de conception, le codage et les tests unitaires et d'intégration. Bien que nombre de ces éléments ne puissent être trouvés dans les tests de pénétration, les résultats de leur non-implantation se trouvent généralement dans la version 5.3 - Exigences en matière de codage de sortie et de prévention des injections. Il est recommandé aux développeurs et aux réviseurs de codes sécurisés de traiter cette section comme si la L1 était requise pour tous les éléments afin de prévenir les injections.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.1.1** | Vérifiez que l'application dispose de défenses contre les attaques de pollution des paramètres HTTP, en particulier si le cadre de l'application ne fait aucune distinction quant à la source des paramètres de la requête (GET, POST, cookies, en-têtes ou variables d'environnement). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Vérifiez que les cadriciels protègent contre les attaques par assignation massive de paramètres, ou que l'application dispose de contre-mesures pour protéger contre l'assignation dangereuse de paramètres, comme le marquage des champs privés ou similaires. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Vérifiez que toutes les entrées (champs de formulaire HTML, requêtes REST, paramètres URL, en-têtes HTTP, cookies, fichiers batch, flux RSS, etc) sont validées par une validation positive (liste d'autorisation). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Vérifier que les données structurées sont fortement typées et validées par rapport à un schéma défini comprenant les caractères, la longueur et le modèle autorisés (par exemple, numéros de carte de crédit ou de téléphone, ou valider que deux champs connexes sont raisonnables, comme vérifier la correspondance entre la banlieue et le code postal). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Vérifiez que les redirections et les transferts d'URL n'autorisent que les destinations prévues, ou affichez un avertissement lors d'une redirection vers un contenu potentiellement non fiable. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Exigences en matière d'assainissement et de « bac à sable »\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.2.1** | Vérifiez que toutes les entrées HTML non fiables provenant d'éditeurs WYSIWYG ou similaires sont correctement assainies avec une bibliothèque ou une fonction de framework de nettoyage HTML. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Vérifiez que les données non structurées sont assainies afin d'appliquer les mesures de sécurité telles que les caractères et la longueur autorisés. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Vérifiez que l'application assainit les entrées de l'utilisateur avant de passer aux systèmes de messagerie pour protéger contre l'injection SMTP ou IMAP. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Vérifiez que l'application évite l'utilisation de eval() ou d'autres fonctions d'exécution de code dynamique. Lorsqu'il n'y a pas d'alternative, toute entrée utilisateur incluse doit être assainie ou mise en sandbox avant d'être exécutée. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Vérifiez que l'application protège contre les attaques par injection de modèles en veillant à ce que toute entrée de l'utilisateur incluse soit aseptisée ou mise en bac à sable. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Vérifier que l'application protège contre les attaques SSRF, en validant ou en assainissant les données non fiables ou les métadonnées de fichiers HTTP, comme les noms de fichiers et les champs de saisie d'URL, utiliser la liste d'autorisation des protocoles, domaines, chemins et ports. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Vérifiez que l'application assainit, désactive ou met en place une isolation (sandbox) pour le contenu scriptable fourni par l'utilisateur (Scalable Vector Graphics - SVG), en particulier en ce qui concerne les XSS résultant de scripts natifs au code présent et foreignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Vérifiez que l'application assainit, désactive ou met en sandbox le contenu des scripts ou des modèles d'expression fournis par l'utilisateur, tels que les feuilles de style Markdown, CSS ou XSL, le BBCode ou autres. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Exigences en matière d'encodage de sortie et de prévention des injections\n\nL'encodage de la sortie à proximité de l'interprète utilisé est essentiel pour la sécurité de toute application. Généralement, l'encodage de sortie n'est pas persistant, mais utilisé pour rendre la sortie sûre dans le contexte de sortie approprié pour une utilisation immédiate. Le défaut d'encodage de la sortie entraînera une application non sécurisée, injectable et dangereuse.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.3.1** | Vérifiez que l'encodage de sortie est pertinent pour l'interprète et le contexte requis. Par exemple, utilisez des encodeurs spécifiques pour les valeurs HTML, les attributs HTML, JavaScript, les paramètres URL, les en-têtes HTTP, SMTP et autres selon le contexte, en particulier à partir d'entrées non fiables (par exemple les noms avec Unicode ou apostrophes, comme ねこ ou O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Vérifiez que l'encodage de sortie préserve le jeu de caractères et la langue choisis par l'utilisateur, de sorte que tout point de caractère Unicode soit valide et traité en toute sécurité. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Vérifiez que l'encodage des sorties en fonction du contexte, de préférence automatisé - ou au pire, manuel - protège contre le XSS réfléchi, stocké et basé sur le DOM. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Vérifier que la sélection de données ou les requêtes de base de données (par exemple SQL, HQL, ORM, NoSQL) utilisent des requêtes paramétrées, des ORM, des cadres d'entités, ou sont autrement protégées contre les attaques par injection de base de données. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Vérifiez que, lorsque des mécanismes paramétrés ou plus sûrs ne sont pas présents, un encodage de sortie spécifique au contexte est utilisé pour se protéger contre les attaques par injection, comme l'utilisation de l'échappement SQL pour se protéger contre l'injection SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Vérifiez que l'application se protège contre les attaques par injection de JSON, les attaques par évaluation de JSON et les évaluations d'expressions JavaScript. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Vérifiez que l'application protège contre les vulnérabilités de LDAP Injection, ou que des contrôles de sécurité spécifiques pour empêcher des injections LDAP ont été mis en place. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Vérifiez que l'application protège contre l'injection de commandes du système d'exploitation et que les appels du système d'exploitation utilisent des requêtes paramétrées du système d'exploitation ou utilisent l'encodage contextuel de la sortie de la ligne de commande. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Vérifiez que l'application protège contre les attaques par inclusion de fichier local (LFI) ou par inclusion de fichier distant (RFI). | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Vérifiez que l'application protège contre les attaques par injection XPath ou par injection XML. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nNote : L'utilisation de requêtes paramétrées ou l'échappement du SQL n'est pas toujours suffisant ; les noms de tables et de colonnes, ORDER BY, etc. ne peuvent pas être échappés. L'inclusion de données échappées fournies par l'utilisateur dans ces champs entraîne l'échec des requêtes ou de l'injection SQL.\n\nNote : Le format SVG autorise explicitement le script ECMA dans presque tous les contextes, de sorte qu'il peut ne pas être possible de bloquer complètement tous les vecteurs XSS SVG. Si un téléchargement SVG est nécessaire, nous recommandons fortement soit de servir ces fichiers téléchargés en tant que texte/plain, soit d'utiliser un domaine de contenu distinct fourni par l'utilisateur pour empêcher que le XSS ne prenne le relais de l'application.\n\n## V5.4 Exigences en matière de mémoire, de chaînes de caractères et de code non géré\n\nLes exigences suivantes ne s'appliquent que lorsque l'application utilise un langage système ou un code non géré.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.4.1** | Vérifiez que l'application utilise une chaîne de caractères à mémoire sécurisée, une copie mémoire sécurisée et l'arithmétique des pointeurs pour détecter ou empêcher les débordements de pile, de mémoire tampon ou de tas. | | ✓ | ✓ | 120 |\n| **5.4.2** | Vérifiez que les chaînes de format ne prennent pas d'entrée potentiellement hostile, et sont constantes. | | ✓ | ✓ | 134 |\n| **5.4.3** | Vérifiez que les techniques de validation des signes, des plages et des entrées sont utilisées pour éviter les débordements d'entiers. | | ✓ | ✓ | 190 |\n\n## V5.5 Exigences de prévention de la désérialisation\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | Vérifiez que les objets sérialisés utilisent des contrôles d'intégrité ou sont chiffrés pour empêcher la création d'objets hostiles ou la falsification de données. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Vérifiez que l'application restreint correctement les analyseurs XML pour n'utiliser que la configuration la plus restrictive possible et pour s'assurer que les fonctions dangereuses telles que la résolution d'entités externes sont désactivées pour empêcher les XXE.  | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Vérifiez que la désérialisation des données non fiables est évitée ou protégée à la fois dans le code personnalisé et les bibliothèques tierces (comme les analyseurs JSON, XML et YAML).  | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Vérifiez que lors de l'analyse de JSON dans les navigateurs ou les backends basés sur JavaScript, JSON.parse est utilisé pour analyser le document JSON. N'utilisez pas eval() pour analyser JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nPour plus d'informations sur l'évasion automatique, veuillez consulter\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nPour plus d'informations sur la désérialisation, veuillez consulter\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:54.595428"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x14-V6-Cryptography.md", "content": "# V6 Exigences de vérification de la cryptographie stockée\n\n## Objectif de contrôle\n\nAssurez-vous qu'une application vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* Tous les modules cryptographiques échouent de manière sécurisée et que les erreurs sont traitées correctement.\n* Un générateur de nombres aléatoires approprié est utilisé.\n* L'accès aux clés est géré de manière sécurisée.\n\n## V6.1 Classification des données\n\nL'actif le plus important est constitué par les données traitées, stockées ou transmises par une application. Il faut toujours procéder à une évaluation de l'impact sur la vie privée afin de classer correctement les besoins en matière de protection des données de toute donnée stockée.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.1.1** | Vérifier que les données privées réglementées sont stockées sous forme chiffrée pendant le repos, comme les informations d'identification personnelle (IIP), les informations personnelles sensibles ou les données considérées comme susceptibles d'être soumises à la GDPR de l'UE. | | ✓ | ✓ | 311 |\n| **6.1.2** | Vérifier que les données de santé réglementées sont stockées de manière chiffrée pendant le repos, comme les dossiers médicaux, les détails des dispositifs médicaux ou les dossiers de recherche désanonymisés. | | ✓ | ✓ | 311 |\n| **6.1.3** | Vérifiez que les données financières réglementées sont stockées de manière cryptée lorsqu'elles sont au repos, telles que les comptes financiers, les défauts ou les antécédents de crédit, les dossiers fiscaux, l'historique des salaires, les bénéficiaires ou les dossiers de marché ou de recherche désanonymisés. | | ✓ | ✓ | 311 |\n\n## V6.2 Algorithmes\n\nLes récents progrès de la cryptographie signifient que des algorithmes et des longueurs de clé auparavant sûrs ne sont plus sûrs ou suffisants pour protéger les données. Il devrait donc être possible de modifier les algorithmes.\n\nBien que cette section ne soit pas facilement testée lors des tests d'intrusions, les développeurs devraient considérer toute cette section comme obligatoire même si la L1 est absente de la plupart des éléments.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.2.1** | Vérifiez que tous les modules cryptographiques échouent en toute sécurité, et que les erreurs sont traitées de manière à ne pas permettre les attaques de type \"Padding Oracle\". | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Vérifiez que des algorithmes, des bibliothèques cryptographiques et des modes éprouvés par l'industrie ou approuvés par le gouvernement sont utilisés, au lieu de la cryptographie codée sur mesure. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Vérifiez que le vecteur d'initialisation du chiffrement, la configuration du chiffrement et les modes de blocage sont configurés de manière sécurisée en utilisant les derniers conseils. | | ✓ | ✓ | 326 |\n| **6.2.4** | Vérifiez que les algorithmes de chiffrement ou de hachage, les longueurs de clé, le nombre de rondes, les chiffrements ou les modes peuvent être reconfigurés, mis à niveau ou échangés à tout moment, pour se protéger contre les failles cryptographiques. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Vérifiez que les modes de blocs non sécurisés connus (c'est-à-dire ECB, etc.), les modes de remplissage (c'est-à-dire PKCS#1 v1.5, etc.), les chiffrements avec des blocs de petites tailles (c'est-à-dire Triple-DES, Blowfish, etc.) et les algorithmes de hachage faibles (c'est-à-dire MD5, SHA1, etc.) ne sont pas utilisés, sauf si cela est nécessaire pour la rétrocompatibilité. | | ✓ | ✓ | 326 |\n| **6.2.6** | Vérifiez que les nonces, vecteurs d'initialisation et autres numéros à usage unique ne doivent pas être utilisés plus d'une fois avec une clé de chiffrement donnée. La méthode de génération doit être appropriée à l'algorithme utilisé. | | ✓ | ✓ | 326 |\n| **6.2.7** | Vérifier que les données chiffrées sont authentifiées par des signatures, des modes de chiffrement authentifiés ou le [HMAC](https://en.wikipedia.org/wiki/HMAC) pour s'assurer que le texte chiffré n'est pas altéré par une partie non autorisée. | | | ✓ | 326 |\n| **6.2.8** | Vérifiez que toutes les opérations cryptographiques sont à temps constant, sans opérations de \"court-circuit\" dans les comparaisons, les calculs ou les retours, afin d'éviter les fuites d'informations. | | | ✓ | 385 |\n\n## V6.3 Valeurs aléatoires\n\nLa véritable génération de nombres pseudo-aléatoires (PRNG) est incroyablement difficile à réaliser. En général, les bonnes sources d'entropie au sein d'un système seront rapidement épuisées si elles sont trop utilisées, mais des sources moins aléatoires peuvent conduire à des clés et des secrets prévisibles.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.3.1** | Vérifiez que tous les nombres aléatoires, noms de fichiers aléatoires, GUIDs aléatoires et chaînes aléatoires sont générés en utilisant le générateur de nombres aléatoires sécurisé cryptographiquement approuvé par le module cryptographique lorsque ces valeurs aléatoires sont destinées à ne pas être devinées par un attaquant. | | ✓ | ✓ | 338 |\n| **6.3.2** | Vérifiez que les GUID aléatoires sont créés en utilisant l'algorithme GUID v4, et un générateur de nombres pseudo-aléatoires sécurisé cryptographiquement (CSPRNG). Les GUID créés à l'aide d'autres générateurs de nombres pseudo-aléatoires peuvent être prévisibles. | | ✓ | ✓ | 338 |\n| **6.3.3** | Vérifiez que les nombres aléatoires sont créés avec une entropie correcte même lorsque l'application est soumise à une forte charge, ou que l'application se dégrade gracieusement dans de telles circonstances. | | | ✓ | 338 |\n\n## V6.4 Gestion du secret\n\nBien que cette section ne soit pas facilement testée, les développeurs devraient considérer toute cette section comme obligatoire même si la L1 est absente de la plupart des éléments.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.4.1** | Vérifiez qu'une solution de gestion des secrets, telle qu'un coffre-fort de clés, est utilisée pour créer, stocker, contrôler l'accès aux secrets et les détruire en toute sécurité. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Vérifiez que le matériel clé ne soit pas exposé à l'application, mais utilise plutôt un module de sécurité isolé comme un coffre-fort pour les opérations cryptographiques. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:54.669981"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x15-V7-Error-Logging.md", "content": "# V7 Traitement des erreurs et exigences de vérification de l'enregistrement\n\n## Objectif de contrôle\n\nL'objectif premier du traitement et de la journalisation des erreurs est de fournir des informations utiles à l'utilisateur, aux administrateurs et aux équipes de réponse aux incidents. L'objectif n'est pas de créer des quantités massives de journaux, mais des journaux de haute qualité, avec plus de signal que de bruit rejeté.\n\nLes journaux de haute qualité contiennent souvent des données sensibles et doivent être protégés conformément aux lois ou directives locales en matière de confidentialité des données. Cela devrait inclure :\n\n* Ne pas collecter ou enregistrer des informations sensibles, sauf si cela est spécifiquement requis.\n* Veiller à ce que toutes les informations enregistrées soient traitées de manière sûre et protégées conformément à leur classification.\n* Veiller à ce que les journaux ne soient pas conservés éternellement, mais qu'ils aient une durée de vie absolue aussi courte que possible.\n\nSi les journaux contiennent des données privées ou sensibles, dont la définition varie d'un pays à l'autre, les journaux deviennent parmi les informations les plus sensibles détenues par l'application et donc très attrayantes pour les attaquants en soi.\n\nIl est également important de s'assurer que l'application échoue en toute sécurité et que les erreurs ne divulguent pas d'informations inutiles.\n\n## V7.1 Exigences relatives au contenu des journaux\n\nL'enregistrement d'informations sensibles est dangereux : les journaux deviennent eux-mêmes classifiés, ce qui signifie qu'ils doivent être cryptés, faire l'objet de politiques de conservation et être divulgués lors d'audits de sécurité. Assurez-vous que seules les informations nécessaires sont conservées dans les journaux, et certainement pas les paiements, les justificatifs d'identité (y compris les jetons de session), les informations sensibles ou identifiables personnellement.\n\nV7.1 couvre le Top 10 de l'OWASP 2017:A10. Comme 2017:A10 et cette section ne sont pas testables tests d'intrusions, il est important pour :\n\n* Les développeurs de s'assurer de la conformité totale avec cette section, comme si tous les éléments étaient marqués comme L1\n* Tests de pénétration de valider la conformité totale de tous les éléments de la V7.1 par le biais d'un entretien, de captures d'écran ou d'une affirmation\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.1.1** | Vérifiez que le journal n'enregistre pas les références ou les détails de paiement. Les jetons de session ne doivent être stockés dans les journaux que sous une forme hachée et irréversible. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Vérifiez que l'application n'enregistre pas d'autres données sensibles telles que définies par les lois locales sur la protection de la vie privée ou la politique de sécurité pertinente. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Vérifiez que l'application enregistre les événements pertinents pour la sécurité, y compris les événements d'authentification réussis et échoués, les échecs de contrôle d'accès, les échecs de désérialisation et les échecs de validation des entrées. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Vérifiez que chaque événement consigné dans le journal contient les informations nécessaires pour permettre une enquête détaillée sur la chronologie de l'événement. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Exigences de traitement des journaux\n\nIl est essentiel d'enregistrer en temps utile les événements de vérification, le triage et l'escalade. Assurez-vous que les journaux de l'application sont clairs et peuvent être facilement surveillés et analysés, soit localement, soit envoyés à un système de surveillance à distance.\n\nV7.2 couvre le Top 10 de l'OWASP 2017:A10. Comme 2017:A10 et cette section ne sont pas testables, il est important pour :\n\n* Les développeurs de s'assurer de la conformité totale avec cette section, comme si tous les éléments étaient marqués comme L1\n* Tests de pénétration de valider la conformité totale de tous les éléments de la V7.2 par le biais d'un entretien, de captures d'écran ou d'une affirmation\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.2.1** | Vérifiez que toutes les décisions d'authentification sont consignées, sans stocker d'identifiants de session ou de mots de passe sensibles. Cela devrait inclure les demandes avec les métadonnées pertinentes nécessaires aux enquêtes de sécurité.  | | ✓ | ✓ | 778 |\n| **7.2.2** | Vérifiez que toutes les décisions de contrôle d'accès peuvent être enregistrées et que toutes les décisions qui ont échoué sont enregistrées. Cela devrait inclure les demandes avec les métadonnées pertinentes nécessaires aux enquêtes de sécurité. | | ✓ | ✓ | 285 |\n\n## V7.3 Exigences en matière de protection des journaux\n\nLes journaux qui peuvent être trivialement modifiés ou supprimés sont inutiles pour les enquêtes et les poursuites. La divulgation des journaux peut révéler des détails internes sur l'application ou les données qu'elle contient. Il convient de prendre des précautions pour protéger les journaux contre toute divulgation, modification ou suppression non autorisée.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.3.1** | Vérifiez que l'application encode correctement les données fournies par l'utilisateur pour éviter l'injection de logs. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 7.3.1] | | | | |\n| **7.3.3** | Vérifiez que les journaux de sécurité sont protégés contre tout accès et toute modification non autorisés. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Vérifiez que les sources de temps sont synchronisées avec l'heure et le fuseau horaire corrects. Envisager sérieusement de n'enregistrer les données qu'en UTC si les systèmes sont globaux pour faciliter l'analyse criminalistique post-incident. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nRemarque : L'encodage des journaux (7.3.1) est difficile à tester et à examiner à l'aide d'outils dynamiques automatisés et de tests de pénétration, mais les architectes, les développeurs et les réviseurs de code source devraient le considérer comme une exigence de niveau 1.\n\n## V7.4 Traitement des erreurs\n\nL'objectif du traitement des erreurs est de permettre à l'application de fournir des événements pertinents pour la sécurité en vue de la surveillance, du triage et de l'escalade. L'objectif n'est pas de créer des journaux. Lorsque vous enregistrez des événements liés à la sécurité, assurez-vous que le journal a un but et qu'il peut être distingué par le SIEM ou un logiciel d'analyse.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.4.1** | Vérifiez qu'un message générique s'affiche lorsqu'une erreur inattendue ou sensible à la sécurité se produit, éventuellement avec un identifiant unique que le personnel de soutien peut utiliser pour enquêter.  ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Vérifiez que le traitement des exceptions est utilisé dans tout le code source pour tenir compte des conditions d'erreur prévues et imprévues. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Vérifiez qu'un gestionnaire d'erreurs de \"dernier recours\" est défini, qui prendra en compte toutes les exceptions non traitées. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nNote : Certains langages, tels que Swift et Go - et selon la pratique courante de conception - de nombreux langages fonctionnels, ne prennent pas en charge les exceptions ou les gestionnaires d'événements de dernier recours. Dans ce cas, les architectes et les développeurs doivent utiliser un modèle, un langage ou un cadre convivial pour s'assurer que les applications peuvent gérer en toute sécurité des événements exceptionnels, inattendus ou liés à la sécurité.\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:54.756025"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x16-V8-Data-Protection.md", "content": "# V8 Exigences de vérification de la protection des données\n\n## Objectif de contrôle\n\nIl y a trois éléments clés pour une bonne protection des données : Confidentialité, intégrité et disponibilité (CIA). Cette norme suppose que la protection des données est appliquée sur un système fiable, tel qu'un serveur, qui a été renforcé et dispose de protections suffisantes.\n\nLes applications doivent supposer que tous les dispositifs des utilisateurs sont compromis d'une manière ou d'une autre. Lorsqu'une application transmet ou stocke des informations sensibles sur des dispositifs non sécurisés, tels que des ordinateurs, des téléphones et des tablettes partagés, l'application est chargée de s'assurer que les données stockées sur ces dispositifs sont cryptées et ne peuvent pas être facilement obtenues, modifiées ou divulguées de manière illicite.\n\nAssurez-vous qu'une application vérifiée satisfait aux exigences de haut niveau suivantes en matière de protection des données :\n\n* Confidentialité : Les données doivent être protégées contre toute observation ou divulgation non autorisée, tant pendant leur transit que lors de leur stockage.\n* Intégrité : Les données doivent être protégées contre toute création, modification ou suppression malveillante par des attaquants non autorisés.\n* Disponibilité : Les données doivent être accessibles aux utilisateurs autorisés, selon les besoins.\n\n## V8.1 Protection générale des données\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.1.1** | Vérifiez que l'application protège les données sensibles contre la mise en cache dans des composants du serveur tels que les équilibreurs de charge et les caches d'applications. | | ✓ | ✓ | 524 |\n| **8.1.2** | Vérifier que toutes les copies en cache ou temporaires de données sensibles stockées sur le serveur sont protégées contre tout accès non autorisé ou purgées/invalidées après que l'utilisateur autorisé a accédé aux données sensibles. | | ✓ | ✓ | 524 |\n| **8.1.3** | Vérifier que l'application minimise le nombre de paramètres dans une requête, tels que les champs cachés, les variables Ajax, les cookies et les valeurs d'en-tête. | | ✓ | ✓ | 233 |\n| **8.1.4** | Vérifier que l'application peut détecter et alerter sur un nombre anormal de demandes, par exemple par IP, par utilisateur, par total par heure ou par jour, ou tout ce qui a un sens pour l'application. | | ✓ | ✓ | 770 |\n| **8.1.5** | Vérifiez que des sauvegardes régulières des données importantes sont effectuées et que des tests de restauration des données sont effectués. | | | ✓ | 19 |\n| **8.1.6** | Vérifiez que les sauvegardes sont stockées en toute sécurité pour éviter que les données ne soient volées ou corrompues. | | | ✓ | 19 |\n\n## V8.2 Protection des données côté client\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.2.1** | Vérifiez que l'application définit suffisamment d'en-têtes anticaching pour que les données sensibles ne soient pas mises en cache dans les navigateurs modernes. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Vérifiez que les données stockées dans le stockage du navigateur (telles que localStorage, sessionStorage, IndexedDB ou cookies) ne contiennent pas de données sensibles. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Vérifiez que les données authentifiées sont effacées du stockage du client, tel que le DOM du navigateur, après la fin du client ou de la session. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Données privées sensibles\n\nCette section permet de protéger les données sensibles contre la création, la lecture, la mise à jour ou la suppression sans autorisation, notamment en cas de grandes quantités.\n\nLe respect de cette section implique le respect du contrôle d'accès V4, et en particulier V4.2. Par exemple, la protection contre les mises à jour ou la divulgation non autorisée d'informations personnelles sensibles nécessite le respect de la V4.2.1. Veuillez vous conformer à cette section et à V4 pour une couverture complète.\n\nNote : Les réglementations et les lois relatives à la protection de la vie privée, telles que \"Australian Privacy Principles\" APP-11 ou GDPR, ont une incidence directe sur la manière dont les applications doivent aborder la mise en œuvre du stockage, de l'utilisation et de la transmission des informations personnelles sensibles. Cela va de sanctions sévères à de simples conseils. Veuillez consulter vos lois et règlements locaux et, le cas échéant, un spécialiste ou un avocat qualifié en matière de protection de la vie privée.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.3.1** | Vérifiez que les données sensibles sont envoyées au serveur dans le corps ou les en-têtes du message HTTP, et que les paramètres de la chaîne de requête de tout verbe HTTP ne contiennent pas de données sensibles. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Vérifier que les utilisateurs disposent d'une méthode pour supprimer ou exporter leurs données sur demande. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Vérifier que les utilisateurs disposent d'un langage clair concernant la collecte et l'utilisation des informations personnelles fournies et que les utilisateurs ont donné leur consentement pour l'utilisation de ces données avant qu'elles ne soient utilisées de quelque manière que ce soit. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Vérifier que toutes les données sensibles créées et traitées par l'application ont été identifiées, et s'assurer qu'une politique est en place sur la manière de traiter les données sensibles. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Vérifier que l'accès aux données sensibles est contrôlé (sans enregistrer les données sensibles elles-mêmes), si les données sont collectées en vertu des directives pertinentes sur la protection des données ou si l'enregistrement de l'accès est nécessaire. | | ✓ | ✓ | 532 |\n| **8.3.6** | Vérifiez que les informations sensibles contenues dans la mémoire sont écrasées dès qu'elles ne sont plus nécessaires pour atténuer les attaques de vidage de la mémoire, en utilisant des zéros ou des données aléatoires. | | ✓ | ✓ | 226 |\n| **8.3.7** | Vérifier que les informations sensibles ou privées qui doivent être chiffrées le sont à l'aide d'algorithmes approuvés qui assurent à la fois la confidentialité et l'intégrité. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Vérifier que les informations personnelles sensibles font l'objet d'une classification de conservation des données, de sorte que les données anciennes ou périmées soient supprimées automatiquement, selon un calendrier ou selon la situation. | | ✓ | ✓ | 285 |\n\nLorsqu'on envisage la protection des données, il faut avant tout tenir compte de l'extraction ou de la modification de masse ou de l'utilisation excessive. Par exemple, de nombreux systèmes de médias sociaux ne permettent aux utilisateurs que d'ajouter 100 nouveaux amis par jour, mais le système d'où proviennent ces demandes n'a pas d'importance. Une plateforme bancaire peut souhaiter bloquer plus de 5 transactions par heure en transférant plus de 1000 euros de fonds vers des institutions externes. Les exigences de chaque système sont susceptibles d'être très différentes, de sorte que la décision d'être \"anormal\" doit tenir compte du modèle de menace et du risque commercial. Les critères importants sont la capacité de détecter, de dissuader ou, de préférence, de bloquer ces actions anormales de masse.\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:54.829024"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x17-V9-Communications.md", "content": "# V9 Exigences de vérification des communications\n\n## Objectif de contrôle\n\nAssurez-vous qu'une demande vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* Le TLS ou le cryptage fort est toujours utilisé, quelle que soit la sensibilité des données transmises\n* Suivez les conseils les plus récents, incluant:\n  * les conseils de configuration\n  * les algorithmes et les cryptogrammes préférés\n* Les algorithmes et les chiffres faibles ou bientôt obsolètes sont commandés en dernier recours\n* Les algorithmes et les chiffres non sécurisés, dépréciés ou connus, sont désactivés.\n\nDans ces exigences :\n\n* Les principaux conseils de l'industrie sur la configuration sécurisée de TLS changent fréquemment, souvent en raison de ruptures catastrophiques dans les algorithmes et les cryptogrammes existants.\n* Utilisez toujours les versions les plus récentes des outils de révision de la configuration TLS (tels que SSLyze ou d'autres scanners TLS) pour configurer l'ordre et la sélection d'algorithmes préférés.\n* La configuration doit être vérifiée périodiquement pour s'assurer que la configuration des communications sécurisées est toujours présente et efficace.\n\n## V9.1 Exigences de sécurité des communications des clients\n\nToutes les communications avec les clients ne doivent avoir lieu que sur des voies de communication cryptées. En particulier, l'utilisation de TLS 1.2 ou d'une version ultérieure est pratiquement obligatoire pour les navigateurs et les moteurs de recherche modernes. \nLa configuration doit être régulièrement revue à l'aide d'outils en ligne afin de s'assurer que les dernières pratiques de pointe sont en place.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.1.1** | Vérifiez que le TLS sécurisé est utilisé pour toutes les connexions des clients et ne revient pas à des protocoles non sécurisés ou non chiffrés. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Vérifiez à l'aide d'outils de test TLS en ligne ou actualisés que seuls les algorithmes, les chiffrages et les protocoles puissants sont activés, les algorithmes et les chiffrages les plus puissants étant définis de préférence. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Vérifiez que seules les dernières versions recommandées du protocole TLS sont activées, telles que TLS 1.2 et TLS 1.3. La dernière version du protocole TLS doit être l'option préférée. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Exigences de sécurité des communications du serveur\n\nLes communications entre serveurs ne se limitent pas à HTTP. Des connexions sécurisées vers et depuis d'autres systèmes, tels que les systèmes de surveillance, les outils de gestion, l'accès à distance et ssh, les intergiciels, les bases de données, les ordinateurs centraux, les systèmes partenaires ou sources externes -- doivent être en place. Toutes ces connexions doivent être cryptées pour éviter \"d'être difficiles à l'extérieur et trivialement faciles à intercepter à l'intérieur\".\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.2.1** | Vérifiez que les connexions vers et depuis le serveur utilisent des certificats TLS de confiance. Lorsque des certificats générés en interne ou auto-signés sont utilisés, le serveur doit être configuré pour ne faire confiance qu'à des AC internes spécifiques et à des certificats auto-signés spécifiques. Tous les autres doivent être rejetés. | | ✓ | ✓ | 295 |\n| **9.2.2** | Vérifier que les communications chiffrées telles que TLS sont utilisées pour toutes les connexions entrantes et sortantes, y compris pour les ports de gestion, la surveillance, l'authentification, les appels d'API ou de service web, les connexions de base de données, de nuage, sans serveur, d'ordinateur central, externes et de partenaires. Le serveur ne doit pas se rabattre sur des protocoles non sécurisés ou non chiffrés. | | ✓ | ✓ | 319 |\n| **9.2.3** | Vérifiez que toutes les connexions chiffrées à des systèmes externes qui impliquent des informations ou des fonctions sensibles sont authentifiées. | | ✓ | ✓ | 287 |\n| **9.2.4** | Vérifiez que la révocation de certification appropriée, telle que le protocole OCSP (Online Certificate Status Protocol), est activée et configurée. | | ✓ | ✓ | 299 |\n| **9.2.5** | Vérifiez que les échecs de connexion TLS en arrière-plan sont enregistrés. | | | ✓ | 544 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Remarques sur les « modes approuvés de TLS ». \n    * Dans le passé, l'ASVS faisait référence à la norme américaine FIPS 140-2, mais en tant que norme mondiale, l'application des normes américaines peut être difficile, contradictoire ou déroutante à appliquer. \n    * Une meilleure méthode pour atteindre la conformité avec 9.1.3 consisterait à examiner des guides tels que [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) ou  [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/), et utiliser des outils d'évaluation TLS connus, tels que sslyze, divers scanners de vulnérabilité ou des services d'évaluation TLS en ligne fiables pour obtenir le niveau de sécurité souhaité.\n", "timestamp": "2025-10-24T11:39:54.899623"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x18-V10-Malicious.md", "content": "# V10 Exigences de vérification des codes malveillants\n\n## Objectif de contrôle\n\nAssurez-vous que le code satisfait aux exigences de haut niveau suivantes :\n\n* L'activité malveillante est traitée de manière sûre et appropriée pour ne pas affecter le reste de l'application.\n* Il n'y a pas de bombes à retardement ou d'autres attaques basées sur le temps.\n* Ne pas \"téléphoner à la maison\" vers des destinations malveillantes ou non autorisées.\n* Il n'y a pas de portes dérobées, d'oeufs de Pâques, d'attaques au salami, de rootkits ou de code non autorisé pouvant être contrôlé par un attaquant.\n\nTrouver un code malveillant est une preuve du négatif, qu'il est impossible de valider complètement. Il convient de tout mettre en œuvre pour s'assurer que le code ne comporte pas de code malveillant inhérent ou de fonctionnalité indésirable.\n\n## V10.1 Contrôles de l'intégrité du code\n\nLa meilleure défense contre les codes malveillants est de \"faire confiance, mais vérifier\". L'introduction d'un code non autorisé ou malveillant dans un code est souvent une infraction pénale dans de nombreuses juridictions. Les politiques et les procédures doivent clairement définir les sanctions applicables aux codes malveillants.\n\nLes principaux développeurs doivent régulièrement examiner les vérifications de code, en particulier celles qui peuvent concerner le temps d'accès, les E/S ou les fonctions réseau.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.1.1** | Vérifiez qu'un outil d'analyse de code est utilisé pour détecter les codes potentiellement malveillants, tels que les fonctions temporelles, les opérations de fichiers et les connexions réseau non sécurisées. | | | ✓ | 749 |\n\n## V10.2 Recherche de code malveillant\n\nLes codes malveillants sont extrêmement rares et difficiles à détecter. L'examen manuel ligne par ligne du code peut aider à rechercher des bombes logiques, mais même le plus expérimenté des examinateurs de code aura du mal à trouver un code malveillant même s'il sait qu'il existe.\n\nIl n'est pas possible de se conformer à cette section sans un accès complet au code source, y compris aux bibliothèques de tiers.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.2.1** | Vérifiez que le code source de l'application et les bibliothèques tierces ne contiennent pas de \"téléphone à la maison\" ou de capacités de collecte de données non autorisées. Lorsque de telles fonctionnalités existent, obtenez l'autorisation de l'utilisateur pour leur fonctionnement avant de collecter des données. | | ✓ | ✓ | 359 |\n| **10.2.2** | Vérifiez que l'application ne demande pas d'autorisations inutiles ou excessives pour les caractéristiques ou capteurs liés à la vie privée, tels que les contacts, les caméras, les microphones ou l'emplacement. | | ✓ | ✓ | 272 |\n| **10.2.3** | Vérifiez que le code source de l'application et les bibliothèques tierces ne contiennent pas de portes dérobées, telles que des comptes ou des clés codées en dur ou supplémentaires non documentées, des obscurcissements de code, des blobs binaires non documentés, des rootkits, ou des fonctions de débogage anti-débogage non sécurisées, ou encore des fonctionnalités obsolètes, non sécurisées ou cachées qui pourraient être utilisées de manière malveillante si elles étaient découvertes. | | | ✓ | 507 |\n| **10.2.4** | Vérifiez que le code source de l'application et les bibliothèques tierces ne contiennent pas de bombes à retardement en recherchant les fonctions liées à la date et à l'heure. | | | ✓ | 511 |\n| **10.2.5** | Vérifiez que le code source de l'application et les bibliothèques tierces ne contiennent pas de code malveillant, tel que des attaques de type salami, des contournements logiques ou des bombes logiques. | | | ✓ | 511 |\n| **10.2.6** | Vérifiez que le code source de l'application et les bibliothèques tierces ne contiennent pas d'œufs de Pâques ou toute autre fonctionnalité potentiellement indésirable. | | | ✓ | 507 |\n\n## V10.3 Contrôles d'intégrité des applications déployées\n\nUne fois qu'une application est déployée, un code malveillant peut encore être inséré. Les applications doivent se protéger contre les attaques courantes, telles que l'exécution de code non signé provenant de sources non fiables et les rachats de sous-domaines.\n\nLa conformité à cette section est susceptible d'être opérationnelle et continue.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.3.1** | Vérifiez que si l'application dispose d'une fonction de mise à jour automatique du client ou du serveur, les mises à jour doivent être obtenues par des canaux sécurisés et signées numériquement. Le code de mise à jour doit valider la signature numérique de la mise à jour avant l'installation ou l'exécution de la mise à jour. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Vérifiez que l'application utilise des protections d'intégrité, telles que la signature de code ou l'intégrité des sous-ressources. L'application ne doit pas charger ou exécuter du code provenant de sources non fiables, comme des includes de chargement, des modules, des plugins, du code ou des bibliothèques provenant de sources non fiables ou de l'Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Vérifiez que l'application est protégée contre les reprises de sous-domaines si elle repose sur des entrées DNS ou des sous-domaines DNS, tels que des noms de domaine expirés, des pointeurs DNS ou CNAME obsolètes, des projets expirés dans des dépôts de code source publics, ou des API de nuages transitoires, des fonctions sans serveur, ou des espaces de stockage (*autogen-bucket-id*.cloud.example.com) ou similaires. Les protections peuvent consister à s'assurer que les noms DNS utilisés par les applications sont régulièrement vérifiés pour détecter toute expiration ou modification. | ✓ | ✓ | ✓ | 350 |\n\n## Références\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:54.968473"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x19-V11-BusLogic.md", "content": "# V11 Exigences de vérification de la logique d'entreprise\n\n## Objectif de contrôle\n\nAssurez-vous qu'une demande vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* Le flux logique de l'entreprise est séquentiel, traité dans l'ordre, et ne peut être contourné.\n* La logique métier comprend des limites pour détecter et prévenir les attaques automatisées, comme les petits transferts de fonds continus, ou l'ajout d'un million d'amis un à la fois, etc.\n* Les flux de logique commerciale de grande valeur ont pris en compte les cas d'abus et les acteurs malveillants, et disposent de protections contre l'usurpation, l'altération, la répudiation, la divulgation d'informations et les attaques par élévation de privilèges.\n\n## V11.1 Exigences de sécurité de la logique d'entreprise\n\nLa sécurité de la logique commerciale est tellement individuelle à chaque demande qu'aucune liste de contrôle ne s'appliquera jamais. La sécurité de la logique d'entreprise doit être conçue pour protéger contre les menaces externes probables - elle ne peut pas être ajoutée en utilisant des pare-feu d'applications web ou des communications sécurisées. Nous recommandons l'utilisation de la modélisation des menaces lors des sprints de conception, par exemple en utilisant l'OWASP Cornucopia ou des outils similaires.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **11.1.1** | Vérifier que l'application traitera seulement les flux de logique métier pour un utilisateur dans l'ordre séquentiel des étapes et sans sauter d'étapes.| ✓ | ✓ | ✓ | 841 |\n| **11.1.2** |Vérifiez que l'application ne traitera que des flux de logique métier dont toutes les étapes sont traitées dans un temps humain réaliste, c'est-à-dire que les transactions ne sont pas soumises trop rapidement. | ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Vérifiez que l'application comporte des limites appropriées pour des actions ou des transactions commerciales spécifiques qui sont correctement exécutées par utilisateur. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Vérifiez que l'application dispose de contrôles anti-automatisation suffisants pour détecter et protéger contre l'exfiltration de données, les demandes excessives de logique métiers, les téléchargements excessifs de fichiers ou les attaques par déni de service. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Vérifier que l'application a des limites ou une validation de la logique métier pour se protéger contre les risques ou les menaces commerciales probables, identifiés à l'aide de la modélisation des menaces ou de méthodologies similaires. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Vérifiez que la demande ne souffre pas de problèmes de \"temps de contrôle au moment de l'utilisation\" (TOCTOU) ou d'autres situations de compétition (race condition) pour les opérations sensibles. | | ✓ | ✓ | 367 |\n| **11.1.7** | Vérifiez que les moniteurs de demande ne présentent pas d'événements ou d'activités inhabituels du point de vue de la logique métier. Par exemple, des tentatives d'effectuer des actions hors service ou des actions qu'un utilisateur normal ne tenterait jamais. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Vérifiez que l'application dispose d'alertes configurables lorsque des attaques automatisées ou une activité inhabituelle sont détectées. | | ✓ | ✓ | 390 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* Anti-automation can be achieved in many ways, including the use of [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) can also help with Attack Detection and Response.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:55.047593"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x20-V12-Files-Resources.md", "content": "# V12 Exigences de vérification des dossiers et des ressources\n\n## Objectif de contrôle\n\nAssurez-vous qu'une application vérifiée satisfait aux exigences de haut niveau suivantes :\n\n* Les données des fichiers non fiables doivent être traitées en conséquence et de manière sécurisée.\n* Les données de fichiers non fiables obtenues à partir de sources non fiables sont stockées en dehors de la racine web et avec des permissions limitées.\n\n## V12.1 Exigences pour le téléchargement de fichiers\n\nBien que les bombes zip soient facilement testables à l'aide de techniques de test de pénétration, elles sont considérées comme L2 et au-dessus pour encourager la prise en compte de la conception et du développement avec des tests manuels minutieux, et pour éviter que les tests de pénétration manuels ou automatisés n'engendrent de déni de service.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.1.1** | Vérifiez que l'application n'accepte pas de fichiers volumineux qui pourraient remplir l'espace de stockage ou provoquer un déni de service. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Vérifiez que l'application contrôle les fichiers compressés (par exemple, zip, gz, docx, odt) par rapport à la taille maximale autorisée non compressée et au nombre maximal de fichiers avant de décompresser le fichier. | | ✓ | ✓ | 409 |\n| **12.1.3** | Vérifiez qu'un quota de taille de fichier et un nombre maximum de fichiers par utilisateur sont appliqués pour s'assurer qu'un seul utilisateur ne peut pas remplir le stockage avec trop de fichiers, ou des fichiers excessivement gros. | | ✓ | ✓ | 770 |\n\n## V12.2 Exigences en matière d'intégrité des fichiers\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.2.1** | Vérifiez que les fichiers obtenus de sources non fiables sont validés comme étant du type attendu en fonction du contenu du fichier. | | ✓ | ✓ | 434 |\n\n## V12.3 Exigences relatives à l'exécution des fichiers\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.3.1** | Vérifiez que les métadonnées de nom de fichier soumises par l'utilisateur ne sont pas utilisées directement par les systèmes de fichiers du système ou du cadre et qu'une API URL est utilisée pour protéger contre la traversée du chemin (path traversal). | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Vérifier que les métadonnées de nom de fichier soumises par l'utilisateur sont validées ou ignorées pour empêcher la divulgation, la création, la mise à jour ou la suppression de fichiers locaux (LFI). | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Vérifier que les métadonnées de nom de fichier soumises par l'utilisateur sont validées ou ignorées pour empêcher la divulgation ou l'exécution de fichiers distants (RFI), qui peuvent également conduire à des SSRF.  | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Vérifiez que l'application protège contre le téléchargement de fichiers réfléchis (RFD) en validant ou en ignorant les noms de fichiers soumis par les utilisateurs dans un paramètre JSON, JSONP ou URL, l'en-tête Content-Type de la réponse doit être défini sur text/plain, et l'en-tête Content-Disposition doit avoir un nom de fichier fixe. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Vérifier que les métadonnées de fichiers non fiables ne sont pas utilisées directement avec l'API système ou les bibliothèques, pour se protéger contre l'injection de commandes du système d'exploitation. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Vérifiez que l'application n'inclut pas et n'exécute pas de fonctionnalités provenant de sources non fiables, telles que des réseaux de distribution de contenu non vérifiés, des bibliothèques JavaScript, des bibliothèques node npm ou des DLL côté serveur. | | ✓ | ✓ | 829 |\n\n## V12.4 Exigences en matière de stockage des fichiers\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.4.1** | Vérifiez que les fichiers obtenus à partir de sources non fiables sont stockés en dehors de la racine Web, avec des autorisations limitées. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Vérifiez que les fichiers obtenus de sources non fiables sont analysés par des scanners antivirus pour empêcher le téléchargement de contenus malveillants connus. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Exigences de téléchargement des fichiers\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.5.1** | Vérifiez que l'application web est configurée pour ne servir que les fichiers ayant des extensions de fichier spécifiques afin d'éviter les informations involontaires et les fuites de code source. Par exemple, les fichiers de sauvegarde (par exemple .bak), les fichiers de travail temporaires (par exemple .swp), les fichiers compressés (.zip, .tar.gz, etc) et les autres extensions couramment utilisées par les éditeurs doivent être bloqués, sauf si cela est nécessaire. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Vérifiez que les demandes directes aux fichiers téléchargés ne seront jamais exécutées en tant que contenu HTML/JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 Exigences de protection des SSRF\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.6.1** | Vérifiez que le serveur web ou d'application est configuré avec une liste d'autorisation de ressources ou de systèmes à partir desquels le serveur peut envoyer des requêtes ou charger des données/fichiers. | ✓ | ✓ | ✓ | 918 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:55.145098"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x21-V13-API.md", "content": "# V13 Exigences de vérification des API et des services Web\n\n## Objectif de contrôle\n\nVeiller à ce qu'une application vérifiée qui utilise des API de  service de confiance (utilisant généralement JSON ou XML ou GraphQL) tel :\n\n* Une authentification, une gestion de session et une autorisation adéquates de tous les services web.\n* Une validation d'entrée de tous les paramètres qui passent d'un niveau de confiance inférieur à un niveau supérieur.\n* Des contrôles de sécurité efficaces pour tous les types d'API, y compris les API en nuage et les API sans serveur\n\nVeuillez lire ce chapitre en combinaison avec tous les autres chapitres à ce même niveau ; nous ne dupliquons plus les problèmes d'authentification ou de gestion de session API.\n\n## V13.1 Exigences génériques de vérification de la sécurité des services web\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.1.1** | Vérifiez que tous les composants de l'application utilisent les mêmes encodages et analyseurs pour éviter les attaques par analyse qui exploitent des comportements différents d'URI ou d'analyse de fichiers qui pourraient être utilisés dans les attaques SSRF et RFI. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 4.1.3] | | | | |\n| **13.1.3** | Vérifier que les URL des API n'exposent pas d'informations sensibles, telles que la clé API, les jetons de session, etc. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Vérifier que les décisions d'autorisation sont prises à la fois à l'URI, appliquées par la sécurité programmatique ou déclarative au niveau du contrôleur ou du routeur, et au niveau des ressources, appliquées par des autorisations basées sur des modèles de permission. | | ✓ | ✓ | 285 |\n| **13.1.5** | Vérifiez que les demandes contenant des types de contenu inattendus ou manquants sont rejetées avec les en-têtes appropriés (statut de réponse HTTP 406 Inacceptable ou 415 Type de support non pris en charge). | | ✓ | ✓ | 434 |\n\n## V13.2 Exigences de vérification pour les services web de type RESTful\n\nLa validation du schéma JSON en est à un stade préliminaire de normalisation (voir références). Lorsque vous envisagez d'utiliser la validation de schéma JSON, qui est la meilleure pratique pour les services web RESTful, pensez à utiliser ces stratégies de validation de données supplémentaires en combinaison avec la validation de schéma JSON :\n\n* Validation de l'objet JSON, par exemple s'il y a des éléments manquants ou en trop.\n* Validation des valeurs de l'objet JSON en utilisant des méthodes de validation d'entrée standard, telles que le type de données, le format de données, la longueur, etc.\n* et validation formelle du schéma JSON.\n\nUne fois que la norme de validation du schéma JSON sera formalisée, l'ASVS mettra à jour ses conseils dans ce domaine. Surveillez attentivement toutes les bibliothèques de validation de schémas JSON utilisées, car elles devront être mises à jour régulièrement jusqu'à ce que la norme soit formalisée et que les bogues soient éliminés des implémentations de référence.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.2.1** | Vérifiez que les méthodes HTTP RESTful activées sont un choix valable pour l'utilisateur ou une action, comme par exemple empêcher les utilisateurs normaux d'utiliser le verbe DELETE ou PUT sur des API ou des ressources protégées. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Vérifier que la validation du schéma JSON est en place et vérifiée avant d'accepter la saisie. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Vérifiez que les services Web RESTful qui utilisent des cookies sont protégés contre la falsification de requête intersite via l'utilisation d'au moins un ou plusieurs des éléments suivants : modèle de cookie de double soumission, nonces CSRF ou vérifications d'en-tête de requête d'origine. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 11.1.4] | | | | |\n| **13.2.5** | Vérifiez que les services REST vérifient explicitement que le type de contenu entrant est bien celui attendu, par exemple application/xml ou application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Vérifiez que les en-têtes de message et la charge utile sont dignes de confiance et non modifiés en transit. Exiger un chiffrement fort pour le transport (TLS uniquement) peut être suffisant dans de nombreux cas, car il assure à la fois la confidentialité et la protection de l'intégrité. Les signatures numériques par message peuvent fournir une assurance supplémentaire en plus des protections de transport pour les applications de haute sécurité, mais apportent avec elles une complexité et des risques supplémentaires à peser par rapport aux avantages. | | ✓ | ✓ | 345 |\n\n## V13.3 Exigences de vérification du service web SOAP\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.3.1** | Vérifier que la validation du schéma XSD a lieu pour garantir un document XML correctement formé, suivi de la validation de chaque champ de saisie avant tout traitement de ces données. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Vérifier que la charge utile du message est signée en utilisant WS-Security pour assurer un transport fiable entre le client et le service. | | ✓ | ✓ | 345 |\n\nNote : En raison de problèmes liés aux attaques XXE contre les DTD, la validation des DTD ne doit pas être utilisée, et l'évaluation des DTD cadre doit être désactivée conformément aux exigences définies dans la configuration V14.\n\n## V13.4 GraphQL et autres exigences de sécurité de la couche de données des services Web\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.4.1** | Vérifiez qu'une liste de requêtes autorisées ou une combinaison de limitation de la profondeur et de la quantité est utilisée pour empêcher les dénis de service (DoS) de GraphQL ou de l'expression de la couche de données résultant de requêtes imbriquées et coûteuses. Pour les scénarios plus avancés, il convient d'utiliser l'analyse du coût des requêtes. | | ✓ | ✓ | 770 |\n| **13.4.2** | Vérifiez que la logique d'autorisation de GraphQL ou d'une autre couche de données doit être mise en œuvre au niveau de la couche de logique d'entreprise au lieu de la couche GraphQL. | | ✓ | ✓ | 285 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#triple-submit-cookie)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:55.229666"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x22-V14-Config.md", "content": "# V14 Exigences de vérification de la configuration\n\n## Objectif de contrôle\n\nAssurez-vous qu'une application vérifiée satisfait :\n\n* Un environnement de construction sécurisé, reproductible et automatisable.\n* Une gestion des dépendances étroite et une configuration renforcée, de sorte que les composants obsolètes ou non sécurisés ne soient pas inclus dans l'application.\n\nLa configuration de l'application \"out of the box\" doit être sûre pour être sur Internet, ce qui signifie une configuration \"out of the box\".\n\n## V14.1 Exigences sur les constructions\n\nLes pipelines de construction sont la base d'une sécurité reproductible : chaque fois qu'un élément non sécurisé est découvert, il peut être résolu dans le code source, les scripts de construction ou de déploiement, et testé automatiquement. Nous encourageons fortement l'utilisation de pipelines de compilation avec des contrôles de sécurité et de dépendance automatiques qui avertissent ou interrompent la compilation afin d'éviter que des problèmes de sécurité connus ne soient déployés en production. Les étapes manuelles effectuées de manière irrégulière conduisent directement à des erreurs de sécurité évitables.\n\nAlors que l'industrie se dirige vers un modèle DevSecOps, il est important de garantir la disponibilité et l'intégrité continues du déploiement et de la configuration pour atteindre un état \"known good\". Dans le passé, si un système était piraté, il fallait des jours, voire des mois, pour prouver qu'aucune autre intrusion n'avait eu lieu. Aujourd'hui, avec l'avènement des infrastructures définies par logiciel, des déploiements A/B rapides sans aucun temps d'arrêt, et des constructions automatisées conteneurisées, il est possible de construire, de durcir et de déployer automatiquement et en continu un \"known good\" en remplacement de tout système compromis.\n\nSi les modèles traditionnels sont toujours en place, des mesures manuelles doivent être prises pour renforcer et sauvegarder cette configuration afin de permettre le remplacement rapide des systèmes compromis par des systèmes à haute intégrité et sans compromis, et ce dans les meilleurs délais.\n\nLa conformité à cette section nécessite un système de construction automatisé et l'accès à des scripts de construction et de déploiement.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.1.1** | Vérifier que les processus de construction et de déploiement des applications sont effectués de manière sûre et répétable, comme l'automatisation des CI / CD, la gestion automatisée de la configuration et les scripts de déploiement automatisés. | | ✓ | ✓ | |\n| **14.1.2** | Vérifiez que les drapeaux du compilateur sont configurés pour activer toutes les protections et les avertissements disponibles contre les débordements de mémoire tampon, y compris la randomisation de la pile, la prévention de l'exécution des données, et pour casser la compilation si un pointeur, une mémoire, une chaîne de format, un entier ou une chaîne de caractères dangereux sont trouvés. | | ✓ | ✓ | 120 |\n| **14.1.3** | Vérifiez que la configuration du serveur est durcie conformément aux recommandations du serveur d'application et des frameworks utilisés. | | ✓ | ✓ | 16 |\n| **14.1.4** | Vérifier que l'application, la configuration et toutes les dépendances peuvent être redéployées à l'aide de scripts de déploiement automatisés, construites à partir d'un runbook documenté et testé dans un délai raisonnable, ou restaurées à partir de sauvegardes en temps utile. | | ✓ | ✓ | |\n| **14.1.5** | Vérifier que les administrateurs autorisés peuvent vérifier l'intégrité de toutes les configurations pertinentes pour la sécurité afin de détecter les altérations. | | | ✓ | |\n\n## V14.2 Exigences sur les dépendances\n\nLa gestion des dépendances est essentielle au bon fonctionnement de toute application, quel que soit son type. L'incapacité à se tenir à jour avec des dépendances obsolètes ou peu sûres est la cause première des attaques les plus importantes et les plus coûteuses à ce jour.\n\nRemarque : au niveau 1, la conformité à la norme 14.2.1 concerne les observations ou les détections de bibliothèques et de composants côté client et autres, plutôt que l'analyse statique du code de construction ou l'analyse des dépendances, plus précise. Ces techniques plus précises pourraient être découvertes par des entretiens, le cas échéant.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.2.1** | Vérifiez que tous les composants sont à jour, de préférence en utilisant un vérificateur de dépendances pendant le temps de construction ou de compilation. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Vérifiez que toutes les fonctionnalités, la documentation, les applications d'exemple et les configurations inutiles sont supprimées. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Vérifier que si les actifs d'application, tels que les bibliothèques JavaScript, les feuilles de style CSS ou les polices web, sont hébergés en externe sur un réseau de diffusion de contenu (CDN) ou un fournisseur externe, l'intégrité des sous-ressources (SRI) est utilisée pour valider l'intégrité de l'actif. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Vérifier que les composants tiers proviennent de dépôts prédéfinis, fiables et continuellement entretenus. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Vérifier qu'un catalogue d'inventaire de toutes les bibliothèques tierces en service est tenu à jour. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Vérifiez que la surface d'attaque est réduite en mettant en bac à sable ou en encapsulant des bibliothèques tierces pour n'exposer que le comportement requis dans l'application. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Exigences de divulgation involontaire de renseignements sur la sécurité\n\nLes configurations de production devraient être renforcées pour se protéger contre les attaques courantes, telles que les consoles de débogage, relever la barre pour les attaques de type \"cross-site scripting\" (XSS) et \"remote file inclusion\" (RFI), et pour éliminer les \"vulnérabilités\" triviales de découverte d'informations qui sont la marque indésirable de nombreux rapports de tests de pénétration. Nombre de ces problèmes sont rarement considérés comme un risque important, mais ils sont liés à d'autres vulnérabilités. Si ces problèmes ne sont pas présents par défaut, elle place la barre plus haute avant que la plupart des attaques puissent réussir.\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.3.1** | [SUPPRIMÉ, DOUBLON AVEC L'EXIGENCE 7.4.1] | | | | |\n| **14.3.2** | Vérifier que les modes de débogage du serveur web ou d'application et du cadre d'application sont désactivés en production afin d'éliminer les fonctionnalités de débogage, les consoles de développement et les divulgations de sécurité non intentionnelles. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Vérifiez que les en-têtes HTTP ou toute partie de la réponse HTTP n'exposent pas d'informations détaillées sur la version des composants du système. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 Exigences relatives aux en-têtes de sécurité HTTP\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.4.1** | Vérifiez que chaque réponse HTTP contient un en-tête Content-Type. Les types de contenu text/*, */*+xml et application/xml doivent également spécifier un jeu de caractères sûr (par exemple, UTF-8, ISO-8859-1). | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Vérifiez que toutes les réponses de l'API contiennent Content-Disposition : attachment ; filename=\"api.json\" (ou tout autre nom de fichier approprié pour le type de contenu). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Vérifier qu'une politique de sécurité du contenu (CSP) est en place pour aider à atténuer l'impact des attaques XSS comme les vulnérabilités d'injection HTML, DOM, JSON et JavaScript. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Vérifiez que toutes les réponses contiennent X-Content-Type-Options: nosniff. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Vérifiez que l'en-tête Strict-Transport-Security est inclus dans toutes les réponses et pour tous les sous-domaines, comme Strict-Transport-Security : max-age=15724800 ; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Vérifiez qu'un en-tête \"Referrer-Policy\" approprié est inclus, tel que \"no-referrer\" ou \"same-origin\". | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Vérifier que le contenu d'une application web ne peut pas être intégré par défaut dans un site tiers et que l'intégration des ressources exactes n'est autorisée que si nécessaire en utilisant un en-tête approprié tel \"Content-Security-Policy: frame-ancestors\" ou \"X-Frame-Options\". | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Exigences sur la validation des en-têtes de requête HTTP\n\n| # | Description | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.5.1** | Vérifiez que le serveur d'application accepte seulement les méthodes HTTP utilisées par l'application/API (incluant les requêtes de type OPTIONS), et journalise/alerte toutes les demandes invalides dans le contexte de l'application. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Vérifiez que l'en-tête Origin fourni n'est pas utilisé pour les décisions d'authentification ou de contrôle d'accès, car l'en-tête Origin peut facilement être modifié par un attaquant. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Vérifiez que l'en-tête \"Cross-Origin Resource Sharing\" (CORS) Access-Control-Allow-Origin utilise une liste d'autorisation stricte de domaines et sous-domaines de confiance pour la comparaison avec l'origine \"null\" et ne la prend pas en charge. | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Vérifiez que les en-têtes HTTP ajoutés par un proxy de confiance ou des dispositifs SSO, tels qu'un jeton au porteur, sont authentifiés par l'application. | | ✓ | ✓ | 306 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering]( https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Adding Content-Disposition to API responses helps prevent many attacks based on misunderstanding on the MIME type between client and server, and the \"filename\" option specifically helps prevent [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:55.303878"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x90-Appendix-A_Glossary.md", "content": "# Annexe A : Glossaire\n\n- **Address Space Layout Randomization (ASLR)** - Une technique pour rendre plus difficile l'exploitation des bugs de corruption de la mémoire.\n- **Authentification** - La vérification de l'identité déclarée d'un utilisateur d'application.\n- **Certificat X.509** - Un certificat X.509 est un certificat numérique qui utilise la norme internationale largement acceptée d'infrastructure à clé publique (PKI) X.509 pour vérifier qu'une clé publique appartient à l'utilisateur, à l'ordinateur ou à l'identité du service contenu dans le certificat.\n- **Clé codée en dur** - Clé cryptographique qui est stockée sur le système de fichiers, que ce soit dans le code, les commentaires ou les fichiers.\n- **Code malveillant** - Code introduit dans une application au cours de son développement à l'insu du propriétaire de l'application, qui contourne la politique de sécurité prévue pour l'application. Ce n'est pas la même chose qu'un logiciel malveillant tel qu'un virus ou un ver !\n- **Common Weakness Enumeration** (CWE) - Common Weakness Enumeration (CWE) est une liste développée par la communauté des faiblesses communes de sécurité logicielle. Elle sert de langage commun, de mesure pour les outils de sécurité des logiciels, et de base pour l'identification des faiblesses, l'atténuation et les efforts de prévention.\n- **Composant** - unité de code autonome, avec des interfaces disque et réseau associées, qui communique avec d'autres composants.\n- **Configuration de la sécurité** - La configuration d'exécution d'une application qui affecte la manière dont la sécurité est assurée.\n- **Contrôle de sécurité** - Une fonction ou un composant qui effectue un contrôle de sécurité (par exemple, un contrôle d'accès) ou qui, lorsqu'il est appelé, produit un effet de sécurité (par exemple, en générant un enregistrement d'audit).\n- **Dynamic Application Security Testing** (DAST) - Les technologies de test dynamique de la sécurité des applications (DAST) sont conçues pour détecter les conditions indiquant une vulnérabilité de sécurité dans une application en cours d'exécution.\n- **Fast IDentity Online** (FIDO) - Un ensemble de normes d'authentification qui permettent d'utiliser une variété de méthodes d'authentification différentes, y compris la biométrie, les modules de plateforme sécurisée (TPM), les jetons de sécurité USB, etc.\n- **Globally Unique Identifier** (GUID) - Numéro de référence unique utilisé comme identifiant dans un logiciel.\n- **Hardware Security Module** (HSM) - Composant matériel capable de stocker des clés cryptographiques et d'autres secrets de manière protégée.\n- **Hibernate Query Language** (HQL) - Un langage de requête qui ressemble en apparence au SQL utilisé par la bibliothèque Hibernate ORM.\n- **Hyper Text Transfer Protocol** (HTTPS) - Un protocole d'application pour les systèmes d'information hypermédia distribués et collaboratifs. Il constitue la base de la communication de données pour le World Wide Web.\n- **Informations d'identification personnelle** (IIP) - sont des informations qui peuvent être utilisées seules ou avec d'autres informations pour identifier, contacter ou localiser une seule personne, ou pour identifier un individu dans son contexte.\n- **Injection SQL (SQLi)** - Technique d'injection de code utilisée pour attaquer des applications orientées données, dans laquelle des instructions SQL malveillantes sont insérées dans un point d'entrée.\n- **Liste d'autorisation** - Une liste de données ou d'opérations autorisées, par exemple une liste de caractères qui sont autorisés à effectuer une validation d'entrée.\n- **Malware** - Code exécutable qui est introduit dans une application pendant son exécution à l'insu de l'utilisateur ou de l'administrateur de l'application.\n- **Modélisation de la menace** - Technique consistant à développer des architectures de sécurité de plus en plus raffinées pour identifier les agents de menace, les zones de sécurité, les contrôles de sécurité et les actifs techniques et commerciaux importants.\n- **Module cryptographique** - Matériel, logiciel et/ou microprogramme qui mettent en œuvre des algorithmes cryptographiques et/ou génèrent des clés cryptographiques.\n- **Object-relational Mapping** (ORM) - Un système utilisé pour permettre à une base de données relationnelle/basée sur des tables d'être référencée et interrogée dans un programme d'application à l'aide d'un modèle d'objet compatible avec l'application.\n- **One-time Password** (OTP) - Un mot de passe qui est généré de manière unique pour être utilisé à une seule occasion.\n- **Open Web Application Security Project** (OWASP) - L'Open Web Application Security Project (OWASP) est une communauté mondiale libre et ouverte qui vise à améliorer la sécurité des logiciels d'application. Notre mission est de rendre la sécurité des applications \"visible\", afin que les personnes et les organisations puissent prendre des décisions éclairées sur les risques liés à la sécurité des applications. Voir : [https://www.owasp.org/](https://www.owasp.org/)\n- **Password-Based Key Derivation Function 2** (PBKDF2) - Un algorithme spécial à sens unique utilisé pour créer une clé cryptographique forte à partir d'un texte d'entrée (comme un mot de passe) et d'une valeur de sel aléatoire supplémentaire et peut donc être utilisé pour rendre plus difficile le déchiffrage d'un mot de passe hors ligne si la valeur résultante est stockée au lieu du mot de passe d'origine.\n- **Position-independent executable** (PIE) - L'exécutable indépendant de la position (PIE) est un corps de code machine qui, placé quelque part dans la mémoire primaire, s'exécute correctement quelle que soit son adresse absolue.\n- **Public Key Infrastructure** (PKI) - Public Key Infrastructure (PKI) est un arrangement qui lie les clés publiques avec les identités respectives des entités. La liaison est établie par un processus d'enregistrement et de délivrance de certificats auprès et par une autorité de certification (CA).\n- **Public Switched Telephone Network** (PSTN) - Le réseau téléphonique traditionnel comprenant à la fois les téléphones fixes et les téléphones mobiles.\n- **Rapport de vérification de la sécurité des applications** - Rapport qui documente les résultats globaux et l'analyse à l'appui produite par le vérificateur pour une application particulière.\n- **Relying Party** (RP) - Généralement une application qui s'appuie sur un utilisateur qui s'est authentifié auprès d'un fournisseur d'authentification distinct. L'application s'appuie sur une sorte de jeton ou sur un ensemble d'assertions signées fournies par ce fournisseur d'authentification pour s'assurer que l'utilisateur est bien celui qu'il prétend être.\n- **Scripting intersite** (XSS) - Faille de sécurité que l'on trouve généralement dans les applications web et qui permet l'injection de scripts côté client dans le contenu.\n- **Sécurité des architectures** - Une abstraction de la conception d'une application qui identifie et décrit où et comment les contrôles de sécurité sont utilisés, et identifie et décrit également l'emplacement et la sensibilité des données de l'utilisateur et de l'application.\n- **Sécurité des applications** - La sécurité au niveau des applications se concentre sur l'analyse des composants qui constituent la couche application du modèle de référence d'interconnexion des systèmes ouverts (modèle OSI), plutôt que de se concentrer par exemple sur le système d'exploitation sous-jacent ou les réseaux connectés.\n- **Server-side Request Forgery** (SSRF) - Une attaque qui abuse des fonctionnalités du serveur pour lire ou mettre à jour les ressources internes en fournissant ou en modifiant une URL que le code exécuté sur le serveur lira ou soumettra des données.\n- **Single Sign-on Authentication** (SSO) - Le Single Sign On (SSO) se produit lorsqu'un utilisateur se connecte à une application et est ensuite automatiquement connecté à d'autres applications sans avoir à se ré-authentifier. Par exemple, lorsque vous vous connectez à Google, lorsque vous accédez à d'autres services Google tels que YouTube, Google Docs et Gmail, vous serez automatiquement connecté.\n- **Software development lifecycle** (SDLC) - Cycle de vie du développement logiciel.\n- **Static application security testing** (SAST) - Le test statique de sécurité des applications (SAST) est un ensemble de technologies conçues pour analyser le code source des applications, le code intermédiaire, les binaires et les conditions de compilation.\n- **SVG** - Graphiques vectoriels évolutifs\n- **Test de la boîte noire** - Méthode de test de logiciels qui consiste à examiner la fonctionnalité d'une application sans examiner ses structures ou son fonctionnement internes.\n- **Time-based OTP** - Une méthode de génération d'un OTP où l'heure actuelle fait partie de l'algorithme pour générer le mot de passe.\n- **Transport Layer Security** (TLS) – Protocoles cryptographiques qui assurent la sécurité des communications sur une connexion réseau\n- **Trusted Platform Module** (TPM) - Un type de HSM qui est généralement attaché à un composant matériel plus grand tel qu'une carte mère et agit comme la \"racine de confiance\" pour ce système.\n- **Two-factor authentication** (2FA) - L'authentification à deux facteurs(2FA) ajoute un deuxième niveau d'authentification à la connexion d'un compte.\n- **Universal 2nd Factor** (U2F) -  Une des normes créées par FIDO spécifiquement pour permettre l'utilisation d'une clé de sécurité USB ou NFC comme 2e facteur d'authentification\n- **URI/URL/URL fragments** - Un Uniform Resource Identifier est une chaîne de caractères utilisée pour identifier un nom ou une ressource web. Un Uniform Resource Locator est souvent utilisé comme référence à une ressource.\n- **Validation des entrées** - La canonisation et la validation des entrées des utilisateurs non fiables.\n- **Vérificateur** - La personne ou l'équipe qui examine une demande par rapport aux exigences de l'OWASP ASVS.\n- **Vérification automatisée** - Utilisation d'outils automatisés (soit des outils d'analyse dynamique, soit des outils d'analyse statique, soit les deux) qui utilisent les signatures de vulnérabilité pour trouver des problèmes.\n- **Vérification de la conception** - Évaluation technique de l'architecture de sécurité d'une application.\n- **Vérification de la sécurité des applications** - L'évaluation technique d'une application par rapport à l'ASVS de l'OWASP.\n- **Vérification dynamique** - L'utilisation d'outils automatisés qui utilisent les signatures de vulnérabilité pour trouver des problèmes pendant l'exécution d'une application.\n- **What You See Is What You Get** (WYSIWYG) - Un type d'éditeur de contenu riche qui montre à quoi ressemblera réellement le contenu lorsqu'il sera rendu plutôt que de montrer le codage utilisé pour régir le rendu.\n- **XML eXternal Entity** (XXE) - Un type d'entité XML qui peut accéder au contenu local ou distant via un identifiant système déclaré. Cela peut entraîner diverses attaques par injection.\n", "timestamp": "2025-10-24T11:39:55.420761"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x91-Appendix-B_References.md", "content": "# Annexe B : Références\n\nLes projets suivants de l'OWASP sont les plus susceptibles d'être utiles aux utilisateurs/adopteurs de cette norme :\n\n## Projets de base de l'OWASP\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## Projet OWASP Cheat Sheet Series\n\n[This project](https://cheatsheetseries.owasp.org/) has a number of cheat sheets which will be relevant for different topics in the ASVS.\n\nVous trouverez ici une correspondance avec l'ASVS : [https://github.com/OWASP/CheatSheetSeries/blob/master/IndexASVS.md](https://github.com/OWASP/CheatSheetSeries/blob/master/IndexASVS.md)\n\n## Projets liés à la sécurité mobile\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Projets liés à l'Internet des objets de l'OWASP\n\n1. Projet OWASP \"Internet of Things\" : [https://www.owasp.org/index.php/OWASP_Internet_of_Things_Project](https://www.owasp.org/index.php/OWASP_Internet_of_Things_Project)\n\n## Projets OWASP sans serveur\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Autres\n\nDe même, les sites web suivants sont les plus susceptibles d'être utiles aux utilisateurs/adopteurs de cette norme\n\n1. SecListes Github : [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Dénombrement des faiblesses communes : [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. Conseil des normes de sécurité PCI : [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. Norme de sécurité des données PCI (DSS) v3.2.1 Exigences et procédures d'évaluation de la sécurité : [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Exigences et procédures d'évaluation des logiciels sécurisés : [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. Exigences et procédures d'évaluation du PCI Secure Software Lifecycle (Secure SLC) : [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:55.535513"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/fr/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/fr/0x93-Appendix-C_IoT.md", "content": "# Annexe C : Exigences de vérification de l'Internet des objets\n\nCette section était à l'origine dans la branche principale, mais avec le travail effectué par l'équipe IoT OWASP, il n'est pas logique de maintenir deux fils de discussion différents sur le sujet. Pour la version 4.0, nous la déplaçons vers l'annexe, et nous invitons tous ceux qui le souhaitent à utiliser plutôt la branche principale [OWASP IoT project](https://owasp.org/www-project-internet-of-things/)\n\n## Objectif de contrôle\n\nLes dispositifs embarqués/implantés devraient :\n\n* Avoir le même niveau de contrôle de sécurité dans le dispositif que dans le serveur, en appliquant les contrôles de sécurité dans un environnement de confiance.\n* Les données sensibles stockées sur l'appareil doivent l'être de manière sécurisée en utilisant un stockage sauvegardé par du matériel tel que des éléments sécurisés.\n* Toutes les données sensibles transmises par le dispositif doivent utiliser la couche de transport de sécurité.\n\n## Exigences de vérification de la sécurité\n\n| # | Description | L1 | L2 | L3 | Depuis\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **C.1** | Vérifiez que les interfaces de débogage de la couche application telles que les interfaces USB, UART et autres variantes série sont désactivées ou protégées par un mot de passe complexe. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Vérifier que les clés et certificats cryptographiques sont uniques à chaque appareil. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Vérifiez que les contrôles de protection de la mémoire tels que ASLR et DEP sont activés par le système d'exploitation embarqué/OT, le cas échéant. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Vérifiez que les interfaces de débogage sur puce telles que JTAG ou SWD sont désactivées ou que le mécanisme de protection disponible est activé et configuré de manière appropriée. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Vérifiez que l'exécution de confiance est mise en œuvre et activée, si elle est disponible sur le SoC ou le CPU de l'appareil. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Vérifier que les données sensibles, les clés privées et les certificats sont stockés de manière sécurisée dans un élément sécurisé, TPM, TEE (Trusted Execution Environment), ou protégés par une cryptographie forte. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Vérifiez que les applications du microprogramme protègent les données en transit en utilisant la sécurité de la couche transport. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Vérifiez que les applications du microprogramme valident la signature numérique des connexions au serveur. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Vérifiez que les communications sans fil sont mutuellement authentifiées. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Vérifiez que les communications sans fil sont envoyées sur un canal crypté.  | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Vérifier que toute utilisation de fonctions C interdites est remplacée par les fonctions équivalentes sûres appropriées. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Vérifiez que chaque microprogramme tient à jour une nomenclature des logiciels cataloguant les composants tiers, le versionnage et les vulnérabilités publiées. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Vérifier que tous les codes, y compris les binaires de tiers, les bibliothèques, les cadres sont examinés pour les références codées en dur (backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Vérifiez que les composants de l'application et du micrologiciel ne sont pas susceptibles de recevoir l'OS Command Injection en invoquant des enveloppes de commandes shell, des scripts, ou que les contrôles de sécurité empêchent l'OS Command Injection. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Vérifiez que les applications du microprogramme fixent la signature numérique à un ou plusieurs serveurs de confiance. | | ✓ | ✓ | 4.0 |\n| **C.16** | Vérifier la présence de dispositifs de résistance et/ou de détection de l'altération. | | ✓ | ✓ | 4.0 |\n| **C.17** | Vérifiez que toutes les technologies de protection de la propriété intellectuelle disponibles fournies par le fabricant de la puce sont activées. | | ✓ | ✓ | 4.0 |\n| **C.18** | Vérifiez que des contrôles de sécurité sont en place pour empêcher l'ingénierie inverse des microprogrammes (par exemple, suppression des symboles de débogage verbeux). | | ✓ | ✓ | 4.0 |\n| **C.19** | Vérifiez que le périphérique valide la signature de l'image de démarrage avant le chargement. | | ✓ | ✓ | 4.0 |\n| **C.20** | Vérifiez que le processus de mise à jour du microprogramme n'est pas vulnérable aux attaques par heure de contrôle ou par heure d'utilisation. | | ✓ | ✓ | 4.0 |\n| **C.21** | Vérifiez que l'appareil utilise la signature de code et valide les fichiers de mise à jour du micrologiciel avant l'installation. | | ✓ | ✓ | 4.0 |\n| **C.22** | Vérifiez que l'appareil ne peut pas être rétrogradé vers d'anciennes versions (anti-rollback) de firmware valide. | | ✓ | ✓ | 4.0 |\n| **C.23** | Vérifier l'utilisation d'un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé sur un dispositif intégré (par exemple, en utilisant des générateurs de nombres aléatoires fournis par des puces). | | ✓ | ✓ | 4.0 |\n| **C.24** | Vérifiez que le microprogramme peut effectuer des mises à jour automatiques selon un calendrier prédéfini. | | ✓ | ✓ | 4.0 |\n| **C.25** | Vérifiez que l'appareil efface le micrologiciel et les données sensibles dès la détection d'une altération ou la réception d'un message non valide. | | | ✓ | 4.0 |\n| **C.26** | Vérifiez que seuls les microcontrôleurs qui prennent en charge la désactivation des interfaces de débogage (par exemple JTAG, SWD) sont utilisés. | | | ✓ | 4.0 |\n| **C.27** | Vérifiez que seuls les microcontrôleurs qui offrent une protection substantielle contre le décapuchonnage et les attaques des canaux latéraux sont utilisés. | | | ✓ | 4.0 |\n| **C.28** | Vérifier que les traces sensibles ne sont pas exposées aux couches extérieures du circuit imprimé. | | | ✓ | 4.0 |\n| **C.29** | Vérifiez que la communication entre les puces est cryptée (par exemple, communication de carte principale à carte fille). | | | ✓ | 4.0 |\n| **C.30** | Vérifiez que l'appareil utilise la signature de code et valide le code avant l'exécution. | | | ✓ | 4.0 |\n| **C.31** | Vérifiez que les informations sensibles conservées en mémoire sont écrasées par des zéros dès qu'elles ne sont plus nécessaires. | | | ✓ | 4.0 |\n| **C.32** | Vérifiez que les applications de microprogrammes utilisent des conteneurs de noyau pour l'isolation entre les applications. | | | ✓ | 4.0 |\n| **C.33** | Vérifiez que les drapeaux de compilateurs sécurisés tels que -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap sont configurés pour les constructions de microprogrammes. | | | ✓ | 4.0 |\n| **C.34** | Vérifiez que les microcontrôleurs sont configurés avec une protection par code (le cas échéant). | | | ✓ | 4.0 |\n\n## Références\n\nPour plus d'informations, voir aussi :\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:55.644410"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x01-Frontispiece.md", "content": "# Frontespizio\n\n## Riguardo allo standard\n\nLa Application Security Verification Standard è una lista di requisiti o test per la sicurezza delle applicazioni che può essere utilizzata da architetti del software, sviluppatori, tester, security professionals, tool vendors, e utenti per definire, realizzare, testare e verificare la sicurezza delle applicazioni.\n\n## Copyright e Licenza\n\nVersion 4.0.3, October 2021\n\n![license](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. Questo documento è rilasciato sotto la [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/). Per qualsiasi riutilizzo o distribuzione, devi chiarire agli altri i termini di licenza di questa opera.\n\n## Leader del progetto\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Principali Contributori\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Altri Contributori e Revisori\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          | Riccardo Sirigu   |                  |                   |\n\n\n\nSe non vi ritrovate nella lista dei contributori relativa alla versione 4.0.3 qui sopra, si prega di aprire un ticket su GitHub per essere riconosciuti negli aggiornamenti futuri.\n\nLa Application Security Verification Standard si basa sul lavoro svolto da coloro che hanno partecipato dalla verisone ASVS 1.0 del 2008 fino alla versione 3.0 del 2016. Gran parte della struttura e degli elementi di verifica che sono ancora presenti nell'ASVS attuale, sono stati originariamente scritti da Mike Boberski, Jeff Williams e Dave Wichers, ma ci sono molti altri contributori. Grazie a tutti coloro che hanno partecipato in precedenza. Per un elenco completo di tutti coloro che hanno contribuito alle versioni precedenti, si prega di consultare ciascuna versione precedente.\n", "timestamp": "2025-10-24T11:39:56.286975"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x02-Preface.md", "content": "# Prefazione\n\nBenvenuti alla versione 4.0 dello Standard di Verifica della Sicurezza delle Applicazioni (ASVS). L'ASVS è un'iniziativa guidata dalla comunità che mira a definire un framework di requisiti e controlli di sicurezza, concentrandosi sulle misure funzionali e non funzionali necessarie per la progettazione, lo sviluppo e il test di moderne applicazioni e servizi web.\n\nLa versione 4.0.3 rappresenta la terza revisione minore della versione 4.0, volta a correggere errori ortografici e a chiarire i requisiti, senza apportare modifiche sostanziali, come l'aggiornamento dei requisiti o l'introduzione di nuovi. Tuttavia, abbiamo leggermente allentato alcuni requisiti dove appropriato e rimosso quelli ormai superflui, mantenendo invariata la numerazione.\n\nL'ASVS 4.0 è il risultato di un impegno collaborativo e dei feedback raccolti dal settore negli ultimi dieci anni. Abbiamo cercato di semplificarne l'adozione per una vasta gamma di casi d'uso, coprendo l'intero ciclo di vita dello sviluppo di software sicuro.\n\nSiamo consapevoli che probabilmente non ci sarà mai un consenso unanime sul contenuto di uno standard per applicazioni web, inclusa l'ASVS. L'analisi del rischio è intrinsecamente soggettiva, il che rende complessa la creazione di uno standard universale. Tuttavia, speriamo che gli aggiornamenti introdotti in questa versione rappresentino un passo avanti nella direzione giusta, rafforzando i concetti chiave di questo importante standard industriale.\n\n## Cosa c'è di nuovo nella versione 4.0\n\nIl cambiamento più rilevante in questa versione è l'adozione delle Linee Guida per l'Identità Digitale del NIST 800-63-3, che introduce controlli di autenticazione moderni, avanzati e basati su evidenze. Pur consapevoli che ci possa essere una certa resistenza nell'adeguarsi a uno standard di autenticazione così avanzato, riteniamo fondamentale che gli standard siano allineati, specialmente quando si basano su evidenze e sono supportati da un altro autorevole standard di sicurezza delle applicazioni.\n\nGli standard di sicurezza delle informazioni dovrebbero puntare a ridurre il numero di requisiti unici, per evitare che le organizzazioni, nel percorso verso la conformità, debbano scegliere tra controlli concorrenti o incompatibili. La OWASP Top 10 del 2017 e ora lo Standard di Verifica della Sicurezza delle Applicazioni OWASP sono allineati al NIST 800-63 per quanto riguarda l'autenticazione e la gestione delle sessioni. Invitiamo altri enti normativi a collaborare con noi, con il NIST e con altri, al fine di sviluppare un insieme di controlli di sicurezza delle applicazioni ampiamente accettato, che massimizzi la sicurezza e riduca al minimo i costi di conformità.\n\nL'ASVS 4.0 è stato completamente rinumerato dall'inizio alla fine. Questo nuovo schema di numerazione ci ha consentito di colmare i vuoti lasciati da capitoli ormai scomparsi e di suddividere i capitoli più estesi, facilitando l'implementazione dei controlli per sviluppatori e team. Ad esempio, se un'applicazione non utilizza JWT, l'intera sezione relativa alla gestione delle sessioni tramite JWT non sarà applicabile.\n\nUna delle principali novità della versione 4.0 è l'introduzione di una mappatura completa con le Common Weakness Enumeration (CWE), una delle funzionalità più richieste nell'ultimo decennio. Questa mappatura permette a produttori di strumenti e utilizzatori di software di gestione delle vulnerabilità di correlare i risultati di altri strumenti e versioni precedenti del ASVS con la versione 4.0 e successive. Per fare spazio alla mappatura CWE, abbiamo eliminato la colonna \"Since\", che, a seguito della rinumerazione totale, aveva perso rilevanza rispetto alle versioni precedenti del ASVS. Non tutti i controlli del ASVS hanno una CWE associata e, poiché i CWE presentano spesso duplicazioni, abbiamo scelto di utilizzare le corrispondenze più comuni, piuttosto che quelle strettamente più precise. Tuttavia, non sempre è possibile trovare una corrispondenza tra i controlli di verifica e le debolezze. Continuiamo a incoraggiare il dibattito con la comunità CWE e, più in generale, con il settore della sicurezza delle informazioni per affrontare questa sfida.\n\nAbbiamo lavorato per soddisfare e superare in modo completo i requisiti necessari ad affrontare la OWASP Top 10 del 2017 e i Controlli Proattivi OWASP del 2018. Poiché la OWASP Top 10 del 2017 rappresenta il livello minimo per evitare negligenze in ambito sicurezza, abbiamo classificato come controlli di Livello 1 tutti i requisiti della Top 10, ad eccezione di quelli specifici al logging. Questo approccio facilita l'adozione di un vero standard di sicurezza per coloro che già utilizzano la OWASP Top 10.\n\nCi siamo inoltre impegnati a rendere l'ASVS 4.0 Livello 1 un insieme di controlli completo e più avanzato rispetto alla Sezione 6.5 dello standard PCI DSS 3.2.1, che copre aspetti come progettazione, sviluppo, test, revisioni sicure del codice e penetration test per le applicazioni. Per raggiungere questo obiettivo, abbiamo esteso i controlli di Livello 1 includendo la rilevazione di buffer overflow, operazioni di memoria non sicure (V5) e flag di compilazione associati a operazioni rischiose sulla memoria (V14), oltre ai già consolidati requisiti per la verifica di applicazioni e servizi web.\n\nAbbiamo completato la transizione del ASVS da controlli monolitici per soli server ad un sistema che fornisce sicurezza per tutte le applicazioni e le API moderne. Nell'era della programmazione funzionale, delle API serverless, del mobile, del cloud, dei container, dell'integrazione continua e consegna continua (CI/CD), del DevSecOps, della federazione e di molte altre tecnologie, non possiamo più trascurare le architetture applicative moderne. Le applicazioni moderne sono progettate in modo molto diverso da quelle in voga al lancio del ASVS originale nel 2009. L'ASVS deve sempre guardare al futuro per offrire raccomandazioni solide al suo pubblico principale: gli sviluppatori. Per questo motivo, abbiamo chiarito o eliminato tutti i requisiti che presuppongono che le applicazioni vengano eseguite su sistemi di proprietà di una singola organizzazione.\n\nA causa della complessità del ASVS 4.0 e del nostro obiettivo di renderlo lo standard di riferimento per tutti gli altri progetti correlati, abbiamo deciso di ritirare il capitolo dedicato al mobile, a favore del Mobile Application Security Verification Standard (MASVS). L'appendice relativa all'Internet of Things (IoT) verrà inclusa in un futuro standard ASVS specifico per l'IoT, curato dall'OWASP Internet of Things Project. Nell'Appendice C, abbiamo inserito un'anteprima iniziale del ASVS per l'IoT. Ringraziamo l'OWASP Mobile Team e l'OWASP IoT Project Team per il loro supporto all'ASVS e siamo entusiasti di collaborare con loro in futuro per offrire standard complementari.\n\nInfine, abbiamo rimosso i controlli duplicati e quelli a basso impatto. Con il tempo, l'ASVS è diventato un insieme completo di controlli, ma non tutti hanno lo stesso valore nel garantire la sicurezza del software. Questo lavoro di eliminazione dei controlli a basso impatto potrebbe proseguire in futuro. Nella prossima edizione del ASVS, il Common Weakness Scoring System (CWSS) sarà utilizzato per aiutare a prioritizzare ulteriormente i controlli davvero rilevanti, distinguendoli da quelli da eliminare.\n\nA partire dalla versione 4.0, l'ASVS si focalizzerà esclusivamente sul diventare lo standard di riferimento per le applicazioni e i servizi web, includendo sia architetture applicative tradizionali che moderne. Coprirà inoltre le pratiche di sicurezza agili e integrerà la cultura DevSecOps, garantendo un approccio completo e aggiornato alla sicurezza.\n", "timestamp": "2025-10-24T11:39:56.374778"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x03-Using-ASVS.md", "content": "# Utilizzo del ASVS\n\nASVS ha due obiettivi principali:\n\n* aiutare le organizzazioni a sviluppare e mantenere applicazioni sicure.\n* consentire ai fornitori di servizi di sicurezza, ai fornitori di strumenti di sicurezza e ai consumatori di allineare i propri requisiti e le loro offerte.\n\n## Livelli di verifica della sicurezza delle applicazioni\n\nLo standard di verifica della sicurezza delle applicazioni (ASVS) definisce tre livelli di verifica della sicurezza, ciascuno con un livello di approfondimento crescente.\n\n* ASVS Livello 1 è pensato per bassi livelli di garanzie di sicurezza ed è completamente testabile tramite penetration test.\n* ASVS Levello 2 è adatto per applicazioni che contengono dati sensibili che richiedono protezione, ed è il livello raccomandato per la maggior parte delle applicazioni.\n* ASVS Levello 3 è riservato alle applicazioni più critiche, come quelle che eseguono transazioni di alto valore, contengono dati medici sensibili o qualsiasi applicazione che richieda il massimo livello di sicurezza.\n\nCiascun livello ASVS contiene un elenco di requisiti di sicurezza. Ognuno di questi requisiti può essere mappato anche su funzionalità e capacità specifiche per la sicurezza che devono essere integrate nel software dagli sviluppatori.\n\n![ASVS Levels](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"ASVS Levels\")\n\nFigura 1 - Livelli dell'OWASP Application Security Verification Standard 4.0 \n\nIl Livello 1 del ASVS è l'unico che può essere testato completamente tramite penetration test eseguiti da personale umano. Tuttavia, tutti gli altri livelli richiedono accesso a documentazione, codice sorgente, configurazioni e interazione con il team di sviluppo. Sebbene il Livello 1 permetta test \"black box\" (senza accesso a documentazione e codice sorgente), questo tipo di verifica non è efficace e dovrebbe essere attivamente scoraggiato. Gli attori malintenzionati hanno tutto il tempo a disposizione per condurre attacchi, mentre la maggior parte dei penetration test si conclude in poche settimane. I difensori, invece, devono non solo integrare controlli di sicurezza, ma anche individuare e risolvere tutte le vulnerabilità e rilevare e rispondere alle minacce in tempi ragionevoli. Gli attaccanti, avendo potenzialmente tempo illimitato, necessitano solo di una singola falla, debolezza o errore di rilevamento per avere successo. I test \"black box\", spesso eseguiti alla fine dello sviluppo, in modo affrettato o persino trascurati, sono del tutto inadeguati per gestire questa disparità temporale tra difensori e attaccanti.\n\nNegli ultimi 30 anni, i test \"black box\" hanno dimostrato ripetutamente la loro inefficacia nell'individuare problemi di sicurezza critici, portando a violazioni sempre più gravi. Per questo motivo, raccomandiamo vivamente di adottare una gamma più ampia di attività di verifica e misure di garanzia della sicurezza, inclusa la sostituzione dei tradizionali penetration test con test ibridi di Livello 1. Questi dovrebbero essere guidati dall'analisi del codice sorgente, accompagnati da un dialogo aperto con gli sviluppatori e un accesso continuo alla documentazione durante tutto il processo di sviluppo. Analogamente a come gli enti di regolamentazione finanziaria non accetterebbero un audit esterno senza accesso ai libri contabili, a transazioni campione o al personale responsabile dei controlli, il settore e i governi dovrebbero richiedere lo stesso livello di trasparenza nell'ingegneria del software.\n\nSosteniamo fortemente l'integrazione di strumenti di sicurezza direttamente nel processo di sviluppo. Strumenti come DAST (Dynamic Application Security Testing) e SAST (Static Application Security Testing) possono essere impiegati continuamente all'interno della pipeline di build, per identificare in modo proattivo vulnerabilità facili da rilevare, che non dovrebbero mai essere presenti nelle applicazioni.\n\nGli strumenti automatizzati e le scansioni online non possono coprire più della metà del ASVS senza supporto umano. Per automatizzare completamente i test su ogni build, si utilizzano unit test e test di integrazione personalizzati, insieme a scansioni online avviate dalla build. Tuttavia, le vulnerabilità nella logica di business e i controlli sugli accessi richiedono l'intervento umano e dovrebbero essere tradotti in unit test e test di integrazione.\n\n## Come utilizzare questo standard\n\nUno dei modi migliori per sfruttare lo standard di verifica della sicurezza delle applicazioni è usarlo come base per creare una checklist di sviluppo sicuro, adattata alla propria applicazione, piattaforma o organizzazione. Personalizzare l'ASVS in base ai propri casi d'uso permette di concentrarsi sui requisiti di sicurezza più rilevanti per i propri progetti e contesti operativi.\n\n### Livello 1 - Primi passi, automatizzato o visione d'insieme del portfolio\n\nUn'applicazione raggiunge il Livello ASVS 1 se è sufficientemente protetta contro vulnerabilità applicative facilmente individuabili, come quelle presenti nella OWASP Top 10 o in elenchi simili.\n\nIl Livello 1 rappresenta il requisito minimo che tutte le applicazioni dovrebbero soddisfare. È utile come punto di partenza in un percorso di sicurezza più ampio o per applicazioni che non trattano dati sensibili e non richiedono i controlli più rigorosi previsti dai Livelli 2 o 3. I controlli di Livello 1 possono essere verificati automaticamente tramite strumenti o manualmente senza accesso al codice sorgente. Consideriamo il Livello 1 come la soglia di sicurezza di base per qualsiasi applicazione.\n\nLe minacce alle applicazioni spesso provengono da attaccanti che utilizzano tecniche semplici per identificare e sfruttare vulnerabilità facilmente rilevabili, a differenza di attori malevoli più determinati che impiegano risorse significative per colpire applicazioni specifiche. Se la vostra applicazione gestisce dati di alto valore, una verifica di Livello 1 non sarà quasi mai sufficiente.\n\n### Livello 2 - La maggior parte delle applicazioni\n\nUn'applicazione raggiunge il Livello ASVS 2 (o Standard) se è in grado di proteggersi adeguatamente dalla maggior parte dei rischi associati al software moderno.\n\nIl Livello 2 garantisce che i controlli di sicurezza siano implementati correttamente, funzionino in modo efficace e siano applicati in maniera appropriata all'interno dell'applicazione. È generalmente raccomandato per applicazioni che gestiscono transazioni business-to-business rilevanti, come quelle che trattano informazioni sanitarie, svolgono funzioni aziendali critiche o sensibili, o elaborano altre risorse sensibili. È anche fondamentale in settori dove l'integrità è essenziale, come l'industria dei videogiochi, per contrastare truffatori e attacchi hacker.\n\nLe minacce per le applicazioni di Livello 2 provengono tipicamente da attaccanti qualificati e motivati, che mirano a obiettivi specifici utilizzando strumenti e tecniche avanzate per individuare e sfruttare le vulnerabilità delle applicazioni.\n\n### Livello 3 - Alto valore, alta affidabilità o alta sicurezza\n\nIl Livello ASVS 3 rappresenta il più alto standard di verifica della sicurezza nell'ASVS, ed è generalmente destinato ad applicazioni che richiedono un livello significativo di protezione, come quelle dei settori della difesa, della sanità, della sicurezza e delle infrastrutture critiche.\n\nLe organizzazioni possono adottare il Livello ASVS 3 per applicazioni che eseguono funzioni critiche, dove un eventuale fallimento potrebbe avere gravi conseguenze operative o compromettere persino la sopravvivenza dell'azienda. Un'applicazione raggiunge il Livello ASVS 3 (o Avanzato) se non solo protegge da vulnerabilità avanzate, ma dimostra anche una progettazione di sicurezza robusta e ben strutturata.\n\nLe applicazioni di Livello ASVS 3 richiedono un'analisi più dettagliata dell'architettura, del codice e dei test rispetto ai livelli inferiori. Un'applicazione sicura a questo livello è organizzata in moduli distinti, in modo da garantire resilienza, scalabilità e sicurezza. Ogni modulo, isolato tramite connessioni di rete o istanze fisiche, è responsabile della propria sicurezza, implementando una difesa stratificata. Queste responsabilità devono essere ben documentate e includere controlli per la riservatezza (ad esempio, crittografia), l'integrità (come la gestione delle transazioni e la validazione degli input), la disponibilità (ottimizzazione della gestione del carico), l'autenticazione (anche tra sistemi), l'autorizzazione e l'auditing (logging).\n\n## Applicazione pratica del ASVS\n\nGli attaccanti possono avere motivazioni diverse e alcuni settori dispongono di asset informatici e informativi unici, con requisiti normativi specifici.\n\nSi raccomanda vivamente alle organizzazioni di valutare con attenzione le proprie caratteristiche di rischio in base alla natura del business e, in funzione di tali rischi e delle esigenze aziendali, determinare il livello ASVS più adatto per garantire la sicurezza delle applicazioni.\n\n## Come fare riferimento ai requisiti ASVS\n\nCiascun requisito dispone di un identificatore in formato `<capitolo>.<sezione>.<requisito>` dove ogni elemento è un numero, per esempio: `1.11.3`.\n- Il valore `<capitolo>` corrisponde al capitolo da cui proviene il requisito, per esempio: tutti i requisiti `1.#.#` appartengono al capitolo `Architettura`.\n- Il valore `<sezione>` corrisponde alla sezione all'interno di quel capitolo in cui compare il requisito, per esempio: tutti i requisiti, `1.11.#` si trovano nella sezione `Architettura logica di business` del capitolo `Architettura`.\n- Il valore `<requisito>` identifica il requisito specifico all'interno del capitolo e della sezione, per esempio: `1.11.3` che, nella versione 4.0.3 di questo standard è:\n\n> Verificare che tutti i flussi logici di business di alto valore, inclusi autenticazione, gestione delle sessioni e controllo degli accessi, siano thread-safe e resistenti alle race conditions quali time-of-check e time-of-use.\n\nGli identificatori possono cambiare tra le versioni dello standard, pertanto è preferibile che altri documenti, rapporti o strumenti utilizzino il formato `v<version>-<chapter>.<section>.<requirement>`, dove 'versione'è l'etichetta della versione ASVS. Per esempio: `v4.0.3-1.11.3` indicherebbe specificatamente il 3° requisito nella sezione 'Architettura logica di business' del capitolo 'Architettura' della versione 4.0.3. (Questo può essere riassunto come `v<version>-<requirement_identifier>`.)\n\nNota: la `v` che precede la parte relativa alla versione deve essere minuscola.\n\nSe gli identificatori vengono usati senza includere l'elemento `v<version>` si presuppone che facciano riferimento al contenuto più recente dello standard ASVS. Ovviamente, man mano che lo standard cresce e cambia, ciò diventa problematico. Ecco perché gli autori o gli sviluppatori dovrebbero sempre includere l'elemento versione.\n\nGli elenchi dei requisiti ASVS sono disponibili in CSV, JSON e altri formati che possono essere utili per riferimento o uso programmatico.\n", "timestamp": "2025-10-24T11:39:56.447116"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x04-Assessment_and_Certification.md", "content": "# Valutazione e certificazione\n\n## La posizione di OWASP sulle certificazioni e i marchi di fiducia ASVS\n\nOWASP, in quanto organizzazione no profit indipendente dai fornitori, attualmente non certifica alcun fornitore, ente verificatore o software.\n\nPertanto, tutte le dichiarazioni di garanzia, i marchi di fiducia o le certificazioni di questo tipo non sono ufficialmente esaminate, registrate o certificate da OWASP. Le organizzazioni che si affidano a tali elementi devono essere caute nel riporre fiducia in terze parti o marchi che dichiarano la certificazione ASVS.\n\nCiò non impedisce alle organizzazioni di offrire servizi di garanzia, purché non rivendichino ufficialmente una certificazione OWASP.\n\n## Linee guida per gli organismi di certificazione\n\nLo standard di verifica della sicurezza delle applicazioni può essere utilizzato come una verifica \"open book\", con accesso completo e senza restrizioni a risorse chiave, quali architetti del software e sviluppatori, documentazione di progetto, codice sorgente, e accesso autenticato ai sistemi di test (incluso l'accesso a uno o più account per ogni ruolo). Questo approccio è particolarmente importante per le verifiche di Livello 2 e Livello 3.\n\nStoricamente, i penetration test e le revisioni del codice sicuro hanno incluso solo problematiche \"per eccezione\", ovvero solo i test falliti vengono riportati nel rapporto finale. Tuttavia, un organismo di certificazione deve includere nel rapporto l'intero ambito della verifica (soprattutto se un componente chiave, come l'autenticazione SSO, è fuori ambito), un riepilogo dei risultati, compresi i test superati e non, con indicazioni chiare su come risolvere eventuali test falliti.\n\nAlcuni requisiti di verifica potrebbero non essere applicabili all'applicazione sotto test. Ad esempio, se si offre ai clienti un'API stateless a livello di servizio, senza una componente client, molti dei requisiti della sezione V3 (Gestione sessioni) non si applicheranno direttamente. In questi casi, un organismo di certificazione può comunque dichiarare la piena conformità ASVS, a patto che venga fornita una chiara motivazione per l'esclusione di tali requisiti nel rapporto finale.\n\nLa conservazione di rapporti di lavoro dettagliati, screenshot o filmati, script per riprodurre un problema in modo affidabile e log elettronici dei test (come i log di proxy e note di cleanup) è considerata una prassi standard nel settore. Questi elementi sono fondamentali per fornire prove solide dei risultati, soprattutto di fronte a sviluppatori scettici. Non è sufficiente eseguire uno strumento e segnalare semplicemente i fallimenti: questo non dimostra che tutti i problemi siano stati effettivamente testati in modo approfondito. In caso di controversia, devono esserci prove sufficienti per garantire che ogni singolo requisito sia stato effettivamente verificato.\n\n### Metodi di valutazione\n\nGli organismi di certificazione sono liberi di scegliere i metodi di valutazione più appropriati, ma devono documentarli in modo trasparente.\n\nA seconda dell'applicazione sottoposta a test e dei requisiti di verifica, possono essere utilizzati vari metodi per garantire un'adeguata affidabilità dei risultati. Ad esempio, la convalida dell'efficacia dei meccanismi di verifica dell'input di un'applicazione può essere eseguita attraverso un penetration test manuale o tramite un'analisi del codice sorgente.\n\n#### Ruolo degli strumenti di test di sicurezza automatizzati\n\nSi incoraggia l'uso di strumenti di penetration testing automatizzati per garantire la copertura più ampia possibile.\n\nTuttavia, non è possibile completare interamente la verifica ASVS solo con strumenti automatizzati. Sebbene molti dei requisiti del Livello 1 possano essere soddisfatti tramite test automatizzati, gran parte dei requisiti non è adatta a essere verificata esclusivamente con penetration test automatizzati.\n\nVa inoltre considerato che la distinzione tra test automatizzati e manuali si è ridotta con l'evoluzione del settore della sicurezza delle applicazioni. Gli strumenti automatizzati vengono spesso calibrati da esperti, mentre i tester manuali sfruttano una varietà di strumenti automatizzati per migliorare l'efficacia delle loro analisi.\n\n#### Ruolo del Penetration Testing\n\nNella versione 4.0, abbiamo deciso di rendere il Livello ASVS 1 completamente testabile tramite penetration testing, senza necessità di accedere a codice sorgente, documentazione o sviluppatori. Tuttavia, per soddisfare i requisiti di logging dell'OWASP Top 10 2017 A10, saranno necessarie interviste, screenshot o altre prove, come indicato anche nell'OWASP Top 10 2017. Nonostante ciò, condurre test senza l'accesso alle informazioni essenziali non è il metodo ideale per una verifica della sicurezza completa, poiché non permette di esaminare il codice sorgente per identificare minacce e controlli mancanti, limitando così la profondità dell'analisi.\n\nPer le valutazioni di Livello 2 o 3, è preferibile avere accesso a sviluppatori, documentazione, codice sorgente e a un ambiente di test con dati non di produzione. Il penetration testing a questi livelli richiede questo tipo di accesso, definito \"revisioni ibride\" o \"penetration test ibridi\", per eseguire un'analisi più approfondita e accurata.\n\n## Altri utilizzi del ASVS\n\nL'ASVS non è solo utile per valutare la sicurezza di un'applicazione, ma ha anche diversi altri potenziali impieghi.\n\n### Come guida completa per l'architettura della sicurezza\n\nUno degli utilizzi più comuni dell'Application Security Verification Standard (ASVS) è come risorsa per gli architetti della sicurezza. Lo Sherwood Applied Business Security Architecture (SABSA) non fornisce molte delle informazioni necessarie per una revisione completa dell'architettura di sicurezza delle applicazioni. L'ASVS può colmare queste lacune, aiutando gli architetti della sicurezza a selezionare controlli più efficaci per affrontare problemi comuni, come i modelli di protezione dei dati e le strategie di convalida degli input.\n\n### Come alternativa agli elenchi di controllo predefiniti per la codifica sicura\n\nMolte organizzazioni possono beneficiare dell'adozione del ASVS, scegliendo uno dei tre livelli o modificandolo per adattare i requisiti a ciascun livello di rischio specifico per il proprio dominio. Incoraggiamo questo tipo di personalizzazione, a condizione che venga mantenuta la tracciabilità. In questo modo, se un'applicazione soddisfa il requisito 4.1, il risultato sarà coerente anche nelle versioni modificate rispetto allo standard originale, man mano che evolve.\n\n### Come guida per unit test e test di integrazione automatizzati\n\nL'ASVS è progettato per essere altamente testabile, ad eccezione dei requisiti relativi all'architettura e al codice malevolo. Creando unit test e test di integrazione che includono fuzzing e scenari malevoli specifici e pertinenti, l'applicazione può diventare quasi auto-verificante a ogni build. Ad esempio, è possibile ampliare la suite di test di un controller di login, verificando il parametro *username* per nomi utente predefiniti comuni, enumerazione degli account, attacchi brute force, injection LDAP, SQL e XSS. Allo stesso modo, i test per il parametro *password* dovrebbero coprire password comuni, lunghezza minima, injection di byte null, rimozione completa del parametro, XSS e altre vulnerabilità.\n\n### Per la formazione allo sviluppo sicuro\n\nL'ASVS può essere utilizzato anche per definire le caratteristiche di un software sicuro. Molti corsi di \"programmazione sicura\" tendono a concentrarsi principalmente su tecniche di hacking etico, offrendo solo alcuni suggerimenti di programmazione, il che potrebbe non essere sufficiente per aiutare gli sviluppatori a scrivere codice più sicuro. Invece, i corsi di sviluppo sicuro possono basarsi sull'ASVS, ponendo maggiore enfasi sui controlli proattivi descritti nello standard, piuttosto che focalizzarsi solo sui 10 principali rischi da evitare. Questo approccio fornisce agli sviluppatori una guida pratica e concreta per costruire applicazioni sicure fin dall'inizio.\n\n### Come catalizzatore per la sicurezza agile delle applicazioni\n\nL'ASVS può essere utilizzato in un processo di sviluppo agile come framework per definire attività specifiche necessarie a garantire un prodotto sicuro. Un approccio potrebbe consistere nel partire dal Livello 1, verificando l'applicazione o il sistema rispetto ai requisiti ASVS per il livello selezionato, individuando i controlli mancanti e creando ticket o attività specifiche nel backlog. Questo aiuta a dare priorità alle attività di sicurezza (o grooming) e rende la sicurezza una parte visibile e integrata del processo agile. L'ASVS può anche essere utilizzato per dare priorità ad attività di audit e revisione, dove un requisito specifico guida la revisione, il refactoring o l'audit da parte di un membro del team, e viene trattato come \"debito\" nel backlog, che dovrà essere risolto nel tempo.\n\n### Come framework per orientare l'approvvigionamento di software sicuro\n\nL'ASVS è un ottimo framework per facilitare l'approvvigionamento di software sicuro o servizi di sviluppo personalizzati. L'acquirente può specificare come requisito che il software da acquistare sia sviluppato in conformità al Livello ASVS X, e richiedere al venditore di dimostrare che il software soddisfa tale livello. Questo approccio è particolarmente efficace se combinato con l'Allegato Contrattuale per Software Sicuro OWASP, garantendo che le aspettative di sicurezza siano chiaramente definite e concordate contrattualmente.\n", "timestamp": "2025-10-24T11:39:56.531851"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x10-V1-Architecture.md", "content": "# V1 Architettura, progettazione e Threat Modeling\n\n## Obiettivo del controllo\n\nL'architettura di sicurezza in molte organizzazioni è diventata quasi un'arte perduta. Nell'era del DevSecOps, l'epoca degli architetti enterprise sembra superata. Il campo della sicurezza delle applicazioni deve evolversi, adottando i principi di sicurezza agile, pur reintroducendo i concetti di architettura della sicurezza più avanzati per i professionisti del software. L'architettura non riguarda l'implementazione, ma è un modo di affrontare i problemi che può portare a molte soluzioni diverse, senza una risposta \"corretta\" unica. Troppo spesso la sicurezza è percepita come rigida, richiedendo agli sviluppatori di correggere il codice in un modo specifico, quando potrebbero conoscere soluzioni migliori. Pensare che esista una soluzione unica per l'architettura è dannoso per l'ingegneria del software.\n\nUn'applicazione web verrà probabilmente rivista più volte durante il suo ciclo di vita, ma la sua architettura complessiva cambierà raramente, evolvendosi lentamente. Lo stesso vale per l'architettura della sicurezza: oggi abbiamo bisogno dell'autenticazione, la richiederemo domani e tra cinque anni. Decisioni ponderate oggi possono far risparmiare tempo, sforzi e risorse in futuro, se si selezionano soluzioni conformi all'architettura esistente. Ad esempio, un decennio fa, l'autenticazione a più fattori era poco diffusa, ma oggi è una componente chiave.\n\nSe gli sviluppatori avessero investito in un unico modello sicuro di provider di identità, come l'identità federata tramite SAML, il provider di identità potrebbe essere aggiornato per soddisfare nuovi requisiti, come la conformità al NIST 800-63, senza dover modificare le interfacce dell'applicazione originale. Se più applicazioni condividono la stessa architettura di sicurezza e, quindi, lo stesso componente, tutte beneficerebbero contemporaneamente di questo aggiornamento. Tuttavia, SAML non sarà sempre la soluzione di autenticazione migliore o più adatta: potrebbe essere necessario sostituirla con altre soluzioni in base ai nuovi requisiti. Tali cambiamenti possono essere molto complessi, costosi al punto da richiedere una riscrittura completa, o impossibili da gestire senza una solida architettura di sicurezza.\n\nIn questo capitolo, l'ASVS affronta i principi fondamentali di una buona architettura di sicurezza: disponibilità, riservatezza, integrità dell'elaborazione, non ripudio e privacy. Questi principi devono essere integrati in modo nativo in tutte le applicazioni. È essenziale \"spostarsi a sinistra\", iniziando con l'adozione di checklist di programmazione sicura, mentoring, formazione, test di programmazione, build, distribuzione, configurazione e operations, fino a concludere con test indipendenti per garantire che tutti i controlli di sicurezza siano attivi e funzionanti. Tradizionalmente, l'ultimo passaggio era l'unico svolto nel settore, ma non è più sufficiente quando il codice viene distribuito in produzione decine o centinaia di volte al giorno. I professionisti della sicurezza devono tenere il passo con le metodologie agili, adottare strumenti di sviluppo, imparare a programmare e collaborare con gli sviluppatori, piuttosto che criticare i progetti mesi dopo che il lavoro è stato concluso e il team è passato oltre.\n\n## V1.1 Ciclo di vita sicuro dello sviluppo software (S-SDLC)\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | Verificare l'utilizzo di un ciclo di vita sicuro dello sviluppo software (S-SDLC) che tenga conto della sicurezza in tutte le fasi di sviluppo. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Verificare l'utilizzo del threat modeling per ogni modifica del design o nella pianificazione dello sprint al fine di identificare le minacce, pianificare contromisure, facilitare risposte ai rischi appropriate e guidare i test di sicurezza. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Verificare che tutte le user story e le funzionalità includano vincoli di sicurezza funzionali, come \"Come utente, dovrei poter visualizzare e modificare il mio profilo. Non dovrei poter visualizzare o modificare il profilo di nessun altro\" | | ✓ | ✓ | 1110 |\n| **1.1.4** | Verificare che tutti i perimetri di trust, i componenti e i flussi di dati significativi dell'applicazione siano documentati e giustificati in modo accurato. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Verificare che l'architettura di alto livello dell'applicazione e tutti i servizi remoti collegati siano definiti e sottoposti a un'analisi approfondita dal punto di vista della sicurezza. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Verificare che siano implementati controlli di sicurezza centralizzati, semplici (secondo il principio dell'economia di progettazione), verificati, sicuri e riutilizzabili, per evitare controlli duplicati, mancanti, inefficaci o non sicuri. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Verificare che tutti gli sviluppatori e tester abbiano a disposizione una checklist di programmazione sicura, requisiti di sicurezza, linee guida o policy. | | ✓ | ✓ | 637 |\n\n## V1.2 Architettura di autenticazione\n\nQuando si progetta un sistema di autenticazione, è irrilevante se si utilizza l'autenticazione a più fattori basata su hardware se un aggressore può reimpostare un account semplicemente chiamando un call center e rispondendo a domande facilmente reperibili. Tutti i percorsi di autenticazione devono avere la stessa efficacia nella verifica dell'identità.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | Verificare l'utilizzo di account di sistema operativo univoci o speciali con privilegi minimi per tutti i componenti, servizi e server dell'applicazione. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Verificare che le comunicazioni tra i componenti dell'applicazione, incluse le API, il middleware e il data layer, siano autenticate. I componenti devono avere i privilegi minimi necessari. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Verificare che l'applicazione utilizzi un unico meccanismo di autenticazione verificato noto per essere sicuro, estendibile per includere l'autenticazione forte e disponga di registri e monitoraggio sufficienti per rilevare abusi o violazioni dell'account. | | ✓ | ✓ | 306 |\n| **1.2.4** | Verificare che tutti i flussi di autenticazione e le API di gestione delle identità implementino dei controlli di autenticazione coerenti in efficacia, in modo tale che non ci siano alternative più deboli, in linea con il livello di rischio dell'applicazione. | | ✓ | ✓ | 306 |\n\n## V1.3 Architettura della gestione sessioni\n\nQuesto è un segnaposto per requisiti architetturali futuri. \n\n## V1.4 Architettura del Controllo Accessi\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | Verificare che i punti di applicazione trusted, come gateway di controllo accessi, server e funzioni serverless, applichino controlli di accesso. Non implementare mai controlli di accesso sul client. | | ✓ | ✓ | 602 |\n| **1.4.2** | [ELIMINATO, NON APPLICABILE] | | | | |\n| **1.4.3** | [ELIMINATO, DUPLICATO DI 4.1.3] | | | | |\n| **1.4.4** | Verificare che l'applicazione utilizzi un unico meccanismo di controllo accessi ben collaudato per accedere a dati e risorse protette. Tutte le richieste devono passare attraverso questo meccanismo per evitare copia e incolla o percorsi alternativi non sicuri. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Verificare che venga utilizzato il controllo di accesso basato su attributi o su funzionalità, in modo che il codice verifichi l'autorizzazione dell'utente per una funzionalità/elemento dati, non solo per il suo ruolo. Le autorizzazioni devono comunque essere assegnate utilizzando i ruoli. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Architettura di Input e Output \n\nNella versione 4.0, abbiamo abbandonato il termine \"lato server\" poiché ambiguo in relazione al perimetro di trust. Tuttavia, il perimetro di trust rimane un aspetto cruciale: i controlli implementati su browser o dispositivi client non affidabili possono essere facilmente aggirati. Nelle moderne architetture tradizionali, il punto di contatto con un componente trusted è cambiato radicalmente. Pertanto, nell'ASVS, il termine \"livello di servizio trusted\" si riferisce a qualsiasi punto di applicazione considerato affidabile, indipendentemente dalla sua posizione. Questo include microservizi, API serverless, componenti lato server, API trusted su dispositivi client con secure boot, API di partner o esterne, e altre implementazioni simili.\n\nIl termine \"client non affidabile\" si riferisce, in questo contesto, alle tecnologie lato client che gestiscono la presentazione, comunemente definite tecnologie \"front-end\". Il termine \"serializzazione\" non si limita al semplice trasferimento di dati in rete sotto forma di array di valori o alla lettura di strutture JSON, ma comprende anche il passaggio di oggetti complessi che possono includere logica.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | Verificare che i requisiti di input e output definiscano chiaramente come gestire ed elaborare i dati in base al tipo, al contenuto, alle leggi in vigore, ai regolamenti e alla conformità ad altre policy applicabili. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Verificare che la serializzazione non venga utilizzata nelle comunicazioni con client non affidabili. Se inevitabile, applicare controlli di integrità adeguati (e possibilmente la crittografia se vengono inviati dati sensibili) per prevenire attacchi di deserializzazione, inclusa l'injection di oggetti. | | ✓ | ✓ | 502 |\n| **1.5.3** | Verificare che la convalida degli input venga applicata su un livello di servizio trusted. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Verificare che la codifica dell'output avvenga vicino o dall'interprete per il quale è destinata. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Architettura Crittografica\n\nLe applicazioni devono essere progettate con una solida architettura crittografica per proteggere i dati in base alla loro classificazione. Crittografare tutto indiscriminatamente è uno spreco, mentre non crittografare nulla può configurarsi come negligenza legale. È fondamentale trovare un equilibrio, generalmente durante la fase di progettazione architetturale, gli sprint di design o le analisi ad alto livello. Progettare la crittografia \"al volo\" o integrarla successivamente comporta costi significativamente maggiori per implementarla in modo sicuro rispetto a un'integrazione pianificata fin dall'inizio.\n\nI requisiti architetturali riguardano l'intero sistema e sono quindi difficili da testare a livello di unità o integrazione. Questi requisiti devono essere considerati negli standard di programmazione durante tutta la fase di sviluppo e rivisti in occasione delle revisioni di sicurezza architetturale, nelle revisioni del codice (anche tra pari) o durante le retrospettive.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | Verificare che esista una policy esplicita per la gestione delle chiavi crittografiche e che il ciclo di vita delle chiavi crittografiche segua uno standard di gestione delle chiavi come il NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Verificare che gli utilizzatori di servizi crittografici proteggano il materiale chiave e altri segreti utilizzando key vault o alternative basate su API. | | ✓ | ✓ | 320 |\n| **1.6.3** | Verificare che tutte le chiavi e le password siano sostituibili e facciano parte di un processo ben definito per la ri-crittografia dei dati sensibili. | | ✓ | ✓ | 320 |\n| **1.6.4** | Verificare che l'architettura consideri i segreti lato client, come chiavi simmetriche, password o token API, come non sicuri e non li utilizzi mai per proteggere o accedere a dati sensibili. | | ✓ | ✓ | 320 |\n\n## V1.7 Architettura di Errori, Logging e Audit\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | Verificare che venga utilizzato un formato e un approccio di logging comune in tutto il sistema. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Verificare che i log vengano trasmessi in modo sicuro a un sistema, preferibilmente remoto, per analisi, rilevamento, allerta e escalation. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Architettura per Protezione Dati e Privacy\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | Verificare che tutti i dati sensibili siano identificati e classificati con adeguati livelli di protezione. | | ✓ | ✓ | |\n| **1.8.2** | Verificare che a tutti i livelli di protezione sia associato un set di requisiti di protezione, come requisiti di crittografia, requisiti di integrità, conservazione, privacy e altri requisiti di riservatezza, e che questi vengano applicati nell'architettura. | | ✓ | ✓ | |\n\n## V1.9 Architettura della Comunicazione\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | Verificare che l'applicazione crittografi le comunicazioni tra componenti, in particolare quando questi componenti si trovano in container, sistemi, siti o provider cloud diversi. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Verificare che i componenti applicativi verifichino l'autenticità di ciascuna parte in un collegamento di comunicazione per prevenire attacchi man-in-the-middle. Ad esempio, i componenti dell'applicazione dovrebbero validare i certificati e le catene TLS. | | ✓ | ✓ | 295 |\n\n## V1.10 Architettura del Software Maligno\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | Verificare l'utilizzo di un sistema di controllo del codice sorgente, con procedure per garantire che i check-in siano accompagnati da segnalazioni o ticket di modifica. Il sistema di controllo del codice sorgente deve disporre di controlli di accesso e utenti identificabili per consentire la tracciabilità di qualsiasi modifica. | | ✓ | ✓ | 284 |\n\n## V1.11 Architettura della Logica di Business\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | Verificare la definizione e la documentazione di tutti i componenti applicativi in termini di funzioni aziendali o di sicurezza fornite. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Verificare che tutti i flussi logici di business di alto valore, inclusi autenticazione, gestione sessioni e controllo degli accessi, sincronizzino correttamente lo stato. | | ✓ | ✓ | 362 |\n| **1.11.3** | Verificare che tutti i flussi logici di business di alto valore, inclusi autenticazione, gestione sessioni e controllo degli accessi, siano thread-safe e resistenti a race conditions quali \"time-of-check\" e \"time-of-use\". | | | ✓ | 367 |\n\n## V1.12 Architettura del Caricamento Sicuro di File\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [ELIMINATO, DUPLICATO DI 12.4.1] | | | | |\n| **1.12.2** | Verificare che i file caricati dagli utenti - se devono essere visualizzati o scaricati dall'applicazione - vengano serviti tramite octet stream o da un dominio non correlato, come un bucket di archiviazione file cloud. Implementare una Content Security Policy (CSP) adeguata per ridurre il rischio di vettori XSS o altri attacchi. | | ✓ | ✓ | 646 |\n\n## V1.13 Architettura delle API\n\nQuesto è un segnaposto per requisiti architetturali futuri.\n\n## V1.14 Architettura della Configurazione\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | Verificare la segregazione dei componenti con livelli di trust differenti attraverso controlli di sicurezza ben definiti, regole firewall, gateway API, proxy inverso, gruppi di sicurezza basati su cloud o meccanismi simili. | | ✓ | ✓ | 923 |\n| **1.14.2** | Verificare l'utilizzo di firme, connessioni affidabili e endpoint verificati per distribuire i file binari su dispositivi remoti. | | ✓ | ✓ | 494 |\n| **1.14.3** | Verificare che la pipeline di build avvisi di componenti obsoleti o non sicuri e intraprenda azioni appropriate. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Verificare che la pipeline di build contenga un passaggio di build per automatizzare la creazione e la verifica del deployment sicuro dell'applicazione, soprattutto se l'infrastruttura dell'applicazione è software-defined, come gli script di build per ambienti cloud. | | ✓ | ✓ | |\n| **1.14.5** | Verificare che le distribuzioni dell'applicazione implementino adeguatamente sandbox, containerizzazione e/o isolamento a livello di rete per rallentare e scoraggiare gli attori malevoli dall'attaccare altre applicazioni, specialmente quando eseguono azioni sensibili o pericolose come la deserializzazione. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Verificare che l'applicazione non utilizzi tecnologie client-side non supportate, non sicure o obsolete come plugin NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL o applet Java client-side. | | ✓ | ✓ | 477 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:56.657320"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x11-V2-Authentication.md", "content": "# V2 Autenticazione\n\n## Obiettivo del controllo\n\nL'autenticazione consiste nel confermare l'identità di qualcuno (o qualcosa) e nell'assicurarsi che le affermazioni fatte da una persona o su un dispositivo siano corrette, resistenti all'impersonazione e proteggano le password da furti o intercettazioni.\n\nQuando l'ASVS è stato pubblicato per la prima volta, la combinazione di username e password era la forma più comune di autenticazione, eccetto nei sistemi ad alta sicurezza. L'Autenticazione Multi-Fattore (MFA) era generalmente riservata agli ambienti più critici e raramente richiesta altrove. Con l'aumento delle violazioni di password, l'idea che gli username fossero confidenziali e le password sconosciute è diventata obsoleta, invalidando molti controlli di sicurezza tradizionali. Ad esempio, il NIST 800-63 considera gli username e l'Autenticazione Basata sulla Conoscenza (KBA) come informazioni pubbliche, e classifica notifiche via SMS ed email come modalità di autenticazione [\"restricted\"](https://pages.nist.gov/800-63-FAQ/#q-b1), mentre le password sono considerate già compromesse. Ciò rende inutili gli autenticatori basati sulla conoscenza, il recupero tramite SMS o email, la cronologia delle password, la loro rotazione e complessità. Questi controlli, spesso poco efficaci, hanno portato gli utenti a creare password deboli ad ogni cambio, e con oltre 5 miliardi di username e password compromessi, è il momento di cambiare approccio.\n\nTra tutti i capitoli del ASVS, quelli relativi all'autenticazione e alla gestione delle sessioni hanno subito i cambiamenti più significativi. L'adozione di pratiche efficaci e basate su evidenze sarà una sfida per molti, ma è normale. La transizione verso un futuro post-password deve iniziare adesso.\n\n## NIST 800-63 - Standard di autenticazione moderno basato su evidenze\n\nLo standard [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) è moderno, basato su evidenze e rappresenta un punto di riferimento per la sicurezza dell'autenticazione, indipendentemente dalla sua applicabilità specifica. È utile per tutte le organizzazioni a livello globale, ma è particolarmente rilevante per le agenzie statunitensi e per coloro che collaborano con esse.\n\nLa terminologia del NIST 800-63 può risultare inizialmente un po' complessa, soprattutto se si ha familiarità solo con l'autenticazione tradizionale tramite username e password. I progressi nell'autenticazione moderna richiedono l'introduzione di nuovi termini, che diventeranno comuni in futuro, ma comprendiamo che la loro adozione richiede tempo. Per semplificare la comprensione, abbiamo fornito un glossario alla fine di questo capitolo. Inoltre, molti requisiti sono stati riformulati per chiarirne meglio l'intento piuttosto che mantenere una corrispondenza letterale. Ad esempio, l'ASVS utilizza il termine \"password\", mentre lo standard NIST usa \"segreto memorizzato\".\n\nLe sezioni sull'Autenticazione (V2), la Gestione delle Sessioni (V3) e, in misura minore, i Controlli di Accesso (V4) del ASVS sono state adattate per essere un sottoinsieme conforme ai controlli selezionati dal NIST 800-63b. Questi controlli sono mirati a contrastare le minacce comuni e le debolezze di autenticazione più sfruttate. Per ottenere la piena conformità con il NIST 800-63, è necessario fare riferimento direttamente a tale standard.\n\n### Selezione di un livello AAL NIST appropriato\n\nL'Application Security Verification Standard (ASVS) ha tentato di mappare i requisiti ASVS L1 a NIST AAL1, L2 a AAL2 e L3 a AAL3. Tuttavia, l'approccio del Livello 1 del ASVS, che considera i controlli come \"essenziali\", potrebbe non sempre corrispondere perfettamente al livello AAL corretto per verificare un'applicazione o un'API. Ad esempio, se un'applicazione è di Livello 3 o ha requisiti normativi che richiedono il rispetto di AAL3, allora il Livello 3 dovrebbe essere selezionato per i capitoli V2 (Autenticazione) e V3 (Gestione delle sessioni). La scelta del livello di Authentication Assurance Level (AAL) conforme al NIST dovrebbe seguire le linee guida NIST 800-63b, come indicato nella sezione *Selecting AAL* [NIST 800-63b Sezione 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Legenda\n\nLe applicazioni possono sempre superare i requisiti del livello attuale, specialmente se nella roadmap è previsto un meccanismo di autenticazione più moderno. In precedenza, l'ASVS richiedeva l'MFA obbligatorio, mentre il NIST non lo impone sempre. Perciò, in questo capitolo abbiamo introdotto indicazioni facoltative per evidenziare dove l'ASVS incoraggia ma non richiede un determinato controllo. Le seguenti indicazioni sono utilizzate in tutto il documento:\n\n| Simbolo | Descrizione |\n| :--: | :-- |\n| | Non richiesto |\n| o | Consigliato, ma non necessario |\n| ✓ | Necessario |\n\n## V2.1 Sicurezza delle Password\n\nLe password, definite \"segreti memorizzati\" nel NIST 800-63, comprendono anche PIN, sequenze di sblocco, la scelta di immagini corrette (come gattini o altri elementi visivi) e frasi d'accesso. Questi sono generalmente considerati \"qualcosa che sai\" e vengono spesso utilizzati come meccanismo di autenticazione a singolo fattore. Tuttavia, ci sono sfide significative legate all'uso continuato dell'autenticazione a singolo fattore, tra cui la divulgazione online di miliardi di username e password validi, l'uso di password predefinite o deboli, e l'accessibilità di tabelle rainbow o dizionari delle password più comuni.\n\nLe applicazioni dovrebbero incoraggiare fortemente gli utenti a utilizzare l'autenticazione a più fattori (MFA) e permettere loro di riutilizzare token già in loro possesso, come token FIDO o U2F, oppure collegarsi a un *Credential Service Provider* (CSP) che offre l'autenticazione a più fattori.\n\nI *Credential Service Providers* (CSP) offrono identità federate agli utenti, che spesso possiedono più identità con diversi CSP, come Azure AD, Okta, Ping Identity o Google per identità aziendali, oppure Facebook, Twitter, Google o WeChat per identità consumer. Questo elenco non rappresenta un'approvazione di tali servizi, ma è un invito agli sviluppatori a considerare il fatto che molti utenti dispongono di identità consolidate con questi provider. Le organizzazioni dovrebbero valutare l'integrazione con identità utente esistenti in base al profilo di rischio associato al CSP. Ad esempio, una organizzazione governativa potrebbe non accettare un'identità social come login per sistemi sensibili, poiché è relativamente semplice creare identità fasulle o temporanee, mentre un'azienda di giochi mobile potrebbe essere incentivata a integrarsi con le principali piattaforme di social media per espandere la propria base di utenti attivi.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.1.1** | Verificare che le password impostate dagli utenti siano lunghe almeno 12 caratteri (dopo aver unito gli spazi multipli). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Verificare che siano consentite password di almeno 64 caratteri e che vengano rifiutate quelle di oltre 128 caratteri. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Verificare che non venga effettuato il troncamento della password. Tuttavia, gli spazi multipli consecutivi possono essere sostituiti da un singolo spazio. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Verificare che nelle password siano consentiti tutti i caratteri Unicode stampabili, inclusi caratteri neutri come spazi ed emoji. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Verificare che gli utenti possano cambiare la propria password. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Verificare che la funzionalità di cambio password richieda all'utente la password corrente e quella nuova. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Verificare che le password inviate durante la registrazione dell'account, l'accesso e il cambio password vengano confrontate con un set di password violate, sia localmente (come le prime 1.000 o 10.000 password più comuni che corrispondono alla policy password del sistema) o utilizzando un'API esterna. Se si utilizza un'API, è necessario utilizzare zero-knowledge proof o un altro meccanismo per garantire che la password non venga inviata o utilizzata in chiaro per verificare il suo stato di violazione. Se la password è violata, l'applicazione deve richiedere all'utente di impostarne una nuova. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Verificare che venga fornito un misuratore di robustezza della password per aiutare gli utenti a impostare una password più sicura. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Verificare che non esistano regole di composizione password che limitino il tipo di caratteri consentiti. Non dovrebbe essere richiesto l'utilizzo di maiuscole, minuscole, numeri o caratteri speciali. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Verificare che non vi siano requisiti periodici di rotazione delle credenziali o cronologia delle password. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Verificare che siano consentite le funzionalità \"incolla\", gli assistenti password del browser e i gestori di password esterni. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Verificare che l'utente possa scegliere di visualizzare temporaneamente l'intera password mascherata o l'ultimo carattere digitato su piattaforme che non dispongono nativamente di questa funzionalità. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nNota: L'obiettivo di consentire all'utente di visualizzare temporaneamente la propria password o l'ultimo carattere digitato è migliorare l'usabilità nell'inserimento delle credenziali, soprattutto quando si utilizzano password lunghe, passphrase o gestori di password. Un ulteriore motivo per includere questo requisito è evitare che, in fase di test, si chieda inutilmente alle organizzazioni di sovrascrivere il comportamento predefinito del campo password della piattaforma, eliminando una moderna funzionalità di sicurezza che risulta user-friendly.\n\n## V2.2 Sicurezza Generale degli Authenticator\n\nLa flessibilità degli authenticator è essenziale per la sicurezza a lungo termine delle applicazioni. È necessario svolgere un refactor dell'applicazione per consentire l'utilizzo di authenticator aggiuntivi in base alle preferenze dell'utente, nonché per consentire la rimozione graduale di authenticator obsoleti o non sicuri.\n\nIl NIST considera email e SMS come tipi di authenticator [\"restricted\"](https://pages.nist.gov/800-63-FAQ/#q-b1), ed è probabile che vengano rimossi da NIST 800-63 e di conseguenza in futuro anche dall'ASVS. Le applicazioni dovrebbero avere una roadmap che non richieda l'utilizzo di email o SMS.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.2.1** | Verificare che i controlli anti-automazione siano efficaci nel mitigare gli attacchi relativi a credenziali compromesse, forza bruta e blocco dell'account. Tali controlli includono il blocco delle password violate più comuni, i blocchi temporanei, la limitazione della velocità, i CAPTCHA, ritardi sempre crescenti tra i tentativi, restrizioni degli indirizzi IP o restrizioni basate sul rischio come posizione, primo accesso su un dispositivo, tentativi recenti di sbloccare l'account o simili. Verificare che non siano possibili più di 100 tentativi falliti all'ora su un singolo account. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Verificare che l'uso di authenticator deboli (come SMS ed email) sia limitato alla verifica secondaria o all'approvazione delle transazioni e non come sostituto di metodi di autenticazione più sicuri. Verificare che vengano offerti in primis metodi più robusti, che gli utenti siano consapevoli dei rischi o che siano implementate misure adeguate per limitare i rischi di compromissione dell'account. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Verificare che agli utenti vengano inviate notifiche dopo aggiornamenti dei dettagli di autenticazione, come reset delle credenziali, modifiche dell'email o dell'indirizzo, accessi da posizioni sconosciute o rischiose. Si preferisca l'uso di notifiche push, piuttosto che SMS o email, ma in assenza di notifiche push, SMS o email sono accettabili purché non venga divulgata nessuna informazione sensibile. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Verificare la resistenza all'impersonificazione tramite phishing, come l'utilizzo dell'autenticazione a due fattori, dispositivi crittografici (come chiavi connesse con un pulsante per l'autenticazione) o, a livelli AAL più alti, certificati lato client. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Verificare che quando un Credential Service Provider (CSP) e l'applicazione che verifica l'autenticazione sono separati, sia presente un mutual TLS tra i due endpoint. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Verificare la resistenza al replay mediante l'uso obbligatorio di dispositivi OTP (One-Time Password), autenticatori crittografici o codici di lookup. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Verificare l'autenticazione richiedendo l'inserimento di un token OTP o un'azione iniziata dall'utente come la pressione di un pulsante su una chiave hardware FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Ciclo di Vita degli Authenticator\n\nGli *authenticator* includono password, *soft token* (token digitali software), *hardware token* (token digitali fisici) e dispositivi biometrici. Il ciclo di vita degli *authenticator* è cruciale per garantire la sicurezza di un'applicazione. Se chiunque potesse registrarsi autonomamente senza una verifica dell'identità, la fiducia nell'identità sarebbe compromessa. Per piattaforme come Reddit, questo livello di sicurezza può essere accettabile. Tuttavia, per sistemi bancari e altre applicazioni sensibili, è fondamentale prestare particolare attenzione durante la fase di registrazione e l'emissione di credenziali o dispositivi, per assicurare la sicurezza dell'applicazione.\n\nNota: alle password non deve essere assegnata una scadenza massima, né devono essere soggette a rotazione periodica. Le password devono essere verificate per eventuali compromissioni, non sostituite regolarmente.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.3.1** | Verificare che le password iniziali o i codici di attivazione generate dal sistema SIANO casuali e sicuri, DEVONO essere lunghi almeno 6 caratteri e POSSONO contenere lettere e numeri, con scadenza dopo un breve periodo di tempo. Non è consentito l'utilizzo a lungo termine di questi segreti iniziali. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Verificare che sia supportata la registrazione e l'utilizzo di dispositivi di autenticazione forniti dall'utente, come token U2F o FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Verificare che le istruzioni di rinnovo siano inviate con sufficiente anticipo per permettere il rinnovo degli autenticatori con scadenza. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Memorizzazione delle credenziali\n\nQuesta sezione è rivolta ad architetti e sviluppatori impegnati nella creazione o ristrutturazione del codice. La verifica completa può essere effettuata solo attraverso la revisione del codice sorgente o tramite unit test o integration test specifici per la sicurezza. I penetration test non coprono nessuno di questi aspetti.\n\nLa lista della funzioni one-way per la derivazione delle chiavi è dettagliata nella sezione 5.1.1.2 del NIST 800-63 B, e nel [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). In alternativa, si possono utilizzare gli standard nazionali o regionali più aggiornati per algoritmi e lunghezza delle chiavi.\n\nQuesta sezione non può essere soggetta a penetration test, pertanto i controlli non sono classificati come L1. Tuttavia, è cruciale per la sicurezza delle credenziali in caso di furto. Se si esegue il fork del ASVS per delineare un'architettura o linee guida di sviluppo sicuro o un elenco di controlli per la revisione del codice sorgente, si consiglia di riportare questi controlli a L1 nella propria versione privata.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.4.1** | Verificare che le password siano archiviate in una forma resistente agli attacchi offline. Le password DEVONO essere sottoposte ad hashing e sale usando funzioni approvate di derivazione di chiavi unidirezionale o di hashing delle password. Le funzioni di derivazione di chiavi e di hashing delle password utilizzano come input una password, un sale e un fattore di costo per generare un hash della password. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Verificare che il sale sia lungo almeno 32 bit e scelto in modo arbitrario per ridurre al minimo le collisioni relative al sale tra gli hash memorizzati. Per ogni credenziale, DEVONO essere archiviati un valore di sale univoco e l'hash risultante. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Verificare che se viene utilizzato PBKDF2, il numero di iterazioni DOVREBBE essere il più alto consentito dalle prestazioni del server, in genere almeno 100.000 iterazioni. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Verificare che se viene utilizzato bcrypt, il fattore di lavoro DOVREBBE essere il più alto consentito dalle prestazioni del server, con un minimo di 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Verificare che venga eseguita un'ulteriore iterazione di una funzione di derivazione di chiavi, utilizzando un valore di sale segreto noto solo al verificatore. Generare il valore di sale utilizzando un generatore di bit casuali approvato [SP 800-90Ar1] e fornire almeno il livello minimo di robustezza specificato nell'ultima revisione di SP 800-131A. Il valore segreto del sale DEVE essere archiviato separatamente dalle password con hash (ad esempio, in un dispositivo specializzato come un modulo di sicurezza hardware). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nLaddove sono menzionati gli standard US, possono essere utilizzati, in alternativa, standard regionali o locali.\n\n## V2.5 Recupero delle Credenziali\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.5.1** | Verificare che un segreto di attivazione iniziale o di recupero generato dal sistema non venga inviato all'utente in chiaro. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Verificare che i suggerimenti per la password o l'autenticazione basata sulla conoscenza (le cosiddette \"domande segrete\") non siano presenti. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Verificare che il recupero delle credenziali tramite password non riveli in alcun modo la password corrente. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Verificare che non siano presenti account condivisi o di default (ad esempio \"root\", \"admin\" o \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Verificare che se un fattore di autenticazione viene modificato o sostituito, l'utente ne venga informato. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Verificare che la password dimenticata e gli altri percorsi di recupero utilizzino un meccanismo di recupero sicuro, come OTP basato sul tempo (TOTP) o un altro soft token, push mobile o un altro meccanismo di recupero offline ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Verificare che in caso di perdita di OTP o di meccanismi di autenticazione a più fattori, venga effettuata una verifica dell'identità comparabile al livello di quella effettuata durante la registrazione. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Verifica con Look-up Secret \n\nI look up secrets sono liste pre-generate di codici segreti, simili ai Numeri di Autorizzazione alle Transazioni (TAN), ai codici di recupero dei social media o a una griglia contenente un set di valori casuali. Questi codici vengono distribuiti in modo sicuro agli utenti. Vengono utilizzati una sola volta e, una volta esauriti, la lista dei look up secret viene scartata. Questo tipo di autenticatore appartiene alla categoria di \"qualcosa che possiedi\".\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.6.1** | Verificare che i look up secrets possano essere utilizzati una sola volta. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Verificare che i lookup secrets abbiano un'entropia sufficiente (112 bit) oppure, se inferiore a 112 bit, siano salati con un valore casuale unico di 32 bit e soggetti ad una funzione hash unidirezionale approvata. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Verificare che i lookup secrets siano resistenti agli attacchi offline, che non siano facilmente prevedibili. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Verifica Out of Band \n\nIn passato, un metodo comune per la verifica out of band era inviare un'email o un SMS con un link per reimpostare la password. Tuttavia, questo meccanismo debole è stato sfruttato dagli attaccanti, che possono prendere il controllo dell'account email della vittima e riutilizzare il link di reset per impadronirsi dell'account. Oggi esistono soluzioni più sicure per gestire la verifica out of band.\n\nI meccanismi sicuri di autenticazione out of band includono dispositivi fisici in grado di comunicare con il verificatore attraverso un canale secondario sicuro, come le notifiche push su dispositivi mobili. Questo tipo di autenticatore rientra nella categoria \"qualcosa che possiedi\". Quando un utente tenta di autenticarsi, l'applicazione verificatrice invia un messaggio al verificatore out of band tramite una connessione sicura diretta o indiretta attraverso un servizio di terze parti. Il messaggio contiene un codice di autenticazione, solitamente un numero casuale a sei cifre o una finestra di dialogo di approvazione. Il verificatore confronta l'hash del codice ricevuto tramite il canale primario con quello del codice originale. Se corrispondono, l'utente è considerato autenticato.\n\nL'ASVS presuppone che raramente gli sviluppatori creeranno nuovi verificatori out of band, come le notifiche push. Pertanto, i seguenti controlli ASVS si applicano a verificatori esistenti, come API di autenticazione, applicazioni e implementazioni di single sign-on. Se si sta sviluppando un nuovo autenticatore out of band, fare riferimento a NIST 800-63B &sect; 5.1.3.1.\n\nVerificatori out of band insicuri, come email e VOIP, non sono consentiti. L'autenticazione PSTN e SMS è attualmente \"restricted\" dal NIST e dovrebbe essere abbandonata a favore di notifiche push o simili. Se è necessario utilizzare l'autenticazione out of band telefonica o SMS, consultare il § 5.1.3.3.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.7.1** | Verificare che gli autenticatori out of band in chiaro (NIST \"restricted\"), come SMS o PSTN, non siano offerti per impostazione predefinita e che vengano prima offerte alternative più sicure come le notifiche push. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Verificare che il meccanismo out of band faccia scadere le richieste di autenticazione, i codici o i token dopo 10 minuti. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Verificare che le richieste di autenticazione, i codici o i token del verificatore fuori banda siano utilizzabili una sola volta e solo per la richiesta di autenticazione originale. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Verificare che il meccanismo out of band di autenticazione e di verifica comunichino su un canale indipendente sicuro. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Verificare che il meccanismo out of band conservi solo una versione con hash del codice di autenticazione. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Verificare che il codice di autenticazione iniziale sia generato da un generatore di numeri casuali sicuro, contenente almeno 20 bit di entropia (in genere è sufficiente un numero casuale a sei cifre). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 Verifica Monouso\n\nLe password monouso (OTP) monofattore sono token software o fisici che visualizzano un segreto monouso pseudo-casuale che cambia continuamente. Questi dispositivi rendono il phishing (impersonificazione) difficile, ma non impossibile. Questo tipo di autenticazione appartiene alla categoria \"qualcosa che possiedi\". I token multifattore, simili agli OTP monofattore, richiedono ulteriori procedure di sicurezza per generare l'OTP finale. Queste includono l'inserimento di un codice PIN valido, l'autenticazione biometrica, la connessione tramite USB o NFC, o l'aggiunta di un valore supplementare, come quello generato da una transaction signing calculator.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.8.1** | Verificare che gli OTP basati sul tempo abbiano una durata definita prima della scadenza. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Verificare che le chiavi simmetriche utilizzate per verificare gli OTP inviati siano protette adeguatamente, ad esempio utilizzando un modulo di sicurezza hardware (HSM) o un key storage sicuro fornito dal sistema operativo. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **2.8.3** | Verificare che nella generazione, nell'inizializzazione e nella verifica degli OTP vengano utilizzati algoritmi crittografici approvati. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Verificare che gli OTP monouso basati sul tempo possano essere utilizzati una sola volta entro il periodo di validità. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Verificare che se un token OTP multi-fattore basato sul tempo viene riutilizzato durante il periodo di validità, venga registrato e rifiutato con l'invio di una notifica al detentore del dispositivo. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Verificare che il dispositivo hardware generatore di codici OTP possa essere revocato in caso di furto o smarrimento. Garantire che la revoca sia immediata su tutte le sessioni aperte, indipendentemente dalla posizione. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Verificare che gli autenticatori biometrici siano limitati all'uso solo come fattori secondari in combinazione con qualcosa che si possiede e qualcosa che si conosce. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Verifica Crittografica\n\nLe chiavi di sicurezza crittografiche, come le smart card o le chiavi FIDO, richiedono che l'utente colleghi o associ il dispositivo crittografico al computer per completare l'autenticazione. Il verificatore invia un *nonce* (numero casuale) al dispositivo o software crittografico, che risponde calcolando una risposta basata su una chiave crittografica memorizzata in modo sicuro.\n\nI requisiti per i dispositivi e i software crittografici, sia monofattore che multifattore, sono gli stessi, poiché la verifica dell'autenticatore crittografico dimostra il possesso dell'autenticatore stesso.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.9.1** | Verificare che le chiavi crittografiche utilizzate nella verifica siano archiviate in modo sicuro e protette dalla divulgazione, ad esempio utilizzando un Trusted Platform Module (TPM) o un Hardware Security Module (HSM), o un servizio del sistema operativo in grado di utilizzare questi meccanismi. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Verificare che il nonce sia di almeno 64 bit e statisticamente unico o unico per l'intera durata di vita del dispositivo crittografico. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Verificare che vengano utilizzati algoritmi crittografici approvati per la generazione, l'inizializzazione e la verifica. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Autenticazione del Servizio\n\nQuesta sezione non può essere verificata tramite penetration test, quindi non include requisiti L1. Tuttavia, se applicata nell'ambito di un'architettura, nella scrittura o nella revisione del codice sicuro, è consigliabile trattare il software di gestione delle chiavi (come Java Key Store) come requisito minimo a livello L1. La memorizzazione in chiaro di segreti non è accettabile in nessun caso.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.10.1** | Verificare che i segreti interni al servizio non si basino su credenziali statiche come password, chiavi API o account condivisi con accesso privilegiato. | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Verificare che, se sono richieste password per l'autenticazione del servizio, l'account di servizio utilizzato non sia uno predefinito. (ad esempio root/root o admin/admin sono predefiniti in alcuni servizi durante l'installazione). | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Verificare che le password siano archiviate con una protezione sufficiente per prevenire attacchi di recupero offline, incluso l'accesso al sistema locale. | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Verificare che password, integrazioni con database e sistemi di terze parti, seed e segreti interni e chiavi API siano gestiti in modo sicuro e non siano inclusi nel codice sorgente o archiviati all'interno dei repository del codice sorgente. Tale archiviazione DOVREBBE resistere agli attacchi offline. Si raccomanda l'utilizzo di un archivio software sicuro delle chiavi (L1), hardware TPM o un HSM (L3) per l'archiviazione delle password. | | OS assisted | HSM | 798 | |\n\n## Requisiti aggiuntivi per le agenzie statunitensi\n\nLe agenzie statunitensi hanno requisiti obbligatori relativi a NIST 800-63. L'Application Security Verification Standard ha sempre riguardato l'80% dei controlli che si applicano a quasi il 100% delle applicazioni, e non l'ultimo 20% dei controlli avanzati o quelli con applicabilità limitata. Pertanto, l'ASVS è un sottoinsieme rigoroso di NIST 800-63, specialmente per le classificazioni IAL1/2 e AAL1/2, ma non è sufficientemente completo, in particolare per le classificazioni IAL3/AAL3.\n\nEsortiamo vivamente le agenzie governative statunitensi a rivedere e implementare NIST 800-63 nella sua interezza.\n\n## Glossario\n\n| Termine | Significato |\n| --- | --- |\n| CSP | Credential Service Provider also called an Identity Provider, un servizio che gestisce le identità degli utenti e fornisce credenziali di autenticazione. |\n| Authenticator | Componente che verifica le credenziali presentate dall'utente. Può gestire diversi fattori come password, token, autenticazione a due fattori (MFA) o accessi federati. |\n| Verifier | Questa entità verifica la validità delle credenziali dell'utente in base alle informazioni ricevute dall'autenticatore. Potrebbe anche confermare se le credenziali sono associate a un utente valido e se sono attive/non revocate. |\n| OTP | One-time password. Password valida per un solo tentativo di accesso e poi scade |\n| SFA | Single-factor authenticators, come qualcosa che conosci (segreti, password, frasi segrete, PINs), qualcosa che sei (biometria, impronte digitali, scansioni facciali), o qualcosa che possiedi (token OTP, un dispositivo crittografico come una smart card). |\n| MFA | Multi-factor authentication, che include almeno due fattori |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:56.739228"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x12-V3-Session-management.md", "content": "# V3 Gestione delle sessioni\n\n## Obiettivo del controllo\n\nUno degli elementi fondamentali di qualsiasi applicazione web o API stateful è il meccanismo che gestisce e mantiene lo stato di un utente o dispositivo durante l'interazione con essa. La gestione delle sessioni consente di trasformare un protocollo senza stato in uno con stato, ed è essenziale per distinguere i vari utenti o dispositivi.\n\nVerificare che un'applicazione soddisfi i seguenti requisiti di alto livello per la gestione delle sessioni:\n\n* Le sessioni sono uniche per ciascun individuo e non possono essere né indovinate né condivise.\n* Le sessioni vengono invalidate quando non più necessarie e scadono dopo un periodo di inattività.\n\nCome già osservato, questi requisiti sono stati adattati per essere un sottoinsieme conforme ai controlli selezionati dal NIST 800-63b, concentrandosi su minacce comuni e vulnerabilità di autenticazione frequentemente sfruttate. I requisiti di verifica precedenti sono stati eliminati, deduplicati o, nella maggior parte dei casi, adattati per allinearsi strettamente con le disposizioni obbligatorie del [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) .\n\n## Requisiti di Verifica della Sicurezza\n\n## V3.1 Sicurezza Fondamentale della Gestione Sessione\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.1.1** | Verificare che l'applicazione non riveli mai token di sessione nei parametri dell'URL. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Associazione di Sessione\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.2.1** | Verificare che l'applicazione generi un nuovo token di sessione all'autenticazione dell'utente. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Verificare che i token di sessione possiedano almeno 64 bit di entropia. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Verificare che l'applicazione memorizzi i token di sessione solo nel browser utilizzando metodi sicuri come cookie adeguatamente protetti (vedere sezione 3.4) o il session storage in HTML5 | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Verificare che i token di sessione siano generati utilizzando algoritmi crittografici approvati. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nL'uso di TLS o di un canale di trasporto sicuro equivalente è obbligatorio per la gestione delle sessioni. Questo aspetto sarà trattato nel capitolo dedicato alla sicurezza delle comunicazioni.\n\n## V3.3 Terminazione Sessione\n\nI timeout di sessione sono stati allineati con il NIST 800-63, che consente durate molto più lunghe rispetto a quelle tradizionalmente previste dagli standard di sicurezza. Le organizzazioni dovrebbero consultare la tabella seguente e, se il rischio associato all'applicazione giustifica un timeout più lungo, il valore NIST dovrebbe rappresentare il limite massimo per i timeout di inattività della sessione.\n\nIn questo contesto, L1 corrisponde a IAL1/AAL1, L2 a IAL2/AAL2 e L3 a IAL3/AAL3. Per IAL2/AAL2 e IAL3/AAL3, un timeout di inattività più breve implica un limite inferiore per la disconnessione o la necessità di riautenticazione per riprendere la sessione.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.3.1** | Verificare che la disconnessione e la scadenza invalidino il token di sessione, in modo che il pulsante Indietro o una relying party a valle non riprendano una sessione autenticata, anche tra relying party. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Se gli autenticatori consentono agli utenti di rimanere collegati, verificare che la riautenticazione avvenga periodicamente sia quando viene utilizzata attivamente sia dopo un periodo di inattività. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 giorni | 12 ore o 30 minuti di inattività, 2FA opzionale | 12 ore o 15 minuti di inattività, con 2FA | 613 | 7.2 |\n| **3.3.3** | Verificare che l'applicazione consenta di terminare tutte le altre sessioni attive dopo un cambio password riuscito (incluso il cambio tramite reset/recupero password) e che ciò si applichi all'intera l'applicazione, all'accesso federato (se presente) e a qualsiasi relying party. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Verificare che gli utenti possano visualizzare e (dopo aver reinserito le credenziali di accesso) disconnettersi da una o tutte le sessioni e i dispositivi attualmente attivi. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Gestione Sessioni Basate su Cookie\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.4.1** | Verificare che i token di sessione basati su cookie abbiano impostato l'attributo 'Secure'. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Verificare che i token di sessione basati su cookie abbiano impostato l'attributo 'HttpOnly'. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Verificare che i token di sessione basati su cookie utilizzino l'attributo 'SameSite' per limitare l'esposizione ad attacchi di Cross-Site Request Forgery (CSRF). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | Verificare che i token di sessione basati su cookie utilizzino il prefisso \"__Host-\" in modo che i cookie vengano inviati solo all'host che ha inizialmente impostato il cookie. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Verificare che se l'applicazione viene pubblicata su un nome di dominio con altre applicazioni che impostano o utilizzano cookie di sessione che potrebbero rivelare i cookie di sessione, che sia presente l'attributo 'path' nei token di sessione utilizzando il percorso più specifico possibile. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Gestione Sessioni Basate su Token\n\nLa gestione delle sessioni basate su token include JWT, OAuth, SAML e API key. Tra queste, le API key sono note per essere deboli e non dovrebbero essere utilizzate nelle implementazioni moderne.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.5.1** | Verificare che l'applicazione consenta agli utenti di revocare i token OAuth che creano relazioni di fiducia verso le applicazioni collegate. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Verificare che l'applicazione utilizzi token di sessione anziché segreti e API key statici, salvo nelle implementazioni legacy. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Verificare che i token di sessione stateless utilizzino firme digitali, crittografia e altre contromisure per proteggersi da manomissioni, enveloping, replay, null cipher, attacchi di key substitution. | | ✓ | ✓ | 345 | |\n\n## V3.6 Riautenticazione Federata\n\nQuesta sezione riguarda coloro che scrivono codice per Relying Party (RP) o Credential Service Provider (CSP). Se ci si affida a codice che implementa queste funzionalità, assicurarsi che questi problemi vengano gestiti correttamente.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.6.1** | Verificare che i Relying Party (RP) specifichino il tempo massimo di autenticazione ai Credential Service Provider (CSP) e che i CSP richiedano una nuova autenticazione dell'utente se è stata utilizzata una sessione entro tale periodo. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Verificare che i Credential Service Provider (CSP) informino i Relying Party (RP) dell'ultimo evento di autenticazione, per consentire ai RP di determinare se è necessario richiedere una nuova autenticazione dell'utente. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Difese contro gli Exploit di Gestione Sessione\n\nEsistono pochi attacchi noti relativi alla gestione delle sessioni, alcuni dei quali sono legati all'esperienza utente (UX) con le sessioni. In passato, l'ASVS, seguendo i requisiti ISO 27002, imponeva il blocco delle sessioni simultanee multiple. Tuttavia, questo approccio non è più appropriato, sia perché gli utenti moderni utilizzano diversi dispositivi o perché l'applicazione è un'API senza sessione del browser. Inoltre, in molte implementazioni, l'ultimo autenticatore prevale, il che spesso avvantaggia l'attaccante. Questa sezione offre una guida avanzata per scoraggiare, ritardare e rilevare gli attacchi di gestione delle sessioni a livello di codice.\n\n### Descrizione dell'Attacco Half-Open\n\nNel 2018, diversi istituti finanziari sono stati vittime di compromissioni attraverso quello che è noto come \"attacco half-open\" (semi-aperto), un termine che è rimasto in uso nel settore. Gli attaccanti hanno sfruttato vulnerabilità comuni a diversi sistemi di autenticazione, gestione delle sessioni e controllo degli accessi, anche all'interno delle stesse istituzioni.\n\nL'attacco half-open inizia con il tentativo di bloccare, reimpostare o recuperare una credenziale. Molti sistemi di gestione delle sessioni utilizzano un pattern di progettazione che riutilizza gli oggetti o modelli di sessione del profilo utente tra stati di autenticazione diversi: non autenticato, parzialmente autenticato (ad esempio per il ripristino della password o il recupero dell'username) e completamente autenticato. Questo approccio assegna un token di sessione valido contenente informazioni del profilo della vittima, inclusi hash delle password e ruoli. Se i controlli di accesso nei controller o nei router non verificano correttamente che l'utente sia completamente autenticato, l'attaccante può agire come se fosse l'utente. Le azioni dell'attaccante possono includere la modifica della password dell'utente con un valore noto, l'aggiornamento dell'indirizzo email per effettuare un ripristino password, la disabilitazione dell'autenticazione a due fattori, la registrazione di un nuovo dispositivo MFA, o la visualizzazione e modifica delle API key.\n\n| # | Descrizione | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.7.1** | Verificare che l'applicazione garantisca una sessione di accesso completa e valida o richieda una riautenticazione o una verifica secondaria prima di consentire qualsiasi transazione sensibile o modifica dell'account. | ✓ | ✓ | ✓ | 306 | |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:56.814932"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x12-V4-Access-Control.md", "content": "# V4 Controllo degli accessi\n\n## Obiettivo del controllo\n\nCon il termine autorizzazione si intende il processo di consentire l'accesso alle risorse solo a coloro che sono autorizzati a utilizzarle. È essenziale che un'applicazione verificata soddisfi i seguenti requisiti di alto livello:\n\n* Gli utenti che accedono alle risorse devono disporre di credenziali valide.\n* Agli utenti devono essere associati ruoli e privilegi ben definiti.\n* I metadati di ruoli e permessi devono essere protetti da attacchi di replay o manomissione (tampering).\n\n## Requisiti di verifica della sicurezza\n\n## V4.1 Progettazione generale del controllo degli accessi\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.1.1** | Verificare che l'applicazione applichi le regole di controllo degli accessi su un livello di servizio trusted, soprattutto se è presente il controllo degli accessi lato client che potrebbe essere bypassato. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Verificare che tutti gli attributi utente e dati e le informazioni sulle policy utilizzate dai controlli di accesso non possano essere manipolati dagli utenti finali se non espressamente autorizzati. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Verificare che esista il principio del privilegio minimo: gli utenti dovrebbero poter accedere solo a funzioni, file di dati, URL, controller, servizi e altre risorse per le quali possiedono un'autorizzazione specifica. Ciò implica una protezione contro lo spoofing e l'escalation di privilegi ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [ELIMINATO, DUPLICATO DI 4.1.3] | | | | |\n| **4.1.5** | Verificare che i controlli di accesso falliscano in modo sicuro anche in caso di eccezione. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Controllo degli accessi a livello di operazione\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.2.1** | Verificare che i dati sensibili e le API siano protetti da attacchi IDOR (Insecure Direct Object Reference). Questi attacchi mirano alla creazione, lettura, aggiornamento ed eliminazione di record, come ad esempio quelli appartenenti ad altri utenti, la visualizzazione di tutti i record o l'eliminazione di tutti i dati. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Verificare che l'applicazione o il framework implementi un meccanismo anti-CSRF robusto per proteggere le funzionalità autenticate e che un meccanismo anti-automazione o anti-CSRF efficace protegga anche le funzionalità non autenticate. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Ulteriori considerazioni sul controllo degli accessi\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.3.1** | Verificare che le interfacce di amministrazione utilizzino un'adeguata autenticazione a due fattori per prevenire l'utilizzo non autorizzato. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Verificare che il directory listing sia disabilitato a meno che non sia espressamente richiesto. Inoltre, le applicazioni non devono consentire la scoperta o la divulgazione di metadati di file o directory, come cartelle Thumbs.db, .DS_Store, .git o .svn. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Verificare che l'applicazione implementi un'autorizzazione aggiuntiva (step-up o adattiva) per i sistemi di basso valore e/o separazione dei compiti per le applicazioni di alto valore, al fine di applicare controlli antifrode in base al rischio e alle frodi passate. | | ✓ | ✓ | 732 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:56.913760"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Validazione, Sanificazione e Codifica\n\n## Obiettivo del controllo\n\nLa problematica di sicurezza più comune nelle applicazioni web è la mancanza di una valida convalida dell'input proveniente dal client o dall'ambiente, e l'assenza di codifica dell'output. Questa carenza è alla base delle vulnerabilità più gravi delle applicazioni web, come Cross-Site Scripting (XSS), SQL injection, injection di interprete, attacchi locale/Unicode, attacchi al file system e buffer overflow.\n\nPer garantire la sicurezza dell'applicazione, è essenziale soddisfare i seguenti requisiti di alto livello:\n\n* L'architettura di convalida dell'input e di codifica dell'output deve seguire procedure concordate per prevenire gli attacchi di injection.\n* I dati di input devono essere fortemente tipizzati, validati, controllati per range o lunghezza, sanitizzati o filtrati.\n* I dati di output devono essere codificati o \"escaped\" in base al contesto, il più vicino possibile all'interprete.\n\nCon l'architettura moderna delle applicazioni web, la codifica dell'output è più importante che mai. In alcuni scenari è difficile fornire una convalida dell'input efficace, quindi l'utilizzo di API sicure come query parametrizzate, framework di templating con escaping automatico o una codifica dell'output accuratamente scelta è fondamentale per la sicurezza dell'applicazione.\n\n## V5.1 Input Validation\n\nL'implementazione corretta dei controlli di convalida dell'input, utilizzando allow list e tipizzazione forte dei dati, può eliminare oltre il 90% di tutti gli attacchi di injection. I controlli di lunghezza e di range possono ridurre ulteriormente tali attacchi. Integrare una convalida dell'input sicura è fondamentale durante l'architettura dell'applicazione, gli sprint di progettazione, l'implementazione e i test unitari e di integrazione. Sebbene molti di questi aspetti non possano essere verificati durante i penetration test, i risultati della loro mancata implementazione si riflettono generalmente in V5.3 - Requisiti di codifica dell'output e prevenzione delle injection. Si consiglia a sviluppatori e revisori di codice sicuro di trattare questa sezione come se il livello L1 fosse obbligatorio per tutte le voci al fine di prevenire le injection.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.1.1** | Verificare che l'applicazione disponga di difese contro gli attacchi di HTTP Parameter Pollution (HPP), soprattutto se il framework applicativo non distingue tra le sorgenti dei parametri di richiesta (GET, POST, cookie, header o variabili d'ambiente). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Verificare che il framework protegga dagli attacchi di assegnazione di massa dei parametri (Mass Assignment) o che l'applicazione implementi contromisure, come la marcatura dei campi come privati, per prevenire l'assegnazione insicura dei parametri. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Verificare che tutti gli input (campi di form HTML, richieste REST, parametri URL, header HTTP, cookie, file batch, feed RSS, ecc.) siano validati utilizzando la convalida positiva (liste positive o allow list). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Verificare che i dati strutturati siano fortemente tipizzati e validati rispetto a uno schema definito, inclusi caratteri consentiti, lunghezza e pattern (ad esempio numeri di carta di credito, indirizzi e-mail, numeri di telefono o convalida di coerenza tra campi correlati, come la verifica della corrispondenza tra città e codice postale). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Verificare che i redirect e i forward degli URL consentano solo destinazioni presenti in una lista consentita, oppure che mostrino un avviso quando si reindirizza verso contenuti potenzialmente non sicuri. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Sanitization and Sandboxing\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.2.1** | Verificare che tutto l'input HTML non fidato proveniente da editor WYSIWYG o simili venga correttamente sanitizzato con una libreria o funzionalità del framework per la sanitizzazione HTML. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Verificare che i dati non strutturati vengano sanitizzati per applicare misure di sicurezza come caratteri consentiti e vincoli sulla lunghezza. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Verificare che l'applicazione sanitizzi l'input dell'utente prima di inviarlo ai sistemi di posta elettronica per proteggersi dall'injection di codice SMTP o IMAP. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Verificare che l'applicazione eviti l'utilizzo di eval() o altre funzionalità di esecuzione dinamica del codice. Se non ci sono alternative, qualsiasi input utente incluso deve essere sanitizzato o eseguito in sandbox prima dell'esecuzione. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Verificare che l'applicazione si protegga dagli attacchi di injection di template assicurando che qualsiasi input utente incluso venga sanitizzato o eseguito in sandbox. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Verificare che l'applicazione si protegga dagli attacchi SSRF convalidando o sanificando dati non fidati o metadati di file HTTP, come nomi di file e campi di input URL, e utilizzando liste consentite di protocolli, domini, percorsi e porte. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Verificare che l'applicazione sanitizzi, disabiliti o esegua in sandbox contenuti SVG (Scalable Vector Graphics) scriptabili forniti dall'utente, in particolare quelli relativi a XSS derivanti da script inline e foreignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Verificare che l'applicazione sanitizzi, disabiliti o esegua in sandbox contenuti forniti dall'utente in linguaggi di scripting o di templating come Markdown, fogli di stile CSS o XSL, BBCode o simili. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Codifica dell'output e prevenzione dalle injection\n\nL'applicazione della codifica dell'output nelle immediate vicinanze o direttamente all'interno dell'interprete utilizzato è fondamentale per garantire la sicurezza di qualsiasi applicazione. Generalmente, la codifica dell'output non viene memorizzata in modo permanente, ma serve a rendere sicuro l'output nel contesto appropriato per un utilizzo immediato. La mancata codifica dell'output rende l'applicazione vulnerabile a iniezioni e potenzialmente pericolosa.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.3.1** | Verificare che la codifica dell'output sia pertinente all'interprete e al contesto specifico. Ad esempio, utilizzare codificatori specifici per valori HTML, attributi HTML, JavaScript, parametri URL, header HTTP, SMTP e altri a seconda del contesto, soprattutto per input non fidati (ad esempio nomi con caratteri Unicode o apostrofi, come ねこ o O'Hara). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Verificare che la codifica dell'output preservi il set di caratteri e la località scelti dall'utente, in modo tale che qualsiasi punto del carattere Unicode sia valido e gestito in modo sicuro. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Verificare che l'escape dell'output contestuale, preferibilmente automatico o, in casi limite, manuale, protegga da XSS riflessa, memorizzata e basata su DOM.  ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Verificare che la selezione dei dati o le query del database (ad esempio SQL, HQL, ORM, NoSQL) utilizzino query parametrizzate, ORM, framework di entità o siano altrimenti protette dagli attacchi di injection del database. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Verificare che, quando i meccanismi parametrizzati o più sicuri non siano presenti, venga utilizzata la codifica dell'output specifica del contesto per proteggersi dagli attacchi di injection, come l'utilizzo dell'escaping SQL per proteggersi dall'injection SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Verificare che l'applicazione si protegga dagli attacchi di injection JSON, dagli attacchi eval JSON e dalla valutazione delle espressioni JavaScript. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Verificare che l'applicazione si protegga dalle vulnerabilità di injection LDAP o che siano stati implementati controlli di sicurezza specifici per prevenire l'injection LDAP. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Verificare che l'applicazione si protegga dall'injection di comandi del SO e che le chiamate al sistema operativo utilizzino query del SO parametrizzate o la codifica contestuale dell'output della riga di comando. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Verificare che l'applicazione si protegga dagli attacchi di inclusione locale di file (LFI) o inclusione remota di file (RFI). | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Verificare che l'applicazione si protegga dagli attacchi di injection XPath o injection XML. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nNota: L'utilizzo di query SQL parametrizzate o l'escaping del codice SQL non è sempre sufficiente a prevenire le injection. Nomi di tabelle, colonne, clausole ORDER BY e altri elementi simili non possono essere soggetti a escaping. L'inclusione di dati forniti dall'utente, anche se sottoposti a escaping, in questi campi può portare a query errate o a vulnerabilità di injection SQL.\n\nNota: Il formato SVG consente esplicitamente l'esecuzione di script ECMA in quasi tutti i contesti, il che potrebbe rendere impossibile bloccare completamente tutti i vettori XSS basati su SVG. Se il caricamento di file SVG è necessario, si raccomanda fortemente di servire tali file con il tipo MIME testo/plain o di utilizzare un dominio separato per i contenuti forniti dagli utenti, in modo da evitare che un attacco XSS riuscito possa compromettere l'intera applicazione.\n\n## V5.4 Memoria, Stringhe e Codice Non Gestito\n\nI seguenti requisiti si applicano solo quando l'applicazione utilizza un linguaggio di sistema o codice non gestito.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.4.1** | Verificare che l'applicazione utilizzi stringhe memory-safe, copie di memoria sicure e operazioni aritmetiche su puntatori per rilevare o prevenire overflow dello stack, del buffer o dell'heap. | | ✓ | ✓ | 120 |\n| **5.4.2** | Verificare che le format string non accettino input potenzialmente ostile e siano immutabili. | | ✓ | ✓ | 134 |\n| **5.4.3** | Verificare che vengano utilizzate tecniche di convalida del segno, dell'intervallo e dell'input per prevenire overflow di interi. | | ✓ | ✓ | 190 |\n\n## V5.5 Prevenzione dalla Deserializzazione\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | Verificare che gli oggetti serializzati utilizzino controlli di integrità o siano crittografati per prevenire la creazione di oggetti malevoli o la manomissione dei dati. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Verificare che l'applicazione limiti correttamente i parser XML a utilizzare solo la configurazione più restrittiva possibile e che funzionalità non sicure come la risoluzione di entità esterne vengano disabilitate per prevenire attacchi di injection di Entità Esterne XML (XXE). | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Verificare che la deserializzazione di dati non fidati venga evitata o protetta sia nel codice personalizzato che nelle librerie di terze parti (come parser JSON, XML e YAML). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Verificare che durante l'analisi del JSON nei browser o nei backend basati su JavaScript, venga utilizzato JSON.parse per analizzare il documento JSON. Evitare di utilizzare eval() per analizzare il JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nPer informazioni aggiuntive su auto-escaping, consultare:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nPer informazioni aggiuntive su deserialization, consultare:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:56.987740"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x14-V6-Cryptography.md", "content": "# V6 Crittografia per lo storage\n\n## Obiettivo del controllo\n\nVerificare che un'applicazione soddisfi i seguenti requisiti di alto livello:\n\n* Tutti i moduli crittografici falliscono in modo sicuro e gli errori vengono gestiti correttamente.\n* Viene utilizzato un generatore di numeri casuali appropriato.\n* L'accesso alle chiavi è gestito in modo sicuro.\n\n## V6.1 Classificazione dei Dati\n\nL'asset più importante è il dato elaborato, memorizzato o trasmesso da un'applicazione. Eseguire sempre una valutazione di impatto sulla privacy per classificare correttamente le esigenze di protezione dei dati memorizzati.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.1.1** | Verificare che i dati personali regolamentati siano memorizzati crittografati a riposo, come le Informazioni di identificazione personale (PII), le informazioni personali sensibili o i dati considerati soggetti al GDPR dell'UE. | | ✓ | ✓ | 311 |\n| **6.1.2** | Verificare che i dati sanitari regolamentati siano memorizzati crittografati a riposo, come cartelle cliniche, dettagli sui dispositivi medici o record di ricerca deanonimizzati. | | ✓ | ✓ | 311 |\n| **6.1.3** | Verificare che i dati finanziari regolamentati siano memorizzati crittografati a riposo, come conti finanziari, inadempienze o cronologie creditizie, registri fiscali, cronologie retributive, beneficiari o record di mercato o di ricerca deanonimizzati. | | ✓ | ✓ | 311 |\n\n## V6.2 Algoritmi\n\nI recenti progressi nella crittografia hanno reso insicuri o insufficienti alcuni algoritmi e lunghezze delle chiavi che in passato erano considerati sicuri per proteggere i dati. Pertanto, dovrebbe essere possibile cambiare facilmente l'algoritmo utilizzato.\n\nSebbene questa sezione non sia facilmente verificabile tramite penetration testing, gli sviluppatori dovrebbero considerarla obbligatoria, anche se il livello 1 è assente nella maggior parte degli elementi.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.2.1** | Verificare che tutti i moduli crittografici falliscano in modo sicuro e che gli errori vengano gestiti in modo tale da non consentire attacchi Oracle Padding. | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Verificare che vengano utilizzati algoritmi, modalità e librerie crittografiche comprovate dal settore o approvate dal governo, invece di implementarle da zero. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Verificare che il vettore di inizializzazione, la configurazione e le modalità dei cifrari a blocchi siano impostate in modo sicuro utilizzando le pratiche più recenti. | | ✓ | ✓ | 326 |\n| **6.2.4** | Verificare che numeri casuali, algoritmi di crittografia o hashing, lunghezze delle chiavi, round, cifrari o modalità possano essere riconfigurati, aggiornati o cambiati in qualsiasi momento, per proteggersi da violazioni crittografiche. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Verificare che non vengano utilizzate modalità a blocchi insicure (ad esempio ECB, ecc.), modalità di padding insicure (ad esempio PKCS # 1 v1.5, ecc.), cifrari con dimensioni ridotte del blocco (ad esempio Triple-DES, Blowfish, ecc.) e algoritmi di hashing deboli (ad esempio MD5, SHA1, ecc.) a meno che non siano necessari per la compatibilità con versioni precedenti. | | ✓ | ✓ | 326 |\n| **6.2.6** | Verificare che i nonce, i vettori di inizializzazione e altri valori monouso non vengano riutilizzati con la stessa chiave crittografica. Il metodo di generazione deve essere appropriato per l'algoritmo utilizzato. | | ✓ | ✓ | 326 |\n| **6.2.7** | Verificare che i dati crittografati siano autenticati tramite firme, modalità di cifratura autenticate o HMAC per garantire che il testo cifrato non venga alterato da terze parti non autorizzate. | | | ✓ | 326 |\n| **6.2.8** | Verificare che tutte le operazioni crittografiche vengano eseguite a tempo costante, senza operazioni di 'cortocircuito' durante i confronti, calcoli o restituzione di valori, per evitare di rivelare informazioni. | | | ✓ | 385 |\n\n## V6.3 Valori casuali\n\nLa generazione di numeri pseudo-casuali (PRNG) veramente casuali è estremamente difficile da ottenere. In generale, le buone fonti di entropia all'interno di un sistema tendono a esaurirsi rapidamente se utilizzate in modo eccessivo, mentre l'uso di fonti con minore casualità può portare alla creazione di chiavi e segreti prevedibili.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.3.1** | Verificare che tutti i numeri casuali, nomi di file, GUID e stringhe siano generati utilizzando un generatore di numeri casuali crittograficamente sicuro approvato dal modulo crittografico quando si desidera che questi valori non siano indovinabili da un attaccante. | | ✓ | ✓ | 338 |\n| **6.3.2** | Verificare che i GUID casuali siano creati utilizzando l'algoritmo GUID v4 e un generatore di numeri pseudo-casuali crittograficamente sicuro (CSPRNG). I GUID creati utilizzando altri generatori di numeri pseudo-casuali potrebbero essere prevedibili. | | ✓ | ✓ | 338 |\n| **6.3.3** | Verificare che i numeri casuali vengano creati con un'entropia adeguata anche quando l'applicazione è sotto carico elevato, oppure che l'applicazione si degradi adeguatamente in tali circostanze. | | | ✓ | 338 |\n\n## V6.4 Gestione dei Segreti\n\nSebbene questa sezione non sia facilmente verificabile tramite penetration testing, gli sviluppatori dovrebbero considerarla obbligatoria nella sua interezza, anche se il livello 1 è assente nella maggior parte delle voci.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.4.1** | Verificare che venga utilizzata una soluzione di gestione dei segreti, come un key vault, per creare, archiviare, controllare l'accesso e distruggere i segreti in modo sicuro. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Verificare che il materiale crittografico non venga esposto all'applicazione ma utilizzi invece un modulo di sicurezza isolato, come un vault, per le operazioni crittografiche. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:57.087280"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x15-V7-Error-Logging.md", "content": "# V7 Gestione degli errori e logging\n\n## Obiettivo del controllo\n\nL'obiettivo principale della gestione degli errori e del logging è fornire informazioni utili all'utente, agli amministratori e ai team di risposta agli incidenti. Lo scopo non è quello di generare enormi quantità di log, ma piuttosto log di alta qualità, con un rapporto più elevato di \"segnale\" rispetto a \"rumore\" inutile.\n\nI log di alta qualità spesso contengono dati sensibili e devono essere protetti in conformità con le leggi o direttive locali sulla privacy dei dati. Questo dovrebbe includere:\n\n* Evitare di raccogliere o registrare informazioni sensibili a meno che non siano strettamente necessarie.\n* Garantire che tutte le informazioni registrate siano gestite in modo sicuro e protette in base alla loro classificazione dei dati.\n* Garantire che i log non vengano conservati indefinitamente, ma abbiano un periodo di conservazione il più breve possibile.\n\nSe i log contengono dati privati o sensibili, la cui definizione può variare da paese a paese, essi diventano alcune delle informazioni più sensibili detenute dall'applicazione e quindi un obiettivo molto appetibile per gli attaccanti.\n\nÈ inoltre fondamentale garantire che l'applicazione fallisca in modo sicuro e che gli errori non rivelino informazioni sensibili o non necessarie.\n\n## V7.1 Contenuto del Log\n\nLa registrazione di informazioni sensibili è rischiosa: i log stessi diventano dati riservati, il che implica che devono essere crittografati, soggetti a politiche di conservazione e resi disponibili durante gli audit di sicurezza. È essenziale garantire che nei log siano conservate solo le informazioni strettamente necessarie, evitando categoricamente informazioni di pagamento, credenziali (inclusi token di sessione), informazioni sensibili o dati personali identificabili.\n\nLa sezione V7.1 copre la voce A10 dell'OWASP Top 10 del 2017. Poiché né la voce A10 del 2017 né questa sezione sono facilmente verificabili tramite penetration testing, è importante:\n\n* Per gli sviluppatori: garantire la piena conformità a questa sezione, trattando tutte le voci come se fossero contrassegnate come L1.\n* Per i penetration tester: convalidare la piena conformità di tutte le voci in V7.1 tramite interviste, screenshot o dichiarazioni.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.1.1** | Verificare che l'applicazione non registri credenziali o dettagli di pagamento. I token di sessione devono essere memorizzati nei log solo in forma di hash irreversibile. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Verificare che l'applicazione non registri altri dati sensibili come definiti dalle leggi sulla privacy locali o dalla relativa politica di sicurezza. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Verificare che l'applicazione registri eventi rilevanti per la sicurezza, inclusi eventi di autenticazione riusciti e non riusciti, errori di controllo dell'accesso, errori di deserializzazione ed errori di convalida dell'input. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Verificare che ogni evento di log includa le informazioni necessarie per consentire un'analisi dettagliata della cronologia degli eventi. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Elaborazione dei Log\n\nLa registrazione tempestiva è fondamentale per gli eventi di audit, la classificazione e la gestione delle escalation. È necessario assicurarsi che i log dell'applicazione siano chiari e possano essere facilmente monitorati e analizzati localmente oppure inviati ad un sistema di monitoraggio remoto.\n\nLa sezione V7.2 copre la voce A10 dell'OWASP Top 10 2017. Poiché né la voce A10 del 2017 né questa sezione sono facilmente verificabili tramite penetration testing, è importante:\n\n* Per gli sviluppatori: garantire la piena conformità a questa sezione, trattando tutte le voci come se fossero contrassegnate come L1.\n* Per i penetration tester: convalidare la piena conformità di tutte le voci in V7.1 tramite interviste, screenshot o dichiarazioni.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.2.1** | Verificare che tutti i tentativi di autenticazione vengano registrati, senza memorizzare token di sessione o password sensibili. Questo dovrebbe includere le richieste con metadati necessari per le indagini di sicurezza. | | ✓ | ✓ | 778 |\n| **7.2.2** | Verificare che tutte le decisioni di controllo dell'accesso possano essere registrate e che tutte le autorizzazioni negate vengano registrate. Questo dovrebbe includere le richieste con metadati pertinenti necessari per le indagini di sicurezza. | | ✓ | ✓ | 285 |\n\n## V7.3 Protezione dei log\n\nI log che possono essere facilmente modificati o eliminati risultano inutili per indagini e le azioni legali. La divulgazione dei log può esporre dettagli interni sull'applicazione o sui dati in essa contenuti. È quindi necessario proteggere i log da divulgazione, modifica o eliminazione non autorizzate.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.3.1** | Verificare che tutti i componenti di logging codifichino opportunamente i dati per prevenire l'injection di log. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [ELIMINATO, DUPLICATO DI 7.3.1] | | | | |\n| **7.3.3** | Verificare che i log di sicurezza siano protetti da accesso e da modifiche non autorizzate. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Verificare che le sorgenti temporali siano sincronizzate con l'ora e il fuso orario corretti. Valutare attentamente la registrazione solo in UTC se i sistemi sono globali per facilitare l'analisi forense post-incidente. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nNota: la codifica dei log (7.3.1) è difficile da testare e revisionare utilizzando strumenti dinamici automatizzati e penetration test, ma architetti, sviluppatori e revisori del codice sorgente dovrebbero considerarla un requisito L1.\n\n## V7.4 Gestione degli Errori\n\nLo scopo della gestione degli errori è permettere all'applicazione di generare eventi rilevanti per la sicurezza, utili per monitoraggio, classificazione ed escalation. Non si tratta solo di creare log. Quando si registrano eventi di sicurezza, assicurarsi che i log abbiano uno scopo preciso e possano essere facilmente distinti da SIEM o software di analisi.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.4.1** | Verificare che venga visualizzato un messaggio generico quando si verifica un errore imprevisto o relativo alla sicurezza, potenzialmente con un ID univoco che il personale di supporto può utilizzare per indagare. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Verificare che la gestione delle eccezioni (o un equivalente funzionale) venga utilizzata in tutto il codice per tenere conto di condizioni di errore previste e impreviste. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Verificare che sia definito un gestore di errori \"di ultima istanza\" in grado di intercettare tutte le eccezioni non gestite ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nNota: alcuni linguaggi, come Swift e Go, e molti linguaggi funzionali a causa delle comuni pratiche di progettazione, non supportano eccezioni o gestori di eventi di ultima istanza. In questo caso, architetti e sviluppatori devono utilizzare un modello, un linguaggio o un framework che consenta alle applicazioni di gestire in modo sicuro eventi eccezionali, imprevisti o relativi alla sicurezza.\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:57.152309"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x16-V8-Data-Protection.md", "content": "# V8 Protezione dei dati\n\n## Obiettivo del controllo\n\nEsistono tre elementi chiave per una solida protezione dei dati: riservatezza, integrità e disponibilità (CIA). Questo standard presuppone che la protezione dei dati venga applicata su un sistema affidabile, come un server, opportunamente protetto e dotato di adeguate misure di sicurezza.\n\nLe applicazioni devono presumere che tutti i dispositivi degli utenti possano essere in qualche modo compromessi. Quando un'applicazione trasmette o archivia informazioni sensibili su dispositivi non sicuri, come computer condivisi, telefoni e tablet, è responsabilità dell'applicazione garantire che i dati archiviati su tali dispositivi siano crittografati e non possano essere facilmente ottenuti, alterati o divulgati in modo illecito.\n\nVerificare che un'applicazione soddisfi i seguenti requisiti di alto livello:\n\n* Riservatezza: I dati devono essere protetti da lettura o divulgazione non autorizzate sia durante il trasferimento che durante l'archiviazione.\n* Integrità: I dati devono essere protetti dalla creazione, alterazione o eliminazione malevola da parte di attori malintenzionati.\n* Disponibilità: I dati devono essere disponibili all'occorrenza per gli utenti autorizzati.\n\n## V8.1 Protezione Generale dei Dati\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.1.1** | Verificare che l'applicazione impedisca la memorizzazione nella cache di dati sensibili in componenti del server come bilanciatori di carico e cache applicative. | | ✓ | ✓ | 524 |\n| **8.1.2** | Verificare che tutte le copie temporanee o memorizzate nella cache dei dati sensibili archiviate sul server siano protette dall'accesso non autorizzato o eliminate/invalidate dopo che l'utente autorizzato accede ai dati sensibili. | | ✓ | ✓ | 524 |\n| **8.1.3** | Verificare che l'applicazione riduca al minimo il numero di parametri in una richiesta, come campi nascosti, variabili Ajax, cookie e header. | | ✓ | ✓ | 233 |\n| **8.1.4** | Verificare che l'applicazione possa rilevare e allertare su un numero anomalo di richieste, ad esempio per IP, utente, totale per ora o giorno, o qualsiasi elemento rilevante per l'applicazione. | | ✓ | ✓ | 770 |\n| **8.1.5** | Verificare che vengano eseguiti backup regolari dei dati importanti e che venga eseguito un ripristino di prova dei dati. | | | ✓ | 19 |\n| **8.1.6** | Verificare che i backup siano archiviati in modo sicuro per impedire il furto o la corruzione dei dati. | | | ✓ | 19 |\n\n## V8.2 Protezione dei Dati lato Client\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.2.1** | Verificare che l'applicazione imposti header anti-caching sufficienti in modo che i dati sensibili non vengano memorizzati nella cache dei browser moderni. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Verificare che i dati memorizzati nell'archiviazione del browser (come localStorage, sessionStorage, IndexedDB o cookie) non contengano dati sensibili. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Verificare che i dati autenticati vengano cancellati dall'archiviazione client, come il DOM del browser, dopo la chiusura del client o della sessione. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Protezione dei Dati Sensibili e Privati\n\nQuesta sezione aiuta a proteggere i dati sensibili da accessi non autorizzati per creazione, lettura, aggiornamento o eliminazione, specialmente in grandi quantità.\n\nLa conformità a questa sezione implica anche la conformità ai controlli di accesso di V4, in particolare a V4.2. Ad esempio, per prevenire aggiornamenti o divulgazioni non autorizzate di informazioni personali sensibili, è necessario rispettare V4.2.1. Per una protezione completa, attenersi sia a questa sezione che a V4.\n\nNota: regolamenti e leggi sulla privacy, come gli Australian Privacy Principles (APP-11) o il GDPR, influenzano direttamente il modo in cui le applicazioni devono gestire l'archiviazione, l'uso e la trasmissione di informazioni personali sensibili. Questi possono variare da severe sanzioni a semplici linee guida. È consigliabile consultare le leggi e i regolamenti locali e, se necessario, rivolgersi a un esperto di privacy o a un avvocato specializzato.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.3.1** | Verificare che i dati sensibili vengano inviati al server nel corpo del messaggio HTTP o negli header, e che i parametri della stringa di query di qualsiasi metodo HTTP non contengano dati sensibili. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Verificare che gli utenti abbiano un metodo per rimuovere o esportare i propri dati su richiesta. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Verificare che agli utenti venga fornita una spiegazione chiara in merito alla raccolta e all'utilizzo delle informazioni personali fornite e che gli utenti abbiano fornito il consenso esplicito all'utilizzo di tali dati prima che vengano utilizzati in qualsiasi modo. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Verificare che tutti i dati sensibili creati ed elaborati dall'applicazione siano stati identificati e che sia presente una politica su come trattare i dati sensibili. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Verificare che l'accesso ai dati sensibili venga registrato (senza registrare i dati sensibili stessi), se i dati vengono raccolti ai sensi delle direttive pertinenti sulla protezione dei dati o laddove sia richiesta la registrazione degli accessi. | | ✓ | ✓ | 532 |\n| **8.3.6** | Verificare che le informazioni sensibili contenute nella memoria vengano sovrascritte non appena non sono più necessarie per mitigare gli attacchi di dump della memoria, utilizzando zeri o dati casuali. | | ✓ | ✓ | 226 |\n| **8.3.7** | Verificare che le informazioni sensibili o private che necessitano confidenzialità vengano crittografate utilizzando algoritmi approvati che forniscono sia riservatezza che integrità. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Verificare che le informazioni personali sensibili siano soggette a classificazione della conservazione dei dati, in modo tale che i dati vecchi o obsoleti vengano eliminati automaticamente, secondo una pianificazione specifica o in base alle necessità. | | ✓ | ✓ | 285 |\n\nQuando si considera la protezione dei dati, una priorità dovrebbe essere la prevenzione dell'estrazione o modifica in blocco, nonché dell'uso eccessivo. Ad esempio, molti sistemi di social media limitano gli utenti a 100 nuove amicizie al giorno, indipendentemente da quale sistema provengano le richieste. Allo stesso modo, una piattaforma bancaria potrebbe bloccare più di 5 transazioni all'ora per importi superiori a 1000 euro verso istituzioni esterne. I requisiti di ogni sistema variano, quindi la definizione di ciò che è \"anormale\" deve riflettere il modello di minaccia e il rischio aziendale. È fondamentale poter rilevare, scoraggiare o, preferibilmente, bloccare azioni anomale di massa.\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:57.250492"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x17-V9-Communications.md", "content": "# V9 Comunicazione\n\n## Obiettivo del controllo\n\nAssicurarsi che l'applicazione rispetti i seguenti requisiti di alto livello:\n\n* È necessaria la crittografia TLS o una crittografia equivalente, indipendentemente dalla riservatezza del contenuto.\n* Seguire le linee guida più recenti, comprese:\n  * Consigli sulla configurazione\n  * Cifrari e algoritmi consigliati\n* Evitare l'uso di algoritmi e cifrature deboli o prossimi alla deprecazione, salvo necessità specifiche.\n* Disabilitare algoritmi e cifrature deprecati o noti per essere insicuri.\n\nAll'interno di questi requisiti:\n\n* Seguire costantemente i consigli del settore sulla configurazione sicura di TLS, poiché tali indicazioni cambiano frequentemente a causa di vulnerabilità critiche rilevate in algoritmi e cifrature esistenti.\n* Utilizzare le versioni più aggiornate degli strumenti di revisione della configurazione TLS per definire l'ordine preferito e la selezione degli algoritmi.\n* Verificare la validità e l'attendibilità dei certificati utilizzati per l'autenticazione TLS.\n\n## V9.1 Sicurezza della Comunicazione lato Client\n\nGarantire che tutti i messaggi client vengano inviati su reti crittografate, utilizzando TLS 1.2 o versioni successive. \nUtilizzare strumenti aggiornati per esaminare regolarmente la configurazione del client.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.1.1** | Verificare che TLS venga utilizzato per tutte le connessioni client e che non si ripieghi su comunicazioni non sicure o non crittografate. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Utilizzare strumenti l'ultima versione dei test TLS per verificare che siano abilitate solo suite crittografiche robuste, con le suite più sicure impostate come preferite. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Verificare che siano abilitate solo le versioni più recenti consigliate del protocollo TLS, come TLS 1.2 e TLS 1.3. La versione più recente del protocollo TLS dovrebbe essere l'opzione preferita. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Sicurezza della Comunicazione lato Server\n\nLa comunicazione server va oltre il semplice HTTP. Devono essere implementate connessioni sicure da e verso altri sistemi, come sistemi di monitoraggio, strumenti di gestione, accesso remoto e SSH, middleware, database, mainframe, sistemi partner o sorgenti esterne. Tutte queste connessioni devono essere crittografate per evitare situazioni in cui le difese perimetrali siano robuste, ma l'intercettazione interna risulti banale.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.2.1** | Verificare che le connessioni da e verso il server utilizzino certificati TLS affidabili. Se vengono utilizzati certificati auto-generati o self-signed, il server deve essere configurato per fidarsi solo di CA interne specifiche e di certificati self-signed specifici. Tutti gli altri devono essere rifiutati. | | ✓ | ✓ | 295 |\n| **9.2.2** | Verificare che la comunicazione crittografata, come TLS, venga utilizzata per tutte le connessioni in ingresso e in uscita, incluse quelle per porte di gestione, monitoraggio, autenticazione, chiamate API o di servizi web, database, cloud, serverless, mainframe, connessioni esterne e con partner. Il server non deve ripiegare su protocolli non sicuri o non crittografati. | | ✓ | ✓ | 319 |\n| **9.2.3** | Verificare che tutte le connessioni crittografate a sistemi esterni che coinvolgono informazioni o funzioni sensibili siano autenticate. | | ✓ | ✓ | 287 |\n| **9.2.4** | Verificare che la revoca corretta dei certificati, come lo \"Online Certificate Status Protocol (OCSP) Stapling\", sia abilitata e configurata. | | ✓ | ✓ | 299 |\n| **9.2.5** | Verificare che gli errori di connessione TLS con il backend vengano loggati. | | | ✓ | 544 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Note su \"Modalità di TSL approvate\":\n    * In passato, l'ASVS faceva riferimento allo standard statunitense FIPS 140-2, ma applicare standard americani a livello globale può essere difficile, contraddittorio o confusionario.\n    * Un metodo migliore per raggiungere la conformità alla sezione 9.1 sarebbe quello di consultare guide come [TLS lato server di Mozilla](https://wiki.mozilla.org/Security/Server_Side_TLS), [generare configurazioni note e sicure](https://mozilla.github.io/server-side-tls/ssl-config-generator/), e utilizzare strumenti di valutazione TLS aggiornati e riconosciuti per ottenere il livello di sicurezza desiderato.\n", "timestamp": "2025-10-24T11:39:57.313385"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x18-V10-Malicious.md", "content": "# V10 Codice malevolo\n\n## Obiettivo del controllo\n\nAssicurarsi che l'applicazione rispetti i seguenti requisiti di alto livello:\n\n* La gestione delle attività malevole deve essere sicura e appropriata per non compromettere il resto dell'applicazione.\n* Il codice non deve contenere bombe a tempo o altri attacchi temporizzati.\n* Il codice non deve \"chiamare casa\" verso destinazioni malevole o non autorizzate.\n* Il codice deve essere privo di backdoor, Easter egg, attacchi salami, rootkit o codice non autorizzato controllabile da un aggressore.\n\nÈ impossibile verificare completamente l'assenza di codice malevolo. Tuttavia, si devono compiere tutti gli sforzi possibili per garantire che il codice non contenga funzionalità dannose o indesiderate.\n\n## V10.1 Code Integrity\n\nLa migliore difesa contro il codice malevolo è \"fidarsi, ma verificare\". L'introduzione di codice non autorizzato o malevolo nel sorgente è spesso considerata un reato in molte giurisdizioni. Le politiche e le procedure dovrebbero chiarire le sanzioni relative al codice malevolo.\n\nI lead developer dovrebbero revisionare regolarmente i commit del codice, in particolare quelli che potrebbero accedere alle funzioni di time, I/O o di rete.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.1.1** | Verificare che sia in uso uno strumento di analisi del codice in grado di rilevare codice potenzialmente malevolo, come funzioni temporali, operazioni insicure su file e connessioni di rete. | | | ✓ | 749 |\n\n## V10.2 Ricerca di codice malevolo\n\nIl codice malevolo è estremamente raro e difficile da individuare. La revisione manuale riga per riga del codice può essere utile per cercare bombe logiche, ma anche il revisore più esperto potrebbe avere difficoltà a individuare codice malevolo, anche sapendo della sua presenza.\n\nLa conformità a questa sezione non è possibile senza un accesso completo al codice sorgente, incluse le librerie di terze parti.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.2.1** | Verificare che il codice sorgente dell'applicazione e le librerie di terze parti non contengano funzionalità non autorizzate di \"chiamata a casa\" o raccolta dati. Se tale funzionalità esiste, è necessario ottenere il permesso dell'utente prima di raccogliere qualsiasi dato. | | ✓ | ✓ | 359 |\n| **10.2.2** | Verificare che l'applicazione non richieda autorizzazioni non necessarie o eccessive per funzionalità o sensori legati alla privacy, come contatti, fotocamere, microfoni o posizione. | | ✓ | ✓ | 272 |\n| **10.2.3** | Verificare che il codice sorgente dell'applicazione e le librerie di terze parti non contengano backdoor, come account o chiavi aggiuntive non documentate e codificate, offuscamento del codice, blob binari non documentati, rootkit, funzionalità anti-debug, funzionalità di debug non sicure o funzionalità obsolete, non sicure o nascoste che potrebbero essere utilizzate in modo malevolo se scoperte. | | | ✓ | 507 |\n| **10.2.4** | Verificare che il codice sorgente dell'applicazione e le librerie di terze parti non contengano bombe a tempo cercando funzioni relative a data e ora. | | | ✓ | 511 |\n| **10.2.5** | Verificare che il codice sorgente dell'applicazione e le librerie di terze parti non contengano codice malevolo, come attacchi salami, bypass logici o bombe logiche. | | | ✓ | 511 |\n| **10.2.6** | Verificare che il codice sorgente dell'applicazione e le librerie di terze parti non contengano Easter egg o altre funzionalità potenzialmente indesiderate. | | | ✓ | 507 |\n\n## V10.3 Integrità dell'applicazione\n\nAnche dopo la distribuzione, un'applicazione può essere vulnerabile all'inserimento di codice malevolo. Le applicazioni devono proteggersi da attacchi comuni, come l'esecuzione di codice non firmato proveniente da fonti non fidate e il takeover di sottodomini.\n\nLa conformità a questa sezione richiede probabilmente l'implementazione di controlli operativi e monitoraggi continui.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.3.1** | Verificare che, se l'applicazione dispone di una funzione di aggiornamento automatico client o server, gli aggiornamenti vengano ottenuti su canali sicuri e firmati digitalmente. Il codice di aggiornamento deve convalidare la firma digitale dell'aggiornamento prima di installarlo o eseguirlo. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Verificare che l'applicazione impieghi protezioni dell'integrità, come la firma del codice o l'integrità delle sotto-risorse. L'applicazione non deve caricare o eseguire codice da fonti non fidate, come inclusioni, moduli, plugin, codice o librerie provenienti da fonti non fidate o da Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Verificare che l'applicazione disponga di protezioni contro takeover di sottodomini se si affida a voci DNS o sottodomini DNS, come nomi di dominio scaduti, puntatori DNS o CNAME obsoleti, progetti scaduti in repository di codice sorgente pubblici, o API cloud temporanee, funzioni serverless o bucket di archiviazione (autogen-bucket-id.cloud.example.com) o simili. Le protezioni possono includere la verifica periodica della scadenza o della modifica dei nomi DNS utilizzati dalle applicazioni. | ✓ | ✓ | ✓ | 350 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:57.375965"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x19-V11-BusLogic.md", "content": "# V11 Logica di business\n\n## Obiettivo del controllo\n\nVerificare che un'applicazione soddisfi i seguenti requisiti di alto livello:\n\n* Il flusso della logica di business deve essere sequenziale, elaborato nell'ordine corretto e non deve essere aggirabile.\n* La logica di business deve includere limiti per rilevare e prevenire attacchi automatizzati, come trasferimenti di fondi ripetuti di piccolo importo o l'aggiunta massiva di utenti (ad esempio, un milione di amici contemporaneamente).\n* I flussi della logica di business ad alto valore devono considerare possibili abusi e attori malintenzionati, e devono includere protezioni contro attacchi di spoofing, manomissione, divulgazione di informazioni e escalation di privilegi.\n\n## V11.1 Sicurezza della logica di business\n\nLa sicurezza della logica di business è così specifica per ogni applicazione che non esiste una lista di controllo universale. Deve essere progettata per proteggersi da minacce esterne probabili e non può essere implementata successivamente tramite firewall per applicazioni web o comunicazioni sicure. Si raccomanda di utilizzare il threat modeling durante le fasi di progettazione, ad esempio attraverso strumenti come OWASP Cornucopia o simili.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **11.1.1** | Verificare che l'applicazione elabori i flussi della logica di business per lo stesso utente solo in sequenza e senza saltare passaggi. | ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Verificare che l'applicazione elabori i flussi della logica di business solo con tutti i passaggi completati in un lasso di tempo umano realistico, ovvero le transazioni non vengano eseguite troppo rapidamente. | ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Verificare che l'applicazione abbia limiti appropriati per azioni o transazioni aziendali specifiche, applicati correttamente su base per utente. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Verificare che l'applicazione disponga di controlli anti-automazione per proteggersi da chiamate eccessive, come esfiltrazione di massa di dati, richieste di logica di business, caricamenti di file o attacchi denial of service. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Verificare che l'applicazione disponga di limiti o convalide della logica di business per proteggersi da probabili rischi o minacce aziendali, identificati mediante threat modeling o metodologie simili. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Verificare che l'applicazione non soffra di problemi \"Time Of Check to Time Of Use\" (TOCTOU) o altre condizioni di race condition per operazioni sensibili. | | ✓ | ✓ | 367 |\n| **11.1.7** | Verificare che l'applicazione monitori eventi o attività inusuali da una prospettiva di logica di business. Ad esempio, tentativi di eseguire azioni fuori ordine o azioni che un utente normale non proverebbe mai ad eseguire. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Verificare che l'applicazione abbia un sistema di allerta configurabile in caso di rilevamento di attacchi automatizzati o attività inusuali. | | ✓ | ✓ | 390 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* Anti-automation can be achieved in many ways, including the use of [OWASP AppSensor](https://github.com/jtmelton/appsensor) and [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) can also help with Attack Detection and Response.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:57.437157"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x20-V12-Files-Resources.md", "content": "# V12 File e risorse\n\n## Obiettivo del controllo\n\nVerificare che un'applicazione soddisfi i seguenti requisiti di alto livello:\n\n* I file non considerati attendibili devono essere gestiti in modo appropriato e sicuro.\n* I file non considerati attendibili ottenuti da fonti non affidabili devono essere archiviati al di fuori della root web e con permessi limitati.\n\n## V12.1 Caricamento di file\n\nSebbene gli attacchi \"Zip Bomb\" siano facilmente testabili tramite tecniche di penetration testing, sono classificati come di livello L2 e superiore per incoraggiare una progettazione e uno sviluppo accurati, con una revisione manuale attenta. Questo evita il ricorso a test di penetration testing automatizzati o manuali non qualificati per individuare condizioni di denial-of-service.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.1.1** | Verificare che l'applicazione non accetti file di grandi dimensioni che potrebbero saturare lo storage o causare un denial-of-service. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Verificare che l'applicazione controlli i file compressi (es. zip, gz, docx, odt) confrontandoli con la dimensione massima consentita allo stato non compresso e con il numero massimo di file prima di procedere alla decompressione. | | ✓ | ✓ | 409 |\n| **12.1.3** | Verificare che venga applicata una quota per la dimensione dei file e un numero massimo di file per utente, per garantire che un singolo utente non possa saturare lo storage con troppi file o file eccessivamente grandi. | | ✓ | ✓ | 770 |\n\n## V12.2 Integrità dei file\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.2.1** | Verificare che i file provenienti da fonti non affidabili siano effettivamente del tipo dichiarato, analizzandone il contenuto. | | ✓ | ✓ | 434 |\n\n## V12.3 Esecuzione dei file\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.3.1** | Verificare che il nome del file inviato dall'utente non venga utilizzato direttamente dai filesystem di sistema o del framework e che venga utilizzata una API URL per proteggere da path traversal. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Verificare o ignorare il nome del file inviato dall'utente per impedire la divulgazione, la creazione, l'aggiornamento o l'eliminazione di file locali (LFI). | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Verificare o ignorare il nome del file inviato dall'utente per impedire la divulgazione o l'esecuzione di file remoti tramite attacchi di Remote File Inclusion (RFI) o Server-Side Request Forgery (SSRF). | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Verificare che l'applicazione protegga dal Reflective File Download (RFD) convalidando o ignorando i nomi dei file inviati dall'utente in un parametro JSON, JSONP o URL. L'header Content-Type della risposta deve essere impostato su \"text/plain\" e l'header Content-Disposition deve avere un nome file immutabile. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Verificare che i metadati di file non affidabili non vengano utilizzati direttamente con le API o le librerie di sistema per proteggere da OS command injection. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Verificare che l'applicazione non includa ed esegua funzionalità da fonti non affidabili, come content delivery network non verificate, librerie JavaScript, librerie npm di Node.js o DLL lato server. | | ✓ | ✓ | 829 |\n\n## V12.4 Archiviazione File\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.4.1** | Verificare che i file ottenuti da fonti non affidabili siano archiviati al di fuori della root web, con permessi limitati. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Verificare che i file ottenuti da fonti non affidabili vengano scansionati da antivirus per prevenire il caricamento e la distribuzione di contenuti dannosi noti. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Download file\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.5.1** | Verificare che il livello web sia configurato per servire solo file con estensioni specifiche per prevenire divulgazione involontaria di informazioni e codice sorgente. Ad esempio, è necessario bloccare il download di file di backup (es. .bak), file di lavoro temporanei (es. .swp), file compressi (.zip, .tar.gz, ecc.) e altre estensioni comunemente utilizzate dagli editor, a meno che non siano espressamente richiesti. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Verificare che le richieste dirette a file caricati non vengano mai eseguite come contenuto HTML/JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 Protezione da SSRF\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.6.1** | Verificare che il server web o applicativo sia configurato con una allow-list di risorse o sistemi verso i quali il server può inviare richieste o caricare dati/file. | ✓ | ✓ | ✓ | 918 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:57.525536"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x21-V13-API.md", "content": "# V13 API and Web Service\n\n## Obiettivo del controllo\n\nAssicurarsi che un'applicazione verificata che utilizza API del livello di servizio trusted (comunemente JSON, XML o GraphQL) disponga di:\n\n* Autenticazione, gestione delle sessioni e autorizzazione adeguate per tutti i servizi web.\n* Validazione dell'input di tutti i parametri che transitano da un livello di trust inferiore a uno superiore.\n* Controlli di sicurezza efficaci per tutti i tipi di API, incluse quelle cloud e serverless.\n\nSi raccomanda di leggere questo capitolo insieme a tutti gli altri capitoli dello stesso livello; le problematiche relative all'autenticazione o alla gestione delle sessioni API non verranno ripetute qui.\n\n## V13.1 Sicurezza generica dei servizi web\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.1.1** | Verificare che tutti i componenti dell'applicazione utilizzino le stesse codifiche e parser per evitare attacchi di parsing che sfruttano comportamenti diversi di parsing URI o file, che potrebbero essere utilizzati in attacchi SSRF e RFI. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [ELIMINATO, DUPLICATO DI 4.3.1] | | | | |\n| **13.1.3** | Verificare che gli URL delle API non espongano informazioni sensibili, come chiavi API, token di sessione, ecc. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Verificare che le decisioni di autorizzazione vengano prese sia a livello di URI, applicate da controlli di sicurezza programmatici o dichiarativi a livello di controller o router, sia a livello di risorsa, applicate da permessi basati sul modello. | | ✓ | ✓ | 285 |\n| **13.1.5** | Verificare che le richieste contenenti tipi di contenuto inaspettati o mancanti vengano rifiutate con header appropriati (status 406 Unacceptable della risposta HTTP o 415 Unsupported Media Type). | | ✓ | ✓ | 434 |\n\n## V13.2 Servizi web RESTful\n\nLa validazione dello schema JSON è ancora in fase di standardizzazione (vedi riferimenti). Quando si valuta l'uso della validazione dello schema JSON, considerata una best practice per i servizi web RESTful, è consigliabile adottare le seguenti strategie di validazione dei dati in combinazione con la convalida dello schema JSON:\n\n* Validazione del parsing dell'oggetto JSON, per verificare la presenza di elementi mancanti o aggiuntivi.\n* Validazione dei valori dell'oggetto JSON utilizzando metodi standard di convalida dell'input, come tipo di dati, formato dei dati, lunghezza, ecc.\n* Convalida formale dello schema JSON.\n\nUna volta che lo standard di convalida dello schema JSON sarà formalizzato, ASVS aggiornerà le sue raccomandazioni in questa sezione. È importante monitorare regolarmente le librerie di validazione dello schema JSON in uso, poiché richiederanno aggiornamenti continui fino alla formalizzazione dello standard e alla correzione dei bug nelle implementazioni di riferimento.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.2.1** | Verificare che i metodi HTTP RESTful abilitati siano una scelta valida per l'utente o l'azione, ad esempio impedendo a utenti normali di utilizzare DELETE o PUT su API o risorse protette. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Verificare che la convalida dello schema JSON sia implementata e verificata prima di accettare l'input. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Verificare che i servizi web RESTful che utilizzano cookie siano protetti da Cross-Site Request Forgery utilizzando almeno uno o più dei seguenti metodi: pattern double submit per i cookie, nonce CSRF, o controlli sull'header Origin. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [ELIMINATO, DUPLICATO DI 11.1.4] | | | | |\n| **13.2.5** | Verificare che i servizi REST controllino esplicitamente che il Content-Type in ingresso sia quello previsto, come application/xml o application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Verificare che gli header e il payload del messaggio siano affidabili e non vengano modificati durante il transito. In molti casi, potrebbe essere sufficiente richiedere una crittografia forte per il trasporto (solo TLS) in quanto fornisce protezione sia della riservatezza che dell'integrità. Le firme digitali per messaggio possono fornire un'ulteriore garanzia in aggiunta alle protezioni di trasporto per applicazioni ad alta sicurezza, ma introducono una maggiore complessità e rischi che devono essere valutati rispetto ai benefici. | | ✓ | ✓ | 345 |\n\n## V13.3 Servizi web SOAP\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.3.1** | Verificare che la convalida dello schema XSD avvenga per garantire un documento XML ben formato, seguita dalla convalida di ciascun campo di input prima di qualsiasi elaborazione dei dati. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Verificare che il payload del messaggio sia firmato utilizzando WS-Security per garantire un trasporto affidabile tra client e servizio. | | ✓ | ✓ | 345 |\n\nNota: A causa di problemi con attacchi XXE contro DTD, la convalida DTD non deve essere utilizzata e la valutazione DTD del framework deve essere disabilitata secondo i requisiti stabiliti in V14 Configurazione.\n\n## V13.4 GraphQL\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.4.1** | Verificare che per le query venga utilizzata una allow-list o una combinazione di limitazione della profondità e della quantità dei risultati restituiti per prevenire Denial of Service (DoS) a livello di GraphQL o dello strato di persistenza a causa di query costose e annidate. Per scenari più avanzati, è consigliabile utilizzare l'analisi del costo delle query. | | ✓ | ✓ | 770 |\n| **13.4.2** | Verificare che la logica di autorizzazione GraphQL o di altro livello dati venga implementata a livello di logica di business anziché a livello GraphQL. | | ✓ | ✓ | 285 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:39:57.593662"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x22-V14-Config.md", "content": "# V14 Configurazioni\n\n## Obiettivo del controllo\n\nAssicurarsi che un'applicazione verificata disponga di:\n\n* Un ambiente di build sicuro, ripetibile e automatizzabile.\n* Una gestione rigorosa di librerie, dipendenze e configurazione di terze parti in modo che l'applicazione non includa componenti obsoleti o non sicuri.\n\nLa configurazione predefinita dell'applicazione deve essere sicura per l'utilizzo su Internet.\n\n## V14.1 Build e distribuzione\n\nLe pipeline di build sono fondamentali per garantire una sicurezza ripetibile: ogni volta che viene rilevata una vulnerabilità, è possibile correggerla nel codice sorgente, negli script di build o di distribuzione, e testare automaticamente la correzione. Si raccomanda vivamente di utilizzare pipeline di build con controlli automatici di sicurezza e gestione delle dipendenze, che avvisino o interrompano la build per prevenire la distribuzione in produzione di problemi di sicurezza noti. L'esecuzione irregolare di passaggi manuali può facilmente portare a errori di sicurezza evitabili.\n\nCon il modello DevSecOps, è essenziale garantire la disponibilità e l'integrità continua della distribuzione e configurazione, mantenendo uno stato noto e funzionante. In passato, in caso di compromissione di un sistema, potevano servire giorni o mesi per dimostrare l'assenza di ulteriori intrusioni. Oggi, con infrastrutture software-defined, distribuzioni A/B a zero downtime e build automatizzate in container, è possibile creare, rafforzare e distribuire automaticamente una versione \"nota e funzionante\" di qualsiasi sistema compromesso.\n\nSe si utilizzano modelli tradizionali, è necessario implementare procedure manuali per rafforzare e fare il backup delle configurazioni, consentendo la rapida sostituzione di sistemi compromessi con sistemi integri in modo tempestivo.\n\nLa conformità a questa sezione richiede un sistema di build automatizzato e l'accesso agli script di build e distribuzione.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.1.1** | Verificare che i processi di build e distribuzione dell'applicazione vengano eseguiti in modo sicuro e ripetibile, come automazione CI/CD, gestione automatizzata della configurazione e script di distribuzione automatizzati. | | ✓ | ✓ | |\n| **14.1.2** | Verificare che le flag del compilatore siano configurate per abilitare tutte le protezioni disponibili e gli avvisi per buffer overflow, inclusa la randomizzazione dello stack, la data execution prevention e l'interruzione della build se vengono trovate operazioni non sicure su puntatori, memoria, format string, numeri interi o stringhe. | | ✓ | ✓ | 120 |\n| **14.1.3** | Verificare che la configurazione del server sia rafforzata secondo le raccomandazioni del server applicativo e dei framework utilizzati. | | ✓ | ✓ | 16 |\n| **14.1.4** | Verificare che l'applicazione, la configurazione e tutte le dipendenze possano essere ridistribuite in un lasso di tempo ragionevole utilizzando script di distribuzione automatizzati, creati da un runbook documentato e testato, o ripristinate da backup in modo tempestivo. | | ✓ | ✓ | |\n| **14.1.5** | che gli amministratori autorizzati possano verificare l'integrità di tutte le configurazioni relative alla sicurezza, al fine di rilevare eventuali manomissioni. | | | ✓ | |\n\n## V14.2 Dipendenze\n\nLa gestione delle dipendenze è cruciale per il funzionamento sicuro di qualsiasi applicazione. Il mancato aggiornamento di dipendenze obsolete o non sicure è una delle principali cause di attacchi gravi e costosi.\n\nNota: Al Livello 1, la conformità a 14.2.1 si basa sull'osservazione o il rilevamento di librerie e componenti lato client e di altro tipo, piuttosto che su un'analisi statica più approfondita del codice in fase di build o sull'analisi delle dipendenze. L'uso di queste tecniche più affidabili può essere documentato attraverso colloqui, se necessario.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.2.1** | Verificare che tutti i componenti siano aggiornati, preferibilmente utilizzando un dependency checker durante la fase di build o compilazione. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Verificare che tutte le funzionalità, documentazione, applicazioni di esempio e configurazioni non necessarie vengano rimosse. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Verificare che se le risorse dell'applicazione, come librerie JavaScript, CSS o web font, sono ospitate esternamente su una Content Delivery Network (CDN) o un provider esterno, venga utilizzata la Subresource Integrity (SRI) per assicurare l'integrità della risorsa. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Verificare che i componenti di terze parti provengano da repository predefiniti, affidabili e mantenuti frequentemente. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Verificare che venga mantenuto un Software Bill of Materials (SBOM) di tutte le librerie di terze parti utilizzate. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Verificare che la superficie di attacco sia ridotta tramite sandbox o incapsulamento delle librerie di terze parti per esporre all'applicazione solo le funzionalità richieste. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Divulgazione accidentale di informazioni di sicurezza\n\nLe configurazioni di produzione devono essere rafforzate per proteggersi da attacchi comuni, come la modalità di debug attiva, Cross-Site Scripting (XSS), Remote File Inclusion (RFI) ed eliminare le vulnerabilità legate alla scoperta di informazioni, spesso segnalate nei report di penetration testing. Sebbene molti di questi problemi non siano classificati come rischi significativi singolarmente, possono essere sfruttati in combinazione con altre vulnerabilità. Assicurandosi che tali problemi siano assenti per impostazione predefinita, si aumenta la difficoltà per il successo della maggior parte degli attacchi.\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.3.1** | [ELIMINATO, DUPLICATO DI 7.4.1] | | | | |\n| **14.3.2** | Verificare che le modalità di debug del server web o dell'applicazione e del framework dell'applicazione siano disabilitate in produzione per eliminare funzionalità di debug, console degli sviluppatori e divulgazioni di sicurezza accidentali. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Verificare che gli header HTTP o qualsiasi parte della risposta HTTP non espongano informazioni dettagliate sulla versione dei componenti di sistema. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 Header di sicurezza HTTP\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.4.1** | Verificare che ogni risposta HTTP contenga un header Content-Type. Specificare inoltre un set di caratteri sicuro (ad esempio, UTF-8, ISO-8859-1) se i tipi di contenuto sono text/*, /+xml e application/xml. Il contenuto deve corrispondere all'header Content-Type fornito. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Verificare che tutte le risposte dell'API contengano un header Content-Disposition: attachment; filename=\"api.json\" (o altro nome file appropriato per il tipo di contenuto). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Verificare che sia presente un header di risposta Content Security Policy (CSP) che contribuisca a mitigare l'impatto degli attacchi XSS come vulnerabilità di HTML, DOM, JSON e JavaScript injection. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Verificare che tutte le risposte contengano un header X-Content-Type-Options: nosniff. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Verificare che un header Strict-Transport-Security sia incluso su tutte le risposte e per tutti i sottodomini, come Strict-Transport-Security: max-age=15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Verificare che sia incluso un header Referrer-Policy adatto per evitare di esporre informazioni sensibili nell'URL tramite l'header Referer a terze parti non fidate. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Verificare che il contenuto di un'applicazione web non possa essere incorporato per impostazione predefinita in un sito di terze parti e che l'incorporamento delle risorse sia consentito solo se necessario utilizzando header di risposta Content-Security-Policy: frame-ancestors e X-Frame-Options appropriati. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Validazione dell'header di richiesta HTTP\n\n| # | Descrizione | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.5.1** | Verificare che il server dell'applicazione accetti solo i metodi HTTP utilizzati dall'applicazione/API, incluse le opzioni di pre-flight (OPTIONS), e registri o generi alert per qualsiasi richiesta non valida per il contesto dell'applicazione. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Verificare che l'header Origin fornito non venga utilizzato per l'autenticazione o il controllo degli accessi, in quanto può essere facilmente modificato da un attaccante. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Verificare che l'header CORS (Cross-Origin Resource Sharing) Access-Control-Allow-Origin utilizzi una allow-list di domini e sottodomini trusted per il confronto e non supporti l'origine \"null\". | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Verificare che gli header HTTP aggiunti da un proxy trusted o da dispositivi SSO, come un token bearer, siano autenticati dall'applicazione. | | ✓ | ✓ | 306 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Adding Content-Disposition to API responses helps prevent many attacks based on misunderstanding on the MIME type between client and server, and the \"filename\" option specifically helps prevent [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:39:57.686904"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x90-Appendix-A_Glossary.md", "content": "# Appendice A: Glossario\n\n- **Address Space Layout Randomization** (ASLR) – Una tecnica per rendere più complicato lo sfruttamento di bug di corruzione della memoria.\n- **Allow list** – Un elenco di dati o operazioni consentite, ad esempio un elenco di caratteri consentiti per la convalida degli input.\n- **Application Security** – La sicurezza a livello di applicazione si concentra sull'analisi dei componenti che compongono il livello applicativo del modello di riferimento per l'interconnessione di sistemi aperti (modello OSI), piuttosto che focalizzarsi, ad esempio, sul sistema operativo sottostante o sulle reti collegate.\n- **Application Security Verification** – La valutazione tecnica di un'applicazione rispetto all'OWASP ASVS.\n- **Application Security Verification Report** – Un report che documenta i risultati complessivi e le analisi di supporto prodotte dal verificatore per una particolare applicazione.\n- **Authentication** – La verifica dell'identità dichiarata di un utente dell'applicazione.\n- **Automated Verification** – L'utilizzo di strumenti automatizzati (strumenti di analisi dinamica, strumenti di analisi statica o entrambi) che utilizzano firme di vulnerabilità per individuare problemi.\n- **Black box testing** – È un metodo di test del software che esamina le funzionalità di un'applicazione senza analizzare le sue strutture o il suo funzionamento interno.\n- **Component** – Un'unità di codice autoconsistente, con interfacce disco e di rete associate che comunica con altri componenti.\n- **Cross-Site Scripting** (XSS) – Una vulnerabilità di sicurezza che si trova tipicamente nelle applicazioni web e consente l'injection di script lato client nel contenuto.\n- **Cryptographic module** – Hardware, software e/o firmware che implementa algoritmi crittografici e/o genera chiavi crittografiche.\n- **Common Weakness Enumeration** (CWE) - Un elenco sviluppato dalla comunità delle comuni debolezze di sicurezza del software. Serve come linguaggio comune, come metro di misura per gli strumenti di sicurezza software e come base per gli sforzi di identificazione, mitigazione e prevenzione delle debolezze.\n- **Design Verification** – La valutazione tecnica dell'architettura di sicurezza di un'applicazione.\n- **Dynamic Application Security Testing** (DAST) - Tecnologie progettate per rilevare condizioni indicative di una vulnerabilità di sicurezza in un'applicazione durante il suo stato di esecuzione.\n- **Dynamic Verification** – L'utilizzo di strumenti automatizzati che utilizzano firme di vulnerabilità per individuare problemi durante l'esecuzione di un'applicazione.\n- **Fast IDentity Online** (FIDO) - Un insieme di standard di autenticazione che consentono l'utilizzo di diversi metodi di autenticazione, tra cui dati biometrici, Trusted Platform Module (TPM), token di sicurezza USB, ecc.\n- **Globally Unique Identifier** (GUID) – Un numero di riferimento univoco utilizzato come identificatore nei software.\n- **Hyper Text Transfer Protocol** (HTTPS) – Un protocollo applicativo per sistemi informativi ipermediali distribuiti, collaborativi. È la base della comunicazione dati per il World Wide Web.\n- **Hardcoded keys** – Chiavi crittografiche memorizzate sul file system, sia nel codice, nei commenti o nei file.\n- **Hardware Security Module** (HSM) - Componente hardware in grado di memorizzare chiavi crittografiche e altri segreti in modo protetto.\n- **Hibernate Query Language** (HQL) - Un linguaggio di query simile a SQL utilizzato dalla libreria ORM Hibernate.\n- **Input Validation** – La normalizzazione e la convalida dell'input utente non fidato.\n- **Malicious Code** – Codice introdotto in un'applicazione durante il suo sviluppo a insaputa del proprietario dell'applicazione, che elude la politica di sicurezza prevista dall'applicazione. Non è la stessa cosa del malware come un virus o un worm!\n- **Malware** – Codice eseguibile introdotto in un'applicazione durante il runtime a insaputa dell'utente o dell'amministratore dell'applicazione.\n- **Open Web Application Security Project** (OWASP) – L'Open Web Application Security Project (OWASP) è una comunità mondiale gratuita e aperta che si concentra sul miglioramento della sicurezza del software applicativo. La nostra missione è rendere la sicurezza delle applicazioni \"visibile\", in modo che le persone e le organizzazioni possano prendere decisioni informate sui rischi per la sicurezza delle applicazioni. Vedi: [https://www.owasp.org/](https://www.owasp.org/)\n- **One-time Password** (OTP) - Una password univoca generata per essere utilizzata una sola volta.\n- **Object-relational Mapping** (ORM) - Un sistema utilizzato per consentire a un database relazionale/basato su tabelle di essere referenziato e interrogato all'interno di un programma applicativo utilizzando un modello a oggetti compatibile con l'applicazione.\n- **Password-Based Key Derivation Function 2** (PBKDF2) - Un algoritmo speciale unidirezionale utilizzato per creare una chiave crittografica forte da un testo di input (come una password) e un valore di salt casuale aggiuntivo e può quindi essere utilizzato per rendere più difficile crackare una password offline se il valore risultante viene archiviato invece della password originale.\n- **Personally Identifiable Information** (PII) - Sono informazioni che possono essere utilizzate da sole o con altre informazioni per identificare, contattare o localizzare una singola persona, o per identificare un individuo in un contesto.\n- **Position-independent executable** (PIE) - Un eseguibile in codice macchina che, posizionato da qualche parte nella memoria primaria, viene eseguito correttamente indipendentemente dal suo indirizzo assoluto.\n- **Public Key Infrastructure** (PKI) - Un accordo che lega le chiavi pubbliche con le rispettive identità delle entità. Il legame viene stabilito attraverso un processo di registrazione e rilascio di certificati presso e da parte di un'autorità di certificazione (CA).\n- **Public Switched Telephone Network** (PSTN) - La rete telefonica tradizionale che include sia i telefoni fissi che i telefoni cellulari.\n- **Relying Party** (RP) - Generalmente un'applicazione che si basa sull'autenticazione di un utente presso un provider di autenticazione separato. L'applicazione si basa su un qualche tipo di token o insieme di asserzioni firmate fornite da quel provider di autenticazione per fidarsi che l'utente sia chi dice di essere.\n- **Static application security testing** (SAST) - Un insieme di tecnologie progettate per analizzare il codice sorgente dell'applicazione, il bytecode e i binari per condizioni di codifica e progettazione che indicano vulnerabilità di sicurezza. Le soluzioni SAST analizzano un'applicazione dall'interno verso l'esterno senza eseguire il codice.\n- **Software development lifecycle** (SDLC) - Il processo passo-passo mediante il quale viene sviluppato il software, passando dai requisiti iniziali all'implementazione e alla manutenzione.\n- **Security Architecture** – Un'astrazione della progettazione di un'applicazione che identifica e descrive dove e come vengono utilizzati i controlli di sicurezza, e identifica e descrive anche la posizione e la riservatezza sia dei dati utente che applicativi.\n- **Security Configuration** – La configurazione runtime di un'applicazione che influenza il modo in cui vengono utilizzati i controlli di sicurezza.\n- **Security Control** – Una funzione o componente che esegue un controllo di sicurezza (ad esempio, un controllo di accesso) o, se chiamato, produce un effetto di sicurezza (ad esempio, la generazione di un record di audit).\n- **Server-side Request Forgery** (SSRF) - Un attacco che abusa della funzionalità sul server per leggere o aggiornare risorse interne fornendo o modificando un URL attraverso cui il codice in esecuzione sul server leggerà o invierà dati.\n- **Single Sign-on Authentication** (SSO) - Ciò si verifica quando un utente accede a un'applicazione e viene quindi automaticamente collegato ad altre applicazioni senza dover effettuare nuovamente l'autenticazione. Ad esempio, quando accedi a Google, quando utilizzi ad altri servizi Google come YouTube, Google Documenti e Gmail, non dovrai svolgere nuovamente il login.\n- **SQL Injection** (SQLi) – Una tecnica di injection utilizzata per attaccare applicazioni basate su dati, in cui istruzioni SQL dannose vengono inserite in input e trattate come codice.\n- **SVG** - Scalable Vector Graphics\n- **Time-based OTP** - Un metodo per generare un OTP in cui l'ora corrente funge da parte dell'algoritmo per generare la password.\n- **Threat Modeling** - Una tecnica che consiste nello sviluppare architetture di sicurezza sempre più accurate per identificare agenti di minaccia, zone di sicurezza, controlli di sicurezza e importanti asset tecnici e aziendali.\n- **Transport Layer Security** (TLS) – Protocolli crittografici che forniscono la sicurezza della comunicazione su una connessione di rete\n- **Trusted Platform Module** (TPM) - È un tipo di HSM (Hardware Security Module) che viene solitamente integrato in un componente hardware più grande, come una scheda madre, e funge da \"root of trust\" per quel sistema.\n- **Two-factor authentication** (2FA) - Aggiunge un secondo livello di verifica per l'accesso ad un account.\n- **Universal 2nd Factor** (U2F) - Uno degli standard creati da FIDO (Fast Identity Online) specificamente per consentire l'utilizzo di una chiave di sicurezza USB o NFC come secondo fattore di autenticazione.\n- **URI/URL/URL fragments** – Un Uniform Resource Identifier (URI) è una stringa di caratteri utilizzata per identificare un nome o una risorsa web. Spesso viene utilizzato un Uniform Resource Locator (URL) come riferimento a una risorsa web.\n- **Verifier** – La persona o il team che sta analizzando un'applicazione rispetto ai requisiti OWASP ASVS (Open Web Application Security Project Application Security Verification Standard).\n- **What You See Is What You Get** (WYSIWYG) - Un tipo di editor di contenuti avanzato che mostra l'aspetto effettivo del contenuto al momento della visualizzazione anziché mostrare il codice utilizzato per controllarne la resa grafica.\n- **X.509 Certificate** – Un certificato digitale che utilizza lo standard internazionale X.509 PKI (Public Key Infrastructure) ampiamente riconosciuto per verificare che una chiave pubblica appartenga all'identità di utente, computer o servizio contenuta nel certificato.\n- **XML eXternal Entity** (XXE) - Un tipo di entità XML che può accedere a contenuti locali o remoti utilizzando un identificatore di sistema. Questo può causare vari tipi di attacchi di injection.\n", "timestamp": "2025-10-24T11:39:57.763423"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x91-Appendix-B_References.md", "content": "# Appendice B: Riferimenti\n\nI seguenti progetti OWASP sono probabilmente i più utili per gli utenti/adottatori di questo standard:\n\n## Progetti principali OWASP  \n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## Progetti OWASP Cheat Sheet  \n\n[Questo progetto](https://owasp.org/www-project-cheat-sheets/) contiene una serie di cheat sheet rilevanti per diversi argomenti del ASVS.\n\nÈ disponibile una mappatura con l'ASVS che può essere trovata qui: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Progetti realitivi alla sicurezza Mobile \n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Progetti OWASP relativi all'Internet of Things  \n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Progetti OWASP relativi all'ambiente Serverless \n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Altri\n\nAnalogamente, i seguenti siti web sono probabilmente i più utili per gli utenti/adottatori di questo standard\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:39:57.897711"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/it/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/it/0x93-Appendix-C_IoT.md", "content": "# Appendice C: Requisiti di Verifica per l'Internet delle Cose (IoT)\n\nQuesto capitolo era originariamente nella sezione principale, ma con il lavoro svolto dal team OWASP IoT, non ha senso mantenere due filoni differenti sull'argomento. Per la versione 4.0, stiamo spostando questo contenuto nell'Appendice e invitiamo tutti coloro che ne hanno bisogno a consultare il [progetto OWASP IoT](https://owasp.org/www-project-internet-of-things/)\n\n## Obiettivo del controllo\n\nI dispositivi Embedded/IoT devono:\n\n* Avere lo stesso livello di controlli di sicurezza presenti nel server, applicando i controlli di sicurezza in un ambiente trusted.\n* I dati sensibili memorizzati sul dispositivo devono essere protetti in modo sicuro utilizzando meccanismi supportati dall'hardware, come secure element.\n* Tutti i dati sensibili trasmessi dal dispositivo devono utilizzare la sicurezza a livello di trasporto.\n\n## Requisiti di Verifica della Sicurezza\n\n| # | Descrizione | L1 | L2 | L3 | Da |\n| --- | --- | --- | --- | -- | -- |\n| **C.1** | Verificare che le interfacce di debug a livello di applicazione come USB, UART e altre varianti seriali siano disabilitate o protette da una password complessa. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Verificare che le chiavi crittografiche e i certificati siano unici per ogni singolo dispositivo. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Verificare che, se applicabili, i controlli di protezione della memoria come ASLR e DEP siano abilitati dal sistema operativo embedded/IoT. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Verificare che le interfacce di debug integrate come JTAG o SWD siano disabilitate o che il meccanismo di protezione disponibile sia abilitato e configurato adeguatamente. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Verificare che se disponibile, la trusted execution sia implementata e abilitata sul SoC o CPU del dispositivo. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Verificare che i dati sensibili, le chiavi private e i certificati siano memorizzati in modo sicuro in un Secure Element, TPM, TEE (Trusted Execution Environment), o protetti mediante crittografia robusta. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Verificare che le app del firmware proteggano i dati in transito utilizzando la sicurezza a livello di trasporto. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Verificare che le app del firmware convalidino la firma digitale delle connessioni server. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Verificare che le comunicazioni wireless siano autenticate reciprocamente. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Verificare che le comunicazioni wireless siano inviate su un canale criptato. | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Verificare che qualsiasi utilizzo di funzioni C vietate sia sostituito con le versioni equivalenti sicure. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Verificare che ogni firmware mantenga un catalogo delle terze parti (software bill of materials), con versioni e vulnerabilità pubblicate. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Verificare che tutto il codice, inclusi i binari di terze parti, le librerie e i framework, sia esaminato per le credenziali hardcoded (backdoor). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Verificare che i componenti applicativi e firmware non siano suscettibili a OS Command Injection tramite l'invocazione di wrapper di comandi shell, script, o che i controlli di sicurezza impediscano l'OS Command Injection. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Verificare che le app del firmware associno la firma digitale ai server trusted. | | ✓ | ✓ | 4.0 |\n| **C.16** | Verificare la presenza di funzionalità di resistenza e/o rilevamento di manomissioni. | | ✓ | ✓ | 4.0 |\n| **C.17** | Verificare che le tecnologie di protezione della proprietà intellettuale fornite dal produttore del chip siano abilitate. | | ✓ | ✓ | 4.0 |\n| **C.18** | Verificare che siano presenti controlli di sicurezza per ostacolare il reverse engineering del firmware (ad esempio, rimozione di simboli di debug). | | ✓ | ✓ | 4.0 |\n| **C.19** | Verificare che il dispositivo convalidi la firma dell'immagine di boot prima di caricarla. | | ✓ | ✓ | 4.0 |\n| **C.20** | Verificare che il processo di aggiornamento del firmware non sia vulnerabile agli attacchi di time-of-check vs time-of-use. | | ✓ | ✓ | 4.0 |\n| **C.21** | Verificare che il dispositivo utilizzi la firma del codice e convalidi i file di aggiornamento del firmware prima dell'installazione. | | ✓ | ✓ | 4.0 |\n| **C.22** | Verificare che sul dispositivo non possano essere installate versioni precedenti (anti-rollback) del firmware. | | ✓ | ✓ | 4.0 |\n| **C.23** | Verificare l'uso di un generatore di numeri pseudo-casuali crittograficamente sicuro sul dispositivo embedded (ad esempio, utilizzando generatori di numeri casuali forniti dal chip). | | ✓ | ✓ | 4.0 |\n| **C.24** | Verificare che il firmware possa eseguire aggiornamenti automatici secondo una pianificazione predefinita. | | ✓ | ✓ | 4.0 |\n| **C.25** | Verificare che il dispositivo cancelli il firmware e i dati sensibili in caso di rilevamento di manomissioni o ricezione di messaggi non validi. | | | ✓ | 4.0 |\n| **C.26** | Verificare che vengano utilizzati solo microcontrollori che supportano la disabilitazione delle interfacce di debug (ad esempio, JTAG, SWD). | | | ✓ | 4.0 |\n| **C.27** | Verificare che vengano utilizzati solo microcontrollori che forniscono una protezione efficace contro gli attacchi di decapping e side channel. | | | ✓ | 4.0 |\n| **C.28** | Verificare che le piste sensibili non siano esposte verso gli strati esterni del circuito stampato. | | | ✓ | 4.0 |\n| **C.29** | Verificare che la comunicazione inter-chip sia criptata (ad esempio, comunicazione tra la scheda principale e la scheda figlia). | | | ✓ | 4.0 |\n| **C.30** | Verificare che il dispositivo utilizzi la firma del codice e convalidi il codice prima dell'esecuzione. | | | ✓ | 4.0 |\n| **C.31** | Verificare che le informazioni sensibili mantenute in memoria vengano sovrascritte con zeri non appena non sono più necessarie. | | | ✓ | 4.0 |\n| **C.32** | Verificare Verifica che le app del firmware utilizzino container a livello kernel per l'isolamento tra le app. | | | ✓ | 4.0 |\n| **C.33** | Verificare che per le build del firmware siano configurate le flag di compilazione sicura come -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap. | | | ✓ | 4.0 |\n| **C.34** | Verificare che i microcontrollori siano configurati con la protezione del codice (se applicabile). | | | ✓ | 4.0 |\n\n## Riferimenti\n\nPer approfondimenti, consultare:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:39:58.000306"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/presentations/README.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/presentations/README.md", "content": "Index of presentations in this folder:\n- **NullCon 2019 ASVS 4.0 Release.pptx** - Original 4.0 release presentation prepared by Andrew van der Stock for Nullcon 2019\n- **AppSec DC 2019 ASVS 4.0 Final.pptx** - Slides for training prepared and delivered by Andrew van der Stock for Global AppSec DC 2019.\n- **OWASP Helsinki Sep 2019 ASVS 4.0.pptx** - Based on Andrew's 4.0 release presentation but modified and extended by Josh Grossman for ~60min presentation at OWASP Helsinki chapter meeting.\n- **OWASP Israel Nov 2019 ASVS 4.0.pptx** - Based on Andrew's 4.0 release presentation but structually modified by Josh Grossman for ~30min presentation at OWASP Israel chapter meeting.\n- **MyDevSecOps Jan 2020 Webinar - ASVS.pptx** - Slightly expanded version of the \"OWASP Israel Nov 2019\" version which runs for ~45mins.\n- **ASVS 5.0 – The rise of the Security Verification Standard** Update on the ASVS including initiatives related to using ASVS for application security verification and the principles for 5.0.", "timestamp": "2025-10-24T11:39:58.338694"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x01-Frontispiece.md", "content": "# Frontispício\n\n## Sobre o Padrão\n\nO Application Security Verification Standard é uma lista de requisitos ou testes de segurança de aplicações que podem ser usados por arquitetos, desenvolvedores, testadores, profissionais de segurança, fornecedores de ferramentas e consumidores para definir, construir, testar e verificar aplicações seguros.\n\n## Direitos autorais e licença\n\nVersão 4.0.3, outubro de 2021\n\n![licença](../images/license.png)\n\nCopyright © 2008–2021 The OWASP Foundation. Este documento é lançado sob a [licença Creative Commons Attribution ShareAlike 3.0](https://creativecommons.org/licenses/by-sa/3.0/). Para qualquer reutilização ou distribuição, deixe claro para outras pessoas os termos da licença deste trabalho.\n\n## Líderes de projeto\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## Principais colaboradores\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## Outros colaboradores e revisores\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\nSe um crédito faltar na lista de créditos 4.0.3 acima, crie um ticket no GitHub para ser reconhecido em futuras atualizações.\n\nO Application Security Verification Standard é construído com base no trabalho dos envolvidos desde o ASVS 1.0 em 2008 até o 3.0 em 2016. Grande parte da estrutura e itens de verificação que ainda estão no ASVS hoje foram originalmente escritos por Mike Boberski, Jeff Williams e Dave Wichers, mas há muitos mais contribuidores. Obrigado a todos os envolvidos. Para obter uma lista abrangente de todos aqueles que contribuíram para versões anteriores, consulte as versões anteriores.\n", "timestamp": "2025-10-24T11:39:58.712125"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x02-Preface.md", "content": "# Prefácio\n\nBem-vindo ao Application Security Verification Standard (ASVS) versão 4.0. O ASVS é um esforço orientado pela comunidade para estabelecer uma estrutura de requisitos e controles de segurança que se concentram na definição dos controles de segurança funcionais e não funcionais necessários ao projetar, desenvolver e testar aplicações e serviços da web modernos.\n\nA versão 4.0.3 é o terceiro minor patch para a v4.0 destinado a corrigir erros ortográficos e tornar os requisitos mais claros sem fazer alterações significativas, como alterar substancialmente, fortalecer ou adicionar requisitos. No entanto, alguns destes podem ter sido ligeiramente enfraquecidos onde consideramos apropriado e alguns requisitos totalmente redundantes foram removidos (mas sem renumeração).\n\nO ASVS v4.0 é o culminar do esforço da comunidade e do feedback da indústria na última década. Tentamos facilitar a adoção do ASVS para uma variedade de casos de uso diferentes em qualquer ciclo de vida de desenvolvimento de software seguro.\n\nEsperamos que provavelmente nunca haverá 100% de concordância sobre o conteúdo de qualquer padrão de aplicação da web, incluindo o ASVS. A análise de risco é sempre subjetiva até certo ponto, criando um desafio ao tentar generalizar num padrão único. No entanto, esperamos que as atualizações mais recentes feitas nesta versão sejam um passo na direção certa e aprimorem os conceitos introduzidos neste padrão crítico do setor.\n\n## O que há de novo no 4.0\n\nA mudança mais significativa nesta versão é a adoção da NIST 800-63-3 Digital Identity Guidelines, introduzindo controles de autenticação modernos e avançados, baseados em evidências. Embora esperemos algum retrocesso no alinhamento com um padrão de autenticação avançada, sentimos ser essencial que os padrões sejam alinhados, principalmente quando outro padrão de segurança de aplicações bem-conceituado é baseado em evidências.\n\nOs padrões de segurança da informação devem tentar minimizar o número de requisitos exclusivos, para que as organizações em conformidade não tenham que decidir sobre controles concorrentes ou incompatíveis. O OWASP Top 10 2017 e agora o OWASP Application Security Verification Standard agora estão alinhados com o NIST 800-63 para autenticação e gestão de sessão. Incentivamos outros órgãos de definição de padrões a trabalhar conosco, NIST e outros para chegar a um conjunto geralmente aceito de controles de segurança de aplicações para maximizar a segurança e minimizar os custos de conformidade.\n\nO ASVS 4.0 foi totalmente renumerado do início ao fim. O novo esquema de numeração permitiu-nos fechar lacunas de capítulos há muito desaparecidos e segmentar capítulos mais longos para minimizar o número de controles que um desenvolvedor ou equipe precisa cumprir. Por exemplo, se uma aplicação não usa JWT, toda a seção sobre JWT na gestão de sessão não é aplicável.\n\nA novidade no 4.0 é um mapeamento abrangente para a Common Weakness Enumeration (CWE), uma das solicitações de recursos mais comumente desejadas que recebemos na última década. O mapeamento CWE permite que os fabricantes de ferramentas e aqueles que usam software de gestão de vulnerabilidade comparem os resultados de outras ferramentas e versões anteriores do ASVS para 4.0 e posteriores. Para abrir espaço para a input CWE, tivemos que retirar a coluna \"Desde\" que, como renumeramos completamente, faz menos sentido do que nas versões anteriores do ASVS. Nem todo item no ASVS tnum CWE associado e, como o CWE tem muita duplicação, tentamos usar o mais comumente usado em vez da correspondência mais próxima. Os controles de verificação nem sempre são mapeáveis para pontos fracos equivalentes.\n\nTrabalhamos para atender e exceder de forma abrangente os requisitos para abordar o OWASP Top 10 2017 e o OWASP Proactive Controls 2018. Como o OWASP Top 10 2017 é o mínimo necessário para evitar negligência, fizemos deliberadamente todos, exceto os 10 principais requisitos de registro específicos. 1, facilitando para os adotantes do OWASP Top 10 avançarem para um padrão de segurança real.\n\nDecidimos garantir que o ASVS 4.0 Nível 1 seja um superconjunto abrangente das Seções 6.5 do PCI DSS 3.2.1, para design de aplicações, codificação, teste, revisões de código seguro e testes de penetração. Isso exigia cobrir buffer overflow e operações de memória inseguras na V5, e sinalizadores de compilação relacionados à memória inseguras na V14, além dos requisitos existentes de verificação de serviços da Web e aplicações líderes do setor.\n\nConcluímos a mudança do ASVS de controles monolíticos apenas do lado do servidor para fornecer controles de segurança para todas as aplicações e APIs modernos. Nos dias de programação funcional, API serverless, dispositivos móveis, nuvem, contêineres, CI/CD e DevSecOps, federação e muito mais, não podemos continuar ignorando a arquitetura moderna de aplicações. As aplicações modernas são projetados de maneira muito diferente daqueles criados quando o ASVS original foi lançado em 2009. O ASVS deve sempre olhar para o futuro para fornecer bons conselhos para nosso público principal - os desenvolvedores. Esclarecemos ou eliminamos qualquer requisito que suponha que as aplicações sejam executados em sistemas pertencentes a uma única organização.\n\nDevido ao tamanho do ASVS 4.0, bem como ao nosso desejo de se torná-lo a linha de base para todos os outros esforços do mesmo, retiramos o capítulo sobre mobile, em favor do Mobile Application Security Verification Standard (MASVS). O apêndice Internet of Things aparecerá num futuro cuidado IoT ASVS do OWASP Internet of Things Project. Incluímos uma prévia do IoT ASVS no Apêndice C. Agradecemos tanto à equipe OWASP Mobile quanto à equipe do projeto OWASP IoT pelo suporte ao ASVS e esperamos trabalhar com eles no futuro para fornecer padrões complementares.\n\nPor fim, desduplicamos e removemos os controles menos impactantes. Com o tempo, o ASVS passou a ser um conjunto abrangente de controles, mas nem todos os controles são iguais na produção de software seguro. Esse esforço para eliminar itens de baixo impacto poderia ir além. Em uma edição futura do ASVS, o Common Weakness Scoring System (CWSS) ajudará a priorizar ainda mais os controles que são realmente importantes e aqueles que devem ser retirados.\n\nA partir da versão 4.0, o ASVS se concentrará exclusivamente em ser o padrão líder de aplicações e serviços da Web, abrangendo arquitetura de aplicações tradicionais e modernos, práticas de segurança ágeis e cultura DevSecOps.\n", "timestamp": "2025-10-24T11:39:58.781055"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x03-Using-ASVS.md", "content": "# Usando o ASVS\n\nA ASVS tem dois objetivos principais:\n\n* ajudar as organizações a desenvolver e manter aplicações seguros.\n* permitir que fornecedores de serviços de segurança, fornecedores de ferramentas de segurança e consumidores alinhem seus requisitos e ofertas.\n\n## Níveis do Application Security Verification\n\nO Application Security Verification Standard define três níveis de verificação de segurança, com cada nível aumentando em profundidade.\n\n* O nível 1 do ASVS é para níveis de garantia baixos e é completamente testável quanto à penetração\n* ASVS Nível 2 é para aplicações que contêm dados confidenciais, que requerem proteção e é o nível recomendado para a maioria das aplicações\n* O nível 3 do ASVS é para as aplicações mais críticos - aplicações que executam transações de alto valor, contêm dados médicos confidenciais ou qualquer aplicação que exija o mais alto nível de confiança.\n\nCada nível ASVS contém uma lista de requisitos de segurança. Cada um desses requisitos também pode ser mapeado para recursos e capacidades específicos de segurança que devem ser incorporados ao software pelos desenvolvedores.\n\n![Níveis ASVS](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"Níveis ASVS\")\n\nFigura 1 - Níveis 4.0 do Padrão de Application Security Verification OWASP\n\nO nível 1 é o único nível que é completamente testável por penetração usando humanos. Todos os outros requerem acesso à documentação, código-fonte, configuração e pessoas envolvidas no processo de desenvolvimento. No entanto, mesmo que L1 permita a ocorrência de testes de \"black box\" (sem documentação e sem fonte), não é uma atividade de garantia eficaz e deve ser ativamente desencorajada. Os atacantes mal-intencionados têm muito tempo, a maioria dos testes de penetração termina em algumas semanas. Os defensores precisam incorporar controles de segurança, proteger, encontrar e resolver todos os pontos fracos, detectar e responder a agentes mal-intencionados num tempo razoável. Atores mal-intencionados têm tempo essencialmente infinito e requerem apenas uma única defesa porosa, uma única fraqueza ou detecção ausente para serem bem-sucedidos. O teste black box, muitas vezes realizado no final do desenvolvimento, rapidamente, ou não, são completamente incapazes de lidar com essa assimetria.\n\nAo longo dos últimos 30 anos, os testes black box provaram repetidas vezes perder problemas críticos de segurança que levaram diretamente a violações cada vez mais massivas. Incentivamos fortemente o uso de uma ampla gama de garantia e verificação de segurança, incluindo a substituição de testes de penetração por testes de penetração conduzidos por código-fonte (híbridos) no Nível 1, com acesso total aos desenvolvedores e à documentação durante todo o processo de desenvolvimento. Os reguladores financeiros não toleram auditorias financeiras externas sem acesso aos livros contábeis, amostras de transações ou pessoas que executam os controles. A indústria e os governos devem exigir o mesmo padrão de transparência no campo da engenharia de software.\n\nIncentivamos fortemente o uso de ferramentas de segurança no próprio processo de desenvolvimento. As ferramentas DAST e SAST podem ser usadas continuamente pelo pipeline de construção para facilitar a localização de problemas de segurança que nunca deveriam estar presentes.\n\nFerramentas automatizadas e varreduras online não conseguem concluir mais da metade do ASVS sem assistência humana. Se for necessária uma automação de teste abrangente para cada compilação, será usada uma combinação de testes personalizados de unidade e integração, com varreduras online iniciadas por compilação. Falhas de lógica de negócios e testes de controle de acesso só são possíveis com assistência humana. Estes devem ser transformados em testes de unidade e integração.\n\n## Como usar este padrão\n\nUma das melhores maneiras de usar o Application Security Verification Standard é usá-lo como um modelo para criar uma Lista de Verificação de Codificação Segura específica para sua aplicação, plataforma ou organização. Adaptar o ASVS aos seus casos de uso aumentará o foco nos requisitos de segurança mais importantes para seus projetos e ambientes.\n\n### Nível 1 - Primeiras etapas, automatizada ou visão completa do portfólio\n\nUma aplicação atinge o nível 1 do ASVS se se defender adequadamente contra vulnerabilidades de segurança de aplicações que são fáceis de descobrir e incluídas no OWASP Top 10 e outras listas de verificação semelhantes.\n\nO nível 1 é o mínimo que todas as aplicações devem buscar. Também é útil como uma primeira etapa num esforço multifásico ou quando as aplicações não armazenam ou manipulam dados confidenciais e, assim, não precisam de controles mais rigorosos de nível 2 ou 3. Os controles de nível 1 podem ser verificados automaticamente por ferramentas ou simplesmente manualmente, sem acesso ao código-fonte. Consideramos o Nível 1 o mínimo exigido para todas as aplicações.\n\nAmeaças à aplicação provavelmente virão de invasores que usam técnicas simples e de baixo esforço para identificar vulnerabilidades fáceis de encontrar e explorar. Isso contrasta com um invasor determinado que gastará energia focada para atingir especificamente a aplicação. Se os dados processados pela sua aplicação tiverem alto valor, raramente irá parar numa revisão de nível 1.\n\n### Nível 2 - A maioria das aplicações\n\nUma aplicação atinge o nível 2 (ou padrão) do ASVS se se defender adequadamente contra a maioria dos riscos associados ao software atualmente.\n\nO nível 2 garante que os controles de segurança estejam em vigor, sejam eficazes e sejam usados na aplicação. O nível 2 é normalmente apropriado para aplicações que lidam com transações business-to-business significativas, incluindo aquelas que processam informações de assistência médica, implementam funções críticas, ou confidenciais de negócios, ou processam outros ativos confidenciais, ou setores onde a integridade é uma faceta crítica para proteger os seus negócios, como a indústria de jogos para impedir trapaceiros e hacks de jogos.\n\nAmeaças aas aplicações de nível 2 normalmente são invasores habilidosos e motivados com foco em alvos específicos usando ferramentas e técnicas que são altamente praticadas e eficazes na descoberta e exploração de pontos fracos nas aplicações.\n\n### Nível 3 - Alto valor, alta garantia ou alta segurança\n\nASVS Nível 3 é o mais alto nível de verificação no ASVS. Este nível é normalmente reservado para aplicações que requerem níveis significativos de verificação de segurança, como aqueles que podem ser encontrados em áreas militares, de saúde e segurança, infraestrutura crítica, etc.\n\nAs organizações podem exigir ASVS Nível 3 para aplicações que executam funções críticas, onde a falha pode afetar significativamente as operações da organização e até mesmo a sua capacidade de sobrevivência. Um exemplo de orientação sobre a aplicação do ASVS Nível 3 é fornecido abaixo. Uma aplicação atinge o Nível 3 do ASVS (ou Avançado) se defender adequadamente contra vulnerabilidades de segurança de aplicações avançados e também demonstrar princípios de um bom design de segurança.\n\nUma aplicação no nível 3 do ASVS requer uma análise mais aprofundada da arquitetura, codificação e teste do que todos os outros níveis. Uma aplicação seguro é modularizado de forma significativa (para facilitar a resiliência, escalabilidade e, primeiro, camadas de segurança), e cada módulo (separado por conexão de rede e/ou instância física) cuida das suas próprias responsabilidades de segurança (defesa em profundidade), que precisam ser devidamente documentados. As responsabilidades incluem controles para garantir a confidencialidade (por exemplo, criptografia), integridade (por exemplo, transações, validação de input), disponibilidade (por exemplo, manipulação de carga normalmente), autenticação (incluindo entre sistemas), autorização e auditoria (logging).\n\n## Aplicando ASVS na Prática\n\nAmeaças diferentes têm motivações diferentes. Alguns setores têm informações exclusivas e ativos de tecnologia e requisitos de conformidade regulamentar específicos do domínio.\n\nAs organizações são fortemente encorajadas a analisar profundamente as suas características de risco exclusivas com base na natureza dos seus negócios e, com base nesse risco e nos requisitos de negócios, determinar o nível ASVS apropriado.\n\n## Como fazer referência aos requisitos ASVS\n\nCada requisito possui um identificador no formato `<chapter>.<section>.<requirement>` onde cada elemento é um número, por exemplo: `1.11.3`.\n- O valor `<chapter>` corresponde ao capítulo de onde vem o requisito, por exemplo: todos os requisitos `1.#.#` são do capítulo `Arquitetura`.\n- O valor `<section>` corresponde à seção dentro desse capítulo onde o requisito aparece, por exemplo: todos os requisitos `1.11.#` estão na seção `Arquitetura de lógica de negócios` do capítulo `Arquitetura`.\n- O valor `<requirement>` identifica o requisito específico no capítulo e seção, por exemplo: `1.11.3` que a partir da versão 4.0.3 desta norma é:\n\n> Verifique se todos os fluxos de lógica de negócios de alto valor, incluindo autenticação, gestão de sessão e controle de acesso, são thread-safe e resistentes a condições de corrida de tempo de verificação e tempo de uso.\n\nOs identificadores podem mudar entre as versões do padrão, portanto, é preferível que outros documentos, relatórios ou ferramentas usem o formato: `v<version>-<chapter>.<section>.<requirement>`, onde: 'versão' é a tag de versão ASVS. Por exemplo: `v4.0.3-1.11.3` seria entendido como significando especificamente o 3.º requisito na seção 'Arquitetura de lógica de negócios' do capítulo 'Arquitetura' da versão 4.0.3. (Isto pode ser resumido como `v<version>-<requirement_identifier>`.)\n\nNota: O `v` que precede a parte da versão deve ser minúsculo.\n\nSe os identificadores forem usados sem incluir o elemento `v<version>`, eles devem ser assumidos para se referir ao conteúdo mais recente do Application Security Verification Standard. Obviamente, à medida que o padrão cresce e muda, isso se torna problemático, e é por isso que escritores ou desenvolvedores devem incluir o elemento de versão.\n\nAs listas de requisitos ASVS são disponibilizadas em CSV, JSON e outros formatos que podem ser úteis para referência ou uso programático.", "timestamp": "2025-10-24T11:39:58.851416"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x04-Assessment_and_Certification.md", "content": "# Avaliação e Certificação\n\n## Postura da OWASP em certificações ASVS e marcas de confiança\n\nA OWASP, como uma organização sem fins lucrativos neutra no âmbito de fornecedores, atualmente não certifica nenhum fornecedor, verificador ou software.\n\nTodas essas afirmações de garantia, marcas de confiança ou certificações não são oficialmente examinadas, registradas ou certificadas pela OWASP, portanto, uma organização que confia em tal visão precisa ser cautelosa com a confiança depositada em qualquer terceiro ou marca de confiança que reivindique a certificação ASVS.\n\nIsso não deve inibir as organizações de oferecer tais serviços de garantia, desde que não reivindiquem a certificação OWASP oficial.\n\n## Orientação para organizações certificadoras\n\nO Application Security Verification Standard pode ser usado como uma verificação de livro aberto da aplicação, incluindo acesso aberto e irrestrito a recursos-chave, como arquitetos e desenvolvedores, documentação do projeto, código-fonte, acesso autenticado a sistemas de teste (incluindo acesso a uma ou mais contas em cada função), especialmente para verificações L2 e L3.\n\nHistoricamente, os testes de penetração e as revisões de código seguro incluíram problemas “por exceção”, ou seja, apenas os testes com falha aparecem no relatório final. Uma organização certificadora deve incluir em qualquer relatório o escopo da verificação (especialmente se um componente-chave estiver fora do escopo, como a autenticação SSO), um resumo das descobertas da verificação, incluindo testes aprovados e reprovados, com indicações claras de como resolver o problema testes falhados.\n\nCertos requisitos de verificação podem não ser aplicáveis à aplicação em teste. Por exemplo, se você fornecer uma API de camada de serviço sem estado snuma implementação de cliente para seus clientes, muitos dos requisitos do V3 Session Management não serão diretamente aplicáveis. Nesses casos, uma organização certificadora ainda pode reivindicar conformidade total com a ASVS, mas deve indicar em qualquer relatório um motivo para a não aplicabilidade de tais requisitos de verificação excluídos.\n\nManter papéis de trabalho detalhados, capturas de tela ou filmes, scripts para explorar um problema de maneira confiável e repetida e registros eletrônicos de teste, como interceptar logs de proxy e notas associadas, como uma lista de limpeza, é considerado uma prática padrão da indústria e pode ser realmente útil como prova das descobertas para os desenvolvedores mais duvidosos. Não basta simplesmente rodar uma ferramenta e reportar as falhas; isso não fornece (de forma alguma) evidência suficiente de que todos os problemas num nível de certificação foram testados e testados exaustivamente. Em caso de disputa, deve haver evidência de garantia suficiente para demonstrar que cada requisito verificado foi de fato testado.\n\n### Método de teste\n\nAs organizações certificadoras são livres para escolher o(s) método(s) de ensaio apropriado(s), mas devem indicá-los num relatório.\n\nDependendo da aplicação em teste e do requisito de verificação, diferentes métodos de teste podem ser usados para obter a mesma confiança nos resultados. Por exemplo, validar a eficácia dos mecanismos de verificação de input de uma aplicação pode ser analisado com um teste de penetração manual ou por análises de código-fonte.\n\n#### O papel das ferramentas automatizadas de teste de segurança\n\nO uso de ferramentas automatizadas de teste de penetração é incentivado para fornecer o máximo de cobertura possível.\n\nNão é possível concluir totalmente a verificação ASVS usando apenas ferramentas automatizadas de teste de penetração. Embora a grande maioria dos requisitos em L1 possa ser realizada usando testes automatizados, a maioria geral dos requisitos não é passível de testes de penetração automatizados.\n\nObserve que as linhas entre testes automatizados e manuais tornaram-se indistintas à medida que o setor de segurança de aplicações amadureceu. As ferramentas automatizadas são geralmente ajustadas manualmente por especialistas e os testadores manuais geralmente utilizam uma ampla variedade de ferramentas automatizadas.\n\n#### O papel do teste de penetração\n\nNa versão 4.0, decidimos tornar o L1 completamente testável sem acesso ao código-fonte, documentação ou desenvolvedores. Dois itens de registro, necessários para cumprir o OWASP Top 10 2017 A10, exigirão entrevistas, capturas de tela ou outra coleta de evidências, assim como no OWASP Top 10 2017. No entanto, testar sem acesso às informações necessárias não é um método ideal de verificação de segurança, pois perde a possibilidade de revisar a fonte, identificar ameaças e controles ausentes e realizar um teste muito mais completo num período menor.\n\nSempre que possível, é necessário acesso a desenvolvedores, documentação, código e acesso a uma aplicação de teste com dados que não sejam de produção ao realizar uma avaliação L2 ou L3. Os testes de penetração feitos nesses níveis requerem esse nível de acesso, que chamamos \"revisões híbridas\" ou \"testes de penetração híbridos\".\n\n## Outros usos para o ASVS\n\nAlém de ser usado para avaliar a segurança de uma aplicação, identificamos vários outros usos potenciais para o ASVS.\n\n### Conforme orientação detalhada da arquitetura de segurança\n\nUm dos usos mais comuns do Application Security Verification Standard é como um recurso para arquitetos de segurança. A Sherwood Applied Business Security Architecture (SABSA) carece de uma grande quantidade de informações necessárias para concluir uma revisão completa da arquitetura de segurança da aplicação. O ASVS pode ser usado para preencher essas lacunas, permitindo que os arquitetos de segurança escolham melhores controles para problemas comuns, como padrões de proteção de dados e estratégias de validação de input.\n\n### Como um substituto para listas de verificação de codificação segura prontas para uso\n\nMuitas organizações podem se beneficiar da adoção do ASVS, escolhendo um dos três níveis ou bifurcando o ASVS e alterando o que é necessário para cada nível de risco de aplicação de uma maneira específica de domínio. Incentivamos esse tipo de bifurcação, desde que a rastreabilidade seja mantida, de modo que, se uma aplicação passou no requisito 4.1, isso significa o mesmo para cópias bifurcadas e para o padrão à medida que ele evolui.\n\n### Como um guia para testes automatizados de unidade e integração\n\nO ASVS foi projetado para ser altamente testável, com a única exceção dos requisitos de arquitetura e código malicioso. Ao criar testes de unidade e integração que testam casos de fuzz e abuso específicos e relevantes, a aplicação torna-se quase autoverificável a cada compilação. Por exemplo, testes adicionais podem ser criados para o conjunto de testes para um controlador de login, testando o parâmetro username para nomes de usuários padrões comuns, enumeração de contas, força bruta, injeção de LDAP e SQL e XSS. Da mesma forma, um teste no parâmetro de senha deve incluir senhas comuns, tamanho da senha, injeção de byte nulo, remoção do parâmetro, XSS e muito mais.\n\n### Para treinamento de desenvolvimento seguro\n\nASVS também pode ser usado para definir características de software seguro. Muitos cursos de “codificação segura” são simplesmente cursos de hacking ético com uma leve mancha de dicas de codificação. Isso pode não necessariamente ajudar os desenvolvedores a escrever um código mais seguro. Em vez disso, os cursos de desenvolvimento seguro podem usar o ASVS com um forte foco nos controles proativos encontrados no ASVS, em vez das 10 principais coisas negativas a não fazer.\n\n### Como um driver para segurança de aplicações ágeis\n\nO ASVS pode ser usado num processo de desenvolvimento ágil como um framework para definir tarefas específicas que precisam ser implementadas pela equipe para ter um produto seguro. Uma abordagem pode ser: começando com o Nível 1, verifique a aplicação ou sistema específico conforme os requisitos ASVS para o nível especificado, encontre quais controles estão faltando e crie tickets/tarefas específicos no backlog. Isso ajuda na priorização de tarefas específicas (ou preparação) e torna a segurança visível no processo ágil. Isso também pode ser usado para priorizar tarefas de auditoria e revisão na organização, onde um requisito específico do ASVS pode ser um driver para revisão, refatoração ou auditoria para um membro específico da equipe e visível como \"dívida\" no backlog que precisa ser feito eventualmente.\n\n### Como uma estrutura para orientar a aquisição de software seguro\n\nO ASVS é uma ótima estrutura para ajudar na aquisição segura de software ou na aquisição de serviços de desenvolvimento personalizados. O comprador pode simplesmente definir um requisito de que o software que deseja adquirir deve ser desenvolvido no nível X da ASVS e solicitar que o vendedor comprove que o software atende ao nível X da ASVS. Isso funciona bem quando combinado com o Anexo do Contrato de Software Seguro OWASP.\n", "timestamp": "2025-10-24T11:39:58.907766"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x10-V1-Architecture.md", "content": "# V1 Arquitetura, Design e Modelagem de Ameaças\n\n## Objetivo de controle\n\nA arquitetura de segurança quase se tornou uma arte perdida em muitas organizações. Os dias do arquiteto corporativo já passaram na era do DevSecOps. O campo de segurança de aplicações deve acompanhar e adotar princípios de segurança ágeis enquanto reintroduz os principais princípios de arquitetura de segurança para profissionais de software. A arquitetura não é uma implementação, mas uma maneira de pensar sobre um problema que tem potencialmente muitas respostas diferentes e nenhuma resposta \"correta\". Com muita frequência, a segurança é vista como inflexível e exigindo que os desenvolvedores corrijam o código de uma maneira específica, quando os desenvolvedores podem conhecer uma maneira muito melhor de resolver o problema. Não existe uma solução única e simples para a arquitetura, e fingir o contrário é um desserviço ao campo da engenharia de software.\n\nÉ provável que uma implementação específica de uma aplicação da Web seja revisada continuamente ao longo da sua vida útil. A arquitetura geral raramente mudará, mas evoluirá lentamente. A arquitetura de segurança é idêntica - precisamos de autenticação hoje, exigiremos autenticação amanhã e precisaremos dela daqui a cinco anos. Se tomarmos decisões sensatas hoje, podemos economizar muito esforço, tempo e dinheiro se selecionarmos e reutilizarmos soluções compatíveis com a arquitetura. Por exemplo, uma década atrás, a autenticação multifator era raramente implementada.\n\nSe os desenvolvedores tivessem investido num modelo único e seguro de provedor de identidade, como a identidade federada SAML, o provedor de identidade poderia ser atualizado para incorporar novos requisitos, como conformidade com NIST 800-63, sem alterar as interfaces da aplicação original. Se muitas aplicações compartilharem a mesma arquitetura de segurança e, assim, o mesmo componente, todos se beneficiarão dessa atualização de uma só vez. No entanto, o SAML nem sempre permanecerá como a melhor ou mais adequada solução de autenticação - pode ser necessário trocá-lo por outras soluções à medida que os requisitos mudam. Mudanças como essa são complicadas, tão caras que exigem uma reescrita completa ou totalmente impossíveis sem arquitetura de segurança.\n\nNeste capítulo, o ASVS cobre os aspectos primários de qualquer arquitetura de segurança sólida: disponibilidade, confidencialidade, integridade de processamento, não repúdio e privacidade. Cada um desses princípios de segurança deve ser integrado e inato a todos os aplicativos. É fundamental \"mudar para a esquerda\", começando com a capacitação do desenvolvedor com listas de verificação de codificação segura, orientação e treinamento, codificação e teste, construção, implantação, configuração e operações e terminando com testes independentes de acompanhamento para garantir que todos os controles de segurança estão presentes e funcionais. A última etapa costumava ser tudo o que fazíamos como indústria, mas isso não é mais suficiente quando os desenvolvedores colocam o código em produção dezenas ou centenas de vezes por dia. Os profissionais de segurança de aplicativos devem acompanhar as técnicas ágeis, o que significa adotar ferramentas de desenvolvedor, aprender a codificar e trabalhar com desenvolvedores, em vez de criticar o projeto meses depois que todos os outros já partiram.\n\n## V1.1 Ciclo de vida de desenvolvimento de software seguro\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.1.1** | Verifique o uso de um ciclo de vida de desenvolvimento de software seguro que aborde a segurança em todos os estágios de desenvolvimento. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Verifique o uso da modelagem de ameaças para cada alteração de design ou planejamento de sprint para identificar ameaças, planejar contramedidas, facilitar respostas apropriadas a riscos e orientar testes de segurança. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Verifique se todas as histórias e recursos do usuário contêm restrições de segurança funcionais, como \"Como usuário, devo poder visualizar e editar meu perfil. Não devo visualizar ou editar o perfil de outra pessoa\" | | ✓ | ✓ | 1110 |\n| **1.1.4** | Verifique a documentação e justificativa de todos os limites de confiança, componentes e fluxos de dados significativos da aplicação. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Verifique a definição e a análise de segurança da arquitetura de alto nível da aplicação e de todos os serviços remotos conectados. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Verifique a implementação de controles de segurança centralizados, simples (economia de design), verificados, seguros e reutilizáveis para evitar controles duplicados, ausentes, ineficazes ou inseguros. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Verifique a disponibilidade de uma lista de verificação de codificação segura, requisitos de segurança, diretriz ou política para todos os desenvolvedores e testadores. | | ✓ | ✓ | 637 |\n\n## V1.2 Arquitetura de autenticação\n\nAo projetar a autenticação, não importa se você tem autenticação multifator habilitada para hardware forte se um invasor puder redefinir uma conta ligando para um call center e respondendo a perguntas comumente conhecidas. Ao provar a identidade, todos os caminhos de autenticação devem ter a mesma força.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.2.1** | Verifique o uso de contas exclusivas ou especiais de sistema operacional de baixo privilégio para todos os componentes de aplicações, serviços e servidores. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Verifique se as comunicações entre os componentes da aplicação, incluindo APIs, middleware e camadas de dados, são autenticadas. Os componentes devem ter os privilégios mínimos necessários. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Verifique se a aplicação usa um único mecanismo de autenticação verificado que é conhecido por ser seguro, pode ser estendido para incluir autenticação forte e tem registro e monitoramento suficientes para detectar abuso ou violações de conta. | | ✓ | ✓ | 306 |\n| **1.2.4** | Verifique se todos os caminhos de autenticação e APIs de gestão de identidade implementam força de controle de segurança de autenticação consistente, de modo que não haja alternativas mais fracas pelo risco da aplicação. | | ✓ | ✓ | 306 |\n\n## V1.3 Arquitetura de gestão de sessão\n\nEste é um espaço reservado para futuros requisitos de arquitetura.\n\n## V1.4 Arquitetura de controle de acesso\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.4.1** | Verifique se os pontos de imposição confiáveis, como gateways de controle de acesso, servidores e funções serverless, reforçam os controles de acesso. Nunca imponha controles de acesso no cliente. | | ✓ | ✓ | 602 |\n| **1.4.2** | [EXCLUÍDO, NÃO ACIONÁVEL] | | | | |\n| **1.4.3** | [EXCLUÍDO, DUPLICADO DE 4.1.3] | | | | |\n| **1.4.4** | Verifique se a aplicação usa um mecanismo de controle de acesso único e bem testado para acessar dados e recursos protegidos. Todas as solicitações devem passar por esse mecanismo único para evitar copiar e colar ou caminhos alternativos inseguros. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Verifique se o controle de acesso baseado em atributo ou recurso é usado pelo qual o código verifica a autorização do usuário para um item de recurso/dado em vez de apenas sua função. As permissões ainda devem ser alocadas usando funções. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Arquitetura de input e output\n\nNa versão 4.0, deixamos de usar o termo \"lado do servidor\" como um termo de limite de confiança carregado. O limite de confiança ainda é preocupante - é possível ignorar a tomada de decisões em navegadores ou dispositivos clientes não confiáveis. No entanto, nas implantações arquitetônicas convencionais de hoje, o ponto de imposição de confiança mudou drasticamente. Portanto, onde o termo \"camada de serviço confiável\" é usado no ASVS, queremos dizer qualquer ponto de aplicação confiável, independentemente da localização, como um microsserviço, API serverless, lado do servidor, uma API confiável num dispositivo cliente com inicialização segura, parceiro ou APIs externas e assim por diante.\n\nO termo \"cliente não confiável\" aqui refere-se a tecnologias do lado do cliente que renderizam a camada de apresentação, geralmente chamadas tecnologias de 'front-end'. O termo \"serialização\" aqui não se refere apenas ao envio de dados pela rede como uma matriz de valores ou à obtenção e leitura de uma estrutura JSON, mas também à passagem de objetos complexos que podem conter lógica.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.5.1** | Verifique se os requisitos de input e output definem claramente como lidar e processar dados com base no tipo, conteúdo e leis aplicáveis, regulamentos e outras conformidades com políticas. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Verifique se a serialização não é usada ao se comunicar com clientes não confiáveis. Se isso não for possível, certifique-se de que os controles de integridade adequados (e possivelmente a criptografia se dados confidenciais forem enviados) sejam aplicados para evitar ataques de desserialização, incluindo injeção de objeto. | | ✓ | ✓ | 502 |\n| **1.5.3** | Verifique se a validação de input é aplicada numa camada de serviço confiável. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Verifique se a codificação de output ocorre perto ou pelo interpretador para o qual se destina. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Arquitetura Criptográfica\n\nAplicações precisam ser projetados com arquitetura criptográfica forte para proteger os ativos de dados conforme a sua classificação. Criptografar tudo é um desperdício, não criptografar nada é legalmente negligente. Um equilíbrio deve ser alcançado, geralmente durante o projeto arquitetônico ou de alto nível, sprints de design ou picos arquitetônicos. Projetar a criptografia à medida que avança ou adaptá-la inevitavelmente custará muito mais para implementar com segurança do que simplesmente incorporá-la desde o início.\n\nOs requisitos de arquitetura são intrínsecos a toda a base de código e, assim, difíceis de unidade ou teste integrado. Os requisitos de arquitetura exigem consideração nos padrões de codificação, durante a fase de codificação, e devem ser revisados durante a arquitetura de segurança, revisões de código ou pares, ou retrospectivas.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.6.1** | Verifique se há uma política explícita para gestão de chaves criptográficas e se o ciclo de vida de uma chave criptográfica segue um padrão de gestão de chaves, como NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Verifique se os consumidores de serviços criptográficos protegem o material de chaves e outros segredos usando cofres de chaves ou alternativas baseadas em API. | | ✓ | ✓ | 320 |\n| **1.6.3** | Verifique se todas as chaves e senhas são substituíveis e fazem parte de um processo bem definido para criptografar novamente dados confidenciais. | | ✓ | ✓ | 320 |\n| **1.6.4** | Verifique se a arquitetura trata os segredos do lado do cliente, como chaves simétricas, senhas ou tokens de API, como inseguros e nunca os usa para proteger ou acessar dados confidenciais. | | ✓ | ✓ | 320 |\n\n## V1.7 Erros, registro e arquitetura de auditoria\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.7.1** | Verifique se um formato e uma abordagem de log comuns são usados em todo o sistema. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Verifique se os logs são transmitidos com segurança para um sistema preferencialmente remoto para análise, detecção, alerta e escalonamento. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Proteção de Dados e Arquitetura de Privacidade\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.8.1** | Verifique se todos os dados confidenciais são identificados e classificados em níveis de proteção. | | ✓ | ✓ | |\n| **1.8.2** | Verifique se todos os níveis de proteção têm um conjunto associado de requisitos de proteção, como requisitos de criptografia, requisitos de integridade, retenção, privacidade e outros requisitos de confidencialidade, e se eles são aplicados na arquitetura. | | ✓ | ✓ | |\n\n## V1.9 Arquitetura de Comunicações\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.9.1** | Verifique se a aplicação criptografa as comunicações entre os componentes, especialmente quando esses componentes estão em contêineres, sistemas, sites ou provedores de nuvem diferentes. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Verifique se os componentes da aplicação verificam a autenticidade de cada lado num link de comunicação para evitar ataques de pessoa no meio. Por exemplo, os componentes da aplicação devem validar cadeias e certificados TLS. | | ✓ | ✓ | 295 |\n\n## V1.10 Arquitetura de software malicioso\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.10.1** | Verifique se um sistema de controle de código-fonte está em uso, com procedimentos para garantir que os check-ins sejam acompanhados de problemas ou tickets de alteração. O sistema de controle de código-fonte deve ter controle de acesso e usuários identificáveis para permitir a rastreabilidade de quaisquer alterações. | | ✓ | ✓ | 284 |\n\n## V1.11 Arquitetura de lógica de negócios\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.11.1** | Verifique a definição e a documentação de todos os componentes da aplicação em termos de negócios ou funções de segurança que eles fornecem. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Verifique se todos os fluxos de lógica de negócios de alto valor, incluindo autenticação, gestão de sessão e controle de acesso, não compartilham estado não sincronizado. | | ✓ | ✓ | 362 |\n| **1.11.3** | Verifique se todos os fluxos de lógica de negócios de alto valor, incluindo autenticação, gestão de sessão e controle de acesso, são thread-safe e resistentes a condições de corrida de tempo de verificação e tempo de uso. | | | ✓ | 367 |\n\n## V1.12 Arquitetura segura de upload de arquivos\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.12.1** | [EXCLUÍDO, DUPLICADO DE 12.4.1] | | | | |\n| **1.12.2** | Verifique se os arquivos carregados pelo usuário - se necessário para serem exibidos ou baixados da aplicação - são servidos por downloads de fluxo de octetos ou de um domínio não relacionado, como um depósito de armazenamento de arquivos em nuvem. Implemente uma Política de Segurança de Conteúdo (CSP) adequada para reduzir o risco de vetores XSS ou outros ataques do arquivo carregado. | | ✓ | ✓ | 646 |\n\n## V1.13 Arquitetura da API\n\nEste é um espaço reservado para futuros requisitos de arquitetura.\n\n## V1.14 Arquitetura de configuração\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.14.1** | Verifique a segregação de componentes de diferentes níveis de confiança por meio de controles de segurança bem definidos, regras de firewall, gateways de API, proxies reversos, grupos de segurança baseados em nuvem ou mecanismos semelhantes. | | ✓ | ✓ | 923 |\n| **1.14.2** | Verifique se as assinaturas binárias, conexões confiáveis e endpoints verificados são usados para implantar binários em dispositivos remotos. | | ✓ | ✓ | 494 |\n| **1.14.3** | Verifique se o pipeline de construção avisa sobre componentes desatualizados ou inseguros e toma as ações apropriadas. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Verifique se o pipeline de construção contém uma etapa de construção para construir e verificar automaticamente a implantação segura da aplicação, especialmente se a infraestrutura da aplicação for definida por software, como scripts de construção do ambiente de nuvem. | | ✓ | ✓ | |\n| **1.14.5** | Verifique se as implantações de aplicações são adequadamente protegidas, conteinerizadas e/ou isoladas no nível da rede para atrasar e impedir que invasores ataquem outras aplicações, especialmente quando estiverem executando ações confidenciais ou perigosas, como desserialização. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Verifique se a aplicação não usa tecnologias não suportadas, inseguras ou obsoletas do lado do cliente, como plug-ins NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL ou miniaplicações Java do lado do cliente. | | ✓ | ✓ | 477 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:39:59.031109"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x11-V2-Authentication.md", "content": "# V2 Autenticação\n\n## Objetivo de controle\n\nAutenticação é o ato de estabelecer ou confirmar que alguém (ou algo) é autêntico e que as afirmações feitas por uma pessoa ou sobre um dispositivo são corretas, resistentes à representação e impedem a recuperação ou interceptação de senhas.\n\nQuando o ASVS foi lançado pela primeira vez, nome de usuário + senha era a forma mais comum de autenticação fora dos sistemas de alta segurança. A autenticação multifator (MFA) era comumente aceita nos círculos de segurança, mas raramente exigida em outros lugares. À medida que o número de violações de senha aumentava, a ideia de que os nomes de usuário são de alguma forma confidenciais e as senhas desconhecidas tornou muitos controles de segurança insustentáveis. Por exemplo, o NIST 800-63 considera nomes de usuário e autenticação baseada em conhecimento (KBA) como informações públicas, SMS e notificações por e-mail como [tipos de autenticadores \"restritos\"](https://pages.nist.gov/800-63-FAQ/#q-b1) e senhas como pré-violadas. Essa realidade torna os autenticadores baseados em conhecimento, a recuperação de SMS e e-mail, o histórico de senhas, a complexidade e os controles de rotação inúteis. Esses controles sempre foram menos úteis,\n\nDe todos os capítulos do ASVS, os capítulos de autenticação e gestão de sessão foram os que mais mudaram. A adoção de práticas de liderança eficazes e baseadas em evidências será um desafio para muitos, e isso é perfeitamente aceitável. Temos que começar a transição para um futuro pós-senha agora.\n\n## NIST 800-63 - Padrão de autenticação moderno e baseado em evidências\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) é um padrão moderno baseado em evidências e representa o melhor conselho disponível, independentemente da aplicabilidade. O padrão é útil para todas as organizações em todo o mundo, mas é particularmente relevante para as agências dos EUA e aquelas que lidam com agências dos EUA.\n\nA terminologia NIST 800-63 pode ser um pouco confusa no início, especialmente se estiver acostumado apenas com autenticação de nome de usuário + senha. Avanços na autenticação moderna são necessários, por isso temos que introduzir uma terminologia que se tornará comum no futuro, mas entendemos a dificuldade de compreensão até que o setor se estabeleça nesses novos termos. Fornecemos um glossário no final deste capítulo para ajudar. Reformulamos muitos requisitos para satisfazer a intenção do requisito, em vez da letra do requisito. Por exemplo, o ASVS usa o termo \"senha\" quando o NIST usa \"segredo memorizado\" neste padrão.\n\nAutenticação ASVS V2, gestão de sessão V3 e, em menor grau, controles de acesso V4 foram adaptados para ser um subconjunto compatível de controles NIST 800-63b selecionados, focados em ameaças comuns e vulnerabilidades de autenticação comumente exploradas. Quando a conformidade total com o NIST 800-63 for necessária, consulte o NIST 800-63.\n\n### Selecionando um nível NIST AAL apropriado\n\nO Application Security Verification Standard tentou mapear os requisitos ASVS L1 para NIST AAL1, L2 para AAL2 e L3 para AAL3. No entanto, a abordagem do ASVS Nível 1 como controles \"essenciais\" pode não ser necessariamente o nível AAL correto para verificar uma aplicação ou API. Por exemplo, se a aplicação for uma aplicação de Nível 3 ou tiver requisitos regulatórios para ser AAL3, o Nível 3 deve ser escolhido nos capítulos V2 e V3 Gestão de Sessões. A escolha do Nível de Asserção de Autenticação (AAL) compatível com NIST deve ser realizada conforme as diretrizes NIST 800-63b, conforme estabelecido em *Selecionar AAL* na [Seção 6.2 do NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Legenda\n\nAs aplicações sempre podem exceder os requisitos do nível atual, especialmente se a autenticação moderna estiver no roteiro de uma aplicação. Anteriormente, o ASVS exigia MFA obrigatório. O NIST não requer MFA obrigatório. Portanto, usamos uma designação opcional neste capítulo para indicar onde o ASVS incentiva, mas não requer um controle. As seguintes chaves são usadas ao longo deste padrão:\n\n| Marcar | Descrição |\n| :--: | :-- |\n| | Não é necessário |\n| o | Recomendado, mas não obrigatório |\n| ✓ | Obrigatório |\n\n## V2.1 Segurança de senha\n\nAs senhas, chamadas \"Memorized Secrets\" pelo NIST 800-63, incluem senhas, PINs, padrões de desbloqueio, escolha o gatinho correto ou outro elemento de imagem e frases secretas. Eles são geralmente considerados \"algo que você conhece\" e frequentemente usados como autenticadores de fator único. Existem desafios significativos para o uso contínuo da autenticação de fator único, incluindo bilhões de nomes de usuários e senhas válidos divulgados na Internet, senhas padrão ou fracas, tabelas arco-íris e dicionários ordenados das senhas mais comuns.\n\nAs aplicações devem incentivar fortemente os usuários a se inscreverem na autenticação multifator e devem permitir que os usuários reutilizem tokens que já possuem, como tokens FIDO ou U2F, ou se conectem a um provedor de serviços de credencial que forneça autenticação multifator.\n\nProvedores de serviços de credenciais (CSPs) fornecem identidade federada para usuários. Os usuários geralmente têm mais de uma identidade com vários CSPs, como uma identidade corporativa usando Azure AD, Okta, Ping Identity ou Google, ou identidade de consumidor usando Facebook, Twitter, Google ou WeChat, para citar apenas algumas alternativas comuns. Esta lista não é um endosso dessas empresas ou serviços, mas simplesmente um incentivo para que os desenvolvedores considerem a realidade de que muitos usuários têm muitas identidades estabelecidas. As organizações devem considerar a integração com identidades de usuário existentes, conforme o perfil de risco da força de comprovação de identidade do CSP. Por exemplo, é improvável que uma organização governamental aceite uma identidade de mídia social como um login para sistemas confidenciais, pois é fácil criar identidades falsas ou jogar fora,\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.1.1** | Verifique se as senhas definidas pelo usuário têm pelo menos 12 caracteres (após a combinação de vários espaços). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Verifique se senhas com pelo menos 64 caracteres são permitidas e se senhas com mais de 128 caracteres são negadas. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Verifique se o truncamento de senha não é executado. No entanto, vários espaços consecutivos podem ser substituídos por um único espaço. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Verifique se qualquer caractere Unicode imprimível, incluindo caracteres neutros de idioma, como espaços e Emojis, são permitidos em senhas. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Verifique se os usuários podem alterar suas senhas. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Verifique se a funcionalidade de alteração de senha requer a senha atual e nova do usuário. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Verifique se as senhas enviadas durante o registro da conta, login e alteração de senha são verificadas em relação a um conjunto de senhas violadas localmente (como as 1.000 ou 10.000 senhas mais comuns que correspondem à política de senha do sistema) ou usando uma API externa. Se estiver usando uma API, uma prova de conhecimento zero ou outro mecanismo deve ser usado para garantir que a senha de texto simples não seja enviada ou usada na verificação do status de violação da senha. Se a senha for violada, a aplicação deve exigir que o usuário defina uma nova senha não violada. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Verifique se um medidor de força da senha é fornecido para ajudar os usuários a definir uma senha mais forte. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Verifique se não há regras de composição de senha limitando o tipo de caracteres permitidos. Não deve haver nenhum requisito para letras maiúsculas ou minúsculas, números ou caracteres especiais. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Verifique se não há rotação periódica de credenciais ou requisitos de histórico de senha. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Verifique se a funcionalidade \"colar\", auxiliares de senha do navegador e gerenciadores de senha externos são permitidos. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Verifique se o usuário pode optar por visualizar temporariamente toda a senha mascarada ou visualizar temporariamente o último caractere digitado da senha em plataformas que não possuem essa funcionalidade integrada. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nNota: O objetivo de permitir que o usuário visualize a sua senha ou veja o último caractere temporariamente é melhorar a usabilidade do input de credenciais, particularmente em relação ao uso de senhas mais longas, frases secretas e gerenciadores de senhas. Outro motivo para incluir o requisito é impedir ou evitar relatórios de teste que exigem desnecessariamente que as organizações substituam o comportamento do campo de senha da plataforma integrada para remover essa experiência de segurança moderna e amigável.\n\n## V2.2 Segurança geral do autenticador\n\nA agilidade do autenticador é essencial para aplicações preparados para o futuro. Refatore os verificadores de aplicações para permitir autenticadores adicionais conforme as preferências do usuário, bem como permitir a retirada de autenticadores obsoletos ou inseguros de maneira ordenada.\n\nO NIST considera e-mail e SMS como [tipos de autenticador \"restritos\"](https://pages.nist.gov/800-63-FAQ/#q-b1) e provavelmente serão removidos do NIST 800-63 e, assim, o ASVS em algum momento no futuro. As candidaturas devem planear um roteiro que não implique a utilização de email ou SMS.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.2.1** | Verifique se os controles antiautomação são eficazes na mitigação de testes de credenciais violadas, força bruta e ataques de bloqueio de conta. Esses controles incluem o bloqueio das senhas violadas mais comuns, bloqueios suaves, limitação de taxa, CAPTCHA, atrasos cada vez maiores entre tentativas, restrições de endereço IP ou restrições baseadas em risco, como localização, primeiro login num dispositivo, tentativas recentes de desbloquear a conta, ou similar. Verifique se não é possível mais de 100 tentativas com falha por hora numa única conta. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Verifique se o uso de autenticadores fracos (como SMS e e-mail) é limitado a verificação secundária e aprovação de transações e não como substituto para métodos de autenticação mais seguros. Verifique se métodos mais fortes são oferecidos antes de métodos fracos, se os usuários estão cientes dos riscos ou se as medidas adequadas estão em vigor para limitar os riscos de comprometimento da conta. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Verifique se as notificações seguras são enviadas aos usuários após atualizações nos detalhes de autenticação, como redefinições de credenciais, alterações de e-mail ou endereço, login de locais desconhecidos ou arriscados. O uso de notificações push - em vez de SMS ou e-mail - é preferível, mas na ausência de notificações push, SMS ou e-mail é aceitável, desde que nenhuma informação confidencial seja divulgada na notificação. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Verifique a resistência à representação contra phishing, como o uso de autenticação multifator, dispositivos criptográficos com intenção (como chaves conectadas com um push para autenticar) ou em níveis AAL mais altos, certificados do lado do cliente. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Verifique se onde um Provedor de Serviços de Credenciais (CSP) e a aplicação que verifica a autenticação estão separados, o TLS mutuamente autenticado está em vigor entre os dois pontos de extremidade. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Verifique a resistência à reprodução por meio do uso obrigatório de dispositivos de senhas descartáveis (OTP), autenticadores criptográficos ou códigos de pesquisa. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Verifique a intenção de autenticação exigindo a input de um token OTP ou ação iniciada pelo usuário, como pressionar um botão numa chave de hardware FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Ciclo de vida do autenticador\n\nAutenticadores são senhas, soft tokens, tokens de hardware e dispositivos biométricos. O ciclo de vida dos autenticadores é crítico para a segurança de uma aplicação - se qualquer pessoa pode registrar uma conta sem evidência de identidade, pode haver pouca confiança na declaração de identidade. Para sites de mídia social como o Reddit, tudo bem. Para sistemas bancários, um maior foco no registro e emissão de credenciais e dispositivos é fundamental para a segurança da aplicação.\n\nObservação: as senhas não devem ter um tempo de vida máximo ou estar sujeitas à rotação de senha. As senhas devem ser verificadas quanto a violação, não substituídas regularmente.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.3.1** | Verifique se as senhas iniciais ou os códigos de ativação gerados pelo sistema DEVEM ser gerados aleatoriamente de forma segura, DEVEM ter pelo menos 6 caracteres e PODEM conter letras e números e expiram após um curto período de tempo. Esses segredos iniciais não devem ser permitidos para se tornar a senha de longo prazo. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Verifique se há suporte para inscrição e uso de dispositivos de autenticação fornecidos pelo usuário, como tokens U2F ou FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Verifique se as instruções de renovação são enviadas com tempo suficiente para renovar os autenticadores com limite de tempo. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Armazenamento de credenciais\n\nArquitetos e desenvolvedores devem aderir a esta seção ao criar ou refatorar o código. Esta seção só pode ser totalmente verificada usando a revisão do código-fonte ou por meio de testes seguros de unidade, ou integração. O teste de penetração não consegue identificar nenhum desses problemas.\n\nA lista de funções de derivação de chave unidirecional aprovadas é detalhada na seção 5.1.1.2 do NIST 800-63 B e em [BSI Kryptographische Verfahren: Empfehlungen und Schlussellängen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). O algoritmo nacional ou regional mais recente e os padrões de comprimento de chave podem ser escolhidos no lugar dessas opções.\n\nEsta seção não pode ser testada quanto à penetração, então os controles não são marcados como L1. No entanto, esta seção é de vital importância para a segurança das credenciais se forem roubadas, portanto, se for bifurcar o ASVS para uma arquitetura ou diretriz de codificação, ou lista de verificação de revisão de código-fonte, coloque esses controles de volta em L1 na sua versão privada.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.4.1** | Verifique se as senhas são armazenadas de forma resistente a ataques off-line. As senhas DEVEM ser salted e hash usando uma derivação de chave unidirecional aprovada ou função de hashing de senha. As funções de derivação de chave e hash de senha usam uma senha, um sal e um fator de custo como inputs ao gerar um hash de senha. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Verifique se o sal tem pelo menos 32 bits de comprimento e é escolhido arbitrariamente para minimizar as colisões de valor de sal entre os hashes armazenados. Para cada credencial, um valor salt único e o hash resultante DEVEM ser armazenados. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Verifique se PBKDF2 é usado, a contagem de iteração DEVE ser tão grande quanto o desempenho do servidor de verificação permitir, normalmente pelo menos 100.000 iterações. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Verifique se o bcrypt é usado, o fator de trabalho DEVE ser tão grande quanto o desempenho do servidor de verificação permitir, com um mínimo de 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Verifique se uma iteração adicional de uma função de derivação de chave é executada, usando um valor salt que é secreto e conhecido apenas pelo verificador. Gere o valor salt usando um gerador de bit aleatório aprovado [SP 800-90Ar1] e forneça pelo menos a segurança mínima especificada na última revisão do SP 800-131A. O valor salt secreto DEVERÁ ser armazenado separadamente das senhas com hash (por exemplo, num dispositivo especializado como um módulo de segurança de hardware). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nQuando os padrões dos EUA são mencionados, um padrão regional ou local pode ser usado no lugar, ou em adição ao padrão dos EUA, conforme necessário.\n\n## V2.5 Recuperação de credenciais\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.5.1** | Verifique se um segredo inicial de ativação ou recuperação gerado pelo sistema não é enviado em texto não criptografado ao usuário. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Verifique se dicas de senha ou autenticação baseada em conhecimento (as chamadas \"perguntas secretas\") não estão presentes. | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Verifique se a recuperação da credencial de senha não revela a senha atual de forma alguma. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Verifique se contas compartilhadas ou padrão não estão presentes (por exemplo, \"root\", \"admin\" ou \"sa\"). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Verifique se um fator de autenticação é alterado ou substituído, o usuário é notificado sobre esse evento. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Verifique a senha esquecida e outros caminhos de recuperação usam um mecanismo de recuperação seguro, como OTP baseado em tempo (TOTP) ou outro token flexível, push móvel ou outro mecanismo de recuperação offline. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Verifique se os fatores de autenticação OTP ou multifator são perdidos, se a prova de identidade é realizada no mesmo nível que durante o registro. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Verificador secreto de pesquisa\n\nOs segredos de pesquisa são listas pré-geradas de códigos secretos, como números de autorização de transação (TAN), códigos de recuperação de mídia social ou uma grade contendo um conjunto de valores aleatórios. Estes são distribuídos de forma segura para os usuários. Esses códigos de pesquisa são usados uma vez e, uma vez usados, a lista secreta de pesquisa é descartada. Esse tipo de autenticador é considerado \"algo que você tem\".\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.6.1** | Verifique se os segredos de pesquisa podem ser usados apenas uma vez. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Verifique se os segredos de pesquisa têm aleatoriedade suficiente (112 bits de entropia) ou, se tiverem menos de 112 bits de entropia, salteados com um sal exclusivo e aleatório de 32 bits e hash com um hash unidirecional aprovado. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Verifique se os segredos de pesquisa são resistentes a ataques offline, como valores previsíveis. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Verificador fora de banda\n\nNo passado, um verificador comum fora de banda seria um e-mail ou SMS contendo um link de redefinição de senha. Os invasores usam esse mecanismo fraco para redefinir contas que ainda não controlam, como assumir o controle da conta de e-mail de uma pessoa e reutilizar qualquer link de redefinição descoberto. Existem maneiras melhores de lidar com a verificação fora da banda.\n\nAutenticadores seguros fora da banda são dispositivos físicos que podem se comunicar com o verificador por um canal secundário seguro. Os exemplos incluem notificações push para dispositivos móveis. Esse tipo de autenticador é considerado \"algo que você tem\". Quando um usuário deseja autenticar, a aplicação de verificação envia uma mensagem para o autenticador fora de banda por meio de uma conexão com o autenticador direta ou indiretamente por um serviço terceirizado. A mensagem contém um código de autenticação (normalmente um número aleatório de seis dígitos ou uma caixa de diálogo de aprovação modal). A aplicação verificador espera receber o código de autenticação por meio do canal primário e compara o hash do valor recebido com o hash do código de autenticação original. Se forem iguais, o verificador fora da banda pode presumir que o usuário foi autenticado.\n\nO ASVS assume que apenas alguns desenvolvedores desenvolverão novos autenticadores fora de banda, como notificações push e, assim, os seguintes controles ASVS se aplicam a verificadores, como API de autenticação, aplicações e implementações de logon único. Se estiver desenvolvendo um novo autenticador fora de banda, consulte NIST 800-63B &sect; 5.1.3.1.\n\nAutenticadores inseguros fora de banda, como e-mail e VOIP, não são permitidos. A autenticação PSTN e SMS são atualmente \"restritas\" pelo NIST e devem ser substituídas em favor de notificações por push ou similares. Se você precisar usar autenticação fora de banda por telefone ou SMS, consulte o &sect; 5.1.3.3.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.7.1** | Verifique se os autenticadores de texto não criptografado fora da banda (NIST \"restrito\"), como SMS ou PSTN, não são oferecidos por padrão e alternativas mais fortes, como notificações por push, são oferecidas primeiro. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Verifique se o verificador fora de banda expira solicitações, códigos ou tokens de autenticação fora de banda após 10 minutos. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Verifique se as solicitações, códigos ou tokens de autenticação do verificador fora de banda podem ser usados apenas uma vez e apenas para a solicitação de autenticação original. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Verifique se o autenticador e o verificador fora da banda se comunicam por um canal independente seguro. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Verifique se o verificador fora da banda retém apenas uma versão com hash do código de autenticação. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Verifique se o código de autenticação inicial é gerado por um gerador de número aleatório seguro, contendo pelo menos 20 bits de entropia (normalmente, um número aleatório de seis dígitos é suficiente). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 Verificador Único\n\nSenhas únicas de fator único (OTPs) são tokens físicos ou flexíveis que exibem um desafio único pseudoaleatório em constante mudança. Esses dispositivos tornam o phishing (personificação) difícil, mas não impossível. Esse tipo de autenticador é considerado \"algo que você tem\". Os tokens multifatores são semelhantes aos OTPs de fator único, mas exigem a inserção de um código PIN válido, desbloqueio biométrico, inserção USB ou emparelhamento NFC, ou algum valor adicional (como calculadoras de assinatura de transação) para criar o OTP final.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.8.1** | Verifique se os OTPs baseados em tempo têm um tempo de vida definido antes de expirar. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Verifique se as chaves simétricas usadas para verificar os OTPs enviados são altamente protegidas, por exemplo, usando um módulo de segurança de hardware ou armazenamento de chave baseado em sistema operacional seguro. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2|\n| **2.8.3** | Verifique se algoritmos criptográficos aprovados são usados na geração, propagação e verificação de OTPs. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Verifique se o OTP baseado em tempo pode ser usado apenas uma vez no período de validade. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Verifique se um token OTP multifator baseado em tempo é reutilizado durante o período de validade, ele é registrado e rejeitado com notificações seguras sendo enviadas ao proprietário do dispositivo. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Verifique se o gerador OTP físico de fator único pode ser revogado em caso de roubo ou outra perda. Assegure-se de que a revogação entre em vigor imediatamente nas sessões de login, independentemente do local. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Verifique se os autenticadores biométricos estão limitados ao uso apenas como fatores secundários em conjunto com algo que você possui e algo que você conhece. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Verificador Criptográfico\n\nAs chaves de segurança criptográficas são cartões inteligentes ou chaves FIDO, nas quais o usuário deve conectar ou emparelhar o dispositivo criptográfico ao computador para concluir a autenticação. Os verificadores enviam um nonce de desafio para os dispositivos criptográficos ou software, e o dispositivo ou software calcula uma resposta com base numa chave criptográfica armazenada com segurança.\n\nOs requisitos para dispositivos e software criptográficos de fator único e dispositivos e software criptográficos multifatores são os mesmos, pois a verificação do autenticador criptográfico prova a posse do fator de autenticação.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.9.1** | Verifique se as chaves criptográficas usadas na verificação são armazenadas com segurança e protegidas contra divulgação, como o uso de um Módulo de plataforma confiável (TPM) ou Módulo de segurança de hardware (HSM) ou um serviço de sistema operacional que pode usar esse armazenamento seguro. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Verifique se o nonce de desafio tem pelo menos 64 bits de comprimento e é estatisticamente exclusivo ou exclusivo durante a vida útil do dispositivo criptográfico. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Verifique se os algoritmos criptográficos aprovados são usados na geração, propagação e verificação. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Autenticação de Serviço\n\nEsta seção não é passível de teste de penetração, portanto, não possui nenhum requisito L1. No entanto, se usado numa arquitetura, codificação ou revisão de código seguro, assuma que o software (assim como Java Key Store) é o requisito mínimo em L1. O armazenamento de segredos em texto não criptografado não é aceitável em nenhuma circunstância.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.10.1** | Verifique se os segredos intra-serviço não dependem de credenciais imutáveis, como senhas, chaves de API ou contas compartilhadas com acesso privilegiado. | | SO assistido | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Verifique se as senhas são necessárias para autenticação de serviço, a conta de serviço usada não é uma credencial padrão. (por exemplo, root/root ou admin/admin são padrão em alguns serviços durante a instalação). | | SO assistido | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Verifique se as senhas são armazenadas com proteção suficiente para evitar ataques de recuperação offline, incluindo acesso ao sistema local. | | SO assistido | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Verifique se senhas, integrações com bancos de dados e sistemas de terceiros, sementes e segredos internos e chaves de API são gerenciados com segurança e não incluídos no código-fonte ou armazenados em repositórios de código-fonte. Esse armazenamento DEVE resistir a ataques offline. O uso de um armazenamento de chave de software seguro (L1), TPM de hardware ou um HSM (L3) é recomendado para armazenamento de senha. | | SO assistido | HSM | 798 | |\n\n## Requisitos adicionais da agência dos EUA\n\nAs agências dos EUA têm requisitos obrigatórios relativos ao NIST 800-63. O Application Security Verification Standard sempre foi sobre os 80% dos controles que se aplicam a quase 100% das aplicações, e não os últimos 20% dos controles avançados ou aqueles que têm aplicabilidade limitada. Como tal, o ASVS é um subconjunto estrito do NIST 800-63, especialmente para as classificações IAL1/2 e AAL1/2, mas não é suficientemente abrangente, particularmente no que diz respeito às classificações IAL3/AAL3.\n\nNós instamos fortemente as agências governamentais dos EUA a revisar e implementar o NIST 800-63 na sua totalidade.\n\n## Glossário de termos\n\n| Termo | Significado |\n| --- | --- |\n| PSC | Provedor de Serviços de Credencial também chamado Provedor de Identidade |\n| Autenticador | Código que autentica uma senha, token, MFA, declaração federada e assim por diante. |\n| Verificador | \"Uma entidade que verifica a identidade do reclamante verificando a posse e o controle do reclamante de um ou dois autenticadores usando um protocolo de autenticação. Para fazer isso, o verificador também pode precisar validar as credenciais que vinculam o(s) autenticador(es) ao identificador do assinante e verificar o seu estado\" |\n| OTP | Senha de uso único |\n| SFA | Autenticadores de fator único, como algo que conheça (segredos memorizados, senhas, senhas, PINs), algo que você é (biometria, impressão digital, digitalizações faciais) ou algo que possui (tokens OTP, um dispositivo criptográfico como um cartão inteligente) , |\n| AMF | Autenticação multifator, que inclui dois ou mais fatores únicos |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:59.105301"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x12-V3-Session-management.md", "content": "# V3 Gestão de sessão\n\n## Objetivo de controle\n\nUm dos principais componentes de qualquer aplicação baseada na Web ou API com estado é o mecanismo pelo qual ele controla e mantém o estado de um usuário ou dispositivo que interage com ele. A gestão de sessão altera um protocolo sem estado para com estado, o que é crítico para diferenciar diferentes usuários ou dispositivos.\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de gestão de sessão de alto nível:\n\n* As sessões são únicas para cada indivíduo e não podem ser adivinhadas ou compartilhadas.\n* As sessões são invalidadas quando não são mais necessárias e expiram durante períodos de inatividade.\n\nConforme observado anteriormente, esses requisitos foram adaptados para serem um subconjunto compatível de controles NIST 800-63b selecionados, focados em ameaças comuns e vulnerabilidades de autenticação comumente exploradas. Os requisitos de verificação anteriores foram retirados, desduplicados ou, geralmente, adaptados para serem fortemente alinhados com a intenção dos [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) requisitos.\n\n## Requisitos de verificação de segurança\n\n## V3.1 Fundamentos de Segurança de Gestão de Sessão\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.1.1** | Verifique se a aplicação nunca revela tokens de sessão em parâmetros de URL. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Ligação de Sessão\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.2.1** | Verifique se a aplicação gera um novo token de sessão na autenticação do usuário. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Verifique se os tokens de sessão possuem pelo menos 64 bits de entropia. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Verifique se a aplicação armazena apenas tokens de sessão no navegador usando métodos seguros, como cookies devidamente protegidos (consulte a seção 3.4) ou armazenamento de sessão HTML 5. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Verifique se os tokens de sessão são gerados usando algoritmos criptográficos aprovados. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nO TLS ou outro canal de transporte seguro é obrigatório para a gestão de sessão. Isso é abordado no capítulo Segurança das Comunicações.\n\n## V3.3 Encerramento da Sessão\n\nOs session timeouts foram alinhados com o NIST 800-63, que permite session timeouts muito mais longos do que os tradicionalmente permitidos pelos padrões de segurança. As organizações devem revisar a tabela abaixo e, se um tempo limite mais longo for desejável com base no risco da aplicação, o valor NIST deve ser o limite superior dos tempos limite de inatividade da sessão.\n\nL1 neste contexto é IAL1/AAL1, L2 é IAL2/AAL3, L3 é IAL3/AAL3. Para IAL2/AAL2 e IAL3/AAL3, o tempo limite de inatividade mais curto é o limite inferior de tempos de inatividade para ser desconectado ou autenticado novamente para retomar a sessão.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.3.1** | Verifique se o logoff e a expiração invalidam o token de sessão, de modo que o botão Voltar ou uma parte confiável downstream não retome uma sessão autenticada, inclusive entre partes confiáveis. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Se os autenticadores permitirem que os usuários permaneçam conectados, verifique se a reautenticação ocorre periodicamente quando usados ativamente ou após um período ocioso. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 dias | 12 horas ou 30 minutos de inatividade, 2FA opcional | 12 horas ou 15 minutos de inatividade, com 2FA | 613 | 7.2 |\n| **3.3.3** | Verifique se a aplicação oferece a opção de encerrar todas as outras sessões ativas após uma alteração de senha bem-sucedida (incluindo alteração por redefinição/recuperação de senha) e se isso é eficaz na aplicação, no login federado (se houver) e em quaisquer partes confiáveis. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Verifique se os usuários podem visualizar e (tendo inserido novamente as credenciais de login) fazer logoff de qualquer ou de todas as sessões e dispositivos ativos no momento. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Gestão de sessão baseado em cookies\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.4.1** | Verifique se os tokens de sessão baseados em cookie têm o atributo 'Seguro' definido. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Verifique se os tokens de sessão baseados em cookie têm o atributo 'HttpOnly' definido. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Verifique se os tokens de sessão baseados em cookies utilizam o atributo 'SameSite' para limitar a exposição a ataques de falsificação de solicitação entre sites. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | Verifique se os tokens de sessão baseados em cookie usam o prefixo \"__Host-\" para que os cookies sejam enviados apenas para o host que inicialmente definiu o cookie. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Verifique se a aplicação é publicado sob um nome de domínio com outras aplicações que definem ou usam cookies de sessão que podem divulgar os cookies de sessão, defina o atributo path em tokens de sessão baseados em cookie usando o caminho mais preciso possível. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Gestão de sessão baseado em token\n\nA gestão de sessão baseado em token inclui chaves JWT, OAuth, SAML e API. Destas, as chaves de API são conhecidas por serem fracas e não devem ser usadas em novos códigos.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.5.1** | Verifique se a aplicação permite que os usuários revoguem tokens OAuth que formam relacionamentos de confiança coma aplicaçãos vinculados. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Verifique se a aplicação usa tokens de sessão em vez de chaves e segredos de API estáticos, exceto com implementações herdadas. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Verifique se os tokens de sessão sem estado usam assinaturas digitais, criptografia e outras contramedidas para proteger contra adulteração, envelopamento, repetição, cifra nula e ataques de substituição de chave. | | ✓ | ✓ | 345 | |\n\n## V3.6 Reautenticação federada\n\nEsta seção se refere àqueles que escrevem códigos de Parte Confiável (RP) ou Provedor de Serviços de Credenciais (CSP). Se depender do código que implementa esses recursos, certifique-se de que esses problemas sejam tratados corretamente.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.6.1** | Verifique se as Partes Confiáveis (RPs) especificam o tempo máximo de autenticação para Provedores de Serviços de Credenciais (CSPs) e se os CSPs autenticam novamente o usuário se eles não tiverem usado uma sessão dentro desse período. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Verifique se os provedores de serviços de credenciais (CSPs) informam as partes confiáveis (RPs) sobre o último evento de autenticação, para permitir que os RPs determinem se precisam autenticar novamente o usuário. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Defesas contra exploits de gestão de sessão\n\nHá um pequeno número de ataques de gestão de sessão, alguns relacionados à experiência do usuário (UX) das sessões. Anteriormente, com base nos requisitos da ISO 27002, o ASVS exigia o bloqueio de várias sessões simultâneas. Bloquear sessões simultâneas não é mais apropriado, não apenas porque os usuários modernos têm muitos dispositivos ou a aplicação é uma API sem uma sessão do navegador, mas na maioria dessas implementações, o último autenticador vence, que geralmente é o invasor. Esta seção fornece orientações importantes sobre dissuasão, atraso e detecção de ataques de gestão de sessão usando código.\n\n### Descrição do ataque semi-aberto\n\nNo início de 2018, várias instituições financeiras foram comprometidas usando o que os invasores chamaram \"ataques semiabertos\". Este termo ficou preso na indústria. Os invasores atingiram várias instituições com diferentes bases de código proprietárias e, de fato, parecem diferentes bases de código dentro das mesmas instituições. O ataque semiaberto está explorando uma falha de padrão de design comumente encontrada em muitos sistemas existentes de autenticação, gestão de sessão e controle de acesso.\n\nOs invasores iniciam um ataque semiaberto tentando bloquear, redefinir ou recuperar uma credencial. Um padrão de design de gestão de sessão popular reutiliza objetos/modelos de sessão de perfil de usuário entre código não autenticado, parcialmente autenticado (redefinições de senha, nome de usuário esquecido) e totalmente autenticado. Esse padrão de design preenche um objeto ou token de sessão válido contendo o perfil da vítima, incluindo hashes de senha e funções. Se as verificações de controle de acesso em controladores ou roteadores não verificarem corretamente se o usuário está totalmente conectado, o invasor poderá agir como o usuário. Os ataques podem incluir alterar a senha do usuário para um valor conhecido, atualizar o endereço de e-mail para executar uma redefinição de senha válida, desabilitar a autenticação multifator ou registrar um novo dispositivo MFA, revelar ou alterar chaves de API e assim por diante.\n\n| # | Descrição | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.7.1** | Verifique se a aplicação garante uma sessão de login completa e válida ou requer reautenticação ou verificação secundária antes de permitir transações confidenciais ou modificações de conta. | ✓ | ✓ | ✓ | 306 | |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:39:59.183658"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x12-V4-Access-Control.md", "content": "# V4 Controle de Acesso\n\n## Objetivo de controle\n\nAutorização é o conceito de permitir acesso a recursos apenas para aqueles autorizados a usá-los. Certifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* As pessoas que acessam recursos possuem credenciais válidas para fazê-lo.\n* Os usuários estão associados a um conjunto bem definido de funções e privilégios.\n* Os metadados de função e permissão são protegidos contra repetição ou adulteração.\n\n## Requisitos de verificação de segurança\n\n## V4.1 Projeto de controle de acesso geral\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.1.1** | Verifique se a aplicação impõe regras de controle de acesso numa camada de serviço confiável, especialmente se o controle de acesso do lado do cliente estiver presente e puder ser ignorado. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Verifique se todos os atributos de usuário e dados e as informações de política usadas pelos controles de acesso não podem ser manipulados pelos usuários finais, a menos que especificamente autorizados. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Verifique se existe o princípio do menor privilégio - os usuários só devem poder acessar funções, arquivos de dados, URLs, controladores, serviços e outros recursos, para os quais possuam autorização específica. Isso implica proteção contra falsificação e elevação de privilégio. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [EXCLUÍDO, DUPLICADO DE 4.1.3] | | | | |\n| **4.1.5** | Verifique se os controles de acesso falham com segurança, inclusive quando ocorre uma exceção. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Controle de acesso de nível de operação\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.2.1** | Verifique se os dados confidenciais e as APIs estão protegidos contra ataques Insecure Direct Object Reference (IDOR) direcionados à criação, leitura, atualização e exclusão de registros, como criar ou atualizar o registro de outra pessoa, visualizar os registros de todos ou excluir todos os registros. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Verifique se a aplicação ou estrutura impõe um forte mecanismo anti-CSRF para proteger a funcionalidade autenticada e se a antiautomação ou anti-CSRF eficaz protege a funcionalidade não autenticada. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Outras considerações de controle de acesso\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.3.1** | Verifique se as interfaces administrativas usam autenticação multifator apropriada para impedir o uso não autorizado. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Verifique se a navegação no diretório está desativada, a menos que seja deliberadamente desejada. Além disso, as aplicações não devem permitir a descoberta ou divulgação de metadados de arquivo ou diretório, como pastas Thumbs.db, .DS_Store, .git ou .svn. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Verifique se a aplicação possui autorização adicional (como intensificação ou autenticação adaptativa) para sistemas de baixo valor e/ou segregação de funções para aplicações de alto valor para impor controles antifraude de acordo com o risco da aplicação e fraudes anteriores. | | ✓ | ✓ | 732 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:59.280862"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Validação, Sanitização e Codificação\n\n## Objetivo de controle\n\nA falha de segurança da aplicação da Web mais comum é a falha em validar adequadamente a input proveniente do cliente ou do ambiente antes de usá-la diretamente sem qualquer codificação de output. Essa fraqueza leva a quase todas as vulnerabilidades significativas em aplicaçãos da Web, como Cross-Site Scripting (XSS), injeção de SQL, interpreter injection, ataques de localidade/Unicode, ataques de sistema de arquivos e buffer overflows.\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* Validação de input e arquitetura de codificação de output têm um pipeline acordado para evitar ataques de injeção.\n* Os dados de input são fortemente digitados, validados, com intervalo ou comprimento verificados, ou, na pior das hipóteses, higienizados ou filtrados.\n* Os dados de output são codificados ou escapados conforme o contexto dos dados o mais próximo possível do interpretador.\n\nCom a arquitetura moderna de aplicações da Web, a codificação de output é mais importante do que nunca. É difícil fornecer validação de input robusta em determinados cenários, portanto, o uso de API mais segura, como consultas parametrizadas, estruturas de modelo de escape automático ou codificação de output cuidadosamente escolhida, é fundamental para a segurança da aplicação.\n\n## V5.1 Validação de input\n\nControles de validação de input implementados adequadamente, usando listas de permissões positivas e digitação forte de dados, podem eliminar mais de 90% de todos os ataques de injeção. As verificações de comprimento e alcance podem reduzir isso ainda mais. Construir a validação de input segura é necessário durante a arquitetura da aplicação, sprints de design, codificação e testes de unidade e integração. Embora muitos desses itens não possam ser encontrados em testes de penetração, os resultados de não implementá-los são geralmente encontrados em V5.3 - Codificação de output e requisitos de prevenção de injeção. Desenvolvedores e revisores de código seguro são recomendados para tratar esta seção como se L1 fosse necessário para todos os itens para evitar injeções.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.1.1** | Verifique se a aplicação possui defesas contra ataques de poluição de parâmetro HTTP, principalmente se a estrutura da aplicação não fizer distinção sobre a origem dos parâmetros de solicitação (GET, POST, cookies, cabeçalhos ou variáveis de ambiente). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Verifique se as estruturas protegem contra ataques de atribuição de parâmetros em massa ou se a aplicação possui contramedidas para proteger contra atribuição de parâmetros não segura, como marcar campos como privados ou similares. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Verifique se todas as inputs (campos de formulário HTML, solicitações REST, parâmetros de URL, cabeçalhos HTTP, cookies, arquivos em lote, feeds RSS, etc.) são validadas usando validação positiva (listas de permissão). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Verifique se os dados estruturados são fortemente digitados e validados em relação a um esquema definido, incluindo caracteres permitidos, comprimento e padrão (por exemplo, números de cartão de crédito, endereços de e-mail, números de telefone ou validação de que dois campos relacionados são razoáveis, como verificar o subúrbio e o CEP /correspondência de código postal). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Verifique se os redirecionamentos e encaminhamentos de URL permitem apenas destinos que aparecem numa lista de permissões ou exibem um aviso ao redirecionar para conteúdo potencialmente não confiável. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Sanitização e Sandbox\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.2.1** | Verifique se todos os inputs de HTML não confiáveis de editores WYSIWYG ou similares foram devidamente sanitizadas com uma biblioteca, ou recurso de estrutura do higienizador de HTML. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Verifique se os dados não estruturados são limpos para impor medidas de segurança, como caracteres e comprimento permitidos. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Verifique se a aplicação limpa a input do usuário antes de passar para os sistemas de e-mail para proteger contra injeção de SMTP ou IMAP. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Verifique se a aplicação evita o uso de eval() ou outros recursos dinâmicos de execução de código. Onde não houver alternativa, qualquer input do usuário incluída deve ser limpa ou protegida antes de ser executada. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Verifique se a aplicação protege contra-ataques de injeção de modelo, garantindo que qualquer input do usuário incluída seja limpa ou protegida. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Verifique se a aplicação protege contra-ataques SSRF, validando ou limpando dados não confiáveis, ou metadados de arquivos HTTP, como nomes de arquivos e campos de input de URL, e usa listas de permissão de protocolos, domínios, caminhos e portas. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Verifique se a aplicação sanitiza, desativa ou coloca em área restrita o conteúdo de scripts Scalable Vector Graphics (SVG) fornecido pelo usuário, especialmente no que se refere a XSS resultante de scripts embutidos e ao ForeignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Verifique se a aplicação sanitiza, desativa ou coloca em sandbox o conteúdo de linguagem de modelo de expressão ou script fornecido pelo usuário, como folhas de estilo Markdown, CSS ou XSL, BBCode ou similares. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Codificação de Output e Prevenção de Injeção\n\nA codificação de output próxima ou adjacente ao interpretador em uso é crítica para a segurança de qualquer aplicação. Normalmente, a codificação de output não é mantida, mas usada para tornar a output segura no contexto de output apropriado para uso imediato. Deixar de codificar a output resultará numa aplicação injetável e insegura.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.3.1** | Verifique se a codificação de output é relevante para o interpretador e o contexto necessários. Por exemplo, use codificadores especificamente para valores HTML, atributos HTML, JavaScript, parâmetros de URL, cabeçalhos HTTP, SMTP e outros conforme o contexto exigir, especialmente de inputs não confiáveis (por exemplo, nomes com Unicode ou apóstrofes, como ねこ ou O'Hara) . ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Verifique se a codificação de output preserva o conjunto de caracteres e localidade escolhidos pelo usuário, de forma que qualquer ponto de caractere Unicode seja válido e manipulado com segurança. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Verifique se o escape de output sensível ao contexto, de preferência automatizado - ou, na pior das hipóteses, manual - protege contra XSS refletido, armazenado e baseado em DOM. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Verifique se a seleção de dados ou consultas de banco de dados (por exemplo, SQL, HQL, ORM, NoSQL) usam consultas parametrizadas, ORMs, estruturas de entidade ou estão protegidas contra ataques de injeção de banco de dados. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Verifique se onde mecanismos parametrizados ou mais seguros não estão presentes, a codificação de output específica do contexto é usada para proteger contra ataques de injeção, como o uso de escape SQL para proteger contra injeção SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Verifique se a aplicação protege contra ataques de injeção JSON, ataques de avaliação JSON e avaliação de expressão JavaScript. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Verifique se a aplicação protege contra vulnerabilidades de injeção de LDAP ou se foram implementados controles de segurança específicos para impedir a injeção de LDAP. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Verifique se a aplicação protege contra injeção de comando do SO e se as chamadas do sistema operacional usam consultas de SO parametrizadas ou usam codificação de output de linha de comando contextual. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Verifique se a aplicação protege contra ataques de inclusão de arquivo local (LFI) ou inclusão de arquivo remoto (RFI). | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Verifique se a aplicação protege contra ataques de injeção XPath ou injeção XML. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nObservação: usar consultas parametrizadas ou escapar do SQL nem sempre é suficiente; nomes de tabelas e colunas, ORDER BY e assim por diante, não podem ser ignorados. A inclusão de dados fornecidos pelo usuário com escape nesses campos resulta em consultas com falha ou injeção de SQL.\n\nObservação: o formato SVG permite explicitamente o script ECMA em quase todos os contextos, portanto, pode não ser possível bloquear completamente todos os vetores SVG XSS. Se o upload de SVG for necessário, é altamente recomendável servir esses arquivos carregados como texto/sem formatação ou usar um domínio de conteúdo fornecido pelo usuário separado para evitar que o XSS bem-sucedido assuma o controle da aplicação.\n\n## V5.4 Memória, String e Código Não Gerenciado\n\nOs requisitos a seguir serão aplicados apenas quando a aplicação usar uma linguagem de sistema ou código não gerenciado.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.4.1** | Verifique se a aplicação usa cadeia de memória segura, cópia de memória mais segura e aritmética de ponteiro para detectar ou evitar estouros de pilha, buffer ou heap. | | ✓ | ✓ | 120 |\n| **5.4.2** | Verifique se as strings de formato não aceitam inputs potencialmente hostis e são constantes. | | ✓ | ✓ | 134 |\n| **5.4.3** | Verifique se as técnicas de validação de sinal, intervalo e input são usadas para evitar estouros de número inteiro. | | ✓ | ✓ | 190 |\n\n## V5.5 Prevenção de desserialização\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.5.1** | Verifique se os objetos serializados usam verificações de integridade ou são criptografados para impedir a criação de objetos hostis ou adulteração de dados. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Verifique se a aplicação restringe corretamente os analisadores de XML para usar apenas a configuração mais restritiva possível e para garantir que recursos não seguros, como a resolução de entidades externas, sejam desabilitados para evitar ataques de XML eXternal Entity (XXE). | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Verifique se a desserialização de dados não confiáveis é evitada ou protegida em código personalizado e bibliotecas de terceiros (como analisadores JSON, XML e YAML). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Verifique se, ao analisar JSON em navegadores ou back-ends baseados em JavaScript, JSON.parse é usado para analisar o documento JSON. Não use eval() para analisar JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nPara obter mais informações sobre escape automático, consulte:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nPara obter mais informações sobre desserialização, consulte:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:39:59.353373"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x14-V6-Cryptography.md", "content": "# V6 Criptografia armazenada\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* Todos os módulos criptográficos falham de maneira segura e os erros são tratados corretamente.\n* Um gerador de números aleatórios adequado é usado.\n* O acesso às chaves é gerenciado com segurança.\n\n## V6.1 Classificação de dados\n\nO ativo mais importante são os dados processados, armazenados ou transmitidos por uma aplicação. Sempre realize uma avaliação de impacto na privacidade para classificar corretamente as necessidades de proteção de dados de quaisquer dados armazenados.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.1.1** | Verifique se os dados privados regulamentados são armazenados criptografados enquanto estão em repouso, como informações de identificação pessoal (PII), informações pessoais confidenciais ou dados avaliados que provavelmente estão sujeitos ao GDPR da UE. | | ✓ | ✓ | 311 |\n| **6.1.2** | Verifique se os dados de saúde regulamentados são armazenados criptografados enquanto estão em repouso, como registros médicos, detalhes de dispositivos médicos ou registros de pesquisa anonimizados. | | ✓ | ✓ | 311 |\n| **6.1.3** | Verifique se os dados financeiros regulamentados são armazenados criptografados enquanto estão inativos, como contas financeiras, inadimplência ou histórico de crédito, registros fiscais, histórico de pagamentos, beneficiários ou registros de pesquisa ou mercado anonimizados. | | ✓ | ✓ | 311 |\n\n## V6.2 Algoritmos\n\nAvanços recentes em criptografia significam que algoritmos e comprimentos de chave anteriormente seguros não são mais seguros ou suficientes para proteger os dados. Portanto, deve ser possível alterar os algoritmos.\n\nEmbora esta seção não seja facilmente testada quanto à penetração, os desenvolvedores devem considerá-la como obrigatória, mesmo que L1 esteja faltando na maioria dos itens.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.2.1** | Verifique se todos os módulos criptográficos falham com segurança e se os erros são tratados de forma a não permitir ataques de Padding Oracle. | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Verifique se são usados algoritmos, modos e bibliotecas criptográficos comprovados pelo setor ou aprovados pelo governo, em vez de criptografia codificada personalizada. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Verifique se o vetor de inicialização de criptografia, a configuração de cifra e os modos de bloqueio estão configurados com segurança usando as recomendações mais recentes. | | ✓ | ✓ | 326 |\n| **6.2.4** | Verifique se o número aleatório, algoritmos de criptografia ou hash, comprimentos de chave, rodadas, cifras ou modos podem ser reconfigurados, atualizados ou trocados a qualquer momento, para proteger contra quebras criptográficas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Verifique se os modos de bloco inseguros conhecidos (ou seja, ECB, etc.), modos de preenchimento (ou seja, PKCS#1 v1.5, etc.), cifras com tamanhos de bloco pequenos (ou seja, Triple-DES, Blowfish, etc.) e algoritmos de hash fracos (ou seja, MD5, SHA1, etc.) não são usados, a menos que sejam necessários para compatibilidade com versões anteriores. | | ✓ | ✓ | 326 |\n| **6.2.6** | Verifique se nonces, vetores de inicialização e outros números de uso único não devem ser usados mais de uma vez com uma determinada chave de criptografia. O método de geração deve ser apropriado para o algoritmo que está sendo usado. | | ✓ | ✓ | 326 |\n| **6.2.7** | Verifique se os dados criptografados são autenticados por meio de assinaturas, modos de cifra autenticados ou HMAC para garantir que o texto cifrado não seja alterado por uma parte não autorizada. | | | ✓ | 326 |\n| **6.2.8** | Verifique se todas as operações criptográficas são de tempo constante, sem operações de 'curto-circuito' em comparações, cálculos ou retornos, para evitar vazamento de informações. | | | ✓ | 385 |\n\n## V6.3 Valores aleatórios\n\nA verdadeira geração de números pseudoaleatórios (PRNG) é incrivelmente difícil de acertar. Geralmente, boas fontes de entropia dentro de um sistema serão rapidamente esgotadas se usadas em excesso, mas fontes com menos aleatoriedade podem levar a chaves e segredos previsíveis.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.3.1** | Verifique se todos os números aleatórios, nomes de arquivos aleatórios, GUIDs aleatórios e strings aleatórias são gerados usando o gerador de números aleatórios criptograficamente seguro aprovado do módulo criptográfico quando esses valores aleatórios não devem ser adivinhados por um invasor. | | ✓ | ✓ | 338 |\n| **6.3.2** | Verifique se os GUIDs aleatórios são criados usando o algoritmo GUID v4 e um gerador de números pseudo-aleatórios criptograficamente seguro (CSPRNG). GUIDs criados usando outros geradores de números pseudo-aleatórios podem ser previsíveis. | | ✓ | ✓ | 338 |\n| **6.3.3** | Verifique se os números aleatórios são criados com a entropia adequada mesmo quando a aplicação está sob carga pesada ou se a aplicação se degrada normalmente nessas circunstâncias. | | | ✓ | 338 |\n\n## V6.4 Gestão de segredo\n\nEmbora esta seção não seja facilmente testada quanto à penetração, os desenvolvedores devem considerá-la como obrigatória, mesmo que L1 esteja faltando na maioria dos itens.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.4.1** | Verifique se uma solução de gestão de segredos, como um cofre de chaves, é usada para criar, armazenar, controlar o acesso e destruir segredos com segurança. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Verifique se o material da chave não está exposto à aplicação, mas usa um módulo de segurança isolado como um cofre para operações criptográficas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:39:59.431305"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x15-V7-Error-Logging.md", "content": "# V7 Tratamento e registro de erros\n\n## Objetivo de controle\n\nO principal objetivo do tratamento e registro de erros é fornecer informações úteis para o usuário, administradores e equipes de resposta a incidentes. O objetivo não é criar grandes quantidades de logs, mas logs de alta qualidade, com mais sinal do que ruído descartado.\n\nLogs de alta qualidade geralmente contêm dados confidenciais e devem ser protegidos conforme as leis ou diretivas locais de privacidade de dados. Isso deve incluir:\n\n* Não coletar ou registrar informações confidenciais, a menos que seja especificamente necessário.\n* Garantir que todas as informações registradas sejam tratadas com segurança e protegidas conforme a sua classificação de dados.\n* Garantir que os logs não sejam armazenados para sempre, mas tenham um tempo de vida absoluto o mais curto possível.\n\nSe os logs contiverem dados privados ou confidenciais, cuja definição varia de país para país, os logs se tornam algumas das informações mais confidenciais mantidas pela aplicação e, assim, muito atraentes para os invasores.\n\nTambém é importante garantir que a aplicação falhe com segurança e que erros não divulguem informações desnecessárias.\n\n## V7.1 Conteúdo do registro\n\nRegistrar informações confidenciais é perigoso - os próprios logs se tornam classificados, o que significa que precisam ser criptografados, sujeitos a políticas de retenção e devem ser divulgados em auditorias de segurança. Certifique-se de que apenas as informações necessárias sejam mantidas em logs e, certamente, nenhum pagamento, credenciais (incluindo tokens de sessão), informações confidenciais ou de identificação pessoal.\n\nV7.1 abrange OWASP Top 10 2017:A10. Como 2017:A10 e esta seção não são passíveis de teste de penetração, é importante para:\n\n* Desenvolvedores devem garantir total conformidade com esta seção, como se todos os itens fossem marcados como L1\n* Penetration testers para validar a conformidade total de todos os itens na V7.1 por meio de entrevista, capturas de tela ou afirmação\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.1.1** | Verifique se a aplicação não registra credenciais ou detalhes de pagamento. Os tokens de sessão devem ser armazenados apenas em logs num formato de hash irreversível. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Verifique se a aplicação não registra outros dados confidenciais conforme definido nas leis de privacidade locais ou na política de segurança relevante. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Verifique se a aplicação registra eventos relevantes de segurança, incluindo eventos de autenticação bem-sucedidos e com falha, falhas de controle de acesso, falhas de desserialização e falhas de validação de input. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Verifique se cada evento de log inclui as informações necessárias que permitem uma investigação detalhada da linha do tempo quando um evento ocorre. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Processamento de Log\n\nO registro oportuno é crítico para eventos de auditoria, triagem e escalonamento. Certifique-se de que os logs da aplicação estejam claros e possam ser facilmente monitorados e analisados localmente ou enviados para um sistema de monitoramento remoto.\n\nV7.2 abrange OWASP Top 10 2017:A10. Como 2017:A10 e esta seção não são passíveis de teste de penetração, é importante para:\n\n* Desenvolvedores devem garantir total conformidade com esta seção, como se todos os itens fossem marcados como L1\n* Penetration testers para validar a conformidade total de todos os itens na V7.2 por entrevista, capturas de tela ou afirmação\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.2.1** | Verifique se todas as decisões de autenticação são registradas, sem armazenar senhas ou tokens de sessão confidenciais. Isso deve incluir solicitações com metadados relevantes necessários para investigações de segurança. | | ✓ | ✓ | 778 |\n| **7.2.2** | Verifique se todas as decisões de controle de acesso podem ser registradas e todas as decisões com falha são registradas. Isso deve incluir solicitações com metadados relevantes necessários para investigações de segurança. | | ✓ | ✓ | 285 |\n\n## V7.3 Proteção de Log\n\nLogs que podem ser modificados ou excluídos trivialmente são inúteis para investigações e processos. A divulgação de logs pode expor detalhes internos sobre a aplicação ou os dados que ele contém. Deve-se tomar cuidado ao proteger os logs contra divulgação, modificação ou exclusão não autorizada.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.3.1** | Verifique se todos os componentes de log codificam os dados adequadamente para evitar a injeção de log. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [EXCLUÍDO, DUPLICADO DE 7.3.1] | | | | |\n| **7.3.3** | Verifique se os logs de segurança estão protegidos contra acesso e modificação não autorizados. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Verifique se as fontes de horário estão sincronizadas com a hora e o fuso horário corretos. Considere fortemente o registro apenas em UTC se os sistemas forem globais para auxiliar na análise forense pós-incidente. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nObservação: a codificação de log (7.3.1) é difícil de testar e revisar usando ferramentas dinâmicas automatizadas e testes de penetração, mas arquitetos, desenvolvedores e revisores de código-fonte devem considerá-la um requisito L1.\n\n## V7.4 Tratamento de Erros\n\nO objetivo do tratamento de erros é permitir que a aplicação forneça eventos relevantes de segurança para monitoramento, triagem e escalonamento. O objetivo não é criar logs. Ao registrar eventos relacionados à segurança, certifique-se de que haja uma finalidade para o registro e que ele possa ser distinguido pelo SIEM ou software de análise.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.4.1** | Verifique se uma mensagem genérica é exibida quando ocorre um erro inesperado ou sensível à segurança, possivelmente com uma ID exclusiva que a equipe de suporte pode usar para investigar. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Verifique se o tratamento de exceção (ou um equivalente funcional) é usado na base de código para contabilizar as condições de erro esperadas e inesperadas. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Verifique se um manipulador de erro de \"último recurso\" está definido para capturar todas as exceções não tratadas. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nNota: Certas linguagens, como Swift e Go - e através da prática de design comum - muitas linguagens funcionais, não suportam exceções ou manipuladores de eventos de último recurso. Nesse caso, arquitetos e desenvolvedores devem usar um padrão, linguagem ou estrutura amigável para garantir que as aplicações possam manipular com segurança eventos excepcionais, inesperados ou relacionados à segurança.\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:39:59.515868"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x16-V8-Data-Protection.md", "content": "# V8 Proteção de Dados\n\n## Objetivo de controle\n\nExistem três elementos-chave para uma boa proteção de dados: Confidencialidade, Integridade e Disponibilidade (CIA). Este padrão assume que a proteção de dados é aplicada num sistema confiável, como um servidor, reforçado e possui proteções suficientes.\n\nAs aplicações devem assumir que todos os dispositivos do usuário estão comprometidos de alguma forma. Quando uma aplicação transmite ou armazena informações confidenciais em dispositivos inseguros, como computadores, telefones e tablets compartilhados, a aplicação é responsável por garantir que os dados armazenados nesses dispositivos sejam criptografados e não possam ser facilmente obtidos, alterados ou divulgados de forma ilícita.\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de proteção de dados de alto nível:\n\n* Confidencialidade: Os dados devem ser protegidos contra observação ou divulgação não autorizada, tanto em trânsito quanto quando armazenados.\n* Integridade: os dados devem ser protegidos contra criação, alteração ou exclusão maliciosa por invasores não autorizados.\n* Disponibilidade: Os dados devem estar disponíveis para usuários autorizados conforme necessário.\n\n## V8.1 Proteção Geral de Dados\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.1.1** | Verifique se a aplicação protege os dados confidenciais de serem armazenados em cache nos componentes do servidor, como balanceadores de carga e caches de aplicações. | | ✓ | ✓ | 524 |\n| **8.1.2** | Verifique se todas as cópias em cache ou temporárias de dados confidenciais armazenados no servidor estão protegidas contra acesso não autorizado ou eliminadas/invalidadas depois que o usuário autorizado acessa os dados confidenciais. | | ✓ | ✓ | 524 |\n| **8.1.3** | Verifique se a aplicação minimiza o número de parâmetros numa solicitação, como campos ocultos, variáveis Ajax, cookies e valores de cabeçalho. | | ✓ | ✓ | 233 |\n| **8.1.4** | Verifique se a aplicação pode detectar e alertar sobre números anormais de solicitações, como por IP, usuário, total por hora ou dia ou o que fizer sentido para a aplicação. | | ✓ | ✓ | 770 |\n| **8.1.5** | Verifique se os backups regulares de dados importantes são executados e se a restauração de teste de dados é realizada. | | | ✓ | 19 |\n| **8.1.6** | Verifique se os backups são armazenados com segurança para evitar que os dados sejam roubados ou corrompidos. | | | ✓ | 19 |\n\n## V8.2 Proteção de dados do lado do cliente\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.2.1** | Verifique se a aplicação define cabeçalhos anti-cache suficientes para que dados confidenciais não sejam armazenados em cache em navegadores modernos. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Verifique se os dados armazenados no armazenamento do navegador (como localStorage, sessionStorage, IndexedDB ou cookies) não contêm dados confidenciais. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Verifique se os dados autenticados foram apagados do armazenamento do cliente, como o DOM do navegador, após o término do cliente ou da sessão. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Dados privados confidenciais\n\nEsta seção ajuda a proteger dados confidenciais de serem criados, lidos, atualizados ou excluídos sem autorização, especialmente em grandes quantidades.\n\nA conformidade com esta seção implica conformidade com o Controle de acesso V4 e, em particular, V4.2. Por exemplo, para proteger contra atualizações não autorizadas ou divulgação de informações pessoais confidenciais, é necessário aderir à V4.2.1. Por favor, cumpra esta seção e V4 para cobertura completa.\n\nObservação: os regulamentos e as leis de privacidade, como os princípios de privacidade australianos APP-11 ou GDPR, afetam diretamente como as aplicações devem abordar a implementação de armazenamento, uso e transmissão de informações pessoais confidenciais. Isso varia de penalidades severas a conselhos simples. Consulte as leis e regulamentos locais e consulte um especialista em privacidade ou advogado qualificado, conforme necessário.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.3.1** | Verifique se os dados confidenciais são enviados ao servidor no corpo ou nos cabeçalhos da mensagem HTTP e se os parâmetros da string de consulta de qualquer verbo HTTP não contêm dados confidenciais. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Verifique se os usuários têm um método para remover ou exportar os seus dados sob demanda. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Verifique se os usuários recebem uma linguagem clara sobre a coleta e o uso das informações pessoais fornecidas e se os usuários forneceram consentimento para o uso desses dados antes de serem usados de qualquer forma. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Verifique se todos os dados confidenciais criados e processados pela aplicação foram identificados e certifique-se de que haja uma política sobre como lidar com dados confidenciais. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Verifique se o acesso a dados confidenciais é auditado (sem registrar os próprios dados confidenciais), se os dados forem coletados conforme as diretivas de proteção de dados relevantes ou se o registro de acesso for necessário. | | ✓ | ✓ | 532 |\n| **8.3.6** | Verifique se as informações confidenciais contidas na memória são substituídas assim que não são mais necessárias para mitigar ataques de despejo de memória, usando zeros ou dados aleatórios. | | ✓ | ✓ | 226 |\n| **8.3.7** | Verifique se as informações confidenciais ou privadas que devem ser criptografadas estão criptografadas usando algoritmos aprovados que fornecem confidencialidade e integridade. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Verifique se as informações pessoais confidenciais estão sujeitas à classificação de retenção de dados, de modo que os dados antigos ou desatualizados sejam excluídos automaticamente, de acordo com a programação ou conforme a situação exigir. | | ✓ | ✓ | 285 |\n\nAo considerar a proteção de dados, uma consideração primária deve ser a extração em massa ou modificação, ou uso excessivo. Por exemplo, muitos sistemas de mídia social permitem apenas que os usuários adicionem 100 novos amigos por dia, mas de qual sistema essas solicitações vieram não é importante. Uma plataforma bancária pode querer bloquear mais de 5 transações por hora, transferindo mais de 1000 euros de fundos para instituições externas. É provável que os requisitos de cada sistema sejam muito diferentes, portanto, decidir sobre \"anormal\" deve considerar o modelo de ameaça e o risco comercial. Critérios importantes são a capacidade de detectar, impedir ou, preferencialmente, bloquear tais ações em massa anormais.\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:39:59.609820"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x17-V9-Communications.md", "content": "# V9 Comunicação\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* Requer TLS ou criptografia forte, independente da sensibilidade do conteúdo.\n* Siga as orientações mais recentes, incluindo:\n  * Conselho de configuração\n  * Algoritmos e cifras preferidos\n* Evite algoritmos e cifras fracos ou prestes a serem obsoletos, exceto como último recurso\n* Desabilite algoritmos e cifras obsoletos ou inseguros conhecidos.\n\nDentro desses requisitos:\n\n* Mantenha-se atualizado com os conselhos recomendados do setor sobre a configuração segura do TLS, pois ele muda com frequência (geralmente devido a quebras catastróficas nos algoritmos e cifras existentes).\n* Use as versões mais recentes das ferramentas de revisão de configuração TLS para configurar a ordem preferida e a seleção do algoritmo.\n* Verifique a sua configuração periodicamente para garantir que a comunicação segura esteja sempre presente e eficaz.\n\n## V9.1 Segurança de comunicação do cliente\n\nCertifique-se de que todas as mensagens do cliente sejam enviadas por redes criptografadas, usando TLS 1.2 ou posterior.\nUse ferramentas atualizadas para revisar a configuração do cliente regularmente.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.1.1** | Verifique se o TLS é usado para toda a conectividade do cliente e não retrocede para comunicações inseguras ou não criptografadas. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | Verifique, usando ferramentas de teste de TLS atualizadas, que somente conjuntos de cifras fortes estão ativados, com os conjuntos de cifras mais fortes definidos como preferenciais. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Verifique se apenas as versões recomendadas mais recentes do protocolo TLS estão habilitadas, como TLS 1.2 e TLS 1.3. A versão mais recente do protocolo TLS deve ser a opção preferida. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Segurança de comunicação do servidor\n\nAs comunicações do servidor são mais que apenas HTTP. Conexões seguras de e para outros sistemas, como sistemas de monitoramento, ferramentas de gestão, acesso remoto e ssh, middleware, banco de dados, mainframes, parceiros ou sistemas de origem externa - devem estar em vigor. Tudo isso deve ser criptografado para evitar \"difícil por fora, trivialmente fácil de interceptar por dentro\".\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.2.1** | Verifique se as conexões de e para o servidor usam certificados TLS confiáveis. Onde certificados gerados internamente ou autoassinados são usados, o servidor deve ser configurado para confiar apenas em CAs internas específicas e certificados autoassinados específicos. Todos os outros devem ser rejeitados. | | ✓ | ✓ | 295 |\n| **9.2.2** | Verifique se as comunicações criptografadas, como TLS, são usadas para todas as conexões de input e output, incluindo portas de gestão, monitoramento, autenticação, API ou chamadas de Web Service, banco de dados, nuvem, serverless, mainframe, externas e conexões de parceiros. O servidor não deve recorrer a protocolos inseguros ou não criptografados. | | ✓ | ✓ | 319 |\n| **9.2.3** | Verifique se todas as conexões criptografadas com sistemas externos que envolvem informações ou funções confidenciais são autenticadas. | | ✓ | ✓ | 287 |\n| **9.2.4** | Verifique se a revogação de certificação adequada, como o grampeamento do protocolo de status de certificado on-line (OCSP), está habilitada e configurada. | | ✓ | ✓ | 299 |\n| **9.2.5** | Verifique se as falhas de conexão TLS de back-end são registradas. | | | ✓ | 544 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Notas sobre “Modos aprovados de TLS”:\n  * No passado, a ASVS referia-se ao padrão americano FIPS 140-2, mas como um padrão global, a aplicação dos padrões americanos pode ser difícil, contraditória ou confusa.\n  * Um método melhor para obter conformidade com a seção 9.1 seria revisar guias como [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) ou [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/) e use ferramentas de avaliação TLS conhecidas e atualizadas para obter o nível de segurança desejado.\n", "timestamp": "2025-10-24T11:39:59.673335"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x18-V10-Malicious.md", "content": "# V10 Código malicioso\n\n## Objetivo de controle\n\nCertifique-se de que o código satisfaça os seguintes requisitos de alto nível:\n\n* A atividade maliciosa é tratada de forma segura e adequada para não afetar o restante da aplicação.\n* Não possui bombas-relógio ou outros ataques baseados no tempo.\n* Não \"telefone para casa\" para destinos maliciosos ou não autorizados.\n* Não possui portas traseiras, ovos de Páscoa, ataques de salame, rootkits ou código não autorizado que possa ser controlado por um invasor.\n\nEncontrar um código malicioso é a prova da negativa, impossível de validar completamente. Devem ser envidados os melhores esforços para garantir que o código não tenha código malicioso inerente ou funcionalidade indesejada.\n\n## V10.1 Integridade do código\n\nA melhor defesa contra códigos maliciosos é \"confiar, mas verificar\". A introdução de código não autorizado ou malicioso no código costuma ser uma ofensa criminal em muitas jurisdições. Políticas e procedimentos devem tornar claras as sanções relativas a códigos maliciosos.\n\nOs principais desenvolvedores devem revisar regularmente os check-ins de código, especialmente aqueles que podem acessar funções de tempo, E/S ou rede.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.1.1** | Verifique se uma ferramenta de análise de código está em uso e pode detectar códigos potencialmente maliciosos, como funções de tempo, operações de arquivo inseguras e conexões de rede. | | | ✓ | 749 |\n\n## V10.2 Pesquisa de código malicioso\n\nO código malicioso é extremamente raro e difícil de detectar. A revisão manual do código linha por linha pode ajudar a procurar por bombas lógicas, mas mesmo o revisor de código mais experiente terá dificuldade em encontrar código malicioso, mesmo que saiba que ele existe.\n\nA conformidade com esta seção não é possível sem acesso completo ao código-fonte, incluindo bibliotecas de terceiros.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.2.1** | Verifique se o código-fonte da aplicação e as bibliotecas de terceiros não contêm recursos não autorizados de telefone residencial ou coleta de dados. Onde tal funcionalidade existir, obtenha a permissão do usuário para que ela opere antes de coletar quaisquer dados. | | ✓ | ✓ | 359 |\n| **10.2.2** | Verifique se a aplicação não solicita permissões desnecessárias ou excessivas para recursos ou sensores relacionados à privacidade, como contatos, câmeras, microfones ou localização. | | ✓ | ✓ | 272 |\n| **10.2.3** | Verifique se o código-fonte da aplicação e as bibliotecas de terceiros não contêm backdoors, como contas ou chaves codificadas ou adicionais não documentadas, ofuscação de código, blobs binários não documentados, rootkits ou antidepuração, recursos de depuração inseguros ou de outra forma fora de data, funcionalidade insegura ou oculta que pode ser usada maliciosamente se descoberta. | | | ✓ | 507 |\n| **10.2.4** | Verifique se o código-fonte da aplicação e as bibliotecas de terceiros não contêm bombas-relógio procurando por funções relacionadas a data e hora. | | | ✓ | 511 |\n| **10.2.5** | Verifique se o código-fonte da aplicação e as bibliotecas de terceiros não contêm código mal-intencionado, como ataques de salame, desvios lógicos ou bombas lógicas. | | | ✓ | 511 |\n| **10.2.6** | Verifique se o código-fonte da aplicação e as bibliotecas de terceiros não contêm ovos de Páscoa ou qualquer outra funcionalidade potencialmente indesejada. | | | ✓ | 507 |\n\n## V10.3 Integridade da aplicação\n\nDepois que uma aplicação é implantado, o código malicioso ainda pode ser inserido. as aplicações precisam se proteger contra-ataques comuns, como a execução de código não assinado de fontes não confiáveis e invasões de subdomínio.\n\nO cumprimento desta seção provavelmente será operacional e contínuo.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.3.1** | Verifique se a aplicação possui um recurso de atualização automática de cliente ou servidor, as atualizações devem ser obtidas por canais seguros e assinadas digitalmente. O código de atualização deve validar a assinatura digital da atualização antes de instalar ou executar a atualização. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Verifique se a aplicação emprega proteções de integridade, como assinatura de código ou integridade de sub-recurso. A aplicação não deve carregar ou executar código de fontes não confiáveis, como carregamento de inclusões, módulos, plug-ins, códigos ou bibliotecas de fontes não confiáveis ou da Internet. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Verifique se a aplicação tem proteção contra invasões de subdomínio se a aplicação depender de inputs DNS ou subdomínios DNS, como nomes de domínio expirados, ponteiros DNS ou CNAMEs desatualizados, projetos expirados em repositórios públicos de código-fonte ou APIs de nuvem temporárias, funções serverless, ou depósitos de armazenamento (*autogen-bucket-id*.cloud.example.com) ou similar. As proteções podem incluir a garantia de que os nomes DNS usados pelas aplicações sejam verificados regularmente quanto à expiração ou alteração. | ✓ | ✓ | ✓ | 350 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:39:59.749990"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x19-V11-BusLogic.md", "content": "# V11 Lógica de Negócios\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* O fluxo da lógica de negócios é sequencial, processado em ordem e não pode ser ignorado.\n* A lógica de negócios inclui limites para detectar e prevenir ataques automatizados, como pequenas transferências contínuas de fundos ou adição de um milhão de amigos, um por vez, e assim por diante.\n* Os fluxos de lógica de negócios de alto valor consideraram casos de abuso e atores mal-intencionados com proteções contra falsificação, adulteração, divulgação de informações e ataques de elevação de privilégio.\n\n## V11.1 Segurança da Lógica de Negócios\n\nA segurança da lógica de negócios é tão individual para cada aplicação que nenhuma lista de verificação será aplicada. A segurança da lógica de negócios deve ser projetada para proteger contra prováveis ameaças externas - ela não pode ser adicionada usando firewalls de aplicações da Web ou comunicações seguras. Recomendamos o uso de modelagem de ameaças durante os sprints de design, por exemplo, usando o OWASP Cornucopia ou ferramentas semelhantes.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **11.1.1** | Verifique se a aplicação processará apenas fluxos de lógica de negócios para o mesmo usuário em ordem sequencial de etapas e sem pular etapas. | ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Verifique se a aplicação processará apenas fluxos de lógica de negócios com todas as etapas sendo processadas em tempo humano realista, ou seja, as transações não são enviadas muito rapidamente. | ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Verifique se a aplicação tem limites apropriados para ações ou transações de negócios específicas que são aplicadas corretamente por usuário. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Verifique se a aplicação possui controles antiautomação para proteção contra chamadas excessivas, como exfiltração de dados em massa, solicitações de lógica de negócios, uploads de arquivos ou ataques de negação de serviço. | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Verifique se a aplicação tem limites de lógica de negócios ou validação para proteger contra prováveis riscos ou ameaças de negócios, identificados usando modelagem de ameaças ou metodologias semelhantes. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Verifique se a aplicação não sofre de problemas de \"Time Of Check to Time Of Use\" (TOCTOU) ou outras condições de corrida para operações confidenciais. | | ✓ | ✓ | 367 |\n| **11.1.7** | Verifique se a aplicação monitora eventos ou atividades incomuns de uma perspectiva de lógica de negócios. Por exemplo, tentativas de executar ações fora de ordem ou ações que um usuário normal nunca tentaria. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Verifique se a aplicação possui alertas configuráveis quando ataques automatizados ou atividades incomuns são detectados. | | ✓ | ✓ | 390 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* A antiautomação pode ser alcançada de várias maneiras, incluindo o uso de [OWASP AppSensor](https://github.com/jtmelton/appsensor) e [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) pode também ajudar com Detecção e Respostas de Ataques.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:39:59.828965"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x20-V12-Files-Resources.md", "content": "# V12 Arquivos e Recursos\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado atenda aos seguintes requisitos de alto nível:\n\n* Dados de arquivos não confiáveis devem ser tratados adequadamente e de maneira segura.\n* Dados de arquivos não confiáveis obtidos de fontes não confiáveis são armazenados fora da raiz da web e com permissões limitadas.\n\n## V12.1 Carregamento de arquivo\n\nEmbora as bombas zip sejam eminentemente testáveis usando técnicas de teste de penetração, elas são consideradas L2 e acima para encorajar a consideração de design e desenvolvimento com testes manuais cuidadosos e para evitar testes de penetração manuais automatizados ou não qualificados de uma condição de negação de serviço.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.1.1** | Verifique se a aplicação não aceitará arquivos grandes que possam encher o armazenamento ou causar uma negação de serviço. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Verifique se a aplicação verifica os arquivos compactados (por exemplo, zip, gz, docx, odt) em relação ao tamanho máximo descompactado permitido e ao número máximo de arquivos antes de descompactar o arquivo. | | ✓ | ✓ | 409 |\n| **12.1.3** | Verifique se uma cota de tamanho de arquivo e um número máximo de arquivos por usuário são aplicados para garantir que um único usuário não possa preencher o armazenamento com muitos arquivos ou arquivos excessivamente grandes. | | ✓ | ✓ | 770 |\n\n## V12.2 Integridade do arquivo\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.2.1** | Verifique se os arquivos obtidos de fontes não confiáveis são validados como sendo do tipo esperado com base no conteúdo do arquivo. | | ✓ | ✓ | 434 |\n\n## V12.3 Execução de Arquivo\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.3.1** | Verifique se os metadados de nome de arquivo enviados pelo usuário não são usados diretamente pelo sistema ou sistemas de arquivos de estrutura e se uma API de URL é usada para proteção contra travessia de caminho. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Verifique se os metadados de nome de arquivo enviados pelo usuário são validados ou ignorados para impedir a divulgação, criação, atualização ou remoção de arquivos locais (LFI). | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Verifique se os metadados de nome de arquivo enviados pelo usuário são validados ou ignorados para evitar a divulgação ou execução de arquivos remotos por ataques de inclusão de arquivo remoto (RFI) ou falsificação de solicitação do lado do servidor (SSRF). | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Verifique se a aplicação protege contra download de arquivo reflexivo (RFD) validando ou ignorando nomes de arquivo enviados pelo usuário num parâmetro JSON, JSONP ou URL, o cabeçalho Content-Type de resposta deve ser definido como text/plain e o cabeçalho Content-Disposition deve ter um nome de arquivo fixo. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Verifique se os metadados de arquivos não confiáveis não são usados diretamente com API ou bibliotecas do sistema, para proteger contra a injeção de comandos do sistema operacional. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Verifique se a aplicação não inclui e executa funcionalidades de fontes não confiáveis, como redes de distribuição de conteúdos não verificados, bibliotecas JavaScript, bibliotecas de nó npm ou DLLs do lado do servidor. | | ✓ | ✓ | 829 |\n\n## V12.4 Armazenamento de Arquivos\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.4.1** | Verifique se os arquivos obtidos de fontes não confiáveis são armazenados fora da raiz da web, com permissões limitadas. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Verifique se os arquivos obtidos de fontes não confiáveis são verificados por scanners antivírus para impedir o upload e a exibição de conteúdo malicioso conhecido. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Download do arquivo\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.5.1** | Verifique se a camada da web está configurada para servir apenas arquivos com extensões de arquivo específicas para evitar informações não intencionais e vazamento de código-fonte. Por exemplo, arquivos de backup (por exemplo, .bak), arquivos de trabalho temporários (por exemplo, .swp), arquivos compactados (.zip, .tar.gz, etc) e outras extensões comumente usadas por editores devem ser bloqueados, a menos que necessário. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Verifique se as solicitações diretas para arquivos carregados nunca serão executadas como conteúdo HTML/JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 Proteção SSRF\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.6.1** | Verifique se o servidor da web ou de aplicações está configurado com uma lista de permissões de recursos ou sistemas para os quais o servidor pode enviar solicitações ou carregar dados/arquivos. | ✓ | ✓ | ✓ | 918 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:39:59.897861"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x21-V13-API.md", "content": "# V13 API e Web Service\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado que usa APIs de camada de serviço confiável (geralmente usando JSON, XML ou GraphQL) tenha:\n\n* Autenticação adequada, gestão de sessão e autorização de todos os serviços da web.\n* Validação de input de todos os parâmetros que transitam de um nível de confiança inferior para superior.\n* Controles de segurança eficazes para todos os tipos de API, incluindo nuvem e API serverless\n\nPor favor, leia este capítulo em combinação com todos os outros capítulos neste mesmo nível; não duplicamos mais questões de autenticação ou gestão de sessões de API.\n\n## V13.1 Segurança genérica de Web Service\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.1.1** | Verifique se todos os componentes da aplicação usam as mesmas codificações e analisadores para evitar ataques de análise que exploram URI diferente ou comportamento de análise de arquivo que pode ser usado em ataques SSRF e RFI. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [EXCLUÍDO, DUPLICADO DE 4.3.1] | | | | |\n| **13.1.3** | Verifique se os URLs da API não expõem informações confidenciais, como a chave da API, tokens de sessão, etc. | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Verifique se as decisões de autorização são feitas no URI, impostas por segurança programática ou declarativa no controlador ou roteador, e no nível do recurso, impostas por permissões baseadas em modelo. | | ✓ | ✓ | 285 |\n| **13.1.5** | Verifique se as solicitações que contêm tipos de conteúdo inesperados ou ausentes são rejeitadas com cabeçalhos apropriados (status de resposta HTTP 406 inaceitável ou 415 tipo de mídia não compatível). | | ✓ | ✓ | 434 |\n\n## V13.2 Serviço Web RESTful\n\nA validação do esquema JSON está em fase de rascunho de padronização (consulte as referências). Ao considerar o uso da validação do esquema JSON, que é a prática recomendada para serviços da Web RESTful, considere o uso dessas estratégias adicionais de validação de dados em combinação com a validação do esquema JSON:\n\n* Validação de análise do objeto JSON, como se houver elementos ausentes ou extras.\n* Validação dos valores do objeto JSON usando métodos de validação de input padrão, como tipo de dados, formato de dados, comprimento, etc.\n* e validação de esquema JSON formal.\n\nAssim que o padrão de validação do esquema JSON for formalizado, a ASVS atualizará os seus conselhos nessa área. Monitore cuidadosamente todas as bibliotecas de validação de esquema JSON em uso, já que elas precisarão ser atualizadas regularmente até que o padrão seja formalizado e os bugs sejam eliminados das implementações de referência.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.2.1** | Verifique se os métodos HTTP RESTful ativados são uma escolha válida para o usuário ou ação, como impedir que usuários normais usem DELETE ou PUT em recursos ou API protegidos. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Verifique se a validação do esquema JSON está em vigor e verificada antes de aceitar a input. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Verifique se os serviços da Web RESTful que utilizam cookies estão protegidos contra falsificação de solicitação entre sites por meio do uso de pelo menos um ou mais dos seguintes: padrão de cookie de envio duplo, nonces CSRF ou verificações de cabeçalho de solicitação de origem. | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [EXCLUÍDO, DUPLICADO DE 11.1.4] | | | | |\n| **13.2.5** | Verifique se os serviços REST verificam explicitamente se o Content-Type de input é o esperado, como application/xml ou application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Verifique se os cabeçalhos e a carga da mensagem são confiáveis e não foram modificados em trânsito. Exigir criptografia forte para transporte (somente TLS) pode ser suficiente em muitos casos, pois fornece proteção de confidencialidade e integridade. As assinaturas digitais por mensagem podem fornecer garantia adicional além das proteções de transporte para aplicações de alta segurança, mas trazem consigo complexidade e riscos adicionais para comparar com os benefícios. | | ✓ | ✓ | 345 |\n\n## V13.3 Serviço Web SOAP\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.3.1** | Verifique se a validação do esquema XSD ocorre para garantir um documento XML formado corretamente, seguido pela validação de cada campo de input antes de qualquer processamento desses dados. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Verifique se a carga útil da mensagem está assinada usando WS-Security para garantir o transporte confiável entre o cliente e o serviço. | | ✓ | ✓ | 345 |\n\nObservação: devido a problemas com ataques XXE contra DTDs, a validação de DTD não deve ser usada e a avaliação de DTD de estrutura desativada de acordo com os requisitos estabelecidos na configuração V14.\n\n## V13.4 GraphQL\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.4.1** | Verifique se uma lista de permissões de consulta ou uma combinação de limitação de profundidade e limitação de quantidade é usada para impedir o GraphQL ou a negação de serviço (DoS) da expressão da camada de dados como resultado de consultas aninhadas caras. Para cenários mais avançados, a análise de custo de consulta deve ser usada. | | ✓ | ✓ | 770 |\n| **13.4.2** | Verifique se GraphQL ou outra lógica de autorização da camada de dados deve ser implementada na camada de lógica de negócios em vez da camada GraphQL. | | ✓ | ✓ | 285 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:00.024684"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x22-V14-Config.md", "content": "# V14 Configuração\n\n## Objetivo de controle\n\nCertifique-se de que uma aplicação verificado tenha:\n\n* Um ambiente de construção seguro, repetível e automatizável.\n* Biblioteca reforçada de terceiros, dependência e gestão de configuração de forma que componentes desatualizados ou inseguros não sejam incluídos pela aplicação.\n\nA configuração da aplicação pronta para uso deve ser segura para estar na Internet, significando uma configuração segura pronta para uso.\n\n## V14.1 Construir e Implantar\n\nOs pipelines de compilação são a base para a segurança repetível - toda vez que algo inseguro é descoberto, ele pode ser resolvido no código-fonte, scripts de compilação ou implantação e testado automaticamente. Incentivamos fortemente o uso de pipelines de compilação com segurança automática e verificações de dependência que avisam ou interrompem a compilação para evitar que problemas de segurança conhecidos sejam implantados na produção. Etapas manuais executadas de forma irregular levam diretamente a erros de segurança evitáveis.\n\nÀ medida que o setor se move para um modelo DevSecOps, é importante garantir a disponibilidade e a integridade contínuas da implantação e da configuração para atingir um estado \"conhecido como bom\". No passado, se um sistema fosse hackeado, levaria de dias a meses para provar que nenhuma outra intrusão havia ocorrido. Hoje, com o advento da infraestrutura definida por software, implantações rápidas de A/B com tempo de inatividade zero e compilações automatizadas em contêineres, é possível criar, fortalecer e implantar de forma automática e contínua uma substituição \"boa\" para qualquer sistema comprometido.\n\nSe os modelos tradicionais ainda estiverem em vigor, devem ser tomadas medidas manuais para fortalecer e fazer backup dessa configuração para permitir que os sistemas comprometidos sejam rapidamente substituídos por sistemas não comprometidos de alta integridade em tempo hábil.\n\nA conformidade com esta seção requer um sistema de compilação automatizado e acesso a scripts de compilação e implantação.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.1.1** | Verifique se os processos de criação e implantação da aplicação são executados de maneira segura e repetível, como automação de CI/CD, gestão de configuração automatizada e scripts de implantação automatizada. | | ✓ | ✓ | |\n| **14.1.2** | Verifique se os sinalizadores do compilador estão configurados para habilitar todas as proteções e avisos de buffer overflow disponíveis, incluindo randomização de pilha, prevenção de execução de dados e para interromper a compilação se um ponteiro inseguro, memória, string de formato, número inteiro ou operações de string forem encontrados. | | ✓ | ✓ | 120 |\n| **14.1.3** | Verifique se a configuração do servidor está protegida de acordo com as recomendações do servidor de aplicações e estruturas em uso. | | ✓ | ✓ | 16 |\n| **14.1.4** | Verifique se a aplicação, a configuração e todas as dependências podem ser reimplantados usando scripts de implantação automatizados, criados a partir de um runbook documentado e testado num tempo razoável ou restaurados de backups em tempo hábil. | | ✓ | ✓ | |\n| **14.1.5** | Verifique se os administradores autorizados podem verificar a integridade de todas as configurações relevantes para a segurança para detectar adulterações. | | | ✓ | |\n\n## V14.2 Dependência\n\nO gestão de dependência é crítico para a operação segura de qualquer aplicação de qualquer tipo. A falha em manter-se atualizado com dependências desatualizadas ou inseguras é a causa raiz dos maiores e mais caros ataques até hoje.\n\nNota: No Nível 1, a conformidade com 14.2.1 refere-se a observações ou detecções do lado do cliente e outras bibliotecas e componentes, em vez da análise de código estático ou análise de dependência mais precisa em tempo de compilação. Essas técnicas mais precisas podem ser descobertas por entrevistas, conforme necessário.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.2.1** | Verifique se todos os componentes estão atualizados, de preferência usando um verificador de dependência durante o tempo de construção ou compilação. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Verifique se todos os recursos, documentação, aplicações de amostra e configurações desnecessários foram removidos. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Verifique se os ativos da aplicação, como bibliotecas JavaScript, CSS ou fontes da Web, são hospedados externamente numa rede de entrega de conteúdo (CDN) ou provedor externo, a integridade do subrecurso (SRI) é usada para validar a integridade do ativo. | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Verifique se os componentes de terceiros vêm de repositórios predefinidos, confiáveis e mantidos continuamente. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Verifique se uma lista de materiais de software (SBOM) é mantida para todas as bibliotecas de terceiros em uso. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Verifique se a superfície de ataque é reduzida por sandbox ou encapsulamento de bibliotecas de terceiros para expor apenas o comportamento necessário na aplicação. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Divulgação de segurança não intencional\n\nAs configurações para produção devem ser fortalecidas para proteger contra-ataques comuns, como consoles de depuração, aumentar o nível de ataques Cross-site Scripting (XSS) e Remote File Inclusion (RFI) e eliminar \"vulnerabilidades\" triviais de descoberta de informações que são as indesejadas marcas registradas de muitos relatórios de teste de penetração. Muitos desses problemas são raramente classificados como um risco significativo, mas estão encadeados com outras vulnerabilidades. Se esses problemas não estiverem presentes por padrão, ele eleva a fasquia antes que a maioria dos ataques seja bem-sucedida.\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.3.1** | [EXCLUÍDO, DUPLICADO DE 7.4.1] | | | | |\n| **14.3.2** | Verifique se os modos de depuração da estrutura da aplicação ou servidor da Web estão desativados na produção para eliminar recursos de depuração, consoles de desenvolvedor e divulgações de segurança não intencionais. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Verifique se os cabeçalhos HTTP ou qualquer parte da resposta HTTP não expõe informações detalhadas sobre a versão dos componentes do sistema. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 Cabeçalhos de segurança HTTP\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.4.1** | Verifique se cada resposta HTTP contém um cabeçalho Content-Type. Especifique também um conjunto de caracteres seguro (por exemplo, UTF-8, ISO-8859-1) se os tipos de conteúdo forem text/*, /+xml e application/xml. O conteúdo deve corresponder ao cabeçalho Content-Type fornecido. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Verifique se todas as respostas da API contêm um anexo Content-Disposition:; cabeçalho filename=\"api.json\" (ou outro nome de arquivo apropriado para o tipo de conteúdo). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Verifique se um cabeçalho de resposta da política de segurança de conteúdo (CSP) está em vigor para ajudar a atenuar o impacto de ataques XSS, como HTML, DOM, JSON e vulnerabilidades de injeção de JavaScript. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Verifique se todas as respostas contêm um cabeçalho X-Content-Type-Options: nosniff. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Verifique se um cabeçalho Strict-Transport-Security está incluído em todas as respostas e para todos os subdomínios, como Strict-Transport-Security: max-age=15724800; includeSubdomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Verifique se um cabeçalho Referrer-Policy adequado está incluído para evitar a exposição de informações confidenciais na URL por meio do cabeçalho Referer para partes não confiáveis. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Verifique se o conteúdo de uma aplicação da Web não pode ser incorporado num site de terceiros por padrão e se a incorporação dos recursos exatos só é permitida quando necessária usando a política de segurança de conteúdo adequada: resposta de ancestrais de quadro e opções de X-Frame cabeçalhos. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Validação de cabeçalho de solicitação HTTP\n\n| # | Descrição | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.5.1** | Verifique se o servidor de aplicações aceita apenas os métodos HTTP em uso pela aplicação/API, incluindo OPÇÕES pré-voo e logs/alertas em quaisquer solicitações que não sejam válidas para o contexto da aplicação. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Verifique se o cabeçalho Origin fornecido não é usado para autenticação ou decisões de controle de acesso, pois o cabeçalho Origin pode ser facilmente alterado por um invasor. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Verifique se o cabeçalho Access-Control-Allow-Origin de compartilhamento de recursos de origem cruzada (CORS) usa uma lista de permissão estrita de domínios e subdomínios confiáveis para correspondência e não oferece suporte à origem \"nula\". | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Verifique se os cabeçalhos HTTP adicionados por um proxy confiável ou dispositivos SSO, como um token de portador, são autenticados pela aplicação. | | ✓ | ✓ | 306 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Adicionar disposição de conteúdo às respostas da API ajuda a evitar muitos ataques baseados em mal-entendidos no tipo MIME entre cliente e servidor, e a opção \"nome do arquivo\" especificamente ajuda a evitar [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:40:00.110809"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x90-Appendix-A_Glossary.md", "content": "# Apêndice A: Glossário\n\n- **Address Space Layout Randomization** (ASLR) - Uma técnica para dificultar a exploração de bugs de corrupção de memória.\n- **Lista de permissões** - Uma lista de dados ou operações permitidas, por exemplo, uma lista de caracteres com permissão para executar a validação de input.\n- **Segurança de aplicações** - a segurança em nível de aplicação se concentra na análise de componentes que compõem a camada de aplicação do Modelo de referência de interconexão de sistemas abertos (modelo OSI), em vez de se concentrar, por exemplo, no sistema operacional subjacente ou nas redes conectadas.\n- **Application Security Verification** - A avaliação técnica de uma aplicação contra o OWASP ASVS.\n- **Relatório de verificação de segurança da aplicação** - Um relatório que documenta os resultados gerais e a análise de suporte produzida pelo verificador para uma aplicação específico.\n- **Autenticação** - A verificação da identidade reivindicada de um usuário da aplicação.\n- **Verificação automatizada** - O uso de ferramentas automatizadas (ferramentas de análise dinâmica, ferramentas de análise estática ou ambas) que usam assinaturas de vulnerabilidade para encontrar problemas.\n- **teste black box** - É um método de teste de software que examina a funcionalidade de uma aplicação sem examinar as suas estruturas ou funcionamento interno.\n- **Componente** - uma unidade de código independente, com disco associado e interfaces de rede que se comunica com outros componentes.\n- **Cross-Site Scripting** (XSS) - Uma vulnerabilidade de segurança normalmente encontrada ema aplicaçãos da Web que permite a injeção de scripts do lado do cliente no conteúdo.\n- **Módulo criptográfico** - Hardware, software e/ou firmware que implementa algoritmos criptográficos e/ou gera chaves criptográficas.\n- **Common Weakness Enumeration** (CWE) - Uma lista desenvolvida pela comunidade de vulnerabilidades comuns de segurança de software. Ele serve como uma linguagem comum, uma medida para ferramentas de segurança de software e como uma linha de base para esforços de identificação, mitigação e prevenção de fraquezas.\n- **Verificação de projeto** - A avaliação técnica da arquitetura de segurança de uma aplicação.\n- **Dynamic Application Security Testing** (DAST) - As tecnologias são projetadas para detectar condições indicativas de uma vulnerabilidade de segurança numa aplicação em seu estado de execução.\n- **Verificação Dinâmica** - O uso de ferramentas automatizadas que usam assinaturas de vulnerabilidade para encontrar problemas durante a execução de uma aplicação.\n- **Fast IDentity Online** (FIDO) - Um conjunto de padrões de autenticação que permite o uso de vários métodos de autenticação diferentes, incluindo biometria, Trusted Platform Modules (TPMs), tokens de segurança USB, etc.\n- **Globally Unique Identifier** (GUID) - um número de referência exclusivo usado como um identificador no software.\n- **Hyper Text Transfer Protocol** (HTTPS) - Um protocolo de aplicação para sistemas de informação de hipermídia distribuídos e colaborativos. É a base da comunicação de dados para a World Wide Web.\n- **Chaves codificadas** - Chaves criptográficas armazenadas no sistema de arquivos, seja em código, comentários ou arquivos.\n- **Módulo de Segurança de Hardware** (HSM) - Componente de hardware capaz de armazenar chaves criptográficas e outros segredos de forma protegida.\n- **Hibernate Query Language** (HQL) - Uma linguagem de consulta semelhante em aparência ao SQL usado pela biblioteca Hibernate ORM.\n- **Validação de input** - A canonização e validação de input de usuário não confiável.\n- **Código malicioso** - Código introduzido numa aplicação durante o seu desenvolvimento sem o conhecimento do proprietário da aplicação, que contorna a política de segurança pretendida da aplicação. Não é o mesmo que malware, como um vírus ou worm!\n- **Malware** - Código executável introduzido numa aplicação durante o tempo de execução sem o conhecimento do usuário ou administrador da aplicação.\n- **Open Web Application Security Project** (OWASP) - O Open Web Application Security Project (OWASP) é uma comunidade mundial gratuita e aberta focada em melhorar a segurança do software de aplicações. A nossa missão é tornar a segurança de aplicações \"visível\", para que pessoas e organizações possam tomar decisões informadas sobre os riscos de segurança de aplicações. Veja: https://www.owasp.org/\n- **One-time Password** (OTP) - Uma senha gerada exclusivamente para ser usada numa única ocasião.\n- **Mapeamento relacional de objeto** (ORM) - Um sistema usado para permitir que um banco de dados relacional/baseado em tabela seja referenciado e consultado dentro de um programa aplicação usando um modelo de objeto compatível com a aplicação.\n- **Função de derivação de chave baseada em senha 2** (PBKDF2) - Um algoritmo unidirecional especial usado para criar uma chave criptográfica forte a partir de um texto de input (como uma senha) e um valor de sal aleatório adicional e, assim, pode ser usado dificulte quebrar uma senha offline se o valor resultante for armazenado em vez da senha original.\n- **Informações de identificação pessoal** (PII) - são informações que podem ser usadas sozinhas ou com outras informações para identificar, contatar ou localizar uma única pessoa ou para identificar um indivíduo no contexto.\n- **Executável independente de posição** (PIE) - Um corpo de código de máquina que, sendo colocado em algum lugar na memória primária, é executado adequadamente independentemente do seu endereço absoluto.\n- **Public Key Infrastructure** (PKI) - Um arranjo que vincula as chaves públicas às respectivas identidades das entidades. A vinculação é estabelecida por meio de um processo de registro e emissão de certificados em e por uma autoridade de certificação (CA).\n- **Rede telefônica pública comutada** (PSTN) - A rede telefônica tradicional, incluindo telefones fixos e celulares.\n- **Relying Party** (RP) - Geralmente, uma aplicação que depende de um usuário autenticado num provedor de autenticação separado. a aplicação conta com algum tipo de token ou conjunto de asserções assinadas fornecidas por esse provedor de autenticação para confiar que o usuário é quem diz ser.\n- **Teste de segurança de aplicações estáticos** (SAST) - Um conjunto de tecnologias projetadas para analisar o código-fonte da aplicação, código de bytes e binários para condições de codificação e design que são indicativas de vulnerabilidades de segurança. As soluções SAST analisam uma aplicação de “dentro para fora” num estado sem execução.\n- **Ciclo de vida de desenvolvimento de software** (SDLC) - O processo passo a passo pelo qual o software é desenvolvido desde os requisitos iniciais até a implantação e manutenção.\n- **Arquitetura de segurança** - Uma abstração do design de uma aplicação que identifica e descreve onde e como os controles de segurança são usados e também identifica e descreve a localização e a confidencialidade dos dados do usuário e da aplicação.\n- **Configuração de segurança** - A configuração de tempo de execução de uma aplicação que afeta como os controles de segurança são usados.\n- **Controle de segurança** - Uma função ou componente que executa uma verificação de segurança (por exemplo, uma verificação de controle de acesso) ou quando chamado resulta num efeito de segurança (por exemplo, gerando um registro de auditoria).\n- **Server-side Request Forgery** (SSRF) - Um ataque que abusa da funcionalidade do servidor para ler ou atualizar recursos internos, fornecendo ou modificando uma URL que o código em execução no servidor irá ler ou enviar dados.\n- **Single Sign-on Authentication** (SSO) - Isso ocorre quando um usuário faz login numa aplicação e é automaticamente conectado a outras aplicações sem precisar se autenticar novamente. Por exemplo, ao fazer login no Google, ao acessar outros serviços do Google, como YouTube, Google Docs e Gmail, você será automaticamente conectado.\n- **SQL Injection** (SQLi) - Uma técnica de injeção de código usada para atacar aplicações baseados em dados, nos quais instruções SQL maliciosas são inseridas num ponto de input.\n- **SVG** - Gráficos vetoriais escaláveis\n- **OTP baseado em tempo** - Um método de geração de um OTP onde a hora atual atua como parte do algoritmo para gerar a senha.\n- **Modelagem de ameaças** - Uma técnica que consiste no desenvolvimento de arquiteturas de segurança cada vez mais refinadas para identificar agentes de ameaças, zonas de segurança, controles de segurança e importantes ativos técnicos e de negócios.\n- **Transport Layer Security** (TLS) - protocolos criptográficos que fornecem segurança de comunicação numa conexão de rede\n- **Módulo de plataforma confiável** (TPM) - Um tipo de HSM que é geralmente conectado a um componente de hardware maior, como uma placa-mãe, e atua como a \"raiz de confiança\" desse sistema.\n- **Autenticação de dois fatores** (2FA) - Adiciona um segundo nível de autenticação a um login de conta.\n- **Universal 2nd Factor** (U2F) - Um dos padrões criados pela FIDO especificamente para permitir que uma chave de segurança USB ou NFC seja usada como um 2.º fator de autenticação.\n- **Fragmentos de URL/URL/URL** - Um identificador de recurso uniforme é uma cadeia de caracteres usada para identificar um nome ou um recurso da web. Um localizador uniforme de recursos é geralmente usado como referência a um recurso.\n- **Verificador** - A pessoa ou equipe que está revisando uma aplicação em relação aos requisitos OWASP ASVS.\n- **O que você vê é o que obtém** (WYSIWYG) - Um tipo de editor de conteúdo avançado que mostra como o conteúdo realmente ficará quando renderizado, em vez de mostrar a codificação usada para controlar a renderização.\n- **Certificado X.509** - Um certificado X.509 é um certificado digital que usa o padrão internacional amplamente aceito de infraestrutura de chave pública (PKI) X.509 para verificar se uma chave pública pertence à identidade do usuário, computador ou serviço contida no certificado.\n- **XML eXternal Entity** (XXE) - Um tipo de entidade XML que pode acessar conteúdo local ou remoto por meio de um identificador de sistema declarado. Isso pode carregar vários ataques de injeção.", "timestamp": "2025-10-24T11:40:00.213252"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x91-Appendix-B_References.md", "content": "# Apêndice B: Referências\n\nOs seguintes projetos OWASP provavelmente serão úteis para usuários/adotantes deste padrão:\n\n## Projetos principais do OWASP\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## Projeto OWASP Cheat Sheet Series\n\n[Este projeto](https://owasp.org/www-project-cheat-sheets/) possui várias sugestões que serão relevantes para diferentes tópicos no ASVS.\n\nExiste um mapeamento para o ASVS que pode ser encontrado aqui: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Projetos Relacionados à Segurança Mobile\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Projetos relacionados à Internet of Things OWASP\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Projetos OWASP Serverless\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Outras\n\nDa mesma forma, os seguintes sites provavelmente serão úteis para usuários/adotantes deste padrão.\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:40:00.322338"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/pt/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/pt/0x93-Appendix-C_IoT.md", "content": "# Apêndice C: Requisitos de verificação da Internet of Things\n\nEste capítulo estava originalmente no ramo principal, mas com o trabalho que a equipe OWASP IoT tem feito, não faz sentido manter dois tópicos diferentes sobre o assunto. Para a versão 4.0, estamos movendo isso para o Apêndice e instamos todos que precisam disso a usar o [OWASP IoT Project](https://owasp.org/www-project-internet-of-things/) principal.\n\n## Objetivo de controle\n\nOs dispositivos integrados/IoT devem:\n\n* Tenha o mesmo nível de controles de segurança no dispositivo encontrado no servidor, aplicando controles de segurança num ambiente confiável.\n* Os dados confidenciais armazenados no dispositivo devem ser feitos de maneira segura, usando armazenamento com suporte de hardware, como elementos seguros.\n* Todos os dados confidenciais transmitidos do dispositivo devem utilizar a segurança da camada de transporte.\n\n## Requisitos de verificação de segurança\n\n| # | Descrição | L1 | L2 | L3 | Desde |\n| --- | --- | --- | --- | --- | --- |\n| **C.1** | Verifique se as interfaces de depuração da camada de aplicação, como USB, UART e outras variantes seriais, estão desativadas ou protegidas por uma senha complexa. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Verifique se as chaves e certificados criptográficos são exclusivos para cada dispositivo individual. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Verifique se os controles de proteção de memória, como ASLR e DEP, estão ativados pelo sistema operacional integrado/IoT, se aplicável. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Verifique se as interfaces de depuração no chip, como JTAG ou SWD, estão desabilitadas ou se o mecanismo de proteção disponível está habilitado e configurado adequadamente. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Verifique se a execução confiável está implementada e habilitada, se disponível no dispositivo SoC ou CPU. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Verifique se dados confidenciais, chaves privadas e certificados estão armazenados com segurança num Elemento Seguro, TPM, TEE (Ambiente de Execução Confiável) ou protegidos por criptografia forte. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Verifique se as aplicações de firmware protegem os dados em trânsito usando a segurança da camada de transporte. | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Verifique se as aplicações de firmware validam a assinatura digital das conexões do servidor. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Verifique se as comunicações sem fio são mutuamente autenticadas. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Verifique se as comunicações sem fio são enviadas por um canal criptografado. | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Verifique se qualquer uso de funções C proibidas é substituído pelas funções equivalentes seguras apropriadas. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Verifique se cada firmware mantém uma lista de materiais de software catalogando componentes de terceiros, versões e vulnerabilidades publicadas. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Verifique se todos os códigos, incluindo binários, bibliotecas e estruturas de terceiros, são revisados quanto a credenciais codificadas (backdoors). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Verifique se os componentes da aplicação e do firmware não são suscetíveis à injeção de comando do sistema operacional, invocando wrappers de comando shell, scripts ou se os controles de segurança impedem a injeção de comando do sistema operacional. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Verifique se as aplicações de firmware fixam a assinatura digital em servidores confiáveis. | | ✓ | ✓ | 4.0 |\n| **C.16** | Verifique a presença de recursos de resistência e/ou detecção de violação. | | ✓ | ✓ | 4.0 |\n| **C.17** | Verifique se todas as tecnologias de proteção de propriedade intelectual disponíveis fornecidas pelo fabricante do chip estão ativadas. | | ✓ | ✓ | 4.0 |\n| **C.18** | Verifique se os controles de segurança estão em vigor para impedir a engenharia reversa do firmware (por exemplo, remoção de símbolos de depuração detalhados). | | ✓ | ✓ | 4.0 |\n| **C.19** | Verifique se o dispositivo valida a assinatura da imagem de inicialização antes de carregar. | | ✓ | ✓ | 4.0 |\n| **C.20** | Verifique se o processo de atualização do firmware não é vulnerável a ataques de tempo de verificação versus tempo de uso. | | ✓ | ✓ | 4.0 |\n| **C.21** | Verifique se o dispositivo usa assinatura de código e valida os arquivos de atualização do firmware antes da instalação. | | ✓ | ✓ | 4.0 |\n| **C.22** | Verifique se o dispositivo não pode ser rebaixado para versões antigas (anti-reversão) de firmware válido. | | ✓ | ✓ | 4.0 |\n| **C.23** | Verifique o uso do gerador de números pseudoaleatórios criptograficamente seguro no dispositivo incorporado (por exemplo, usando geradores de números aleatórios fornecidos por chip). | | ✓ | ✓ | 4.0 |\n| **C.24** | Verifique se o firmware pode executar atualizações automáticas de firmware num cronograma predefinido. | | ✓ | ✓ | 4.0 |\n| **C.25** | Verifique se o dispositivo limpa o firmware e os dados confidenciais após a detecção de adulteração ou recebimento de mensagem inválida. | | | ✓ | 4.0 |\n| **C.26** | Verifique se apenas os microcontroladores que suportam a desativação de interfaces de depuração (por exemplo, JTAG, SWD) são usados. | | | ✓ | 4.0 |\n| **C.27** | Verifique se apenas os microcontroladores que fornecem proteção substancial contra-ataques de decapagem e de canal lateral são usados. | | | ✓ | 4.0 |\n| **C.28** | Verifique se os traços sensíveis não estão expostos às camadas externas da placa de circuito impresso. | | | ✓ | 4.0 |\n| **C.29** | Verifique se a comunicação entre chips está criptografada (por exemplo, comunicação da placa principal para a placa filha). | | | ✓ | 4.0 |\n| **C.30** | Verifique se o dispositivo usa assinatura de código e valida o código antes da execução. | | | ✓ | 4.0 |\n| **C.31** | Verifique se as informações confidenciais mantidas na memória são substituídas por zeros assim que não são mais necessárias. | | | ✓ | 4.0 |\n| **C.32** | Verifique se as aplicações de firmware utilizam contêineres de kernel para isolamento entre aplicações. | | | ✓ | 4.0 |\n| **C.33** | Verifique se os sinalizadores de compilador seguro, como -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap, estão configurados para compilações de firmware. | | | ✓ | 4.0 |\n| **C.34** | Verifique se os microcontroladores estão configurados com proteção de código (se aplicável). | | | ✓ | 4.0 |\n\n## Referências\n\nPara mais informações, consulte também:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [Projeto OWASP Embedded Application Security](https://owasp.org/www-project-embedded-application-security/)\n* [Projeto Internet of Things OWASP](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:40:00.411544"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x01-Frontispiece.md", "content": "# Фронтиспис\n\n## О стандарте\n\nСтандарт верификации требований к безопасности приложений — это перечень требований к безопасности приложений (тестов), которыми могут пользоваться архитекторы, разработчики, тестировщики, специалисты по безопасности, разработчики инструментов и конечные пользователи для проектирования, разработки, тестирования и контроля безопасных приложений.\n\n## Авторские права и лицензия\n\nВерсия 4.0.3, октябрь 2021\n\n![лицензия](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. Этот документ выпущен под [лицензией Creative Commons Attribution ShareAlike 3.0](https://creativecommons.org/licenses/by-sa/3.0/). При воспроизведении или распространении этого документа необходимо разъяснить условия лицензии на него.\n\n## Руководители проекта\n\n|                       |                  |             |\n|---------------------- |----------------- |------------ |\n| Andrew van der Stock  | Daniel Cuthbert  | Jim Manico  |\n| Josh C Grossman       | Elar Lang      |             |\n\n## Основные участники\n\n|                 |                 |                    |\n|---------------- |---------------- |------------------- |\n| Abhay Bhargav   | Benedikt Bauer  | Osama Elnaggar     |\n| Ralph Andalis  | Ron Perris      | Sjoerd Langkemper  |\n| Tonimir Kisasondi |                |                    |\n\n## Другие участники и рецензенты\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\nЕсли Вы — участник проекта, но Вашего имени нет в приведенном выше списке, пожалуйста, зарегистрируйте issue на GitHub, для признания в будущих обновлениях.\n\nЧетвертая версия стандарта верификации требований к безопасности приложений опирается на предыдущие версии ASVS, начиная с первой, вышедшей в 2008 году, и до третьей, в 2016. Большая часть разделов оглавления и пунктов требований до сих пор присутствующих в ASVS, изначально были написаны Майком Боберски, Джеффом Уильямсом и Дэйвом Уичерсом, но участников было гораздо больше - спасибо им всем. Полные списки всех, кто внес свой вклад в более ранние версии, есть в соответствующих версиях документа.\n", "timestamp": "2025-10-24T11:40:00.774513"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x02-Preface.md", "content": "# Предисловие\n\nДобро пожаловать в Стандарт верификации требований к безопасности приложений (ASVS) версии 4.0. ASVS — это инициатива сообщества по созданию системы требований и мер безопасности, направленных на определение функциональных и нефункциональных мер безопасности, необходимых при проектировании, разработке и тестировании современных web-приложений и web-сервисов.\n\nВерсия 4.0.3 — третья редакция для версии 4.0, предназначенная для исправления орфографических ошибок и уточнений без внесения существенных изменений, таких как значительные изменения, усиление или добавление требований. Однако некоторые требования, возможно, были слегка ослаблены там, где мы сочли это целесообразным, а некоторые избыточные требования были удалены (без изменения сквозной нумерации).\n\nASVS v4.0 — кульминация усилий профессионального сообщества и отзывов экспертов за последнее десятилетие. Мы попытались упростить внедрение ASVS для различных вариантов его использования на протяжении жизненного цикла разработки безопасного программного обеспечения.\n\nМы понимаем, что, скорее всего, никогда не сможем достичь полного согласия по содержанию любого стандарта, включая ASVS. Анализ рисков всегда в какой-то степени субъективен, что создает трудности при попытке обобщить его с помощью универсального стандарта. Однако мы надеемся, что последние обновления, внесенные в эту версию, станут шагом в правильном направлении и улучшат концепции, представленные в этом важнейшем профессиональном стандарте.\n\n## Что нового в версии 4.0\n\nНаиболее значительным изменением в этой версии является принятие Стандарта по цифровой идентификации NIST 800-63-3, в котором представлены современные, основанные на доказательствах, и продвинутые способы аутентификации. Хотя мы и ожидаем некоторого сопротивления согласованию с новым стандартом, считаем, что это согласование важно, особенно с известным стандартом безопасности приложений, который основан на доказательствах.\n\nСтандарты информационной безопасности должны стремиться свести к минимуму количество уникальных требований, чтобы соблюдающим их организациям не приходилось принимать решения о конкурирующих или несовместимых мерах. OWASP Top 10 2017, а теперь и OWASP Application Security Verification Standard теперь соответствуют NIST 800-63 в части аутентификации и управления сессиями. Мы призываем всех, кто разрабатывает стандарты, сотрудничать с нами, NIST и другими, чтобы прийти к общепринятому набору мер безопасности приложений, для обеспечения максимальной безопасности и минимизации затрат на соблюдение требований..\n\nРазделы и пункты ASVS 4.0 были полностью перенумерованы. Новая схема нумерации позволила нам устранить пробелы в исчезнувших и разбить на части более длинные главы, чтобы свести к минимуму количество мер, которые должны соблюдать разработчики. Например, если приложение не использует JWT, то весь раздел о JWT в управлении сессиями для него неприменим.\n\nНовым в версии 4.0 является сопоставление с Common Weakness Enumeration (CWE), — одна из наиболее частых просьб, которые мы получали за последнее десятилетие. Сопоставление с CWE позволяет разработчикам инструментов и тем, кто использует ПО управления уязвимостями, сопоставлять результаты других инструментов и предыдущих версий ASVS с этой и более поздними версиями. Чтобы освободить место для записи CWE, нам пришлось удалить столбец «Версия», который, поскольку мы полностью перенумеровали пункты, утратил смысл. Не каждый пункт в ASVS имеет связанный CWE, но, поскольку CWE имеет большое количество дублей, мы попытались использовать наиболее часто используемые, а не наиболее близкие совпадения. Пункты требований не всегда удается сопоставить с недостатками. Мы приветствуем продолжающуюся дискуссию между сообществами CWE и информационной безопасности в целом по устранению этого пробела.\n\nМы старались всесторонне удовлетворить и превзойти требования стандартов OWASP Top 10 2017 и OWASP Proactive Controls 2018. Поскольку OWASP Top 10 2017 — это минимальный уровень, то во избежание небрежности, мы умышленно присвоили всем требованиям Top 10 первый уровень соответствия, упрощая приверженцам OWASP переход к данному стандарту.\n\nМы стремились к тому, чтобы первый уровень соответствия ASVS 4.0 полностью охватывал раздел 6.5 стандарта PCI DSS 3.2.1, в части проектирования и разработки приложений, тестирования, анализа безопасности кода и тестов на проникновение. Это потребовало включения в раздел V5 требований по переполнению буфера и небезопасным операциям с памятью, а в V14 - по небезопасным флагам компиляции, связанным с памятью, в дополнение к существующим требованиям к проверке приложений и web-сервисов.\n\nМы завершили переход ASVS от мер безопасности, применимых только к монолитным архитектурам, к обеспечению безопасности для всех современных приложений и API. Во времена бессерверных API, мобильных устройств, облачных сред, контейнеров, CI/CD и DevSecOps, мы не можем продолжать игнорировать современную архитектуру приложений. Современные приложения разрабатываются совсем иначе, чем те, что создавались во время выпуска первой версии ASVS в 2009 году. ASVS всегда должен ориентироваться на будущее, чтобы мы могли давать разумные советы нашей основной аудитории — разработчикам. Мы разъяснили или исключили требования, предполагающие, что приложения выполняются в системах, принадлежащих только одной организации.\n\nИз-за размера ASVS 4.0, а также из-за нашего желания стать базовым стандартом для других инициатив ASVS, мы отказались от \"мобильной\" главы в пользу стандарта исследования безопасности мобильных приложений (MASVS). Приложение «Интернет вещей» появится в будущем стандарте IoT ASVS в рамках проекта OWASP Internet of Things. Мы включили предварительную версию IoT ASVS в Приложение C. Мы благодарим команду OWASP Mobile и команду проекта OWASP IoT за их поддержку ASVS и надеемся на сотрудничество с ними в будущем при разработке дополнительных стандартов.\n\nНаконец, мы устранили дубли и убрали менее результативные меры. Со временем ASVS стал комплексным набором мер, но не все они одинаково полезны для разработки безопасного ПО. Работа по устранению неэффективных мер продолжится. В будущей версии ASVS Common Weakness Scoring System (CWSS) поможет расставить приоритеты над мерами, которые действительно важны, и от которых следует отказаться.\n\nНачиная с версии 4.0, ASVS будет сосредоточен исключительно на том, чтобы стать ведущим стандартом для web-приложений и сервисов, охватывая традиционную и современную архитектуры приложений, а также гибкие методы обеспечения безопасности (Agile) и культуру DevSecOps.\n", "timestamp": "2025-10-24T11:40:00.822455"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x03-Using-ASVS.md", "content": "# Использование ASVS\n\nУ ASVS две основные задачи:\n\n* помочь организациям разрабатывать и поддерживать безопасные приложения.\n* согласовать между собой требования потребителей и предложения разработчиков инструментов и поставщиков услуг кибербезопасности.\n\n## Уровни соответствия ASVS\n\nСтандарт верификации требований к безопасности приложений определяет три уровня соответствия, каждый из которых усиливает требования предыдущего.\n\n* Первый уровень ASVS соответствует низкому уровню безопасности и полностью поддается тестированию на проникновение.\n* Второй уровень ASVS предназначен для приложений, содержащих конфиденциальную информацию, и являются рекомендуемым для большинства приложений.\n* Третий уровень ASVS предназначен для наиболее критичных приложений, выполняющих финансовые транзакции, содержащих медицинские данные и других приложений, требующих высочайшего уровня доверия.\n\nКаждый уровень ASVS содержит перечень требований безопасности. Каждое из этих требований также может быть сопоставлено с функциями и возможностями, специфичными для безопасности, которые должны быть встроены разработчиками в программное обеспечение.\n\n![Уровни ASVS](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"Уровни ASVS\")\n\nРис. 1 — Уровни OWASP ASVS версии 4.0\n\nПервый уровень — единственный, который можно полностью протестировать на проникновение вручную. Все остальные требуют доступа к документации, исходному коду, конфигурации и к специалистам, участвующим в процессе разработки. Однако, даже если L1 и допускает тестирование по принципу «черного ящика» (без документации и исходных кодов), он не является достаточным для достижения соответствия, и на этом не следует останавливаться. У злоумышленников огромный запас времени, а большинство тестов на проникновение проводятся в течение пары недель. Защитникам необходимо встраивать меры безопасности, защищать, находить и устранять все уязвимости, а также обнаруживать злоумышленников и реагировать на них в разумные сроки. У злоумышленники по сути бесконечное время, и для успеха им требуется только одно слабое звено в защите, одна уязвимость или недостаток обнаружения. Тестирование методом «черного ящика», часто выполняемое в конце разработки, наспех или не выполняемое вовсе, совершенно не справляется с этой асимметрией.\n\nЗа последние 30 с лишним лет тестирование методом \"черного ящика\" снова и снова доказывало, что оно пропускает критические проблемы безопасности, которые непосредственно приводили ко все более массовым нарушениям. Мы настоятельно рекомендуем использовать широкий спектр инструментов по анализу защищённости, включая замену тестов на проникновение на основе исходного кода (гибридными) тестами на проникновение на L1 с полным доступом к разработчикам и документации на протяжении всего процесса разработки. Финансовые регуляторы не начинают внешний финансовый аудит без доступа к бухгалтерским книгам, выборкам транзакций и к людям, их выполняющим. Государства и профессиональные сообщества должны требовать такого же уровня прозрачности и в области разработки программного обеспечения.\n\nМы настоятельно рекомендуем использовать инструменты анализа в самом процессе разработки. DAST и SAST могут быть встроены в конвейер сборки, чтобы налету обнаруживать проблемы безопасности, которых не должно быть.\n\nАвтоматизированные инструменты и online-сканирование не в состоянии выполнить более половины требований ASVS без помощи человека. Если требуется комплексная автоматизация тестирования для каждой сборки, то используется комбинация модульных и интеграционных тестов, а также online-сканирование, инициированное сборкой. Тестирование недостатков бизнес-логики и контроля доступа возможно только с помощью человека. Оно должно быть встроено в модульные и интеграционные тесты.\n\n## Как применять этот стандарт\n\nОдин из лучших способов применения ASVS — использовать его в качестве основы для создания чек-листа безопасной разработки для вашего приложения, платформы или организации. Адаптация ASV к вашим сценариям использования позволит уделять больше внимания требованиям безопасности, которые наиболее важны для ваших проектов и сред.\n\n### Уровень 1 — Первые шаги, автоматизированный или поверхностный\n\nПриложение достигает первого уровня ASVS, если оно адекватно защищает от уязвимостей безопасности, которые легко обнаружить, которые включены в список OWASP Top 10 и другие подобные списки.\n\nПервый уровень — это абсолютный минимум, к которому должны стремиться все приложения без исключений. Он также полезен в качестве первого шага в многоэтапной работе или когда приложения не хранят и не обрабатывают конфиденциальную информацию, и, следовательно, не нуждаются в более строгих мерах безопасности второго или третьего уровня. Элементы управления уровня 1 могут быть проверены либо автоматически с помощью инструментов, либо просто вручную без доступа к исходному коду. Мы считаем уровень 1 минимально необходимым для всех приложений.\n\nЧаще всего, угрозы для приложения исходят от нарушителей, которые пользуются простыми, не требующими больших усилий методами для выявления легко обнаруживаемых и легко эксплуатируемых уязвимостей. Совсем другое дело, когда приложение атакует заинтересованный и опытный злоумышленник. Если данные, обрабатываемые вашим приложением, имеют большую ценность, вы вряд ли захотите останавливаться на первом уровне.\n\n### Уровень 2 — Большинство приложений\n\nПриложение достигает второго уровня ASVS, если оно адекватно защищает от большинства рисков, связанных с современным программным обеспечением.\n\nУровень 2 гарантирует наличие и эффективность применения мер безопасности в приложении. Уровень 2 обычно подходит для приложений, которые обрабатывают важные бизнес-транзакции, в том числе те, которые обрабатывают данные о здоровье, решают критически важные для бизнеса задачи, или в отраслях, где целостность является значимым аспектом для защиты бизнеса, например, в игровой индустрии, чтобы помешать читерам и взлому игр.\n\nУгрозы для приложений уровня 2 обычно представляют собой квалифицированных и мотивированных нарушителей, сосредоточенных на конкретных целях, использующих инструменты и методы, которые хорошо отработаны и эффективны при обнаружении и использовании слабых мест в приложениях.\n\n### Уровень 3 - Высокая стоимость, надежность или безопасность\n\nТретий уровень ASVS — самый высокий в рамках ASVS. Этот уровень обычно необходим для приложений, требующих серьезных гарантий безопасности, например, в таких областях, как оборона, здравоохранение, критическая инфраструктура и т.д.\n\nОрганизациям может потребоваться ASVS уровня 3 для приложений, выполняющих критически важные функции, где сбой может существенно повлиять на непрерывность работы и даже на ее сохранение как организации. Ниже приводится примерное руководство по применению ASVS уровня 3. Приложение достигает третьего (продвинутого) уровня ASVS, если оно адекватно защищено от серьезных уязвимостей безопасности приложений, а также соответствует концептуальной архитектуре безопасности приложений.\n\nПриложение на третьем уровне ASVS требует более глубокого анализа архитектуры, разработки и тестирования, чем на других уровнях. Защищенное приложение обычно имеет модульную структуру (для обеспечения отказоустойчивости, масштабируемости и, прежде всего, уровней безопасности), при этом каждый модуль (отделенный от других сетевым подключением и / или физически) выполняет свои собственные задачи по обеспечению безопасности (эшелонированная защита), которые должны быть должным образом задокументированы. Эти задачи включают меры обеспечения конфиденциальности (шифрование), целостности (например, транзакционной, форматно-логический контроль), доступности (например корректная работа под нагрузкой), аутентификация (в том числе между системами), авторизация и аудит (ведение журнала событий безопасности).\n\n## Применение ASVS на практике\n\nРазные угрозы имеют разную мотивацию. В отдельных отраслях имеются уникальные информационные и технологические ресурсы или отраслевые регуляторные требования.\n\nОрганизациям настоятельно рекомендуется внимательно изучить риски, присущие характеру их бизнеса, и на их основе и с учетом бизнес-требований определить соответствующий уровень ASVS.\n\n## Как ссылаться на требования ASVS\n\nКаждое требование имеет идентификатор в формате `<глава>.<раздел>.<требование>` где каждый элемент является числом, например: `1.11.3`.\n\n* Значение `<глава>` соответствует главе, в которой находится это требование, например: все требования `1.#.#` находятся в главе `Архитектура`.\n* Значение `<раздел>` соответствует разделу в этой главе, где находится это требование, например: все требования `1.11.#` находятся в разделе `Бизнес-логика` главы `Архитектура`.\n* Значение `<требование>` указывает на конкретное требование в главе и разделе, например: `1.11.3`, которым в версии 4.0.3 этого стандарта является:\n\n> Убедитесь, что все критичные потоки бизнес-логики, включая аутентификацию, управление сессиями и контроль доступа, являются безопасными с точки зрения их параллельного выполнения и устойчивыми к условиям гонки, вызванной разницей между состояниями приложения в момент проверки и в момент использования (TOCTOU).\n\nИдентификаторы требований могут меняться от версии к версии, поэтому желательно, чтобы другие документы, отчеты или инструменты использовали формат: `v<версия>-<глава>.<раздел>.<требование>`, где: 'версия' это метка версии ASVS. Например: `v4.0.3-1.11.3` будет означать 3-е требование в разделе 'Бизнес-логика' главы 'Архитектура' в версии 4.0.3. (Резюмируя, `v<версия>-<идентификатор_требования>`.)\n\nПримечание. Буква `v`, предшествующая версии, должна быть в нижнем регистре.\n\nСчитается, что если идентификаторы указаны без элемента `v<версия>`, то они относятся к последней версии стандарта. Очевидно, что по мере развития и изменения стандарта это станет проблематичным, поэтому авторы и разработчики должны включать элемент версии.\n\nСписки требований ASVS доступны в форматах CSV, JSON и других, которые могут оказаться полезными для справки или использования в программах.\n", "timestamp": "2025-10-24T11:40:00.891786"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x04-Assessment_and_Certification.md", "content": "# Оценка и сертификация\n\n## Позиция OWASP в отношении сертификатов и знаков доверия ASVS\n\nOWASP, будучи независимой от поставщиков некоммерческой организацией, в настоящее время не сертифицирует разработчиков, аудиторов или программное обеспечение.\n\nПодобные заверения, знаки доверия или сертификаты официально не контролируются, не регистрируются и не сертифицируются OWASP, поэтому организация, полагающаяся на них, должна проявлять осторожность в отношении доверия к любой третьей стороне или знаку доверия, претендующему на сертификацию ASVS.\n\nЭто не должно препятствовать предлагать такие услуги по обеспечению гарантий, если они не претендуют на официальную сертификацию OWASP.\n\n## Руководство для сертифицирующих организаций\n\nСтандарт верификации требований к безопасности приложений может использоваться в качестве открытой книги, подразумевая открытый и неограниченный доступ к ключевым ресурсам, таким как архитекторы и разработчики, проектная документация, исходный код, санкционированный доступ к тестовым системам (включая доступ к одной или нескольким учетным записям в каждой роли), особенно для проверок на L2 и L3.\n\nИсторически так сложилось, что при тестировании на проникновение и анализе безопасности кода проблемы учитывались в виде исключения, то есть в окончательный отчет попадали только неудачные тесты. Сертифицирующая организация должна включать в отчет область исследования (особенно, если ключевой компонент, например, single sign-on, остается за ее рамками), сводку результатов тестирования, включая пройденные и непройденные тесты, с четкими указаниями, как устранить причины по непройденным тестам.\n\nНекоторые требования стандарта могут быть неприменимы к тестируемому приложению. Например, если вы предоставляете потребителям REST API без сохранения состояния без реализации клиента, то многие требования раздела V3 \"Управление сессиями\" напрямую неприменимы. В таких случаях сертифицирующая организация может по-прежнему заявлять о полном соответствии ASVS, но должна чётко указывать в отчете причину неприменимости исключенных требований.\n\nВключение подробных рабочих документов, снимков или видео экрана, сценариев эксплуатации уязвимостей и т.п. в отчет о тестировании, считается стандартной практикой и может быть действительно полезным в качестве доказательств для сомневающихся разработчиков. Недостаточно просто запустить инструмент и сообщить о несоблюдении требования; само по себе это еще не является достаточных основанием того, что все недостатки подтверждены и тщательно протестированы. В случае спора должны быть представлены достаточные аргументы, чтобы продемонстрировать, что каждое требование было действительно верифицировано.\n\n### Методы тестирования\n\nСертифицирующие организации свободны в выборе подходящего метода (методов) тестирования, но должны явно указать их в отчете.\n\nВ зависимости от тестируемого приложения и уровня требований разные методы могут обеспечить равную уверенность в результатах. Например, механизм форматно-логического контроля входных данных можно проверить либо с помощью теста на проникновение, либо, анализируя исходный код.\n\n#### Роль инструментов автоматизированного тестирования безопасности\n\nРекомендуется использовать автоматизированные инструменты тестирования на проникновение, чтобы обеспечить как можно больший охват.\n\nНевозможно провести проверку ASVS полностью только с помощью автоматизированных инструментов. Хотя подавляющее большинство требований в L1 может быть выполнено с помощью автоматизированных тестов, все же остаются требования, не поддающиеся автоматизации.\n\nПожалуйста, обратите внимание, что границы между автоматизированным и ручным тестированием размываются по мере совершенствования безопасности приложений. Автоматизированные инструменты часто настраиваются вручную экспертами, а при ручном тестировании часто используется широкий спектр автоматизированных инструментов.\n\n#### Роль тестирования на проникновение\n\nВ версии 4.0 мы решили сделать L1 полностью тестируемым на проникновение без доступа к исходному коду, документации или разработчикам. Два требования к ведению журнала, которые необходимы для соответствия пункту A10 в OWASP Top 10 2017, потребуют интервью, снимков экрана или других доказательств (как и в OWASP Top 10 2017). Однако тестирование без доступа к необходимой информации не является идеальным методом, поскольку при этом упускается возможность проверки исходного кода, выявления угроз и отсутствующих мер защиты, а также выполнения гораздо более тщательного тестирования в более короткие сроки.\n\nТам, где это возможно, при выполнении оценки на L2 или L3 требуется доступ к разработчикам, документации, коду и к тестовому приложению с тестовыми данными. Тестирование на проникновение, проводимое на этих уровнях, требует такого уровня доступа, который мы называем «гибридным анализом» или «гибридными тестами на проникновение».\n\n## Другие варианты использования ASVS\n\nПомимо использования для оценки безопасности приложения, мы предлагаем ряд других потенциальных применений для ASVS.\n\n### Как подробное руководство по архитектуре безопасности\n\nОдним из наиболее распространенных применений Стандарта верификации безопасности приложений является использование в качестве ресурса для архитекторов безопасности. В Sherwood Applied Business Security Architecture (SABSA) отсутствует большой пласт информации, необходимой для проведения тщательного анализа архитектуры безопасности приложений. ASVS можно использовать для восполнения этого пробела, давая возможность выбирать более эффективные меры для решения общих проблем, таких как архитектурные шаблоны защиты данных и стратегии контроля входных данных.\n\n### Как чек-лист по безопасному программированию\n\nМногие организации могут извлечь выгоду из внедрения ASVS, выбрав один из трех уровней или адаптируя ASVS под себя, изменяя требования для каждого уровня риска приложения в зависимости от нужд своей компании. Мы поощряем эту адаптацию, если поддерживается отслеживаемость, т.е., если приложение удовлетворяет требованию 4.1 для адаптированной версии, значит оно удовлетворяет и требованию стандарта по мере его развития.\n\n### Как руководство по автоматизированному модульному и интеграционному тестированию\n\nASVS создавался таким, чтобы его можно было легко протестировать, за исключением требований к архитектуре и вредоносному коду. Благодаря модульным и интеграционным тестам, которые проверяют характерные случаи фаззинга и недокументированного использования, приложение с каждой сборкой становится практически самотестируемым. Например, для набора тестов для контроллера входа в систему можно разработать дополнительные тесты, проверяющие атрибут username на совпадение с наиболее распространенными именами пользователей по умолчанию, перебор учетных записей, LDAP- и SQL-инъекции, а также XSS. Аналогично, проверка атрибута password должна включать перебор самых распространенных паролей, оценку длины пароля, вставку нулевого байта, удаление этого атрибута, XSS и многое другое.\n\n### Как курс по безопасной разработке\n\nASVS также можно использовать для определения характеристик защищенного программного обеспечения. Многие \"курсы безопасной разработки\" — это просто курсы по этичному хакингу с легким намеком на советы по безопасной разработке. Не факт, что это как-то поможет разработчикам писать более безопасный код. Вместо этого курсы по безопасной разработке могут использовать ASVS с упором на упреждающие меры, описанные в ASVS, а не на Top 10 того, что делать не надо.\n\n### Как движущая сила к Agile-процессу безопасности приложений\n\nASVS можно использовать в процессе Agile-разработки в качестве основы для определения задач, которые должны быть реализованы, чтобы получить безопасный продукт. Один из подходов может быть следующим: начиная с первого уровня, проверить конкретное приложение или систему на соответствии с требованиями ASVS для указанного уровня, определить недостающие меры безопасности, и поставить задачи на их доработку. Это помогает расставить приоритеты конкретных задач и делает безопасность видимой в Agile-процессе. Это также может быть использовано для определения приоритетов задач анализа и аудита. Каждое требование ASVS может быть движущей силой для проведения рефакторинга или аудита конкретным участником или командой, и отображаться как его \"долг\" в очереди задач, который необходимо рано или поздно выполнить.\n\n### Как руководство по приобретению безопасного программного обеспечения\n\nASVS — это отличное руководство по приобретению безопасного программного обеспечения или заказных услуг по его разработке. Заказчику достаточно указать требование, что программное обеспечение, которое он хочет приобрести, должно быть разработано на уровне ASVS LX, и потребовать, чтобы Исполнитель доказал, что оно ему соответствует. Это неплохо сочетается с Приложением OWASP к Договору на безопасное программное обеспечение.\n", "timestamp": "2025-10-24T11:40:00.987109"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x10-V1-Architecture.md", "content": "# V1 Архитектура, проектирование и моделирование угроз\n\n## Задачи контроля\n\nВо многих организациях архитектура безопасности сегодня стала почти забытым занятием. Слава корпоративных архитекторов в эпоху DevSecOps проходит. Область безопасности приложений должна подхватить это знамя, и, адаптируясь к принципам Agile, представить свои передовые принципы архитектуры безопасности разработчикам программного обеспечения. Архитектура — это не реализация, а способ осмысления проблемы, которая потенциально имеет много разных решений и не имеет единственного правильного ответа. Часто безопасность считается негибкой, требуя, чтобы разработчики исправляли код определённым образом, однако разработчики часто могут знать гораздо лучший способ решения. Не существует единого простого решения в архитектуре, и делать вид, что это не так, — медвежья услуга разработчикам программного обеспечения.\n\nКонкретная реализация web-приложения, возможно, будет постоянно меняться на протяжении всего его жизненного цикла, но общая архитектура, скорее всего, будет меняться редко, и развиваться медленно. Так же и архитектура безопасности — аутентификация нужна нам сегодня, и завтра, и через пять лет. Если мы примем правильные решения сегодня, то сможем сэкономить много сил, времени и средств, выбрав и повторно используя архитектурно-совместимые решения. Например, лет десять назад многофакторная аутентификация почти не применялась.\n\nЕсли бы разработчики вложились в единую защищённую модель поставщика удостоверений, такую как федеративные удостоверения SAML, её можно было бы обновить, включив только новые требования, например, из стандарта NIST 800-63, без изменения интерфейсов исходного приложения. Если множество приложений имеют общую архитектуру безопасности и, следовательно, общие компоненты, то все они получат выгоду от этого обновления одновременно. Однако SAML не всегда будет лучшим или наиболее подходящим решением для аутентификации — возможно, его придётся заменить другими решениями по мере изменения требований. Подобные изменения либо сложны, либо настолько дорогостоящи, что требуют полной переделки, либо совершенно невозможны без архитектуры безопасности.\n\nВ этой главе ASVS охватывает основные аспекты правильной архитектуры безопасности: доступность, конфиденциальность, целостность обработки, неотказуемость и конфиденциальность. Каждый из этих принципов безопасности должен быть встроен во все приложения. Крайне важно «двигаться влево», начиная с поддержки разработчиков с помощью чек-листов безопасного программирования, наставничества и обучения, разработки и тестирования, сборки, развёртывания, конфигурирования и эксплуатации, и заканчивая приёмо-сдаточным тестированием, чтобы убедиться, что все необходимые меры безопасности приняты и они работают. Раньше этот последний шаг и был всем, что мы делали. Но теперь этого недостаточно, ведь разработчики выпускают код в промышленную среду десятки или сотни раз в день. Специалисты по безопасности приложений должны идти в ногу с гибкими методами, что означает изучение инструментов разработки, обучение программированию и совместную работу с разработчиками, а не критику проекта спустя месяцы после того, как все остальные продвинулись дальше.\n\n## V1.1 Жизненный цикл разработки безопасного ПО\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.1.1** | Убедитесь в использовании безопасного жизненного цикла разработки программного обеспечения, который обеспечивает безопасность на всех этапах разработки. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | Убедитесь в применении моделирования угроз для каждого изменения дизайна или планирования спринта, чтобы выявлять угрозы, планировать контрмеры, способствовать надлежащему реагированию на риски и управлять тестированием безопасности. | | ✓ | ✓ | 1053 |\n| **1.1.3** | Убедитесь, что все пользовательские истории и функции содержат функциональные ограничения безопасности. Например, такие: \"Как пользователь, я должен иметь возможность просматривать и редактировать свой профиль, но не должен иметь возможности просматривать или редактировать чужой профиль\". | | ✓ | ✓ | 1110 |\n| **1.1.4** | Убедитесь в наличии документации и обоснования для всех границ доверия приложения, его компонентов и значимых информационных взаимодействий. | | ✓ | ✓ | 1059 |\n| **1.1.5** | Проверьте описание концептуальной архитектуры приложения, связанных с ним внешних систем и анализ их безопасности. ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | Проконтролируйте наличие централизованных, простых в реализации, проверенных, безопасных и переиспользуемых мер безопасности, чтобы избежать их дублирования или, наоборот, отсутствия, а также неэффективных или небезопасных мер. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | Убедитесь в наличии чек-листа для безопасной разработки, требований, политик и стандартов безопасности, а также в их доступности для разработчиков и тестировщиков. | | ✓ | ✓ | 637 |\n\n## V1.2 Аутентификация\n\nПри проектировании системы аутентификации не имеет значения, насколько безопасна ваша многофакторная аутентификация, если злоумышленник может сбросить пароль учетной записи, просто позвонив в контакт-центр, и ответив на общеизвестные вопросы. При подтверждении личности все пути аутентификации должны иметь одинаковую силу.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.2.1** | Убедитесь в использовании всеми компонентами приложений, служб и серверов уникальных или специальных учетных записей операционной системы с низким уровнем привилегий. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | Убедитесь, что взаимодействие между всеми компонентами приложения, включая API, промежуточное ПО и уровень хранения данных, аутентифицировано. Компоненты должны иметь минимально необходимые привилегии. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | Убедитесь, что приложение использует единый утвержденный механизм аутентификации, который может быть дополнен включением строгой аутентификации, а также обеспечивает адекватное журналирование и мониторинг для обнаружения нарушений политик безопасности или взлома учетной записи. | | ✓ | ✓ | 306 |\n| **1.2.4** | Убедитесь, что все пути аутентификации и API идентификации реализуют заданный уровень безопасности, и что более слабые альтернативы отсутствуют. | | ✓ | ✓ | 306 |\n\n## V1.3 Управление сессиями\n\nМесто вставки для будущих архитектурных требований.\n\n## V1.4 Контроль доступа\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.4.1** | Убедитесь, что контроль доступа применяется в пределах контролируемоой зоны (т.е. на шлюзах безопасности, серверах и бессерверных функциях). Нельзя применять контроль доступа на стороне клиента. | | ✓ | ✓ | 602 |\n| **1.4.2** | [УДАЛЕНО, НЕВОЗМОЖНО ПРОВЕРИТЬ] | | | | |\n| **1.4.3** | [УДАЛЕНО, ДУБЛИРУЕТ 4.1.3] | | | | |\n| **1.4.4** | Убедитесь, что приложение использует единый и тщательно протестированный механизм контроля доступа для доступа к защищенным данным и ресурсам. Все запросы должны проходить через этот единый механизм, чтобы избежать копирования и вставки или небезопасных альтернативных путей. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | Убедитесь, что при управлении доступом на основе атрибутов или функций, код проверяет доступ пользователя к функции/данным, а не только его роль. Разрешения в любом случае должны выдаваться в соответствии с ролью. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 Входные и выходные данные\n\nВ версии 4.0 мы отошли от термина «серверная часть» как термина, обозначающего границу доверия. Граница доверия как термин по-прежнему вызывает сомнения — контроль доступа в недоверенных браузерах или клиентских устройствах можно обойти. Однако в современных архитектурных концепциях смысл точки обеспечения доверия кардинально изменился. Поэтому, когда в ASVS используется термин «уровень доверенного сервиса», мы подразумеваем любую доверенную точку применения политики управления доступом, независимо от ее местоположения, например, это может быть микросервис, бессерверный API, серверная часть, доверенный API на клиентском устройстве, которое имеет доверенную загрузку, партнерские или внешние API и т.д.\n\nТермин «недоверенный клиент» здесь относится к технологиям на стороне клиента, которые отображают уровень представления, обычно называемый интерфейсным (front-end). Термин «сериализация» здесь относится не только к отправке данных по сети, например, массива значений или получению и чтению структуры JSON, но и к передаче сложных объектов, которые могут содержать логику, например, Data Transfer Objects, (DTO).\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.5.1** | Убедитесь, что требования к входным и выходным данным четко определяют, как обращаться с данными и обрабатывать их в зависимости от типа, содержимого и применимых законов, нормативных документов и других политик. | | ✓ | ✓ | 1029 |\n| **1.5.2** | Убедитесь, что сериализация не используется при взаимодействии с недоверенными клиентами. Если это невозможно, убедитесь, что применяются адекватные меры контроля целостности (и, при необходимости, шифрование при передаче конфиденциальных данных) для предотвращения атак десериализации, включая внедрение объектов. | | ✓ | ✓ | 502 |\n| **1.5.3** | Убедитесь, что форматно-логический контроль входных данных выполняется на уровне доверенного сервиса. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | Убедитесь, что кодировка и/или экранирование выходных данных проводится интерпретатором, для которого они предназначены, или непосредственно перед ним. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 Криптографическая защита\n\nПриложения должны разрабатываться в соответствии с утвержденной архитектурой криптографической защиты информационных ресурсов с учетом их категории конфиденциальности. Шифровать всё — это расточительство, а не шифровать вовсе — правовой нигилизм. Компромисс обычно находится во время архитектурного или концептуального проектирования, спринтов по дизайну. Разработка криптографии по ходу проекта или ее последующая модернизация обойдутся гораздо дороже, чем встроить ее с самого начала.\n\nАрхитектурные требования предъявляются ко всей кодовой базе, поэтому их трудно охватить модульными или интеграционными тестами. Требования к архитектуре требуют учета в стандартах разработки на протяжении всего жизненного цикла и должны учитываться на архитектуре безопасности, при оценке кода коллегами или на ретроспективах.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.6.1** | Убедитесь в наличии формализованной политики управления криптографическими ключами и что жизненный цикл криптографического ключа соответствует стандарту управления ключами, например NIST SP 800-57. | | ✓ | ✓ | 320 |\n| **1.6.2** | Убедитесь, что потребители криптографических сервисов защищают ключевой материал и другие секреты с помощью хранилища ключей (vault) или альтернатив на основе API. | | ✓ | ✓ | 320 |\n| **1.6.3** | Убедитесь, что все ключи и пароли являются заменяемыми и являются частью формализованного и легко воспроизводимого процесса шифрования чувствительных данных. | | ✓ | ✓ | 320 |\n| **1.6.4** | Убедитесь, что на уровне архитектуры секреты на стороне клиента, такие как симметричные ключи, пароли или API-токены, считаются по умолчанию небезопасными, и никогда не используются для защиты или доступа к конфиденциальным данным. | | ✓ | ✓ | 320 |\n\n## V1.7 Обработка ошибок, ведение журнала и аудит\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.7.1** | Убедитесь, что в системе используются единый подход и формат ведения журнала событий. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | Убедитесь, что журналы событий безопасности надежно передаются в предпочтительно удалённую систему для их дальнейшего анализа, обнаружения аномалий, оповещения соответствующих специалистов и эскалации. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 Защита информации и конфиденциальность\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.8.1** | Убедитесь, что все чувствительные данные идентифицированы и классифицированы по уровням защиты. | | ✓ | ✓ | |\n| **1.8.2** | Убедитесь, что каждому уровню защиты соответствует набор требований безопасности (целостность, конфиденциальность, сроки хранения и др.), и что эти требования удовлетворяются в архитектуре. | | ✓ | ✓ | |\n\n## V1.9 Передача данных\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.9.1** | Убедитесь, что приложение шифрует обмен данными между компонентами, особенно когда эти компоненты находятся в разных контейнерах, системах, сайтах или у разных провайдеров облачной инфраструктуры. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | Убедитесь, что компоненты приложения аутентифицируют каждую сторону взаимодействия, чтобы предотвратить атаки \"человек посередине\". Например, компоненты приложения должны проверять сертификаты и цепочки доверия TLS. | | ✓ | ✓ | 295 |\n\n## V1.10 Вредоносный код\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.10.1** | Убедитесь, что используется система управления исходным кодом и применяются процедуры, гарантирующие, что регистрация кода сопровождается отчетами о проблемах или заявками на изменение. Система управления исходным кодом должна контролировать доступ и идентифицировать пользователей, чтобы можно было отслеживать каждое изменение кода. | | ✓ | ✓ | 284 |\n\n## V1.11 Бизнес-логика\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.11.1** | Проверьте определение и документацию на компоненты приложения с точки зрения бизнес-функций или функций безопасности, которые они обеспечивают. | | ✓ | ✓ | 1059 |\n| **1.11.2** | Убедитесь, что все ключевые потоки бизнес-логики, включая аутентификацию, управление сессиями и контроль доступа, не используются в несинхронизированном состоянии. | | ✓ | ✓ | 362 |\n| **1.11.3** | Убедитесь, что все критичные потоки бизнес-логики, включая аутентификацию, управление сессиями и контроль доступа, являются безопасными с точки зрения их параллельного выполнения и устойчивыми к условиям гонки, вызванной разницей между состояниями приложения в момент проверки и в момент использования (TOCTOU). | | | ✓ | 367 |\n\n## V1.12 Безопасная загрузка файлов\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.12.1** | [УДАЛЕНО, ДУБЛИРУЕТ 12.4.1] | | | | |\n| **1.12.2** | Убедитесь, что загружаемые пользователем файлы — если требуется их отображение или загрузка из приложения — сохраняются либо как MIME-type: application/octet-stream, либо из несвязанного домена, например из облачного хранилища файлов, Чтобы снизить риск воздействия XSS-векторов или других атак, связанных с загружаемыми файлами, применяется соответствующая политика безопасности контента (CSP). | | ✓ | ✓ | 646 |\n\n## V1.13 Архитектура API\n\nМесто вставки для будущих архитектурных требований.\n\n## V1.14 Безопасные конфигурации\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **1.14.1** | Контролируйте разделение компонентов с разными уровнями доверия с помощью шлюзов безопасности, правил брандмауэра, шлюзов API, обратных прокси-серверов, облачных групп безопасности и т.п. | | ✓ | ✓ | 923 |\n| **1.14.2** | Убедитесь, что при развертывании бинарных файлов на удаленных устройствах контролируются их сигнатуры, используются доверенные соединения и конечные точки из списка разрешенных. | | ✓ | ✓ | 494 |\n| **1.14.3** | Убедитесь, что конвейер сборки предупреждает об устаревших или небезопасных компонентах и предпринимает соответствующие действия. | | ✓ | ✓ | 1104 |\n| **1.14.4** | Убедитесь, что конвейер содержит этап автоматической сборки и проверки безопасного развертывания приложения, особенно если инфраструктура приложения определяется программно, например сценарием сборки в облачной среде. | | ✓ | ✓ | |\n| **1.14.5** | Убедитесь, что развертывание приложений проводится в «песочнице», контейнере и/или изолировано на сетевом уровне, чтобы сдержать нарушителя от атак на другие приложения, особенно когда они выполняют чувствительные или опасные действия, например, десериализацию. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | Убедитесь, что приложение не использует неподдерживаемые, небезопасные или устаревшие клиентские технологии, такие как подключаемые модули NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL или клиентские Java-апплеты. | | ✓ | ✓ | 477 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:40:01.079760"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x11-V2-Authentication.md", "content": "# V2 Аутентификация\n\n## Задачи контроля\n\nАутентификация — это действие по установлению или подтверждению подлинности кого-либо (или чего-либо) и того, что утверждения, сделанные человеком или устройством, верны, защищены от подмены и предотвращают восстановление или перехват паролей.\n\nКогда ASVS был впервые опубликован, имя пользователя и пароль были наиболее распространенной формой аутентификации (за исключением систем, содержащих сведения, составляющие государственную тайну). Многофакторная аутентификация (МФА) была широко известна в узких кругах специалистов, но редко применялась. По мере увеличения количества взломов идея о том, что имена пользователей каким-то образом конфиденциальны, а пароли неизвестны, оказалась несостоятельной (вместе с мерами безопасности, которые на ней основывались). Например, NIST 800-63 рассматривает имена пользователей и аутентификацию на основе знаний — Knowledge Based Authentication (KBA) — как общедоступную информацию; уведомления по SMS и электронной почте — как [«ограниченные» типы аутентификаторов](https://pages.nist.gov/800-63-FAQ/#q-b1), а все пароли — как предварительно взломанные. Эта реальность делает бесполезными аутентификаторы, основанные на знаниях, восстановление по SMS и электронной почте, историю паролей, сложность и контроль ротации. Эти меры и раньше были не очень полезными, часто вынуждая пользователей каждые несколько месяцев придумывать такие же слабые пароли, но когда счет взломанных учетных записей пошёл на миллиарды, пришло время двигаться дальше.\n\nИз всех глав ASVS больше всего изменились главы об аутентификации и управлении сессиями. Внедрение эффективной, основанной на фактических данных передовой практики для многих будет сложной задачей, и это совершенно нормально. Мы должны начать переход к пост-парольному будущему уже сейчас.\n\n## NIST 800-63 — современный стандарт аутентификации, основанный на доказательствах\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) — современный, основанный на фактических данных стандарт, который представляет собой наилучшие из имеющихся рекомендаций, независимо от их применимости. Стандарт полезен для всех организаций по всему миру, но особенно актуален для государственных служб в США и тех, кто работает с ними.\n\nПоначалу терминология NIST 800-63 может поначалу немного сбивать с толку, особенно если раньше вы пользовались только аутентификацией по имени пользователя и паролю. Чтобы описать достижения в области современной аутентификации необходимо ввести новую терминологию, которая станет общепринятой в будущем. Мы осознаем сложность ее понимания, пока сообщество не примет эти новые термины, поэтому в конце этой главы мы привели глоссарий, чтобы помочь вам. Мы перефразировали многие требования, чтобы лучше донести «дух» требования, а не его «букву». Например, в ASVS используется термин «пароль», тогда как в NIST — «запоминаемый секрет».\n\nРазделы ASVS V2 Аутентификация, V3 Управление сессиями, и, в меньшей степени, V4 Контроль доступа были адаптированы для соответствия с избранными мерами в NIST 800-63b, ориентированными на основные угрозы и часто эксплуатируемые недостатки аутентификации. Если требуется полное соответствие требованиям NIST 800-63, лучше обратиться непосредственно к NIST 800-63.\n\n### Выбор подходящего уровня доверия (AAL) в NIST\n\nВ Стандарте верификации требований к безопасности приложений мы попытались сопоставить ASVS L1 с требованиями NIST уровня доверия AAL1, L2 с AAL2 и L3 с AAL3. Однако выбор базовых мер в ASVS L1 не обязательно окажется правильным AAL для тестирования приложения или API. Например, если приложение относится к L3 или соответствует нормативным требованиям AAL3, следует выбрать L3 в главах V2 и V3 Управление сессиями. Выбор уровня доверия (AAL) для аутентификации, совместимого с NIST, должен соответствовать рекомендациям NIST 800-63b, изложенным в разделе *Выбор AAL* в [NIST 800-63b раздел 6.2](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA).\n\n## Условные обозначения\n\nПриложения могут превосходить требования текущего уровня, особенно если современные механизмы аутентификации входят в план развития приложения. Ранее для ASVS требовалась обязательная МФА, а в NIST нет требования обязательности. Поэтому в этой главе мы использовали дополнительные обозначения, чтобы указать, где ASVS поощряет, но не требует контроля:\n\n| Знак | Описание |\n| :--: | :-- |\n| | Не требуется |\n| o | Рекомендуется |\n| ✓ | Обязательно |\n\n## V2.1 Парольная защита\n\nПароли, называемые в NIST 800-63 «запоминаемыми секретами», включают в себя пароли, PIN-коды, узоры разблокировки, выбор правильного изображения из набора и парольные фразы. Они обычно считаются «чем-то, что вы знаете» и часто используются в качестве однофакторных аутентификаторов. Существуют серьезные проблемы с дальнейшим использованием однофакторной аутентификации, включая миллиарды действительных имен пользователей и паролей, раскрытых в Интернете, стандартные или слабые пароли, радужные таблицы и упорядоченные словари наиболее распространенных паролей.\n\nПриложения должны настоятельно рекомендовать пользователям включать многофакторную аутентификацию и позволять применять токены, которые у них уже есть, такие как FIDO или U2F, или ссылаться на поставщика услуг учетных данных (Credential Service Provider, CSP), который обеспечивает многофакторную аутентификацию.\n\nCSP предоставляют федеративную идентификацию для пользователей. У пользователей часто бывает множество цифровых удостоверений у разных CSP, например корпоративное на Azure AD, Okta или Ping Identity, и личные — на Яндекс, VK или Google, и это лишь некоторые из распространенных вариантов. Этот список не является рекомендацией этих компаний или их услуг, а просто побуждает разработчиков учитывать тот факт, что многие пользователи имеют несколько разных цифровых удостоверений. Организации должны рассмотреть возможность интеграции с существующими учётными записями пользователей в соответствии с профилем риска, который определяется доверием к удостоверениям, предоставляемым каждым CSP. Например, маловероятно, что какой-либо госорган примет учётную запись из социальной сети в качестве входа в государственную информационную систему, поскольку легко создать поддельную или одноразовую учётную запись, в то время как компания, разрабатывающая мобильные игры, вполне может интегрироваться с основными платформами социальных сетей, чтобы увеличить базу активных игроков.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.1.1** | Убедитесь, что устанавливаемые пользователем пароли имеют длину не менее 12 символов (после объединения пробелов, если они идут подряд). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | Убедитесь, что разрешены пароли длиной не менее 64 символов и что пароли длиной более 128 символов запрещены. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | Убедитесь, что отсутствует усечение пароля по длине. Идущие подряд несколько пробелов могут быть заменены одним. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | Убедитесь, что в паролях разрешены любые печатные символы Unicode, включая нейтральные к языку символы, такие как пробелы и эмодзи. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | Убедитесь, что пользователи могут менять свой пароль. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | Убедитесь, что при изменении пароля требуется ввести текущий и новый пароль пользователя. | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | Убедитесь (локально или с помощью внешнего API), что пароли, введенные при регистрации учетной записи, входе в систему или смене пароля, проверяются на вхождение в состав скомпрометированных (например, в 1000 или 10 000 наиболее распространенных). Для API при проверке следует использовать доказательство с нулевым разглашением или другой механизм, гарантирующий, что пароль не будет отправлен открытым текстом. Если пароль скомпрометирован, то приложение должно потребовать от пользователя ввести другой. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | Убедитесь в наличии индикатора надежности пароля, который поможет пользователям установить более стойкий пароль. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | Убедитесь, что правила составления пароля не ограничивают допустимый тип символов. Не должно быть никаких требований к наличию символов в верхнем или нижнем регистре, цифр или специальным символов. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | Убедитесь, что нет требований к периодической замене учетных данных или истории паролей. | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | Убедитесь, что разрешены функции вставки пароля в соответствующие поля экранных форм, а также утверждены браузерные расширения по управлению паролями и/или менеджеры паролей. | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | Убедитесь, что пользователь имеет возможность временно приоткрыть весь маскированный пароль, либо последний введенный символ (если такая функция не включена по умолчанию). | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\nПримечание: Цель предоставления пользователю возможности временно просматривать свой пароль или его последний символ состоит в том, чтобы повысить удобство ввода учётных данных, особенно для длинных паролей, парольных фраз и в менеджерах паролей.\n\n## V2.2 Базовые требования\n\nДля приложений, ориентированных на будущее необходима гибкость в отношении аутентификаторов.  Для включения дополнительных средств аутентификации в соответствии с предпочтениями пользователя, а также для планомерного вывода из эксплуатации устаревших или небезопасных средств аутентификации код приложения необходимо регулярно пересматривать.\n\nNIST рассматривает email и SMS как [«ограниченные» типы аутентификаторов](https://pages.nist.gov/800-63-FAQ/#q-b1), и они, видимо, будут исключены из NIST 800-63, и, следовательно, из ASVS в будущих версиях. Приложения должны запланировать отказ от использования электронной почты или SMS при аутентификации.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.2.1** | Убедитесь, что для снижения последствий от взлома учетных данных реализованы механизмы защиты от атак методом перебора и блокирования учетных записей. Такие механизмы включают запрет выбора наиболее распространенных скомпрометированных паролей, временную блокировку учетной записи, ограничение частоты запросов, CAPTCHA, увеличивающиеся интервалы между попытками, ограничение списка допустимых IP-адресов, или основанные на оценке рисков, например, ограничение по местоположению, времени входа и т.п. Убедитесь, что для одной учетной записи разрешено, не более ста неудачных попыток в час. | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | Убедитесь, что использование слабых механизмов аутентификации (таких как SMS и email) ограничивается проверкой второго фактора или подтверждением транзакций, а не заменой более безопасных механизмов. Убедитесь, что сначала предлагаются более надежные методы, а затем более слабые; что пользователи осведомлены о рисках; и что приняты надлежащие меры для ограничения рисков компрометации учётной записи. | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | Убедитесь, что после обновления учетных данных, например, сброса пароля, изменения электронной почты или адреса, входа в систему из неизвестного места, пользователям отправляются уведомления. Предпочтительно использование push-уведомлений, а не SMS или email, но при невозможности использования push-уведомлений  допустимы SMS или email, при условии, что в уведомлении не раскрывается конфиденциальная информация. | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | Убедитесь в устойчивости к фишингу. Для защиты используются многофакторная аутентификация; мобильные устройства с push-аутентификацией (позволяющие подтвердить или отклонить намерение пройти аутентификацию через push-уведомления). На более высоких уровнях AAL — сертификаты на стороне клиента. | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | Убедитесь, что если провайдер учётных данных (CSP) и аутентифицирующее приложение разделены, между их конечными точками используется протокол mTLS с взаимной аутентификацией. | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | Убедитесь в устойчивости к атакам повторного воспроизведения, требуя обязательного использования одноразовых паролей (OTP), криптографических аутентификаторов или проверочных кодов. | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | Убедитесь, что намерение пройти аутентификацию, подтверждается требованием ввести OTP или инициированным пользователем действием, например, нажатием кнопки на аппаратном ключе FIDO. | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 Жизненный цикл аутентификатора\n\nАутентификаторы — это пароли, программные и аппаратные токены и биометрические устройства. Жизненный цикл аутентификаторов имеет решающее значение для безопасности приложения. Если зарегистрировать учетную запись без подтверждения ее подлинности, то она не вызовет большого доверия. Для сайтов социальных сетей такие в порядке вещей, но для безопасности банковских приложений внимание к регистрации и выдаче учетных данных и устройств имеет решающее значение.\n\nПримечание: Пароли не должны иметь максимального срока действия или подлежать замене. Их следует регулярно проверять на предмет взлома, а не заменять.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.3.1** | Убедитесь, что создаваемые системой начальные пароли или коды активации формируются криптографически случайным образом. Они ДОЛЖНЫ иметь длину не менее 6 символов и МОГУТ содержать буквы и цифры, а срок их действия истекает через короткий период времени. Нельзя допускать, чтобы начальный пароль становился долгосрочным. | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | Убедитесь, что поддерживается регистрация и использование предоставленных пользователем устройств аутентификации, таких как токены U2F или FIDO. | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | Убедитесь, что для обновления аутентификаторов с ограниченным сроком действия инструкции по их замене направляются заблаговременно. | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 Хранение учётных данных\n\nАрхитекторам и разработчикам следует сверяться с этим разделом при создании или рефакторинге кода. Изложенные здесь требования можно полностью проверить, анализируя исходный код или с помощью модульных или интеграционных тестов безопасности. Тестирование на проникновение не сможет выявить ни одной из этих проблем.\n\nСписок утвержденных односторонних функций формирования ключей подробно описан в разделе [5.1.1.2 NIST 800-63 B](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver), и в [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile). Вместо этих вариантов требования к алгоритмам и длине ключа можно взять из актуальных версий [национальных стандартов](https://tc26.ru/standarts/).\n\nТребования этого раздела нельзя проверить пентестом, поэтому они не отмечены в L1. Однако этот раздел имеет жизненно важное значение для безопасности учетных данных в случае их кражи. Поэтому, если вы применяете ASVS в качестве руководства по архитектуре, разработке или чек-листа проверки исходного кода, пожалуйста, включите эти меры в L1 в вашей собственной версии.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.4.1** | Убедитесь, что пароли хранятся в форме, устойчивой к атакам в режиме offline. Пароли ДОЛЖНЫ быть «засолены» и хэшированы с использованием утвержденной односторонней функции формирования ключа или функции хеширования. При генерации хэша функция принимает на вход пароль, соль и показатель стоимости. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | Убедитесь, что соль имеет как минимум 32 бит энтропии и выбирается произвольно, чтобы минимизировать коллизии значений соли между сохраненными хэшами. Для КАЖДОГО пароля должны хранится уникальное значение соли и результирующий хэш. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | Убедитесь, что если используется функция PBKDF2, то количество итераций ДОЛЖНО быть настолько большим, насколько это позволяет производительность сервера верификации, но не менее 100000 итераций. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | Убедитесь, что working factor при использовании bcrypt велик настолько, насколько это позволяет производительность сервера верификации, но не менее 10. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | Убедитесь, что выполняется дополнительная итерация функции формирования ключа с использованием значения соли, которое является секретным и известно только верификатору. Соль формируется с помощью утвержденного генератора случайных битов в соответствии с NIST SP 800-90Ar1 и обеспечивается хотя бы минимальный уровень безопасности, указанный в последней редакции NIST SP 800-131A. Значение секретной соли ДОЛЖНО храниться отдельно от хэшированных паролей (в специализированном устройстве, например, в HSM (аппаратном модуле безопасности). | | ✓ | ✓ | 916 | 5.1.1.2 |\n\nВместо или в дополнение к приведенным в этом документе стандартам США  могут использоваться [национальные стандарты](https://tc26.ru/standarts/).\n\n## V2.5 Восстановление учётных данных\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.5.1** | Убедитесь, что сгенерированный системой начальный секрет активации или восстановления не отправляется пользователю в виде открытого текста. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | Убедитесь, что не используются подсказки для проверки пароля или аутентификация на основе знаний (так называемые «секретные вопросы»). | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | Убедитесь, что при восстановлении забытого пароля никоим образом не раскрывается текущий пароль. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | Убедитесь, что отсутствуют неперсонифицированные учетные записи или учетные записи по умолчанию (например, root, admin, sa, guest и т.п.). | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | Убедитесь, что при изменении фактора аутентификации пользователь был уведомлен об этом событии. | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | Убедитесь, что пути восстановления пароля (Забыли пароль? и др.) используют безопасный механизм, например, OTP на основе времени (TOTP), мобильное push-уведомление или иной механизм передачи по дополнительному каналу. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | Убедитесь, что в случае потери OTP или любого другого фактора аутентификация выполняется с тем же уровнем безопасности, что и во время регистрации. | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 Проверочные коды\n\nПроверочные коды – это предварительно сгенерированные списки секретных кодов, аналогичные номерам авторизации транзакций (TAN), кодам восстановления в социальных сетях или кодовым таблицам, содержащим набор случайных значений, безопасным образом распространяемые среди пользователей. Каждый код используется только один раз, и когда все они использованы, кодовая таблица становится недействительной. Этот тип аутентификаторов считается «чем-то, что у вас есть».\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.6.1** | Убедитесь, что проверочный код из кодовой таблицы можно использовать только один раз. | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | Убедитесь, что проверочные коды имеют достаточную случайность (112 бит энтропии). Если их энтропия меньше 112 бит, они «засолены» уникальной и случайной 32-битной солью и хэшированы с помощью утвержденной односторонней функции хэширования. | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | Убедитесь, что проверочные коды устойчивы к атакам offline. Например, что в них не используются предсказуемые значения. | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 Второй фактор аутентификации\n\nВ прошлом обычным механизмом проверки второго фактора аутентификации был email или SMS, содержащие ссылку для сброса пароля. Злоумышленники используют этот слабый механизм для сброса пароля, которые они хотят контролировать, например, захватывая учетную запись электронной почты жертвы, и используя обнаруженную там ссылку для установки собственного пароля. Есть способы обработки второго фактора и получше.\n\nБезопасный второй фактор — это физическое устройство, которое может обмениваться данными с верификатором по отдельному безопасному каналу. Пример — push-уведомления на мобильные устройства. Этот фактор считается «чем-то, что у вас есть». Когда пользователь хочет пройти аутентификацию, проверяющее приложение отправляет сообщение напрямую или косвенно через сторонний сервис. Сообщение содержит код аутентификации (обычно это случайное шестизначное число или модальное диалоговое окно подтверждения). Проверяющее приложение ожидает получения кода аутентификации по основному каналу и сравнивает значения полученного хэша с хэшем отправленного кода аутентификации. Если они совпадают, то верификатор может считать, что пользователь прошел аутентификацию.\n\nASVS предполагает, что мало кто будет разрабатывать с нуля новые факторы аутентификации, такие как push-уведомления, и, таким образом, следующие меры ASVS применяются к таким верификаторам, как API и приложения аутентификации, реализации единого входа. При разработке новых аутентификаторов, см. [&sect; 5.1.3.1](https://pages.nist.gov/800-63-3/sp800-63b.html#ooba).\n\nЭлектронная почта и VOIP в качестве второго фактора недопустимы. Аутентификация через ТСОП и SMS в настоящее время «ограничивается» в NIST и должна быть заменена на push-уведомления и т.п. Если вам необходимо использовать телефон или SMS как второй фактор, см. [&sect; 5.1.3.3](https://pages.nist.gov/800-63-3/sp800-63b.html#pstnOOB).\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.7.1** | Убедитесь, что по умолчанию не предлагается передавать второй фактор аутентификации открытым текстом через SMS или ТСОП. Т.е. сначала предлагаются более безопасные альтернативы, например, push-уведомления. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | Убедитесь, что срок действия запросов аутентификации, кодов или токенов, передаваемых по дополнительному каналу, истекает не позже, чем через 10 минут. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | Убедитесь, что запросы аутентификации, коды или токены, передаваемые по дополнительному каналу, можно использовать только один раз и только для исходного запроса аутентификации. | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | Убедитесь, что проверяющая и проверяемая стороны взаимодействуют по отдельному защищенному каналу. | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | Убедитесь, что проверяющая сторона сохраняет только хешированную версию кода аутентификации. | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | Убедитесь, что код аутентификации формируется криптографическим генератором случайных чисел, и содержит не менее 20 бит энтропии (обычно достаточно шестизначного случайного числа). | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 OTP\n\nОднофакторные одноразовые пароли (OTP) — это физические или программные токены, которые отображают постоянно меняющееся псевдослучайное одноразовые значение. Эти устройства делают фишинг (т.е. выдачу себя за другое лицо) трудным, но не невозможным. Этот тип аутентификатора считается «чем-то, что у вас есть». Многофакторные токены аналогичны однофакторным одноразовым паролям, но требуют ввода действующего PIN-кода, биометрической разблокировки, USB-токена, сопряжения по NFC или некоторого дополнительного значения (например, калькулятора подписи транзакций) для создания одноразового пароля.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.8.1** | Убедитесь, что основанные на времени одноразовые пароли (OTP) имеют конечный срок действия. | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | Убедитесь, что симметричные ключи, используемые для проверки отправленных одноразовых паролей, надежно защищены, например, с помощью аппаратного модуля безопасности (HSM) или безопасного хранилища ключей. предоставляемого операционной системой. | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.3** | Убедитесь, что при создании, заполнении и проверке одноразовых паролей используются утвержденные криптографические алгоритмы. | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | Убедитесь, что одноразовый пароль на основе времени можно использовать только один раз в течение срока действия. | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | Убедитесь, что если многофакторный OTP-токен на основе времени используется повторно в течение срока действия, то это событие регистрируется, токен не принимается, а владельцу устройства направляется уведомление. | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | Убедитесь, что физический генератор однофакторных одноразовых паролей может быть отозван в случае его кражи или утери. Убедитесь, что отзыв вступает в силу немедленно во всех сессиях, в которых выполнен вход, независимо от местоположения. | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | Убедитесь, что биометрические факторы аутентификации можно использовать только в качестве дополнительных, в сочетании с тем, что у вас есть, или с чем-то, что вы знаете. | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 Криптографический верификатор\n\nКриптографические ключи безопасности — это смарт-карты или ключи FIDO, к которым пользователь должен подключить или связать криптографическое устройство с компьютером для завершения аутентификации. Верификатор отправляет одноразовый запрос криптографическому устройству или приложению, которые вычисляют ответ на основе хранимого в тайне криптографического ключа.\n\nТребования к однофакторным и многофакторным криптографическим устройствам и приложениям одинаковы, поскольку успешная проверка криптографического аутентификатора подтверждает обладание фактором аутентификации.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.9.1** | Убедитесь, что криптографические ключи, используемые при проверке, хранятся в тайне и защищены от разглашения, например с помощью модуля доверенной платформы (TPM) или аппаратного модуля безопасности (HSM) или службы ОС, которая может использовать это защищенное хранилище. | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | Убедитесь, что одноразовая случайная строка (nonce) в запросе имеет длину не менее 64 бит и является уникальной статистически или в течение срока службы криптографического устройства. | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | Убедитесь, что при создании и проверке используются утвержденные криптографические алгоритмы. | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 Технические учётные записи\n\nЭтот раздел не поддается тестированию на проникновение, поэтому не имеет требований L1. Однако, если у вас в архитектуре, разработке или анализе безопасного кода используются секреты, пожалуйста, рассматривайте программное хранилище (такое как доверенное хранилище ключей в Java) как минимальное требование на первом уровне. Хранение секретов в открытом виде недопустимо ни при каких обстоятельствах.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **2.10.1** | Убедитесь, что секреты технических учетных записей не зависят от неизменных учётных данных, таких как пароли, ключи API или неперсонифицированные учетные записи с привилегированным доступом. | | ОС | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | Убедитесь, что если для аутентификации технической учётной записи требуется пароль, то она не является учётной записью по умолчанию. Например, во время установки иногда используются root /root или admin / admin. | | ОС | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | Убедитесь, что пароли хранятся с достаточной защитой для предотвращения атак восстановления offline, включая доступ к локальной системе. | | ОС | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | Убедитесь, что пароли, строки подключения к базам данных и внешним системам, векторы инициализации и внутренние секреты, а также ключи API хранятся в тайне, и не включаются в исходный код, не хранятся в репозиториях исходного кода. Такое хранилище ДОЛЖНО противостоять атакам в режиме offline. Для хранения паролей рекомендуется использовать безопасное хранилище программных ключей (L1), аппаратный TPM или HSM (L3). | | ОС | HSM | 798 | |\n\n## Дополнительные требования для госучреждений США\n\nУ госучреждений в США есть обязательные требования, касающиеся NIST 800-63. Стандарт верификации требований к безопасности приложений всегда старался охватить те 80% мер, которые применимы почти ко всем приложениям, а не те 20%, которые имеют ограниченную применимость. Сам ASVS является подмножеством NIST 800-63 в части уровней IAL1/2 и AAL1/2, но не полностью заменяет его, особенно в отношении уровней IAL3/AAL3.\n\nМы настоятельно рекомендуем госучреждениям США изучить и внедрить у себя NIST 800-63 во всей его полноте.\n\n## Определения и сокращения\n\n| Термин | Определение |\n| -- | -- |\n| CSP | Поставщик услуг учетных данных (Credential Service Provider) также называемый поставщиком цифровых удостоверений (Identity Provider) |\n| Аутентификатор | Код, который подтверждает подлинность пароля, токена, МФА, федеративного утверждения и т.д. |\n| Верификатор | Сущность, которая подтверждает личность заявителя, удостоверяя, что он обладает одним или двумя аутентификаторами с использованием протокола аутентификации. Для этого верификатору также может потребоваться проверить учетные данные, которые связывают аутентификатор(ы) с идентификатором пользователя и проконтролировать их статус |\n| OTP | Одноразовый пароль (One-time password) |\n| SFA | Однофакторные аутентификаторы (Single-factor authenticators), например, то, что вы знаете (запомненные секреты, пароли, парольные фразы, PIN-коды), то, чем вы являетесь (биометрические данные, отпечатки пальцев, сканирование лица) или то, что у вас есть (токены OTP, криптографическое устройство, такое как смарт-карта). |\n| МФА | Многофакторная аутентификация (Multi-factor authentication, MFA), включающая два или более одиночных фактора. |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:01.155071"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x12-V3-Session-management.md", "content": "# V3 Управление сессиями\n\n## Задачи контроля\n\nОдним из основных компонентов любого web-приложения или API с отслеживанием состояния является механизм, с помощью которого оно контролирует и поддерживает состояние пользователя или устройства, взаимодействующего с ним. Управление сессиями превращает протокол без сохранения состояния в протокол с его сохранением, что имеет решающее значение для разграничения пользователей или устройств.\n\nУбедитесь, что проверяемое приложение удовлетворяет следующим концептуальным требованиям к управлению сессиями:\n\n* Сессии уникальны для каждого пользователя, их идентификаторы нельзя угадать, и ими нельзя «поделиться» с другими.\n* Сессии становятся недействительными, когда они больше не нужны, т.е. при бездействии пользователя срок действия сессии истекает.\n\nКак отмечалось ранее, эти требования были адаптированы для соответствия подмножеству мер в [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html), ориентированных на наиболее распространенные угрозы и часто эксплуатируемые недостатки аутентификации. Из предыдущих требований были исключены дубли.\n\n## Верификация требований к безопасности\n\n## V3.1 Базовые требования\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.1.1** | Убедитесь, что приложение не указывает сессионные токены в параметрах URL. | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 Создание сессии\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.2.1** | Убедитесь, что при аутентификации пользователя приложение каждый раз создает новый сессионный токен. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | Убедитесь, что сессионные токены обладают энтропией как минимум в 64-бит. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | Убедитесь, что приложение хранит сессионные токены в браузере безопасно, например, в защищенных файлах cookie (см. раздел V.3.4) или в хранилище сессий HTML5. | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | Убедитесь, что сессионные токены генерируются с использованием утвержденных криптографических алгоритмов. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\nTLS или другой безопасный канал передачи является обязательным для управления сессиями. Об этом говорится в главе «Передача данных».\n\n## V3.3 Завершение сессии\n\nПериод ожидания сессии приведен в соответствие со стандартом NIST 800-63, который допускает гораздо более продолжительные значения, чем в других стандартах по безопасности. Организации должны проанализировать приведенную ниже таблицу, и если желателен более длительный период ожидания в зависимости от риска приложения, значение NIST должно быть верхним пределом времени простоя.\n\nL1 в этом контексте — это IAL1/AAL1, L2 — это IAL2/AAL3, L3 — это IAL3/AAL3. Для IAL2/AAL2 и IAL3/AAL3 более короткий период ожидания является нижней границей времени для выхода из системы или повторной аутентификации для возобновления сессии.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.3.1** | Убедитесь, что при выходе из системы и по истечению срока действия сессионный токен становится недействительным, таким образом, чтобы кнопка «Назад» или нижестоящая проверяющая сторона не возобновляли аутентифицированную сессию, в том числе между проверяющими сторонами. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | Если механизмы аутентификации позволяют пользователям оставаться в системе, убедитесь, что как при активном использовании, так и после периода простоя, периодически проводится повторная аутентификация. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30 дней | 12 часов или 30 минут бездействия, МФА как опция | 12 часов или 15 минут бездействия, МФА обязательна | 613 | 7.2 |\n| **3.3.3** | Убедитесь, что после успешного изменения пароля (в т.ч. после его сброса/восстановления) приложение дает возможность завершить все активные сессии, и что это действие распространяется на приложения при федеративном входе в систему (при его наличии) и на проверяющие стороны. | | ✓ | ✓ | 613 | |\n| **3.3.4** | Убедитесь, что пользователи могут видеть все свои активные на данный момент сессии и устройства и (после повторного ввода учетных данных) выходить из любой из них или из всех сразу. | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 Cookie\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.4.1** | Убедитесь, что для сессионных токенов на основе файлов cookie установлен атрибут Secure. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | Убедитесь, что для сессионных токенов на основе cookie установлен атрибут HttpOnly. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | Убедитесь, что сессионные токены на основе cookie используют атрибут SameSite, установленный в значение Lax или Strict, чтобы ограничить подверженность атакам по подмене межсайтовых запросов (CSRF). ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | Убедитесь, что токены сессии на основе cookie используют префикс \"__Host-\". Таким образом, cookie отправляются только на тот хост, который изначально его установил, т.е. нельзя установить несколько cookie с одинаковым именем из другого поддомена или с другим значением домена или с другим значением пути. | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | Убедитесь, что если приложение публикуется под одним доменным именем с другими приложениями, которые также устанавливают или используют свои сессионные cookie, и могут раскрывать их, то задайте атрибут Path, используя максимально точный путь. ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 Токены\n\nУправление сессиями на основе токенов включает в себя JWT, OAuth, SAML и API-ключи. Известно, что последние являются наиболее слабыми и не должны использоваться в новых разработках.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.5.1** | Убедитесь, что приложение позволяет пользователям отзывать Oauth-токены, которые формируют отношения доверия со связанными приложениями. | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | Убедитесь, что приложение использует сессионные токены, а не статические секреты и API-ключи, за исключением устаревших реализаций. | | ✓ | ✓ | 798 | |\n| **3.5.3** | Убедитесь, что сессионные токены без сохранения состояния используют электронную подпись, шифрование и другие контрмеры для защиты от атак подделки, обертывания, воспроизведения, нулевого шифрования и подмены ключей. | | ✓ | ✓ | 345 | |\n\n## V3.6 Федеративная повторная аутентификация\n\nЭтот раздел предназначен для тех, кто разрабатывает код для проверяющей стороны (англ.: Relying Party, RP) или поставщика учётных данных (англ.: Credential Service Provider, CSP). Если вы полагаетесь на код, реализующий эти функции, убедитесь, что следующие ниже требования удовлетворяются.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.6.1** | Убедитесь, что на проверяющей стороне (RP) определено предельно допустимое время аутентификации для поставщика учетных данных (CSP), и что CSP должны требовать повторной аутентификации пользователя, в случае бездействия в течение этого периода. | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | Убедитесь, что поставщик учетных данных (CSP) информирует проверяющую сторону (RP) о последнем событии аутентификации, чтобы RP могла определить, нужно ли ей повторно аутентифицировать пользователя. | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 Меры защиты от уязвимостей сессии\n\nСуществует несколько атак на управление сессиями, некоторые из которых связаны с пользовательским интерфейсом (UX). Ранее, в соответствии с требованиями ISO 27002, ASVS требовал блокировать параллельные сессии. Теперь такое решение неприменимо, не только потому, что у современных пользователей много устройств, или потому, что приложение может представлять собой API без сессий от браузера, но ещё и потому, что в большинстве этих реализаций действующим остается только последний аутентификатор, который чаще всего и предъявляет злоумышленник. В этом разделе представлены основные рекомендации по предотвращению, задержке и обнаружению атак на управление сессиями.\n\n### Описание «полуоткрытой» атаки\n\nВ начале 2018 года несколько финансовых учреждений были скомпрометированы с помощью так называемых «полуоткрытых атак». Полуоткрытая атака использует недостаток шаблона проектирования, часто встречающийся во многих системах аутентификации, управления сессиями и контроля доступа.\n\nЗлоумышленники начинают полуоткрытую атаку, пытаясь заблокировать, сбросить или восстановить учетные данные. В популярном шаблоне проектирования объекты профиля пользователя переиспользуются между неаутентифицированным, полуаутентифицированным (сброс или восстановление) и полностью аутентифицированным состояниями. Этот шаблон вставляет объект сессии или токен, содержащий профиль жертвы, включая хэш его пароля и имеющиеся роли. Если контроллер доступа или маршрутизатор не проверяют, что пользователь действительно полностью аутентифицирован, то злоумышленник сможет действовать от имени пользователя. Атаки могут включать изменение пароля, обновление адреса email, отключение многофакторной аутентификации или регистрацию нового устройства для МФА, раскрытие или изменение API-ключей и т.д.\n\n| № | Описание | L1 | L2 | L3 | CWE | NIST |\n| :---: | :--- | :---: | :---:| :---: | :---: | :---: |\n| **3.7.1** | Убедитесь, что приложение обеспечивает полный, действительный сеанс входа в систему или требует повторной аутентификации или проверки второго фактора, прежде чем разрешать какие-либо конфиденциальные транзакции или изменения учетной записи. | ✓ | ✓ | ✓ | 306 | |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:40:01.262446"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x12-V4-Access-Control.md", "content": "# V4 Контроль доступа\n\n## Задачи контроля\n\nАвторизация — это концепция предоставления доступа к ресурсам только тем, кому разрешено их использовать. Убедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям:\n\n* Те, кто получает доступ к ресурсам, имеют действующие учётные записи.\n* Пользователи имеют четко определенный набор ролей и привилегий.\n* Метаданные ролей и разрешений защищены от воспроизведения или подделки.\n\n## Верификация требований к безопасности\n\n## V4.1 Базовые принципы\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.1.1** | Убедитесь, что приложение применяет правила контроля доступа на уровне доверенного сервиса, особенно если контроль доступа реализован на стороне клиента и может быть обойдён. | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | Убедитесь, что конечные пользователи без специального на то разрешения не могут манипулировать атрибутами пользователей и данных, а также информацией о применяемой политике контроля доступа. | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | Убедитесь, что применяется принцип наименьших привилегий, т.е. пользователи имеют доступ только к тем функциям, данным, URL-адресам, контроллерам, сервисам и прочим ресурсам, для которых им явно определены права. Это подразумевает защиту от спуфинга (подмены) и повышения привилегий. ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [УДАЛЕНО, ДУБЛИРУЕТ 4.1.3] | | | | |\n| **4.1.5** | Убедитесь, что механизмы управления доступом даже при сбоях ведут себя безопасным образом, в том числе при возникновении исключений. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 Этап эксплуатации\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.2.1** | Убедитесь, что конфиденциальные данные и API защищены от атак с небезопасной прямой ссылкой на объект (IDOR), направленных на создание, чтение, обновление и удаление данных, например, регистрацию или изменение чужой учётной записи, просмотр или удаление всех учетных записей. | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | Убедитесь, что приложение или платформа применяют надежный механизм защиты от CSRF-атак для неаутентифицированной зоны, а после аутентификации — защиту от автоматизированных атак и от CSRF. | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 Прочие соображения\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **4.3.1** | Убедитесь, что в интерфейсе администратора для предотвращения его несанкционированного использования используется многофакторная аутентификация. | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | Убедитесь, что везде, где это не предусмотрено специально, отключен просмотр каталогов. Кроме того, приложения не должны разрешать обнаружение или раскрытие метаданных файлов или каталогов, таких как Thumbs.db, .DS_Store, .git или .svn. | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | Убедитесь, что для обеспечения контроля над мошенничеством с учетом рисков и исторического опыта, в приложении применяются дополнительные меры контроля доступа (например, двухшаговая или адаптивная аутентификация) для менее значимых систем и/или разделение полномочий для более критичных приложений. | | ✓ | ✓ | 732 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:01.354822"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 Форматно-логический контроль, нейтрализация и кодировка\n\n## Задачи контроля\n\nНаиболее распространенным недостатком безопасности web-приложений является неспособность должным образом проконтролировать входные данные, поступающие от клиента или среды, перед их непосредственным использованием без какой-либо кодировки. Это приводит почти ко всем существенным уязвимостям в web-приложениях, таким как межсайтовый скриптинг (XSS), инъекции SQL и команд, атаки, связанные с кодировкой, атаки на файловую систему и переполнение буфера.\n\nУбедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям:\n\n* Архитектура контроля входных и кодирования выходных данных имеет согласованный конвейер для предотвращения атак с использованием инъекций.\n* Входные данные строго типизируются, контролируется их логическая непротиворечивость, проверяются допустимая размерность или диапазон значений, или, как минимум, они нейтрализуются или фильтруются.\n* Выходные данные кодируются или экранируются в соответствии с контекстом данных как можно ближе к интерпретатору.\n\nПри современной архитектуре web-приложений кодирование выходных данных становится важным как никогда. В некоторых случаях сложно обеспечить надёжный контроль входных данных, поэтому использование более безопасных API, таких как параметризованные запросы, автоматически экранирующие шаблоны или тщательно подобранная кодировка для выходных данных, имеют решающее значение для безопасности приложения.\n\n## V5.1 Контроль входных данных\n\nПравильно реализованные меры контроля входных данных, с использованием «белых» списков разрешений и строгой типизации данных, могут устранить более 90% атак с использованием инъекций. Контроль размера и диапазона значений могут еще сильнее снизить эти проблемы. Встраивание контроля входных данных необходимо на этапах проектирования архитектуры приложения, разработки, а также модульного и интеграционного тестирования. Хотя многих из этих требований и нет в тестах на проникновение, результаты их невыполнения обычно приводят к необходимости выполнения требований раздела V5.3 Кодирование выходной информации и предотвращение инъекций. Разработчикам и исследователям безопасности приложений рекомендуется относиться к этому разделу так, как если бы для всех пунктов требовался первый уровень (L1), чтобы предотвратить инъекции.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.1.1** | Убедитесь, что в приложении применяются механизмы защиты от атак «загрязнения» параметров HTTP, особенно если платформа приложения не различает источник параметров запроса (GET, POST, файлы cookie, http-заголовки или переменные среды). | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | Убедитесь, что фреймворки защищают от атак с массовым присвоением параметров, или что приложение обеспечивает меры защиты от небезопасного назначения параметров, например, помечая поля как private и т.п. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | Убедитесь, что все входные данные проходят форматно-логический контроль по «белому» списку разрешенных типов данных, значений атрибутов, параметров, заголовков, запросов, методов и т.п., включая поля HTML-формы, REST-запросы, параметры URL, HTTP-заголовки, атрибуты cookie, пакетные файлы, RSS-каналы и т.д. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | Убедитесь, что структурированные данные строго типизированы и проверяются по заданной схеме, в которой указаны разрешенные символы, максимальная длина и шаблон данных (например, номера банковских карт, телефонов, адреса email. Проверяется, что связанные поля соответствуют друг другу, например, городу однозначно соответствует его почтовый индекс). ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | Убедитесь, что перенаправление URL разрешено только по адресам из списка разрешенных. При перенаправлении на потенциально недоверенный адрес отображается предупреждение. | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 Нейтрализация и изоляция\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.2.1** | Убедитесь, что весь недоверенный HTML-код, из визуальных редакторов (WYSIWYG), должным образом нейтрализуется с помощью библиотеки санитизации или функционала HTML-фреймворка. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | Убедитесь, что неструктурированные данные нейтрализуются с применением таких мер, как разрешенные символы и длина строки. | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | Убедитесь, что приложение нейтрализует пользовательский ввод перед передачей в почтовые системы для защиты от SMTP- или IMAP-инъекций. | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | Убедитесь, что приложение избегает использования eval() или других функций динамического исполнения кода. Там, где нет альтернатив, пользовательский ввод должен нейтрализовываться или помещаться в песочницу перед исполнением. | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | Убедитесь, что приложение защищено от атак с внедрением шаблонов, гарантируя, что весь пользовательский ввод нейтрализуется или исполняется в изолированной среде. | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | Убедитесь, что приложение защищено от SSRF-атак, проверяя или нейтрализуя недоверенные данные или метаданные HTTP-запросов, такие как имена файлов, поля для ввода URL-адресов, а также применяет списки разрешенных протоколов, доменов, путей и портов. | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | Убедитесь, что приложение нейтрализует, отключает или изолирует предоставляемый пользователем контент для сценариев масштабируемой векторной графики (SVG), особенно если они относятся к XSS, полученным из встроенных в код сценариев или foreignObject. | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | Убедитесь, что приложение нейтрализует, отключает или помещает в песочницу предоставляемый пользователем контент на языках сценариев или шаблонов разметки, таких как Markdown, таблицы стилей CSS или XSL, BBCode и т.п. | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 Кодирование выходных данных и предотвращение инъекций\n\nКодирование выходных данных непосредственно перед используемым интерпретатором имеет решающее значение для безопасности приложения. Как правило, сама кодировка не хранится, а применяется для корректного отображения выходных данных в соответствующем контексте. Неспособность применить кодировку может привести к инъекциям и небезопасному приложению.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.3.1** | Убедитесь, что кодировка выходных данных подходит для интерпретатора и контекста. Т.е. для значений и атрибутов HTML, JavaScript, параметров в URL, HTTP-заголовков, SMTP и др. кодировка определяется в зависимости от контекста, особенно при недоверенных входных данных, например, имен на Unicode или с апострофами, таких как ねこ или О'Хара). ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | Убедитесь, что кодировка выходных данных отображает выбранный пользователем набор символов и языковой стандарт, таким образом чтобы любой символ Unicode был допустимым и безопасно обрабатывался. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | Убедитесь, что контекстно-зависимое экранирование выходных данных защищает от XSS-атак (отражённых, сохраненных, основанных на DOM). Предпочтительно автоматизированное, или хотя бы ручное. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | Убедитесь, что запросы к базам данных (SQL, HQL, ORM, NoSQL и пр.) параметризованы посредством ORM, Entity Framework, или иным образом защищены от атак инъекции в базу данных. ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | Убедитесь, что для защиты от SQL-инъекций там, где параметризованные или более безопасные механизмы отсутствуют, при выводе данных используется контекстно-зависимое кодирование, например, экранирование SQL. ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | Убедитесь, что приложение защищено от JSON-инъекции, атак JSON eval и интерпретации кода на JavaScript. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | Убедитесь, что приложение защищено от LDAP-инъекций или что были реализованы меры безопасности для предотвращения LDAP-инъекций. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | Убедитесь, что приложение защищено от инъекций команд операционной системы, и что для вызова команд (и передачи в них аргументов) используются параметризованные запросы к ОС или контекстное кодирование при выводе командной строки. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | Убедитесь, что приложение защищено от атак с локальным включением файлов (LFI) или удаленным включением файлов (RFI). | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | Убедитесь, что приложение защищено от атак с использованием XPath- или XML-инъекций. ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\nПримечание: Использования параметризованных запросов или экранирования SQL не всегда достаточно. Наименования таблиц и столбцов, ORDER BY и т.д. экранировать не получится. Включение экранированных пользовательских данных в эти поля приводит к неудачным запросам или SQL-инъекции.\n\nПримечание. Формат SVG явно разрешает ECMAScript почти во всех контекстах, поэтому полностью заблокировать все XSS-векторы в SVG может оказаться невозможным. Если требуется загрузка SVG, мы настоятельно рекомендуем загружать файлы либо как text/plain, либо со своего домена, чтобы предотвратить XSS-атаку на приложение.\n\n## V5.4 Память, строки и неуправляемый код\n\nСледующие требования будут актуальны, если приложение использует язык ассемблера или неуправляемый код.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.4.1** | Убедитесь, что для обнаружения или предотвращения ситуаций переполнения стека, буфера или кучи приложение учитывает размер доступной области памяти при строковых операциях, копировании в память, в арифметике указателей и т.п.. | | ✓ | ✓ | 120 |\n| **5.4.2** | Убедитесь, что строка форматирования не содержит потенциально вредоносных входных данных и является неизменяемой. | | ✓ | ✓ | 134 |\n| **5.4.3** | Убедитесь, что для предотвращения целочисленного переполнения применяется контроль знака, диапазона и типа допустимых входных данных. | | ✓ | ✓ | 190 |\n\n## V5.5 Предотвращение десериализации\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **5.5.1** | Убедитесь, что для предотвращения создания вредоносных объектов или подмены данных используется контроль целостности и/или шифрование. ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | Убедитесь, что приложение правильно ограничивает XML-парсер наиболее строгой конфигурацией, которая гарантирует, что небезопасные XML-функции, такие как разрешение внешних объектов, отключены для предотвращения атак XML eXternal Entity (XXE). | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | Убедитесь, что десериализация недоверенных данных исключена или изолирована как в пользовательском коде, так и в сторонних библиотеках (например, в парсерах JSON, XML, YAML и пр.). | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | Убедитесь, что при разборе JSON в браузерах или в серверной части на основе JavaScript для документа JSON используется JSON.parse. Не используйте eval() для разбора JSON. | ✓ | ✓ | ✓ | 95 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\nДля дополнительной информации по экранированию см. также:\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\nДля дополнительной информации по десериализации см. также:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:40:01.415938"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x14-V6-Cryptography.md", "content": "# V6 Хранимая криптография\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям:\n\n* Криптографические модули выходят из строя безопасным образом, и ошибки корректно обрабатываются.\n* Используется соответствующий генератор случайных чисел.\n* Обеспечивается контроль доступа к ключам.\n\n## V6.1 Категории информации\n\nСамым важным активом является информация, обрабатываемая, хранимая или передаваемая приложением. Проводите оценку воздействия на ее конфиденциальность, чтобы правильно классифицировать потребности в защите информации при хранении.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.1.1** | Убедитесь, что в зашифрованном виде хранятся регулируемые законом персональные данные, или данные, которые могут подпадать под действие ФЗ-152, GDPR и т.п. | | ✓ | ✓ | 311 |\n| **6.1.2** | Убедитесь, что в зашифрованном виде хранятся регулируемые законом данные о здоровье, например медицинские карты, результаты анализов, диагностические данные с медицинского оборудования или необезличенные результаты клинических исследований. | | ✓ | ✓ | 311 |\n| **6.1.3** | Убедитесь, что в зашифрованном виде хранится регулируемая законом финансовая информация, например, данные о банковских картах и счетах, о банкротстве, кредитная история, налоговые декларации, история платежей, выгодоприобретатели или необезличенные данные исследований рынка. | | ✓ | ✓ | 311 |\n\n## V6.2 Алгоритмы\n\nНедавние достижения в области криптографии означают, что ранее считавшиеся стойкими алгоритмы и достаточными длины ключей больше не являются таковыми для защиты данных. Следовательно, должна быть возможность поменять алгоритмы.\n\nХотя этот раздел нелегко протестировать на проникновение, разработчики должны рассматривать весь этот раздел как обязательный, даже если пометка в L1 отсутствует.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.2.1** | Убедитесь, что криптографические модули при сбоях ведут себя безопасно, а ошибки обрабатываются таким образом, чтобы не допустить атаки Padding Oracle. | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | Убедитесь, что используются утвержденные государственные или отраслевые стандарты на криптографические алгоритмы, режимы и библиотеки, а не криптография собственной / заказной разработки. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | Убедитесь, что вектор инициализации, конфигурация шифра и блочные режимы настроены безопасно, используя актуальные рекомендации. | | ✓ | ✓ | 326 |\n| **6.2.4** | Убедитесь, что для защиты от криптографических атак в любой момент можно перенастроить, обновить или изменить параметры алгоритмов (генерации случайных чисел, шифрования, хэширования), а также длины ключей, раунды, шифры или режимы. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | Убедитесь, что не используются небезопасные блочные режимы (например, ECB и т.д.), режимы дополнения (например, PKCS#1 v1.5 и т.д.), шифры с небольшими размерами блоков (например, 3DES, Blowfish и т.д.) и нестойкие алгоритмы хеширования (например, MD5, SHA1 и т. д.), если это не требуется для обратной совместимости. | | ✓ | ✓ | 326 |\n| **6.2.6** | Убедитесь, что значения nonce, векторов инициализации и других случайных одноразовых строк не должны использоваться более одного раза с данным ключом шифрования. Метод их генерации должен соответствовать используемому алгоритму. | | ✓ | ✓ | 326 |\n| **6.2.7** | Убедитесь, что зашифрованные данные аутентифицированы с помощью подписей, аутентифицированных режимов шифрования или HMAC, чтобы гарантировать, что зашифрованный текст не будет изменен неуполномоченной на то стороной. | | | ✓ | 326 |\n| **6.2.8** | Убедитесь, что все криптографические операции выполняются за постоянное время, без операций «короткого замыкания» при сравнении, вычислениях или возврате, чтобы избежать утечки информации по побочным каналам. | | | ✓ | 385 |\n\n## V6.3 Случайные значения\n\nНастоящий генератор псевдослучайных чисел (PRNG) невероятно сложно сделать правильно. Обычно, хорошие источники энтропии в системе быстро истощаются при чрезмерном использовании, но источники с меньшей случайностью могут привести к предсказуемым ключам и секретам.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.3.1** | Убедитесь, что все случайные числа, случайные имена файлов, случайные идентификаторы GUID и случайные строки генерируются с помощью утвержденного криптографического генератора случайных чисел в криптографическом модуле. | | ✓ | ✓ | 338 |\n| **6.3.2** | Убедитесь, что случайные идентификаторы GUID создаются с использованием алгоритма GUIDv4 и криптографического генератора псевдослучайных чисел (CSPRNG). GUID, созданные с помощью других генераторов псевдослучайных чисел, могут быть предсказуемыми.| | ✓ | ✓ | 338 |\n| **6.3.3** | Убедитесь, что случайные числа создаются с надлежащей энтропией, даже когда приложение находится под большой нагрузкой, и что при сбоях оно ведет себя безопасно. | | | ✓ | 338 |\n\n## V6.4 Управление секретами\n\nХотя этот раздел нелегко протестировать на проникновение, разработчики должны рассматривать весь этот раздел как обязательный, даже если пометка в L1 отсутствует.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **6.4.1** | Убедитесь, что для безопасного создания, хранения, контроля доступа и уничтожения секретов используется решение для управления секретами, например, сейф — хранилище ключей (key vault). ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | Убедитесь, что ключевой материал не доступен приложению, и для криптографических операций применяется изолированный модуль безопасности, например, сейф (vault). ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:40:01.491703"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x15-V7-Error-Logging.md", "content": "# V7 Обработка ошибок и ведение журнала\n\n## Задачи контроля\n\nОсновная цель обработки ошибок и ведения журнала — дать полезную информацию пользователям, администраторам и группам реагирования на инциденты. Цель журнала не в том, чтобы регистрировать в нем как можно больше записей, а в полезности каждой отдельной записи, и в улучшении отношения сигнал/шум.\n\nКачественные журналы часто содержат конфиденциальную информацию и должны быть защищены в соответствии с местными законами о конфиденциальности. Меры защиты журнала должны включать:\n\n* Не собирать и не регистрировать в журналах конфиденциальную информацию, если этого не требуется.\n* Обеспечивать безопасную обработку и защиту регистрируемой в журналах информации в соответствии с ее категорией.\n* Убедиться, что журналы не хранятся вечно, и имеют как можно более короткий срок хранения.\n\nЕсли журналы содержат персональные или другие чувствительные данные, определение которых варьируется от страны к стране, то они становятся одной из наиболее привлекательных целей для злоумышленников в приложении.\n\nТакже важно убедиться, что и при сбоях приложение ведет себя безопасно, не раскрывая избыточной информации в тексте ошибок.\n\n## V7.1 Содержимое журнала\n\nРегистрация конфиденциальной информации в журнале опасна — журналы сами по себе становятся засекреченными, а это означает, что они должны быть зашифрованы, на них распространяются политики хранения и их необходимо раскрывать в ходе аудитов безопасности. Убедитесь, что в журналах хранится только необходимая информация, и, конечно, никаких платежных, учетных (включая сессионные токены), конфиденциальных или персональных данных.\n\nV7.1 покрывает [OWASP Top 10 2017:A10](https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring). Поскольку 2017:A10 не поддаётся тестированию на проникновение, то необходимо:\n\n* разработчикам — обеспечивать полное соответствие этому разделу, как если бы все требования были помечены как L1;\n* пентестерам — обеспечивать контроль соответствия всем требованиям V7.1 с помощью интервью, снимков экрана и проверки утверждений.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.1.1** | Убедитесь, что приложение не записывает в журнал учетные или платежные данные. Сессионные токены могут записываться в журнал только в необратимой хэшированной форме. ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | Убедитесь, что приложение не записывает в журнал другие конфиденциальные данные в соответствии с применимыми законами (ПДн, банковская, налоговая, коммерческая, врачебная и иные виды тайн) или действующей политике безопасности. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | Убедитесь, что приложение регистрирует в журнале события, относящиеся к безопасности, включая успешную и неудачную аутентификацию, события нарушения контроля доступа, десериализации и форматно-логического контроля входных данных. ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | Убедитесь, что каждое событие журнала включает необходимую и достаточную информацию, которая позволит провести его подробное исследование с учетом хронологических связей. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 Обработка журнала\n\nСвоевременная регистрация событий имеет решающее значение для их аудита, сортировки и эскалации. Убедитесь, что журналы приложения понятны и могут анализироваться либо локально, либо в удаленной системе мониторинга.\n\nV7.2 покрывает [OWASP Top 10 2017:A10](https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring). Поскольку 2017:A10 не поддаётся тестированию на проникновение, то необходимо:\n\n* разработчикам — обеспечивать полное соответствие этому разделу, как если бы все требования были помечены как L1;\n* пентестерам — обеспечивать контроль соответствия всем требованиям V7.2 с помощью интервью, снимков экрана и проверки утверждений.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.2.1** | Убедитесь, что все решения по аутентификации регистрируются в журнале, без сохранения сессионных токенов, паролей и т.п., включая запросы с соответствующими метаданными, необходимыми для расследований событий безопасности. | | ✓ | ✓ | 778 |\n| **7.2.2** | Убедитесь, что все решения по контролю доступа МОГУТ, а все неудачные попытки ДОЛЖНЫ быть занесены в журнал, включая запросы с соответствующими метаданными, необходимыми для расследований событий безопасности. | | ✓ | ✓ | 285 |\n\n## V7.3 Защита журнала\n\nЖурналы, которые можно тривиально изменить или удалить, бесполезны для расследований и криминалистики. Раскрытие журнала может привести к разглашению внутренних сведений о приложении или содержащейся в нем информации. Необходимо соблюдать осторожность при защите журналов от несанкционированного раскрытия, изменения или удаления.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.3.1** | Убедитесь, что все компоненты записывают события в журнал в нормализованной форме, указывая правильную кодировку, и используя экранирование символов, чтобы предотвратить инъекцию в журнал. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [УДАЛЕНО, ДУБЛИРУЕТ 7.3.1] | | | | |\n| **7.3.3** | Убедитесь, что журналы событий безопасности защищены от несанкционированного доступа и изменения. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | Убедитесь, что системное время синхронизируется с утвержденными источниками времени и в правильном часовом поясе. Для географически распределенных систем настоятельно рекомендуется вести журнал в формате UTC, чтобы облегчить криминалистический анализ после инцидента. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\nПримечание: Кодирование журнала (7.3.1) сложно протестировать и проверить с помощью автоматизированных динамических инструментов и тестов на проникновение, но архитекторы, разработчики и рецензенты исходного кода должны учитывать это требование как L1.\n\n## V7.4 Обработка ошибок\n\nЦель обработки ошибок — предоставлять важные для безопасности приложения события для мониторинга, сортировки и эскалации. Смысл не в том, чтобы создавать много записей. При регистрации событий, связанных с безопасностью, убедитесь, что в каждой записи есть смысл, который понятен SIEM или аналитической системе.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **7.4.1** | Убедитесь, что при возникновении непредвиденной ошибки или ошибки, связанной с безопасностью, отображается универсальное сообщение с уникальным идентификатором, который персонал службы сопровождения может использовать для расследования. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | Убедитесь, что для учета ожидаемых и непредвиденных ошибок в кодовой базе используется обработка исключений (или ее функциональный эквивалент). ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | Убедитесь, что определен обработчик ошибок «последней инстанции», который будет перехватывать все необработанные исключения. ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\nПримечание. Некоторые языки, такие как Swift и Go, а также многие функциональные языки не поддерживают исключения или обработчики событий последней инстанции. В этом случае архитекторы и разработчики должны использовать такой шаблон, язык или фреймворк, которые обеспечат безопасную обработку исключений, а также неожиданных или связанных с безопасностью событий.\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Testing Guide 4.0: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:40:01.577639"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x16-V8-Data-Protection.md", "content": "# V8 Защита информации\n\n## Задачи контроля\n\nЕсть три ключевых элемента надежной защиты данных: конфиденциальность, целостность и доступность. В данном стандарте предполагается, что защита данных обеспечивается в доверенной системе, например, на сервере, укрепленном достаточным набором мер защиты.\n\nПриложение должно считать, что все пользовательские устройства так или иначе скомпрометированы. Если приложение передает или хранит конфиденциальную информацию на небезопасных устройствах, таких как компьютеры, телефоны и планшеты, приложение несет ответственность за то, чтобы информация, хранящаяся на этих устройствах, была зашифрована и не могла быть легко получена незаконным путем, изменена или разглашена.\n\nУбедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям к защите информации:\n\n* Конфиденциальность: информация должна быть защищена от несанкционированного просмотра или разглашения как при передаче, так и при хранении.\n* Целостность: информация должна быть защищена от несанкционированной регистрации, изменения или удаления неуполномоченными лицами.\n* Доступность: информация должна быть доступна авторизованным пользователям по мере необходимости.\n\n## V8.1 Базовые меры\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.1.1** | Убедитесь, что приложение защищает конфиденциальные данные от кэширования в серверных компонентах, таких как балансировщики нагрузки и кэши приложений. | | ✓ | ✓ | 524 |\n| **8.1.2** | Убедитесь, что все кэшированные или временные копии конфиденциальных данных, хранящиеся на сервере, защищены от несанкционированного доступа или очищены/аннулированы после того, как авторизованный пользователь получит доступ к конфиденциальным данным. | | ✓ | ✓ | 524 |\n| **8.1.3** | Убедитесь, что приложение минимизирует количество параметров в запросе, таких как скрытые поля, переменные AJAX, файлы cookie и значения заголовков. | | ✓ | ✓ | 233 |\n| **8.1.4** | Убедитесь, что приложение может обнаруживать и предупреждать об аномальном количестве запросов, например, по данному IP-адресу или пользователю, по общему количеству запросов в час или в день или по другому признаку в контексте приложения. | | ✓ | ✓ | 770 |\n| **8.1.5** | Убедитесь, что регулярно создаются резервные копии всех значимых данных и проводится тестирование по восстановлению этих данных. | | | ✓ | 19 |\n| **8.1.6** | Убедитесь, что резервные копии хранятся в безопасном месте, чтобы предотвратить кражу или повреждение данных. | | | ✓ | 19 |\n\n## V8.2 Защита данных на стороне клиента\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.2.1** | Убедитесь, что приложение устанавливает соответствующие заголовки для предотвращения кэширования, чтобы конфиденциальные данные не кэшировались в современных браузерах. | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | Убедитесь, что данные, хранящиеся в хранилище браузера (например, localStorage, sessionStorage, IndexedDB или файлы cookie), не содержат конфиденциальной информации. | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | Убедитесь, что данные, полученные после аутентификации клиента, удаляются из хранилища, например из DOM браузера, после завершения работы клиента или сессии. | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 Персональные данные\n\nЭтот раздел поможет защитить конфиденциальную информацию от её несанкционированной регистрации, чтения, изменения или удаления, особенно большими партиями.\n\nСоблюдение требований данного раздела также подразумевает удовлетворение требованиям раздела V4 Контроля доступа, особенно в части V4.2. Например, для защиты от несанкционированного изменения или разглашения персональных данных требуется соответствие требованию V4.2.1. Для полного охвата необходимо соответствие и этому разделу и V4.\n\nПримечание: Законы и регламенты о персональных данных, такие как Федеральный закон РФ \"О персональных данных\" 152-ФЗ или GDPR, напрямую влияют на то, как приложения должны подходить к хранению, использованию и передаче персональных данных. Наказания варьируются от суровых штрафов до простых советов. Ознакомьтесь с местными законами и нормативными актами, а также при необходимости проконсультируйтесь с квалифицированным специалистом по вопросам персональных данных или юристом.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **8.3.1** | Убедитесь, что в параметрах строки HTTP-запроса не содержится конфиденциальных данных. Вместо этого они отправляются на сервер в теле или заголовках HTTP-сообщения. | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | Убедитесь, что у пользователей есть способ удалить или экспортировать свои данные по запросу. | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | Убедитесь, что пользователям предоставлены четкие формулировки в отношении сбора и использования их персональных данных, и что они дали добровольное согласие на обработку этих данных, прежде чем эти данные будут каким-либо образом использованы. | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | Убедитесь, что определены все конфиденциальные данные, создающиеся и обрабатываемые приложением, и что на эти данные распространяется действие политики обращения с конфиденциальными данными. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | Убедитесь, что доступ к конфиденциальным данным подвергается аудиту (без регистрации в журнале самих этих данных), если данные собираются в соответствии с соответствующими законами о защите данных или если вести журнал доступа требуется по стандарту организации (отрасли). | | ✓ | ✓ | 532 |\n| **8.3.6** | Убедитесь, что для предотвращения атак с дампом памяти, конфиденциальная информация, содержащаяся в памяти, после того как она больше не нужна, перезаписывается (нулями или случайными данными). | | ✓ | ✓ | 226 |\n| **8.3.7** | Убедитесь, что конфиденциальная информация, которую необходимо зашифровать, зашифрована с использованием утвержденных алгоритмов, обеспечивающих как конфиденциальность, так и целостность. ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | Убедитесь, что конфиденциальная информация подлежит классификации по сроку хранения, чтобы ненужные или устаревшие данные удалялись автоматически, по расписанию или по мере необходимости. | | ✓ | ✓ | 285 |\n\nПри рассмотрении вопроса о защите данных основное внимание следует уделять их массовому извлечению, изменению или чрезмерному использованию. Например, многие социальные сети позволяют пользователям добавлять не более 100 новых «друзей» в день. Банковская система может заблокировать переводы во внешние учреждения, если их частота более пяти в час, и сумма более $1000. Требования к каждой системе могут быть разными, поэтому, отвечая на вопрос \"Что считать «аномалией»?\", необходимо учитывать модель угроз и бизнес-риски. Важными критериями являются способность обнаруживать, сдерживать, и, что ещё важнее, блокировать такие аномальные массовые операции.\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [Сайт Security Headers](https://securityheaders.io)\n* [Проект OWASP Secure Headers](https://owasp.org/www-project-secure-headers/)\n* [Проект OWASP Privacy Risks](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [Обзор European Union General Data Protection Regulation (GDPR)](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:40:01.627263"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x17-V9-Communications.md", "content": "# V9 Передача данных\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение соответствует следующим концептуальным требованиям:\n\n* Требует TLS или шифрования, независимо от конфиденциальности обрабатываемой информации.\n* Следует последним рекомендациям в части:\n  * безопасных конфигураций;\n  * предпочтительных алгоритмов и шифров.\n* Избегает нестойких или устаревающих алгоритмов и шифров, за исключением крайних случаев.\n* Отключает небезопасные алгоритмы и шифры.\n\nВ рамках этих требований:\n\n* Будьте в курсе рекомендаций по безопасной конфигурации TLS, поскольку они часто меняется («часто» из-за катастрофических проблем, обнаруживаемых в существующих алгоритмах и шифрах).\n* Используйте самые последние версии инструментов анализа конфигурации TLS, чтобы настроить предпочтительный порядок и выбор алгоритмов.\n* Периодически проверяйте конфигурацию, чтобы убедиться, что данные передаются надёжно и безопасно.\n\n## V9.1 Безопасность подключений со стороны клиента\n\nУбедитесь, что сообщения клиента передаются по зашифрованным каналам с использованием TLS 1.2 или более поздней версии.\nИспользуйте современные инструменты для регулярной проверки конфигурации клиента.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.1.1** | Убедитесь, что для клиентских подключений используется протокол TLS, и при этом он не оставляет соединения без защиты (незашифрованными или неаутентифицированными). ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | С помощью современных инструментов тестирования TLS убедитесь, что включены только стойкие шифронаборы, при этом наиболее стойкие из них выбраны как предпочтительные. | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | Убедитесь, что включены только актуальные и рекомендуемые версии протокола TLS, такие как TLS 1.2 и TLS 1.3. Наиболее свежая версия TLS должна быть выбрана как предпочтительная. | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 Безопасность подключений со стороны сервера\n\nСвязь с сервером — это не только HTTP. Также необходимо обеспечить безопасные соединения с другими системами, такими как системы мониторинга, инструменты управления, удаленный доступ и ssh, промежуточное ПО, базы данных, серверы, партнерские или внешние API. Все эти соединения должны быть зашифрованы, чтобы не допустить перехвата информации по принципу «трудно снаружи, но легко внутри».\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **9.2.1** | Убедитесь, что для подключения к и от сервера используются доверенные сертификаты TLS. Если используются сгенерированные собственным УЦ или самоподписанные сертификаты, то сервер должен быть настроен так, чтобы доверять только утвержденным внутренним центрам сертификации и только указанным самоподписанным сертификатам. Все остальные должны отвергаться. | | ✓ | ✓ | 295 |\n| **9.2.2** | Убедитесь, что для всех входящих и исходящих подключений используются зашифрованные соединения, такие как TLS, в том числе для портов управления, мониторинга, аутентификации, вызовов API или web-сервисов, подключений к базам данных, облачным сервисам, бессерверным функциям, серверам, внешних и партнерских подключений. Сервер не должен возвращаться к небезопасным или незашифрованным протоколам. | | ✓ | ✓ | 319 |\n| **9.2.3** | Убедитесь, что все зашифрованные соединения с внешними системами, передающие конфиденциальную информацию или функции, аутентифицированы. | | ✓ | ✓ | 287 |\n| **9.2.4** | Убедитесь, что включена и настроена процедура отзыва сертификатов, например, Online Certificate Status Protocol (OCSP) Stapling. | | ✓ | ✓ | 299 |\n| **9.2.5** | Убедитесь, что сбои TLS-соединений со стороны сервера  регистрируются в журнале. | | | ✓ | 544 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* Примечания по рекомендованным режимам TLS:\n  * В прошлом ASVS ссылался на стандарт США FIPS 140-2, но рекомендация о применении стандартов США в качестве международных может оказаться трудной в реализации, противоречивой и нелогичной.\n  * Лучшим способом достижения соответствия разделу 9.1 будет рассмотрение таких руководств, как [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) или [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/), и использование известных и современных инструменты анализа TLS для достижения желаемого уровня безопасности.\n", "timestamp": "2025-10-24T11:40:01.672141"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x18-V10-Malicious.md", "content": "# V10 Вредоносный код\n\n## Задачи контроля\n\nУбедитесь, что ваш код удовлетворяет следующим концептуальным требованиям:\n\n* Вредоносная активность надёжно и безопасно сдерживается, чтобы не повлиять на остальную часть приложения.\n* Не имеет «бомб отложенного действия» или других атак, основанных на времени.\n* Не «звонит домой» злонамеренным или неразрешённым адресатам.\n* В нём нет лазеек, «пасхальных яиц», атак «салями», руткитов или несанкционированного кода, которым может управлять злоумышленник.\n\nОбнаружение вредоносного кода является «доказательством от противного», в котором нельзя удостовериться полностью. Следует приложить все силы для обеспечения гарантии того, что ваш код не содержит встроенного вредоносного кода или недокументированных возможностей.\n\n## V10.1 Целостность исходного кода\n\nЛучшая защита от вредоносного кода — принцип «доверяй, но проверяй». Включение недокументированного или вредоносного кода во многих юрисдикциях является уголовным преступлением. Регламенты и процедуры должны четко определять санкции в отношении вредоносного кода.\n\nВедущие разработчики должны регулярно проводить анализ регистрации нового кода, особенно там, где есть доступ к системному времени, вводу-выводу или сетевым функциям.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.1.1** | Убедитесь, что используется инструмент анализа исходного кода, который может обнаруживать потенциально вредоносный код, например, манипуляции с системным временем, с файлами и сетевыми подключениями. | | | ✓ | 749 |\n\n## V10.2 Поиск вредоносного кода\n\nВредоносный код встречается крайне редко, и его трудно обнаружить. Построчный просмотр кода вручную может помочь в поиске логических бомб, но даже самый опытный рецензент едва ли найдет вредоносный код, даже если знает, что он есть.\n\nСоблюдение требований этого раздела невозможно без полного доступа к исходному коду, включая сторонние библиотеки.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.2.1** | Убедитесь, что исходный код приложения и сторонние библиотеки не содержат недокументированных возможностей по сбору и отправке данных пользователя неразрешённым адресатам. Если такие функции существуют, необходимо получить разрешение на эти действия и явное согласие пользователя, прежде чем собирать какие-либо данные. | | ✓ | ✓ | 359 |\n| **10.2.2** | Убедитесь, что приложение не запрашивает ненужных или избыточных разрешений для функций, связанных с конфиденциальностью, например, доступ к контактам, сообщениям, истории просмотров и пр. или к датчикам, таким как камера, микрофон или местоположение. | | ✓ | ✓ | 272 |\n| **10.2.3** | Убедитесь, что исходный код приложения и сторонних библиотек не содержит лазеек, таких как включенные в код и/или недокументированные учетные записи или ключи, обфускация кода, недокументированные бинарные объекты (blob), руткиты или средства защиты от отладки, или иные устаревшие, небезопасные или скрытые функции, которые могут быть использованы злонамеренно. | | | ✓ | 507 |\n| **10.2.4** | Убедитесь, что исходный код приложения и сторонние библиотеки не содержат «бомб отложенного действия», выполнив поиск функций, связанных с датой и временем. | | | ✓ | 511 |\n| **10.2.5** | Убедитесь, что исходный код приложения и сторонние библиотеки не содержат вредоносного кода, такого как атаки типа «нарезка салями», обход логики или «логические бомбы». | | | ✓ | 511 |\n| **10.2.6** | Убедитесь, что исходный код приложения и сторонние библиотеки не содержат «пасхальных яиц» и других недокументированных функций. | | | ✓ | 507 |\n\n## V10.3 Целостность приложения\n\nВредоносный код может быть включен и после развертывания приложения. Приложения должны защищать себя от распространенных атак, таких как выполнение неподписанного кода из недоверенных источников и захват доменов.\n\nСоблюдение требований этого раздела, вероятно, будет регулярным занятием во время эксплуатации приложений.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **10.3.1** | Убедитесь, что если в приложении есть функция автоматического обновления клиента или сервера, то обновления должны быть получены по защищенным каналам и подписаны электронной подписью. Код обновления должен проверять подпись обновления до установки или применения обновления. | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | Убедитесь, что приложение использует меры защиты целостности, такие как подпись кода или включаемых ресурсов (subresource integrity). Приложение не должно загружать или исполнять код из недоверенных источников, таких как загрузка компонентов, модулей, плагинов, кода или библиотек из Интернета. | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | Убедитесь, что если приложение полагается на записи DNS или субдомены DNS, то оно контролирует возможный захват субдоменов злоумышленниками, например, после истечения срока делегирования доменных имен, устаревании указателей DNS или CNAME, в необновляемых проектах, в общедоступных репозиториях исходного кода или во временных облачных API, бессерверных функциях, или хранилищах (*autogen-bucket-id*.cloud.example.com и т.п.). Меры защиты включают регулярную проверку DNS-имен, используемых приложениями, на предмет истечения срока их делегирования или изменения владельца. | ✓ | ✓ | ✓ | 350 |\n\n## Ссылки\n\n* [Враждебный захват субдомена, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Угон заброшенных поддоменов, часть 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:40:01.758578"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x19-V11-BusLogic.md", "content": "# V11 Бизнес-логика\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям:\n\n* Поток бизнес-логики является последовательным, обрабатывается по порядку, и его нельзя обойти.\n* Бизнес-логика включает ограничения для обнаружения и предотвращения автоматизированных атак, таких как многократно повторяющиеся денежные переводы  незначительных сумм или добавление миллиона друзей по одному за раз и т.д.\n* Ключевые потоки бизнес-логики учитывают возможность злоупотреблений и злонамеренных действий и имеют защиту от несанкционированного доступа, разглашения и искажения информации и атак с повышением привилегий.\n\n## V11.1 Безопасность бизнес-логики\n\nБезопасность бизнес-логики настолько индивидуальна для каждого приложения, что не поможет ни один чек-лист. Она должна проектироваться для защиты от вероятных внешних угроз, но её нельзя «включить» как набор правил на WAF или, организовав защищенный канал связи. Мы рекомендуем использовать моделирование угроз во время спринтов по дизайну, например, с помощью OWASP Cornucopia или аналогичных инструментов.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **11.1.1** | Убедитесь, что приложение обрабатывает потоки бизнес-логики для того же пользователя, последовательно, и без пропуска шагов.| ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | Убедитесь, что приложение обрабатывает потоки бизнес-логики только в том случае, если все шаги обрабатываются в реалистичном для человека масштабе времени, т.е. транзакции не делаются слишком быстро.| ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | Убедитесь, что приложение ограничивает определенные операции бизнес-процессов или транзакции по частоте и потребляемым ресурсам, и эти ограничения корректно применяются для каждого пользователя. | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | Убедитесь, что в приложении предусмотрены меры защиты от автоматизации аномальных по размеру запросов на массовую выгрузку данных, запросов бизнес-логики, загрузки файлов или атак типа «отказ в обслуживании». | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | Убедитесь, что приложение имеет ограничения бизнес-логики или меры защиты от наиболее вероятных бизнес-рисков или угроз, выявленных с помощью моделирования угроз или аналогичных методологий. | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | Убедитесь, что приложение не подвержено атакам типа «момент проверки до момента использования» (TOCTOU) или других условий гонки для конфиденциальных операций. | | ✓ | ✓ | 367 |\n| **11.1.7** | Убедитесь, что приложение отслеживает необычные события или действия с точки зрения бизнес-логики. Например, попытки выполнить действия не по порядку или действия, которые обычный пользователь никогда бы не совершил. ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | Убедитесь, что приложение имеет настраиваемое оповещение при обнаружении автоматизированных атак или необычных действий. | | ✓ | ✓ | 390 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* \"Анти-автоматизация\" атак может быть достигнута многими способами, включая [OWASP AppSensor](https://github.com/jtmelton/appsensor) и [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) также может помочь с обнаружением и реагированием на атаки.\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:40:01.823987"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x20-V12-Files-Resources.md", "content": "# V12 Файлы и ресурсы\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение удовлетворяет следующим концептуальным требованиям:\n\n* Недоверенные данные файлов должны обрабатываться соответствующим и безопасным образом.\n* Недоверенные данные файлов, полученные из недоверенных источников, хранятся вне корневого каталога webroot и с ограниченными разрешениями.\n\n## V12.1 Загрузка файлов на сервер\n\nХотя zip-бомбы хорошо поддаются тестированию методами пентеста, они относятся к уровню L2 и выше, чтобы поощрять проектирование и разработку с тщательным ручным тестированием и избегать автоматизированного или неквалифицированного ручного тестирования на выявление ситуации отказа в обслуживании.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.1.1** | Убедитесь, что приложение не будет принимать файлы, размер которых превышает доступное место или вызывает отказ в обслуживании. | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | Убедитесь, что приложение проверяет сжатые файлы (например, zip, gz, docx, odt) на соответствие максимально допустимому несжатому размеру и максимальному количеству файлов перед распаковкой файла. | | ✓ | ✓ | 409 |\n| **12.1.3** | Убедитесь, что применяются квоты на размер файла и на максимальное количество файлов на одного пользователя, чтобы гарантировать, что пользователь не может заполнить все хранилище слишком большим количеством файлов или файлами чрезмерно большого размера. | | ✓ | ✓ | 770 |\n\n## V12.2 Целостность файлов\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.2.1** | Убедитесь, что файлы, полученные из недоверенных источников, соответствуют ожидаемому типу на основе содержимого файла (а не только его наименования). | | ✓ | ✓ | 434 |\n\n## V12.3 Исполнение файла\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.3.1** | Убедитесь, что метаданные имени файла, отправляемые пользователем, не используются напрямую файловыми системами ОС или платформы. Вместо этого для защиты от атак path traversal (перемещения по каталогам) используется API URL. | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | Убедитесь, что передаваемые пользователем метаданные файла проверяются на предмет раскрытия, создания, изменения или удаления локальных файлов (LFI) или игнорируются. | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | Убедитесь, что передаваемые пользователем метаданные файла проверяются на предмет раскрытия или исполнения файлов посредством удаленного включения (RFI) или подделки запросов на стороне сервера (SSRF), или игнорируются. | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | Убедитесь, что приложение защищено от отраженной загрузки файлов (Reflected File Download, RFD), проверяя или игнорируя передаваемые пользователем в JSON, JSONP или в параметрах URL имена файлов. При этом заголовок ответа Content-Type должен быть установлен в text/plain, а заголовок Content-Disposition должно иметь фиксированное имя файла. | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | Убедитесь, что недоверенные метаданные файла не используются напрямую с системными API или библиотеками для защиты от инъекции команд операционной системы. | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | Убедитесь, что приложение не включает и не исполняет функции из недоверенных источников, таких как непроверенные сети доставки контента (CDN), библиотеки JavaScript, пакеты из npm в Node.js, или серверные библиотеки DLL. | | ✓ | ✓ | 829 |\n\n## V12.4 Хранение файлов\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.4.1** | Убедитесь, что файлы, полученные из недоверенных источников, хранятся вне корневого каталога webroot и имеют ограниченные разрешения. | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | Убедитесь, что файлы, полученные из недоверенных источников, проверяются антивирусными сканерами, чтобы предотвратить загрузку и распространение известного вредоносного кода. | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 Загрузка файлов клиентом\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.5.1** | Убедитесь, что уровень представления (web) обслуживает только файлы с заранее определенными расширениями, чтобы предотвратить непреднамеренную утечку информации и исходного кода. Например, файлы резервных копий (.bak), временные рабочие файлы (.swp), сжатые файлы (.zip, .tar.gz и т. д.) и другие расширения, обычно используемые редакторами, должны быть заблокированы, если в них нет необходимости. | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | Убедитесь, что прямые запросы к загруженным файлам никогда не будут интерпретироваться как содержимое HTML/JavaScript. | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 Защита от SSRF\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **12.6.1** | Убедитесь, что на web-сервере или сервере приложений настроен список разрешенных ресурсов или систем, к которым сервер может отправлять запросы или с которых он может загружать данные/файлы. | ✓ | ✓ | ✓ | 918 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [Unrestricted File Upload](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:01.888334"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x21-V13-API.md", "content": "# V13 API и web-сервисы\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение, использующее API на уровне доверенного сервиса (обычно это JSON, XML или GraphQL), имеет:\n\n* Адекватную аутентификацию, управление сессиями и авторизацию для всех web-сервисов.\n* Форматно-логический контроль всех входных параметров, которые передаются с более низкого уровня доверия на более высокий.\n* Эффективные меры безопасности для всех типов API, включая облачные и бессерверные API.\n\nПожалуйста, воспринимайте эту главу в контексте с другими главами; мы больше не дублируем требования аутентификации или управления сессиями для API.\n\n## V13.1 Базовая безопасность web-сервисов\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.1.1** | Убедитесь, что все компоненты приложения используют одну и ту же кодировку символов и ту же библиотеку синтаксического разбора, чтобы избежать атак, которые используют различные URI или поведение парсера, которое может привести к атакам SSRF и RFI. | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [УДАЛЕНО, ДУБЛИРУЕТ 4.3.1] | | | | |\n| **13.1.3** | Убедитесь, что URL-адреса API не содержат конфиденциальной информации (ключ API, сессионный токен и т.д.) | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | Убедитесь, что решения об авторизации принимаются как на уровне URI, за счет процедурной или декларативной безопасности на контроллере или маршрутизаторе, так и на уровне ресурсной системы, с учетом разрешений ролевой модели. | | ✓ | ✓ | 285 |\n| **13.1.5** | Убедитесь, что HTTP-запросы, содержащие непредусмотренные или несуществующие типы контента, отклоняются с соответствующими заголовками (статусы ответа HTTP 406 Unacceptable или HTTP 415 Unsupported Media Type). | | ✓ | ✓ | 434 |\n\n## V13.2 RESTful web-сервисы\n\nJSON-схемы находятся на стадии проекта стандарта (см. Ссылки). При рассмотрении вопроса о возможности проверки JSON-схем — лучшей практики для RESTful web-сервисов, — рассмотрите возможность использования следующих дополнительных проверок данных в сочетании с проверкой JSON по схеме:\n\n* Контроль синтаксического разбора объекта в JSON, например, на наличие или отсутствие элементов.\n* Проверка объекта JSON с использованием стандартных методов форматно-логического контроля, таких как тип и формат данных, ограничение длины строки и т.д.\n* и формальная проверка JSON-схемы.\n\nКак только стандарт проверки JSON-схем будет формализован, ASVS обновит свои рекомендации в этой области. Внимательно следите за используемыми библиотеками валидации схем, поскольку их необходимо будет регулярно обновлять до тех пор, пока стандарт не будет окончательно утверждён и устранены ошибки в эталонных реализациях.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.2.1** | Убедитесь, что разрешенные RESTful HTTP-методы допустимы для пользователя или действия, например, обычным пользователям нельзя использовать DELETE или PUT для защищенных API или ресурсов. | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | Прежде чем принимать входные данные в формате JSON, убедитесь в наличии схемы данных, и что по ней проводится форматно-логический контроль. | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | Убедитесь, что RESTful web-сервисы, использующие cookie, защищены от подделки межсайтовых запросов с помощью, по крайней мере, одного или нескольких из следующих способов: двойной проверки случайного значения (в POST при отправке формы и в cookie), анти-CSRF-токена (nonce) или проверки заголовка источника запроса (Origin). | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [УДАЛЕНО, ДУБЛИРУЕТ 11.1.4] | | | | |\n| **13.2.5** | Убедитесь, что REST API явно проверяют, предусмотрена ли обработка указанного во входных данных Content-Type, например application/xml или application/json. | | ✓ | ✓ | 436 |\n| **13.2.6** | Убедитесь, что заголовки и тело сообщения заслуживают доверия и не изменяются при передаче. Требования стойкого шифрования при передаче (только TLS) может быть достаточно во многих случаях, поскольку оно обеспечивает как конфиденциальность, так и защиту целостности. Электронные подписи для каждого сообщения могут дать дополнительные гарантии к средствам защиты канала передачи для приложений с высокими требованиями к безопасности, но они сопряжены с дополнительными сложностями и рисками, которые перевешивают преимущества. | | ✓ | ✓ | 345 |\n\n## V13.3 Web сервисы SOAP\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.3.1** | Убедитесь, что для обеспечения правильного формирования XML-документа до его обработки выполняется проверка каждого поля на соответствие ограничений XSD-схемы. | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | Убедитесь, что тело сообщения подписывается с помощью WS-Security, чтобы обеспечить безопасную передачу между клиентом и сервисом. | | ✓ | ✓ | 345 |\n\nПримечание. Из-за XXE-атак на DTD не следует использовать проверку DTD, и отключить её в соответствии с требованиями, изложенными в разделе V14.\n\n## V13.4 GraphQL\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **13.4.1** | Убедитесь, что для предотвращения отказа в обслуживании (DoS) GraphQL или выражения уровня данных в результате ресурсоёмких вложенных запросов применяется список разрешенных запросов или комбинация ограничения по глубине и количеству. Для более сложных сценариев следует использовать анализ стоимости запроса. | | ✓ | ✓ | 770 |\n| **13.4.2** | Убедитесь, что логика авторизации в GraphQL или на другом уровне данных реализована на уровне бизнес-логики, а не на уровне GraphQL. | | ✓ | ✓ | 285 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [Проект OWASP Serverless](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:01.945012"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x22-V14-Config.md", "content": "# V14 Конфигурация\n\n## Задачи контроля\n\nУбедитесь, что исследуемое приложение имеет:\n\n* Безопасную, воспроизводимую, автоматизированную среду сборки.\n* Усиленный контроль над библиотеками, зависимостями и конфигурациями сторонних разработчиков таким образом, чтобы устаревшие или небезопасные компоненты не включались в приложение.\n\nКонфигурация приложения по умолчанию должна быть безопасной для работы в Интернете, что означает безопасную конфигурацию «из коробки».\n\n## V14.1 Сборка и развёртывание\n\nКонвейеры сборки являются основой для повторяемой безопасности. Каждый раз, при обнаружении чего-то небезопасного, его можно устранить в исходном коде, сценариях сборки или развертывания и автоматически протестировать. Мы настоятельно рекомендуем использовать конвейеры сборки с автоматическим контролем безопасности и зависимостей, которые предупреждают или прерывают сборку для предотвращения попадания известных уязвимостей в промышленную среду. Ручные, нерегулярно выполняемые проверки, напрямую приводят к ошибкам, которых можно избежать.\n\nПо мере перехода к модели DevSecOps важно обеспечить постоянную доступность и целостность развёртывания и конфигурации для достижения эталонного состояния. В прошлом, если система была взломана, требовалось от нескольких дней до месяцев, чтобы доказать, что вторжения не повторялись. Сегодня, с появлением программно-определяемой инфраструктуры, быстрого A/B развёртывания с нулевым временем простоя и автоматизации контейнерных сборок, стало возможным автоматически и непрерывно создавать, укреплять и развёртывать эталонную замену для скомпрометированной системы.\n\nЕсли до сих пор используются традиционные модели, то необходимо предпринять ручные шаги по укрепления защиты и резервному копированию этой конфигурации, чтобы обеспечить быструю и своевременную замену скомпрометированных систем на безопасные системы с высокой степенью целостности.\n\nДля соблюдения требований этого раздела требуется автоматизированная система сборки и доступ к сценариям сборки и развёртывания.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.1.1** | Убедитесь, что процессы сборки и развертывания приложений выполняются безопасным и воспроизводимым образом, например посредством автоматизации CI/CD, автоматизированного управления конфигурациями и автоматизированными сценариями развертывания. | | ✓ | ✓ | |\n| **14.1.2** | Убедитесь, что включены флаги компилятора для всех имеющихся мер защиты и предупреждений: о переполнении буфера, включая рандомизацию стека (ASLR), предотвращение выполнения данных (DEP) и прерывание сборки при обнаружении небезопасных операций с указателями, памятью, строками форматирования, целыми числами или строками. | | ✓ | ✓ | 120 |\n| **14.1.3** | Убедитесь, что в соответствии с рекомендациями используемого сервера приложений и фреймворка укреплена безопасность конфигурации сервера. | | ✓ | ✓ | 16 |\n| **14.1.4** | Убедитесь, что приложение, конфигурация и все зависимости могут быть повторно развернуты с помощью сценариев автоматического развёртывания, созданы из документированного и протестированного runbook в разумные сроки или своевременно восстановлены из резервных копий. | | ✓ | ✓ | |\n| **14.1.5** | Убедитесь, что для обнаружения несанкционированного доступа уполномоченные администраторы могут проверять целостность всех конфигураций, связанных с безопасностью. | | | ✓ | |\n\n## V14.2 Зависимости\n\nУправление зависимостями имеет решающее значение для безопасной работы любого приложения любого типа. Отсутствие своевременного обновления устаревших или небезопасных зависимостей является основной причиной самых масштабных и дорого обошедшихся атак на сегодняшний день.\n\nПримечание: Соответствие требованию 14.2.1 на уровне L1 относится к определению состава клиентских и прочих библиотек и компонентов, а не к более точному статическому анализу кода во время сборки или анализу зависимостей. Эти детали при необходимости могут быть выяснены устно.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.2.1** | Убедитесь, что все компоненты обновляются, желательно с помощью инструмента проверки зависимостей во время сборки или компиляции. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | Убедитесь, что удалены все ненужные функции, документация, примеры приложений и конфигураций. | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | Убедитесь, что если ресурсы приложения, такие как библиотеки JavaScript, CSS или web-шрифты, размещаются извне (в сети доставки контента (CDN) или у внешнего разработчика), то для проверки целостности этого ресурса используется Subresource Integrity (SRI). | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | Убедитесь, что сторонние компоненты берутся из утвержденных, доверенных и постоянно поддерживаемых репозиториев. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | Убедитесь, что для всех используемых сторонних библиотек ведется спецификация программного обеспечения (SBOM). ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | Убедитесь, что поверхность атаки сокращается за счет изоляции сторонних библиотек или инкапсуляции их функций таким образом, чтобы они демонстрировали приложению только требуемое поведение. ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 Непреднамеренное раскрытие информации о безопасности\n\nКонфигурации для среды промышленной эксплуатации должны быть укреплены для защиты от распространенных атак, таких как консоли отладки, межсайтовые сценарии (XSS), удаленное включение файлов (RFI) а также для устранения тривиальных «уязвимостей» раскрытия информации, которые, к сожалению, являются приметой многих отчетов о тестировании на проникновение. Сами подобные уязвимости редко оцениваются как значительные, но они «приглашают друзей». Если их нет по умолчанию, это повышает уровень защиты, т.к. многие атаки не смогут увенчаться успехом.\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.3.1** | [УДАЛЕНО, ДУБЛИРУЕТ 7.4.1] | | | | |\n| **14.3.2** | Убедитесь, что в промышленной среде отключены режимы отладки web-сервера, сервера или платформы приложений, чтобы отключить функции отладки, консоль разработчика и исключить непреднамеренное раскрытие информации о безопасности. | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | Убедитесь, что в HTTP-заголовках или HTTP-ответах не содержится информации о версии системных компонентов. | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 HTTP-заголовки безопасности\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.4.1** | Убедитесь, что каждый HTTP-ответ содержит заголовок Content-Type. Если тип контента — text/*, /+xml или application/xml, то должна быть указана безопасная кодовая страница (например, charset=UTF-8 или ISO-8859-5). Контент должен соответствовать предоставленному заголовку Content-Type. | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | Убедитесь, что все ответы API содержат заголовок Content-Disposition: attachment; filename=\"api.json\" (или другое наименование файла, подходящее для этого типа контента). | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | Убедитесь, что присутствует заголовок ответа Content Security Policy (CSP), который помогает ослабить воздействие XSS-атак через HTML, DOM, JSON или через инъекции JavaScript. | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | Убедитесь, что ответы содержат заголовок X-Content-Type-Options: nosniff. | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | Убедитесь, что заголовок Strict-Transport-Security включен во все ответы и для всех поддоменов, например, Strict-Transport-Security: max-age=15778463; includeSubDomains. | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | Убедитесь, что присутствует заголовок Referrer-Policy с уместным для приложения значением, чтобы избежать раскрытия недоверенным сторонам конфиденциальной информации в URL-адресе через заголовок Referer. | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | Убедитесь, что содержимое web-приложения по умолчанию не может быть встроено на сторонний сайт, и что встраивание оригинальных ресурсов приложения возможно только с разрешения автора, используя соответствующие заголовки ответов Content-Security-Policy: frame-ancestors и X-Frame-Options. | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 Проверка заголовка HTTP-запроса\n\n| № | Описание | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---:| :---: | :---: |\n| **14.5.1** | Убедитесь, что сервер приложений принимает только те HTTP-методы, которые использует приложение/API, и регистрирует/предупреждает о любых запросах, недопустимых для контекста приложения. | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | Убедитесь, что полученный заголовок Origin не используется для аутентификации или при принятии решений о контроле доступа, поскольку он может быть легко изменен злоумышленником. | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | Убедитесь, что заголовок Access-Control-Allow-Origin при совместном использовании ресурсов (CORS) применяет для сопоставления строгий список разрешенных доверенных доменов и поддоменов, а не \"null\". | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | Убедитесь, что приложением аутентифицируются HTTP-заголовки, добавляемые доверенным прокси-сервером или устройствами единого входа (SSO), например, через токен на предъявителя (bearer). | | ✓ | ✓ | 306 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* Добавление `Content-Disposition` к ответам API помогает предотвратить многие атаки, основанные на несогласованности в `MIME type` между клиентом и сервером, а опция `filename` помогает предотвратить [атаки Reflected File Download (RFD)](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:40:01.999803"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x90-Appendix-A_Glossary.md", "content": "# Приложение A: Термины и сокращения\n\n- **Address Space Layout Randomization** (ASLR) –*рандомизация распределения адресного пространства*– метод, позволяющий усложнить использование ошибок, связанных с повреждением памяти.\n- **Allow list** – список разрешённых данных или операций, например список символов, разрешённых форматно-логическим контролем.\n- **Application Security** –*безопасность приложений*– анализ компонентов, составляющих прикладной уровень эталонной модели взаимодействия открытых систем (модели OSI), и в меньшей степени – инфраструктуры, например, операционных систем или сетей.\n- **Application Security Verification** –*верификация требований к безопасности приложений*– технический анализ приложения по стандарту OWASP ASVS.\n- **Application Security Verification Report** – отчёт по тестированию конкретного приложения, в котором аудитор документирует общие результаты и даёт сопроводительные пояснения.\n- **Authentication** –*аутентификация*– проверка учетных данных, предъявленных пользователем приложения.\n- **Automated Verification** –*автоматизированная проверка*– поиск сигнатур уязвимостей с помощью автоматизированных инструментов динамического и/или статического анализа безопасности кода.\n- **Black box testing** –*метод «чёрного ящика»*– метод тестирования программного обеспечения, который проверяет функциональность приложения, не заглядывая в его внутреннюю структуру и операции.\n- **Component** –*компонент*– автономный блок кода со связанными дисковыми и сетевыми интерфейсами, который взаимодействует с другими компонентами.\n- **Cross-Site Scripting** (XSS) –*межсайтовый скриптинг*– уязвимость в системе безопасности, обычно обнаруживаемая в web-приложениях, позволяющая внедрять скрипты в контент на стороне клиента.\n- **Cryptographic module** –*криптографический модуль*– аппаратное, программное и/или микропрограммное обеспечение, реализующее криптографические алгоритмы и/или генерирующее криптографические ключи.\n- **Common Weakness Enumeration** (CWE) –*список общих недостатков*– разработанный сообществом список распространенных недостатков безопасности программного обеспечения. Он служит общим языком, мерилом для средств обеспечения безопасности программного обеспечения, а также основой для выявления недостатков, их устранения и предотвращения.\n- **Design Verification** –*верификация дизайна*– технический анализ архитектуры безопасности приложения.\n- **Dynamic Application Security Testing** (DAST) –*динамический анализ кода*– технологии, предназначенные для обнаружения условий, указывающих на уязвимость системы безопасности в приложении, производящийся во время его выполнения на реальном или виртуальном процессоре.\n- **Dynamic Verification** –*динамическая верификация*– использование автоматизированных инструментов, использующих сигнатуры уязвимостей для поиска проблем во время выполнения приложения.\n- **Fast IDentity Online** (FIDO) - набор стандартов аутентификации, которые позволяют использовать различные методы аутентификации, включая биометрические данные, модули доверенной платформы (TPM), USB-токены и т.д.\n- **Globally Unique Identifier** (GUID) – уникальный индекс, используемый в качестве идентификатора в программном обеспечении.\n- **Hyper Text Transfer Protocol** (HTTPS) – протокол приложений для распределенных, гипермедиа (гипертекст+мультимедиа)-систем и совместной работы. Основа для передачи данных в World Wide Web.\n- **Hardcoded keys** –*жёстко запрограммированные ключи*– криптографические ключи, которые хранятся в файловой системе, будь то код, комментарии или файлы.\n- **Hardware Security Module** (HSM) —*аппаратный модуль безопасности*— аппаратный компонент, способный хранить криптографические ключи и другие секреты в защищённом виде.\n- **Hibernate Query Language** (HQL) – язык запросов, внешне похожий на SQL, используемый библиотекой Hibernate ORM.\n- **Input Validation** —*форматно-логический контроль*— нормализация и проверка корректности недоверенных входных данных.\n- **Malicious Code** —*вредоносный код*— код, попавший в приложение во время его разработки без ведома его автора, который обходит имеющуюся политику безопасности приложения. Не путать с вредоносным ПО, таким как вирусы или черви.\n- **Malware** —*вредоносное ПО*— исполняемый код, который попадает в приложение во время выполнения без ведома пользователя или администратора приложения.\n- **Open Web Application Security Project** (OWASP) – бесплатно распространяемый проект и открытое международное сообщество, занимающееся повышением безопасности прикладного программного обеспечения. Наша миссия — сделать безопасность приложений «видимой», чтобы люди и организации могли принимать обоснованные решения о рисках безопасности приложений. См.: <https://www.owasp.org/>\n- **One-time Password** (OTP) —*одноразовый пароль*— уникальный пароль, сгенерированный для одноразового использования.\n- **Object-relational Mapping** (ORM) - система, позволяющая приложению делать запросы к реляционной/табличной базе данных, используя объектную модель, совместимую с приложением.\n- **Password-Based Key Derivation Function 2** (PBKDF2) - специальный односторонний алгоритм для формирования стойкого криптографического ключа на основе введённого текста (например, пароля) и дополнительного случайного значения — соли, которая затрудняет взлом пароля в режиме offline, если вместо исходного пароля хранится результирующее значение.\n- **Personally Identifiable Information** (PII) —*информация, позволяющая установить личность*— информация, которая может быть использована сама по себе или в совокупности с другой информацией для идентификации, установления контакта или определения местонахождения конкретного человека.\n- **Position-independent executable** (PIE) —*позиционно-независимый исполняемый файл*— текст машинного кода, который, будучи помещен где-то в основной памяти, выполняется должным образом независимо от его абсолютного адреса.\n- **Public Key Infrastructure** (PKI) —*инфраструктура открытых ключей*— механизм, который связывает открытые ключи с соответствующими идентификаторами сущностей. Привязка устанавливается посредством процесса регистрации и выдачи сертификатов в центре сертификации (CA) и с его помощью.\n- **Public Switched Telephone Network** (PSTN) —*коммутируемая телефонная сеть общего пользования (ТСОП, ТфОП)*— традиционная телефонная сеть, соединяющая как стационарные, так и мобильные телефоны.\n- **Relying Party** (RP) —*проверяющая сторона*— как правило, приложение, которое удостоверяет пользователя данного поставщика учетных данных. Приложение проверяет токен или набор подписанных утверждений, предоставляемых этим поставщиком, чтобы убедиться, что пользователь является тем, за кого себя выдает.\n- **Static application security testing** (SAST) –*статический анализ кода*– ряд технологий, предназначенных для анализа исходного кода приложения, байт-кода и бинарных файлов на наличие условий разработки и проектирования, которые указывают на уязвимости в системе безопасности. Решения SAST анализируют приложение «изнутри» в незапущенном состоянии.\n- **Software development lifecycle** (SDLC) –*жизненный цикл разработки программного обеспечения*– пошаговый процесс разработки ПО, начиная с первоначальных требований, и заканчивая развертыванием и сопровождением.\n- **Security Architecture** –*архитектура безопасности*– абстракция дизайна приложения, которая определяет и описывает, где и как применяются меры безопасности, а также местоположение и категории информации.\n- **Security Configuration** –*конфигурация безопасности*– конфигурация среды выполнения приложения, которая влияет на то, как применяются меры безопасности.\n- **Security Control** –*мера обеспечения безопасности*– функция или компонент, который контролирует (например, меры контроля доступа) или приводит к действию по обеспечению безопасности (например, регистрирует запись в журнале аудита).\n- **Server-side Request Forgery** (SSRF) –*подделка запросов на стороне сервера*– атака, которая злоупотребляет функциональными возможностями сервера для чтения или обновления внутренних ресурсов путем предоставления или изменения URL-адреса, по которому код, запущенный на сервере, будет читать или отправлять данные.\n- **Single Sign-on Authentication** (SSO) –*аутентификация единого входа*– пользователь входит в одно приложение, одновременно получая возможность войти в несколько других, без необходимости повторной аутентификации. Например, когда вы входите в Google, вы автоматически входите в другие сервисы Google, такие как YouTube, Google Docs, Gmail и т.д.\n- **SQL Injection** (SQLi) –*SQL-инъекция*– метод внедрения кода, используемый для атаки приложений, управляемых данными, в которых вредоносные SQL-выражения вставляются в точку входа.\n- **SVG** - Scalable Vector Graphics –*масштабируемая векторная графика*\n- **Time-based OTP** (TOTP) - метод создания OTP, при котором текущее время является входным аргументом для алгоритма формирования пароля.\n- **Threat Modeling** –*моделирование угроз*– метод, состоящий в совершенствовании архитектур безопасности для выявления нарушителей, границ доверия, мер безопасности, а также ключевых технических и бизнес-активов.\n- **Transport Layer Security** (TLS) –*безопасность транспортного уровня*– криптографические протоколы, обеспечивающие безопасность канала связи по сетевому соединению.\n- **Trusted Platform Module** (TPM) –*модуль доверенной платформы*– тип HSM, который обычно является компонентом другого оборудования, например, материнской платы, и выступает в роли «корня доверия» для этой системы.\n- **Two-factor authentication** (2FA) –*двухфакторная аутентификация (2ФА)*– добавляет еще один уровень аутентификации для входа в учетную запись.\n- **Universal 2nd Factor** (U2F) –*универсальный второй фактор*– один из стандартов, разработанных FIDO специально для использования в качестве второго фактора аутентификации NFC- или USB-токена.\n- **URI/URL/фрагменты URL** –*унифицированный  идентификатор ресурса*– это строка символов, используемая для идентификации имени или web-ресурса. –*Унифицированный указатель ресурсов*– часто используется в качестве ссылки на ресурс.\n- **Verifier** –*верификатор/аудитор*– лицо или группа людей, которые анализируют безопасность приложение на соответствие требованиям OWASP ASVS.\n- **What You See Is What You Get** (WYSIWYG) – тип редактора гипермедиа, который показывает, как на самом деле будет выглядеть содержимое при отображении, а не код разметки, управляющий отображением.\n- **Сертификат X.509** – электронный сертификат, соответствующий общепринятому международному стандарту инфраструктуры открытых ключей X.509 (PKI) для проверки принадлежности открытого ключа идентификатору пользователя, компьютера или сервиса, указанному в сертификате.\n- **XML eXternal Entity** (XXE) – тип элемента XML, который может получать доступ к локальному или удаленному содержимому через объявленный идентификатор. Может привести к атакам инъекции.\n", "timestamp": "2025-10-24T11:40:02.103822"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x91-Appendix-B_References.md", "content": "# Приложение B: Полезные ссылки\n\nСледующие проекты OWASP, скорее всего, будут полезны для читателей/последователей этого стандарта:\n\n## Основные проекты OWASP\n\n1. Проект OWASP Top 10: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Security Knowledge Framework: [https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## Проект OWASP Cheat Sheet Series\n\n[В этом проекте](https://owasp.org/www-project-cheat-sheets/) есть памятки, которые будут актуальны для многих требований ASVS.\n\nСопоставление памяток с требованиями ASVS можно найти здесь: [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## Проекты Mobile Security\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Проект OWASP Internet of Things\n\nOWASP Internet of Things: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Проект OWASP Serverless\n\nOWASP Serverless: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Другие\n\nСледующие web-сайты, скорее всего, также будут полезны для читателей/последователей этого стандарта:\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://ru.pcisecuritystandards.org/_onelink_/pcisecurity/en2ru/minisite/en/docs/PCI_DSS_v3-2-1_RU.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:40:02.163992"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/ru/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/ru/0x93-Appendix-C_IoT.md", "content": "# Приложение C: Требования к верификации Internet of Things\n\nЭта глава изначально была в основной ветке, но с учётом работы, проделанной командой OWASP IoT, нет смысла поддерживать две разные ветки по этому вопросу. Для версии 4.0 мы переносим это в Приложение и призываем всех, кому это требуется, переходить в основной проект [OWASP IoT](https://owasp.org/www-project-internet-of-things/)\n\n## Задачи контроля\n\nВстраиваемые / IoT-устройства должны:\n\n* Обеспечивать тот же уровень безопасности на устройстве, что и на сервере, применяя меры безопасности в доверенной среде.\n* Конфиденциальные данные, хранящиеся на устройстве, должны храниться безопасным образом с использованием аппаратного хранилища, например, Secure Element.\n* Все конфиденциальные данные, передаваемые с устройства, должны использовать безопасность транспортного уровня (TLS).\n\n## Верификация требований к безопасности\n\n| № | Описание | L1 | L2 | L3 | Версия |\n| --- | --- | --- | --- | -- | -- |\n| **C.1** | Убедитесь, что последовательные интерфейсы отладки прикладного уровня, такие как USB, UART и другие, отключены или защищены сложным паролем. | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | Убедитесь, что криптографические ключи и сертификаты уникальны для каждого отдельного устройства. | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | Убедитесь, что во встроенной операционной системе/IoT включены средства защиты памяти, такие как ASLR и DEP, если применимо. | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | Убедитесь, что отключены встроенные интерфейсы отладки, такие как JTAG или SWD, или что имеющийся механизм защиты включен и настроен соответствующим образом. | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | Убедитесь, что если на SoC или процессоре устройства реализовано доверенное выполнение, то оно включено. | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | Убедитесь, что конфиденциальные данные, закрытые ключи и сертификаты безопасно хранятся в Secure Element, TPM, TEE (Trusted Execution Environment) или защищены с помощью стойкой криптографии. | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | Убедитесь, что приложения встроенного ПО защищают передаваемые данные с помощью безопасности транспортного уровня (TLS). | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | Убедитесь, что приложения встроенного ПО проверяют электронную подпись подключений к серверу. | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | Убедитесь, что беспроводные подключения проходят взаимную аутентификацию. | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | Убедитесь, что беспроводные подключения осуществляются по зашифрованному каналу.  | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | Убедитесь, что любое использование запрещенных функций на языке C заменено их безопасными эквивалентами. | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | Убедитесь, что каждая \"прошивка\" содержит спецификацию программного обеспечения с каталогом сторонних компонентов, версиями и опубликованными уязвимостями. | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | Убедитесь, что весь код, включая сторонние бинарные файлы, библиотеки и фреймворки, проверяется на наличие в коде учётных данных (бэкдоров). | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | Убедитесь, что компоненты приложения и встроенного ПО не подвержены инъекции команд операционной системы, вызывая команды оболочки ОС или скрипты, и что меры безопасности их предотвращают. | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | Убедитесь, что приложения встроенного ПО закрепляют (pinning) электронную подпись на доверенных серверах. |  | ✓ | ✓ | 4.0 |\n| **C.16** | Убедитесь в наличии средств защиты от несанкционированного доступа и/или его обнаружения. |  | ✓ | ✓ | 4.0 |\n| **C.17** | Убедитесь, что включены все имеющиеся технологии защиты интеллектуальной собственности, предоставляемые производителем чипа. |  | ✓ | ✓ | 4.0 |\n| **C.18** | Убедитесь, что меры безопасности препятствуют обратному инжинирингу встроенного ПО (например, удалению символов детализации отладки). |  | ✓ | ✓ | 4.0 |\n| **C.19** | Убедитесь, что перед загрузкой устройство проверяет подпись загрузочного образа. |  | ✓ | ✓ | 4.0 |\n| **C.20** | Убедитесь, что процесс обновления прошивки не подвержен атакам типа «момент проверки до момента использования». |  | ✓ | ✓ | 4.0 |\n| **C.21** | Перед установкой убедитесь, что устройство использует подпись кода и проверяет файлы обновления прошивки. |  | ✓ | ✓ | 4.0 |\n| **C.22** | Убедитесь, что версия прошивки устройство не может быть понижена до старых версий (анти-откат). |  | ✓ | ✓ | 4.0 |\n| **C.23** | Проверьте использование криптографического генератора псевдослучайных чисел на встроенном устройстве (например, с использованием генераторов случайных чисел, предоставляемых чипом). |  | ✓ | ✓ | 4.0 |\n| **C.24** | Убедитесь, что прошивка может выполнять автоматическое обновление по заданному расписанию. |  | ✓ | ✓ | 4.0 |\n| **C.25** | Убедитесь, что устройство стирает прошивку и конфиденциальные данные при обнаружении несанкционированного доступа или получении недопустимого сообщения. |  |  | ✓ | 4.0 |\n| **C.26** | Убедитесь, что используются только микроконтроллеры, поддерживающие отключение интерфейсов отладки (например, JTAG, SWD). |  |  | ✓ | 4.0 |\n| **C.27** | Убедитесь, что используются только те микроконтроллеры, которые обеспечивают существенную защиту от декапинга (анг.: de-capping) и атак по побочным каналам. |  |  | ✓ | 4.0 |\n| **C.28** | Убедитесь, что конфиденциальные дорожки не соприкасаются с внешними слоями печатной платы. |  |  | ✓ | 4.0 |\n| **C.29** | Убедитесь, что канал связи между микросхемами зашифрован (например, между основной и дочерней платой). |  |  | ✓ | 4.0 |\n| **C.30** | Убедитесь, что устройство использует подпись кода и проверяет код перед выполнением. |  |  | ✓ | 4.0 |\n| **C.31** | Убедитесь, что конфиденциальная информация, хранящаяся в памяти, перезаписывается нулями, как только она больше не требуется. |  |  | ✓ | 4.0 |\n| **C.32** | Убедитесь, что приложения встроенного ПО используют контейнеры ядра для изоляции между приложениями. |  |  | ✓ | 4.0 |\n| **C.33** | Убедитесь, что для сборок микропрограмм настроены безопасные флаги компилятора, такие как -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap. |  |  | ✓ | 4.0 |\n| **C.34** | Убедитесь, что в микроконтроллере настроена защита кода (если применимо).|  |  | ✓ | 4.0 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:40:02.222322"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x01-Frontispiece.md", "content": "# 卷首语\n\n## 关于本标准\n\n应用安全验证标准，是一份要求和测试应用安全的清单，可供架构师、开发人员、测试人员、安全专家、工具供应商和消费者参考，用于定义、构建、测试和验证安全的应用。\n\n## 版权和许可\n\nVersion 4.0.3, 2021年10月\n\n![license](../images/license.png)\n\nCopyright © 2008-2021 The OWASP Foundation. 本文档根据 [Creative Commons Attribution ShareAlike 3.0 license](https://creativecommons.org/licenses/by-sa/3.0/) 发布。 对于任何重用或分发，你必须向他人明确说明本作品的许可条款。\n\n## 项目负责人\n\n|                      \t|                 \t|            \t|\n|----------------------\t|-----------------\t|------------\t|\n| Andrew van der Stock \t| Daniel Cuthbert \t| Jim Manico \t|\n| Josh C Grossman      \t| Elar Lang     \t|            \t|\n\n## 主要贡献者\n\n|                \t|                \t|                   \t|\n|----------------\t|----------------\t|-------------------\t|\n| Abhay Bhargav  \t| Benedikt Bauer \t| Osama Elnaggar    \t|\n| Ralph Andalis \t| Ron Perris     \t| Sjoerd Langkemper \t|\n| Tonimir Kisasondi |               \t|                   \t|\n\n## 其他贡献者和审查者\n\n|                     |                    |                   |                  |                   |\n| ------------------- | ------------------ | ----------------- | ---------------- | ----------------- |\n| Aaron Guzman        | Alina Vasiljeva    | Andreas Kurtz     | Anthony Weems    | Barbara Schachner |\n| Christian Heinrich  | Christopher Loessl | Clément Notin     | Dan Cornell      | Daniël Geerts     |\n| David Clarke        | David Johansson    | David Quisenberry | Elie Saad        | Erlend Oftedal    |\n| Fatih Ersinadim     | Filip van Laenen   | Geoff Baskwill    | Glenn ten Cate   | Grant Ongers      |\n| hello7s             | Isaac Lewis        | Jacob Salassi     | James Sulinski   | Jason Axley       |\n| Jason Morrow        | Javier Dominguez   | Jet Anderson      | jeurgen          | Jim Newman        |\n| Jonathan Schnittger | Joseph Kerby       | Kelby Ludwig      | Lars Haulin      | Lewis Ardern      |\n| Liam Smit           | lyz-code           | Marc Aubry        | Marco Schnüriger | Mark Burnett      |\n| Philippe De Ryck    | Ravi Balla         | Rick Mitchell     | Riotaro Okada    | Robin Wood        |\n| Rogan Dawes         | Ryan Goltry        | Sajjad Pourali    | Serg Belkommen   | Siim Puustusmaa   |\n| Ståle Pettersen     | Stuart Gunter      | Tal Argoni        | Tim Hemel        | Tomasz Wrobel     |\n| Vincent De Schutter | Mike Jang          |                   |                  |                   |\n\n\n\n如果上面的 4.0.3 致谢列表中缺少某些内容，请在GitHub上记录一个工单，以便在未来的更新中得到确认。\n\n从2008年的ASVS 1.0，到2016年的3.0，这份应用安全验证标准，一直都站在前人的肩膀上。 直到今天，ASVS中的大部分结构和验证项，都是最初由Mike Boberski、Jeff Williams和Dave Wichers编写的，但还有许多贡献者。 感谢那些以前参与过的人。若需查看所有早期版本贡献者的名单，请查阅每个以前的版本。\n", "timestamp": "2025-10-24T11:40:03.048988"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x02-Preface.md", "content": "# 序言\n\n欢迎来到应用安全验证标准（Application Security Verification Standard，以下简称ASVS）4.0版。 ASVS是一项社区驱动的工作，旨在建立一个安全要求和控制的框架，在设计、开发和测试现代网络应用程序和网络服务时，定义所需要的功能和非功能性的安全控制措施。\n\n4.0.3版是对4.0版的第三个小补丁，旨在修正拼写错误，使需求更清晰，而不做实质性的改变（如加强或增加需求）。 然而，在我们认为合适的地方，一些要求可能被稍微削弱，一些完全多余的要求被删除（但没有重新编号）。\n\nASVS v4.0是过去十年来社区努力和行业反馈的结晶。 我们试图让 ASVS 更容易地适应安全软件开发生命周期中的各种用例场景。\n\n我们知道，对于任何 Web 应用程序标准（包括 ASVS）的内容，很可能永远不会达成 100% 的一致。 在某种程度上，风险分析总是主观的，这对试图以一刀切的标准来概括造成了一种挑战。 然而，我们希望这个最新的版本，是朝着正确方向迈出的一步，并增强了这个关键行业标准中的概念。\n\n## 4.0版的新内容\n\n这个版本中最重要的变化，是采用了 NIST 800-63-3 数字身份指南，引入了现代的、基于证据的高级认证控制。 虽然我们预计在与高级认证标准接轨方面会有一些阻力（这个广受好评的应用安全标准是基于证据的），但我们认为标准保持一致是非常必要的。\n\n信息安全标准应尽量减少独特要求的数量，以便遵守的组织不必决定冲突或不兼容的控制措施。 在认证和会话管理方面，《OWASP Top 10 2017》和现在的《OWASP 应用安全验证标准》，已与NIST 800-63保持一致。我们鼓励其他标准制定机构与我们、NIST和其他机构合作，制定一套普遍接受的应用安全控制措施，最大限度地提高安全性和减少合规成本。\n\nASVS 4.0从头到尾都进行了重新编号。新的编号方案使我们能够弥补长期消失的章节的空白，并允许我们分割较长的章节，以尽量减少开发人员或团队必须遵守的控制项。例如，如果应用程序不使用JWT，那么会话管理中有关 JWT 的整个部分都不适用。\n\n4.0版本中的新内容，是对 常见弱点列举（Common Weakness Enumeration，以下简称CWE）的全面映射，这是我们在过去十年中最普遍的功能要求之一。 CWE 映射，允许供应商和使用漏洞管理软件的人，将其他工具和先前 ASVS 版本的内容，同 4.0 及之后的版本进行匹配。 为了给 CWE 条目腾出空间，我们不得不取消“起始时间”列，由于我们完全重新编号，因此这一列意义不大。 并非ASVS中的每个项目都有相关的CWE，由于CWE有大量的重复，我们尝试使用最常用而非最接近的匹配项。 验证控制，并不总是可以对应到等效的CWE。 我们乐意与 CWE 社区和信息安全领域就缩小这一差距进行更广泛的讨论。\n\n我们致力于全面满足并超越《OWASP Top 10 2017》和《OWASP Proactive Controls 2018》的要求。由于《OWASP Top 10 2017》是避免疏忽的最低要求，我们特意将Top 10中的所有要求（除“日志记录”外）列为1级控制（Level 1），让OWASP Top 10的采用者，更容易将实际的安全标准落地。\n\n我们着手确保ASVS 4.0 1级（Level 1），是PCI DSS 3.2.1第6.5节的超集，用于应用程序设计、编码、测试、代码安全审计和渗透测试。这需要覆盖 V5 中的缓冲区溢出和不安全内存操作，以及 V14 中与不安全内存相关的编译标志，以及现有行业领先的应用程序和 Web 服务验证要求。\n\nW我们已经完成了ASVS的转变，从单一的服务器端控制，到为所有现代应用和API提供安全控制。 在server-less API、移动、云、容器、CI/CD和DevSecOps、联邦等等的时代，我们不能继续忽视现代应用架构。 现代应用的设计，与2009年最初的ASVS发布时的设计大不相同。ASVS必须始终着眼于未来，这样我们才能为我们的主要受众——开发者提供合理的建议。 我们已经删除了那些“假设应用程序在单个组织拥有的系统上执行”的要求。\n\n由于ASVS 4.0的规模，以及我们希望成为所有其他应用安全验证标准的基线，我们已经淘汰了“移动”章节，转而支持移动应用程序安全验证标准（MASVS）。 物联网附录将出现在未来OWASP IoT项目的物联网ASVS中。我们在附录C中包含了物联网ASVS的早期预览。 感谢OWASP Mobile团队和OWASP IoT项目团队对ASVS的支持，期待未来与他们合作提供补充标准。\n\n最后，我们删除和淘汰了影响较小的控制项。 随着时间的推移，ASVS开始成为一套全面的控制措施，但并非所有控制项在开发安全软件方面都是平等的。 消除低影响项目的努力可能会更进一步。 在 ASVS 的未来版本中，通用弱点评分系统（Common Weakness Scoring System，CWSS），将有助于进一步优先考虑那些真正重要的控制和应该停用的控制。\n\n从4.0版本开始，ASVS将专注于成为领先的Web应用程序和服务标准，涵盖传统和现代应用架构，以及敏捷的安全实践和DevSecOps文化。\n", "timestamp": "2025-10-24T11:40:03.160811"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x03-Using-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x03-Using-ASVS.md", "content": " # 使用ASVS\n\nASVS有两个主要目标：\n\n* 帮助组织开发和维护安全的应用程序。\n* 允许安全服务厂商、安全工具供应商和消费者调整他们的要求和产品。\n\n## 应用安全验证级别\n\n应用程序安全验证标准（ASVS）定义了三个安全验证级别，每个级别的深度都在增加。\n\n* ASVS Level 1 适用于低保证级别，可通过渗透测试验证。\n* ASVS Level 2 适用于包含敏感数据的应用程序（需要保护），是大多数应用程序的推荐级别。\n* ASVS Level 3 适用于最关键的应用程序：执行高价值交易、包含敏感医疗数据的应用程序，或任何需要最高级别信任的应用程序。\n\n每个ASVS级别都包含一个安全要求的列表。其中的每一项，都可以对应到开发人员必须在软件中建立的特定安全特性和功能。\n\n![ASVS Level](https://raw.githubusercontent.com/OWASP/ASVS/master/4.0/images/asvs_40_levels.png \"ASVS Level\")\n\n图1 - OWASP应用安全验证标准级别（4.0版）\n\nLevel 1 是唯一可以由人类进行渗透测试的级别。 所有其他的等级都需要接触文档、源代码、配置以及开发人员。 然而，即使L1允许通过“黑盒”（无文档和无源代码）测试来验证，但它并不是有效的保证活动，应尽量避免单独采用。 恶意攻击者有大量的时间，但大多数渗透测试在几周内就会结束。 防御者需要在合理的时间内，建立安全控制，发现、解决和保护所有的弱点，检测和应对恶意攻击者。恶意攻击者的时间基本上是无限的，只需要一处漏洞，或者一个缺少检测的弱点就可以成功。 黑盒测试，通常在开发结束时快速执行，或者根本不执行，完全无法应对这种不对称性。\n\n在过去的 30 多年里，黑盒测试一次又一次被证明会遗漏关键的安全问题，直接导致了越来越多的大规模漏洞。 我们强烈鼓励使用广泛的安全保证和验证，包括用 Level 1 的源代码主导的（混合）渗透测试来取代渗透测试，在整个开发过程中可以充分接触到开发人员和文档。 金融监管机构不会容忍“无法接触账本、交易样本或执行控制的人员”的外部财务审计。 行业和政府必须要求软件工程领域具有相同的透明度标准。\n\n我们强烈鼓励在开发过程中使用安全工具。 构建管道可以持续使用 DAST 和 SAST 工具，来查找容易发现的、不应该出现的安全问题。\n\n在没有人工协助的情况下，ASVS中超过半数的验证项无法被自动化工具和在线扫描完成。 如果需要对每次构建进行全面的自动化测试，则使用自定义单元和集成测试的组合，以及由构建发起的在线扫描。 业务逻辑缺陷和访问控制测试只能使用人工协助。 这些内容应该变成单元和集成测试。\n\n## 如何使用这个标准\n\n使用应用程序安全验证标准（ASVS）的最佳方法之一，是将其作为一个蓝图，创建一个针对您的应用程序、平台或组织的安全编码检查表。 建议您根据不同的项目场景，针对其中最重要的安全要求，在定制的ASVS中增加关注。\n\n### Level 1 - 第一步，自动化，或全景图\n\n如果一个应用程序能够充分防御 OWASP Top10 或其他类似检查表中提到的那些容易发现的安全漏洞，那么它就达到了ASVS Level 1。\n\nLevel 1，是所有应用程序应争取的最低限度。 作为多个阶段工作的第一步，或是当应用程序不存储或处理敏感数据，因此不需要L2或L3的更严格的控制时，它也是有用的。 Level 1控制可以通过工具自动检查，也可以在不访问源代码的情况下简单地手动检查。我们认为Level 1是所有应用程序的最低要求。\n\n对应用程序的威胁，往往来自那些使用简单、省力的技术来识别“简单漏洞”的攻击者。 这与坚定的攻击者形成对比，后者将花费集中的精力专门针对应用程序。 如果您的应用程序处理的数据具有很高的价值，您很少会止步于Level 1。\n\n### Level 2 - 大多数应用程序\n\n如果一个应用程序能够充分抵御当今与软件相关的大多数风险，那么它就达到了ASVS Level 2（级别或标准）。\n\nLevel 2 确保安全控制在应用程序中得到有效的落实。 Level 2 通常适用于处理重要B2B事务（B2B，Business-to-Business）的应用程序， 包括处理医疗保健信息、实施关键业务、实现敏感功能、或处理敏感资产的应用程序，或完整性是保护其业务的关键方面的行业，例如打击游戏外挂和作弊的游戏行业。\n\n对 Level 2 应用程序的威胁，通常是熟练的和有动机的攻击者，他们专注于特定的目标，使用工具和技术有效地发现和利用应用程序中的风险。\n\n### Level 3 - 高价值、高保证或高安全性\n\nASVS Level 3，是 ASVS 内的最高级别验证。 这个级别通常保留给需要大量安全验证的应用，例如军事、健康、安全和关键基础设施等领域的应用。\n\n对于执行关键功能的应用程序，组织可能需要 ASVS Level 3，在这种情况下，故障可能会严重影响组织的运作，甚至影响其生存。下面提供了有关 ASVS 3Level 3应用的示例指导。 如果一个应用程序能够充分防御高级应用程序的安全漏洞，并显示出良好的安全设计原则，那么它就达到了ASVS Level 3（或高级）。\n\n与其他级别相比，ASVS Level 3 的应用程序需要对架构、编码和测试进行更深入的分析。 安全的应用程序以有意义的方式模块化的（以促进弹性，可扩展性，以及最重要的安全层），每个由网络连接和/或物理实例分开的模块，负责自己纵深防御的安全职责，这需要适当的记录。 职责包括确保机密性（例如加密）、完整性（例如事务、输入验证）、可用性（例如优雅地处理负载）、身份验证（包括系统之间）、授权和审计（日志记录）的控制。\n\n## 在实践中应用ASVS\n\n不同的威胁有不同的动机。某些行业有独特的信息和技术资产，以及特定领域的监管要求。\n\n我们强烈建议，各组织根据其业务性质，深入研究其独特的风险特征，并根据该风险和业务要求，确定适当的ASVS级别。\n\n## 如何引用ASVS要求\n\n每个需求都有一个标识符，格式为 `<章>.<节>.<要求>` ，每个元素都是一个数字，例如：`1.11.3` 。\n- `<chapter>` 值对应于需求出现的章，例如：所有 `1.#.#` 的需求都来自`Architecture`这一章。\n- `<section>` 值对应于该章中需求出现的小节，例如：所有 `1.11.#` 需求都在 `Architecture` 章的 `Business Logic Architecture` 部分。\n- `<requirement>`值对应该章的具体要求，例如：本标准的4.0.3版本中的 `1.11.3` 是：\n\n> 验证所有高价值业务逻辑流（包括身份验证、会话管理和访问控制）都是线程安全的，并且可以防止“检查时间和使用时间不一致”导致的条件竞争问题。\n\n标识符可能会在标准版本之间发生变化，因此在其他文档、报告或工具最好使用以下格式： `v<version>-<chapter>.<section>.<requirement>` ，其中：“version”是 ASVS 版本标签。 例如：`v4.0.3-1.11.3` 将被理解为特指版本 4.0.3 中“架构”这一章中“业务逻辑架构”这一节的第 3 项要求。 （可概括为`v<version>-<requirement_identifier>`。）\n\n注意：版本部分前面的 `v` 要小写。\n\n如果使用不包括 `v<version>` 的标识符，那么它们应该被认为是指最新的应用安全验证标准内容。显然，随着标准的增长和变化，这将导致问题，这就是为什么作者或开发者应该将版本包括进去。\n\nASVS 需求列表，以 CSV、JSON 和其他可能对参考或编程有用的格式提供。\n", "timestamp": "2025-10-24T11:40:03.214883"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x04-Assessment_and_Certification.md", "content": "# 评估和认证\n\n## OWASP对ASVS认证和信任标志的立场\n\nOWASP作为一个与供应商无关的非营利性组织，目前不认证任何供应商、验证人员或软件。\n\n所有这类保证声明、信任标志或认证，均未经 OWASP 正式审查、注册或认证，因此依赖此类观点的组织，需要谨慎对待任何第三方的信任或声称ASVS认证的信任标志。\n\n这并不影响组织提供此类保证服务，只要他们不要求官方的 OWASP 认证。\n\n## 认证组织指南\n\n应用程序安全验证标准，可以用作应用程序的公开验证，包括对关键资源的开放和自由访问（如架构师和开发人员、项目文档、源代码），对测试系统的认证访问（包括对每个角色的一个或多个帐户的访问），特别是L2和L3验证。\n\n从历史上看，渗透测试和安全代码审查都包含“异常”问题——即只有未通过的测试项才会出现在最终报告中。 认证组织必须在任何报告中包括验证的范围（特别是某个关键组件不在范围内时，如SSO身份验证）、验证结果的摘要，包括通过的和未通过的测试，并清楚地说明如何解决未通过的测试。\n\n某些验证要求可能不适用于被测试的应用程序。例如，如果你向客户提供无状态的服务层API而没有客户端实现，那么“V3-会话管理”中的许多要求就不能直接使用。 在这种情况下，认证机构仍可声称完全符合 ASVS 的要求，但必须在报告中明确说明被排除的验证要求不适用的原因。\n\n保留详细的工作底稿、屏幕截图或视频、可靠地重复利用一个问题的脚本，以及测试的电子记录，如拦截代理日志和相关的笔记（如清理清单），被认为是标准的行业惯例，哪怕是对于最可疑的开发人员来说，它们也能作为调查结果的证明。 仅仅跑一个工具并报告故障是不够的，这根本不能提供充分的证据，证明所有认证级别的问题都经过了彻底的测试。 在有争议的情况下，应该有足够的证据，来证明每一个经过验证的需求确实被测试过。\n\n### 测试方法\n\n认证机构可自由选择适当的测试方法，但应在报告中注明。\n\n根据所测试的应用程序和验证需求，可以使用不同的测试方法来获得相似的结果置信度。 例如，要验证应用程序输入验证机制的有效性，可以通过手动渗透测试或通过源代码来分析。\n\n#### 自动化安全测试工具的作用\n\n鼓励使用自动化渗透测试工具以提供尽可能多的覆盖范围。\n\n仅使用自动渗透测试工具，是不可能完全完成ASVS验证的。虽然L1中的绝大多数需求可以使用自动化测试来执行，但总体上，绝大多数需求并不适合自动化渗透测试。\n\n请注意，随着应用安全行业的成熟，自动化和手动测试之间的界限已经变得模糊。 自动化工具通常由专家手动调整，而手动测试人员通常会利用各种自动化工具。\n\n#### 渗透测试的作用\n\n在 4.0 版本中，我们决定让 L1 完全可渗透测试，而无需访问源代码、文档或开发人员。 OWASP Top 10 2017 A10 要求的两个日志记录项目，将需要访谈、屏幕截图或其他证据，就像它们在 OWASP Top 10 2017 中的一样。 然而，在无法获得必要信息的情况下进行测试，并不是一种理想的安全验证方式，因为它不仅错过了审查来源、识别威胁和缺失控制的可能性，还会错过在更短的时间内进行更彻底测试的可能。\n\n在可能的情况下，执行L2或L3评估时，需要访问开发人员、文档、代码，以及访问具有非生产数据的测试应用程序。 在这些级别进行的渗透测试，需要这种级别的访问，我们称之为 “混合审查” 或 “混合渗透测试”。\n\n## ASVS的其他用途\n\n除了用于评估应用程序的安全性外，我们还确定了ASVS的许多其他潜在用途。\n\n### 作为详细的安全架构指南\n\n应用程序安全验证标准的更常见用途之一，是作为安全架构师的资源。 Sherwood应用业务安全架（Sherwood Applied Business Security Architecture，SABSA）缺少大量的信息，而这些信息是完成一次彻底的应用安全架构审查所必需的。 ASVS可以用来填补这些空白，让安全架构师为常见问题选择更好的控制措施，如数据保护模式和输入验证策略。\n\n### 作为现有安全编码Checklists的替代品\n\n许多组织可以从采用ASVS中受益，通过选择三个级别中的一个，或通过fork ASVS，在特定领域改变每个应用风险级别的要求。 我们鼓励这种fork，只要保持可追溯性，因此，如果一个应用程序已经通过了标准版本中的“要求4.1”，那么也就通过了fork版本中的这个要求。\n\n### 作为自动化单元和集成测试的指南\n\nASVS的设计是高度可测试的，唯一的例外是架构和恶意代码要求。 通过构建单元和集成测试，对相关的滥用情况进行fuzz测试，应用程序几乎可以在每次构建中进行自我验证。 例如，可以为登录控制器制作额外的测试，测试常见的默认用户名参数、帐户枚举、暴力破解、LDAP注入、SQL 注入以及 XSS。 同样地，对密码参数的测试，应该包括常用密码、密码长度、空字节注入、移除参数、XSS等。\n\n### 用于安全开发培训\n\nASVS 还可用于定义安全软件的特征。 许多“安全编码”课程只是带有少量编码技巧的道德黑客课程。 这不一定能帮助开发人员编写更安全的代码。 相反，安全开发课程可以使用 ASVS，重点关注 ASVS 中的主动控制，而不是前 10 项不该做的负面事情。\n\n### 作为敏捷应用安全的驱动程序\n\n在敏捷开发过程中，为了获得安全的产品，ASVS可以作为框架来定义团队需要实施的特定任务。 一种可能的方法是：从 Level 1 开始，根据指定级别的 ASVS 要求，验证特定应用程序或系统，查找缺少哪些项目，并在待办事项中提出特定工单/任务。 这有助于对具体任务进行优先排序（梳理），并使安全在敏捷开发中可见。 这也可用于确定组织中审计和审查任务的优先；其中，特定的 ASVS 要求，可以作为团队成员审查、重构或审计的驱动因素，并可以记录到最终的待办清单中。\n\n### 作为指导安全软件采购的框架\n\nASVS 是一个很好的框架，可以帮助确保安全软件的采购或定制开发服务的采购。 买方可以简单地设定一个要求，即他们希望采购的软件必须按照 ASVS 的 Level x 来开发，并要求卖方证明该软件满足ASVS的x级。\n", "timestamp": "2025-10-24T11:40:03.257063"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x10-V1-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x10-V1-Architecture.md", "content": "# V1 架构、设计和威胁建模\n\n## 控制目标\n\n在许多组织中，安全架构几乎已成为一门失传的艺术。 在DevSecOps时代，企业架构师的日子已经过去。应用安全领域必须迎头赶上，采用敏捷安全原则，同时将领先的安全架构原则重新介绍给软件从业者。 A架构不是一种实施，而是一种思考问题的方式，它可能有许多不同的答案，而没有一个单一的“正确”答案。 很多时候，安全被视为不灵活的，要求开发人员以特定方式修复代码，而开发人员可能知道解决问题的更好方法。 对于架构来说，没有单一的、简单的解决方案，尝试寻找这种方案，是对软件工程领域的一种损害。\n\n一个Web应用程序的具体实现，很可能在其生命周期中不断被修改，但整体架构可能很少改变，而是缓慢发展。 安全架构也是一样的，身份验证——我们今天需要、明天需要、五年后也需要。 如果我们今天做出合理的决定，选择和复用符合架构的解决方案，那么就可以节省大量的精力、时间和金钱。 例如，十年前，多因素认证很少被实施。\n\n如果开发人员已经在单一的“安全标识提供程序模型”上有所投入（例如SAML联邦认证），身份提供者可以更新以纳入新的要求（例如NIST 800-63标准），同时不改变原始应用程序的接口。 如果许多应用程序共享相同的安全架构和组件，那么它们都将同时从这次升级中受益。 然而，SAML 并不总是最好或最合适的身份验证解决方案——随着需求的变化，可能需要替换为其他解决方案。 像这样的更改要么很复杂，成本高到需要完全重写，要么在没有安全架构的情况下完全不可能。\n\n在本章中，ASVS涵盖了任何良好安全架构的主要方面：可用性、保密性、完整性、不可抵赖性和隐私。 这些安全原则中的每一条，都必须适用并内置于所有应用程序中。 “左移”至关重要，从安全编码Checklists、指导和培训、编码和测试、构建、部署、配置和操作开始，到后续的独立测试，确保所有安全控制存在且功能正常。 这最后一步，曾经是我们作为一个行业所做的一切，但当开发人员每天数十次或数百次地推送代码时，就已经不够了。 应用安全专业人员必须跟上敏捷技术的步伐，这意味着要适应开发人员的工具，学习编码，并与开发人员一起工作，而不是在其他人离开的几个月后再批评项目。\n\n## V1.1 安全软件开发生命周期\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.1.1** | 验证使用安全的软件开发生命周期，在开发的各个阶段解决安全问题。 ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **1.1.2** | 验证在每次设计变更或sprint计划中使用威胁建模，以识别威胁、计划对策、促进适当的风险响应，并指导安全测试。 | | ✓ | ✓ | 1053 |\n| **1.1.3** | 验证所有用户信息和功能是否包含功能安全约束，例如 “作为一个用户，我应该能够查看和编辑我的个人资料。我不应该能够查看或编辑其他人的资料” | | ✓ | ✓ | 1110 |\n| **1.1.4** | 验证应用程序所有的信任边界、组件和重要数据流的文档，判断其合理性。 | | ✓ | ✓ | 1059 |\n| **1.1.5** | 验证应用程序的高级架构及远程连接服务涉及的定义和安全分析。 ([C1](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1059 |\n| **1.1.6** | 验证集中、简单（设计）、安全、经过审查、和可重复使用的安全控制措施的实施情况，以避免重复、缺失、无效或不安全的控制措施。 ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 637 |\n| **1.1.7** | 向所有开发人员和测试人员，验证安全编码Checklist、安全需求、指南或策略的可用性。 | | ✓ | ✓ | 637 |\n\n## V1.2 认证架构\n\n在设计身份验证时，如果攻击者可以通过拨打客服电话，回答常见的问题来重置帐户，那么是否具有强大硬件支持的多因素身份验证（MFA）并不重要。 在证明身份时，所有的认证途径必须具有相同的强度。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.2.1** | 验证应用程序所有的组件、服务和服务器，是否使用了唯一或特殊的低权限操作系统帐户。 ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 250 |\n| **1.2.2** | 验证应用组件之间（包括 API、中间件和数据层）的通信是否经过验证。组件只具有最低的必要权限。 ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 306 |\n| **1.2.3** | 验证应用程序是否使用已知安全的单一认证机制，可以扩展到强身份验证，并有足够的日志记录和监控，来检测帐户滥用或违规行为。 | | ✓ | ✓ | 306 |\n| **1.2.4** | 验证所有的认证途径和身份管理 API ，都实现了一致的认证安全控制强度， 以便收敛应用程序的风险。 | | ✓ | ✓ | 306 |\n\n## V1.3 会话管理架构\n\n这是未来架构需求的占位符。\n\n## V1.4 访问控制架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.4.1** | 验证受信任的实施点（如访问控制网关、服务器和Serverless函数）是否实施了访问控制。切勿在客户端实施访问控制。 | | ✓ | ✓ | 602 |\n| **1.4.2** | [已删除，不可操作] | | | | |\n| **1.4.3** | [已删除，与 4.1.3 重复] | | | | |\n| **1.4.4** | 验证应用程序使用单一的、经过严格审查的访问控制机制，来访问受保护的数据和资源。 所有请求都必须通过这个单一机制，以避免复制、粘贴或不安全的替代路径。 ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 284 |\n| **1.4.5** | 验证是否使用基于属性/特征的访问控制，即代码应检查用户对某一特征/数据项的授权，而不仅仅是他们的角色。 权限仍应依照不同角色进行分配。 ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 275 |\n\n## V1.5 输入和输出架构\n\n在4.0中，我们已经不再把 “服务器端” 作为一个表示信任边界的术语。 信任边界仍然令人担忧——在不受信任的浏览器或客户端设备上做决定，很容易被绕过的。 然而，在今天的主流架构部署中，信任的执行点已经发生了巨大的变化。 因此，在 ASVS 中使用 “受信任的服务层” 这一术语时，我们描述的都是受信任的执行点，无论其位置如何，如微服务、Serverless API、服务器端、具有安全启动的客户端设备上的受信任的API、合作伙伴或外部API等等。\n\n这里的“不受信任的客户端”一词，是指呈现表示层的客户端技术，通常称为“前端”技术。 这里的术语“序列化”不仅表示通过网络发送数据（如一个数组的值或获取 JSON 结构），还指传递可以包含逻辑的复杂对象。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.5.1** | 验证输入和输出要求，明确规定如何根据类型、内容以及适用的法律、法规和其他政策规定，来操作和处理数据。 | | ✓ | ✓ | 1029 |\n| **1.5.2** | 验证在与不受信任的客户进行通信时，不使用序列化。 如果无法做到这一点，请确保执行足够的完整性控制（如果发送敏感数据，可能还要进行加密），以防止反序列化攻击，包括对象注入。 | | ✓ | ✓ | 502 |\n| **1.5.3** | 验证输入验证是否在可信的服务层上执行。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 602 |\n| **1.5.4** | 验证输出编码是否发生在其预期的解释器附近（或由解释器进行）。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 116 |\n\n## V1.6 加密架构\n\n应用程序需要设计强大的加密架构，以根据其分类保护数据资产。加密所有东西，是浪费；不加密任何东西，是法律上的疏忽。 在架构或顶层设计、设计冲刺（Design Sprint）或架构高峰期，通常需要取得一种平衡。 一边设计加密技术，一边进行开发迭代，这样的安全实施，其成本不可避免地要比一开始就做简单的构建要高得多。\n\n架构要求是整个代码库的内在要求，因此很难进行单元或集成测试。架构需求需要在整个编码阶段的编码标准中加以考虑，并应在安全架构、代码审查或复盘会议中加以审查。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.6.1** | 验证是否有明确的加密密钥管理政策，以及加密密钥的生命周期是否遵循密钥管理标准，如NIST SP 800-57。 | | ✓ | ✓ | 320 |\n| **1.6.2** | 验证密码服务的消费者是否通过使用密钥库或基于API的替代方案，来保护密钥材料和其他机密。 | | ✓ | ✓ | 320 |\n| **1.6.3** | 验证所有的密钥和密码是否可替换的，并且是重新加密敏感数据的明确定义流程的一部分。 | | ✓ | ✓ | 320 |\n| **1.6.4** | 验证架构是否将客户端机密（例如对称密钥、密码或 API 令牌）视为不安全的，并且从不使用它们来保护或访问敏感数据。 | | ✓ | ✓ | 320 |\n\n## V1.7 错误、日志和审计架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.7.1** | 验证整个系统是否使用了通用的日志记录格式和方法。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 1009 |\n| **1.7.2** | 验证日志是否安全地传输到远程系统，以便进行分析、检测、报警和升级。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n## V1.8 数据保护和隐私架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.8.1** | 验证所有敏感数据都已识别并归入保护级别。 | | ✓ | ✓ | |\n| **1.8.2** | 验证所有保护级别都具有一套相关的保护要求，如加密要求、完整性要求、保留、隐私和其他机密性要求，并在架构中应用这些要求。 | | ✓ | ✓ | |\n\n## V1.9 通信架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.9.1** | 验证应用程序对组件之间的通信进行加密，特别是当这些组件处于不同的容器、系统、站点或云提供商时。 ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 319 |\n| **1.9.2** | 验证应用组件是否验证了通信链接中每一方的真实性，以防止中间人攻击。例如，应用程序组件应校验TLS证书链。 | | ✓ | ✓ | 295 |\n\n## V1.10 恶意软件架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.10.1** | 验证是否使用了源代码控制系统，以及有程序确保签入时附带问题或变更单。源代码控制系统应该具有访问控制和可识别的用户，以追溯任何的更改。 | | ✓ | ✓ | 284 |\n\n## V1.11 业务逻辑架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.11.1** | 验证所有应用组件在其提供的业务或安全功能方面的定义和文档。 | | ✓ | ✓ | 1059 |\n| **1.11.2** | 验证所有高价值的业务逻辑流，包括认证、会话管理和访问控制，不共享不同步的状态。 | | ✓ | ✓ | 362 |\n| **1.11.3** | 验证所有高价值的业务逻辑流，包括身份验证、会话管理和访问控制都是线程安全的，并能抵抗检查时间和使用时间不同步时的条件竞争。 | | | ✓ | 367 |\n\n## V1.12 安全上传架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.12.1** | [已删除，与 12.4.1 重复] | | | | |\n| **1.12.2** | 验证用户上传的文件——如果需要显示或从应用中下载，是通过二进制流下载，或从无关的域（如云文件存储桶）提供。实施合适的内容安全策略（CSP），以减少来自上传文件的XSS向量或其他攻击的风险。 | | ✓ | ✓ | 646 |\n\n## V1.13 API架构\n\n这是未来架构需求的占位符。\n\n## V1.14 配置架构\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **1.14.1** | 通过明确的安全控制、防火墙规则、API 网关、反向代理、基于云的安全组或类似机制，验证不同信任级别的组件的隔离情况。 | | ✓ | ✓ | 923 |\n| **1.14.2** | 验证二进制签名、可信连接和经过验证的接口，以将二进制文件部署到远程设备。 | | ✓ | ✓ | 494 |\n| **1.14.3** | 验证构建管道是否对过期或不安全的组件发出警告并采取适当的行动。 | | ✓ | ✓ | 1104 |\n| **1.14.4** | 验证构建管道是否包含自动构建和验证应用安全部署的构建步骤，特别是当应用基础设施是软件定义时，例如云环境构建脚本。 | | ✓ | ✓ | |\n| **1.14.5** | 验证应用程序部署是否在网络级别进行了充分的沙盒化、容器化或隔离，以延迟和阻止攻击者攻击其他应用程序，尤其是当攻击者执行敏感或危险操作时（如反序列化）。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n| **1.14.6** | 验证应用程序未使用不受支持、不安全或不推荐的客户端技术，如NSAPI插件、Flash、Shockwave、ActiveX、Silverlight、NACL或客户端Java applets。 | | ✓ | ✓ | 477 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Attack Surface Analysis Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/sdl/)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:40:03.339584"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x11-V2-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x11-V2-Authentication.md", "content": "# V2 认证\n\n## 控制目标\n\n认证是建立或确认某人（或某物）的真实性，并且个人或设备的声明是正确的，可防止假冒，并防止恢复或拦截密码。\n\n当ASVS首次发布时，用户名+密码是最常见的认证形式（除高安全系统以外）。 多因素身份验证（MFA）在安全界被普遍接受，但在其他地方很少需要。 随着密码泄露次数的增加，认为用户名在某种程度上是保密的，而密码则是未知的这种想法使得许多安全控制无法成立。 例如，NIST 800-63 将用户名和基于知识的身份验证（KBA）视为公共信息，将 SMS 和电子邮件通知视为[“受限”的认证类型](https://pages.nist.gov/800-63-FAQ/#q-b1)，而密码是预先泄露的。 这一现实使基于知识的认证器、短信和电子邮件恢复、密码历史、复杂性和轮换控制变得毫无用处。 这些控制措施不总那么有用，经常迫使用户每隔几个月就想出一些弱的密码，但是随着50多亿用户名和密码泄露事件的公布，现在是时候继续前进了。\n\n在ASVS的所有章节中，认证和会话管理章节的变化最大。采用有效的、以证据为基础的领先实践，对许多人来说将是挑战，这完全没问题。 现在我们必须开始向未来的后密码时代过渡。\n\n## NIST 800-63 - 现代的、基于证据的认证标准\n\n[NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) 是一种现代的、基于证据的标准，代表了可用的最佳建议，无论其适用性如何。该标准对世界各地的所有组织都有帮助，但与美国机构和与美国机构打交道的机构尤其相关。\n\nNIST 800-63的术语一开始可能有点令人困惑，特别是你只习惯于用户名+密码认证的话。 现代认证的进步是必要的，所以我们必须引入将来会变得司空见惯的术语，但我们确实理解：在行业落实这些新术语之前，理解这些新术语的困难。 我们在本章末尾提供了一个词汇表，以提供帮助。 我们重新表述了许多要求，以满足要求的意图，而不只是拘泥于文字。 例如，当NIST在本标准中使用“记忆秘密”时（memorized secret），ASV使用术语“密码”（password）。\n\nASVS V2 身份验证、V3 会话管理以及在较小程度上的V4 访问控制，已被调整为符合 NIST 800-63b 控制项的一个子集，主要围绕常见的威胁和经常被利用的认证弱点。如果需要完全遵守NIST 800-63，请参考NIST 800-63。\n\n### 选择合适的 NIST AAL 级别\n\n应用程序安全验证标准（ASVS），已尝试将 ASVS L1 对应到 NIST AAL1 要求，将 L2 对应到 AAL2，将 L3 对应到 AAL3。 然而，ASVS Level 1作为“基本”的控制，不一定是验证应用或API的正确AAL级别。 例如，如果该应用是 L3 应用或有 AAL3 的监管要求，则应在V2和V3会话管理章节选择 L3。 应根据NIST 800-63b指南选择符合NIST标准的认证保证级别（AAL），如[NIST 800-63b第6.2节](https://pages.nist.gov/800-63-3/sp800-63-3.html#AAL_CYOA) 中的 *Selecting AAL* 。\n\n## 图例\n\n应用程序总是可以超过当前级别的要求，特别是如果现代认证是在应用程序的路线图上。以前，ASVS要求强制MFA。NIST不要求强制MFA。因此，我们在本章中使用了一个可选的指定，以表明ASVS鼓励但不要求控制的地方。本标准自始至终使用了以下图示：\n\n| 标记 | 说明 |\n| :--: | :-- |\n| | 不要求 |\n| o | 建议，但不要求 |\n| ✓ | 要求 |\n\n## V2.1 密码安全\n\n在NIST 800-63中，密码被称为“记忆的秘密”（Memorized Secrets），包括密码、PIN、解锁图案、选择正确的小猫或其他图像元素以及密码短语。 它们通常被认为是“您知道的东西”，并且通常用作单因素身份认证工具。 继续使用单因素认证有很大的风险，包括互联网上披露的数十亿有效用户名和密码、默认或弱密码、彩虹表和最常见密码的有序字典。\n\n应用程序应强烈鼓励用户注册多因素认证，并应允许用户重新使用他们已经拥有的令牌，如FIDO或U2F令牌，或链接到提供多因素认证的凭证服务提供商。\n\n凭据服务提供商（CSP）为用户提供联合身份。 用户通常会拥有多个CSP的多个身份，例如使用Azure AD、Okta、Ping identity或Google的企业身份，或使用Facebook、Twitter、Google或微信的普通用户，这只是一些常见的可能。 这份清单并不是对这些公司或服务的认可，而只是鼓励开发者考虑用户有许多既定身份的现实。 组织应该考虑与现有的用户身份整合，根据CSP的身份证明强度的风险状况，组织应考虑与现有用户身份集成。 例如，政府机构不太可能接受社交媒体身份作为敏感系统的登录名，因为很容易伪造或丢弃身份，而移动游戏公司可能需要与主要社交媒体平台整合，以扩大他们的活跃玩家群。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.1.1** | 验证用户设置的密码长度至少为 12 个字符（多个空格合并后）。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.2** | 验证是否允许64个字符以上的密码，并拒绝超过128个字符的密码。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.3** | 验证不进行密码截断。然而，连续的多个空格可以被单个空格代替。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.4** | 验证密码中是否允许使用任何可打印的Unicode字符，包括语言中立字符，例如空格和表情符号。 | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.5** | 验证用户可以更改其密码。 | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.6** | 验证密码更改功能是否需要用户的当前密码和新密码。 | ✓ | ✓ | ✓ | 620 | 5.1.1.2 |\n| **2.1.7** | 验证在账户注册、登录和密码更改过程中提交的密码，是否出现在被泄露过的密码中，这些密码可以是本地的（如符合系统密码策略的前1000个或10000个最常见的密码），也可以使用外部API。 如果使用API，应使用零知识证明或其他机制，以确保纯文本密码不被发送或用于验证密码的违反状态。 如果密码被泄露，应用程序必须要求用户设置一个新的未被泄露的密码。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.8** | 验证是否提供了密码强度表，以帮助用户设置更强的密码。 | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.9** | 验证是否有限制允许的字符类型的密码组成规则。对大写或小写、数字或特殊字符不应有任何要求。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.10** | 验证没有定期更换凭证或密码历史的要求。 | ✓ | ✓ | ✓ | 263 | 5.1.1.2 |\n| **2.1.11** | 验证是否允许 “粘贴” 功能、浏览器密码辅助工具和外部密码管理器。 | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n| **2.1.12** | 验证用户可以选择临时查看整个屏蔽的密码，或者在没有内置功能的平台上临时查看密码的最后输入的字符。 | ✓ | ✓ | ✓ | 521 | 5.1.1.2 |\n\n注意：允许用户查看密码或临时查看最后一个字符的目的，是为了提高凭证输入的可用性，尤其是在使用更长的密码、口令和密码管理器时。 包含该要求的另一个原因，是为了防止测试报告不必要地要求组织重写内置平台密码字段的行为，从而保持这种现代用户友好的安全体验。\n\n## V2.2 通用身份验证器的安全性\n\n身份验证器的敏捷性，对于面向未来的应用程序至关重要。 重构应用程序验证器以允许用户根据偏好添加额外的验证器，并允许以有序的方式停用已弃用或不安全的验证器。\n\nNIST 将电子邮件和 SMS 视为 [“受限”的身份验证器类型](https://pages.nist.gov/800-63-FAQ/#q-b1)，它们很可能在未来的某个时候从NIST 800-63以及ASVS中删除。 应用程序应计划一个不需要使用电子邮件或短信的路线图。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.2.1** | 验证反自动化控制的措施能够有效地缓解被泄露的凭证测试、暴力破解和账户锁定攻击。 这些控制措施包括阻止最常见的泄露密码、软锁定、速率限制、验证码、每次尝试后逐渐增加的间隔时间、IP地址限制，或基于风险的限制，例如位置、设备上的首次登录、最近解锁账户的尝试等类似情况。 验证单个帐户每小时的失败尝试次数不超过 100 次。 | ✓ | ✓ | ✓ | 307 | 5.2.2 / 5.1.1.2 / 5.1.4.2 / 5.1.5.2 |\n| **2.2.2** | 验证弱身份验证器（例如 SMS 和电子邮件）的使用，仅限于二次验证和批准交易，而不是作为更安全的认证方法的替代。 验证是否在弱方法之前提供了更强的方法，用户是否意识到风险，或者是否采取了适当的措施来限制帐户泄露的风险。 | ✓ | ✓ | ✓ | 304 | 5.2.10 |\n| **2.2.3** | 验证在更新认证信息（如凭证重置、电子邮件或地址变更、从未知或风险地点登录）后向用户发送安全通知。 最好使用推送通知——而不是短信或电子邮件，但在没有推送通知的情况下，只要通知中没有披露敏感信息，短信或电子邮件也是可以接受的。 | ✓ | ✓ | ✓ | 620 | |\n| **2.2.4** | 验证对网络钓鱼的抗冒充性，如使用多因素认证、有意图的加密设备（如有推送认证的连接密钥），或在更高的AAL级别，客户端证书。 | | | ✓ | 308 | 5.2.5 |\n| **2.2.5** | 验证当凭证服务提供者（CSP）和验证认证的应用程序分开时，两个端点之间有相互认证的TLS（mTLS）。 | | | ✓ | 319 | 5.2.6 |\n| **2.2.6** | 验证抗重放性，是否通过强制使用一次性密码（OTP）设备、加密认证器或查询代码。 | | | ✓ | 308 | 5.2.8 |\n| **2.2.7** | 通过要求输入OTP令牌或用户发起的动作（如按下FIDO硬件钥匙的按钮）来验证认证意图。 | | | ✓ | 308 | 5.2.9 |\n\n## V2.3 身份验证器生命周期\n\n认证器是密码、软令牌、硬件令牌和生物识别设备。认证器的生命周期对应用程序的安全至关重要——如果任何人都可以在没有身份证明的情况下自行注册一个账户，那么对身份断言的信任就会很低。 对于像Reddit这样的社交媒体网站，这是完全可以的。 对于银行系统来说，更加注重凭证和设备的注册和发放（对应用程序的安全至关重要）。\n\n注意：密码不要有最长的使用寿命，也不要进行密码轮换。 应检查密码是否已泄露，而不是定期更换。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.3.1** | 验证系统生成的初始密码或激活码应该是安全随机生成的，应该至少有6个字符的长度，可以包含字母和数字，并在短时间内过期。这些初始秘密不得被允许成为长期密码。 | ✓ | ✓ | ✓ | 330 | 5.1.1.2 / A.3 |\n| **2.3.2** | 验证是否支持注册和使用用户提供的认证设备，如U2F或FIDO令牌。 | | ✓ | ✓ | 308 | 6.1.3 |\n| **2.3.3** | 验证更新指令的发送时间是否足够，以更新有时间限制的认证器。 | | ✓ | ✓ | 287 | 6.1.4 |\n\n## V2.4 凭证存储\n\n架构师和开发人员在构建或重构代码时，应遵守本节。本节内容只能使用源代码审查或通过安全单元或集成测试来完全验证。渗透测试不能识别这里面的任何问题。\n\n经批准的单向密钥推导功能列表详见NIST 800-63 B第5.1.1.2节，以及 [BSI Kryptographische Verfahren: Empfehlungen und Schlussell&auml;ngen (2018)](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile)。除了上面这些选择，还可以根据最新的国家或地区选择算法和密钥长度标准。\n\n此部分无法进行渗透测试，因此控制措施未标记为 L1。但是，如果证书被盗，这部分对证书的安全至关重要，因此如果为架构或编码指南或源代码审查清单Fork ASVS，请在您的私有版本中将这些控制措施放回 L1。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.4.1** | 验证密码是以一种可以抵抗离线攻击的形式存储的。密码应使用认可的单向密钥推导或密码散列函数进行加盐和散列。密钥推导和密码散列函数，在生成密码散列时，将密码、盐和计算成本作为输入。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.2** | 验证盐的长度至少为32位，并且是任意选择的，以减少存储的哈希值之间的碰撞。对于每个凭证，应存储唯一的盐值和由此产生的哈希值。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.3** | 验证如果使用 PBKDF2，迭代次数应在验证服务器性能允许的范围内，一般至少为100,000次迭代。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.4** | 验证如果使用 bcrypt，工作系数应在验证服务器性能允许的范围内尽量大，最小为10。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 916 | 5.1.1.2 |\n| **2.4.5** | 验证是否执行了密钥派生函数的额外迭代，使用的是只有验证者知道的秘密盐值。使用经批准的随机位生成器 [SP 800-90Ar1] 生成盐值，并至少提供 SP 800-131A 最新修订版中规定的最低安全强度。秘密盐值应与散列密码分开存储（例如，在像硬件安全模块这样的专用设备中）。 | | ✓ | ✓ | 916 | 5.1.1.2 |\n\n在提到美国标准时，可以根据需要使用地区或当地标准来代替或补充美国标准。\n\n## V2.5 凭证恢复\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.5.1** | 验证系统生成的初始激活或恢复密码，不会以明文形式发送给用户。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.2** | 验证密码提示或基于知识的身份验证（所谓的“密码保护问题”）不存在。 | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.3** | 验证密码凭据恢复不会以任何方式泄露当前密码。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.4** | 验证共享或默认帐户不存在（例如“root”、“admin”或“sa”）. | ✓ | ✓ | ✓ | 16 | 5.1.1.2 / A.3 |\n| **2.5.5** | 验证如果更改或替换了身份验证因素，则用户会收到此事件的通知。 | ✓ | ✓ | ✓ | 304 | 6.1.2.3 |\n| **2.5.6** | 验证忘记密码以及其他恢复路径，使用了安全的恢复机制，例如基于时间的OTP（TOTP）或其他软令牌、移动推送或其他离线恢复机制。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 640 | 5.1.1.2 |\n| **2.5.7** | 验证如果OTP或多因素身份验证因素丢失，身份证明的执行水平与注册时相同。 | | ✓ | ✓ | 308 | 6.1.2.3 |\n\n## V2.6 查找密码认证\n\n查找密码（译者注：Look-up secrets，类似于密码保护卡），是预先生成的秘密代码列表，类似于交易授权号码（TAN）、社交媒体恢复代码，或包含一组随机值的网格。 这些被安全地分配给用户。这些 查询代码只使用一次，一旦全部使用，查询的秘密列表就会被丢弃。这种类型的认证器被认为是 “你拥有的东西”。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.6.1** | 验证查找密文只能使用一次。 | | ✓ | ✓ | 308 | 5.1.2.2 |\n| **2.6.2** | 验证查询秘密有足够的随机性（112位熵），如果少于112位熵，则用唯一的随机32位盐进行加盐，并用认可的单向散列进行散列。 | | ✓ | ✓ | 330 | 5.1.2.2 |\n| **2.6.3** | 验证查找秘密能够抵抗离线攻击，例如可预测的值。 | | ✓ | ✓ | 310 | 5.1.2.2 |\n\n## V2.7 带外验证器\n\n在过去，常见的带外验证器是包含密码重置链接的电子邮件或短信。攻击者利用这种薄弱的机制来重置他们尚未控制的账户，例如接管一个人的电子邮件账户并重新使用任何发现的重置链接。 处理带外验证有更好的方法。\n\n安全的带外验证器是可以通过安全的二级信道与验证器进行通信的物理设备。 例子包括向移动设备推送通知。这种类型的验证器被认为是 “你拥有的东西”。 当用户希望进行认证时，验证应用程序通过与认证器的连接，直接或间接地通过第三方服务向带外认证器发送一个消息。 该消息包含一个认证代码（通常是一个随机的六位数或一个模式化的批准对话框）。 验证应用程序等待通过主通道接收验证码，并将接收到的值的哈希值与原始验证码的哈希值进行比较。如果它们匹配，则带外验证器可以认为用户已通过身份验证。\n\nASVS假定只有少数开发者会开发新的带外认证器，如推送通知，因此以下ASVS控制措施适用于验证器，如认证API、应用程序和单点登录实现。 如果开发一个新的带外认证器，请参考 NIST 800-63B &sect; 5.1.3.1。\n\n不安全的带外认证器，如电子邮件和VOIP是不允许的。 PSTN和SMS认证目前受到NIST的 “限制”，应该被弃用，以支持推送通知或类似的方式。 如果你需要使用电话或短信的带外认证，请参见 NIST 800-63B &sect; 5.1.3.3。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.7.1** | 验证默认情况下不提供短信或PSTN等带外的明文认证器，并首先提供推送通知等更强的替代方案。 | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.2** | 验证带外验证器在10分钟后将带外验证请求、代码或令牌过期。 | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.3** | 验证带外验证器身份验证请求、代码或令牌仅可使用一次，并且仅可用于原始身份验证请求。 | ✓ | ✓ | ✓ | 287 | 5.1.3.2 |\n| **2.7.4** | 验证带外验证器和验证器是否通过安全的独立信道进行通信。 | ✓ | ✓ | ✓ | 523 | 5.1.3.2 |\n| **2.7.5** | 验证带外验证器只保留认证代码的散列版本。 | | ✓ | ✓ | 256 | 5.1.3.2 |\n| **2.7.6** | 验证初始验证码是否由安全随机数生成器生成，包含至少 20 位熵（通常为 6 位数字随机数即可）。 | | ✓ | ✓ | 310 | 5.1.3.2 |\n\n## V2.8 一次性验证器\n\n单因素一次性密码（OTP），是显示持续变化的伪随机一次性挑战的物理或软令牌。 这些设备使网络钓鱼（冒充）变得困难，但并非不可能。 这种类型的身份验证器被认为是“你拥有的东西”。 多因素令牌，类似于单因素 OTP，但需要输入有效的 PIN 码、生物识别解锁、USB 插入、NFC 配对或一些附加值（例如交易签名计算器）才能创建最终 OTP。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.8.1** | 验证基于时间的OTP在过期前有确定的使用寿命 | ✓ | ✓ | ✓ | 613 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | 验证用于验证提交的OTP的对称密钥是否被高度保护，例如使用硬件安全模块或基于安全操作系统的密钥存储。 | | ✓ | ✓ | 320 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.3** | 验证OTP的生成、播种和验证是否使用了经过批准的加密算法。 | | ✓ | ✓ | 326 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | 验证基于时间的OTP在有效期内只能使用一次。 | | ✓ | ✓ | 287 | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** | 验证如果基于时间的多因素OTP令牌在有效期内被重复使用，将被记录并拒绝，同时向设备持有者发送安全通知。 | | ✓ | ✓ | 287 | 5.1.5.2 |\n| **2.8.6** | 验证物理单因素OTP生成器在被盗或其他损失的情况下可以被撤销。确保撤销在登录会话中立即生效，无论在何处。 | | ✓ | ✓ | 613 | 5.2.1 |\n| **2.8.7** | 验证生物特征身份验证器仅限于用作次要因素，与“你拥有的东西”和“你知道的东西”一起使用。 | | o | ✓ | 308 | 5.2.3 |\n\n## V2.9 密码验证器\n\n加密安全密钥是智能卡或FIDO密钥，用户必须将加密设备插入或配对到计算机上才能完成身份验证。验证者立即向加密设备或软件发送挑战随机数，设备或软件根据安全存储的加密密钥计算出响应。\n\n对单因素密码设备和软件的要求，和多因素密码设备和软件的要求是一样的，都是证明密码认证者拥有认证因素。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.9.1** | 验证用于验证的加密密钥是否安全存储并防止泄露，例如使用可信平台模块（TPM）或硬件安全模块（HSM），或可以使用这种安全存储的操作系统服务。 | | ✓ | ✓ | 320 | 5.1.7.2 |\n| **2.9.2** | 验证质询随机数的长度至少为 64 位，并且在统计学上是唯一的，或在加密设备的生命周期内是唯一的。 | | ✓ | ✓ | 330 | 5.1.7.2 |\n| **2.9.3** | 验证在生成、播种和验证中使用经批准的加密算法。 | | ✓ | ✓ | 327 | 5.1.7.2 |\n\n## V2.10 服务认证\n\n此部分不可渗透测试，因此没有任何 L1 要求。但是，如果用于架构、编码或安全代码审查，请假设软件（就像 Java 密钥库一样）是 L1 的最低要求。 在任何情况下都不允许明文存储秘密。\n\n注：\n- HSM，硬件安全模块（Hardware Security Module）\n- OS assisted，操作系统协助\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **2.10.1** | 验证服务内机密不依赖于不变的凭据，例如密码、API 密钥或具有特权访问权限的共享帐户。 | | OS assisted | HSM | 287 | 5.1.1.1 |\n| **2.10.2** | 验证如果服务身份验证需要密码，则使用的服务帐户不是默认凭据（例如，root/root 或 admin/admin 是安装过程中某些服务的默认设置）。 | | OS assisted | HSM | 255 | 5.1.1.1 |\n| **2.10.3** | 验证存储的密码是否有足够的保护，以防止离线恢复攻击，包括本地系统访问。 | | OS assisted | HSM | 522 | 5.1.1.1 |\n| **2.10.4** | 验证密码、与数据库和第三方系统的集成、种子和内部机密以及 API 密钥都得到安全管理，不包含在源代码中或存储在源代码存储库中。 这种存储应能抵御离线攻击。建议使用安全的软件密钥存储（L1）、硬件 TPM 或 HSM（L3）来存储密码。 | | OS assisted | HSM | 798 | |\n\n## 美国机构的其他要求\n\n美国机构对 NIST 800-63 有强制性要求。 一直以来，应用安全验证标准都是对几乎100%的应用采取80%的控制措施，而不是最后20%的高级控制或那些有限的适用性。 因此，ASVS 是 NIST 800-63 的一个严格的子集，特别是对于 IAL1/2 和 AAL1/2 分类，但不够全面，特别是关于 IAL3/AAL3 分类。\n\n我们强烈敦促美国政府机构全面审查和实施 NIST 800-63。\n\n## 术语表\n\n| 术语 | 含义 |\n| -- | -- |\n| CSP | 凭证服务提供者也称为身份提供者 |\n| Authenticator | 验证密码、令牌、MFA、联合断言等的代码。 |\n| Verifier | “通过使用认证协议，验证申请人对一个或两个认证器的拥有和控制，来验证申请人的身份的实体。 为此，验证者可能还需要验证将认证器与用户的标识符联系起来的凭证，并检查其状态” |\n| OTP | 一次性密码 |\n| SFA | 单因素身份验证，例如“您知道的东西”（记忆的秘密、密码、密码短语、pin），“您的特征“（生物特征识别、指纹、面部扫描），或“您拥有的东西“（OTP令牌、智能卡等加密设备）， |\n| MFA | 多因素认证，包括两个或多个单因素 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [NIST 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST 800-63 A - Enrollment and Identity Proofing](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63a.pdf)\n* [NIST 800-63 B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST 800-63 C - Federation and Assertions](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63c.pdf)\n* [NIST 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Testing Guide 4.0: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/04-Authentication_Testing/README.html)\n* [OWASP Cheat Sheet - Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Forgot password](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Cheat Sheet - Choosing and using security questions](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:03.436251"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x12-V3-Session-management.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x12-V3-Session-management.md", "content": "# V3 会话管理\n\n## 控制目标\n\n任何基于Web的应用程序或有状态的API的核心组成部分之一，是它控制和维护与之交互的用户或设备的状态的机制。会话管理将无状态协议变为有状态协议，这对于区分不同的用户或设备至关重要。\n\n确保经过验证的应用程序满足以下高级会话管理需求:\n\n* 会话对每个人都是唯一的，不能被猜测或共享。\n* 会话在不再需要时失效，在不活动期间超时。\n\n如前所述，这些要求已被调整为符合 NIST 800-63b 控制的一个子集，重点关注常见的威胁和经常被利用的认证弱点。 以前的验证要求已被淘汰、去重，或者在大多数情况下已调整为与强制性 [NIST 800-63b](https://pages.nist.gov/800-63-3/sp800-63b.html) 要求的意图保持高度一致。\n\n## 安全验证要求\n\n## V3.1 基本会话管理安全\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.1.1** | 验证应用不会在URL参数中显示会话令牌。 | ✓ | ✓ | ✓ | 598 | |\n\n## V3.2 会话绑定\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.2.1** | 验证应用程序在用户身份验证时，生成新的会话令牌。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 384 | 7.1 |\n| **3.2.2** | 验证会话令牌具有至少 64 位的熵。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 331 | 7.1 |\n| **3.2.3** | 验证应用程序仅使用安全方法在浏览器中存储会话令牌，例如适当的 cookie保护（参见第 3.4 节）或 HTML 5 会话存储。 | ✓ | ✓ | ✓ | 539 | 7.1 |\n| **3.2.4** | 验证会话令牌是使用批准的加密算法生成的。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 331 | 7.1 |\n\n会话管理必须使用 TLS 或其他安全传输通道。这在“通信安全”一章中有介绍。\n\n## V3.3 会话终止\n\n会话超时已经与NIST 800-63保持一致，它允许比传统安全标准所允许的更长的会话超时。组织应查看下表，如果应用的风险需要更长的超时，NIST值应是会话空闲超时的上限。\n\n在此上下文中，L1 是 IAL1/AAL1，L2 是 IAL2/AAL3，L3 是 IAL3/AAL3。对于 IAL2/AAL2 和 IAL3/AAL3，空闲超时时间越短，表示注销或重新认证恢复会话的时间越短。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.3.1** | 验证注销和到期是否会使会话令牌无效，以便后退按钮或下游依赖方不会恢复经身份验证过的会话。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 613 | 7.1 |\n| **3.3.2** | 如果认证器允许用户保持登录状态，请验证在活跃使用或空闲一段时间过后，定期进行重新认证。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | 30天 | 12小时 或 30分钟不活动，可选2FA | 12小时 或 15 分钟不活动，使用2FA | 613 | 7.2 |\n| **3.3.3** | 验证应用程序是否提供了在成功更改密码（包括通过密码重置/恢复）后终止所有其他活动会话的选项，并且这在应用程序、联合登录（如果存在）和任何依赖方中都是有效的。 | | ✓ | ✓ | 613 | |\n| **3.3.4** | 验证用户能够查看并（在重新输入登录凭证后）注销当前的所有活动会话和设备。 | | ✓ | ✓ | 613 | 7.1 |\n\n## V3.4 基于 Cookie 的会话管理\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.4.1** | 验证基于 cookie 的会话令牌是否设置了'Secure'属性。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 614 | 7.1.1 |\n| **3.4.2** | 验证基于 cookie 的会话令牌是否设置了'HttpOnly'属性。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1004 | 7.1.1 |\n| **3.4.3** | 验证基于cookie的会话令牌是否使用了'SameSite'属性，以限制跨站点请求伪造攻击（CSRF）的风险。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.4** | 验证基于cookie的会话令牌是否使用'__Host-'前缀，这样cookie只会被发送到最初设置cookie的主机。 | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n| **3.4.5** | 验证如果应用程序在一个域名下发布，而其他应用程序设置或使用会话cookie（这可能会泄露会话cookie），则在基于cookie的会话令牌中设置路径属性（Path），尽可能使用最精确的路径。 ([C6](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 16 | 7.1.1 |\n\n## V3.5 基于令牌的会话管理\n\n基于令牌的会话管理包括JWT、OAuth、SAML和API密钥。其中，API密钥公认较弱，不应该在新代码中使用。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.5.1** | 验证该应用允许用户撤销与链接应用建立信任关系的OAuth令牌。 | | ✓ | ✓ | 290 | 7.1.2 |\n| **3.5.2** | 验证应用程序使用会话令牌，而不是静态API密码或密钥，旧的实现除外。 | | ✓ | ✓ | 798 | |\n| **3.5.3** | 验证无状态会话令牌是否使用数字签名、加密等对策，来防止篡改、封装、重放、空密码和密钥替换等攻击。 | | ✓ | ✓ | 345 | |\n\n## V3.6 联合重认证\n\n本节与那些编写依赖方（RP）或凭证服务提供商（CSP）代码的人员有关。如果依赖于实现这些功能的代码，请确保正确处理这些问题。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.6.1** | 验证依赖方（RP）是否指定了凭证服务提供商（CSP）的最长身份验证时间，并且如果用户在该期间内未使用会话，CSP是否会重新验证用户。 | | | ✓ | 613 | 7.2.1 |\n| **3.6.2** | 验证凭证服务提供商（CSP）通知依赖方（RP）最后一次认证事件，以便 RP 确定他们是否需要重新认证用户。 | | | ✓ | 613 | 7.2.1 |\n\n## V3.7 针对会话管理漏洞的防御措施\n\n已知的一些会话管理漏洞，与会话的用户体验（UX）相关。以前，根据 ISO 27002 要求，ASVS 需要阻止多个并发会话。 现在，阻止并发会话已不再合适，不仅因为现代用户有许多设备，或者应用程序是没有浏览器会话的 API，还因为在大多数这些实现中，最后一个身份验证者获胜，这通常是攻击者。本小节提供了使用代码阻止、延迟和检测会话管理攻击的主要指导。\n\n### 半开放攻击的描述\n\n在2018年初，一些金融机构遭到了攻击者所谓的“半开放攻击”（half-open attacks）。这个术语在行业中一直存在。攻击者以不同的专有代码库攻击了多家机构，实际上，在同一个机构中似乎也有不同的代码库。这种“半开放攻击”利用了许多现有认证、会话管理和访问控制系统中常见的设计模式缺陷。\n\n攻击者通过试图锁定、重置或恢复一个凭证来开始半开放攻击。流行的会话管理设计模式，在未认证、半认证（密码重置、忘记用户名）和完全认证的代码之间，重用用户配置文件会话对象/模型。 这种设计模式会填充一个有效的会话对象或令牌，其中包含受害者的个人资料，包括密码哈希值和角色。如果访问控制检查在控制器或路由器没有正确验证用户是完全登录，攻击者将能够冒充用户。攻击手段可能包括：将用户的密码更改为已知值、更新电子邮件地址以执行有效的密码重置、禁用多因素身份验证或注册新的MFA设备、暴露或更改API密钥等。\n\n| # | 说明 | L1 | L2 | L3 | CWE | [NIST &sect;](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :--- | :---: | :---: | :---: | :---: | :---: |\n| **3.7.1** | 在允许任何敏感交易或帐户修改之前，验证应用程序确保完整、有效的登录会话，或要求重新验证（二次验证）。 | ✓ | ✓ | ✓ | 306 | |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Testing Guide 4.0: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/06-Session_Management_Testing/README.html)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Directives)\n", "timestamp": "2025-10-24T11:40:03.514333"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x12-V4-Access-Control.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x12-V4-Access-Control.md", "content": "# V4 访问控制\n\n## 控制目标\n\n授权是一个概念，即只允许那些被允许使用资源的人访问资源。确保经过验证的应用程序满足以下高级要求：\n\n* 访问资源的人员持有有效凭据才能这样做。\n* 用户与一组明确定义的角色和权限相关联。\n* 角色和权限元数据受到保护，不会被重放或篡改。\n\n## 安全验证要求\n\n## V4.1 通用访问控制设计\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.1.1** | 验证应用程序是否在受信任的服务层上执行访问控制规则，尤其是在有客户端访问控制并且可能被绕过的情况下。 | ✓ | ✓ | ✓ | 602 |\n| **4.1.2** | 验证访问控制所使用的所有用户和数据属性以及策略信息，不能被最终用户操纵，除非得到特别授权。 | ✓ | ✓ | ✓ | 639 |\n| **4.1.3** | 验证是否存在最小权限原则——用户应该只能访问他们拥有特定授权的功能、数据文件、URL、控制器、服务和其他资源。这意味着防止欺骗或特权提升。 ([C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n| **4.1.4** | [已删除，与 4.1.3 重复] | | | | |\n| **4.1.5** | 验证访问控制安全，在发生异常时是否失效。 ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 285 |\n\n## V4.2 操作级访问控制\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.2.1** | 验证敏感数据和API的保护，防止针对创建、读取、更新和删除记录的不安全直接对象引用（IDOR）攻击，如创建或更新别人的记录，查看每个人的记录或删除所有记录。 | ✓ | ✓ | ✓ | 639 |\n| **4.2.2** | 验证应用程序或框架是否实施了强大的反 CSRF 机制来保护经过身份验证的功能，以及有效的反自动化或反 CSRF 保护无需身份验证的功能。 | ✓ | ✓ | ✓ | 352 |\n\n## V4.3 其他访问控制注意事项\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **4.3.1** | 验证管理界面使用适当的多因素认证，防止未经授权的使用。 | ✓ | ✓ | ✓ | 419 |\n| **4.3.2** | 验证目录浏览被禁用，除非特意需要。此外，应用程序不应允许披露文件或目录元数据，例如Thumbs.db、.DS_Store、.git或.svn文件夹。 | ✓ | ✓ | ✓ | 548 |\n| **4.3.3** | 验证应用程序对低价值的系统有额外的授权（如升级或自适应认证），对高价值的应用程序进行职责分离，以根据应用程序和过去的欺诈风险执行反欺诈控制。 | | ✓ | ✓ | 732 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Testing Guide 4.0: Authorization](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/05-Authorization_Testing/README.html)\n* [OWASP Cheat Sheet: Access Control](https://cheatsheetseries.owasp.org/cheatsheets/Access_Control_Cheat_Sheet.html)\n* [OWASP CSRF Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP REST Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:03.567835"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x13-V5-Validation-Sanitization-Encoding.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x13-V5-Validation-Sanitization-Encoding.md", "content": "# V5 验证、过滤和编码\n\n## 控制目标\n\n最常见的 Web 应用程序安全漏洞，是在没有任何输出编码的情况下，直接使用来自客户端或环境的输入（缺乏正确的验证）。 这一弱点导致了 Web 应用程序中几乎所有的重大漏洞，例如跨站点脚本（XSS）、SQL 注入、解释器注入、语言环境/Unicode 攻击、文件系统攻击和缓冲区溢出。\n\n确保经过验证的应用程序满足以下高级要求：\n\n* 输入验证和输出编码架构有一条约定的管道来防止注入攻击。\n* 输入数据是强类型的，经过验证，范围或长度检查，或者在最坏的情况下，经过消毒或过滤。\n* 输出结果根据数据的上下文进行编码或转义，尽可能地接近解释器。\n\n随着现代网络应用架构的发展，输出编码比以往任何时候都更重要。在某些情况下很难提供健壮的输入验证，因此使用更安全的API，如参数化查询、自动转义的模板框架或精心选择的输出编码，对应用程序的安全性至关重要。\n\n## V5.1 输入验证\n\n正确实施的输入验证控制，使用白名单列表和强数据类型，可以消除 90% 以上的所有注入攻击。长度和范围检查可以进一步减少这种情况。在应用程序架构、设计冲刺（Design Sprint）、编码以及单元和集成测试期间，需要构建安全输入验证。 尽管其中许多项目在渗透测试中找不到，但不实施它们的结果通常可以在 V5.3 - 输出编码和注入预防要求 中找到。建议开发人员和安全代码审查人员将本小节作为基础（正如所有项目都需要满足 L1 那样），以防止注入。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.1.1** | 验证应用程序是否有HTTP参数污染攻击的防御措施，特别是当应用程序框架没有区分请求参数的来源（GET、POST、cookies、请求头或环境变量）。 | ✓ | ✓ | ✓ | 235 |\n| **5.1.2** | 验证框架是否能防止批量参数分配攻击，或者应用程序是否有对策来防止不安全的参数分配，如将字段标记为私有等类型。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 915 |\n| **5.1.3** | 验证所有输入（HTML 表单字段、REST 请求、URL 参数、HTTP 请求头、cookies、批处理文件、RSS 源等）都使用“白名单”（允许列表）。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.4** | 验证结构化数据是强类型的，并根据定义的模式进行验证，包括允许的字符、长度和模式（如信用卡号码、电子邮件地址、电话号码，或验证两个相关字段是否合理，如检查郊区和邮政编码是否匹配）。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 20 |\n| **5.1.5** | 验证URL重定向和转发的目标地址都在白名单中，或者在重定向到可能不受信任的内容时显示警告。 | ✓ | ✓ | ✓ | 601 |\n\n## V5.2 过滤和沙盒化\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.2.1** | 验证所有来自“所见即所得”编辑器或类似的不受信任的HTML输入，都已经通过HTML过滤库或框架功能，进行了适当的净化。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.2.2** | 验证非结构化数据是否经过消毒处理，以执行安全措施，如允许的字符集和长度。 | ✓ | ✓ | ✓ | 138 |\n| **5.2.3** | 验证应用程序在传递给邮件系统之前，对用户的输入进行过滤，以防止SMTP或IMAP注入。 | ✓ | ✓ | ✓ | 147 |\n| **5.2.4** | 验证应用程序是否避免使用eval()或其他动态代码执行功能。在没有其他选择的情况下，任何被包含的用户输入必须在执行前进行过滤或沙箱处理。 | ✓ | ✓ | ✓ | 95 |\n| **5.2.5** | 验证应用程序是否对相关的用户输入进行过滤或沙箱处理，来防止模板注入攻击。 | ✓ | ✓ | ✓ | 94 |\n| **5.2.6** | 验证应用程序是否通过验证或净化不受信任的数据或HTTP文件元数据（如文件名和URL输入字段），并使用协议、域、路径和端口的白名单，来防止SSRF攻击。 | ✓ | ✓ | ✓ | 918 |\n| **5.2.7** | 验证应用程序是否过滤、禁用或沙盒处理了用户提供的可扩展矢量图（SVG）脚本内容，特别是与内联脚本产生的XSS有关的内容，以及外部对象。 | ✓ | ✓ | ✓ | 159 |\n| **5.2.8** | 验证应用程序是否对用户提供的模板语言内容（脚本或表达式，如Markdown、CSS或XSL样式表、BBCode或类似内容）进行过滤、禁用或沙盒处理。 | ✓ | ✓ | ✓ | 94 |\n\n## V5.3 输出编码和预防注入\n\n靠近或邻近当前解释器的输出编码，对应用程序的安全至关重要。通常情况下，输出编码并不持久化，而是用于在适当的输出环境中使输出安全，以便立即使用。不进行输出编码，将最终形成一个不安全、可注入的应用程序。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.3.1** | 验证输出编码是否与所需的解释器和环境相关。例如，根据HTML值、HTML属性、JavaScript、URL参数、HTTP头、SMTP等上下文的要求，使用专门的编码器，特别是来自不可信任的输入（如带有Unicode或单引号的名字，如ねこ或O'Hara）。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 116 |\n| **5.3.2** | 验证输出编码是否保留了用户选择的字符集和地域，从而使任何Unicode字符点都能得到有效和安全的处理。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 176 |\n| **5.3.3** | 验证上下文感知，最好是自动——或者最差也是手动——转义输出，以防止反射、存储或基于DOM的XSS。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 79 |\n| **5.3.4** | 验证数据选择或数据库查询（如 SQL、HQL、ORM、NoSQL）是否使用参数化查询、ORM、实体框架，或以其他方式防止数据库注入攻击。 ([C3](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.5** | 验证在没有参数化或更安全机制的情况下，使用特定上下文的输出编码来防止注入攻击，例如使用SQL转义来防止SQL注入。 ([C3, C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 89 |\n| **5.3.6** | 验证应用程序是否可以防止JSON注入攻击、JSON eval攻击和JavaScript表达式评估。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 830 |\n| **5.3.7** | 验证应用程序可以防止LDAP注入漏洞，或者已经实施了特定的安全控制来防止LDAP注入。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 90 |\n| **5.3.8** | 验证应用程序是否能防止操作系统命令注入，以及操作系统调用是否使用参数化的操作系统查询或使用上下文命令行输出编码。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 78 |\n| **5.3.9** | 验证应用程序是否能防止本地文件包含（LFI）或远程文件包含（RFI）攻击。 | ✓ | ✓ | ✓ | 829 |\n| **5.3.10** | 验证应用程序是否能防止XPath注入或XML注入攻击。 ([C4](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 643 |\n\n注意：使用参数化查询或转义SQL并不总是足够的；表和列名、ORDER BY等不能被转义。若在这些字段中转义用户提供的数据，会导致查询失败或SQL注入。\n\n注意：SVG格式在几乎所有情况下都明确允许ECMA脚本，所以可能无法完全阻止所有的SVG XSS向量。如果需要上传SVG，我们强烈建议将这些上传的文件作为text/plain提供，或者使用一个单独的“用户提供内容”域，以防止成功的XSS接管应用程序。\n\n## V5.4 内存、字符串和非托管代码\n\n以下要求仅在应用程序使用系统语言或非托管代码时适用。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.4.1** | 验证应用程序是否使用内存安全字符串、更安全的内存复制和指针运算，以检测或防止堆栈、缓冲区或堆溢出。 | | ✓ | ✓ | 120 |\n| **5.4.2** | 验证格式化字符串不接受潜在的有害输入，并且是常量。 | | ✓ | ✓ | 134 |\n| **5.4.3** | 验证运用了符号、范围和输入验证技术来防止整数溢出。 | | ✓ | ✓ | 190 |\n\n## V5.5 预防反序列化\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **5.5.1** | 验证序列化对象是否使用完整性检查或加密，以防止恶意对象的创建或数据篡改。 ([C5](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 502 |\n| **5.5.2** | 验证应用程序正确限制 XML 解析器，使其只使用最严格的配置，并确保禁用不安全的功能，如解析外部实体，以防止 XML 外部实体注入（XXE）攻击。 | ✓ | ✓ | ✓ | 611 |\n| **5.5.3** | 验证自定义代码和第三方库（如JSON、XML和YAML解析器）禁止或限制不受信任数据的反序列化。 | ✓ | ✓ | ✓ | 502 |\n| **5.5.4** | 验证在浏览器或基于 JavaScript 的后端解析 JSON 时，使用 JSON.parse 来解析 JSON 文档。不使用 eval() 来解析 JSON。 | ✓ | ✓ | ✓ | 95 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Testing Guide 4.0: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Cheat Sheet: Input Validation](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.html)\n* [OWASP LDAP Injection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Testing Guide 4.0: Client Side Testing](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/11-Client_Side_Testing/)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [XML External Entity (XXE) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n\n有关自动转义的更多信息，请参阅：\n\n* [Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems](https://googleonlinesecurity.blogspot.com/2009/03/reducing-xss-by-way-of-automatic.html)\n* [AngularJS Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n* [AngularJS ngBind](https://docs.angularjs.org/api/ng/directive/ngBind)\n* [Angular Sanitization](https://angular.io/guide/security#sanitization-and-security-contexts)\n* [Angular Security](https://angular.io/guide/security)\n* [ReactJS Escaping](https://reactjs.org/docs/introducing-jsx.html#jsx-prevents-injection-attacks)\n* [Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)\n\n有关反序列化的更多信息，请参阅：\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [OWASP Deserialization of Untrusted Data Guide](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data)\n", "timestamp": "2025-10-24T11:40:03.668461"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x14-V6-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x14-V6-Cryptography.md", "content": "# V6 存储密码学\n\n## 控制目标\n\n确保经过验证的应用程序满足以下高级要求：\n\n* 所有加密模块以安全的方式失效，并且正确处理错误。\n* 使用合适的随机数发生器。\n* 密钥访问被安全地管理。\n\n## V6.1 数据分类\n\n最重要的资产是由应用程序处理、存储或传输的数据。始终执行隐私影响评估，对任何存储数据的数据保护需求进行正确分类。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.1.1** | 验证受监管的私人数据在静止状态下是否被加密存储，如个人身份信息（PII）、敏感个人信息或经评估可能受制于欧盟GDPR的数据。 | | ✓ | ✓ | 311 |\n| **6.1.2** | 验证受监管的健康数据在静止状态下是否被加密存储，如医疗记录、医疗设备详情或去匿名化的研究记录。 | | ✓ | ✓ | 311 |\n| **6.1.3** | 验证受监管的金融数据在静止状态下是否被加密存储，如金融账户、违约或信用记录、税务记录、工资记录、受益人或去匿名化的市场或研究记录。 | | ✓ | ✓ | 311 |\n\n## V6.2 算法\n\n密码学的最新进展意味着以前安全的算法和密钥长度不再安全或足以保护数据。因此，应该可以改变算法。\n\n虽然这一部分不容易进行渗透测试，但开发人员应该把这一整节视为强制性的，即使在大多数项目中 L1 都没有要求。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.2.1** | 验证所有的加密模块即使在故障时也是安全的，并且处理错误的方式不会使Padding Oracle攻击得逞。 | ✓ | ✓ | ✓ | 310 |\n| **6.2.2** | 验证使用业界认可或政府批准的加密算法、模式和库，而不是自定义编码的加密技术。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **6.2.3** | 验证加密初始化向量、密码配置和分组模式是否使用最新建议进行安全配置。 | | ✓ | ✓ | 326 |\n| **6.2.4** | 验证随机数、加密或散列算法、密钥长度、轮次、密码或模式，可以在任何时候重新配置、升级或交换，以防止密码中断。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 326 |\n| **6.2.5** | 验证不使用已知不安全的分组模式（如ECB等）、填充模式（如PKCS#1 v1.5等）、小块大小的密码（如Triple-DES、Blowfish等）和弱散列算法（如MD5、SHA1等），除非需要向后兼容。 | | ✓ | ✓ | 326 |\n| **6.2.6** | 验证随机数、初始化向量和其他一次性使用的数字，不得与特定的加密密钥使用超过一次。生成方法必须适合所使用的算法。 | | ✓ | ✓ | 326 |\n| **6.2.7** | 验证加密数据是否通过签名、认证的密码模式或 HMAC 进行身份验证，以确保密文不会被未经授权的一方更改。 | | | ✓ | 326 |\n| **6.2.8** | 验证所有的密码操作都是恒定时间的，在比较、计算或返回中没有“短路”操作，以避免信息泄漏。 | | | ✓ | 385 |\n\n## V6.3 随机值\n\n真正的伪随机数生成（PRNG）很难实现。通常，如果过度使用，系统内良好的熵源不但很快耗尽，而且随机性较小的源会导致可预测的密钥和秘密。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.3.1** | 验证所有的随机数、随机文件名、随机GUID和随机字符串，都是使用加密模块认可的加密安全随机数生成器生成的，而这些随机值旨在不被攻击者猜测。 | | ✓ | ✓ | 338 |\n| **6.3.2** | 验证是否使用 GUID v4 算法和加密安全伪随机数生成器（CSPRNG）创建了随机 GUID。使用其他伪随机数生成器创建的 GUID 可能是可预测的。 | | ✓ | ✓ | 338 |\n| **6.3.3** | 验证应用程序即使在处于高负载下时也使用适当的熵创建随机数，或者应用程序在这种情况下优雅地降级。 | | | ✓ | 338 |\n\n## V6.4 密钥管理\n\n虽然这一部分不容易进行渗透测试，但开发人员应将整个部分视为强制性的，即使大多数项目中都缺少 L1 的要求。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **6.4.1** | 验证秘密管理解决方案，如钥匙库，用于安全地创建、存储、控制对秘密的访问和销毁。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 798 |\n| **6.4.2** | 验证密钥材料是否未暴露给应用程序，而是使用一个隔离的安全模块（如保险库）进行加密操作。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 320 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Testing Guide 4.0: Testing for weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/README.html)\n* [OWASP Cheat Sheet: Cryptographic Storage](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-2](https://csrc.nist.gov/publications/detail/fips/140/2/final)\n", "timestamp": "2025-10-24T11:40:03.764752"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x15-V7-Error-Logging.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x15-V7-Error-Logging.md", "content": "# V7 错误处理和日志记录\n\n## 控制目标\n\n错误处理和记录的主要目标，是为用户、管理员和事件响应团队提供有用的信息。目标不是创建大量日志，而是创建高质量的日志，信息多于丢弃的噪声。\n\n高质量的日志往往包含敏感数据，必须按照当地的数据隐私法或指令进行保护。这应该包括：\n\n* 除非特别要求，否则不收集或记录敏感信息。\n* 确保所有记录的信息被安全地处理，并根据其数据分类进行保护。\n* 确保日志不会被永久存储，而是有一个尽可能短的生命周期。\n\n如果日志包含私人或敏感数据（各国对这些数据的定义各不相同），则日志将成为应用程序所持有的最敏感信息之一，因此对攻击者本身来说非常有吸引力。\n\n同样重要的是，要确保应用程序安全地故障，而且错误不会泄露不必要的信息。\n\n## V7.1 日志内容\n\n记录敏感信息是很危险的——日志本身就成了机密，这意味着它们需要被加密，成为保留政策的对象，并且必须在安全审计中被披露。确保只有必要的信息被保存在日志中，当然没有支付、凭证（包括会话令牌）、敏感或个人身份信息。\n\nV7.1 涵盖了 OWASP Top 10 2017:A10. 由于 2017:A10 和本节不可通过渗透测试来验证，重要的是：\n\n* 开发人员要确保完全遵守本节，就像所有项目都被标记为L1一样。\n* 渗透测试人员通过访谈，屏幕截图或断言来验证 V7.1 中所有项目的完全合规性。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.1.1** | 验证应用程序不记录凭证或支付细节。会话令牌应该只以不可逆的散列形式存储在日志中。 ([C9, C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.2** | 验证应用程序不会记录当地隐私法或相关安全政策规定的其他敏感数据。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 532 |\n| **7.1.3** | 验证应用程序是否记录安全相关事件，例如成功和失败的认证事件、访问控制失败、反序列化失败和输入验证失败的事件。 ([C5, C7](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n| **7.1.4** | 验证每个日志事件都包含必要的信息，以便在事件发生后详细调查时间轴。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 778 |\n\n## V7.2 日志处理\n\n及时的日志记录对于事件的审计、研判和升级是至关重要的。确保应用程序的日志是清晰的，可以很容易地在本地监测和分析，或将日志发送到远程监控系统。\n\nV7.2 涵盖了 OWASP Top 10 2017:A10. 由于 2017:A10 和本节不可通过渗透测试来验证，重要的是：\n\n* 开发人员要确保完全遵守本节，就像所有项目都被标记为L1一样。\n* 渗透测试人员通过访谈，屏幕截图或断言来验证 V7.2 中所有项目的完全合规性。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.2.1** | 验证所有的认证决策都被记录下来，不存储敏感的会话令牌或密码。这应该包括安全调查所需的具有相关元数据的请求。 | | ✓ | ✓ | 778 |\n| **7.2.2** | 验证是否可以记录所有访问控制决策并记录所有失败的决策。这应包括安全调查所需的具有相关元数据的请求。 | | ✓ | ✓ | 285 |\n\n## V7.3 日志保护\n\n可以轻易修改或删除的日志，对于调查和起诉毫无用处。日志的披露可能会暴露有关应用程序或其包含的数据的内部细节。在保护日志免遭未经授权的披露、修改或删除时，必须小心谨慎。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.3.1** | 验证所有日志组件是否对数据进行了适当的编码，以防止日志注入。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 117 |\n| **7.3.2** | [已删除，与 7.3.1 重复] | | | | |\n| **7.3.3** | 验证安全日志是否受到保护，防止未授权的访问或修改。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 200 |\n| **7.3.4** | 验证时间源是否同步到正确的时间和时区。如果系统是全球性的，强烈考虑只用UTC来记录，以协助事件后的取证分析。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n\n注意：日志编码（7.3.1）很难使用自动化工具和渗透测试进行测试和审查，但架构师、开发人员和源代码审查人员应将其视为 L1 要求。\n\n\n## V7.4 错误处理\n\n错误处理的目的，是允许应用程序提供与安全有关的事件，用于监控、研判和升级。目的不是为了创建日志。当记录安全相关的事件时，要确保日志有其目的，并且可以被SIEM或分析软件识别。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **7.4.1** | 验证在发生意外或安全敏感错误时，是否显示通用信息，可能带有支持人员可以用于调查的唯一ID。 ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 210 |\n| **7.4.2** | 验证整个代码库是否使用了异常处理（或类似功能），以说明预期和非预期的错误情况。 ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 544 |\n| **7.4.3** | 验证是否定义了“最后手段”的错误处理程序，以捕获所有未处理的异常。 ([C10](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 431 |\n\n注意：某些语言，例如 Swift 和 Go ——以及通过常见的设计实践——许多函数式语言，不支持异常或最后的事件处理程序。在这种情况下，架构师和开发人员应该使用一种模式、语言或框架友好的方式，来确保应用程序能够安全地处理异常、意外或安全相关的事件。\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Testing Guide 4.0 content: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README.html)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n", "timestamp": "2025-10-24T11:40:03.869647"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x16-V8-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x16-V8-Data-Protection.md", "content": "# V8 数据保护\n\n## Control Objective\n\n健全的数据保护有三个关键因素。机密性、完整性和可用性（CIA）。这个标准假定数据保护是在一个可信的系统上执行的，比如服务器，它已经被加固并有足够的保护措施。\n\n应用程序必须假设所有的用户设备都以某种方式受到损害。如果应用程序在不安全的设备上传输或存储敏感信息，如共享电脑、手机和平板电脑，应用程序有责任确保存储在这些设备上的数据是加密的，不能轻易地被非法获取、改变或披露。\n\n确保经过验证的应用程序满足以下高水平的数据保护要求：\n\n* 机密性。数据应受到保护，在传输过程中和存储时都不会被未经授权的观察或披露。\n* 完整性。应保护数据不被未经授权的攻击者恶意创建、更改或删除。\n* 可用性。数据应按要求提供给授权的用户。\n\n## V8.1 通用数据保护\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.1.1** | 验证应用程序保护敏感数据不被缓存在负载均衡和应用程序缓存等服务器组件中。 | | ✓ | ✓ | 524 |\n| **8.1.2** | 验证在服务器上所存储敏感数据的所有缓存或临时副本是否受到保护（防止未经授权的访问），或在被授权用户访问后清除/失效。 | | ✓ | ✓ | 524 |\n| **8.1.3** | 验证应用程序尽量减少请求中的参数数量，如隐藏字段、Ajax 变量、cookies 和请求头。 | | ✓ | ✓ | 233 |\n| **8.1.4** | 验证应用程序能够检测并提醒异常的请求数量，例如按IP、用户、每小时或每天的总数，或其它对应用程序有意义的指标。 | | ✓ | ✓ | 770 |\n| **8.1.5** | 验证是否对重要数据进行了定期备份，是否对数据进行了测试恢复。 | | | ✓ | 19 |\n| **8.1.6** | 验证备份的安全存储，防止数据被盗或损坏。 | | | ✓ | 19 |\n\n## V8.2 客户端数据保护\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.2.1** | 验证应用程序设置足够的“禁止缓存”头，以便敏感数据不会在现代浏览器中被缓存。 | ✓ | ✓ | ✓ | 525 |\n| **8.2.2** | 验证存储在浏览器存储（例如 localStorage、sessionStorage、IndexedDB 或 cookie）中的数据不包含敏感数据。 | ✓ | ✓ | ✓ | 922 |\n| **8.2.3** | 在客户端或会话终止后，验证经过身份验证的数据已从客户端存储（例如浏览器 DOM）中清除。 | ✓ | ✓ | ✓ | 922 |\n\n## V8.3 敏感私有数据\n\n本小节有助于保护敏感数据免遭未经授权的创建、读取、更新或删除，尤其是批量数据。\n\n遵守本节意味着遵守 V4 访问控制，尤其是 V4.2。例如，为了防止个人敏感信息的未授权的更新或泄露，需要遵守 V4.2.1。请遵守本节和 V4 以获得全面覆盖。\n\n注意：隐私法规和法律，例如澳大利亚隐私原则 APP-11 或 GDPR，直接影响应用程序必须如何处理敏感个人信息的存储、使用和传输的实施。范围从严厉的处罚到简单的建议。请查阅您当地的法律法规，并根据需要咨询专业的隐私专家或律师。\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **8.3.1** | 验证敏感数据是在HTTP消息正文或请求头中被发送到服务器，以及HTTP请求方法的查询字符串参数都不包含敏感数据。 | ✓ | ✓ | ✓ | 319 |\n| **8.3.2** | 验证用户是否有途径按需删除或导出自己的数据。 | ✓ | ✓ | ✓ | 212 |\n| **8.3.3** | 验证向用户提供了关于收集和使用其个人信息的明确语言，并且在以任何方式使用这些数据之前，用户已勾选了同意。 | ✓ | ✓ | ✓ | 285 |\n| **8.3.4** | 验证应用程序创建和处理的所有敏感数据是否已被识别，并确保已制定了如何处理敏感数据的策略。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 200 |\n| **8.3.5** | 如果数据是根据相关数据保护指令收集的或（应用）要求记录访问日志，验证访问敏感数据是否被审计（不记录敏感数据本身）。 | | ✓ | ✓ | 532 |\n| **8.3.6** | 为了减少内存转储攻击，一旦不再需要内存中的敏感信息，请检查该敏感信息是否会被覆盖（使用0或随机数）。 | | ✓ | ✓ | 226 |\n| **8.3.7** | 验证需要加密的敏感信息或私有信息是否使用经过批准的机密性和完整性算法加密。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 327 |\n| **8.3.8** | 验证敏感的个人信息是否符合数据保留分类，以便自动、按计划或根据情况需要删除旧数据或过时数据。 | | ✓ | ✓ | 285 |\n\n在考虑数据保护时，首要的考虑应该围绕批量提取、修改或过度使用。例如，许多社交媒体系统只允许用户每天添加100个新好友，但这些请求来自哪个系统并不重要。银行平台可能希望阻止每小时超过5笔的、转移超过1000欧元的外部交易。每个系统的要求可能非常不同，所以决定 “异常” 必须考虑威胁模型和商业风险。重要的标准是检测、遏制，或者最好是阻止这种异常批量行为的能力。\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [Consider using Security Headers website to check security and anti-caching headers](https://securityheaders.io)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [European Union General Data Protection Regulation (GDPR) overview](https://edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n", "timestamp": "2025-10-24T11:40:03.967168"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x17-V9-Communications.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x17-V9-Communications.md", "content": "# V9 通讯\n\n## 控制目标\n\n确保经过验证的应用程序满足以下高级要求：\n\n* 要求 TLS 或强加密，与内容的敏感性无关。\n* 遵循最新指南，包括：\n  * 配置建议\n  * 首选算法和密码\n* 避免使用弱的或即将被废弃的算法和密码，除非是最后的手段。\n* 禁用已废弃或已知不安全的算法和密码。\n\n在这些要求范围内：\n\n* 了解业界对安全TLS配置的建议，因为它经常变化（往往是由于现有算法和密码的灾难性破坏）。\n* 使用最新版本的TLS配置审查工具，来配置首选顺序和算法选择。\n* 定期检查你的配置，以确保安全通信始终存在并有效。\n\n## V9.1 客户端通信安全\n\n确保所有客户端消息都通过加密网络发送，使用TLS 1.2或更高版本。\n使用最新的工具定期检查客户端配置。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.1.1** | 验证所有客户端连接都使用了TLS，并且不会降级到不安全或未加密的通信。 ([C8](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 319 |\n| **9.1.2** | 使用最新的TLS测试工具，验证是否只启用了强密码套件，并将最强的密码套件设置为首选。 | ✓ | ✓ | ✓ | 326 |\n| **9.1.3** | 验证只启用最新推荐版本的TLS协议，如TLS 1.2和TLS 1.3。最新版本的TLS协议应该是首选项。 | ✓ | ✓ | ✓ | 326 |\n\n## V9.2 服务器通信安全\n\n服务器通信不仅仅是 HTTP。与其他系统的安全连接，例如监控系统、管理工具、远程访问和 ssh、中间件、数据库、大型机、合作伙伴或外部源系统——必须到位。所有这些都必须加密，以防止“外面安全，里面被轻易截获”。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **9.2.1** | 验证与服务器的连接是否使用受信任的TLS证书。在使用内部生成或自签名证书的情况下，必须将服务器配置为只信任特定的内部CA和特定的自签证书。所有其他的都应该被拒绝。 | | ✓ | ✓ | 295 |\n| **9.2.2** | 确认所有入站和出站连接都使用了 TLS 等加密通信，包括管理端口、监控、身份验证、API 或 Web 服务调用、数据库、云、serverless、大型机、外部和合作伙伴的连接。服务器不得回退到不安全或未加密的协议。 | | ✓ | ✓ | 319 |\n| **9.2.3** | 验证所有外部系统中与敏感信息/功能相关的加密连接，均已通过身份验证。 | | ✓ | ✓ | 287 |\n| **9.2.4** | 验证是否启用并配置了正确的证书吊销，例如在线证书状态协议（OCSP）Stapling。 | | ✓ | ✓ | 299 |\n| **9.2.5** | 验证是否记录了后端TLS连接失败（的事件）。 | | | ✓ | 544 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP – TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* [OWASP - Pinning Guide](https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning)\n* 关于 “TLS的批准模式“ 的说明:\n    * 在过去，ASVS提到了美国标准FIPS 140-2，但作为一个全球标准美国标准的应用可能充满困难、矛盾或混乱。\n    * 实现第9.1节的更好方法是审查指南，如 [Mozilla's Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS) or [generate known good configurations](https://mozilla.github.io/server-side-tls/ssl-config-generator/)，并使用已知最新的TLS评估工具来获得所需的安全等级。\n", "timestamp": "2025-10-24T11:40:04.051958"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x18-V10-Malicious.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x18-V10-Malicious.md", "content": "# V10 恶意代码\n\n## 控制目标\n\n确保代码满足以下高级要求：\n\n* 恶意活动得到安全和适当的处理，不会影响应用程序的其余部分。\n* 没有定时炸弹或其他基于时间的攻击。\n* 不会向恶意或未经授权的目的地“打电话回家”。\n* 没有后门、复活节彩蛋、Salami攻击、rootkit 或攻击者可以控制的未授权代码。\n\n发现恶意代码是否定的证明，这是不可能被充分验证的。应尽最大努力，确保代码没有固有的恶意代码或不需要的功能。\n\n## V10.1 代码完整性\n\n对恶意代码的最佳防御是“信任，但要验证”。在许多司法管辖区，将未经授权或恶意的代码片段引入代码，通常是刑事犯罪。策略和过程应明确对恶意代码的制裁。\n\n首席开发人员应该定期检查代码签入，特别是那些可能去访问时间、I/O或网络功能的代码签入。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.1.1** | 验证是否使用了代码分析工具，可以检测潜在的恶意代码，如时间函数、不安全的文件操作和网络连接。 | | | ✓ | 749 |\n\n## V10.2 恶意代码搜索\n\n恶意代码极为罕见，难以检测。手动逐行审查代码可以帮助寻找逻辑炸弹，但即使是最有经验的代码审查员也很难找到恶意代码，哪怕事先知道它们的存在。\n\n如果不能完全接触到源代码，包括第三方库，就不可能遵守本节的规定。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.2.1** | 验证应用程序的源代码和第三方库不包含未经授权的回连或数据收集功能。如果存在这样的功能，在收集任何数据之前，要获得用户的操作许可。 | | ✓ | ✓ | 359 |\n| **10.2.2** | 验证应用程序不会对隐私相关的功能或传感器（例如联系人、摄像头、麦克风或位置）要求不必要或过度的权限。 | | ✓ | ✓ | 272 |\n| **10.2.3** | 验证应用程序的源代码和第三方库不包含后门，如硬编码或额外的未记录的账户或密钥、代码混淆、未记录的二进制blobs、rootkits或反调试、不安全的调试特性，或其他过时、不安全或隐藏的功能，一旦被发现可能会被恶意使用。 | | | ✓ | 507 |\n| **10.2.4** | 通过搜索日期和时间相关函数，来验证应用程序源代码和第三方库不包含时间炸弹。 | | | ✓ | 511 |\n| **10.2.5** | 验证应用程序源代码和第三方库不包含恶意代码，例如salami攻击、逻辑绕过或逻辑炸弹。 | | | ✓ | 511 |\n| **10.2.6** | 验证应用程序的源代码和第三方库不包含复活节彩蛋或任何其他潜在的冗余功能。 | | | ✓ | 507 |\n\n## V10.3 应用程序完整性\n\n应用程序被部署后，恶意代码仍然可以被插入。应用程序需要保护自己免受常见的攻击，例如执行来自不受信任来源的未签名代码或子域接管。\n\n本节内容的实现，很可能是操作性和持续性的。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **10.3.1** | 验证如果应用程序具有客户端或服务器自动更新功能，则应通过安全通道获得更新，并进行数字签名。更新代码必须在安装或执行更新之前验证更新的数字签名。 | ✓ | ✓ | ✓ | 16 |\n| **10.3.2** | 验证应用程序是否采用了完整性保护，如代码签名或子资源完整性。应用程序不得从不受信任的来源加载或执行代码，例如从不可信任的来源或互联网加载模块、插件、代码或库。 | ✓ | ✓ | ✓ | 353 |\n| **10.3.3** | 如果应用程序依赖 DNS 条目或 DNS 子域，例如过期的域名、过时的 DNS 指针或 CNAME、公共源代码库中过期的项目或临时的云API接口、serverless功能或存储桶（*autogen-bucket-id*.cloud.example.com）或类似情况，则验证该应用程序是否具有防止子域接管的措施。保护措施可以包括确保定期检查应用程序使用的DNS名称是否过期或改变。 | ✓ | ✓ | ✓ | 350 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [Hostile Subdomain Takeover, Detectify Labs](https://labs.detectify.com/2014/10/21/hostile-subdomain-takeover-using-herokugithubdesk-more/)\n* [Hijacking of abandoned subdomains part 2, Detectify Labs](https://labs.detectify.com/2014/12/08/hijacking-of-abandoned-subdomains-part-2/)\n", "timestamp": "2025-10-24T11:40:04.114536"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x19-V11-BusLogic.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x19-V11-BusLogic.md", "content": "# V11 业务逻辑\n\n## 控制目标\n\n确保经过验证的应用程序满足以下高级要求：\n\n* 业务逻辑流程是串行的，按顺序处理的，并且不能被绕过。\n* 业务逻辑包括检测和防止自动化攻击，如连续的小额资金转移，或一次添加上百万个好友等。\n* 高价值的业务逻辑流已经考虑了滥用情况和恶意行为者，并有防止欺骗、篡改、信息披露和特权提升攻击的保护措施。\n\n## V11.1 业务逻辑安全\n\n业务逻辑安全对每个应用程序来说都是非常独特的，因此没有通用的检查表。业务逻辑安全必须设计成能够抵御可能的外部威胁——它不能使用 Web 应用防火墙或安全通信来添加。我们建议在设计冲刺（Design Sprint）期间使用威胁建模，例如使用 OWASP Cornucopia 或类似工具。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **11.1.1** | 验证应用程序仅按串行顺序处理同一用户的业务逻辑流，不会跳过步骤。 | ✓ | ✓ | ✓ | 841 |\n| **11.1.2** | 验证应用程序将只处理业务逻辑流，所有步骤都在现实的人工时间内处理，即事务不会提交得太快。 | ✓ | ✓ | ✓ | 799 |\n| **11.1.3** | 验证应用程序是否对特定的业务操作或交易有适当的限制，并在每个用户的基础上正确执行。 | ✓ | ✓ | ✓ | 770 |\n| **11.1.4** | 验证应用程序具有反自动化的控制手段，以防止过度调用，如大量数据泄露、业务逻辑请求、文件上传或拒绝服务攻击。 | ✓ | ✓ | ✓ | 770 |\n| **11.1.5** | 验证应用程序是否具有业务逻辑限制或验证，以防止可能的业务风险或威胁（使用威胁建模或类似方法识别）。 | ✓ | ✓ | ✓ | 841 |\n| **11.1.6** | 验证应用程序是否存在TOCTOU（Time Of Check to Time Of Use）问题 或敏感操作的其他条件竞争问题。 | | ✓ | ✓ | 367 |\n| **11.1.7** | 验证应用程序是否从业务逻辑角度监控异常事件或活动。例如，尝试执行无序的操作或普通用户永远不会尝试的操作。 ([C9](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 754 |\n| **11.1.8** | 验证应用程序在检测到自动化攻击或异常活动时，具有可配置的警报。 | | ✓ | ✓ | 390 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Web Security Testing Guide 4.1: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README.html)\n* 反自动化可以通过多种方式实现，包括使用 [OWASP AppSensor](https://github.com/jtmelton/appsensor) 和 [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP AppSensor](https://github.com/jtmelton/appsensor) 也可以帮助进行攻击检测和响应。\n* [OWASP Cornucopia](https://owasp.org/www-project-cornucopia/)\n", "timestamp": "2025-10-24T11:40:04.207635"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x20-V12-Files-Resources.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x20-V12-Files-Resources.md", "content": "# V12 文件和资源\n\n## 控制目标\n\n确保经过验证的应用程序满足以下高级要求：\n\n* 不受信任的文件数据应以安全的方式进行相应处理。\n* 从不可信任的来源获得的不可信任的文件数据被存储在Web目录之外，并具有有限的权限。\n\n## V12.1 文件上传\n\n尽管zip炸弹很容易使用渗透测试技术进行测试，但它们被认为是L2及以上级别，以鼓励设计和开发时考虑仔细的人工测试，并避免对拒绝服务场景进行自动化或不熟练的手动渗透测试。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.1.1** | 确认应用程序不会接受可能会填满存储空间或导致拒绝服务的大文件。 | ✓ | ✓ | ✓ | 400 |\n| **12.1.2** | 验证应用程序在解压缩文件前，根据允许的最大解压缩尺寸和最大文件数检查压缩文件（如zip，gz，docx，odt）。 | | ✓ | ✓ | 409 |\n| **12.1.3** | 验证文件大小配额和每个用户的最大文件数是否被强制执行，以确保单个用户不能用过多的文件或过大的文件填满存储。 | | ✓ | ✓ | 770 |\n\n## V12.2 文件完整性\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.2.1** | 验证从不可信任的来源获得的文件，根据文件的内容，验证其是否为预期类型。 | | ✓ | ✓ | 434 |\n\n## V12.3 文件执行\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.3.1** | 验证系统或框架文件系统不直接使用用户提交的文件名元数据，并且使用 URL API 来防止路径遍历。 | ✓ | ✓ | ✓ | 22 |\n| **12.3.2** | 验证用户提交的文件名元数据是否经过验证或忽略，以防止通过本地文件包含（LFI） 泄露、创建、更新或删除本地文件。 | ✓ | ✓ | ✓ | 73 |\n| **12.3.3** | 验证用户提交的文件名元数据是否经过验证或忽略，以防止通过远程文件包含（Remote File Inclusion，RFI）或服务器端请求伪造攻击（server - Server Side Request Forgery，SSRF）泄露或执行远程文件。 | ✓ | ✓ | ✓ | 98 |\n| **12.3.4** | 验证应用程序通过验证或忽略用户提交的JSON、JSONP或URL参数中的文件名来防止反射文件下载（RFD），响应的Content-Type头应该设置为 text/plain，而Content-Disposition头应该有一个固定的文件名。 | ✓ | ✓ | ✓ | 641 |\n| **12.3.5** | 验证未受信任的文件元数据不直接用于系统API或库，以防止操作系统命令注入。 | ✓ | ✓ | ✓ | 78 |\n| **12.3.6** | 验证应用程序不包含或执行不可信任来源的功能，如未经验证的内容分发网络、JavaScript 库、node npm 库或服务器端 DLL。 | | ✓ | ✓ | 829 |\n\n## V12.4 文件存储\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.4.1** | 验证从不受信任的来源获得的文件是否存储在 Web 根目录之外，并具有有限的权限。 | ✓ | ✓ | ✓ | 552 |\n| **12.4.2** | 验证从不受信任的来源获得的文件是否已被防病毒扫描程序扫描，以防止上传和提供已知的恶意内容。 | ✓ | ✓ | ✓ | 509 |\n\n## V12.5 文件下载\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.5.1** | 验证网络层是否被配置为只提供具有特定文件扩展名的文件，以防止意外信息和源代码泄漏。例如，除非有需要，应阻止提供备份文件（如.bak）、临时工作文件（如.swp）、压缩文件（.zip、.tar.gz等）以及其他编辑人员常用的扩展名。 | ✓ | ✓ | ✓ | 552 |\n| **12.5.2** | 验证对上传文件的直接请求永远不会作为 HTML/JavaScript 内容执行。 | ✓ | ✓ | ✓ | 434 |\n\n## V12.6 SSRF保护\n\n| # | 说明 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **12.6.1** | 验证 Web 或应用程序服务器是否配置了资源或系统的白名单列表，服务器可以向其发送请求或加载数据/文件。 | ✓ | ✓ | ✓ | 918 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [File Extension Handling for Sensitive Information](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)\n* [Reflective file download by Oren Hafif](https://www.trustwave.com/Resources/SpiderLabs-Blog/Reflected-File-Download---A-New-Web-Attack-Vector/)\n* [OWASP Third Party JavaScript Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:04.284417"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x21-V13-API.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x21-V13-API.md", "content": "# V13 API和Web Service\n\n## 控制目标\n\n确保经验证使用可信服务层API（通常使用JSON或XML或GraphQL）的应用程序具有:\n\n* 对所有网络服务进行充分的认证、会话管理和授权。\n* 对所有从较低信任级别传入较高信任级别的输入参数进行验证。\n* 有效地对所有API类型进行安全控制，包括云和Serverless API。\n\n请将本章与其他章节结合起来阅读；我们不再重复说明认证或API会话管理问题。\n\n## V13.1 通用Web Service安全\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.1.1** | 验证所有应用程序组件使用相同的编码和解析器，以避免利用不同的URI或文件解析特性的攻击（这些解析特性可能被用于SSRF和RFI攻击）。 | ✓ | ✓ | ✓ | 116 |\n| **13.1.2** | [已删除，与 4.3.1 重复] | | | | |\n| **13.1.3** | 验证 API URL不公开敏感信息，例如 API 密钥、会话令牌等。 | ✓ | ✓ | ✓ | 598 |\n| **13.1.4** | 验证授权决策是同时在URI（由程序性或声明性的控制器或路由安全执行）和资源层面（由基于模型的权限执行）做出的。 | | ✓ | ✓ | 285 |\n| **13.1.5** | 验证包含意外或缺少内容类型的请求是否通过适当的响应头拒绝（HTTP 响应状态 406 Unacceptable 或 415 Unsupported Media Type）。 | | ✓ | ✓ | 434 |\n\n## V13.2 RESTful Web Service\n\nJSON模式验证还处于标准化的草案阶段（见参考文献）。当考虑使用JSON模式验证（这是RESTful web services的最佳实践）时，可以考虑将这些额外的数据验证策略与JSON模式验证结合使用:\n\n* 对JSON对象进行解析验证，例如是否有缺失或多余的元素。\n* 使用标准的输入验证方法对JSON对象的值进行验证，如数据类型、数据格式、长度等。\n* 以及正式的JSON模式验证。\n\n一旦JSON模式验证标准被正式确定，ASVS将更新这方面的建议。仔细监测正在使用的任何JSON模式验证库，因为它们需要定期更新，直到标准正式化并且从参考实现中消除错误。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.2.1** | 验证启用的RESTful HTTP方法对用户或操作来说是有效的选择，例如防止普通用户在受保护的API或资源上使用DELETE或PUT。 | ✓ | ✓ | ✓ | 650 |\n| **13.2.2** | 验证 JSON 模式验证是否到位，并在接受输入之前进行验证。 | ✓ | ✓ | ✓ | 20 |\n| **13.2.3** | 通过使用以下至少一项或多项来验证使用 cookie 的 RESTful Web services是否受到跨站点请求伪造（CSRF）的保护：双重提交 cookie 模式、CSRF 随机数或 Origin 请求头检查。 | ✓ | ✓ | ✓ | 352 |\n| **13.2.4** | [已删除，与 11.1.4 重复] | | | | |\n| **13.2.5** | 验证REST服务明确检查传入的Content-Type是否为预期类型，如application/xml或application/json。 | | ✓ | ✓ | 436 |\n| **13.2.6** | 验证消息头和有效载荷是可信的，在传输过程中没有被修改。在许多情况下，要求对传输进行强加密（仅TLS）可能就足够了，因为它同时提供保密性和完整性保护。每条信息的数字签名可以在传输保护的基础上，为高安全性的应用提供额外的保证，但也带来了额外的复杂性和风险，需要权衡利弊。 | | ✓ | ✓ | 345 |\n\n## V13.3 SOAP Web Service\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.3.1** | 验证是否进行了 XSD 模式验证以确保 XML 文档格式正确，然后在对该数据进行任何处理之前验证每个输入字段。 | ✓ | ✓ | ✓ | 20 |\n| **13.3.2** | 验证消息负载是否使用 WS-Security 进行签名，以确保客户端和service之间的可靠传输。 | | ✓ | ✓ | 345 |\n\n注意：由于针对 DTD 存在 XXE 攻击问题，因此不应使用 DTD 验证，并且根据 V14 配置 中规定的要求，禁用框架 DTD 评估。\n\n## V13.4 GraphQL\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **13.4.1** | 验证是否使用查询白名单或深度和数量限制的组合，来防止昂贵的嵌套查询，导致对 GraphQL 或数据层表达式的拒绝服务（DoS）。对于更高级的场景，应该使用查询成本分析。 | | ✓ | ✓ | 770 |\n| **13.4.2** | 验证 GraphQL 或其他数据层的授权逻辑应在业务逻辑层，而不是 GraphQL 层实现。 | | ✓ | ✓ | 285 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Serverless Top 10](https://github.com/OWASP/Serverless-Top-10-Project/raw/master/OWASP-Top-10-Serverless-Interpretation-en.pdf)\n* [OWASP Serverless Project](https://owasp.org/www-project-serverless-top-10/)\n* [OWASP Testing Guide 4.0: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [OWASP Cross-Site Request Forgery cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet - General Guidance](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#general-guidance)\n* [JSON Web Tokens (and Signing)](https://jwt.io/)\n* [REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n* [XML DTD Entity Attacks](https://www.vsecurity.com/download/publications/XMLDTDEntityAttacks.pdf)\n* [Orange Tsai - A new era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:04.328638"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x22-V14-Config.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x22-V14-Config.md", "content": "# V14 配置\n\n## 控制目标\n\n确保经过验证的应用程序具有：\n\n* 一个安全的、可重复的、可自动化的构建环境。\n* 加固第三方库、依赖和配置管理，使应用不包括过时的或不安全的组件。\n\n应用程序开箱即用配置应该是安全的，可以放在互联网上，这意味着安全的开箱配置。\n\n## V14.1 构建和部署\n\n构建管道是可重复安全性的基础——每次发现不安全的东西时，都可以在源代码、构建或部署脚本中解决它，并自动进行测试。我们强烈鼓励使用自动化的构建管道来执行安全和依赖检查，这些检查会警告或破坏构建，以防止已知的安全问题被部署到生产环境中。不定期执行的手动步骤会直接导致可避免的安全错误。\n\n随着行业向DevSecOps模式的转变，必须确保部署和配置的持续可用性和完整性，以实现“已知良好”的状态。在过去，如果一个系统被入侵，需要几天到几个月的时间来证明没有进一步的入侵发生。今天，随着软件定义的基础设施、零停机时间的快速A/B部署和自动化容器构建的出现，自动和持续地构建、加固和部署一个“已知良好”的替代品来替代任何被入侵的系统，是有可能的。\n\n如果传统模式仍然存在，那么就必须采取手动步骤来加固和备份该配置，以便及时用高完整性的、未受损害的系统快速替换受损害的系统。\n\n遵守本节的规定要求一个自动化的构建系统，以及对构建和部署脚本的访问。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.1.1** | 验证应用程序的构建和部署过程是以安全和可重复的方式进行的，如 CI / CD 自动化、自动配置管理和自动部署脚本。 | | ✓ | ✓ | |\n| **14.1.2** | 验证编译器标志的配置是否配置为启用所有可用的缓冲区溢出保护和警告，包括堆栈随机化、数据执行保护，并在发现不安全的指针、内存、格式字符串、整数或字符串操作时中断构建。 | | ✓ | ✓ | 120 |\n| **14.1.3** | 验证服务器配置是否按照应用程序服务器和所使用框架的建议进行了加固。 | | ✓ | ✓ | 16 |\n| **14.1.4** | 验证应用程序、配置和所有依赖项是否可以使用自动部署脚本重新部署、在合理的时间内根据记录和测试的运行手册构建，或者及时从备份中恢复。 | | ✓ | ✓ | |\n| **14.1.5** | 验证授权管理员可以验证所有安全相关配置的完整性，以发现篡改行为。 | | | ✓ | |\n\n## V14.2 依赖\n\n依赖管理，对于任何类型应用程序的安全运行都至关重要。未能及时更新过时的或不安全的依赖，是迄今为止最大和最昂贵攻击的根本原因。\n\n注意：在 L1 ，14.2.1 的合规性与客户端和其他库、组件的观察或检测有关，而不是更准确的构建时静态代码分析或依赖分析。这些更准确的技术可根据需要在访谈中发现。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.2.1** | 验证所有组件都是最新的，最好是在构建或编译时使用依赖检查工具。 ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | ✓ | ✓ | ✓ | 1026 |\n| **14.2.2** | 验证所有不需要的功能、文档、示例应用程序和配置均已被删除。 | ✓ | ✓ | ✓ | 1002 |\n| **14.2.3** | 应用资产，例如JavaScript库、CSS或网页字体，如果被托管在外部的内容分发网络（CDN）或供应商，则验证使用子资源完整性（SRI）来验证该资产的完整性。 | ✓ | ✓ | ✓ | 829 |\n| **14.2.4** | 验证第三方组件来自预先定义的、可信的和持续维护的资源库。 ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 829 |\n| **14.2.5** | 验证是否维护了正在使用中的所有第三方库的软件材料清单（SBOM）。 ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | |\n| **14.2.6** | 验证通过沙盒或封装第三方库来减少攻击面，只将必需的行为暴露在应用程序中。 ([C2](https://owasp.org/www-project-proactive-controls/#div-numbering)) | | ✓ | ✓ | 265 |\n\n## V14.3 意外安全泄露\n\n应加强生产配置以防止常见攻击，例如调试控制台，提高跨站点脚本（XSS）和远程文件包含（RFI）攻击的门槛，并消除琐碎的信息发现“漏洞”，这是许多渗透测试报告中不受欢迎的标志。 其中许多问题很少被评为重大风险，但它们可跟其他漏洞联系在一起。如果这些问题在默认情况下不存在，那就提高了大多数攻击的门槛。\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.3.1** | [已删除，与 7.4.1 重复] | | | | |\n| **14.3.2** | 验证Web或应用服务器和应用框架的调试模式在生产中是否被禁用，以消除调试功能、开发人员控制台和非预期的安全披露。 | ✓ | ✓ | ✓ | 497 |\n| **14.3.3** | 验证HTTP标头或HTTP响应的任何部分不暴露系统组件的详细版本信息。 | ✓ | ✓ | ✓ | 200 |\n\n## V14.4 HTTP 安全标头\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.4.1** | 验证每个HTTP响应都包含一个 Content-Type 头。如果内容类型是 text/* 、 /+xml 和 application/xml ，还要指定一个安全的字符集（如UTF-8，ISO-8859-1）。内容必须与提供的Content-Type头相匹配。 | ✓ | ✓ | ✓ | 173 |\n| **14.4.2** | 验证所有 API 响应是否包含 Content-Disposition: attachment; filename=\"api.json\" 标头（或内容类型的其他适当文件名）。 | ✓ | ✓ | ✓ | 116 |\n| **14.4.3** | 验证内容安全策略（CSP）响应标头是否到位，有助于减轻对 HTML、DOM、JSON 和 JavaScript 注入漏洞等 XSS 攻击的影响。 | ✓ | ✓ | ✓ | 1021 |\n| **14.4.4** | 验证所有响应是否包含 X-Content-Type-Options: nosniff 标头。 | ✓ | ✓ | ✓ | 116 |\n| **14.4.5** | 验证所有响应和所有子域中是否包含 Strict-Transport-Security 标头，例如 Strict-Transport-Security: max-age=15724800; includeSubdomains。 | ✓ | ✓ | ✓ | 523 |\n| **14.4.6** | 验证是否包含合适的 Referrer-Policy 标头，以避免通过 Referer 标头将 URL 中的敏感信息暴露给不受信任的各方。 | ✓ | ✓ | ✓ | 116 |\n| **14.4.7** | 验证网络应用程序的内容在默认情况下不能被嵌入第三方网站，只有在必要时，才允许使用合适的Content-Security-Policy: frame-ancestors和X-Frame-Options响应头嵌入确切的资源。 | ✓ | ✓ | ✓ | 1021 |\n\n## V14.5 HTTP 请求头验证\n\n| # | 描述 | L1 | L2 | L3 | CWE |\n| :---: | :--- | :---: | :---: | :---: | :---: |\n| **14.5.1** | 验证应用服务器只接受应用/API使用的HTTP方法，包括预检请求的OPTIONS，并对使应用上下文无效的请求进行记录/警告。 | ✓ | ✓ | ✓ | 749 |\n| **14.5.2** | 验证提供的 Origin 标头是否不用于身份验证或访问控制决策，因为 Origin 标头很容易被攻击者更改。 | ✓ | ✓ | ✓ | 346 |\n| **14.5.3** | 验证跨域资源共享（CORS）的 Access-Control-Allow-Origin 标头是否使用受信任域和子域的严格白名单匹配。并且不支持'null'源。 | ✓ | ✓ | ✓ | 346 |\n| **14.5.4** | 验证由受信任的代理或 SSO 设备添加的 HTTP 标头（例如bearer令牌）是否已通过应用程序的身份验证。 | | ✓ | ✓ | 306 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Web Security Testing Guide 4.1: Testing for HTTP Verb Tampering](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/03-Testing_for_HTTP_Verb_Tampering.html)\n* 将 Content-Disposition 添加到 API 响应，有助于防止许多基于客户端和服务器之间的MIME类型误解的攻击，并且“filename”选项特别有助于防止 [Reflected File Download attacks.](https://www.blackhat.com/docs/eu-14/materials/eu-14-Hafif-Reflected-File-Download-A-New-Web-Attack-Vector.pdf)\n* [Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [Exploiting CORS misconfiguration for BitCoins and Bounties](https://portswigger.net/blog/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)\n* [OWASP Web Security Testing Guide 4.1: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/README.html)\n* [Sandboxing third party components](https://cheatsheetseries.owasp.org/cheatsheets/Third_Party_Javascript_Management_Cheat_Sheet.html#sandboxing-content)\n", "timestamp": "2025-10-24T11:40:04.392922"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x90-Appendix-A_Glossary.md", "content": "# 附录A：词汇表\n\n- **地址空间布局随机化**（ASLR, Address Space Layout Randomization）- 一种技术，使内存损坏的漏洞利用更加困难。\n- **允许列表** - 允许的数据或操作的列表，例如输入验证时允许执行的字符列表。\n- **应用程序安全** - 应用程序级安全性侧重于分析构成开放系统互连参考模型（OSI 模型）应用层的组件，而不是侧重于例如底层操作系统或连接网络。\n- **应用安全验证** – 根据OWASP ASVS对一个应用进行技术评估。\n- **应用安全验证报告** - 记录验证者对某一特定应用的总体结果和支持性分析的报告。\n- **认证** - 对应用用户所声称身份的验证。\n- **自动化验证** – 使用漏洞签名来发现问题的自动化工具（动态分析工具、静态分析工具或两者兼有）。\n- **黑盒测试** - 它是一种软件测试方法，在不窥视其内部结构或工作原理的情况下检查应用程序的功能。\n- **组件** - 一个独立的代码单元，有相关的磁盘和网络接口，与其他组件进行通信。\n- **跨站脚本**（XSS, Cross-Site Scripting）- 通常在网络应用中发现的一种安全漏洞，允许在内容中注入客户端脚本。\n- **加密模块** - 实现加密算法或生成加密密钥的硬件、软件或固件。\n- **常见弱点列举**（CWE, Common Weakness Enumeration）- 一个社区开发的常见软件安全弱点列表。它是一种通用语言，是软件安全工具的衡量标准，也是弱点识别、缓解和预防工作的基准。\n- **设计验证** - 对应用程序的安全架构进行技术评估。\n- **动态应用安全测试**（DAST, Dynamic Application Security Testing）- 技术旨在检测应用程序在运行状态下的安全漏洞。\n- **动态验证** - 使用自动化工具，使用漏洞签名，在应用程序的执行过程中发现问题。\n- **快速在线身份认证**（FIDO, Fast IDentity Online）- 一组认证标准，允许使用各种不同的身份验证方法，包括生物识别、可信平台模块（TPM）、USB 安全令牌等。\n- **全球唯一标识符**（GUID, Globally Unique Identifier）– 在软件中作为标识符使用的唯一参考号。\n- **超文本传输​​协议**（HTTPS）– 分布式、协作式、超媒体信息系统的应用协议。它是万维网数据通信的基础。\n- **硬编码密钥** – 存储在文件系统中的加密钥匙，无论是代码、注释还是文件。\n- **硬件安全模块**（HSM, Hardware Security Module）- 硬件组件，能够以受保护的方式存储加密密钥和其他密码。\n- **Hibernate查询语言**（HQL）- 一种查询语言，在外观上类似于Hibernate ORM库使用的SQL。\n- **输入验证** - 对未受信任的用户输入的规范化和验证。\n- **恶意代码** - 在应用程序所有者不知情的情况下，在开发过程中将代码引入到应用程序中，从而规避了应用程序的预期安全策略。这与病毒或蠕虫等恶意软件不同！\n- **恶意软件** - 在应用程序用户或管理员不知情的情况下，在运行期间被引入到应用程序的可执行代码。\n- **OWASP**（OWASP，Open Web Application Security Project）– 开放网络应用安全项目（OWASP）是一个全球自由开放的社区，致力于提高应用软件的安全性。我们的使命是使应用安全“可见”，以便人们和组织能够对应用安全风险做出明智的决定。见： See: https://www.owasp.org/\n- **一次性密码**（OTP）- 唯一生成的密码，可在单一场合中使用。\n- **对象关系映射**（ORM）- 一种系统，用于允许使用应用兼容的对象模型，在应用中引用和查询基于关系/表的数据库。\n- **PBKDF2**（PBKDF2，Password-Based Key Derivation Function 2）- 一种特殊的单向算法，用于从输入文本（如密码）和额外的随机盐值中创建一个强大的加密密钥，因此，如果产生的值被存储（而不是原始密码），则可用于使密码更难被离线破解。\n- **个人可识别信息**（PII）- 是指可单独使用或与其他信息一起使用的信息，可用于识别、联系或定位一个人，或用于识别一个人的背景。\n- **与位置无关的可执行文件**（PIE）- 放置在主存储器某处的机器代码体，无论其绝对地址如何，都能正确执行。\n- **公钥基础设施**（PKI）- 将公钥与实体的各自身份结合起来的一种安排。绑定是通过在证书机构（CA）注册和颁发证书的过程建立的。\n- **公共交换电话网**（PSTN）- 传统的电话网络，包括固定电话和移动电话。\n- **依赖方**（RP，Relying Party）- 指依赖用户对单独的认证提供者进行认证的应用程序。该应用程序依赖于该身份验证提供者提供的某种令牌或一组签名断言，来相信用户就是他们所说的那个人。\n- **静态应用安全测试**（SAST）- 一套分析应用源代码、字节码和二进制文件的技术，用于了解表明存在安全漏洞的编码和设计场景。SAST解决方案在非运行状态下从“内部”分析一个应用程序。\n- **软件开发生命周期**（SDLC）- 软件从最初的需求到部署和维护的一步步发展过程。\n- **安全架构** - 应用程序设计的抽象，确定和描述安全控制的位置和方式，同时也确定和描述用户和应用程序数据的位置和敏感性。\n- **安全配置** - 应用程序的运行时配置，影响安全控制的使用方式。\n- **安全控制** - 执行安全检查（如访问控制检查）或在调用时产生安全效果（如生成审计记录）的功能或组件。\n- **服务器端请求伪造**（SSRF）- 滥用服务器上的功能，通过更改在服务器上运行的代码会读取或提交数据的URL，来读取或更新内部资源的攻击。\n- **单点登录验证**（SSO）- 这发生在用户登录到一个应用程序，然后就自动登录到其他应用程序，而无需重新认证。例如，当你已登录到Google时，在访问其他谷歌服务，如YouTube、谷歌文档和Gmail时，你将自动登录。\n- **SQL注入**（SQLi）- 一种代码注入技术，用于攻击数据驱动的应用程序，其中恶意的SQL语句被插入到一个入口点。\n- **SVG** - 可扩展矢量图形\n- **基于时间的OTP** - 一种生成OTP的方法，将当前的时间作为生成密码的算法的一部分。\n- **威胁建模** - 一种技术，包括开发越来越精细的安全架构，以确定威胁代理、安全域、安全控制以及重要的技术和商业资产。\n- **传输层安全**（TLS）- 通过网络连接提供通信安全的加密协议。\n- **信任平台模块**（TPM，Trusted Platform Module）- 一种HSM，通常连接到较大的硬件组件，如主板，并作为该系统的“信任根”。\n- **双因素认证**（2FA）- 这为账户登录增加了第二层认证。\n- **通用第二因素**（U2F）- 由FIDO创建的标准之一，专门用于允许USB或NFC安全密钥作为第二认证因素使用。\n- **URI/URL/URL分片** – 统一资源标识符是用于标识web资源名称或web资源的字符串。统一资源定位符通常用作对资源的引用。\n- **验证者** – 根据OWASP ASVS要求审核应用程序的人员或团队。\n- **所见即所得**（WYSIWYG，What You See Is What You Get）- 一种富文本的内容编辑器，显示内容在渲染时的实际效果，而不是显示用于管理渲染的编码。\n- **X.509证书** - X.509证书是一种数字证书，它使用广泛接受的国际X.509公钥基础设施（PKI）标准，来验证公钥是否属于证书中包含的用户、计算机或服务身份。\n- **XML外部实体**（XXE，XML eXternal Entity）- 一种XML实体，可以通过声明的系统标识访问本地或远程内容。这可能会导致各种注入攻击。\n", "timestamp": "2025-10-24T11:40:04.463498"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x91-Appendix-B_References.md", "content": "# 附录B：参考文献\n\n以下OWASP项目最可能对本标准的用户/采用者有用：\n\n## OWASP核心项目\n\n1. OWASP Top 10项目：[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP网络安全测试指南：[https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP 主动控制：[https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP安全知识框架：[https://owasp.org/www-project-security-knowledge-framework/](https://owasp.org/www-project-security-knowledge-framework/)\n5. OWASP软件保障成熟度模型（SAMM）：[https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n\n## OWASP Cheat Sheet系列项目\n\n[该项目](https://owasp.org/www-project-cheat-sheets/) 有许多与 ASVS 中的不同主题相关的备忘单。\n\n可以在此处找到到 ASVS 的映射： [https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html](https://cheatsheetseries.owasp.org/cheatsheets/IndexASVS.html)\n\n## 移动安全相关项目\n\n1. OWASP 移动安全项目：[https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 风险：[https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP移动安全测试指南和移动应用安全验证标准：[https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## OWASP物联网相关项目\n\n1. OWASP物联网项目：[https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## OWASP Serverless项目\n\n1. OWASP Serverless项目：[https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## 其他\n\n同样，以下网站最有可能对本标准的用户/采用者有用\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE 常见弱点列举: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI 安全标准委员会: [https://www.pcisecuritystandards.org](https://www.pcisecuritystandards.org)\n4. PCI 数据安全标准（DSS）v3.2.1 要求和安全评估程序：[https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI 软件安全框架 - 安全软件要求和评估程序： [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI 安全软件生命周期（Secure SLC）要求和评估程序： [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n", "timestamp": "2025-10-24T11:40:04.551564"}
{"source": "github", "repo": "OWASP/ASVS", "file": "4.0/zh-cn/0x93-Appendix-C_IoT.md", "url": "https://github.com/OWASP/ASVS/blob/master/4.0/zh-cn/0x93-Appendix-C_IoT.md", "content": "# 附录C: 物联网验证要求\n\n本章原本是在main分支中，但考虑到OWASP IoT团队已完成的工作，所以在该主题上维护两个不同的线程没有意义。对于 4.0 版本，我们将其移到附录中，并敦促所有需要此功能的人使用主要的 [OWASP IoT 项目](https://owasp.org/www-project-internet-of-things/)\n\n## 控制目标\n\n嵌入式/IoT设备应该满足：\n\n* 通过在受信任的环境中实施安全控制，在设备内拥有与服务器中相同级别的安全控制。\n* 存储在设备上的敏感数据，应使用硬件支持的存储（如安全元件）以安全的方式完成。\n* 从设备传输的所有敏感数据，都应利用传输层安全。\n\n## 安全验证要求\n\n| # | 说明 | L1 | L2 | L3 | 起始时间 |\n| --- | --- | --- | --- | -- | -- |\n| **C.1** | 验证应用层调试接口，如USB、UART和其他串行变体，是否被禁用或受到复杂密码的保护。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.2** | 验证加密密钥和证书对于每个单独的设备都是唯一的。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.3** | 验证嵌入式/IoT 操作系统（如果适用）是否启用了内存保护控制（如 ASLR 和 DEP）。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.4** | 验证是否禁用了 JTAG 或 SWD 等片上调试接口，或者是否启用并正确配置了可用的保护机制。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.5** | 验证是否已实施并启用受信任的执行（如果在设备 SoC 或 CPU 上可用）。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.6** | 验证敏感数据、私钥和证书是否安全存储在Secure Element、TPM、TEE (Trusted Execution Environment)中，或使用强加密保护。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.7** | 验证固件应用程序使用传输层安全，保护传输中的数据。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.8** | 验证固件应用程序验证与服务器连接的数字签名。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.9** | 验证无线通信鉴权。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.10** | 验证无线通信是否通过加密通道发送。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.11** | 验证任何被禁止的C函数，都被替换成适当的安全函数。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.12** | 验证每个固件都有一个软件材料清单，其中包括第三方组件、版本和已公布的漏洞。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.13** | 验证所有代码，包括第三方二进制文件、库、框架都经过审查，以防止硬编码凭据（后门）。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.14** | 通过调用shell命令封装器、脚本或安全控制，来防止操作系统命令注入，验证应用程序和固件组件不受操作系统命令注入的影响。 | ✓ | ✓ | ✓ | 4.0 |\n| **C.15** | 验证固件应用程序将数字签名固定到可信服务器。 |  | ✓ | ✓ | 4.0 |\n| **C.16** | 验证是否存在防篡改或篡改检测功能。 |  | ✓ | ✓ | 4.0 |\n| **C.17** | 验证是否启用了芯片制造商提供的任何可用的知识产权保护技术。 |  | ✓ | ✓ | 4.0 |\n| **C.18** | 验证安全控制是否到位，以阻止固件逆向工程（例如，删除冗长的调试符号）。 |  | ✓ | ✓ | 4.0 |\n| **C.19** | 验证设备在加载前校验启动镜像的签名。 |  | ✓ | ✓ | 4.0 |\n| **C.20** | 验证固件更新过程不会受到“检查时间与使用时间”攻击（译者注：time-of-check vs time-of-use attacks）。 |  | ✓ | ✓ | 4.0 |\n| **C.21** | 验证设备在安装前使用代码签名并校验固件升级文件。 |  | ✓ | ✓ | 4.0 |\n| **C.22** | 验证设备不能被降级到有效固件的旧版本（防回滚）。 |  | ✓ | ✓ | 4.0 |\n| **C.23** | 验证嵌入式设备使用了密码学安全的伪随机数生成器（例如，使用芯片提供的随机数生成器）。 |  | ✓ | ✓ | 4.0 |\n| **C.24** | 验证固件能够按照预定的时间表，执行自动固件更新。 |  | ✓ | ✓ | 4.0 |\n| **C.25** | 验证设备在检测到篡改或收到无效信息时，能擦除固件和敏感数据。 |  |  | ✓ | 4.0 |\n| **C.26** | 验证只使用了支持禁用调试接口（如JTAG、SWD）的微控制器。 |  |  | ✓ | 4.0 |\n| **C.27** | 验证只使用了提供实质性保护的微控制器，以防止“去封装”（译者注：de-capping, decapsulation）和侧信道攻击。 |  |  | ✓ | 4.0 |\n| **C.28** | 验证敏感导线不暴露在印刷电路板的外层。 |  |  | ✓ | 4.0 |\n| **C.29** | 验证芯片间的通信是加密的（如主板到子板的通信）。 |  |  | ✓ | 4.0 |\n| **C.30** | 验证设备使用代码签名并在执行前验证代码。 |  |  | ✓ | 4.0 |\n| **C.31** | 验证保存在内存中的敏感信息一旦不再需要，就立即用零值覆盖。 |  |  | ✓ | 4.0 |\n| **C.32** | 验证固件应用程序利用内核容器在应用程序之间进行隔离。 |  |  | ✓ | 4.0 |\n| **C.33** | 验证安全编译器标志，例如 -fPIE, -fstack-protector-all, -Wl,-z,noexecstack, -Wl,-z,noexecheap 已配置到固件构建中。 |  |  | ✓ | 4.0 |\n| **C.34** | 验证微型控制器是否配置了代码保护（如果适用）。 |  |  | ✓ | 4.0 |\n\n## 参考文献\n\n有关更多信息，请参阅：\n\n* [OWASP Internet of Things Top 10](https://owasp.org/www-pdf-archive/OWASP-IoT-Top-10-2018-final.pdf)\n* [OWASP Embedded Application Security Project](https://owasp.org/www-project-embedded-application-security/)\n* [OWASP Internet of Things Project](https://owasp.org/www-project-internet-of-things/)\n* [Trudy TCP Proxy Tool](https://github.com/praetorian-inc/trudy)\n", "timestamp": "2025-10-24T11:40:04.621049"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x01-Frontispiece.md", "content": "# Frontispiece\n\n## About the Standard\n\nThe Application Security Verification Standard is a list of application security requirements that architects, developers, testers, security professionals, tool vendors, and consumers can use to define, build, test, and verify secure applications.\n\n## Copyright and License\n\nVersion 5.0.0, May 2025\n\n![license](../images/license.png)\n\nCopyright © 2008-2025 The OWASP Foundation.\n\nThis document is released under the [Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/).\n\nFor any reuse or distribution, you must clearly communicate the license terms of this work to others.\n\n## Project Leads\n\n|                       |                  |\n|---------------------- |----------------- |\n| Elar Lang             | Josh C Grossman  |\n| Jim Manico            | Daniel Cuthbert  |\n\n## Working Group\n\n|                 |                   |                    |                  |\n|---------------- |------------------ |------------------- |----------------- |\n| Tobias Ahnoff   | Ralph Andalis     | Ryan Armstrong     | Gabriel Corona   |\n| Meghan Jacquot  | Shanni Prutchi    | Iman Sharafaldin   | Eden Yardeni     |\n\n## Other Major Contributors\n\n|                   |                   |\n|-------------------|-------------------|\n| Sjoerd Langkemper | Isaac Lewis       |\n| Mark Carney       | Sandro Gauci      |\n\n## Other Contributors and Reviewers\n\nWe have included a list of the other contributors in Appendix E.\n\nIf a credit is missing from the 5.x credit list, please log a ticket at GitHub to be recognized in future 5.x updates.\n\nThe Application Security Verification Standard builds on the work of those involved in ASVS 1.0 (2008) through 4.0 (2019). Much of the structure and many of the verification items that remain in ASVS today were originally written by Andrew van der Stock, Mike Boberski, Jeff Williams, and Dave Wichers, among numerous other contributors. Thank you to everyone who has contributed in the past. For a comprehensive list of earlier contributors, please consult each prior version.\n", "timestamp": "2025-10-24T11:40:06.472122"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x02-Preface.md", "content": "# Preface\n\nWelcome to the Application Security Verification Standard (ASVS) Version 5.0.\n\n## Introduction\n\nOriginally launched in 2008 through a global community collaboration, the ASVS defines a comprehensive set of security requirements for designing, developing, and testing modern web applications and services.\n\nFollowing the release of ASVS 4.0 in 2019 and its minor update (v4.0.3) in 2021, Version 5.0 represents a significant milestone—modernized to reflect the latest advances in software security.\n\nASVS 5.0 is the result of extensive contributions from project leaders, working group members, and the wider OWASP community to update and improve this important standard.\n\n## Principles behind version 5.0\n\nThis major revision has been developed with several key principles in mind:\n\n* Refined Scope and Focus: This version of the standard has been designed to align more directly with the foundational pillars in its name: Application, Security, Verification, and Standard. Requirements have been rewritten to emphasize the prevention of security flaws rather than mandating specific technical implementations. Requirement texts are intended to be self-explanatory, explaining why they exist.\n\n* Support for Documented Security Decisions: ASVS 5.0 introduces requirements for documenting key security decisions. This enhances traceability and supports context-sensitive implementations, allowing organizations to tailor their security posture to their specific needs and risks.\n\n* Updated Levels: While ASVS retains its three-tier model, the level definitions have evolved to make the ASVS easier to adopt. Level 1 is designed as the initial step to adopting the ASVS, providing the first layer of defense. Level 2 represents a comprehensive view of standard security practices, and Level 3 addresses advanced, high-assurance requirements.\n\n* Restructured and Expanded Content: ASVS 5.0 includes approximately 350 requirements across 17 chapters. Chapters have been reorganized for clarity and usability. A two-way mapping between v4.0 and v5.0 is provided to facilitate migration.\n\n## Looking ahead\n\nJust as securing an application is never truly finished, neither is the ASVS. Although Version 5.0 is a major release, development continues. This release allows the wider community to benefit from the improvements and additions which have been accumulated but also lays the groundwork for future enhancements. This could include community-driven efforts to create implementation and verification guidance built on top of the core requirement set.\n\nASVS 5.0 is designed to serve as a reliable foundation for secure software development. The community is invited to adopt, contribute, and build upon this standard to collectively advance the state of application security.\n", "timestamp": "2025-10-24T11:40:06.542580"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x03-What-is-the-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x03-What-is-the-ASVS.md", "content": "# What is the ASVS?\n\nThe Application Security Verification Standard (ASVS) defines security requirements for web applications and services, and it is a valuable resource for anyone aiming to design, develop, and maintain secure applications or evaluate their security.\n\nThis chapter outlines the essential aspects of using the ASVS, including its scope, the structure of its priority-based levels, and the primary use cases for the standard.\n\n## Scope of the ASVS\n\nThe scope of the ASVS is defined by its name: Application, Security, Verification, and Standard. It establishes which requirements are included or excluded, with the overarching goal of identifying the security principles that must be achieved. The scope also considers documentation requirements, which serve as the foundation for implementation requirements.\n\nThere is no such thing as scope for attackers. Therefore, ASVS requirements should be evaluated alongside guidance for other aspects of the application lifecycle, including CI/CD processes, hosting, and operational activities.\n\n### Application\n\nASVS defines an \"application\" as the software product being developed, into which security controls must be integrated. ASVS does not prescribe development lifecycle activities or dictate how the application should be built via a CI/CD pipeline; instead, it specifies the security outcomes that must be achieved within the product itself.\n\nComponents that serve, modify, or validate HTTP traffic, such as Web Application Firewalls (WAFs), load balancers, or proxies, may be considered part of the application for those specific purposes, as some security controls depend directly on them or can be implemented through them. These components should be considered for requirements related to cached responses, rate limiting, or restricting incoming and outgoing connections based on source and destination.\n\nConversely, ASVS generally excludes requirements that are not directly relevant to the application or where configuration is outside the application's responsibility. For example, DNS issues are typically managed by a separate team or function.\n\nSimilarly, while the application is responsible for how it consumes input and produces output, if an external process interacts with the application or its data, it is considered out of scope for ASVS. For instance, backing up the application or its data is usually the responsibility of an external process and is not controlled by the application or its developers.\n\n### Security\n\nEvery requirement must have a demonstrable impact on security. The absence of a requirement must result in a less secure application, and implementing the requirement must reduce either the likelihood or the impact of a security risk.\n\nAll other considerations, such as functional aspects, code style, or policy requirements, are out of scope.\n\n### Verification\n\nThe requirement must be verifiable, and the verification must result in a \"fail\" or \"pass\" decision.\n\n### Standard\n\nThe ASVS is designed to be a collection of security requirements to be implemented to comply with the standard. This means that requirements are limited to defining the security goal to achieve that. Other related information can be built on top of ASVS or linked via mappings.\n\nSpecifically, OWASP has many projects, and the ASVS deliberately avoids overlapping with the content in other projects. For example, developers may have a question, \"how do I implement a particular requirement in my particular technology or environment,\" and this should be covered by the Cheat Sheet Series project. Verifiers may have a question \"how do I test this requirement in this environment,\" and this should be covered by the Web Security Testing Guide project.\n\nWhilst the ASVS is not just intended for security experts to use, it does expect the reader to have technical knowledge to understand the content or the ability to research particular concepts.\n\n### Requirement\n\nThe word requirement is used specifically in the ASVS as it describes what must be achieved to satisfy it. The ASVS only contains requirements (must) and does not contain recommendations (should) as the main condition.\n\nIn other words, recommendations, whether they are just one of many possible options to solve a problem or code style considerations, do not satisfy the definition to be a requirement.\n\nASVS requirements are intended to address specific security principles without being too implementation or technology-specific, at the same time, being self-explanatory as to why they exist. This also means that requirements are not built around a particular verification method or implementation.\n\n### Documented security decisions\n\nIn software security, planning security design and the mechanisms to be used early on will lead to a more consistent and reliable implementation in the finished product or feature.\n\nAdditionally, for certain requirements, implementation will be complicated and very specific to an application's needs. Common examples include permissions, input validation, and protective controls around different levels of sensitive data.\n\nTo account for this, rather than sweeping statements like \"all data must be encrypted\" or trying to cover every possible use case in a requirement, documentation requirements were included which mandate that the application developer's approach and configuration to these sorts of controls must be documented. This can then be reviewed for appropriateness and then the actual implementation can be compared to the documentation to assess whether the implementation matches expectations.\n\nThese requirements are intended to document the decisions which the organization developing the application has taken regarding how to implement certain security requirements.\n\nDocumentation requirements are always in the first section of a chapter (although not every chapter has them) and always have a related implementation requirement where the decisions that are documented should actually be put into place. The point here is that verifying that the documentation is in place and that the actual implementation are two separate activities.\n\nThere are two key drivers for including these requirements. The first driver is that a security requirement will often involve enforcing rules e.g., what kind of file types are allowed to be uploaded, what business controls should be enforced, what are the allowed characters for a particular field. These rules will differ for every application, and therefore, the ASVS cannot prescriptively define what they should be, nor will a cheat sheet or more detailed response help in this case. Similarly, without these decisions being documented, it will not be possible to perform verification of the requirements that implement these decisions.\n\nThe second driver is that for certain requirements, it is important to provide an application development with flexibility regarding how to address particular security challenges. For example, in previous ASVS versions, session timeout rules were very prescriptive. Practically speaking, many applications, especially those that are consumer-facing, have much more relaxed rules and prefer to implement other mitigation controls instead. Documentation requirements, therefore, explicitly allow for flexibility around this.\n\nClearly, it is not expected that individual developers will be making and documenting these decisions but rather the organization as a whole will be taking those decisions and making sure that they are communicated to developers who then make sure to follow them.\n\nProviding developers with specifications and designs for new features and functionality is a standard part of software development. Similarly, developers are expected to use common components and user interface mechanisms rather than just making their own decisions each time. As such, extending this to security should not be seen as surprising or controversial.\n\nThere is also flexibility around how to achieve this. Security decisions might be documented in a literal document, which developers are expected to refer to. Alternatively, security decisions could be documented and implemented in a common code library that all developers are mandated to use. In both cases, the desired result is achieved.\n\n## Application Security Verification Levels\n\nThe ASVS defines three security verification levels, with each level increasing in depth and complexity. The general aim is for organizations to start with the first level to address the most critical security concerns, and then move up to the higher levels according to the organization and application needs. Levels may be presented as L1, L2, and L3 in the document and in requirement texts.\n\nEach ASVS level indicates the security requirements that are required to achieve from that level, with the higher remaining level requirements as recommendations.\n\nIn order to avoid duplicate requirements or requirements that are no longer relevant at higher levels, some requirements apply to a particular level but have more stringent conditions for higher levels.\n\n### Level evaluation\n\nLevels are defined by priority-based evaluation of each requirement based on experience implementing and testing security requirements. The main focus is on comparing risk reduction with the effort to implement the requirement. Another key factor is to keep a low barrier to entry.\n\nRisk reduction considers the extent to which the requirement reduces the level of security risk within the application, taking into account the classic Confidentiality, Integrity, and Availability impact factors as well as considering whether this is a primary layer of defense or whether it would be considered defense in depth.\n\nThe rigorous discussions around both the criteria and the leveling decisions have resulted in an allocation which should hold true for the vast majority of cases, whilst accepting that it may not be a 100% fit for every situation. This means that in certain cases, organizations may wish to prioritize requirements from a higher level earlier on based on their own specific risk considerations.\n\nThe types of requirements in each level could be characterized as follows.\n\n### Level 1\n\nThis level contains the minimum requirements to consider when securing an application and represents a critical starting point. This level contains around 20% of the ASVS requirements. The goal for this level is to have as few requirements as possible, to decrease the barrier to entry.\n\nThese requirements are generally critical or basic, first-layer of defense requirements for preventing common attacks that do not require other vulnerabilities or preconditions to be exploitable.\n\nIn addition to the first layer of defense requirements, some requirements have less of an impact at higher levels, such as requirements related to passwords. Those are more important for Level 1, as from higher levels, the multi-factor authentication requirements become relevant.\n\nLevel 1 is not necessarily penetration testable by an external tester without internal access to documentation or code (such as \"black box\" testing), although the lower number of requirements should make it easier to verify.\n\n### Level 2\n\nMost applications should be striving to achieve this level of security. Around 50% of the requirements in the ASVS are L2 meaning that an application needs to implement around 70% of the requirements in the ASVS (all of the L1 and L2 requirements) in order to comply with L2.\n\nThese requirements generally relate to either less common attacks or more complicated protections against common attacks. They may still be a first layer of defense, or they may require certain preconditions for the attack to be successful.\n\n### Level 3\n\nThis level should be the goal for applications looking to demonstrate the highest levels of security and provides the final ~30% of requirements to comply with.\n\nRequirements in this section are generally either defense-in-depth mechanisms or other useful but hard-to-implement controls.\n\n### Which level to achieve\n\nThe priority-based levels are intended to provide a reflection of the application security maturity of the organization and the application. Rather than the ASVS prescriptively stating what level an application should be at, an organization should analyze its risks and decide what level it believes it should be at, depending on the sensitivity of the application and of course, the expectations of the application's users.\n\nFor example, an early-stage startup that is only collecting limited sensitive data may decide to focus on Level 1 for its initial security goals, but a bank may have difficulty justifying anything less than Level 3 to its customers for its online banking application.\n\n## How to use the ASVS\n\n### The structure of the ASVS\n\nThe ASVS is made up of a total of around 350 requirements which are divided into 17 chapters, each of which is further divided into sections.\n\nThe aim of the chapter and section division is to simplify choosing or filtering out chapters and sections based on the what is relevant for the application. For example, for a machine-to-machine API, the requirements in chapter V3 related to web frontends will not be relevant. If there is no use of OAuth or WebRTC, then those chapters can be ignored as well.\n\n### Release strategy\n\nASVS releases follow the pattern \"Major.Minor.Patch\" and the numbers provide information on what has changed within the release. In a major release, the first number will change, in a minor release, the second number will change, and in a patch release, the third number will change.\n\n* Major release - Full reorganization, almost everything may have changed, including requirement numbers. Reevaluation for compliance will be necessary (for example, 4.0.3 -> 5.0.0).\n* Minor release - Requirements may be added or removed, but overall numbering will stay the same. Reevaluation for compliance will be necessary, but should be easier (for example, 5.0.0 -> 5.1.0).\n* Patch release - Requirements may be removed (for example, if they are duplicates or outdated) or made less stringent, but an application that complied with the previous release will comply with the patch release as well (for example, 5.0.0 -> 5.0.1).\n\nThe above specifically relates to the requirements in the ASVS. Changes to surrounding text and other content such as the appendices will not be considered to be a breaking change.\n\n### Flexibility with the ASVS\n\nSeveral of the points described above, such as documentation requirements and the levels mechanism, provide the ability to use the ASVS in a more flexible and organization-specific way.\n\nAdditionally, organizations are strongly encouraged to create an organization- or domain-specific fork that adjusts requirements based on the specific characteristics and risk levels of their applications. However, it is important to maintain traceability so that passing requirement 4.1.1 means the same across all versions.\n\nIdeally, each organization should create its own tailored ASVS, omitting irrelevant sections (e.g., GraphQL, WebSockets, SOAP, if unused). An organization-specific ASVS version or supplement is also a good place to provide organization-specific implementation guidance, detailing libraries or resources to use when complying with requirements.\n\n### How to Reference ASVS Requirements\n\nEach requirement has an identifier in the format `<chapter>.<section>.<requirement>`, where each element is a number. For example, `1.11.3`.\n\n* The `<chapter>` value corresponds to the chapter from which the requirement comes; for example, all `1.#.#` requirements are from the 'Encoding and Sanitization' chapter.\n* The `<section>` value corresponds to the section within that chapter where the requirement appears, for example: all `1.2.#` requirements are in the 'Injection Prevention' section of the 'Encoding and Sanitization' chapter.\n* The `<requirement>` value identifies the specific requirement within the chapter and section, for example, `1.2.5` which as of version 5.0.0 of this standard is:\n\n> Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.\n\nSince the identifiers may change between versions of the standard, it is preferable for other documents, reports, or tools to use the following format: `v<version>-<chapter>.<section>.<requirement>`, where: 'version' is the ASVS version tag. For example: `v5.0.0-1.2.5` would be understood to mean specifically the 5th requirement in the 'Injection Prevention' section of the 'Encoding and Sanitization' chapter from version 5.0.0. (This could be summarized as `v<version>-<requirement_identifier>`.)\n\nNote: The `v` preceding the version number in the format should always be lowercase.\n\nIf identifiers are used without including the `v<version>` element then they should be assumed to refer to the latest Application Security Verification Standard content. As the standard grows and changes this becomes problematic, which is why writers or developers should include the version element.\n\nASVS requirement lists are made available in CSV, JSON, and other formats which may be useful for reference or programmatic use.\n\n### Forking the ASVS\n\nOrganizations can benefit from adopting ASVS by choosing one of the three levels or by creating a domain-specific fork that adjusts requirements per application risk level. This type of fork is encouraged, provided that it maintains traceability so that passing requirement 4.1.1 means the same across all versions.\n\nIdeally, each organization should create its own tailored ASVS, omitting irrelevant sections (e.g., GraphQL, Websockets, SOAP, if unused). Forking should start with ASVS Level 1 as a baseline, advancing to Levels 2 or 3 based on the application’s risk.\n\n## Use cases for the ASVS\n\nThe ASVS can be used to assess the security of an application and this is explored in more depth in the next chapter. However, several other potential uses for the ASVS (or a forked version) have been identified.\n\n### As Detailed Security Architecture Guidance\n\nOne of the more common uses for the Application Security Verification Standard is as a resource for security architects. There are limited resources available for how to build a secure application architecture, especially with modern applications. ASVS can be used to fill in those gaps by allowing security architects to choose better controls for common problems, such as data protection patterns and input validation strategies. The architecture and documentation requirements will be particularly useful for this.\n\n### As a Specialized Secure Coding Reference\n\nThe ASVS can be used as a basis for preparing a secure coding reference during application development, helping developers to make sure that they keep security in mind when they build software. Whilst the ASVS can be the base, organizations should prepare their own specific guidance which is clear and unified and ideally be prepared based on guidance from security engineers or security architects. As an extension to this, organizations are encouraged wherever possible to prepare approved security mechanisms and libraries that can be referenced in the guidance and used by developers.\n\n### As a Guide for Automated Unit and Integration Tests\n\nThe ASVS is designed to be highly testable. Some verifications will be technical where as other requirements (such as the architectural and documentation requirements) may require documentation or architecture review. By building unit and integration tests that test and fuzz for specific and relevant abuse cases related to the requirements that are verifiable by technical means, it should be easier to check that these controls are operating correctly on each build. For example, additional tests can be crafted for the test suite for a login controller, testing the username parameter for common default usernames, account enumeration, brute forcing, LDAP and SQL injection, and XSS. Similarly, a test on the password parameter should include common passwords, password length, null byte injection, removing the parameter, XSS, and more.\n\n### For Secure Development Training\n\nASVS can also be used to define the characteristics of secure software. Many “secure coding” courses are simply ethical hacking courses with a light smear of coding tips. This may not necessarily help developers to write more secure code. Instead, secure development courses can use the ASVS with a strong focus on the positive mechanisms found in the ASVS, rather than the Top 10 negative things not to do. The ASVS structure also provides a logical structure for walking through the different topics when securing an application.\n\n### As a Framework for Guiding the Procurement of Secure Software\n\nThe ASVS is a great framework to help with secure software procurement or procurement of custom development services. The buyer can simply set a requirement that the software they wish to procure must be developed at ASVS level X, and request that the seller proves that the software satisfies ASVS level X.\n\n## Applying ASVS in Practice\n\nDifferent threats have different motivations. Some industries have unique information and technology assets and domain-specific regulatory compliance requirements.\n\nOrganizations are strongly encouraged to look deeply at their unique risk characteristics based on the nature of their business, and based upon that risk and business requirements determine the appropriate ASVS level.\n", "timestamp": "2025-10-24T11:40:06.624776"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x04-Assessment_and_Certification.md", "content": "# Assessment and Certification\n\n## OWASP's Stance on ASVS Certifications and Trust Marks\n\nOWASP, as a vendor-neutral nonprofit, does not certify any vendors, verifiers, or software. Any assurance, trust mark, or certification claiming ASVS compliance is not officially endorsed by OWASP, so organizations should be cautious of third-party claims of ASVS certification.\n\nOrganizations may offer assurance services, provided they do not claim official OWASP certification.\n\n## How to Verify ASVS Compliance\n\nThe ASVS is deliberately not prescriptive about exactly how to verify compliance at the level of a testing guide. However, it is important to highlight some key points.\n\n### Verification reporting\n\nTraditional penetration testing reports issues “by exception,” only listing failures. However, an ASVS certification report should include scope, a summary of all requirements checked, the requirements where exceptions were noted, and guidance on resolving issues. Some requirements may be non-applicable (e.g., session management in stateless APIs), and this must be noted in the report.\n\n### Scope of Verification\n\nAn organization developing an application will generally not implement all requirements, as some may be irrelevant or less significant based on the functionality of the application. The verifier should make the scope of the verification clear including which Level the organization is attempting to achieve and which requirements were included. This should be from the perspective of what was included rather than what was not included. They should also provide an opinion on the rationale of excluding the requirements which haven't been implemented.\n\nThis should allow the consumer of a verification report to understand the context of the verification and make an informed decision about the level of trust they can place in the application.\n\nCertifying organizations can choose their testing methods but should disclose them in the report and this should ideally be repeatable. Different methods, like manual penetration tests or source code analysis, may be used to verify aspects such as input validation, depending on the application and requirements.\n\n### Verification Mechanisms\n\nThere are a number of different techniques which may be needed to verify specific ASVS requirements. Aside from penetration testing (using valid credentials to get full application coverage), verifying ASVS requirements may require access to documentation, source code, configuration, and the people involved in the development process. Especially for verifying L2 and L3 requirements. It is standard practice to provide robust evidence of findings with detailed documentation, which may include work papers, screenshots, scripts, and testing logs. Merely running an automated tool without thorough testing is insufficient for certification, as each requirement must be verifiably tested.\n\nThe use of automation to verify ASVS requirements is a topic that is constantly of interest. It is therefore important to clarify some points related to automated and black box testing.\n\n#### The Role of Automated Security Testing Tools\n\nWhen automated security testing tools such as Dynamic and Static Application Security Testing tools (DAST and SAST) are correctly implemented in the build pipeline, they may be able to identify some security issues that should never exist. However, without careful configuration and tuning they will not provide the required coverage and the level of noise will prevent real security issues from being identified and mitigated.\n\nWhilst this may provide coverage of some of the more basic and straightforward technical requirements such as those relating to output encoding or sanitization, it is critical to note that these tools will be unable entirely to verify many of the more complicated ASVS requirements or those that relate to business logic and access control.\n\nFor less straightforward requirements, it is likely that automation can still be utilized but application specific verifications will need to be written to achieve this. These may be similar to unit and integration tests that the organization may already be using. It may therefore be possible to use this existing test automation infrastructure to write these ASVS specific tests. Whilst doing this will require short term investment, the long term benefits being able to continually verify these ASVS requirements will be significant.\n\nIn summary, testable using automation != running an off the shelf tool.\n\n#### The Role of Penetration Testing\n\nWhilst L1 in version 4.0 was optimized for \"black box\" (no documentation and no source) testing to occur, even then the standard was clear that it is not an effective assurance activity and should be actively discouraged.\n\nTesting without access to necessary additional information is an inefficient and ineffective mechanism for security verification, as it misses out on the possibility of reviewing the source, identifying threats and missing controls, and performing a far more thorough test in a shorter timeframe.\n\nIt is strongly encouraged to perform documentation or source code-led (hybrid) penetration testing, which have full access to the application developers and the application's documentation, rather than traditional penetration tests. This will certainly be necessary in order to verify many of the ASVS requirements.\n", "timestamp": "2025-10-24T11:40:06.691623"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x05-For-Users-Of-4.0.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x05-For-Users-Of-4.0.md", "content": "# Changes Compared to v4.x\n\n## Introduction\n\nUsers familiar with version 4.x of the standard may find it helpful to review the key changes introduced in version 5.0, including updates in content, scope, and underlying philosophy.\n\nOf the 286 requirements in version 4.0.3, only 11 remain unchanged, while 15 have undergone minor grammatical adjustments without altering their meaning. In total 109 requirements (38%) are no longer separate requirements in version 5.0 with 50 simply being deleted, 28 removed as duplicates and 31 merged into other requirements. The rest have been revised in some way. Even requirements that were not substantively modified have different identifiers due to reordering or restructuring.\n\nTo facilitate adoption of version 5.0, mapping documents are provided to help users trace how requirements from version 4.x correspond to those in version 5.0. These mappings are not tied to release versioning and may be updated or clarified as needed.\n\n## Requirement Philosophy\n\n### Scope and Focus\n\nVersion 4.x included requirements that did not align with the intended scope of the standard; these have been removed. Requirements that did not meet the scope criteria for 5.0 or were not verifiable have also been excluded.\n\n### Emphasis on Security Goals Over Mechanisms\n\nIn version 4.x, many requirements focused on specific mechanisms rather than the underlying security objectives. In version 5.0, requirements are centered on security goals, referencing particular mechanisms only when they are the sole practical solution, or providing them as examples or supplementary guidance.\n\nThis approach recognizes that multiple methods may exist to achieve a given security objective, and avoids unnecessary prescriptiveness that could limit organizational flexibility.\n\nAdditionally, requirements addressing the same security concern have been consolidated where appropriate.\n\n### Documented Security Decisions\n\nWhile the concept of documented security decisions may appear new in version 5.0, it is an evolution of earlier requirements related to policy application and threat modeling in version 4.0. Previously, some requirements implicitly demanded analysis to inform the implementation of security controls, such as determining permitted network connections.\n\nTo ensure that necessary information is available for implementation and verification, these expectations are now explicitly defined as documentation requirements, making them clear, actionable, and verifiable.\n\n## Structural Changes and New Chapters\n\nSeveral chapters in version 5.0 introduce entirely new content:\n\n* OAuth and OIDC – Given the widespread adoption of these protocols for access delegation and single sign-on, dedicated requirements have been added to address the diverse scenarios developers may encounter. This area may eventually evolve into a standalone standard, similar to the treatment of Mobile and IoT requirements in previous versions.\n* WebRTC – As this technology gains popularity, its unique security considerations and challenges are now addressed in a dedicated section.\n\nEfforts have also been made to ensure that chapters and sections are organized around coherent sets of related requirements.\n\nThis restructuring has led to the creation of additional chapters:\n\n* Self-contained Tokens – Formerly grouped under session management, self-contained tokens are now recognized as a distinct mechanism and a foundational element for stateless communication (such as in OAuth and OIDC). Due to their unique security implications, they are addressed in a dedicated chapter, with some new requirements introduced in version 5.x.\n* Web Frontend Security – With the increasing complexity of browser-based applications and the rise of API-only architectures, frontend security requirements have been separated into their own chapter.\n* Secure Coding and Architecture – New requirements addressing general security practices that did not fit within existing chapters have been grouped here.\n\nOther organizational changes in version 5.0 were made to clarify intent. For example, input validation requirements were moved alongside business logic, reflecting their role in enforcing business rules, rather than being grouped with sanitization and encoding.\n\nThe former V1 Architecture chapter has been removed. Its initial section contained requirements that were out of scope, while subsequent sections have been redistributed to relevant chapters, with requirements deduplicated and clarified as necessary.\n\n## Removal of Direct Mappings to Other Standards\n\nDirect mappings to other standards have been removed from the main body of the standard. The aim is to prepare a mapping with the OWASP Common Requirement Enumeration (CRE) project, which in turn will link ASVS to a range of OWASP projects and external standards.\n\nDirect mappings to CWE and NIST are no longer maintained, as explained below.\n\n### Reduced Coupling with NIST Digital Identity Guidelines\n\nThe NIST [Digital Identity Guidelines (SP 800-63)](https://pages.nist.gov/800-63-3/) have long served as a reference for authentication and authorization controls. In version 4.x, certain chapters were closely aligned with NIST's structure and terminology.\n\nWhile these guidelines remain an important reference, strict alignment introduced challenges, including less widely recognized terminology, duplication of similar requirements, and incomplete mappings. Version 5.0 moves away from this approach to improve clarity and relevance.\n\n### Moving Away from Common Weakness Enumeration (CWE)\n\nThe [Common Weakness Enumeration (CWE)](https://cwe.mitre.org/) provides a useful taxonomy of software security weaknesses. However, challenges such as category-only CWEs, difficulties in mapping requirements to a single CWE, and the presence of imprecise mappings in version 4.x have led to the decision to discontinue direct CWE mappings in version 5.0.\n\n## Rethinking Level Definitions\n\nVersion 4.x described the levels as L1 (\"Minimum\"), L2 (\"Standard\"), and L3 (\"Advanced\"), with the implication that all applications handling sensitive data should meet at least L2.\n\nVersion 5.0 addresses several issues with this approach which are described in the following paragraphs.\n\nAs a practical matter, whereas version 4.x used tick marks for level indicators, 5.x uses a simple number on all formats of the standard including markdown, PDF, DOCX, CSV, JSON and XML. For backwards compatibility, legacy versions of the CSV, JSON and XML outputs which still use tick marks are also generated.\n\n### Easier Entry Level\n\nFeedback indicated that the large number of Level 1 requirements (~120), combined with its designation as the \"minimum\" level that is not good enough for most applications, discouraged adoption. Version 5.0 aims to lower this barrier by defining Level 1 primarily around first-layer defense requirements, resulting in clearer and fewer requirements at that level. To demonstrate this numerically, in v4.0.3 there were 128 L1 requirements out of a total of 278 requirements, representing 46%. In 5.0.0 there are 70 L1 requirements out of a total of 345 requirements, representing 20%.\n\n### The Fallacy of Testability\n\nA key factor in selecting controls for Level 1 in version 4.x was their suitability for assessment through \"black box\" external penetration testing. However, this approach was not fully aligned with the intent of Level 1 as the minimum set of security controls. Some users argued that Level 1 was insufficient for securing applications, while others found it too difficult to test.\n\nRelying on testability as a criterion is both relative and, at times, misleading. The fact that a requirement is testable does not guarantee that it can be tested in an automated or straightforward manner. Moreover, the most easily testable requirements are not always those with the greatest security impact or the simplest to implement.\n\nAs such, in version 5.0, the level decisions were made primarily based on risk reduction and also keeping in mind the effort to implement.\n\n### Not Just About Risk\n\nThe use of prescriptive, risk-based levels that mandate a specific level for certain applications has proven to be overly rigid. In practice, the prioritization and implementation of security controls depend on multiple factors, including both risk reduction and the effort required for implementation.\n\nTherefore, organizations are encouraged to achieve the level that they feel like they should be achieving based on their maturity and the message they want to send to their users.\n", "timestamp": "2025-10-24T11:40:06.822590"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x10-V1-Encoding-and-Sanitization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x10-V1-Encoding-and-Sanitization.md", "content": "# V1 Encoding and Sanitization\n\n## Control Objective\n\nThis chapter addresses the most common web application security weaknesses related to the unsafe processing of untrusted data. Such weaknesses can result in various technical vulnerabilities, where untrusted data is interpreted according to the syntax rules of the relevant interpreter.\n\nFor modern web applications, it is always best to use safer APIs, such as parameterized queries, auto-escaping, or templating frameworks. Otherwise, carefully performed output encoding, escaping, or sanitization becomes critical to the application's security.\n\nInput validation serves as a defense-in-depth mechanism to protect against unexpected or dangerous content. However, since its primary purpose is to ensure that incoming content matches functional and business expectations, requirements related to this can be found in the \"Validation and Business Logic\" chapter.\n\n## V1.1 Encoding and Sanitization Architecture\n\nIn the sections below, syntax-specific or interpreter-specific requirements for safely processing unsafe content to avoid security vulnerabilities are provided. The requirements in this section cover the order in which this processing should occur and where it should take place. They also aim to ensure that whenever data is stored, it remains in its original state and is not stored in an encoded or escaped form (e.g., HTML encoding), to prevent double encoding issues.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **1.1.1** | Verify that input is decoded or unescaped into a canonical form only once, it is only decoded when encoded data in that form is expected, and that this is done before processing the input further, for example it is not performed after input validation or sanitization. | 2 |\n| **1.1.2** | Verify that the application performs output encoding and escaping either as a final step before being used by the interpreter for which it is intended or by the interpreter itself. | 2 |\n\n## V1.2 Injection Prevention\n\nOutput encoding or escaping, performed close to or adjacent to a potentially dangerous context, is critical to the security of any application. Typically, output encoding and escaping are not persisted, but are instead used to render output safe for immediate use in the appropriate interpreter. Attempting to perform this too early may result in malformed content or render the encoding or escaping ineffective.\n\nIn many cases, software libraries include safe or safer functions that perform this automatically, although it is necessary to ensure that they are correct for the current context.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **1.2.1** | Verify that output encoding for an HTTP response, HTML document, or XML document is relevant for the context required, such as encoding the relevant characters for HTML elements, HTML attributes, HTML comments, CSS, or HTTP header fields, to avoid changing the message or document structure. | 1 |\n| **1.2.2** | Verify that when dynamically building URLs, untrusted data is encoded according to its context (e.g., URL encoding or base64url encoding for query or path parameters). Ensure that only safe URL protocols are permitted (e.g., disallow javascript: or data:). | 1 |\n| **1.2.3** | Verify that output encoding or escaping is used when dynamically building JavaScript content (including JSON), to avoid changing the message or document structure (to avoid JavaScript and JSON injection). | 1 |\n| **1.2.4** | Verify that data selection or database queries (e.g., SQL, HQL, NoSQL, Cypher) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from SQL Injection and other database injection attacks. This is also relevant when writing stored procedures. | 1 |\n| **1.2.5** | Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding. | 1 |\n| **1.2.6** | Verify that the application protects against LDAP injection vulnerabilities, or that specific security controls to prevent LDAP injection have been implemented. | 2 |\n| **1.2.7** | Verify that the application is protected against XPath injection attacks by using query parameterization or precompiled queries. | 2 |\n| **1.2.8** | Verify that LaTeX processors are configured securely (such as not using the \"--shell-escape\" flag) and an allowlist of commands is used to prevent LaTeX injection attacks. | 2 |\n| **1.2.9** | Verify that the application escapes special characters in regular expressions (typically using a backslash) to prevent them from being misinterpreted as metacharacters. | 2 |\n| **1.2.10** | Verify that the application is protected against CSV and Formula Injection. The application must follow the escaping rules defined in RFC 4180 sections 2.6 and 2.7 when exporting CSV content. Additionally, when exporting to CSV or other spreadsheet formats (such as XLS, XLSX, or ODF), special characters (including '=', '+', '-', '@', '\\t' (tab), and '\\0' (null character)) must be escaped with a single quote if they appear as the first character in a field value. | 3 |\n\nNote: Using parameterized queries or escaping SQL is not always sufficient. Query parts such as table and column names (including \"ORDER BY\" column names) cannot be escaped. Including escaped user-supplied data in these fields results in failed queries or SQL injection.\n\n## V1.3 Sanitization\n\nThe ideal protection against using untrusted content in an unsafe context is to use context-specific encoding or escaping, which maintains the same semantic meaning of the unsafe content but renders it safe for use in that particular context, as discussed in more detail in the previous section.\n\nWhere this is not possible, sanitization becomes necessary, removing potentially dangerous characters or content. In some cases, this may change the semantic meaning of the input, but for security reasons, there may be no alternative.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **1.3.1** | Verify that all untrusted HTML input from WYSIWYG editors or similar is sanitized using a well-known and secure HTML sanitization library or framework feature. | 1 |\n| **1.3.2** | Verify that the application avoids the use of eval() or other dynamic code execution features such as Spring Expression Language (SpEL). Where there is no alternative, any user input being included must be sanitized before being executed. | 1 |\n| **1.3.3** | Verify that data being passed to a potentially dangerous context is sanitized beforehand to enforce safety measures, such as only allowing characters which are safe for this context and trimming input which is too long. | 2 |\n| **1.3.4** | Verify that user-supplied Scalable Vector Graphics (SVG) scriptable content is validated or sanitized to contain only tags and attributes (such as draw graphics) that are safe for the application, e.g., do not contain scripts and foreignObject. | 2 |\n| **1.3.5** | Verify that the application sanitizes or disables user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar. | 2 |\n| **1.3.6** | Verify that the application protects against Server-side Request Forgery (SSRF) attacks, by validating untrusted data against an allowlist of protocols, domains, paths and ports and sanitizing potentially dangerous characters before using the data to call another service. | 2 |\n| **1.3.7** | Verify that the application protects against template injection attacks by not allowing templates to be built based on untrusted input. Where there is no alternative, any untrusted input being included dynamically during template creation must be sanitized or strictly validated. | 2 |\n| **1.3.8** | Verify that the application appropriately sanitizes untrusted input before use in Java Naming and Directory Interface (JNDI) queries and that JNDI is configured securely to prevent JNDI injection attacks. | 2 |\n| **1.3.9** | Verify that the application sanitizes content before it is sent to memcache to prevent injection attacks. | 2 |\n| **1.3.10** | Verify that format strings which might resolve in an unexpected or malicious way when used are sanitized before being processed. | 2 |\n| **1.3.11** | Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection. | 2 |\n| **1.3.12** | Verify that regular expressions are free from elements causing exponential backtracking, and ensure untrusted input is sanitized to mitigate ReDoS or Runaway Regex attacks. | 3 |\n\n## V1.4 Memory, String, and Unmanaged Code\n\nThe following requirements address risks associated with unsafe memory use, which generally apply when the application uses a systems language or unmanaged code.\n\nIn some cases, it may be possible to achieve this by setting compiler flags that enable buffer overflow protections and warnings, including stack randomization and data execution prevention, and that break the build if unsafe pointer, memory, format string, integer, or string operations are found.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **1.4.1** | Verify that the application uses memory-safe string, safer memory copy and pointer arithmetic to detect or prevent stack, buffer, or heap overflows. | 2 |\n| **1.4.2** | Verify that sign, range, and input validation techniques are used to prevent integer overflows. | 2 |\n| **1.4.3** | Verify that dynamically allocated memory and resources are released, and that references or pointers to freed memory are removed or set to null to prevent dangling pointers and use-after-free vulnerabilities. | 2 |\n\n## V1.5 Safe Deserialization\n\nThe conversion of data from a stored or transmitted representation into actual application objects (deserialization) has historically been the cause of various code injection vulnerabilities. It is important to perform this process carefully and safely to avoid these types of issues.\n\nIn particular, certain methods of deserialization have been identified by programming language or framework documentation as insecure and cannot be made safe with untrusted data. For each mechanism in use, careful due diligence should be performed.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **1.5.1** | Verify that the application configures XML parsers to use a restrictive configuration and that unsafe features such as resolving external entities are disabled to prevent XML eXternal Entity (XXE) attacks. | 1 |\n| **1.5.2** | Verify that deserialization of untrusted data enforces safe input handling, such as using an allowlist of object types or restricting client-defined object types, to prevent deserialization attacks. Deserialization mechanisms that are explicitly defined as insecure must not be used with untrusted input. | 2 |\n| **1.5.3** | Verify that different parsers used in the application for the same data type (e.g., JSON parsers, XML parsers, URL parsers), perform parsing in a consistent way and use the same character encoding mechanism to avoid issues such as JSON Interoperability vulnerabilities or different URI or file parsing behavior being exploited in Remote File Inclusion (RFI) or Server-side Request Forgery (SSRF) attacks. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n* [OWASP Web Security Testing Guide: Client-Side Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files](https://datatracker.ietf.org/doc/html/rfc4180#section-2)\n\nFor more information, specifically on deserialization or parsing issues, please see:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [An Exploration of JSON Interoperability Vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)\n* [Orange Tsai - A New Era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:06.921484"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x11-V2-Validation-and-Business-Logic.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x11-V2-Validation-and-Business-Logic.md", "content": "# V2 Validation and Business Logic\n\n## Control Objective\n\nThis chapter aims to ensure that a verified application meets the following high-level goals:\n\n* Input received by the application matches business or functional expectations.\n* The business logic flow is sequential, processed in order, and cannot be bypassed.\n* Business logic includes limits and controls to detect and prevent automated attacks, such as continuous small funds transfers or adding a million friends one at a time.\n* High-value business logic flows have considered abuse cases and malicious actors, and have protections against spoofing, tampering, information disclosure, and elevation of privilege attacks.\n\n## V2.1 Validation and Business Logic Documentation\n\nValidation and business logic documentation should clearly define business logic limits, validation rules, and contextual consistency of combined data items, so it is clear what needs to be implemented in the application.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **2.1.1** | Verify that the application's documentation defines input validation rules for how to check the validity of data items against an expected structure. This could be common data formats such as credit card numbers, email addresses, telephone numbers, or it could be an internal data format. | 1 |\n| **2.1.2** | Verify that the application's documentation defines how to validate the logical and contextual consistency of combined data items, such as checking that suburb and ZIP code match. | 2 |\n| **2.1.3** | Verify that expectations for business logic limits and validations are documented, including both per-user and globally across the application. | 2 |\n\n## V2.2 Input Validation\n\nEffective input validation controls enforce business or functional expectations around the type of data the application expects to receive. This ensures good data quality and reduces the attack surface. However, it does not remove or replace the need to use correct encoding, parameterization, or sanitization when using the data in another component or for presenting it for output.\n\nIn this context, \"input\" could come from a wide variety of sources, including HTML form fields, REST requests, URL parameters, HTTP header fields, cookies, files on disk, databases, and external APIs.\n\nA business logic control might check that a particular input is a number less than 100. A functional expectation might check that a number is below a certain threshold, as that number controls how many times a particular loop will take place, and a high number could lead to excessive processing and a potential denial of service condition.\n\nWhile schema validation is not explicitly mandated, it may be the most effective mechanism for full validation coverage of HTTP APIs or other interfaces that use JSON or XML.\n\nPlease note the following points on Schema Validation:\n\n* The \"published version\" of the JSON Schema validation specification is considered production-ready, but not strictly speaking \"stable.\" When using JSON Schema validation, ensure there are no gaps with the guidance in the requirements below.\n* Any JSON Schema validation libraries in use should also be monitored and updated if necessary once the standard is formalized.\n* DTD validation should not be used, and framework DTD evaluation should be disabled, to avoid issues with XXE attacks against DTDs.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **2.2.1** | Verify that input is validated to enforce business or functional expectations for that input. This should either use positive validation against an allow list of values, patterns, and ranges, or be based on comparing the input to an expected structure and logical limits according to predefined rules. For L1, this can focus on input which is used to make specific business or security decisions. For L2 and up, this should apply to all input. | 1 |\n| **2.2.2** | Verify that the application is designed to enforce input validation at a trusted service layer. While client-side validation improves usability and should be encouraged, it must not be relied upon as a security control. | 1 |\n| **2.2.3** | Verify that the application ensures that combinations of related data items are reasonable according to the pre-defined rules. | 2 |\n\n## V2.3 Business Logic Security\n\nThis section considers key requirements to ensure that the application enforces business logic processes in the correct way and is not vulnerable to attacks that exploit the logic and flow of the application.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **2.3.1** | Verify that the application will only process business logic flows for the same user in the expected sequential step order and without skipping steps. | 1 |\n| **2.3.2** | Verify that business logic limits are implemented per the application's documentation to avoid business logic flaws being exploited. | 2 |\n| **2.3.3** | Verify that transactions are being used at the business logic level such that either a business logic operation succeeds in its entirety or it is rolled back to the previous correct state. | 2 |\n| **2.3.4** | Verify that business logic level locking mechanisms are used to ensure that limited quantity resources (such as theater seats or delivery slots) cannot be double-booked by manipulating the application's logic. | 2 |\n| **2.3.5** | Verify that high-value business logic flows require multi-user approval to prevent unauthorized or accidental actions. This could include but is not limited to large monetary transfers, contract approvals, access to classified information, or safety overrides in manufacturing. | 3 |\n\n## V2.4 Anti-automation\n\nThis section includes anti-automation controls to ensure that human-like interactions are required and excessive automated requests are prevented.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **2.4.1** | Verify that anti-automation controls are in place to protect against excessive calls to application functions that could lead to data exfiltration, garbage-data creation, quota exhaustion, rate-limit breaches, denial-of-service, or overuse of costly resources. | 2 |\n| **2.4.2** | Verify that business logic flows require realistic human timing, preventing excessively rapid transaction submissions. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Web Security Testing Guide: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README)\n* Anti-automation can be achieved in many ways, including the use of the [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n", "timestamp": "2025-10-24T11:40:07.009991"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x12-V3-Web-Frontend-Security.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x12-V3-Web-Frontend-Security.md", "content": "# V3 Web Frontend Security\n\n## Control Objective\n\nThis category focuses on requirements designed to protect against attacks executed via a web frontend. These requirements do not apply to machine-to-machine solutions.\n\n## V3.1 Web Frontend Security Documentation\n\nThis section outlines the browser security features that should be specified in the application's documentation.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.1.1** | Verify that application documentation states the expected security features that browsers using the application must support (such as HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP), and other relevant HTTP security mechanisms). It must also define how the application must behave when some of these features are not available (such as warning the user or blocking access). | 3 |\n\n## V3.2 Unintended Content Interpretation\n\nRendering content or functionality in an incorrect context can result in malicious content being executed or displayed.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.2.1** | Verify that security controls are in place to prevent browsers from rendering content or functionality in HTTP responses in an incorrect context (e.g., when an API, a user-uploaded file or other resource is requested directly). Possible controls could include: not serving the content unless HTTP request header fields (such as Sec-Fetch-\\*) indicate it is the correct context, using the sandbox directive of the Content-Security-Policy header field or using the attachment disposition type in the Content-Disposition header field. | 1 |\n| **3.2.2** | Verify that content intended to be displayed as text, rather than rendered as HTML, is handled using safe rendering functions (such as createTextNode or textContent) to prevent unintended execution of content such as HTML or JavaScript. | 1 |\n| **3.2.3** | Verify that the application avoids DOM clobbering when using client-side JavaScript by employing explicit variable declarations, performing strict type checking, avoiding storing global variables on the document object, and implementing namespace isolation. | 3 |\n\n## V3.3 Cookie Setup\n\nThis section outlines requirements for securely configuring sensitive cookies to provide a higher level of assurance that they were created by the application itself and to prevent their contents from leaking or being inappropriately modified.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.3.1** | Verify that cookies have the 'Secure' attribute set, and if the '\\__Host-' prefix is not used for the cookie name, the '__Secure-' prefix must be used for the cookie name. | 1 |\n| **3.3.2** | Verify that each cookie's 'SameSite' attribute value is set according to the purpose of the cookie, to limit exposure to user interface redress attacks and browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF). | 2 |\n| **3.3.3** | Verify that cookies have the '__Host-' prefix for the cookie name unless they are explicitly designed to be shared with other hosts. | 2 |\n| **3.3.4** | Verify that if the value of a cookie is not meant to be accessible to client-side scripts (such as a session token), the cookie must have the 'HttpOnly' attribute set and the same value (e. g. session token) must only be transferred to the client via the 'Set-Cookie' header field. | 2 |\n| **3.3.5** | Verify that when the application writes a cookie, the cookie name and value length combined are not over 4096 bytes. Overly large cookies will not be stored by the browser and therefore not sent with requests, preventing the user from using application functionality which relies on that cookie. | 3 |\n\n## V3.4 Browser Security Mechanism Headers\n\nThis section describes which security headers should be set on HTTP responses to enable browser security features and restrictions when handling responses from the application.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.4.1** | Verify that a Strict-Transport-Security header field is included on all responses to enforce an HTTP Strict Transport Security (HSTS) policy. A maximum age of at least 1 year must be defined, and for L2 and up, the policy must apply to all subdomains as well. | 1 |\n| **3.4.2** | Verify that the Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header field is a fixed value by the application, or if the Origin HTTP request header field value is used, it is validated against an allowlist of trusted origins. When 'Access-Control-Allow-Origin: *' needs to be used, verify that the response does not include any sensitive information. | 1 |\n| **3.4.3** | Verify that HTTP responses include a Content-Security-Policy response header field which defines directives to ensure the browser only loads and executes trusted content or resources, in order to limit execution of malicious JavaScript. As a minimum, a global policy must be used which includes the directives object-src 'none' and base-uri 'none' and defines either an allowlist or uses nonces or hashes. For an L3 application, a per-response policy with nonces or hashes must be defined. | 2 |\n| **3.4.4** | Verify that all HTTP responses contain an 'X-Content-Type-Options: nosniff' header field. This instructs browsers not to use content sniffing and MIME type guessing for the given response, and to require the response's Content-Type header field value to match the destination resource. For example, the response to a request for a style is only accepted if the response's Content-Type is 'text/css'. This also enables the use of the Cross-Origin Read Blocking (CORB) functionality by the browser. | 2 |\n| **3.4.5** | Verify that the application sets a referrer policy to prevent leakage of technically sensitive data to third-party services via the 'Referer' HTTP request header field. This can be done using the Referrer-Policy HTTP response header field or via HTML element attributes. Sensitive data could include path and query data in the URL, and for internal non-public applications also the hostname. | 2 |\n| **3.4.6** | Verify that the web application uses the frame-ancestors directive of the Content-Security-Policy header field for every HTTP response to ensure that it cannot be embedded by default and that embedding of specific resources is allowed only when necessary. Note that the X-Frame-Options header field, although supported by browsers, is obsolete and may not be relied upon. | 2 |\n| **3.4.7** | Verify that the Content-Security-Policy header field specifies a location to report violations. | 3 |\n| **3.4.8** | Verify that all HTTP responses that initiate a document rendering (such as responses with Content-Type text/html), include the Cross‑Origin‑Opener‑Policy header field with the same-origin directive or the same-origin-allow-popups directive as required. This prevents attacks that abuse shared access to Window objects, such as tabnabbing and frame counting. | 3 |\n\n## V3.5 Browser Origin Separation\n\nWhen accepting a request to sensitive functionality on the server side, the application needs to ensure the request is initiated by the application itself or by a trusted party and has not been forged by an attacker.\n\nSensitive functionality in this context could include accepting form posts for authenticated and non-authenticated users (such as an authentication request), state-changing operations, or resource-demanding functionality (such as data export).\n\nThe key protections here are browser security policies like Same Origin Policy for JavaScript and also SameSite logic for cookies. Another common protection is the CORS preflight mechanism. This mechanism will be critical for endpoints designed to be called from a different origin, but it can also be a useful request forgery prevention mechanism for endpoints which are not designed to be called from a different origin.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.5.1** | Verify that, if the application does not rely on the CORS preflight mechanism to prevent disallowed cross-origin requests to use sensitive functionality, these requests are validated to ensure they originate from the application itself. This may be done by using and validating anti-forgery tokens or requiring extra HTTP header fields that are not CORS-safelisted request-header fields. This is to defend against browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF). | 1 |\n| **3.5.2** | Verify that, if the application relies on the CORS preflight mechanism to prevent disallowed cross-origin use of sensitive functionality, it is not possible to call the functionality with a request which does not trigger a CORS-preflight request. This may require checking the values of the 'Origin' and 'Content-Type' request header fields or using an extra header field that is not a CORS-safelisted header-field. | 1 |\n| **3.5.3** | Verify that HTTP requests to sensitive functionality use appropriate HTTP methods such as POST, PUT, PATCH, or DELETE, and not methods defined by the HTTP specification as \"safe\" such as HEAD, OPTIONS, or GET. Alternatively, strict validation of the Sec-Fetch-* request header fields can be used to ensure that the request did not originate from an inappropriate cross-origin call, a navigation request, or a resource load (such as an image source) where this is not expected. | 1 |\n| **3.5.4** | Verify that separate applications are hosted on different hostnames to leverage the restrictions provided by same-origin policy, including how documents or scripts loaded by one origin can interact with resources from another origin and hostname-based restrictions on cookies. | 2 |\n| **3.5.5** | Verify that messages received by the postMessage interface are discarded if the origin of the message is not trusted, or if the syntax of the message is invalid. | 2 |\n| **3.5.6** | Verify that JSONP functionality is not enabled anywhere across the application to avoid Cross-Site Script Inclusion (XSSI) attacks. | 3 |\n| **3.5.7** | Verify that data requiring authorization is not included in script resource responses, like JavaScript files, to prevent Cross-Site Script Inclusion (XSSI) attacks. | 3 |\n| **3.5.8** | Verify that authenticated resources (such as images, videos, scripts, and other documents) can be loaded or embedded on behalf of the user only when intended. This can be accomplished by strict validation of the Sec-Fetch-* HTTP request header fields to ensure that the request did not originate from an inappropriate cross-origin call, or by setting a restrictive Cross-Origin-Resource-Policy HTTP response header field to instruct the browser to block returned content. | 3 |\n\n## V3.6 External Resource Integrity\n\nThis section provides guidance for the safe hosting of content on third-party sites.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.6.1** | Verify that client-side assets, such as JavaScript libraries, CSS, or web fonts, are only hosted externally (e.g., on a Content Delivery Network) if the resource is static and versioned and Subresource Integrity (SRI) is used to validate the integrity of the asset. If this is not possible, there should be a documented security decision to justify this for each resource. | 3 |\n\n## V3.7 Other Browser Security Considerations\n\nThis section includes various other security controls and modern browser security features required for client-side browser security.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **3.7.1** | Verify that the application only uses client-side technologies which are still supported and considered secure. Examples of technologies which do not meet this requirement include NSAPI plugins, Flash, Shockwave, ActiveX, Silverlight, NACL, or client-side Java applets. | 2 |\n| **3.7.2** | Verify that the application will only automatically redirect the user to a different hostname or domain (which is not controlled by the application) where the destination appears on an allowlist. | 2 |\n| **3.7.3** | Verify that the application shows a notification when the user is being redirected to a URL outside of the application's control, with an option to cancel the navigation. | 3 |\n| **3.7.4** | Verify that the application's top-level domain (e.g., site.tld) is added to the public preload list for HTTP Strict Transport Security (HSTS). This ensures that the use of TLS for the application is built directly into the main browsers, rather than relying only on the Strict-Transport-Security response header field. | 3 |\n| **3.7.5** | Verify that the application behaves as documented (such as warning the user or blocking access) if the browser used to access the application does not support the expected security features. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes)\n* [OWASP Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [HSTS Browser Preload List submission form](https://hstspreload.org/)\n* [OWASP DOM Clobbering Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_Clobbering_Prevention_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:07.138115"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x13-V4-API-and-Web-Service.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x13-V4-API-and-Web-Service.md", "content": "# V4 API and Web Service\n\n## Control Objective\n\nSeveral considerations apply specifically to applications that expose APIs for use by web browsers or other consumers (commonly using JSON, XML, or GraphQL). This chapter covers the relevant security configurations and mechanisms that should be applied.\n\nNote that authentication, session management, and input validation concerns from other chapters also apply to APIs, so this chapter cannot be taken out of context or tested in isolation.\n\n## V4.1 Generic Web Service Security\n\nThis section addresses general web service security considerations and, consequently, basic web service hygiene practices.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **4.1.1** | Verify that every HTTP response with a message body contains a Content-Type header field that matches the actual content of the response, including the charset parameter to specify safe character encoding (e.g., UTF-8, ISO-8859-1) according to IANA Media Types, such as \"text/\", \"/+xml\" and \"/xml\". | 1 |\n| **4.1.2** | Verify that only user-facing endpoints (intended for manual web-browser access) automatically redirect from HTTP to HTTPS, while other services or endpoints do not implement transparent redirects. This is to avoid a situation where a client is erroneously sending unencrypted HTTP requests, but since the requests are being automatically redirected to HTTPS, the leakage of sensitive data goes undiscovered. | 2 |\n| **4.1.3** | Verify that any HTTP header field used by the application and set by an intermediary layer, such as a load balancer, a web proxy, or a backend-for-frontend service, cannot be overridden by the end-user. Example headers might include X-Real-IP, X-Forwarded-*, or X-User-ID. | 2 |\n| **4.1.4** | Verify that only HTTP methods that are explicitly supported by the application or its API (including OPTIONS during preflight requests) can be used and that unused methods are blocked. | 3 |\n| **4.1.5** | Verify that per-message digital signatures are used to provide additional assurance on top of transport protections for requests or transactions which are highly sensitive or which traverse a number of systems. | 3 |\n\n## V4.2 HTTP Message Structure Validation\n\nThis section explains how the structure and header fields of an HTTP message should be validated to prevent attacks such as request smuggling, response splitting, header injection, and denial of service via overly long HTTP messages.\n\nThese requirements are relevant for general HTTP message processing and generation, but are especially important when converting HTTP messages between different HTTP versions.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **4.2.1** | Verify that all application components (including load balancers, firewalls, and application servers) determine boundaries of incoming HTTP messages using the appropriate mechanism for the HTTP version to prevent HTTP request smuggling. In HTTP/1.x, if a Transfer-Encoding header field is present, the Content-Length header must be ignored per RFC 2616. When using HTTP/2 or HTTP/3, if a Content-Length header field is present, the receiver must ensure that it is consistent with the length of the DATA frames. | 2 |\n| **4.2.2** | Verify that when generating HTTP messages, the Content-Length header field does not conflict with the length of the content as determined by the framing of the HTTP protocol, in order to prevent request smuggling attacks. | 3 |\n| **4.2.3** | Verify that the application does not send nor accept HTTP/2 or HTTP/3 messages with connection-specific header fields such as Transfer-Encoding to prevent response splitting and header injection attacks. | 3 |\n| **4.2.4** | Verify that the application only accepts HTTP/2 and HTTP/3 requests where the header fields and values do not contain any CR (\\r), LF (\\n), or CRLF (\\r\\n) sequences, to prevent header injection attacks. | 3 |\n| **4.2.5** | Verify that, if the application (backend or frontend) builds and sends requests, it uses validation, sanitization, or other mechanisms to avoid creating URIs (such as for API calls) or HTTP request header fields (such as Authorization or Cookie), which are too long to be accepted by the receiving component. This could cause a denial of service, such as when sending an overly long request (e.g., a long cookie header field), which results in the server always responding with an error status. | 3 |\n\n## V4.3 GraphQL\n\nGraphQL is becoming more common as a way of creating data-rich clients that are not tightly coupled to a variety of backend services. This section covers security considerations for GraphQL.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **4.3.1** | Verify that a query allowlist, depth limiting, amount limiting, or query cost analysis is used to prevent GraphQL or data layer expression Denial of Service (DoS) as a result of expensive, nested queries. | 2 |\n| **4.3.2** | Verify that GraphQL introspection queries are disabled in the production environment unless the GraphQL API is meant to be used by other parties. | 2 |\n\n## V4.4 WebSocket\n\nWebSocket is a communications protocol that provides a simultaneous two-way communication channel over a single TCP connection. It was standardized by the IETF as RFC 6455 in 2011 and is distinct from HTTP, even though it is designed to work over HTTP ports 443 and 80.\n\nThis section provides key security requirements to prevent attacks related to communication security and session management that specifically exploit this real-time communication channel.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **4.4.1** | Verify that WebSocket over TLS (WSS) is used for all WebSocket connections. | 1 |\n| **4.4.2** | Verify that, during the initial HTTP WebSocket handshake, the Origin header field is checked against a list of origins allowed for the application. | 2 |\n| **4.4.3** | Verify that, if the application's standard session management cannot be used, dedicated tokens are being used for this, which comply with the relevant Session Management security requirements. | 2 |\n| **4.4.4** | Verify that dedicated WebSocket session management tokens are initially obtained or validated through the previously authenticated HTTPS session when transitioning an existing HTTPS session to a WebSocket channel. | 2 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* Resources on GraphQL Authorization from [graphql.org](https://graphql.org/learn/authorization/) and [Apollo](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-methods).\n* [OWASP Web Security Testing Guide: GraphQL Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL)\n* [OWASP Web Security Testing Guide: Testing WebSockets](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets)\n", "timestamp": "2025-10-24T11:40:07.191925"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x14-V5-File-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x14-V5-File-Handling.md", "content": "# V5 File Handling\n\n## Control Objective\n\nThe use of files can present a variety of risks to the application, including denial of service, unauthorized access, and storage exhaustion. This chapter includes requirements to address these risks.\n\n## V5.1 File Handling Documentation\n\nThis section includes a requirement to document the expected characteristics of files accepted by the application, as a necessary precondition for developing and verifying relevant security checks.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **5.1.1** | Verify that the documentation defines the permitted file types, expected file extensions, and maximum size (including unpacked size) for each upload feature. Additionally, ensure that the documentation specifies how files are made safe for end-users to download and process, such as how the application behaves when a malicious file is detected. | 2 |\n\n## V5.2 File Upload and Content\n\nFile upload functionality is a primary source of untrusted files. This section outlines the requirements for ensuring that the presence, volume, or content of these files cannot harm the application.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **5.2.1** | Verify that the application will only accept files of a size which it can process without causing a loss of performance or a denial of service attack. | 1 |\n| **5.2.2** | Verify that when the application accepts a file, either on its own or within an archive such as a zip file, it checks if the file extension matches an expected file extension and validates that the contents correspond to the type represented by the extension. This includes, but is not limited to, checking the initial 'magic bytes', performing image re-writing, and using specialized libraries for file content validation. For L1, this can focus just on files which are used to make specific business or security decisions. For L2 and up, this must apply to all files being accepted. | 1 |\n| **5.2.3** | Verify that the application checks compressed files (e.g., zip, gz, docx, odt) against maximum allowed uncompressed size and against maximum number of files before uncompressing the file. | 2 |\n| **5.2.4** | Verify that a file size quota and maximum number of files per user are enforced to ensure that a single user cannot fill up the storage with too many files, or excessively large files. | 3 |\n| **5.2.5** | Verify that the application does not allow uploading compressed files containing symlinks unless this is specifically required (in which case it will be necessary to enforce an allowlist of the files that can be symlinked to). | 3 |\n| **5.2.6** | Verify that the application rejects uploaded images with a pixel size larger than the maximum allowed, to prevent pixel flood attacks. | 3 |\n\n## V5.3 File Storage\n\nThis section includes requirements to prevent files from being inappropriately executed after upload, to detect dangerous content, and to avoid untrusted data being used to control where files are being stored.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **5.3.1** | Verify that files uploaded or generated by untrusted input and stored in a public folder, are not executed as server-side program code when accessed directly with an HTTP request. | 1 |\n| **5.3.2** | Verify that when the application creates file paths for file operations, instead of user-submitted filenames, it uses internally generated or trusted data, or if user-submitted filenames or file metadata must be used, strict validation and sanitization must be applied. This is to protect against path traversal, local or remote file inclusion (LFI, RFI), and server-side request forgery (SSRF) attacks. | 1 |\n| **5.3.3** | Verify that server-side file processing, such as file decompression, ignores user-provided path information to prevent vulnerabilities such as zip slip. | 3 |\n\n## V5.4 File Download\n\nThis section contains requirements to mitigate risks when serving files to be downloaded, including path traversal and injection attacks. This also includes making sure they don't contain dangerous content.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **5.4.1** | Verify that the application validates or ignores user-submitted filenames, including in a JSON, JSONP, or URL parameter and specifies a filename in the Content-Disposition header field in the response. | 2 |\n| **5.4.2** | Verify that file names served (e.g., in HTTP response header fields or email attachments) are encoded or sanitized (e.g., following RFC 6266) to preserve document structure and prevent injection attacks. | 2 |\n| **5.4.3** | Verify that files obtained from untrusted sources are scanned by antivirus scanners to prevent serving of known malicious content. | 2 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)\n* [Example of using symlinks for arbitrary file read](https://hackerone.com/reports/1439593)\n* [Explanation of \"Magic Bytes\" from Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures)\n", "timestamp": "2025-10-24T11:40:07.253086"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x15-V6-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x15-V6-Authentication.md", "content": "# V6 Authentication\n\n## Control Objective\n\nAuthentication is the process of establishing or confirming the authenticity of an individual or device. It involves verifying claims made by a person or about a device, ensuring resistance to impersonation, and preventing the recovery or interception of passwords.\n\n[NIST SP 800-63](https://pages.nist.gov/800-63-3/) is a modern, evidence-based standard that is valuable for organizations worldwide, but is particularly relevant to US agencies and those interacting with US agencies.\n\nWhile many of the requirements in this chapter are based on the second section of the standard (known as NIST SP 800-63B \"Digital Identity Guidelines - Authentication and Lifecycle Management\"), the chapter focuses on common threats and frequently exploited authentication weaknesses. It does not attempt to comprehensively cover every point in the standard. For cases where full NIST SP 800-63 compliance is necessary, please refer to NIST SP 800-63.\n\nAdditionally, NIST SP 800-63 terminology may sometimes differ, and this chapter often uses more commonly understood terminology to improve clarity.\n\nA common feature of more advanced applications is the ability to adapt authentication stages required based on various risk factors. This feature is covered in the \"Authorization\" chapter, since these mechanisms also need to be considered for authorization decisions.\n\n## V6.1 Authentication Documentation\n\nThis section contains requirements detailing the authentication documentation that should be maintained for an application. This is crucial for implementing and assessing how the relevant authentication controls should be configured.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.1.1** | Verify that application documentation defines how controls such as rate limiting, anti-automation, and adaptive response, are used to defend against attacks such as credential stuffing and password brute force. The documentation must make clear how these controls are configured and prevent malicious account lockout. | 1 |\n| **6.1.2** | Verify that a list of context-specific words is documented in order to prevent their use in passwords. The list could include permutations of organization names, product names, system identifiers, project codenames, department or role names, and similar. | 2 |\n| **6.1.3** | Verify that, if the application includes multiple authentication pathways, these are all documented together with the security controls and authentication strength which must be consistently enforced across them. | 2 |\n\n## V6.2 Password Security\n\nPasswords, called \"Memorized Secrets\" by NIST SP 800-63, include passwords, passphrases, PINs, unlock patterns, and picking the correct kitten or another image element. They are generally considered \"something you know\" and are often used as a single-factor authentication mechanism.\n\nAs such, this section contains requirements for making sure that passwords are created and handled securely. Most of the requirements are L1 as they are most important at that level. From L2 onwards, multi-factor authentication mechanisms are required, where passwords may be one of those factors.\n\nThe requirements in this section mostly relate to [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) of [NIST's Guidance](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.2.1** | Verify that user set passwords are at least 8 characters in length although a minimum of 15 characters is strongly recommended. | 1 |\n| **6.2.2** | Verify that users can change their password. | 1 |\n| **6.2.3** | Verify that password change functionality requires the user's current and new password. | 1 |\n| **6.2.4** | Verify that passwords submitted during account registration or password change are checked against an available set of, at least, the top 3000 passwords which match the application's password policy, e.g. minimum length. | 1 |\n| **6.2.5** | Verify that passwords of any composition can be used, without rules limiting the type of characters permitted. There must be no requirement for a minimum number of upper or lower case characters, numbers, or special characters. | 1 |\n| **6.2.6** | Verify that password input fields use type=password to mask the entry. Applications may allow the user to temporarily view the entire masked password, or the last typed character of the password. | 1 |\n| **6.2.7** | Verify that \"paste\" functionality, browser password helpers, and external password managers are permitted. | 1 |\n| **6.2.8** | Verify that the application verifies the user's password exactly as received from the user, without any modifications such as truncation or case transformation. | 1 |\n| **6.2.9** | Verify that passwords of at least 64 characters are permitted. | 2 |\n| **6.2.10** | Verify that a user's password stays valid until it is discovered to be compromised or the user rotates it. The application must not require periodic credential rotation. | 2 |\n| **6.2.11** | Verify that the documented list of context specific words is used to prevent easy to guess passwords being created. | 2 |\n| **6.2.12** | Verify that passwords submitted during account registration or password changes are checked against a set of breached passwords. | 2 |\n\n## V6.3 General Authentication Security\n\nThis section contains general requirements for the security of authentication mechanisms as well as setting out the different expectations for levels. L2 applications must force the use of multi-factor authentication (MFA). L3 applications must use hardware-based authentication, performed in an attested and trusted execution environment (TEE). This could include device-bound passkeys, eIDAS Level of Assurance (LoA) High enforced authenticators, authenticators with NIST Authenticator Assurance Level 3 (AAL3) assurance, or an equivalent mechanism.\n\nWhile this is a relatively aggressive stance on MFA, it is critical to raise the bar around this to protect users, and any attempt to relax these requirements should be accompanied by a clear plan on how the risks around authentication will be mitigated, taking into account NIST's guidance and research on the topic.\n\nNote that at the time of release, NIST SP 800-63 considers email as [not acceptable](https://pages.nist.gov/800-63-FAQ/#q-b11) as an authentication mechanism ([archived copy](https://web.archive.org/web/20250330115328/https://pages.nist.gov/800-63-FAQ/#q-b11)).\n\nThe requirements in this section relate to a variety of sections of [NIST's Guidance](https://pages.nist.gov/800-63-3/sp800-63b.html), including: [&sect; 4.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#421-permitted-authenticator-types), [&sect; 4.3.1](https://pages.nist.gov/800-63-3/sp800-63b.html#431-permitted-authenticator-types), [&sect; 5.2.2](https://pages.nist.gov/800-63-3/sp800-63b.html#522-rate-limiting-throttling), and [&sect; 6.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-612-post-enrollment-binding).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.3.1** | Verify that controls to prevent attacks such as credential stuffing and password brute force are implemented according to the application's security documentation. | 1 |\n| **6.3.2** | Verify that default user accounts (e.g., \"root\", \"admin\", or \"sa\") are not present in the application or are disabled. | 1 |\n| **6.3.3** | Verify that either a multi-factor authentication mechanism or a combination of single-factor authentication mechanisms, must be used in order to access the application. For L3, one of the factors must be a hardware-based authentication mechanism which provides compromise and impersonation resistance against phishing attacks while verifying the intent to authenticate by requiring a user-initiated action (such as a button press on a FIDO hardware key or a mobile phone). Relaxing any of the considerations in this requirement requires a fully documented rationale and a comprehensive set of mitigating controls. | 2 |\n| **6.3.4** | Verify that, if the application includes multiple authentication pathways, there are no undocumented pathways and that security controls and authentication strength are enforced consistently. | 2 |\n| **6.3.5** | Verify that users are notified of suspicious authentication attempts (successful or unsuccessful). This may include authentication attempts from an unusual location or client, partially successful authentication (only one of multiple factors), an authentication attempt after a long period of inactivity or a successful authentication after several unsuccessful attempts. | 3 |\n| **6.3.6** | Verify that email is not used as either a single-factor or multi-factor authentication mechanism. | 3 |\n| **6.3.7** | Verify that users are notified after updates to authentication details, such as credential resets or modification of the username or email address. | 3 |\n| **6.3.8** | Verify that valid users cannot be deduced from failed authentication challenges, such as by basing on error messages, HTTP response codes, or different response times. Registration and forgot password functionality must also have this protection. | 3 |\n\n## V6.4 Authentication Factor Lifecycle and Recovery\n\nAuthentication factors may include passwords, soft tokens, hardware tokens, and biometric devices. Securely handling the lifecycle of these mechanisms is critical to the security of an application, and this section includes requirements related to this.\n\nThe requirements in this section mostly relate to [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) or [&sect; 6.1.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#replacement) of [NIST's Guidance](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.4.1** | Verify that system generated initial passwords or activation codes are securely randomly generated, follow the existing password policy, and expire after a short period of time or after they are initially used. These initial secrets must not be permitted to become the long term password. | 1 |\n| **6.4.2** | Verify that password hints or knowledge-based authentication (so-called \"secret questions\") are not present. | 1 |\n| **6.4.3** | Verify that a secure process for resetting a forgotten password is implemented, that does not bypass any enabled multi-factor authentication mechanisms. | 2 |\n| **6.4.4** | Verify that if a multi-factor authentication factor is lost, evidence of identity proofing is performed at the same level as during enrollment. | 2 |\n| **6.4.5** | Verify that renewal instructions for authentication mechanisms which expire are sent with enough time to be carried out before the old authentication mechanism expires, configuring automated reminders if necessary. | 3 |\n| **6.4.6** | Verify that administrative users can initiate the password reset process for the user, but that this does not allow them to change or choose the user's password. This prevents a situation where they know the user's password. | 3 |\n\n## V6.5 General Multi-factor authentication requirements\n\nThis section provides general guidance that will be relevant to various different multi-factor authentication methods.\n\nThe mechanisms include:\n\n* Lookup Secrets\n* Time based One-time Passwords (TOTPs)\n* Out-of-Band mechanisms\n\nLookup secrets are pre-generated lists of secret codes, similar to Transaction Authorization Numbers (TAN), social media recovery codes, or a grid containing a set of random values. This type of authentication mechanism is considered \"something you have\" because the codes are deliberately not memorable so will need to be stored somewhere.\n\nTime based One-time Passwords (TOTPs) are physical or soft tokens that display a continually changing pseudo-random one-time challenge. This type of authentication mechanism is considered \"something you have\". Multi-factor TOTPs are similar to single-factor TOTPs, but require a valid PIN code, biometric unlocking, USB insertion or NFC pairing, or some additional value (such as transaction signing calculators) to be entered to create the final One-time Password (OTP).\n\nDetails on out-of-band mechanisms will be provided in the next section.\n\nThe requirements in these sections mostly relate to [&sect; 5.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-512-look-up-secrets), [&sect; 5.1.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-513-out-of-band-devices), [&sect; 5.1.4.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5142-single-factor-otp-verifiers), [&sect; 5.1.5.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5152-multi-factor-otp-verifiers), [&sect; 5.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#521-physical-authenticators), and [&sect; 5.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#523-use-of-biometrics) of [NIST's Guidance](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.5.1** | Verify that lookup secrets, out-of-band authentication requests or codes, and time-based one-time passwords (TOTPs) are only successfully usable once. | 2 |\n| **6.5.2** | Verify that, when being stored in the application's backend, lookup secrets with less than 112 bits of entropy (19 random alphanumeric characters or 34 random digits) are hashed with an approved password storage hashing algorithm that incorporates a 32-bit random salt. A standard hash function can be used if the secret has 112 bits of entropy or more. | 2 |\n| **6.5.3** | Verify that lookup secrets, out-of-band authentication code, and time-based one-time password seeds, are generated using a Cryptographically Secure Pseudorandom Number Generator (CSPRNG) to avoid predictable values. | 2 |\n| **6.5.4** | Verify that lookup secrets and out-of-band authentication codes have a minimum of 20 bits of entropy (typically 4 random alphanumeric characters or 6 random digits is sufficient). | 2 |\n| **6.5.5** | Verify that out-of-band authentication requests, codes, or tokens, as well as time-based one-time passwords (TOTPs) have a defined lifetime. Out of band requests must have a maximum lifetime of 10 minutes and for TOTP a maximum lifetime of 30 seconds. | 2 |\n| **6.5.6** | Verify that any authentication factor (including physical devices) can be revoked in case of theft or other loss. | 3 |\n| **6.5.7** | Verify that biometric authentication mechanisms are only used as secondary factors together with either something you have or something you know. | 3 |\n| **6.5.8** | Verify that time-based one-time passwords (TOTPs) are checked based on a time source from a trusted service and not from an untrusted or client provided time. | 3 |\n\n## V6.6 Out-of-Band authentication mechanisms\n\nThis usually involves the authentication server communicating with a physical device over a secure secondary channel. For example, sending push notifications to mobile devices. This type of authentication mechanism is considered \"something you have\".\n\nUnsafe out-of-band authentication mechanisms such as e-mail and VOIP are not permitted. PSTN and SMS authentication are currently considered to be [\"restricted\" authentication mechanisms](https://pages.nist.gov/800-63-FAQ/#q-b01) by NIST and should be deprecated in favor of Time based One-time Passwords (TOTPs), a cryptographic mechanism, or similar. NIST SP 800-63B [&sect; 5.1.3.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-5133-authentication-using-the-public-switched-telephone-network) recommends addressing the risks of device swap, SIM change, number porting, or other abnormal behavior, if telephone or SMS out-of-band authentication absolutely has to be supported. While this ASVS section does not mandate this as a requirement, not taking these precautions for a sensitive L2 app or an L3 app should be seen as a significant red flag.\n\nNote that NIST has also recently provided guidance which [discourages the use of push notifications](https://pages.nist.gov/800-63-4/sp800-63b/authenticators/#fig-3). While this ASVS section does not do so, it is important to be aware of the risks of \"push bombing\".\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.6.1** | Verify that authentication mechanisms using the Public Switched Telephone Network (PSTN) to deliver One-time Passwords (OTPs) via phone or SMS are offered only when the phone number has previously been validated, alternate stronger methods (such as Time based One-time Passwords) are also offered, and the service provides information on their security risks to users. For L3 applications, phone and SMS must not be available as options. | 2 |\n| **6.6.2** | Verify that out-of-band authentication requests, codes, or tokens are bound to the original authentication request for which they were generated and are not usable for a previous or subsequent one. | 2 |\n| **6.6.3** | Verify that a code based out-of-band authentication mechanism is protected against brute force attacks by using rate limiting. Consider also using a code with at least 64 bits of entropy. | 2 |\n| **6.6.4** | Verify that, where push notifications are used for multi-factor authentication, rate limiting is used to prevent push bombing attacks. Number matching may also mitigate this risk. | 3 |\n\n## V6.7 Cryptographic authentication mechanism\n\nCryptographic authentication mechanisms include smart cards or FIDO keys, where the user has to plug in or pair the cryptographic device to the computer to complete authentication. The authentication server will send a challenge nonce to the cryptographic device or software, and the device or software calculates a response based upon a securely stored cryptographic key. The requirements in this section provide implementation-specific guidance for these mechanisms, with guidance on cryptographic algorithms being covered in the \"Cryptography\" chapter.\n\nWhere shared or secret keys are used for cryptographic authentication, these should be stored using the same mechanisms as other system secrets, as documented in the \"Secret Management\" section in the \"Configuration\" chapter.\n\nThe requirements in this section mostly relate to [&sect; 5.1.7.2](https://pages.nist.gov/800-63-3/sp800-63b.html#sfcdv) of [NIST's Guidance](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.7.1** | Verify that the certificates used to verify cryptographic authentication assertions are stored in a way protects them from modification. | 3 |\n| **6.7.2** | Verify that the challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device. | 3 |\n\n## V6.8 Authentication with an Identity Provider\n\nIdentity Providers (IdPs) provide federated identity for users. Users will often have more than one identity with multiple IdPs, such as an enterprise identity using Azure AD, Okta, Ping Identity, or Google, or consumer identity using Facebook, Twitter, Google, or WeChat, to name just a few common alternatives. This list is not an endorsement of these companies or services, but simply an encouragement for developers to consider the reality that many users have many established identities. Organizations should consider integrating with existing user identities, as per the risk profile of the IdP's strength of identity proofing. For example, it is unlikely a government organization would accept a social media identity as a login for sensitive systems, as it is easy to create fake or throwaway identities, whereas a mobile game company may well need to integrate with major social media platforms to grow their active player base.\n\nSecure use of external identity providers requires careful configuration and verification to prevent identity spoofing or forged assertions. This section provides requirements to address these risks.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **6.8.1** | Verify that, if the application supports multiple identity providers (IdPs), the user's identity cannot be spoofed via another supported identity provider (eg. by using the same user identifier). The standard mitigation would be for the application to register and identify the user using a combination of the IdP ID (serving as a namespace) and the user's ID in the IdP. | 2 |\n| **6.8.2** | Verify that the presence and integrity of digital signatures on authentication assertions (for example on JWTs or SAML assertions) are always validated, rejecting any assertions that are unsigned or have invalid signatures. | 2 |\n| **6.8.3** | Verify that SAML assertions are uniquely processed and used only once within the validity period to prevent replay attacks. | 2 |\n| **6.8.4** | Verify that, if an application uses a separate Identity Provider (IdP) and expects specific authentication strength, methods, or recentness for specific functions, the application verifies this using the information returned by the IdP. For example, if OIDC is used, this might be achieved by validating ID Token claims such as 'acr', 'amr', and 'auth_time' (if present). If the IdP does not provide this information, the application must have a documented fallback approach that assumes that the minimum strength authentication mechanism was used (for example, single-factor authentication using username and password). | 2 |\n\n## References\n\nFor more information, see also:\n\n* [NIST SP 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST SP 800-63B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST SP 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Web Security Testing Guide: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing)\n* [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Forgot Password Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Choosing and Using Security Questions Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n* [CISA Guidance on \"Number Matching\"](https://www.cisa.gov/sites/default/files/publications/fact-sheet-implement-number-matching-in-mfa-applications-508c.pdf)\n* [Details on the FIDO Alliance](https://fidoalliance.org/)\n", "timestamp": "2025-10-24T11:40:07.357588"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x16-V7-Session-Management.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x16-V7-Session-Management.md", "content": "# V7 Session Management\n\n## Control Objective\n\nSession management mechanisms allow applications to correlate user and device interactions over time, even when using stateless communication protocols (such as HTTP). Modern applications may use multiple session tokens with distinct characteristics and purposes. A secure session management system is one that prevents attackers from obtaining, utilizing, or otherwise abusing a victim's session. Applications maintaining sessions must ensure that the following high-level session management requirements are met:\n\n* Sessions are unique to each individual and cannot be guessed or shared.\n* Sessions are invalidated when no longer required and are timed out during periods of inactivity.\n\nMany of the requirements in this chapter relate to selected [NIST SP 800-63 Digital Identity Guidelines](https://pages.nist.gov/800-63-4/) controls, focusing on common threats and commonly exploited authentication weaknesses.\n\nNote that requirements for specific implementation details of certain session management mechanisms can be found elsewhere:\n\n* HTTP Cookies are a common mechanism for securing session tokens. Specific security requirements for cookies can be found in the \"Web Frontend Security\" chapter.\n* Self-contained tokens are frequently used as a way of maintaining sessions. Specific security requirements can be found in the \"Self-contained Tokens\" chapter.\n\n## V7.1 Session Management Documentation\n\nThere is no single pattern that suits all applications. Therefore, it is not feasible to define universal boundaries and limits that suit all cases. A risk analysis with documented security decisions related to session handling must be conducted as a prerequisite to implementation and testing. This ensures that the session management system is tailored to the specific requirements of the application.\n\nRegardless of whether a stateful or \"stateless\" session mechanism is chosen, the analysis must be complete and documented to demonstrate that the selected solution is capable of satisfying all relevant security requirements. Interaction with any Single Sign-on (SSO) mechanisms in use should also be considered.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.1.1** | Verify that the user's session inactivity timeout and absolute maximum session lifetime are documented, are appropriate in combination with other controls, and that the documentation includes justification for any deviations from NIST SP 800-63B re-authentication requirements. | 2 |\n| **7.1.2** | Verify that the documentation defines how many concurrent (parallel) sessions are allowed for one account as well as the intended behaviors and actions to be taken when the maximum number of active sessions is reached. | 2 |\n| **7.1.3** | Verify that all systems that create and manage user sessions as part of a federated identity management ecosystem (such as SSO systems) are documented along with controls to coordinate session lifetimes, termination, and any other conditions that require re-authentication. | 2 |\n\n## V7.2 Fundamental Session Management Security\n\nThis section satisfies the essential requirements of secure sessions by verifying that session tokens are securely generated and validated.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.2.1** | Verify that the application performs all session token verification using a trusted, backend service. | 1 |\n| **7.2.2** | Verify that the application uses either self-contained or reference tokens that are dynamically generated for session management, i.e. not using static API secrets and keys. | 1 |\n| **7.2.3** | Verify that if reference tokens are used to represent user sessions, they are unique and generated using a cryptographically secure pseudo-random number generator (CSPRNG) and possess at least 128 bits of entropy. | 1 |\n| **7.2.4** | Verify that the application generates a new session token on user authentication, including re-authentication, and terminates the current session token. | 1 |\n\n## V7.3 Session Timeout\n\nSession timeout mechanisms serve to minimize the window of opportunity for session hijacking and other forms of session abuse. Timeouts must satisfy documented security decisions.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.3.1** | Verify that there is an inactivity timeout such that re-authentication is enforced according to risk analysis and documented security decisions. | 2 |\n| **7.3.2** | Verify that there is an absolute maximum session lifetime such that re-authentication is enforced according to risk analysis and documented security decisions. | 2 |\n\n## V7.4 Session Termination\n\nSession termination may be handled either by the application itself or by the SSO provider if the SSO provider is handling session management instead of the application. It may be necessary to decide whether the SSO provider is in scope when considering the requirements in this section as some may be controlled by the provider.\n\nSession termination should result in requiring re-authentication and be effective across the application, federated login (if present), and any relying parties.\n\nFor stateful session mechanisms, termination typically involves invalidating the session on the backend. In the case of self-contained tokens, additional measures are required to revoke or block these tokens, as they may otherwise remain valid until expiration.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.4.1** | Verify that when session termination is triggered (such as logout or expiration), the application disallows any further use of the session. For reference tokens or stateful sessions, this means invalidating the session data at the application backend. Applications using self-contained tokens will need a solution such as maintaining a list of terminated tokens, disallowing tokens produced before a per-user date and time or rotating a per-user signing key. | 1 |\n| **7.4.2** | Verify that the application terminates all active sessions when a user account is disabled or deleted (such as an employee leaving the company). | 1 |\n| **7.4.3** | Verify that the application gives the option to terminate all other active sessions after a successful change or removal of any authentication factor (including password change via reset or recovery and, if present, an MFA settings update). | 2 |\n| **7.4.4** | Verify that all pages that require authentication have easy and visible access to logout functionality. | 2 |\n| **7.4.5** | Verify that application administrators are able to terminate active sessions for an individual user or for all users. | 2 |\n\n## V7.5 Defenses Against Session Abuse\n\nThis section provides requirements to mitigate the risk posed by active sessions that are either hijacked or abused through vectors that rely on the existence and capabilities of active user sessions. For example, using malicious content execution to force an authenticated victim browser to perform an action using the victim's session.\n\nNote that the level-specific guidance in the \"Authentication\" chapter should be taken into account when considering requirements in this section.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.5.1** | Verify that the application requires full re-authentication before allowing modifications to sensitive account attributes which may affect authentication such as email address, phone number, MFA configuration, or other information used in account recovery. | 2 |\n| **7.5.2** | Verify that users are able to view and (having authenticated again with at least one factor) terminate any or all currently active sessions. | 2 |\n| **7.5.3** | Verify that the application requires further authentication with at least one factor or secondary verification before performing highly sensitive transactions or operations. | 3 |\n\n## V7.6 Federated Re-authentication\n\nThis section relates to those writing Relying Party (RP) or Identity Provider (IdP) code. These requirements are derived from the [NIST SP 800-63C](https://pages.nist.gov/800-63-4/sp800-63c.html) for Federation & Assertions.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **7.6.1** | Verify that session lifetime and termination between Relying Parties (RPs) and Identity Providers (IdPs) behave as documented, requiring re-authentication as necessary such as when the maximum time between IdP authentication events is reached. | 2 |\n| **7.6.2** | Verify that creation of a session requires either the user's consent or an explicit action, preventing the creation of new application sessions without user interaction. | 2 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:07.456688"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x17-V8-Authorization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x17-V8-Authorization.md", "content": "# V8 Authorization\n\n## Control Objective\n\nAuthorization ensures that access is granted only to permitted consumers (users, servers, and other clients). To enforce the Principle of Least Privilege (POLP), verified applications must meet the following high-level requirements:\n\n* Document authorization rules, including decision-making factors and environmental contexts.\n* Consumers should have access only to resources permitted by their defined entitlements.\n\n## V8.1 Authorization Documentation\n\nComprehensive authorization documentation is essential to ensure that security decisions are consistently applied, auditable, and aligned with organizational policies. This reduces the risk of unauthorized access by making security requirements clear and actionable for developers, administrators, and testers.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **8.1.1** | Verify that authorization documentation defines rules for restricting function-level and data-specific access based on consumer permissions and resource attributes. | 1 |\n| **8.1.2** | Verify that authorization documentation defines rules for field-level access restrictions (both read and write) based on consumer permissions and resource attributes. Note that these rules might depend on other attribute values of the relevant data object, such as state or status. | 2 |\n| **8.1.3** | Verify that the application's documentation defines the environmental and contextual attributes (including but not limited to, time of day, user location, IP address, or device) that are used in the application to make security decisions, including those pertaining to authentication and authorization. | 3 |\n| **8.1.4** | Verify that authentication and authorization documentation defines how environmental and contextual factors are used in decision-making, in addition to function-level, data-specific, and field-level authorization. This should include the attributes evaluated, thresholds for risk, and actions taken (e.g., allow, challenge, deny, step-up authentication). | 3 |\n\n## V8.2 General Authorization Design\n\nImplementing granular authorization controls at the function, data, and field levels ensures that consumers can access only what has been explicitly granted to them.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **8.2.1** | Verify that the application ensures that function-level access is restricted to consumers with explicit permissions. | 1 |\n| **8.2.2** | Verify that the application ensures that data-specific access is restricted to consumers with explicit permissions to specific data items to mitigate insecure direct object reference (IDOR) and broken object level authorization (BOLA). | 1 |\n| **8.2.3** | Verify that the application ensures that field-level access is restricted to consumers with explicit permissions to specific fields to mitigate broken object property level authorization (BOPLA). | 2 |\n| **8.2.4** | Verify that adaptive security controls based on a consumer's environmental and contextual attributes (such as time of day, location, IP address, or device) are implemented for authentication and authorization decisions, as defined in the application's documentation. These controls must be applied when the consumer tries to start a new session and also during an existing session. | 3 |\n\n## V8.3 Operation Level Authorization\n\nThe immediate application of authorization changes in the appropriate tier of an application's architecture is crucial to preventing unauthorized actions, especially in dynamic environments.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **8.3.1** | Verify that the application enforces authorization rules at a trusted service layer and doesn't rely on controls that an untrusted consumer could manipulate, such as client-side JavaScript. | 1 |\n| **8.3.2** | Verify that changes to values on which authorization decisions are made are applied immediately. Where changes cannot be applied immediately, (such as when relying on data in self-contained tokens), there must be mitigating controls to alert when a consumer performs an action when they are no longer authorized to do so and revert the change. Note that this alternative would not mitigate information leakage. | 3 |\n| **8.3.3** | Verify that access to an object is based on the originating subject's (e.g. consumer's) permissions, not on the permissions of any intermediary or service acting on their behalf. For example, if a consumer calls a web service using a self-contained token for authentication, and the service then requests data from a different service, the second service will use the consumer's token, rather than a machine-to-machine token from the first service, to make permission decisions. | 3 |\n\n## V8.4 Other Authorization Considerations\n\nAdditional considerations for authorization, particularly for administrative interfaces and multi-tenant environments, help prevent unauthorized access.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **8.4.1** | Verify that multi-tenant applications use cross-tenant controls to ensure consumer operations will never affect tenants with which they do not have permissions to interact. | 2 |\n| **8.4.2** | Verify that access to administrative interfaces incorporates multiple layers of security, including continuous consumer identity verification, device security posture assessment, and contextual risk analysis, ensuring that network location or trusted endpoints are not the sole factors for authorization even though they may reduce the likelihood of unauthorized access. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Authorization](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/05-Authorization_Testing)\n* [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:07.525715"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x18-V9-Self-contained-Tokens.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x18-V9-Self-contained-Tokens.md", "content": "# V9 Self-contained Tokens\n\n## Control Objective\n\nThe concept of a self-contained token is mentioned in the original RFC 6749 OAuth 2.0 from 2012. It refers to a token containing data or claims on which a receiving service will rely to make security decisions. This should be differentiated from a simple token containing only an identifier, which a receiving service uses to look up data locally. The most common examples of self-contained tokens are JSON Web Tokens (JWTs) and SAML assertions.\n\nThe use of self-contained tokens has become very widespread, even outside of OAuth and OIDC. At the same time, the security of this mechanism relies on the ability to validate the integrity of the token and to ensure that the token is valid for a particular context. There are many pitfalls with this process, and this chapter provides specific details of the mechanisms that applications should have in place to prevent them.\n\n## V9.1 Token source and integrity\n\nThis section includes requirements to ensure that the token has been produced by a trusted party and has not been tampered with.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **9.1.1** | Verify that self-contained tokens are validated using their digital signature or MAC to protect against tampering before accepting the token's contents. | 1 |\n| **9.1.2** | Verify that only algorithms on an allowlist can be used to create and verify self-contained tokens, for a given context. The allowlist must include the permitted algorithms, ideally only either symmetric or asymmetric algorithms, and must not include the 'None' algorithm. If both symmetric and asymmetric must be supported, additional controls will be needed to prevent key confusion. | 1 |\n| **9.1.3** | Verify that key material that is used to validate self-contained tokens is from trusted pre-configured sources for the token issuer, preventing attackers from specifying untrusted sources and keys. For JWTs and other JWS structures, headers such as 'jku', 'x5u', and 'jwk' must be validated against an allowlist of trusted sources. | 1 |\n\n## V9.2 Token content\n\nBefore making security decisions based on the content of a self-contained token, it is necessary to validate that the token has been presented within its validity period and that it is intended for use by the receiving service and for the purpose for which it was presented. This helps avoid insecure cross-usage between different services or with different token types from the same issuer.\n\nSpecific requirements for OAuth and OIDC are covered in the dedicated chapter.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **9.2.1** | Verify that, if a validity time span is present in the token data, the token and its content are accepted only if the verification time is within this validity time span. For example, for JWTs, the claims 'nbf' and 'exp' must be verified. | 1 |\n| **9.2.2** | Verify that the service receiving a token validates the token to be the correct type and is meant for the intended purpose before accepting the token's contents. For example, only access tokens can be accepted for authorization decisions and only ID Tokens can be used for proving user authentication. | 2 |\n| **9.2.3** | Verify that the service only accepts tokens which are intended for use with that service (audience). For JWTs, this can be achieved by validating the 'aud' claim against an allowlist defined in the service. | 2 |\n| **9.2.4** | Verify that, if a token issuer uses the same private key for issuing tokens to different audiences, the issued tokens contain an audience restriction that uniquely identifies the intended audiences. This will prevent a token from being reused with an unintended audience. If the audience identifier is dynamically provisioned, the token issuer must validate these audiences in order to make sure that they do not result in audience impersonation. | 2 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP JSON Web Token Cheat Sheet for Java Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html) (but has useful general guidance)\n", "timestamp": "2025-10-24T11:40:07.629499"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x19-V10-OAuth-and-OIDC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x19-V10-OAuth-and-OIDC.md", "content": "# V10 OAuth and OIDC\n\n## Control Objective\n\nOAuth2 (referred to as OAuth in this chapter) is an industry-standard framework for delegated authorization. For example, using OAuth, a client application can obtain access to APIs (server resources) on a user's behalf, provided the user has authorized the client application to do so.\n\nBy itself, OAuth is not designed for user authentication. The OpenID Connect (OIDC) framework extends OAuth by adding a user identity layer on top of OAuth. OIDC provides support for features including standardized user information, Single Sign-On (SSO), and session management. As OIDC is an extension of OAuth, the OAuth requirements in this chapter also apply to OIDC.\n\nThe following roles are defined in OAuth:\n\n* The OAuth client is the application that attempts to obtain access to server resources (e.g., by calling an API using the issued access token). The OAuth client is often a server-side application.\n    * A confidential client is a client capable of maintaining the confidentiality of the credentials it uses to authenticate itself with the authorization server.\n    * A public client is not capable of maintaining the confidentiality of credentials for authenticating with the authorization server. Therefore, instead of authenticating itself (e.g., using 'client_id' and 'client_secret' parameters), it only identifies itself (using a 'client_id' parameter).\n* The OAuth resource server (RS) is the server API exposing resources to OAuth clients.\n* The OAuth authorization server (AS) is a server application that issues access tokens to OAuth clients. These access tokens allow OAuth clients to access RS resources, either on behalf of an end-user or on the OAuth client's own behalf. The AS is often a separate application, but (if appropriate) it may be integrated into a suitable RS.\n* The resource owner (RO) is the end-user who authorizes OAuth clients to obtain limited access to resources hosted on the resource server on their behalf. The resource owner consents to this delegated authorization by interacting with the authorization server.\n\nThe following roles are defined in OIDC:\n\n* The relying party (RP) is the client application requesting end-user authentication through the OpenID Provider. It assumes the role of an OAuth client.\n* The OpenID Provider (OP) is an OAuth AS that is capable of authenticating the end-user and provides OIDC claims to an RP. The OP may be the identity provider (IdP), but in federated scenarios, the OP and the identity provider (where the end-user authenticates) may be different server applications.\n\nOAuth and OIDC were initially designed for third-party applications. Today, they are often used by first-party applications as well. However, when used in first-party scenarios, such as authentication and session management, the protocol adds some complexity, which may introduce new security challenges.\n\nOAuth and OIDC can be used for many types of applications, but the focus for ASVS and the requirements in this chapter is on web applications and APIs.\n\nSince OAuth and OIDC can be considered logic on top of web technologies, general requirements from other chapters always apply, and this chapter cannot be taken out of context.\n\nThis chapter addresses best current practices for OAuth2 and OIDC aligned with specifications found at <https://oauth.net/2/> and <https://openid.net/developers/specs/>. Even if RFCs are considered mature, they are updated frequently. Thus, it is important to align with the latest versions when applying the requirements in this chapter. See the references section for more details.\n\nGiven the complexity of the area, it is vitally important for a secure OAuth or OIDC solution to use well-known industry-standard authorization servers and apply the recommended security configuration.\n\nTerminology used in this chapter aligns with OAuth RFCs and OIDC specifications, but note that OIDC terminology is only used for OIDC-specific requirements; otherwise, OAuth terminology is used.\n\nIn the context of OAuth and OIDC, the term \"token\" in this chapter refers to:\n\n* Access tokens, which shall only be consumed by the RS and can either be reference tokens that are validated using introspection or self-contained tokens that are validated using some key material.\n* Refresh tokens, which shall only be consumed by the authorization server that issued the token.\n* OIDC ID Tokens, which shall only be consumed by the client that triggered the authorization flow.\n\nThe risk levels for some of the requirements in this chapter depend on whether the client is a confidential client or regarded as a public client. Since using strong client authentication mitigates many attack vectors, a few requirements might be relaxed when using a confidential client for L1 applications.\n\n## V10.1 Generic OAuth and OIDC Security\n\nThis section covers generic architectural requirements that apply to all applications using OAuth or OIDC.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.1.1** | Verify that tokens are only sent to components that strictly need them. For example, when using a backend-for-frontend pattern for browser-based JavaScript applications, access and refresh tokens shall only be accessible for the backend. | 2 |\n| **10.1.2** | Verify that the client only accepts values from the authorization server (such as the authorization code or ID Token) if these values result from an authorization flow that was initiated by the same user agent session and transaction. This requires that client-generated secrets, such as the proof key for code exchange (PKCE) 'code_verifier', 'state' or OIDC 'nonce', are not guessable, are specific to the transaction, and are securely bound to both the client and the user agent session in which the transaction was started. | 2 |\n\n## V10.2 OAuth Client\n\nThese requirements detail the responsibilities for OAuth client applications. The client can be, for example, a web server backend (often acting as a Backend For Frontend, BFF), a backend service integration, or a frontend Single Page Application (SPA, aka browser-based application).\n\nIn general, backend clients are regarded as confidential clients and frontend clients are regarded as public clients. However, native applications running on the end-user device can be regarded as confidential when using OAuth dynamic client registration.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.2.1** | Verify that, if the code flow is used, the OAuth client has protection against browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF), which trigger token requests, either by using proof key for code exchange (PKCE) functionality or checking the 'state' parameter that was sent in the authorization request. | 2 |\n| **10.2.2** | Verify that, if the OAuth client can interact with more than one authorization server, it has a defense against mix-up attacks. For example, it could require that the authorization server return the 'iss' parameter value and validate it in the authorization response and the token response. | 2 |\n| **10.2.3** | Verify that the OAuth client only requests the required scopes (or other authorization parameters) in requests to the authorization server. | 3 |\n\n## V10.3 OAuth Resource Server\n\nIn the context of ASVS and this chapter, the resource server is an API. To provide secure access, the resource server must:\n\n* Validate the access token, according to the token format and relevant protocol specifications, e.g., JWT-validation or OAuth token introspection.\n* If valid, enforce authorization decisions based on the information from the access token and permissions which have been granted. For example, the resource server needs to verify that the client (acting on behalf of RO) is authorized to access the requested resource.\n\nTherefore, the requirements listed here are OAuth or OIDC specific and should be performed after token validation and before performing authorization based on information from the token.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.3.1** | Verify that the resource server only accepts access tokens that are intended for use with that service (audience). The audience may be included in a structured access token (such as the 'aud' claim in JWT), or it can be checked using the token introspection endpoint. | 2 |\n| **10.3.2** | Verify that the resource server enforces authorization decisions based on claims from the access token that define delegated authorization. If claims such as 'sub', 'scope', and 'authorization_details' are present, they must be part of the decision. | 2 |\n| **10.3.3** | Verify that if an access control decision requires identifying a unique user from an access token (JWT or related token introspection response), the resource server identifies the user from claims that cannot be reassigned to other users. Typically, it means using a combination of 'iss' and 'sub' claims. | 2 |\n| **10.3.4** | Verify that, if the resource server requires specific authentication strength, methods, or recentness, it verifies that the presented access token satisfies these constraints. For example, if present, using the OIDC 'acr', 'amr' and 'auth_time' claims respectively. | 2 |\n| **10.3.5** | Verify that the resource server prevents the use of stolen access tokens or replay of access tokens (from unauthorized parties) by requiring sender-constrained access tokens, either Mutual TLS for OAuth 2 or OAuth 2 Demonstration of Proof of Possession (DPoP). | 3 |\n\n## V10.4 OAuth Authorization Server\n\nThese requirements detail the responsibilities for OAuth authorization servers, including OpenID Providers.\n\nFor client authentication, the 'self_signed_tls_client_auth' method is allowed with the prerequisites required by [section 2.2](https://datatracker.ietf.org/doc/html/rfc8705#name-self-signed-certificate-mut) of [RFC 8705](https://datatracker.ietf.org/doc/html/rfc8705).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.4.1** | Verify that the authorization server validates redirect URIs based on a client-specific allowlist of pre-registered URIs using exact string comparison. | 1 |\n| **10.4.2** | Verify that, if the authorization server returns the authorization code in the authorization response, it can be used only once for a token request. For the second valid request with an authorization code that has already been used to issue an access token, the authorization server must reject a token request and revoke any issued tokens related to the authorization code. | 1 |\n| **10.4.3** | Verify that the authorization code is short-lived. The maximum lifetime can be up to 10 minutes for L1 and L2 applications and up to 1 minute for L3 applications. | 1 |\n| **10.4.4** | Verify that for a given client, the authorization server only allows the usage of grants that this client needs to use. Note that the grants 'token' (Implicit flow) and 'password' (Resource Owner Password Credentials flow) must no longer be used. | 1 |\n| **10.4.5** | Verify that the authorization server mitigates refresh token replay attacks for public clients, preferably using sender-constrained refresh tokens, i.e., Demonstrating Proof of Possession (DPoP) or Certificate-Bound Access Tokens using mutual TLS (mTLS). For L1 and L2 applications, refresh token rotation may be used. If refresh token rotation is used, the authorization server must invalidate the refresh token after usage, and revoke all refresh tokens for that authorization if an already used and invalidated refresh token is provided. | 1 |\n| **10.4.6** | Verify that, if the code grant is used, the authorization server mitigates authorization code interception attacks by requiring proof key for code exchange (PKCE). For authorization requests, the authorization server must require a valid 'code_challenge' value and must not accept a 'code_challenge_method' value of 'plain'. For a token request, it must require validation of the 'code_verifier' parameter. | 2 |\n| **10.4.7** | Verify that if the authorization server supports unauthenticated dynamic client registration, it mitigates the risk of malicious client applications. It must validate client metadata such as any registered URIs, ensure the user's consent, and warn the user before processing an authorization request with an untrusted client application. | 2 |\n| **10.4.8** | Verify that refresh tokens have an absolute expiration, including if sliding refresh token expiration is applied. | 2 |\n| **10.4.9** | Verify that refresh tokens and reference access tokens can be revoked by an authorized user using the authorization server user interface, to mitigate the risk of malicious clients or stolen tokens. | 2 |\n| **10.4.10** | Verify that confidential client is authenticated for client-to-authorized server backchannel requests such as token requests, pushed authorization requests (PAR), and token revocation requests. | 2 |\n| **10.4.11** | Verify that the authorization server configuration only assigns the required scopes to the OAuth client. | 2 |\n| **10.4.12** | Verify that for a given client, the authorization server only allows the 'response_mode' value that this client needs to use. For example, by having the authorization server validate this value against the expected values or by using pushed authorization request (PAR) or JWT-secured Authorization Request (JAR). | 3 |\n| **10.4.13** | Verify that grant type 'code' is always used together with pushed authorization requests (PAR). | 3 |\n| **10.4.14** | Verify that the authorization server issues only sender-constrained (Proof-of-Possession) access tokens, either with certificate-bound access tokens using mutual TLS (mTLS) or DPoP-bound access tokens (Demonstration of Proof of Possession). | 3 |\n| **10.4.15** | Verify that, for a server-side client (which is not executed on the end-user device), the authorization server ensures that the 'authorization_details' parameter value is from the client backend and that the user has not tampered with it. For example, by requiring the usage of pushed authorization request (PAR) or JWT-secured Authorization Request (JAR). | 3 |\n| **10.4.16** | Verify that the client is confidential and the authorization server requires the use of strong client authentication methods (based on public-key cryptography and resistant to replay attacks), such as mutual TLS ('tls_client_auth', 'self_signed_tls_client_auth') or private key JWT ('private_key_jwt'). | 3 |\n\n## V10.5 OIDC Client\n\nAs the OIDC relying party acts as an OAuth client, the requirements from the section \"OAuth Client\" apply as well.\n\nNote that the \"Authentication with an Identity Provider\" section in the \"Authentication\" chapter also contains relevant general requirements.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.5.1** | Verify that the client (as the relying party) mitigates ID Token replay attacks. For example, by ensuring that the 'nonce' claim in the ID Token matches the 'nonce' value sent in the authentication request to the OpenID Provider (in OAuth2 refereed to as the authorization request sent to the authorization server). | 2 |\n| **10.5.2** | Verify that the client uniquely identifies the user from ID Token claims, usually the 'sub' claim, which cannot be reassigned to other users (for the scope of an identity provider). | 2 |\n| **10.5.3** | Verify that the client rejects attempts by a malicious authorization server to impersonate another authorization server through authorization server metadata. The client must reject authorization server metadata if the issuer URL in the authorization server metadata does not exactly match the pre-configured issuer URL expected by the client. | 2 |\n| **10.5.4** | Verify that the client validates that the ID Token is intended to be used for that client (audience) by checking that the 'aud' claim from the token is equal to the 'client_id' value for the client. | 2 |\n| **10.5.5** | Verify that, when using OIDC back-channel logout, the relying party mitigates denial of service through forced logout and cross-JWT confusion in the logout flow. The client must verify that the logout token is correctly typed with a value of 'logout+jwt', contains the 'event' claim with the correct member name, and does not contain a 'nonce' claim. Note that it is also recommended to have a short expiration (e.g., 2 minutes). | 2 |\n\n## V10.6 OpenID Provider\n\nAs OpenID Providers act as OAuth authorization servers, the requirements from the section \"OAuth Authorization Server\" apply as well.\n\nNote that if using the ID Token flow (not the code flow), no access tokens are issued, and many of the requirements for OAuth AS are not applicable.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.6.1** | Verify that the OpenID Provider only allows values 'code', 'ciba', 'id_token', or 'id_token code' for response mode. Note that 'code' is preferred over 'id_token code' (the OIDC Hybrid flow), and 'token' (any Implicit flow) must not be used. | 2 |\n| **10.6.2** | Verify that the OpenID Provider mitigates denial of service through forced logout. By obtaining explicit confirmation from the end-user or, if present, validating parameters in the logout request (initiated by the relying party), such as the 'id_token_hint'. | 2 |\n\n## V10.7 Consent Management\n\nThese requirements cover the verification of the user's consent by the authorization server. Without proper user consent verification, a malicious actor may obtain permissions on the user's behalf through spoofing or social-engineering.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **10.7.1** | Verify that the authorization server ensures that the user consents to each authorization request. If the identity of the client cannot be assured, the authorization server must always explicitly prompt the user for consent. | 2 |\n| **10.7.2** | Verify that when the authorization server prompts for user consent, it presents sufficient and clear information about what is being consented to. When applicable, this should include the nature of the requested authorizations (typically based on scope, resource server, Rich Authorization Requests (RAR) authorization details), the identity of the authorized application, and the lifetime of these authorizations. | 2 |\n| **10.7.3** | Verify that the user can review, modify, and revoke consents which the user has granted through the authorization server. | 2 |\n\n## References\n\nFor more information on OAuth, please see:\n\n* [oauth.net](https://oauth.net/)\n* [OWASP OAuth 2.0 Protocol Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)\n\nFor OAuth-related requirements in ASVS following published and in draft status RFC-s are used:\n\n* [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)\n* [RFC6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)\n* [RFC6819 OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)\n* [RFC7636 Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636)\n* [RFC7591 OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591)\n* [RFC8628 OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)\n* [RFC8707 Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)\n* [RFC9068 JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068)\n* [RFC9126 OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9126)\n* [RFC9207 OAuth 2.0 Authorization Server Issuer Identification](https://datatracker.ietf.org/doc/html/rfc9207)\n* [RFC9396 OAuth 2.0 Rich Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9396)\n* [RFC9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)\n* [RFC9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700)\n* [draft OAuth 2.0 for Browser-Based Applications](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)<!-- recheck on release -->\n* [draft The OAuth 2.1 Authorization Framework](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)<!-- recheck on release -->\n\nFor more information on OpenID Connect, please see:\n\n* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)\n* [FAPI 2.0 Security Profile](https://openid.net/specs/fapi-security-profile-2_0-final.html)\n", "timestamp": "2025-10-24T11:40:07.749306"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x20-V11-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x20-V11-Cryptography.md", "content": "# V11 Cryptography\n\n## Control Objective\n\nThe objective of this chapter is to define best practices for the general use of cryptography, as well as to instill a fundamental understanding of cryptographic principles and inspire a shift toward more resilient and modern approaches. It encourages the following:\n\n* Implementing robust cryptographic systems that fail securely, adapt to evolving threats, and are future-proof.\n* Utilizing cryptographic mechanisms that are both secure and aligned with industry best practices.\n* Maintaining a secure cryptographic key management system with appropriate access controls and auditing.\n* Regularly evaluating the cryptographic landscape to assess new risks and adapt algorithms accordingly.\n* Discovering and managing cryptographic use cases throughout the application's lifecycle to ensure that all cryptographic assets are accounted for and secured.\n\nIn addition to outlining general principles and best practices, this document also provides more in-depth technical information about the requirements in Appendix C - Cryptography Standards. This includes algorithms and modes that are considered \"approved\" for the purposes of the requirements in this chapter.\n\nRequirements that use cryptography to solve a separate problem, such as secrets management or communications security, will be in different parts of the standard.\n\n## V11.1 Cryptographic Inventory and Documentation\n\nApplications need to be designed with strong cryptographic architecture to protect data assets according to their classification. Encrypting everything is wasteful; not encrypting anything is legally negligent. A balance must be struck, usually during architectural or high-level design, design sprints, or architectural spikes. Designing cryptography \"on the fly\" or retrofitting it will inevitably cost much more to implement securely than simply building it in from the start.\n\nIt is important to ensure that all cryptographic assets are regularly discovered, inventoried, and assessed. Please see the appendix for more information on how this can be done.\n\nThe need to future-proof cryptographic systems against the eventual rise of quantum computing is also critical. Post-Quantum Cryptography (PQC) refers to cryptographic algorithms designed to remain secure against attacks by quantum computers, which are expected to break widely used algorithms such as RSA and elliptic curve cryptography (ECC).\n\nPlease see the appendix for current guidance on vetted PQC primitives and standards.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.1.1** | Verify that there is a documented policy for management of cryptographic keys and a cryptographic key lifecycle that follows a key management standard such as NIST SP 800-57. This should include ensuring that keys are not overshared (for example, with more than two entities for shared secrets and more than one entity for private keys). | 2 |\n| **11.1.2** | Verify that a cryptographic inventory is performed, maintained, regularly updated, and includes all cryptographic keys, algorithms, and certificates used by the application. It must also document where keys can and cannot be used in the system, and the types of data that can and cannot be protected using the keys. | 2 |\n| **11.1.3** | Verify that cryptographic discovery mechanisms are employed to identify all instances of cryptography in the system, including encryption, hashing, and signing operations. | 3 |\n| **11.1.4** | Verify that a cryptographic inventory is maintained. This must include a documented plan that outlines the migration path to new cryptographic standards, such as post-quantum cryptography, in order to react to future threats. | 3 |\n\n## V11.2 Secure Cryptography Implementation\n\nThis section defines the requirements for the selection, implementation, and ongoing management of core cryptographic algorithms for an application. The objective is to ensure that only robust, industry-accepted cryptographic primitives are deployed, in alignment with current standards (e.g., NIST, ISO/IEC) and best practices. Organizations must ensure that each cryptographic component is selected based on peer-reviewed evidence and practical security testing.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.2.1** | Verify that industry-validated implementations (including libraries and hardware-accelerated implementations) are used for cryptographic operations. | 2 |\n| **11.2.2** | Verify that the application is designed with crypto agility such that random number, authenticated encryption, MAC, or hashing algorithms, key lengths, rounds, ciphers and modes can be reconfigured, upgraded, or swapped at any time, to protect against cryptographic breaks. Similarly, it must also be possible to replace keys and passwords and re-encrypt data. This will allow for seamless upgrades to post-quantum cryptography (PQC), once high-assurance implementations of approved PQC schemes or standards are widely available. | 2 |\n| **11.2.3** | Verify that all cryptographic primitives utilize a minimum of 128-bits of security based on the algorithm, key size, and configuration. For example, a 256-bit ECC key provides roughly 128 bits of security where RSA requires a 3072-bit key to achieve 128 bits of security. | 2 |\n| **11.2.4** | Verify that all cryptographic operations are constant-time, with no 'short-circuit' operations in comparisons, calculations, or returns, to avoid leaking information. | 3 |\n| **11.2.5** | Verify that all cryptographic modules fail securely, and errors are handled in a way that does not enable vulnerabilities, such as Padding Oracle attacks. | 3 |\n\n## V11.3 Encryption Algorithms\n\nAuthenticated encryption algorithms built on AES and CHACHA20 form the backbone of modern cryptographic practice.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.3.1** | Verify that insecure block modes (e.g., ECB) and weak padding schemes (e.g., PKCS#1 v1.5) are not used. | 1 |\n| **11.3.2** | Verify that only approved ciphers and modes such as AES with GCM are used. | 1 |\n| **11.3.3** | Verify that encrypted data is protected against unauthorized modification preferably by using an approved authenticated encryption method or by combining an approved encryption method with an approved MAC algorithm. | 2 |\n| **11.3.4** | Verify that nonces, initialization vectors, and other single-use numbers are not used for more than one encryption key and data-element pair. The method of generation must be appropriate for the algorithm being used. | 3 |\n| **11.3.5** | Verify that any combination of an encryption algorithm and a MAC algorithm is operating in encrypt-then-MAC mode. | 3 |\n\n## V11.4 Hashing and Hash-based Functions\n\nCryptographic hashes are used in a wide variety of cryptographic protocols, such as digital signatures, HMAC, key derivation functions (KDF), random bit generation, and password storage. The security of the cryptographic system is only as strong as the underlying hash functions used. This section outlines the requirements for using secure hash functions in cryptographic operations.\n\nFor password storage, as well as the cryptography appendix, the [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms) will also provide useful context and guidance.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.4.1** | Verify that only approved hash functions are used for general cryptographic use cases, including digital signatures, HMAC, KDF, and random bit generation. Disallowed hash functions, such as MD5, must not be used for any cryptographic purpose. | 1 |\n| **11.4.2** | Verify that passwords are stored using an approved, computationally intensive, key derivation function (also known as a \"password hashing function\"), with parameter settings configured based on current guidance. The settings should balance security and performance to make brute-force attacks sufficiently challenging for the required level of security. | 2 |\n| **11.4.3** | Verify that hash functions used in digital signatures, as part of data authentication or data integrity are collision resistant and have appropriate bit-lengths. If collision resistance is required, the output length must be at least 256 bits. If only resistance to second pre-image attacks is required, the output length must be at least 128 bits. | 2 |\n| **11.4.4** | Verify that the application uses approved key derivation functions with key stretching parameters when deriving secret keys from passwords. The parameters in use must balance security and performance to prevent brute-force attacks from compromising the resulting cryptographic key. | 2 |\n\n## V11.5 Random Values\n\nCryptographically secure Pseudo-random Number Generation (CSPRNG) is incredibly difficult to get right. Generally, good sources of entropy within a system will be quickly depleted if over-used, but sources with less randomness can lead to predictable keys and secrets.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.5.1** | Verify that all random numbers and strings which are intended to be non-guessable must be generated using a cryptographically secure pseudo-random number generator (CSPRNG) and have at least 128 bits of entropy. Note that UUIDs do not respect this condition. | 2 |\n| **11.5.2** | Verify that the random number generation mechanism in use is designed to work securely, even under heavy demand. | 3 |\n\n## V11.6 Public Key Cryptography\n\nPublic Key Cryptography will be used where it is not possible or not desirable to share a secret key between multiple parties.\n\nAs part of this, there exists a need for approved key exchange mechanisms, such as Diffie-Hellman and Elliptic Curve Diffie-Hellman (ECDH) to ensure that the cryptosystem remains secure against modern threats. The \"Secure Communication\" chapter provides requirements for TLS so the requirements in this section are intended for situations where Public Key Cryptography is being used in use cases other than TLS.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.6.1** | Verify that only approved cryptographic algorithms and modes of operation are used for key generation and seeding, and digital signature generation and verification. Key generation algorithms must not generate insecure keys vulnerable to known attacks, for example, RSA keys which are vulnerable to Fermat factorization. | 2 |\n| **11.6.2** | Verify that approved cryptographic algorithms are used for key exchange (such as Diffie-Hellman) with a focus on ensuring that key exchange mechanisms use secure parameters. This will prevent attacks on the key establishment process which could lead to adversary-in-the-middle attacks or cryptographic breaks. | 3 |\n\n## V11.7 In-Use Data Cryptography\n\nProtecting data while it is being processed is paramount. Techniques such as full memory encryption, encryption of data in transit, and ensuring data is encrypted as quickly as possible after use is recommended.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **11.7.1** | Verify that full memory encryption is in use that protects sensitive data while it is in use, preventing access by unauthorized users or processes. | 3 |\n| **11.7.2** | Verify that data minimization ensures the minimal amount of data is exposed during processing, and ensure that data is encrypted immediately after use or as soon as feasible. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Testing for Weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography)\n* [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-3](https://csrc.nist.gov/pubs/fips/140-3/final)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:40:07.850803"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x21-V12-Secure-Communication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x21-V12-Secure-Communication.md", "content": "# V12 Secure Communication\n\n## Control Objective\n\nThis chapter includes requirements related to the specific mechanisms that should be in place to protect data in transit, both between an end-user client and a backend service, as well as between internal and backend services.\n\nThe general concepts promoted by this chapter include:\n\n* Ensuring that communications are encrypted externally, and ideally internally as well.\n* Configuring encryption mechanisms using the latest guidance, including preferred algorithms and ciphers.\n* Using signed certificates to ensure that communications are not being intercepted by unauthorized parties.\n\nIn addition to outlining general principles and best practices, the ASVS also provides more in-depth technical information about cryptographic strength in Appendix C - Cryptography Standards.\n\n## V12.1 General TLS Security Guidance\n\nThis section provides initial guidance on how to secure TLS communications. Up-to-date tools should be used to review TLS configuration on an ongoing basis.\n\nWhile the use of wildcard TLS certificates is not inherently insecure, a compromise of a certificate that is deployed across all owned environments (e.g., production, staging, development, and test) may lead to a compromise of the security posture of the applications using it. Proper protection, management, and the use of separate TLS certificates in different environments should be employed if possible.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **12.1.1** | Verify that only the latest recommended versions of the TLS protocol are enabled, such as TLS 1.2 and TLS 1.3. The latest version of the TLS protocol must be the preferred option. | 1 |\n| **12.1.2** | Verify that only recommended cipher suites are enabled, with the strongest cipher suites set as preferred. L3 applications must only support cipher suites which provide forward secrecy. | 2 |\n| **12.1.3** | Verify that the application validates that mTLS client certificates are trusted before using the certificate identity for authentication or authorization. | 2 |\n| **12.1.4** | Verify that proper certification revocation, such as Online Certificate Status Protocol (OCSP) Stapling, is enabled and configured. | 3 |\n| **12.1.5** | Verify that Encrypted Client Hello (ECH) is enabled in the application's TLS settings to prevent exposure of sensitive metadata, such as the Server Name Indication (SNI), during TLS handshake processes. | 3 |\n\n## V12.2 HTTPS Communication with External Facing Services\n\nEnsure all HTTP traffic to external-facing services which the application exposes is sent encrypted, with publicly trusted certificates.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **12.2.1** | Verify that TLS is used for all connectivity between a client and external facing, HTTP-based services, and does not fall back to insecure or unencrypted communications. | 1 |\n| **12.2.2** | Verify that external facing services use publicly trusted TLS certificates. | 1 |\n\n## V12.3 General Service to Service Communication Security\n\nServer communications (both internal and external) involve more than just HTTP. Connections to and from other systems must also be secure, ideally using TLS.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **12.3.1** | Verify that an encrypted protocol such as TLS is used for all inbound and outbound connections to and from the application, including monitoring systems, management tools, remote access and SSH, middleware, databases, mainframes, partner systems, or external APIs. The server must not fall back to insecure or unencrypted protocols. | 2 |\n| **12.3.2** | Verify that TLS clients validate certificates received before communicating with a TLS server. | 2 |\n| **12.3.3** | Verify that TLS or another appropriate transport encryption mechanism used for all connectivity between internal, HTTP-based services within the application, and does not fall back to insecure or unencrypted communications. | 2 |\n| **12.3.4** | Verify that TLS connections between internal services use trusted certificates. Where internally generated or self-signed certificates are used, the consuming service must be configured to only trust specific internal CAs and specific self-signed certificates. | 2 |\n| **12.3.5** | Verify that services communicating internally within a system (intra-service communications) use strong authentication to ensure that each endpoint is verified. Strong authentication methods, such as TLS client authentication, must be employed to ensure identity, using public-key infrastructure and mechanisms that are resistant to replay attacks. For microservice architectures, consider using a service mesh to simplify certificate management and enhance security. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP - Transport Layer Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n* [Mozilla's Server Side TLS configuration guide](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* [Mozilla's tool to generate known good TLS configurations](https://ssl-config.mozilla.org/).\n* [O-Saft - OWASP Project to validate TLS configuration](https://owasp.org/www-project-o-saft/)\n", "timestamp": "2025-10-24T11:40:07.921351"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x22-V13-Configuration.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x22-V13-Configuration.md", "content": "# V13 Configuration\n\n## Control Objective\n\nThe application's default configuration must be secure for use on the Internet.\n\nThis chapter provides guidance on the various configurations necessary to achieve this, including those applied during development, build, and deployment.\n\nTopics covered include preventing data leakage, securely managing communication between components, and protecting secrets.\n\n## V13.1 Configuration Documentation\n\nThis section outlines documentation requirements for how the application communicates with internal and external services, as well as techniques to prevent loss of availability due to service inaccessibility. It also addresses documentation related to secrets.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **13.1.1** | Verify that all communication needs for the application are documented. This must include external services which the application relies upon and cases where an end user might be able to provide an external location to which the application will then connect. | 2 |\n| **13.1.2** | Verify that for each service the application uses, the documentation defines the maximum number of concurrent connections (e.g., connection pool limits) and how the application behaves when that limit is reached, including any fallback or recovery mechanisms, to prevent denial of service conditions. | 3 |\n| **13.1.3** | Verify that the application documentation defines resource‑management strategies for every external system or service it uses (e.g., databases, file handles, threads, HTTP connections). This should include resource‑release procedures, timeout settings, failure handling, and where retry logic is implemented, specifying retry limits, delays, and back‑off algorithms. For synchronous HTTP request–response operations it should mandate short timeouts and either disable retries or strictly limit retries to prevent cascading delays and resource exhaustion. | 3 |\n| **13.1.4** | Verify that the application's documentation defines the secrets that are critical for the security of the application and a schedule for rotating them, based on the organization's threat model and business requirements. | 3 |\n\n## V13.2 Backend Communication Configuration\n\nApplications interact with multiple services, including APIs, databases, or other components. These may be considered internal to the application but not included in the application's standard access control mechanisms, or they may be entirely external. In either case, it is necessary to configure the application to interact securely with these components and, if required, protect that configuration.\n\nNote: The \"Secure Communication\" chapter provides guidance for encryption in transit.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **13.2.1** | Verify that communications between backend application components that don't support the application's standard user session mechanism, including APIs, middleware, and data layers, are authenticated. Authentication must use individual service accounts, short-term tokens, or certificate-based authentication and not unchanging credentials such as passwords, API keys, or shared accounts with privileged access. | 2 |\n| **13.2.2** | Verify that communications between backend application components, including local or operating system services, APIs, middleware, and data layers, are performed with accounts assigned the least necessary privileges. | 2 |\n| **13.2.3** | Verify that if a credential has to be used for service authentication, the credential being used by the consumer is not a default credential (e.g., root/root or admin/admin). | 2 |\n| **13.2.4** | Verify that an allowlist is used to define the external resources or systems with which the application is permitted to communicate (e.g., for outbound requests, data loads, or file access). This allowlist can be implemented at the application layer, web server, firewall, or a combination of different layers. | 2 |\n| **13.2.5** | Verify that the web or application server is configured with an allowlist of resources or systems to which the server can send requests or load data or files from. | 2 |\n| **13.2.6** | Verify that where the application connects to separate services, it follows the documented configuration for each connection, such as maximum parallel connections, behavior when maximum allowed connections is reached, connection timeouts, and retry strategies. | 3 |\n\n## V13.3 Secret Management\n\nSecret management is an essential configuration task to ensure the protection of data used in the application. Specific requirements for cryptography can be found in the \"Cryptography\" chapter, but this section focuses on the management and handling aspects of secrets.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **13.3.1** | Verify that a secrets management solution, such as a key vault, is used to securely create, store, control access to, and destroy backend secrets. These could include passwords, key material, integrations with databases and third-party systems, keys and seeds for time-based tokens, other internal secrets, and API keys. Secrets must not be included in application source code or included in build artifacts. For an L3 application, this must involve a hardware-backed solution such as an HSM. | 2 |\n| **13.3.2** | Verify that access to secret assets adheres to the principle of least privilege. | 2 |\n| **13.3.3** | Verify that all cryptographic operations are performed using an isolated security module (such as a vault or hardware security module) to securely manage and protect key material from exposure outside of the security module. | 3 |\n| **13.3.4** | Verify that secrets are configured to expire and be rotated based on the application's documentation. | 3 |\n\n## V13.4 Unintended Information Leakage\n\nProduction configurations should be hardened to avoid disclosing unnecessary data. Many of these issues are rarely rated as significant risks but are often chained with other vulnerabilities. If these issues are not present by default, it raises the bar for attacking an application.\n\nFor example, hiding the version of server-side components does not eliminate the need to patch all components, and disabling folder listing does not remove the need to use authorization controls or keep files away from the public folder, but it raises the bar.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **13.4.1** | Verify that the application is deployed either without any source control metadata, including the .git or .svn folders, or in a way that these folders are inaccessible both externally and to the application itself. | 1 |\n| **13.4.2** | Verify that debug modes are disabled for all components in production environments to prevent exposure of debugging features and information leakage. | 2 |\n| **13.4.3** | Verify that web servers do not expose directory listings to clients unless explicitly intended. | 2 |\n| **13.4.4** | Verify that using the HTTP TRACE method is not supported in production environments, to avoid potential information leakage. | 2 |\n| **13.4.5** | Verify that documentation (such as for internal APIs) and monitoring endpoints are not exposed unless explicitly intended. | 2 |\n| **13.4.6** | Verify that the application does not expose detailed version information of backend components. | 3 |\n| **13.4.7** | Verify that the web tier is configured to only serve files with specific file extensions to prevent unintentional information, configuration, and source code leakage. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing)\n", "timestamp": "2025-10-24T11:40:08.076460"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x23-V14-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x23-V14-Data-Protection.md", "content": "# V14 Data Protection\n\n## Control Objective\n\nApplications cannot account for all usage patterns and user behaviors, and should therefore implement controls to limit unauthorized access to sensitive data on client devices.\n\nThis chapter includes requirements related to defining what data needs to be protected, how it should be protected, and specific mechanisms to implement or pitfalls to avoid.\n\nAnother consideration for data protection is bulk extraction, modification, or excessive usage. Each system's requirements are likely to be very different, so determining what is \"abnormal\" must consider the threat model and business risk. From an ASVS perspective, detecting these issues is handled in the \"Security Logging and Error Handling\" chapter, and setting limits is handled in the \"Validation and Business Logic\" chapter.\n\n## V14.1 Data Protection Documentation\n\nA key prerequisite for being able to protect data is to categorize what data should be considered sensitive. There are likely to be several different levels of sensitivity, and for each level, the controls required to protect data at that level will be different.\n\nThere are various privacy regulations and laws that affect how applications must approach the storage, use, and transmission of sensitive personal information. This section no longer tries to duplicate these types of data protection or privacy legislation, but rather focuses on key technical considerations for protecting sensitive data. Please consult local laws and regulations, and consult a qualified privacy specialist or lawyer as required.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **14.1.1** | Verify that all sensitive data created and processed by the application has been identified and classified into protection levels. This includes data that is only encoded and therefore easily decoded, such as Base64 strings or the plaintext payload inside a JWT. Protection levels need to take into account any data protection and privacy regulations and standards which the application is required to comply with. | 2 |\n| **14.1.2** | Verify that all sensitive data protection levels have a documented set of protection requirements. This must include (but not be limited to) requirements related to general encryption, integrity verification, retention, how the data is to be logged, access controls around sensitive data in logs, database-level encryption, privacy and privacy-enhancing technologies to be used, and other confidentiality requirements. | 2 |\n\n## V14.2 General Data Protection\n\nThis section contains various practical requirements related to the protection of data. Most are specific to particular issues such as unintended data leakage, but there is also a general requirement to implement protection controls based on the protection level required for each data item.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **14.2.1** | Verify that sensitive data is only sent to the server in the HTTP message body or header fields, and that the URL and query string do not contain sensitive information, such as an API key or session token. | 1 |\n| **14.2.2** | Verify that the application prevents sensitive data from being cached in server components, such as load balancers and application caches, or ensures that the data is securely purged after use. | 2 |\n| **14.2.3** | Verify that defined sensitive data is not sent to untrusted parties (e.g., user trackers) to prevent unwanted collection of data outside of the application's control. | 2 |\n| **14.2.4** | Verify that controls around sensitive data related to encryption, integrity verification, retention, how the data is to be logged, access controls around sensitive data in logs, privacy and privacy-enhancing technologies, are implemented as defined in the documentation for the specific data's protection level. | 2 |\n| **14.2.5** | Verify that caching mechanisms are configured to only cache responses which have the expected content type for that resource and do not contain sensitive, dynamic content. The web server should return a 404 or 302 response when a non-existent file is accessed rather than returning a different, valid file. This should prevent Web Cache Deception attacks. | 3 |\n| **14.2.6** | Verify that the application only returns the minimum required sensitive data for the application's functionality. For example, only returning some of the digits of a credit card number and not the full number. If the complete data is required, it should be masked in the user interface unless the user specifically views it. | 3 |\n| **14.2.7** | Verify that sensitive information is subject to data retention classification, ensuring that outdated or unnecessary data is deleted automatically, on a defined schedule, or as the situation requires. | 3 |\n| **14.2.8** | Verify that sensitive information is removed from the metadata of user-submitted files unless storage is consented to by the user. | 3 |\n\n## V14.3 Client-side Data Protection\n\nThis section contains requirements preventing data from leaking in specific ways at the client or user agent side of an application.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **14.3.1** | Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated. The 'Clear-Site-Data' HTTP response header field may be able to help with this but the client-side should also be able to clear up if the server connection is not available when the session is terminated. | 1 |\n| **14.3.2** | Verify that the application sets sufficient anti-caching HTTP response header fields (i.e., Cache-Control: no-store) so that sensitive data is not cached in browsers. | 2 |\n| **14.3.3** | Verify that data stored in browser storage (such as localStorage, sessionStorage, IndexedDB, or cookies) does not contain sensitive data, with the exception of session tokens. | 2 |\n\n## References\n\nFor more information, see also:\n\n* [Consider using the Security Headers website to check security and anti-caching header fields](https://securityheaders.com/)\n* [Documentation about anti-caching headers by Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [Australian Privacy Principle 11 - Security of personal information](https://www.oaic.gov.au/privacy/australian-privacy-principles/australian-privacy-principles-guidelines/chapter-11-app-11-security-of-personal-information)\n* [European Union General Data Protection Regulation (GDPR) overview](https://www.edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://www.edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n* [Information on the \"Clear-Site-Data\" header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data)\n* [White paper on Web Cache Deception](https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack-wp.pdf)\n", "timestamp": "2025-10-24T11:40:08.156352"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x24-V15-Secure-Coding-and-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x24-V15-Secure-Coding-and-Architecture.md", "content": "# V15 Secure Coding and Architecture\n\n## Control Objective\n\nMany ASVS requirements either relate to a particular area of security, such as authentication or authorization, or pertain to a particular type of application functionality, such as logging or file handling.\n\nThis chapter provides general security requirements to consider when designing and developing applications. These requirements focus not only on clean architecture and code quality but also on specific architecture and coding practices necessary for application security.\n\n## V15.1 Secure Coding and Architecture Documentation\n\nMany requirements for establishing a secure and defensible architecture depend on clear documentation of decisions made regarding the implementation of specific security controls and the components used within the application.\n\nThis section outlines the documentation requirements, including identifying components considered to contain \"dangerous functionality\" or to be \"risky components.\"\n\nA component with \"dangerous functionality\" may be an internally developed or third-party component that performs operations such as deserialization of untrusted data, raw file or binary data parsing, dynamic code execution, or direct memory manipulation. Vulnerabilities in these types of operations pose a high risk of compromising the application and potentially exposing its underlying infrastructure.\n\nA \"risky component\" is a 3rd party library (i.e., not internally developed) with missing or poorly implemented security controls around its development processes or functionality. Examples include components that are poorly maintained, unsupported, at the end-of-life stage, or have a history of significant vulnerabilities.\n\nThis section also emphasizes the importance of defining appropriate timeframes for addressing vulnerabilities in third-party components.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **15.1.1** | Verify that application documentation defines risk based remediation time frames for 3rd party component versions with vulnerabilities and for updating libraries in general, to minimize the risk from these components. | 1 |\n| **15.1.2** | Verify that an inventory catalog, such as software bill of materials (SBOM), is maintained of all third-party libraries in use, including verifying that components come from pre-defined, trusted, and continually maintained repositories. | 2 |\n| **15.1.3** | Verify that the application documentation identifies functionality which is time-consuming or resource-demanding. This must include how to prevent a loss of availability due to overusing this functionality and how to avoid a situation where building a response takes longer than the consumer's timeout. Potential defenses may include asynchronous processing, using queues, and limiting parallel processes per user and per application. | 2 |\n| **15.1.4** | Verify that application documentation highlights third-party libraries which are considered to be \"risky components\". | 3 |\n| **15.1.5** | Verify that application documentation highlights parts of the application where \"dangerous functionality\" is being used. | 3 |\n\n## V15.2 Security Architecture and Dependencies\n\nThis section includes requirements for handling risky, outdated, or insecure dependencies and components through dependency management.\n\nIt also includes using architectural-level techniques such as sandboxing, encapsulation, containerization, and network isolation to reduce the impact of using \"dangerous operations\" or \"risky components\" (as defined in the previous section) and prevent loss of availability due to overusing resource-demanding functionality.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **15.2.1** | Verify that the application only contains components which have not breached the documented update and remediation time frames. | 1 |\n| **15.2.2** | Verify that the application has implemented defenses against loss of availability due to functionality which is time-consuming or resource-demanding, based on the documented security decisions and strategies for this. | 2 |\n| **15.2.3** | Verify that the production environment only includes functionality that is required for the application to function, and does not expose extraneous functionality such as test code, sample snippets, and development functionality. | 2 |\n| **15.2.4** | Verify that third-party components and all of their transitive dependencies are included from the expected repository, whether internally owned or an external source, and that there is no risk of a dependency confusion attack. | 3 |\n| **15.2.5** | Verify that the application implements additional protections around parts of the application which are documented as containing \"dangerous functionality\" or using third-party libraries considered to be \"risky components\". This could include techniques such as sandboxing, encapsulation, containerization or network level isolation to delay and deter attackers who compromise one part of an application from pivoting elsewhere in the application. | 3 |\n\n## V15.3 Defensive Coding\n\nThis section covers vulnerability types, including type juggling, prototype pollution, and others, which result from using insecure coding patterns in a particular language. Some may not be relevant to all languages, whereas others will have language-specific fixes or may relate to how a particular language or framework handles a feature such as HTTP parameters. It also considers the risk of not cryptographically validating application updates.\n\nIt also considers the risks associated with using objects to represent data items and accepting and returning these via external APIs. In this case, the application must ensure that data fields that should not be writable are not modified by user input (mass assignment) and that the API is selective about what data fields get returned. Where field access depends on a user's permissions, this should be considered in the context of the field-level access control requirement in the Authorization chapter.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **15.3.1** | Verify that the application only returns the required subset of fields from a data object. For example, it should not return an entire data object, as some individual fields should not be accessible to users. | 1 |\n| **15.3.2** | Verify that where the application backend makes calls to external URLs, it is configured to not follow redirects unless it is intended functionality. | 2 |\n| **15.3.3** | Verify that the application has countermeasures to protect against mass assignment attacks by limiting allowed fields per controller and action, e.g., it is not possible to insert or update a field value when it was not intended to be part of that action. | 2 |\n| **15.3.4** | Verify that all proxying and middleware components transfer the user's original IP address correctly using trusted data fields that cannot be manipulated by the end user, and the application and web server use this correct value for logging and security decisions such as rate limiting, taking into account that even the original IP address may not be reliable due to dynamic IPs, VPNs, or corporate firewalls. | 2 |\n| **15.3.5** | Verify that the application explicitly ensures that variables are of the correct type and performs strict equality and comparator operations. This is to avoid type juggling or type confusion vulnerabilities caused by the application code making an assumption about a variable type. | 2 |\n| **15.3.6** | Verify that JavaScript code is written in a way that prevents prototype pollution, for example, by using Set() or Map() instead of object literals. | 2 |\n| **15.3.7** | Verify that the application has defenses against HTTP parameter pollution attacks, particularly if the application framework makes no distinction about the source of request parameters (query string, body parameters, cookies, or header fields). | 2 |\n\n## V15.4 Safe Concurrency\n\nConcurrency issues such as race conditions, time-of-check to time-of-use (TOCTOU) vulnerabilities, deadlocks, livelocks, thread starvation, and improper synchronization can lead to unpredictable behavior and security risks. This section includes various techniques and strategies to help mitigate these risks.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **15.4.1** | Verify that shared objects in multi-threaded code (such as caches, files, or in-memory objects accessed by multiple threads) are accessed safely by using thread-safe types and synchronization mechanisms like locks or semaphores to avoid race conditions and data corruption. | 3 |\n| **15.4.2** | Verify that checks on a resource's state, such as its existence or permissions, and the actions that depend on them are performed as a single atomic operation to prevent time-of-check to time-of-use (TOCTOU) race conditions. For example, checking if a file exists before opening it, or verifying a user’s access before granting it. | 3 |\n| **15.4.3** | Verify that locks are used consistently to avoid threads getting stuck, whether by waiting on each other or retrying endlessly, and that locking logic stays within the code responsible for managing the resource to ensure locks cannot be inadvertently or maliciously modified by external classes or code. | 3 |\n| **15.4.4** | Verify that resource allocation policies prevent thread starvation by ensuring fair access to resources, such as by leveraging thread pools, allowing lower-priority threads to proceed within a reasonable timeframe. | 3 |\n\n## References\n\nFor more information, see also:\n\n* [OWASP Prototype Pollution Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.html)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [OWASP CycloneDX Bill of Materials Specification](https://owasp.org/www-project-cyclonedx/)\n* [OWASP Web Security Testing Guide: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution)\n", "timestamp": "2025-10-24T11:40:08.234917"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x25-V16-Security-Logging-and-Error-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x25-V16-Security-Logging-and-Error-Handling.md", "content": "# V16 Security Logging and Error Handling\n\n## Control Objective\n\nSecurity logs are distinct from error or performance logs and are used to record security-relevant events such as authentication decisions, access control decisions, and attempts to bypass security controls, such as input validation or business logic validation. Their purpose is to support detection, response, and investigation by providing high-signal, structured data for analysis tools like SIEMs.\n\nLogs should not include sensitive personal data unless legally required, and any logged data must be protected as a high-value asset. Logging must not compromise privacy or system security. Applications must also fail securely, avoiding unnecessary disclosure or disruption.\n\nFor detailed implementation guidance, refer to the OWASP Cheat Sheets in the references section.\n\n## V16.1 Security Logging Documentation\n\nThis section ensures a clear and complete inventory of logging across the application stack. This is essential for effective security monitoring, incident response, and compliance.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **16.1.1** | Verify that an inventory exists documenting the logging performed at each layer of the application's technology stack, what events are being logged, log formats, where that logging is stored, how it is used, how access to it is controlled, and for how long logs are kept. | 2 |\n\n## V16.2 General Logging\n\nThis section provides requirements to ensure that security logs are consistently structured and contain the expected metadata. The goal is to make logs machine-readable and analyzable across distributed systems and tools.\n\nNaturally, security events often involve sensitive data. If such data is logged without consideration, the logs themselves become classified and therefore subject to encryption requirements, stricter retention policies, and potential disclosure during audits.\n\nTherefore, it is critical to log only what is necessary and to treat log data with the same care as other sensitive assets.\n\nThe requirements below establish foundational requirements for logging metadata, synchronization, format, and control.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **16.2.1** | Verify that each log entry includes necessary metadata (such as when, where, who, what) that would allow for a detailed investigation of the timeline when an event happens. | 2 |\n| **16.2.2** | Verify that time sources for all logging components are synchronized, and that timestamps in security event metadata use UTC or include an explicit time zone offset. UTC is recommended to ensure consistency across distributed systems and to prevent confusion during daylight saving time transitions. | 2 |\n| **16.2.3** | Verify that the application only stores or broadcasts logs to the files and services that are documented in the log inventory. | 2 |\n| **16.2.4** | Verify that logs can be read and correlated by the log processor that is in use, preferably by using a common logging format. | 2 |\n| **16.2.5** | Verify that when logging sensitive data, the application enforces logging based on the data's protection level. For example, it may not be allowed to log certain data, such as credentials or payment details. Other data, such as session tokens, may only be logged by being hashed or masked, either in full or partially. | 2 |\n\n## V16.3 Security Events\n\nThis section defines requirements for logging security-relevant events within the application. Capturing these events is critical for detecting suspicious behavior, supporting investigations, and fulfilling compliance obligations.\n\nThis section outlines the types of events that should be logged but does not attempt to provide exhaustive detail. Each application has unique risk factors and operational context.\n\nNote that while ASVS includes logging of security events in scope, alerting and correlation (e.g., SIEM rules or monitoring infrastructure) are considered out of scope and are handled by operational and monitoring systems.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **16.3.1** | Verify that all authentication operations are logged, including successful and unsuccessful attempts. Additional metadata, such as the type of authentication or factors used, should also be collected. | 2 |\n| **16.3.2** | Verify that failed authorization attempts are logged. For L3, this must include logging all authorization decisions, including logging when sensitive data is accessed (without logging the sensitive data itself). | 2 |\n| **16.3.3** | Verify that the application logs the security events that are defined in the documentation and also logs attempts to bypass the security controls, such as input validation, business logic, and anti-automation. | 2 |\n| **16.3.4** | Verify that the application logs unexpected errors and security control failures such as backend TLS failures. | 2 |\n\n## V16.4 Log Protection\n\nLogs are valuable forensic artifacts and must be protected. If logs can be easily modified or deleted, they lose their integrity and become unreliable for incident investigations or legal proceedings. Logs may expose internal application behavior or sensitive metadata, making them an attractive target for attackers.\n\nThis section defines requirements to ensure that logs are protected from unauthorized access, tampering, and disclosure, and that they are safely transmitted and stored in secure, isolated systems.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **16.4.1** | Verify that all logging components appropriately encode data to prevent log injection. | 2 |\n| **16.4.2** | Verify that logs are protected from unauthorized access and cannot be modified. | 2 |\n| **16.4.3** | Verify that logs are securely transmitted to a logically separate system for analysis, detection, alerting, and escalation. The aim is to ensure that if the application is breached, the logs are not compromised. | 2 |\n\n## V16.5 Error Handling\n\nThis section defines requirements to ensure that applications fail gracefully and securely without disclosing sensitive internal details.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **16.5.1** | Verify that a generic message is returned to the consumer when an unexpected or security-sensitive error occurs, ensuring no exposure of sensitive internal system data such as stack traces, queries, secret keys, and tokens. | 2 |\n| **16.5.2** | Verify that the application continues to operate securely when external resource access fails, for example, by using patterns such as circuit breakers or graceful degradation. | 2 |\n| **16.5.3** | Verify that the application fails gracefully and securely, including when an exception occurs, preventing fail-open conditions such as processing a transaction despite errors resulting from validation logic. | 2 |\n| **16.5.4** | Verify that a \"last resort\" error handler is defined which will catch all unhandled exceptions. This is both to avoid losing error details that must go to log files and to ensure that an error does not take down the entire application process, leading to a loss of availability. | 3 |\n\nNote: Certain languages, (including Swift, Go, and through common design practice, many functional languages,) do not support exceptions or last-resort event handlers. In this case, architects and developers should use a pattern, language, or framework-friendly way to ensure that applications can securely handle exceptional, unexpected, or security-related events.\n\n## References\n\nFor more information, see also:\n\n* [OWASP Web Security Testing Guide: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n* [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* [OWASP Application Logging Vocabulary Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Vocabulary_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:08.309958"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x26-V17-WebRTC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x26-V17-WebRTC.md", "content": "# V17 WebRTC\n\n## Control Objective\n\nWeb Real-Time Communication (WebRTC) enables real-time voice, video, and data exchange in modern applications. As adoption increases, securing WebRTC infrastructure becomes critical. This section provides security requirements for stakeholders who develop, host, or integrate WebRTC systems.\n\nThe WebRTC market can be broadly categorized into three segments:\n\n1. Product Developers: Proprietary and open-source vendors that create and supply WebRTC products and solutions. Their focus is on developing robust and secure WebRTC technologies that can be used by others.\n\n2. Communication Platforms as a Service (CPaaS): Providers that offer APIs, SDKs, and the necessary infrastructure or platforms to enable WebRTC functionalities. CPaaS providers may use products from the first category or develop their own WebRTC software to offer these services.\n\n3. Service Providers: Organizations that leverage products from product developers or CPaaS providers, or develop their own WebRTC solutions. They create and implement applications for online conferencing, healthcare, e-learning, and other domains where real-time communication is crucial.\n\nThe security requirements outlined here are primarily focused on Product Developers, CPaaS, and Service Providers who:\n\n* Utilize open-source solutions to build their WebRTC applications.\n* Use commercial WebRTC products as part of their infrastructure.\n* Use internally developed WebRTC solutions or integrate various components into a cohesive service offering.\n\nIt is important to note that these security requirements do not apply to developers who exclusively use SDKs and APIs provided by CPaaS vendors. For such developers, the CPaaS providers are typically responsible for most of the underlying security concerns within their platforms, and a generic security standard like ASVS may not fully address their needs.\n\n## V17.1 TURN Server\n\nThis section defines security requirements for systems that operate their own TURN (Traversal Using Relays around NAT) servers. TURN servers assist in relaying media in restrictive network environments but can pose risks if misconfigured. These controls focus on secure address filtering and protection against resource exhaustion.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **17.1.1** | Verify that the Traversal Using Relays around NAT (TURN) service only allows access to IP addresses that are not reserved for special purposes (e.g., internal networks, broadcast, loopback). Note that this applies to both IPv4 and IPv6 addresses. | 2 |\n| **17.1.2** | Verify that the Traversal Using Relays around NAT (TURN) service is not susceptible to resource exhaustion when legitimate users attempt to open a large number of ports on the TURN server. | 3 |\n\n## V17.2 Media\n\nThese requirements only apply to systems that host their own WebRTC media servers, such as Selective Forwarding Units (SFUs), Multipoint Control Units (MCUs), recording servers, or gateway servers. Media servers handle and distribute media streams, making their security critical to protect communication between peers. Safeguarding media streams is paramount in WebRTC applications to prevent eavesdropping, tampering, and denial-of-service attacks that could compromise user privacy and communication quality.\n\nIn particular, it is necessary to implement protections against flood attacks such as rate limiting, validating timestamps, using synchronized clocks to match real-time intervals, and managing buffers to prevent overflow and maintain proper timing. If packets for a particular media session arrive too quickly, excess packets should be dropped. It is also important to protect the system from malformed packets by implementing input validation, safely handling integer overflows, preventing buffer overflows, and employing other robust error-handling techniques.\n\nSystems that rely solely on peer-to-peer media communication between web browsers, without the involvement of intermediate media servers, are excluded from these specific media-related security requirements.\n\nThis section refers to the use of Datagram Transport Layer Security (DTLS) in the context of WebRTC. A requirement related to having a documented policy for the management of cryptographic keys can be found in the \"Cryptography\" chapter. Information on approved cryptographic methods can be found either in the Cryptography Appendix of the ASVS or in documents such as NIST SP 800‑52 Rev. 2 or BSI TR‑02102‑2 (Version 2025‑01).\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **17.2.1** | Verify that the key for the Datagram Transport Layer Security (DTLS) certificate is managed and protected based on the documented policy for management of cryptographic keys. | 2 |\n| **17.2.2** | Verify that the media server is configured to use and support approved Datagram Transport Layer Security (DTLS) cipher suites and a secure protection profile for the DTLS Extension for establishing keys for the Secure Real-time Transport Protocol (DTLS-SRTP). | 2 |\n| **17.2.3** | Verify that Secure Real-time Transport Protocol (SRTP) authentication is checked at the media server to prevent Real-time Transport Protocol (RTP) injection attacks from leading to either a Denial of Service condition or audio or video media insertion into media streams. | 2 |\n| **17.2.4** | Verify that the media server is able to continue processing incoming media traffic when encountering malformed Secure Real-time Transport Protocol (SRTP) packets. | 2 |\n| **17.2.5** | Verify that the media server is able to continue processing incoming media traffic during a flood of Secure Real-time Transport Protocol (SRTP) packets from legitimate users. | 3 |\n| **17.2.6** | Verify that the media server is not susceptible to the \"ClientHello\" Race Condition vulnerability in Datagram Transport Layer Security (DTLS) by checking if the media server is publicly known to be vulnerable or by performing the race condition test. | 3 |\n| **17.2.7** | Verify that any audio or video recording mechanisms associated with the media server are able to continue processing incoming media traffic during a flood of Secure Real-time Transport Protocol (SRTP) packets from legitimate users. | 3 |\n| **17.2.8** | Verify that the Datagram Transport Layer Security (DTLS) certificate is checked against the Session Description Protocol (SDP) fingerprint attribute, terminating the media stream if the check fails, to ensure the authenticity of the media stream. | 3 |\n\n## V17.3 Signaling\n\nThis section defines requirements for systems that operate their own WebRTC signaling servers. Signaling coordinates peer-to-peer communication and must be resilient against attacks that could disrupt session establishment or control.\n\nTo ensure secure signaling, systems must handle malformed inputs gracefully and remain available under load.\n\n| # | Description | Level |\n| :---: | :--- | :---: |\n| **17.3.1** | Verify that the signaling server is able to continue processing legitimate incoming signaling messages during a flood attack. This should be achieved by implementing rate limiting at the signaling level. | 2 |\n| **17.3.2** | Verify that the signaling server is able to continue processing legitimate signaling messages when encountering malformed signaling message that could cause a denial of service condition. This could include implementing input validation, safely handling integer overflows, preventing buffer overflows, and employing other robust error-handling techniques. | 2 |\n\n## References\n\nFor more information, see also:\n\n* The WebRTC DTLS ClientHello DoS is best documented at [Enable Security's blog post aimed at security professionals](https://www.enablesecurity.com/blog/novel-dos-vulnerability-affecting-webrtc-media-servers/) and the associated [white paper aimed at WebRTC developers](https://www.enablesecurity.com/blog/webrtc-hello-race-conditions-paper/)\n* [RFC 3550 - RTP: A Transport Protocol for Real-Time Applications](https://www.rfc-editor.org/rfc/rfc3550)\n* [RFC 3711 - The Secure Real-time Transport Protocol (SRTP)](https://datatracker.ietf.org/doc/html/rfc3711)\n* [RFC 5764 - Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP))](https://datatracker.ietf.org/doc/html/rfc5764)\n* [RFC 8825 - Overview: Real-Time Protocols for Browser-Based Applications](https://www.rfc-editor.org/info/rfc8825)\n* [RFC 8826 - Security Considerations for WebRTC](https://www.rfc-editor.org/info/rfc8826)\n* [RFC 8827 - WebRTC Security Architecture](https://www.rfc-editor.org/info/rfc8827)\n* [DTLS-SRTP Protection Profiles](https://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml)\n", "timestamp": "2025-10-24T11:40:08.383716"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x90-Appendix-A_Glossary.md", "content": "# Appendix A: Glossary\n\n* **Absolute Maximum Session Lifetime** – Also referred to as \"Overall Timeout\" by NIST, this is the maximal amount of time a session can remain active following authentication regardless of user interaction. This is a component of session expiration.\n* **Allowlist** – A list of permitted data or operations, for example, a list of characters that are allowed to perform input validation.\n* **Anti-forgery token** – A mechanism by which one or more tokens are passed in a request and validated by the application server to ensure that the request has come from an expected endpoint.\n* **Application Security** – Application-level security focuses on the analysis of components that comprise the application layer of the Open Systems Interconnection Reference Model (OSI Model), rather than focusing on for example the underlying operating system or connected networks.\n* **Application Security Verification** – The technical assessment of an application against the OWASP ASVS.\n* **Application Security Verification Report** – A report that documents the overall results and supporting analysis produced by the verifier for a particular application.\n* **Authentication** – The verification of the claimed identity of an application user.\n* **Automated Verification** – The use of automated tools (either dynamic analysis tools, static analysis tools, or both) that use vulnerability signatures to find problems.\n* **Black box testing** – A method of software testing that examines the functionality of an application without peering into its internal structures or workings.\n* **Common Weakness Enumeration** (CWE) – A community-developed list of common software security weaknesses. It serves as a common language, a measuring stick for software security tools, and a baseline for weakness identification, mitigation, and prevention efforts.\n* **Component** – A self-contained unit of code, with associated disk and network interfaces that communicates with other components.\n* **Credential Service Provider** (CSP) – Also called an Identity Provider (IdP). A source of user data which may be used as an authentication source by other applications.\n* **Cross-Site Script Inclusion** (XSSI) - A variant of Cross-Site Scripting (XSS) attack in which a web application retrieves malicious code from an external resource and includes that code as part of its own content.\n* **Cross-Site Scripting** (XSS) – A security vulnerability typically found in web applications allowing the injection of client-side scripts into content.\n* **Cryptographic module** – Hardware, software, and/or firmware that implements cryptographic algorithms and/or generates cryptographic keys.\n* **Cryptographically secure pseudo-random number generator** (CSPRNG) - A pseudorandom number generator with properties that make it suitable for use in cryptography, also referred to as a cryptographic random number generator (CRNG).\n* **Datagram Transport Layer Security** (DTLS) – A cryptographic protocol which provides communication security over a network connection. It is based on the TLS protocol but adapted for protecting datagram-oriented protocols (usually over UDP). Defined in RFC 9147 for DTLS 1.3.\n* **Datagram Transport Layer Security Extension to Establish Keys for the Secure Real-time Transport Protocol** (DTLS-SRTP) – A mechanism for using a DTLS handshake for establishing key material for a SRTP session. Defined in RFC 5764.\n* **Design Verification** – The technical assessment of the security architecture of an application.\n* **Dynamic Application Security Testing** (DAST) – Technologies are designed to detect conditions indicative of a security vulnerability in an application in its running state.\n* **Dynamic Verification** – The use of automated tools that use vulnerability signatures to find problems during the execution of an application.\n* **Fast IDentity Online** (FIDO) – A set of authentication standards that allow a variety of different authentication methods to be used including biometrics, Trusted Platform Modules (TPMs), USB security tokens, etc.\n* **Hardware Security Module** (HSM) – Hardware component that stores cryptographic keys and other secrets in a protected manner.\n* **Hibernate Query Language** (HQL) – A query language that is similar in appearance to SQL used by the Hibernate ORM library.\n* **HTTP Strict Transport Security** (HSTS) – An policy which instructs the browser to only connect to the domain returning the header via TLS and when a valid certificate is presented. It is activated using the Strict-Transport-Security response header field.\n* **HyperText Transfer Protocol** (HTTP) – An application protocol for distributed, collaborative, hypermedia information systems. It is the foundation of data communication for the World Wide Web.\n* **HyperText Transfer Protocol over SSL/TLS** (HTTPS) – A method of securing HTTP communication by encrypting it using Transport Layer Security (TLS).\n* **Identity Provider** (IdP) – Also called a Credential Service Provider (CSP) in NIST references. An entity that provides an authentication source for other applications.\n* **Inactivity Timeout** – This is the length of time a session can remain active in the absence of user interaction with the application. This is a component of session expiration.\n* **Input Validation** – The canonicalization and validation of untrusted user input.\n* **JSON Web Token** (JWT) – RFC 7519 defines a standard for a JSON data object made up of a header section which explains how to validate the object, a body section containing a set of claims, and a signature section which contains a digital signature which can be used to validate the contents of the body section. It is a type of self-contained token.\n* **Local File Inclusion** (LFI) - An attack that exploits vulnerable file inclusion procedures in an application, leading to the inclusion of local files already present on the server.\n* **Malicious Code** – Code introduced into an application during its development unbeknownst to the application owner, which circumvents the application's intended security policy. Not the same as malware such as a virus or worm!\n* **Malware** – Executable code that is introduced into an application during runtime without the knowledge of the application user or administrator.\n* **Message authentication code** (MAC) - A cryptographic checksum on data, computed by a MAC generation algorithm, that is used to provide assurance on its integrity and authenticity.\n* **Multi-factor authentication** (MFA) – Authentication which includes two or more of the single factors.\n* **Mutual TLS** (mTLS) – See TLS client authentication.\n* **Object-relational Mapping** (ORM) – A system used to allow a relational/table-based database to be referenced and queried within an application program using an application-compatible object model.\n* **One-time Password** (OTP) – A password that is uniquely generated to be used on a single occasion.\n* **Open Worldwide Application Security Project** (OWASP) – The Open Worldwide Application Security Project (OWASP) is a worldwide free and open community focused on improving the security of application software. Our mission is to make application security \"visible,\" so that people and organizations can make informed decisions about application security risks. See: [https://www.owasp.org/](https://www.owasp.org/).\n* **Password-Based Key Derivation Function 2** (PBKDF2) – A special one-way algorithm used to create a strong cryptographic key from an input text (such as a password) and an additional random salt value and can therefore be used to make it harder to crack a password offline if the resulting value is stored instead of the original password.\n* **Public Key Infrastructure** (PKI) – An arrangement that binds public keys with respective identities of entities. The binding is established through a process of registration and issuance of certificates at and by a certificate authority (CA).\n* **Public Switched Telephone Network** (PSTN) – The traditional telephone network that includes both fixed-line telephones and mobile telephones.\n* **Real-time Transport Protocol** (RTP) and **Real-time Transport Control Protocol** (RTCP) – Two protocols used in association for transporting multimedia streams. Used by the WebRTC stack. Defined in RFC 3550.\n* **Reference Token** – A type of token that acts as a pointer or identifier to state or metadata stored on a server, sometimes referred to as random tokens or opaque tokens. Unlike self-contained tokens, which embed some of their relevant data within the token itself, reference tokens contain no intrinsic information, instead relying on the server for context. The reference token will either be or contain a session identifier.\n* **Relying Party** (RP) – Generally an application which is relying on a user having authenticated against a separate authentication provider. The application relies on some sort of token or set of signed assertions provided by that authentication provider to trust that the user is who they say they are.\n* **Remote File Inclusion** (RFI) - An attack that exploits vulnerable inclusion procedures in the application, resulting in the inclusion of remote files.\n* **Scalable Vector Graphics** (SVG) – An XML-based markup language for describing two-dimensional based vector graphics.\n* **Secure Real-time Transport Protocol** (SRTP) and **Secure Real-time Transport Control Protocol** (SRTCP) – A profile of the RTP and RTCP protocols providing support for message encryption, authentication and integrity protection. Defined in RFC 3711.\n* **Security Architecture** – An abstraction of an application's design that identifies and describes where and how security controls are used, and also identifies and describes the location and sensitivity of both user and application data.\n* **Security Assertion Markup Language** (SAML) – An open standard for single sign-on authentication based on passing signed assertions (usually XML objects) between the identity provider and the relying party.\n* **Security Configuration** – The runtime configuration of an application that affects how security controls are used.\n* **Security Control** – A function or component that performs a security check (e.g., an authorization check) or when called results in a security effect (e.g., generating an audit record).\n* **Security information and event management** (SIEM) - A system for threat detection, compliance and security incident management through the collection and analysis of security-related data from various sources within an organization's IT infrastructure.\n* **Self-Contained Token** – A token that encapsulates one or more attributes that do not rely on server-side state or other external storage. These tokens ensure the authenticity and integrity of their contained attributes, enabling secure, \"stateless\" information exchange across systems. Self-contained tokens are generally secured using cryptographic techniques, such as digital signatures or message authentication codes (MACs), to ensure the authenticity, integrity, and in some cases the confidentiality of its data. Common examples include SAML Assertions and JWTs.\n* **Server-side Request Forgery** (SSRF) – An attack that abuses functionality on the server to read or update internal resources. The attacker supplies or modifies a URL, which the code running on the server will read or submit data to.\n* **Session Description Protocol** (SDP) – A message format for setting up multimedia session (used for example in WebRTC). Defined in RFC 4566.\n* **Session Identifier** or **Session ID** – A key which identifies a stateful session stored at the back end. Will be transferred to and from the client either as or inside a \"Reference Token\".\n* **Session Token** – A \"catch-all\" phrase used in this standard to refer to the token or value used in either stateless session mechanisms (which use a self-contained token) or stateful session mechanisms (which use a reference token).\n* **Session Traversal Utilities for NAT** (STUN) – A protocol used to assist NAT traversal in order to establish peer-to-peer communications. Defined in RFC 3489.\n* **Single-factor authenticator** – A mechanism to check that a user is authenticated. It should either be something you know (memorized secrets, passwords, passphrases, PINs), something you are (biometrics, fingerprint, face scans), or something you have (OTP tokens, a cryptographic device such as a smart card).\n* **Single Sign-on Authentication** (SSO) – This occurs when a user logs into one application and is then automatically logged into other applications without having to re-authenticate. For example, when logging into Google, the user will be automatically logged into other Google services such as YouTube, Google Docs, and Gmail.\n* **Software bill of materials** (SBOM) - A structured, comprehensive list of all components, modules, libraries, frameworks and other resources required to build or assemble a software application.\n* **Software Composition Analysis** (SCA) – A set of technologies designed to analyze application composition, dependencies, libraries and packages for security vulnerabilities of specific component versions in use. This is not to be confused with source-code analysis which is now commonly referred to as SAST.\n* **Software development lifecycle** (SDLC) – The step-by-step process by which software is developed going from the initial requirements to deployment and maintenance.\n* **SQL Injection** (SQLi) – A code injection technique used to attack data-driven applications, in which malicious SQL statements are inserted into an entry point.\n* **Stateful Session Mechanism** – In a stateful session mechanism, the application retains session state at the backend which typically corresponds to a session token, generated using a cryptographically secure pseudo-random number generator (CSPRNG), which is issued to the end user.\n* **Stateless Session Mechanism** – A stateless session mechanism will use a self-contained token which is passed to clients, and contains session information that is not necessarily stored within the service which then receives and validates the token. In reality, a service will need to have access to some session information (such as a JWT revocation list) in order to be able to enforce required security controls.\n* **Static application security testing** (SAST) – A set of technologies designed to analyze application source code, byte code and binaries for coding and design conditions that are indicative of security vulnerabilities. SAST solutions analyze an application from the “inside out” in a non-running state.\n* **Threat Modeling** – A technique consisting of developing increasingly refined security architectures to identify threat agents, security zones, security controls, and important technical and business assets.\n* **Time-of-check to time-of-use** (TOCTOU) – A situation where an application checks the state of a resource before using that resource, but the resource's state can be changed between the check and the use. This can invalidate the results of the check and cause a situation where the application performs invalid actions due to this state mismatch.\n* **Time based One-time Passwords** (TOTPs) - A method of generating an OTP where the current time acts as part of the algorithm to generate the password.\n* **TLS client authentication**, also called **Mutual TLS** (mTLS) – In a standard TLS connection, a client can use the certificate provided by the server to validate the server's identity. Where TLS client authentication is used, the client also uses its own private key and certificate to allow the server to also validate the client's identity.\n* **Transport Layer Security** (TLS) – Cryptographic protocols that provide communication security over a network connection.\n* **Traversal Using Relays around NAT** (TURN) – An extension of the STUN protocol using a TURN server as a relay when direct peer-to-peer connections cannot be established. Defined in RFC 8656.\n* **Trusted execution environment** (TEE) - An isolated processing environment in which applications can be securely executed irrespective of the rest of the system.\n* **Trusted Platform Module** (TPM) – A type of HSM that is usually attached to a larger hardware component such as a motherboard and acts as the \"root of trust\" for that system.\n* **Trusted Service Layer** – Any trusted control enforcement point, such as a microservice, serverless API, server-side, a trusted API on a client device that has secure boot, partner or external APIs, and so on. Trusted means that there is no concern that an untrusted user will be able to bypass or skip the layer or controls implemented at that layer.\n* **Uniform Resource Identifier** (URI)- A unique string of characters that identifies a resource, such as webpage, mail address, places.\n* **Uniform Resource Locator** (URL) – A string that specifies the location of resource on the Internet.\n* **Universally Unique Identifier** (UUID) – A unique reference number used as an identifier in software.\n* **Verifier** – The person or team that is reviewing an application against the OWASP ASVS requirements.\n* **Web Real-Time Communication** (WebRTC) – A protocol stack and associated web API used for the transport of multimedia streams in web applications, usually in the context of teleconferencing. Based on SRTP, SRTCP, DTLS, SDP and STUN/TURN.\n* **WebSocket over TLS** (WSS) – A practice of securing WebSocket communication by layering WebSocket over TLS protocol.\n* **What You See Is What You Get** (WYSIWYG) – A type of rich content editor that shows how the content will actually look when rendered rather than showing the coding used to govern the rendering.\n* **X.509 Certificate** – An X.509 certificate is a digital certificate that uses the widely accepted international X.509 public key infrastructure (PKI) standard to verify that a public key belongs to the user, computer or service identity contained within the certificate.\n* **XML eXternal Entity** (XXE) – A type of XML entity that can access local or remote content via a declared system identifier. This may lead to various injection attacks.\n", "timestamp": "2025-10-24T11:40:08.527761"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x91-Appendix-B_References.md", "content": "# Appendix B: References\n\nThe following OWASP projects are most likely to be useful to users/adopters of this standard:\n\n## OWASP Core Projects\n\n1. OWASP Top 10 Project: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n5. OWASP Secure Headers Project: [https://owasp.org/www-project-secure-headers/](https://owasp.org/www-project-secure-headers/)\n\n## OWASP Cheat Sheet Series project\n\n[This project](https://owasp.org/www-project-cheat-sheets/) has several cheat sheets that will be relevant to different topics in the ASVS.\n\nThere is a mapping to the ASVS which can be found here: [https://cheatsheetseries.owasp.org/IndexASVS.html](https://cheatsheetseries.owasp.org/IndexASVS.html)\n\n## Mobile Security Related Projects\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## OWASP Internet of Things related projects\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## OWASP Serverless projects\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Others\n\nSimilarly, the following websites are most likely to be useful to users/adopters of this standard\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n7. OWASP ASVS 4.0 Testing Guide [https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide](https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide)\n", "timestamp": "2025-10-24T11:40:08.596299"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x92-Appendix-C_Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x92-Appendix-C_Cryptography.md", "content": "# Appendix C: Cryptography Standards\n\nThe \"Cryptography\" chapter goes beyond simply defining best practices. It aims to enhance understanding of cryptography principles and encourage the adoption of more resilient, modern security methods. This appendix provides detailed technical information regarding each requirement, complementing the overarching standards outlined in the \"Cryptography\" chapter.\n\nThis appendix defines the level of approval for different cryptographic mechanisms:\n\n* Approved (A) mechanisms can be used in applications.\n* Legacy mechanisms (L) should not be used in applications but might still be used for compatibility with existing legacy applications or code only. While the usage of such these mechanisms is currently not considered to be a vulnerability in itself, they should be replaced by more secure and future-proof mechanisms as soon as possible.\n* Disallowed mechanisms (D) must not be used because they are currently considered broken or do not provide sufficient security.\n\nThis list may be overridden in the context of a given application for various reasons including:\n\n* new evolutions in the field of cryptography;\n* compliance with regulation.\n\n## Cryptographic Inventory and Documentation\n\nThis section provides additional information\nfor V11.1 Cryptographic Inventory and Documentation.\n\nIt is important to ensure that all cryptographic assets, such as algorithms, keys, and certificates, are regularly discovered, inventoried, and assessed. For Level 3, this should include the use of static and dynamic scanning to discover the use of cryptography in an application. Tools such as SAST and DAST may help with this but it is possible that dedicated tools would be needed to get more comprehensive coverage. Freeware examples of tools include:\n\n* [CryptoMon - Network Cryptography Monitor - using eBPF, written in python](https://github.com/Santandersecurityresearch/CryptoMon)\n* [Cryptobom Forge Tool: Generating Comprehensive CBOMs from CodeQL Outputs](https://github.com/Santandersecurityresearch/cryptobom-forge)\n\n## Equivalent Strengths of Cryptographic Parameters\n\nThe relative security strengths for various cryptographic systems are in this table (from [NIST SP 800-57 Part 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final), p.71):\n\n| Security Strength | Symmetric Key Algorithms | Finite Field | Integer Factorization | Elliptic Curve |\n|--|--|--|--|--|\n| <= 80 | 2TDEA | L = 1024 <br> N = 160 | k = 1024 | f = 160-223 |\n| 112 | 3TDEA   | L = 2048 <br> N = 224 | k = 2048 | f = 224-255 |\n| 128 | AES-128 | L = 3072 <br> N = 256 | k = 3072 | f = 256-383 |\n| 192 | AES-192 | L = 7680 <br> N = 384 | k = 7680 | f = 384-511 |\n| 256 | AES-256 | L = 15360 <br> N = 512 | k = 15360 | f = 512+ |\n\nExample of applications:\n\n* Finite Field Cryptography: DSA, FFDH, MQV\n* Integer Factorization Cryptography: RSA\n* Elliptic Curve Cryptography: ECDSA, EdDSA, ECDH, MQV\n\nNote: that this section assumes that no quantum computer exists; if such a computer would exist, the estimates for the last 3 columns would be no longer valid.\n\n## Random Values\n\nThis section provides additional information\nfor V11.5 Random Values.\n\n| Name | Version/Reference | Notes | Status |\n|:-:|:-:|:-:|:-:|\n| `/dev/random` | Linux 4.8+ [(Oct 2016)](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=818e607b57c94ade9824dad63a96c2ea6b21baf3), also found in iOS, Android, and other Linux-based POSIX operating systems. Based on [RFC7539](https://datatracker.ietf.org/doc/html/rfc7539) | Utilizing ChaCha20 stream. Found in iOS [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/secrandomcopybytes(_:_:_:)?language=objc) and Android [`Secure Random`](https://developer.android.com/reference/java/security/SecureRandom) with the correct settings provided to each. | A |\n| `/dev/urandom` | Linux kernel's special file for providing random data | Provides high-quality, entropy sources from hardware randomness | A |\n| `AES-CTR-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | As used in common implementations, such as [Windows CNG API `BCryptGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) set by [`BCRYPT_RNG_ALGORITHM`](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers). | A |\n| `HMAC-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `Hash-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `getentropy()` | [OpenBSD](https://man.openbsd.org/getentropy.2), available in [Linux glibc 2.25+](https://man7.org/linux/man-pages/man3/getentropy.3.html) and [macOS 10.12+](https://support.apple.com/en-gb/guide/security/seca0c73a75b/web) | Provides secure random bytes directly from the kernel's entropy source with a straightforward and minimal API. It’s more modern and avoids pitfalls associated with older APIs. | A |\n\nThe underlying hash function used with HMAC-DRBG or Hash-DRBG must be approved for this usage.\n\n## Cipher Algorithms\n\nThis section provides additional information\nfor V11.3 Encryption Algorithms.\n\nApproved cipher algorithms are listed in order of preference.\n\n| Symmetric Key Algorithms | Reference | Status |\n|--|--|--|\n| AES-256 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| Salsa20 | [Salsa 20 specification](https://cr.yp.to/snuffle/spec.pdf) | A |\n| XChaCha20 | [XChaCha20 Draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha-03) | A |\n| XSalsa20 | [Extending the Salsa20 nonce](https://cr.yp.to/snuffle/xsalsa-20110204.pdf) | A |\n| ChaCha20 | [RFC 8439](https://www.rfc-editor.org/info/rfc8439) | A |\n| AES-192 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| AES-128 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | L |\n| 2TDEA | | D |\n| TDEA (3DES/3DEA) | | D |\n| IDEA | | D |\n| RC4 | | D |\n| Blowfish| | D |\n| ARC4 | | D |\n| DES | | D |\n\n### AES Cipher Modes\n\nBlock ciphers, such as AES, can be used with different modes of operations. Many modes of operations, such as Electronic codebook (ECB), are insecure and must not be used. The Galois/Counter Mode (GCM) and Counter with cipher block chaining message authentication code (CCM) modes of operations provide authenticated encryption and should be used in modern applications.\n\nApproved modes are listed in order of preference.\n\n| Mode | Authenticated | Reference | Status | Restriction |\n|--|--|--|--|--|\n| GCM | Yes | [NIST SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A | |\n| CCM | Yes | [NIST SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A | |\n| CBC | No | [NIST SP 800-38A](https://csrc.nist.gov/pubs/sp/800/38/a/final) | L | |\n| CCM-8 | Yes | | D | |\n| ECB | No | | D | |\n| CFB | No | | D | |\n| OFB | No | | D | |\n| CTR | No | | D | |\n\nNotes:\n\n* All encrypted messages must be authenticated. For ANY use of CBC mode there MUST be an associated hashing MAC algorithm to validate the message. In general, this MUST be applied in the Encrypt-Then-Hash method (but TLS 1.2 uses Hash-Then-Encrypt instead). If this cannot be guaranteed, then CBC MUST NOT be used. The only application where encryption without a MAC algorithm is allowed is disk encryption.\n* If CBC is used, it shall be guaranteed that the verification of the padding is performed in constant time.\n* When using CCM-8, the MAC tag only has 64 bits of security. This does not conform to requirement 6.2.9 which requires at least 128 bits of security.\n* Disk encryption is considered out of scope for the ASVS. Therefore this appendix does not list any approved method for disk encryption. For this usage, encryption without authentication is usually accepted and the XTS, XEX and LRW modes are typically used.\n\n### Key Wrapping\n\nCryptographic key wrap (and corresponding key unwrap) is a method of protecting an existing key by encapsulating (i.e., wrapping) it by employing an additional encryption mechanism so that the original key is not obviously exposed, e.g., during a transfer. This additional key used to protect the original key is referred to as the wrap key.\n\nThis operation may be performed when it is desirable to protect keys in places deemed untrustworthy, or to send sensitive keys over untrusted networks or within applications.\nHowever, serious consideration should be given to understanding the nature (e.g., the identity and the purpose) of the original key prior to committing to a wrap/unwrap procedure as this may have repercussions for both source and target systems/applications in terms of security and especially compliance which may include audit trails of a key's function (e.g., signing) as well as appropriate key storage.\n\nSpecifically, AES-256 MUST be used for key wrapping, following [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) and considering forward-looking provisions against the quantum threat. Cipher modes using AES are the following, in order of preference:\n\n| Key Wrapping | Reference | Status |\n|--|--|--|\n| KW | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n| KWP | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n\nAES-192 and AES-128 MAY be used if the use case demands it, but its motivation MUST be documented in the entity's cryptography inventory.\n\n### Authenticated Encryption\n\nWith the exception of disk encryption, encrypted data must be protected against unauthorized modification using some form of authenticated encryption (AE) scheme, usually using an authenticated encryption with associated data (AEAD) scheme.\n\nThe application should preferably use an approved AEAD scheme. It might alternatively combine an approved cipher scheme and an approved MAC algorithm with a Encrypt-then-MAC construct.\n\nMAC-then-encrypt is still allowed for compatibility with legacy applications. It is used in TLS v1.2 with old ciphers suites.\n\n| AEAD mechanism | Reference | Status |\n|--------------------------|---------|-----|\n|AES-GCM | [SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A |\n|AES-CCM  | [SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A |\n|ChaCha-Poly1305 | [RFC 7539](https://datatracker.ietf.org/doc/html/rfc7539) | A |\n|AEGIS-256 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128L| [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|Encrypt-then-MAC | | A |\n|MAC-then-encrypt | | L |\n\n## Hash Functions\n\nThis section provides additional information\nfor V11.4 Hashing and Hash-based Functions.\n\n### Hash Functions for General Use Cases\n\nThe following table lists hash functions approved in general cryptographic use cases such as digital signatures:\n\n* Approved hash functions provide strong collision resistance and are suitable for high-security applications.\n* Some of these algorithms offer strong resistance to attacks when used with proper cryptographic key management, and so are additionally approved for HMAC, KDF, and RBG functions.\n* Hash function with less than 254 bit of output have insufficient collision resistance and must not be used for digital signature or other applications requiring collision resistance. For other usages, they might be used for compatibility and verification ONLY with legacy systems but must not be used in new designs.\n\n| Hash function | Reference | Status | Restrictions |\n| -------------- | ------------------------------------------------------------- |--|--|\n| SHA3-512 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-384 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-384 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512/256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA-256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHAKE256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| BLAKE2s | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE2b | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE3 | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf) | A | |\n| SHA-224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA-512/224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA3-224 | [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA-1 | [RFC 3174](https://www.rfc-editor.org/info/rfc3174) & [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| CRC (any length) |  | D |  |\n| MD4 | [RFC 1320](https://www.rfc-editor.org/info/rfc1320) | D | |\n| MD5 | [RFC 1321](https://www.rfc-editor.org/info/rfc1321) | D | |\n\n### Hash Functions for Password Storage\n\nFor secure password hashing, dedicated hash functions must be used. These slow-hashing algorithms mitigate brute-force and dictionary attacks by increasing the computational difficulty of password cracking.\n\n| KDF | Reference | Required Parameters | Status |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| bcrypt | [A Future-Adaptable Password Scheme](https://www.researchgate.net/publication/2519476_A_Future-Adaptable_Password_Scheme) | cost ≥ 10 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 1,300,000 | L |\n\nApproved password-based key derivations functions can be used for password storage.\n\n## Key Derivation Functions (KDFs)\n\n### General Key Derivation Functions\n\n| KDF              | Reference                                                                                     | Status |\n| ---------------- | --------------------------------------------------------------------------------------------- | ------ |\n| HKDF             | [RFC 5869](https://www.rfc-editor.org/info/rfc5869)                                           | A      |\n| TLS 1.2 PRF      | [RFC 5248](https://www.rfc-editor.org/info/rfc5248)                                           | L      |\n| MD5-based KDFs   | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                           | D      |\n| SHA-1-based KDFs | [RFC 3174](https://www.rfc-editor.org/info/rfc3174) & [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | D      |\n\n### Password-based Key Derivation Functions\n\n| KDF | Reference | Required Parameters | Status |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 1,300,000 | L |\n\n## Key Exchange Mechanisms\n\nThis section provides additional information\nfor V11.6 Public Key Cryptography.\n\n### KEX Schemes\n\nA security strength of 112 bits or above MUST be ensured for all Key Exchange schemes, and their implementation MUST follow the parameter choices in the following table.\n\n| Scheme | Domain Parameters | Forward Secrecy |Status |\n|--|--|--|--|\n| Finite Field Diffie-Hellman (FFDH) | L >= 3072 & N >= 256 | Yes | A |\n| Elliptic Curve Diffie-Hellman (ECDH) | f >= 256-383 | Yes | A |\n| Encrypted key transport with RSA-PKCS#1 v1.5 | | No | D |\n\nWhere the following parameters are:\n\n* k is the key size for RSA keys.\n* L is the size of the public key and N is the size of the private key for finite field cryptography.\n* f is the range of key sizes for ECC.\n\nAny new implementation MUST NOT use any scheme that is NOT compliant with [NIST SP 800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r3/final) & [B](https://csrc.nist.gov/pubs/sp/800/56/b/r2/final) and [NIST SP 800-77](https://csrc.nist.gov/pubs/sp/800/77/r1/final). Specifically, IKEv1 MUST NOT be used in production.\n\n### Diffie-Hellman groups\n\nThe following groups are approved for implementations of Diffie-Hellman key exchange. Security strengths are documented in [NIST SP 800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r3/final), Appendix D, and [NIST SP 800-57 Part 1 Rev.5](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Group            | Status |\n|------------------|--------|\n| P-224, secp224r1 | A      |\n| P-256, secp256r1 | A      |\n| P-384, secp384r1 | A      |\n| P-521, secp521r1 | A      |\n| K-233, sect233k1 | A      |\n| K-283, sect283k1 | A      |\n| K-409, sect409k1 | A      |\n| K-571, sect571k1 | A      |\n| B-233, sect233r1 | A      |\n| B-283, sect283r1 | A      |\n| B-409, sect409r1 | A      |\n| B-571, sect571r1 | A      |\n| Curve448         | A      |\n| Curve25519       | A      |\n| MODP-2048        | A      |\n| MODP-3072        | A      |\n| MODP-4096        | A      |\n| MODP-6144        | A      |\n| MODP-8192        | A      |\n| ffdhe2048        | A      |\n| ffdhe3072        | A      |\n| ffdhe4096        | A      |\n| ffdhe6144        | A      |\n| ffdhe8192        | A      |\n\n## Message Authentication Codes (MAC)\n\nMessage Authentication Codes (MACs) are cryptographic constructs used to verify the integrity and authenticity of a message. A MAC takes a message and a secret key as inputs and produces a fixed-size tag (the MAC value). MACs are widely used in secure communication protocols (e.g., TLS/SSL) to ensure that messages exchanged between parties are authentic and intact.\n\n| MAC Algorithm | Reference                                                                                 | Status | Restrictions |\n| --------------| ----------------------------------------------------------------------------------------- | -------| ------------ |\n| HMAC-SHA-256  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-384  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-512  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| KMAC128       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| KMAC256       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| BLAKE3 (keyed_hash mode) | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf)  | A | |\n| AES-CMAC      | [RFC 4493](https://datatracker.ietf.org/doc/html/rfc4493) & [NIST SP 800-38B](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf) | A | |\n| AES-GMAC      | [NIST SP 800-38D](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)            | A | |\n| Poly1305-AES  | [The Poly1305-AES message-authentication code](https://cr.yp.to/mac/poly1305-20050329.pdf)                  | A | |\n| HMAC-SHA-1    | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | L | |\n| HMAC-MD5      | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                | D      | |\n\n## Digital Signatures\n\nSignature schemes MUST use approved key sizes and parameters per [NIST SP 800-57 Part 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Signature Algorithm            | Reference                                                  | Status |\n| ------------------------------ | ---------------------------------------------------------- | ------ |\n| EdDSA (Ed25519, Ed448)         | [RFC 8032](https://www.rfc-editor.org/info/rfc8032)        | A      |\n| XEdDSA (Curve25519, Curve448)  | [XEdDSA](https://signal.org/docs/specifications/xeddsa/)   | A      |\n| ECDSA (P-256, P-384, P-521)    | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-5/final)  | A      |\n| RSA-RSSA-PSS                   | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | A      |\n| RSA-SSA-PKCS#1 v1.5            | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | D      |\n| DSA (any key size)             | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-4/final)  | D      |\n\n## Post-Quantum Encryption Standards\n\nPost-quantum cryptography (PQC) implementations should follow [FIPS-203](https://csrc.nist.gov/pubs/fips/203/ipd), [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd), and [FIPS-205](https://csrc.nist.gov/pubs/fips/205/ipd). At this time, there are not many hardened code examples or reference implementations available for these standards. For further details, see the [NIST announcement of the first three finalized post-quantum encryption standards (August 2024)](https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards).\n\nThe proposed [mlkem768x25519](https://datatracker.ietf.org/doc/draft-kwiatkowski-tls-ecdhe-mlkem/03/) post-quantum hybrid TLS key agreement method is supported by major browsers such as [Firefox release 132](https://www.mozilla.org/en-US/firefox/132.0/releasenotes/) and [Chrome release 131](https://security.googleblog.com/2024/09/a-new-path-for-kyber-on-web.html). It may be used in cryptographic testing environments or when available within industry- or government-approved libraries.\n", "timestamp": "2025-10-24T11:40:08.670141"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x93-Appendix-D_Recommendations.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x93-Appendix-D_Recommendations.md", "content": "# Appendix D: Recommendations\n\n## Introduction\n\nWhilst preparing version 5.0 of the Application Security Verification Standard (ASVS), it became clear that there were a number of existing and newly suggested items that shouldn't be included as requirements in 5.0. This may have been because they were not in scope for ASVS as per the definition for 5.0 or alternatively it was felt that while they were a good idea, they could not be made mandatory.\n\nNot wanting to lose all these items entirely, some have been captured in this appendix.\n\n## Recommended, in-scope mechanisms\n\nThe following items are in-scope for ASVS. They should not be made mandatory but it is strongly recommended to consider them as part of a secure application.\n\n* A password strength meter should provided to help users set a stronger password.\n* Create a publicly available security.txt file at the root or .well-known directory of the application that clearly defines a link or e-mail address for people to contact owners about security issues.\n* Client-side input validation should be enforced in addition to validation at a trusted service layer as this provides a good opportunity to discover when someone has bypassed client-side controls in an attempt to attack the application.\n* Prevent accidentally accessible and sensitive pages from appearing in search engines using a robots.txt file, the X-Robots-Tag response header or a robots html meta tag.\n* When using GraphQL, implement authorization logic at the business logic layer instead of the GraphQL or resolver layer to avoid having to handle authorization on every separate interface.\n\nReferences:\n\n* [More information on security.txt including a link to the RFC](https://securitytxt.org/)\n\n## Software Security principles\n\nThe following items were previously in ASVS but are not really requirements. Rather they are principles to consider when implementing security controls that when followed will lead to more robust controls. These include:\n\n* Security controls should be centralized, simple (economy of design), verifiably secure, and reusable. This should avoid duplicate, missing, or ineffective controls.\n* Wherever possible, use previously written and well-vetted security control implementations rather than relying on implementing controls from scratch.\n* Ideally, a single access control mechanism should be used to access protected data and resources. All requests should pass through this single mechanism to avoid copy and paste or insecure alternative paths.\n* Attribute or feature-based access control is a recommended pattern whereby the code checks the user's authorization for a feature or data item rather than just their role. Permissions should still be allocated using roles.\n\n## Software Security processes\n\nThere are a number of security processes which were removed from ASVS 5.0 but are still a good idea. The OWASP SAMM project may be a good source for how to effectively implement these processes. The items which were previously in ASVS include:\n\n* Verify the use of a secure software development lifecycle that addresses security in all stages of development.\n* Verify the use of threat modeling for every design change or sprint planning to identify threats, plan for countermeasures, facilitate appropriate risk responses, and guide security testing.\n* Verify that all user stories and features contain functional security constraints, such as \"As a user, I should be able to view and edit my profile. I should not be able to view or edit anyone else's profile\"\n* Verify availability of a secure coding checklist, security requirements, guideline, or policy to all developers and testers.\n* Verify that an ongoing process exists to ensure that the application source code is free from backdoors, malicious code (e.g., salami attacks, logic bombs, time bombs), and undocumented or hidden features (e.g., Easter eggs, insecure debugging tools). Complying with this section is not possible without complete access to source code, including third-party libraries, and is therefore probably only suitable for applications requiring the very highest levels of security.\n* Verify that mechanisms are in place to detect and respond to configuration drift in deployed environments. This may include using immutable infrastructure, automated redeployment from a secure baseline, or drift detection tools that compare current state against approved configurations.\n* Verify that configuration hardening is performed on all third-party products, libraries, frameworks, and services as per their individual recommendations.\n\nReferences:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/securityengineering/sdl/)\n", "timestamp": "2025-10-24T11:40:08.816442"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/en/0x94-Appendix-E_Contributors.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/en/0x94-Appendix-E_Contributors.md", "content": "# Appendix E - Contributors\n\nWe gratefully acknowledge the contributions of the following people who have commented or opened pull requests since the the release of ASVS 4.0.0.\n\nIf you are aware of any mistakes or would like your name to appear differently, please let us know.\n\n| | | | |\n|---|---|---|---|\n| Johan Sydseter ([sydseter](https://github.com/sydseter)) | luis servin ([lfservin](https://github.com/lfservin)) | Oleksii Dovydkov ([oleksiidov](https://github.com/oleksiidov)) | IZUKA Masahiro ([maizuka](https://github.com/maizuka))  |\n| James Sulinski ([jsulinski](https://github.com/jsulinski)) | Eli Saad ([ThunderSon](https://github.com/ThunderSon)) | [kkshitish9](https://github.com/kkshitish9) | Andrew van der Stock ([vanderaj](https://github.com/vanderaj))  |\n| Rick M ([kingthorin](https://github.com/kingthorin)) | Bankde Eakasit ([Bankde](https://github.com/Bankde)) | Michael Gargiullo ([mgargiullo](https://github.com/mgargiullo)) | Raphael Dunant ([Racater](https://github.com/Racater))  |\n| Cesar Kohl ([cesarkohl](https://github.com/cesarkohl)) | [inaz0](https://github.com/inaz0) | Joerg Bruenner ([JoergBruenner](https://github.com/JoergBruenner)) | David Deatherage ([securitydave](https://github.com/securitydave))  |\n| John Carroll  ([yosignals](https://github.com/yosignals)) | Jim Fenton ([jimfenton](https://github.com/jimfenton)) | Matteo Pace ([M4tteoP](https://github.com/M4tteoP)) | Sebastien gioria ([SPoint42](https://github.com/SPoint42))  |\n| Steven van der Baan ([vdbaan](https://github.com/vdbaan)) | Jeremy Bonghwan Choi ([jeremychoi](https://github.com/jeremychoi)) | [craig-shony](https://github.com/craig-shony) | Riccardo Sirigu ([ricsirigu](https://github.com/ricsirigu))  |\n| Tomasz Wrobel ([tw2as](https://github.com/tw2as)) | Alena Dubeshko ([belalena](https://github.com/belalena)) | Rafael Green ([RafaelGreen1](https://github.com/RafaelGreen1)) | [mjang-cobalt](https://github.com/mjang-cobalt)  |\n| [clallier94](https://github.com/clallier94) | Kevin W. Wall ([kwwall](https://github.com/kwwall)) | Jordan Sherman ([jsherm-fwdsec](https://github.com/jsherm-fwdsec) / [deleterepo](https://github.com/deleterepo)) | Ingo Rauner ([ingo-rauner](https://github.com/ingo-rauner))  |\n| Dirk Wetter ([drwetter](https://github.com/drwetter)) | Moshe Zioni ([moshe-apiiro](https://github.com/moshe-apiiro)) | Patrick Dwyer ([coderpatros](https://github.com/coderpatros)) | David Clarke ([davidclarke-au](https://github.com/davidclarke-au))  |\n| Takaharu Ogasa ([takaharuogasa](https://github.com/takaharuogasa)) | Arkadii Yakovets ([arkid15r](https://github.com/arkid15r)) | Motoyasu Saburi ([motoyasu-saburi](https://github.com/motoyasu-saburi)) | [leirn](https://github.com/leirn)  |\n| [wet-certitude](https://github.com/wet-certitude) | [timhemel](https://github.com/timhemel) | RL Thornton ([thornshadow99](https://github.com/thornshadow99)) | Thomas Bandt ([aspnetde](https://github.com/aspnetde))  |\n| Roel Storms ([roelstorms](https://github.com/roelstorms)) | Jeroen Willemsen ([commjoen](https://github.com/commjoen)) | [anonymous-31](https://github.com/anonymous-31) | Kamran Saifullah ([deFr0ggy](https://github.com/deFr0ggy))  |\n| Steve Springett ([stevespringett](https://github.com/stevespringett)) | Spyros ([northdpole](https://github.com/northdpole)) | Hans Herrera ([hansphp](https://github.com/hansphp)) | [Marx314](https://github.com/Marx314)  |\n| [CarlosAllendes](https://github.com/CarlosAllendes) | Yonah Russ ([yruss972](https://github.com/yruss972)) | Sander Maijers ([sanmai-NL](https://github.com/sanmai-NL)) | Luboš Bretschneider  ([bretik](https://github.com/bretik))  |\n| Eva Sarafianou ([esarafianou](https://github.com/esarafianou)) | Ata Seren [ataseren](https://github.com/ataseren) | Steve Thomas ([Sc00bz](https://github.com/Sc00bz)) | Dominique RIGHETTO ([righettod](https://github.com/righettod))  |\n| Steven van der Baan ([svdb-ncc](https://github.com/svdb-ncc)) | Michael Vacarella ([Aif4thah](https://github.com/Aif4thah)) | Tonimir Kisasondi ([tkisason](https://github.com/tkisason)) | Stefan Streichsbier ([streichsbaer](https://github.com/streichsbaer))  |\n| [hi-unc1e](https://github.com/hi-unc1e) | sb3k ([starbuck3000](https://github.com/starbuck3000)) | [mario-platt](https://github.com/mario-platt) | Devdatta Akhawe ([devd](https://github.com/devd))  |\n| Michael Gissing ([scolytus](https://github.com/scolytus)) | Jet Anderson ([thatsjet](https://github.com/thatsjet)) | Dave Wichers ([davewichers](https://github.com/davewichers)) | Jonny Schnittger ([JonnySchnittger](https://github.com/JonnySchnittger))  |\n| Silvia Väli ([silviavali](https://github.com/silviavali)) | [jackgates73](https://github.com/jackgates73) | [1songb1rd](https://github.com/1songb1rd) | Timur - ([timurozkul](https://github.com/timurozkul))  |\n| Gareth Heyes ([hackvertor](https://github.com/hackvertor)) | [appills](https://github.com/appills) | [suvikaartinen](https://github.com/suvikaartinen) | chaals ([chaals](https://github.com/chaals))  |\n| DanielPharos ([AtlasHackert](https://github.com/AtlasHackert)) | will Farrell ([willfarrell](https://github.com/willfarrell)) | Alina Vasiljeva ([avasiljeva](https://github.com/avasiljeva)) | Paul McCann ([ismisepaul](https://github.com/ismisepaul))  |\n| Sage ([SajjadPourali](https://github.com/SajjadPourali)) | [rbsec](https://github.com/rbsec) | Benedikt Bauer ([mastacheata](https://github.com/mastacheata)) | James Jardine ([jamesjardine](https://github.com/jamesjardine))  |\n| Mark Burnett ([m8urnett](https://github.com/m8urnett)) | [dschwarz91](https://github.com/dschwarz91) | Cyber-AppSec ([Cyber-AppSec](https://github.com/Cyber-AppSec)) | [Tib3rius](https://github.com/Tib3rius)  |\n| BitnessWise ([bitnesswise](https://github.com/bitnesswise)) | damienbod ([damienbod](https://github.com/damienbod)) | Jared Meit ([jmeit-fwdsec](https://github.com/jmeit-fwdsec)) | Stefan Seelmann ([sseelmann](https://github.com/sseelmann))  |\n| Brendan O'Connor ([ussjoin](https://github.com/ussjoin)) | Andrei Titov ([andrettv](https://github.com/andrettv)) | Hans-Petter Fjeld ([atluxity](https://github.com/atluxity)) | [markehack](https://github.com/markehack)  |\n| Neil Madden ([NeilMadden](https://github.com/NeilMadden)) | Michael Geramb ([mgeramb](https://github.com/mgeramb)) | Osama Elnaggar ([ossie-git](https://github.com/ossie-git)) | [mackowski](https://github.com/mackowski)  |\n| Ravi Balla ([raviballa](https://github.com/raviballa)) | Hazana ([hazanasec](https://github.com/hazanasec)) | David Means ([dmeans82](https://github.com/dmeans82)) | Alexander Stein ([tohch4](https://github.com/tohch4))  |\n| BaeSenseii ([baesenseii](https://github.com/baesenseii)) | Vincent De Schutter ([VincentDS](https://github.com/VincentDS)) | S Bani ([sbani](https://github.com/sbani)) | Mitsuaki Akiyama ([mak1yama](https://github.com/mak1yama))  |\n| Christopher Loessl ([hashier](https://github.com/hashier)) | [victorxm](https://github.com/victorxm) | Michal Rada ([michalradacz](https://github.com/michalradacz)) | Veeresh Devireddy ([drveresh](https://github.com/drveresh))  |\n| [MaknaSEO](https://github.com/MaknaSEO) | [darkzero2022](https://github.com/darkzero2022) | Liam ([LiamDobbelaere](https://github.com/LiamDobbelaere)) | Frank Denis ([jedisct1](https://github.com/jedisct1))  |\n| Otto Sulin ([ottosulin](https://github.com/ottosulin)) | [carllaw6885](https://github.com/carllaw6885) | Anders Johan Holmefjord ([aholmis](https://github.com/aholmis)) | Richard Fritsch ([rfricz](https://github.com/rfricz))  |\n| [mesutgungor](https://github.com/mesutgungor) | Scott Helme ([ScottHelme](https://github.com/ScottHelme)) | Carlo Reggiani ([carloreggiani](https://github.com/carloreggiani)) | Suyash Srivastava ([suyash5053](https://github.com/suyash5053))  |\n| Mark Potter ([markonweb](https://github.com/markonweb)) | Arjan Lamers ([alamers](https://github.com/alamers)) | Gøran Breivik ([gobrtg](https://github.com/gobrtg)) | [flo-blg](https://github.com/flo-blg)  |\n| Guillaume Déflache ([guillaume-d](https://github.com/guillaume-d)) | Toufik Airane ([toufik-airane](https://github.com/toufik-airane)) | Keith Hoodlet ([securingdev](https://github.com/securingdev)) | Sinner ([SoftwareSinner](https://github.com/SoftwareSinner))  |\n| [iloving](https://github.com/iloving) | Jeroen Beckers ([TheDauntless](https://github.com/TheDauntless)) | Joubin Jabbari ([joubin](https://github.com/joubin)) | yu fujioka ([fujiokayu](https://github.com/fujiokayu))  |\n| execjosh ([execjosh](https://github.com/execjosh)) | Alicja Kario ([tomato42](https://github.com/tomato42)) | Sidney Ribeiro ([srjsoftware](https://github.com/srjsoftware)) | Gabriel Marquet ([Gby56](https://github.com/Gby56))  |\n| Drew Schulz ([drschulz](https://github.com/drschulz)) | [bedirhan](https://github.com/bedirhan) | [muralito](https://github.com/muralito) | Ronnie Flathers ([ropnop](https://github.com/ropnop))  |\n| Philippe De Ryck ([philippederyck](https://github.com/philippederyck)) | Malte ([mal33](https://github.com/mal33)) | [MazeOfThoughts](https://github.com/MazeOfThoughts) | Andreas Falk ([andifalk](https://github.com/andifalk))  |\n| Javi ([javixeneize](https://github.com/javixeneize)) | Daniel Hahn ([averell23](https://github.com/averell23)) | [borislav-c](https://github.com/borislav-c) | Robin Wood ([digininja](https://github.com/digininja))  |\n| [miro2ns](https://github.com/miro2ns) | Jan Dockx ([jandockx](https://github.com/jandockx)) | [vipinsaini434](https://github.com/vipinsaini434) | [priyanshukumar397](https://github.com/priyanshukumar397)  |\n| Nat Sakimura ([sakimura](https://github.com/sakimura)) | Benjamin Häublein ([BenjaminHae](https://github.com/BenjaminHae)) | [unknown-user-from](https://github.com/unknown-user-from) | Ali Ramazan TAŞDELEN ([alitasdln](https://github.com/alitasdln))  |\n| Pedro Escaleira ([oEscal](https://github.com/oEscal)) | Josh ([josh-hemphill](https://github.com/josh-hemphill)) | Tim Würtele ([SECtim](https://github.com/SECtim)) | AviD ([avidouglen](https://github.com/avidouglen))  |\n| SheHacksPurple ([shehackspurple](https://github.com/shehackspurple)) | [fcerullo-cycubix](https://github.com/fcerullo-cycubix) | Hector Eryx Paredes Camacho ([heryxpc](https://github.com/heryxpc)) | Irene Michlin ([irene221b](https://github.com/irene221b))  |\n| Jonah Y-M ([TG-Techie](https://github.com/TG-Techie)) | Dhiraj Bahroos ([bahroos](https://github.com/bahroos)) | Jef Meijvis ([jefmeijvis](https://github.com/jefmeijvis)) | [IzmaDoesItbeta](https://github.com/IzmaDoesItbeta)  |\n| Abdessamad TEMMAR ([TmmmmmR](https://github.com/TmmmmmR)) | [sectroyer](https://github.com/sectroyer) | Soh Satoh ([sohsatoh](https://github.com/sohsatoh)) | [regoravalaz](https://github.com/regoravalaz)  |\n| james-t ([james-bitherder](https://github.com/james-bitherder)) | Aram Hovsepyan ([aramhovsepyan](https://github.com/aramhovsepyan)) | [JaimeGomezGarciaSan](https://github.com/JaimeGomezGarciaSan) | [ValdiGit01](https://github.com/ValdiGit01)  |\n| iwatachan ([ishowta](https://github.com/ishowta)) | Vinod Anandan ([VinodAnandan](https://github.com/VinodAnandan)) | Kevin Kien ([KevinKien](https://github.com/KevinKien)) | [paul-williamson-swoop](https://github.com/paul-williamson-swoop)  |\n| [endergzr](https://github.com/endergzr) | Radhwan Alshamamri ([Rado0z](https://github.com/Rado0z)) | Grant Ongers ([rewtd](https://github.com/rewtd)) | Cure53 ([cure53](https://github.com/cure53))  |\n| [AliR2Linux](https://github.com/AliR2Linux) | Ads Dawson ([GangGreenTemperTatum](https://github.com/GangGreenTemperTatum)) | William Reyor ([BillReyor](https://github.com/BillReyor)) | gabe ([gcrow](https://github.com/gcrow))  |\n| [mascotter](https://github.com/mascotter) | [luissaiz](https://github.com/luissaiz) | Suren Manukyan ([vx-sec](https://github.com/vx-sec)) | Piotr Gliźniewicz  ([pglizniewicz](https://github.com/pglizniewicz))  |\n| Tadeusz Wachowski ([tadeuszwachowski](https://github.com/tadeuszwachowski)) | Nasir aka Nate ([andesec](https://github.com/andesec)) | [settantasette](https://github.com/settantasette) | Lars Haulin ([LarsH](https://github.com/LarsH))  |\n| Terence Eden ([edent](https://github.com/edent)) | [JasmineScholz](https://github.com/JasmineScholz) | Arun Sivadasan ([teavanist](https://github.com/teavanist)) | Yusuf GÜR ([yusuffgur](https://github.com/yusuffgur))  |\n| Troy Marshall ([troymarshall](https://github.com/troymarshall)) | Tanner Prynn ([tprynn](https://github.com/tprynn)) | Nick K. ([nickific](https://github.com/nickific)) | [raoul361](https://github.com/raoul361)  |\n| Azeem Ilyas ([TheAxZim](https://github.com/TheAxZim)) | Evo Stamatov ([avioli](https://github.com/avioli)) | Tim Potter ([timpotter87](https://github.com/timpotter87)) | Gavin Ray ([GavinRay97](https://github.com/GavinRay97))  |\n| monis ([demideus](https://github.com/demideus)) | Marcin Hoppe ([MarcinHoppe](https://github.com/MarcinHoppe)) | Grambulf ([ramshazar](https://github.com/ramshazar)) | Jordan Pike ([computersarebad](https://github.com/computersarebad))  |\n| Jason Rogers ([jason-invision](https://github.com/jason-invision)) | Ben Hall ([benbhall](https://github.com/benbhall)) | JamesPoppyCock ([jamesly123](https://github.com/jamesly123)) | WhiteHackLabs ([whitehacklabs](https://github.com/whitehacklabs))  |\n| Alex Gaynor ([alex](https://github.com/alex)) | Filip van Laenen ([filipvanlaenen](https://github.com/filipvanlaenen)) | [jeurgen](https://github.com/jeurgen) | [GraoMelo](https://github.com/GraoMelo)  |\n| Andreas Kurtz ([ay-kay](https://github.com/ay-kay)) | Tom Tervoort ([TomTervoort](https://github.com/TomTervoort)) | old man ([deveras](https://github.com/deveras)) | Marco Schnüriger ([marcortw](https://github.com/marcortw))  |\n| [stiiin](https://github.com/stiiin) | infoseclearn ([teaminfoseclearn](https://github.com/teaminfoseclearn)) | [hljupkij](https://github.com/hljupkij) | Noe ([nmarher](https://github.com/nmarher))  |\n| Lyz ([lyz-code](https://github.com/lyz-code)) | Martin Riedel ([mrtnrdl](https://github.com/mrtnrdl)) | KIM Jaesuck ([tcaesvk](https://github.com/tcaesvk)) | Barbara Schachner ([bschach](https://github.com/bschach))  |\n| René Reuter ([AresSec](https://github.com/AresSec)) | [carhackpils](https://github.com/carhackpils) | Tyler ([tyler2cr](https://github.com/tyler2cr)) | Hugo ([hasousa](https://github.com/hasousa))  |\n| Wouter Bloeyaert ([Someniak](https://github.com/Someniak)) | Mark de Rijk ([markderijkinfosec](https://github.com/markderijkinfosec)) | Ramin ([picohub](https://github.com/picohub)) | Philip D. Turner ([philipdturner](https://github.com/philipdturner))  |\n| Will Chatham ([willc](https://github.com/willc)) | | | |\n", "timestamp": "2025-10-24T11:40:08.926576"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x01-Frontispiece.md", "content": "# Frontispice\n\n## À propos du référentiel\n\nLe Référentiel de vérification de la sécurité des applications (Application Security Verification Standard) est une liste d'exigences de sécurité des applications que les architectes, les développeurs, les testeurs, les professionnels de la sécurité, les fournisseurs d'outils et les consommateurs peuvent utiliser pour définir, créer, tester et vérifier des applications sécurisées.\n\n## Copyright et licence\n\nVersion 5.0.0, Mai 2025\n\n![license](../images/license.png)\n\nCopyright © 2008-2025 La Fondation OWASP.\n\nCe document est publié sous la [licence Creative Commons Attribution ShareAlike 4.0](https://creativecommons.org/licenses/by-sa/4.0/).\n\nPour toute réutilisation ou distribution, vous devez indiquer clairement aux autres les termes de la licence de ce travail.\n\n## Chefs de projet\n\n|                       |                  |\n|---------------------- |----------------- |\n| Elar Lang             | Josh C Grossman  |\n| Jim Manico            | Daniel Cuthbert  |\n\n## Groupes de travail\n\n|                 |                   |                    |                  |\n|---------------- |------------------ |------------------- |----------------- |\n| Tobias Ahnoff   | Ralph Andalis     | Ryan Armstrong     | Gabriel Corona   |\n| Meghan Jacquot  | Shanni Prutchi    | Iman Sharafaldin   | Eden Yardeni     |\n\n## Autres contributeurs majeurs\n\n|                   |                   |\n|------------------ |-------------------|\n| Sjoerd Langkemper | Isaac Lewis       |\n| Mark Carney       | Sandro Gauci      |\n\n## Contributeurs et relecteurs\n\nNous avons inclus une liste des autres contributeurs dans l’annexe E.\n\nS'il manque un crédit dans la liste des crédits 5.0, veuillez enregistrer un ticket sur GitHub pour être reconnu dans les futures mises à jour.\n\nLe référentiel de vérification de la sécurité des applications repose sur les épaules des personnes concernées, de ASVS 1.0 en 2008 à 4.0 en 2019. Une grande partie de la structure et des éléments de vérification qui sont encore dans l'ASVS aujourd'hui ont été écrits à l'origine par Andrew van der Stock, Mike Boberski, Jeff Williams et/ou Dave Wichers, mais il y a beaucoup plus de contributeurs. Merci à tous ceux qui y ont participé précédemment. Pour une liste complète de tous ceux qui ont contribué aux versions précédentes, veuillez consulter chaque version antérieure.\n", "timestamp": "2025-10-24T11:40:09.242810"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x02-Preface.md", "content": "# Préface\n\nBienvenue dans la version 5.0 du référentiel de vérification de la sécurité des applications (ASVS).\n\n## Introduction\n\nLancé à l'origine en 2008 grâce à une collaboration communautaire mondiale, l'ASVS définit un ensemble exhaustif d'exigences de sécurité pour la conception, le développement et le test d'applications et de services Web modernes.\n\nAprès la sortie d'ASVS 4.0 en 2019 et sa mise à jour mineure (v4.0.3) en 2021, la version 5.0 représente une étape importante, modernisée pour refléter les dernières avancées en matière de sécurité logicielle.\n\nASVS 5.0 est le résultat de nombreuses contributions des chefs de projet, des membres du groupe de travail et de la communauté OWASP au sens large pour mettre à jour et améliorer ce référentiel important.\n\n## Principes derrière la version 5.0\n\nCette révision majeure a été élaborée en gardant à l’esprit plusieurs principes clés :\n\n* Périmètre et orientation affinées : Cette version du référentiel a été conçue pour s'aligner plus directement sur les piliers fondamentaux de son nom : Application, Sécurité, Vérification et Référentiel. Les exigences ont été réécrites afin de mettre l'accent sur la prévention des failles de sécurité plutôt que d'imposer des implémentations techniques spécifiques. Les textes des exigences sont explicites et expliquent leur raison d'être.\n\n* Prise en charge des décisions de sécurité documentées : ASVS 5.0 introduit des exigences de documentation des décisions de sécurité clés. Cela améliore la traçabilité et prend en charge les implémentations qui dépendent du contexte, permettant aux organisations d'adapter leur posture de sécurité à leurs besoins et risques spécifiques.\n\n* Niveaux mis à jour : Bien qu'ASVS conserve son modèle à trois niveaux, les définitions des niveaux ont évolué pour faciliter son adoption. Le niveau 1 est conçu comme la première étape de l'adoption d'ASVS, fournissant la première couche de défense. Le niveau 2 offre une vue d'ensemble des pratiques de sécurité standard, et le niveau 3 répond aux exigences avancées de haute assurance.\n\n* Contenu restructuré et enrichi : ASVS 5.0 comprend environ 350 exigences réparties en 17 chapitres. Les chapitres ont été réorganisés pour plus de clarté et de praticité. Un mappage bidirectionnel entre les versions 4.0 et 5.0 est fourni pour faciliter la migration.\n\n## Regard vers l'avenir\n\nTout comme la sécurisation d'une application n'est jamais vraiment achevée, l'ASVS ne l'est pas non plus. Bien que la version 5.0 soit une version majeure, le développement se poursuit. Cette version permet à la communauté de bénéficier des améliorations et des ajouts accumulés, et pose également les bases de futures améliorations. Cela pourrait inclure des efforts communautaires pour créer des guides de mise en œuvre et de vérification, basés sur les exigences de base.\n\nASVS 5.0 est conçu pour servir de base fiable au développement de logiciels sécurisés. La communauté est invitée à adopter, contribuer et développer ce référentiel afin de faire progresser collectivement la sécurité des applications.\n", "timestamp": "2025-10-24T11:40:09.319950"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x03-What-is-the-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x03-What-is-the-ASVS.md", "content": "# Qu'est-ce que l'ASVS ?\n\nLe Référentiel de vérification de la sécurité des applications (ASVS) définit des exigences de sécurité pour les applications et services web. Elle constitue une ressource précieuse pour quiconque souhaite concevoir, développer et maintenir des applications sécurisées ou évaluer leur sécurité.\n\nCe chapitre décrit les aspects essentiels de l'utilisation de l'ASVS, notamment son champ d'application, la structure de ses niveaux de priorité et ses principaux cas d'utilisation.\n\n## Périmètre de l'ASVS\n\nLe périmètre de l'ASVS est définie par son nom : Application, Sécurité, Vérification et Référentiel. Elle établit les exigences incluses ou exclues, avec pour objectif principal d'identifier les principes de sécurité à respecter. Elle prend également en compte les exigences de documentation, qui servent de base aux exigences de mise en œuvre.\n\nIl n'existe aucun périmètre pour les attaquants. Par conséquent, les exigences de l'ASVS doivent être évaluées parallèlement aux recommandations relatives aux autres aspects du cycle de vie des applications, notamment les processus CI/CD, l'hébergement et les activités opérationnelles.\n\n### Application\n\nASVS définit une « application » comme le produit logiciel en cours de développement, dans lequel des contrôles de sécurité doivent être intégrés. ASVS ne prescrit pas les activités du cycle de développement ni la manière dont l'application doit être construite via un pipeline CI/CD ; il spécifie plutôt les résultats de sécurité à atteindre au sein même du produit.\n\nLes composants qui traitent, modifient ou valident le trafic HTTP, tels que les pares-feux d'applications web (WAF), les équilibreurs de charge ou les proxys, peuvent être considérés comme faisant partie de l'application à ces fins spécifiques, car certains contrôles de sécurité en dépendent directement ou peuvent être implémentés par leur intermédiaire. Ces composants doivent être pris en compte pour les exigences liées aux réponses mises en cache, à la limitation du débit ou à la restriction des connexions entrantes et sortantes en fonction de la source et de la destination.\n\nÀ l'inverse, ASVS exclut généralement les exigences qui ne concernent pas directement l'application ou dont la configuration ne relève pas de sa responsabilité. Par exemple, les problèmes DNS sont généralement gérés par une équipe ou une fonction distincte.\n\nDe même, si l'application est responsable de la manière dont elle consomme les entrées et produit les sorties, l'interaction d'un processus externe avec l'application ou ses données est considérée comme hors du périmètre d'ASVS. Par exemple, la sauvegarde de l'application ou de ses données relève généralement de la responsabilité d'un processus externe et n'est pas contrôlée par l'application ou ses développeurs.\n\n### Sécurité\n\nChaque exigence doit avoir un impact démontrable sur la sécurité. L'absence d'exigence doit entraîner une application moins sécurisée, et sa mise en œuvre doit réduire la probabilité ou l'impact d'un risque de sécurité.\n\nToutes les autres considérations, telles que les aspects fonctionnels, le style de code ou les exigences de politique, sont hors du périmètre d'application.\n\n### Vérification\n\nL'exigence doit être vérifiable et la vérification doit aboutir à une décision d'échec ou de réussite.\n\n### Référentiel\n\nL'ASVS est conçue comme un recueil d'exigences de sécurité à mettre en œuvre pour se conformer au référentiel. Cela signifie que les exigences se limitent à la définition de l'objectif de sécurité à atteindre. D'autres informations connexes peuvent être intégrées à l'ASVS ou reliées par des mappings.\n\nPlus précisément, l'OWASP comporte de nombreux projets, et l'ASVS évite délibérément tout chevauchement avec le contenu d'autres projets. Par exemple, les développeurs peuvent se demander : « Comment implémenter une exigence particulière dans ma technologie ou mon environnement ? » Cette question devrait être traitée par le projet « Cheat-Sheets ». Les vérificateurs peuvent se demander : « Comment tester cette exigence dans cet environnement ? » Cette question devrait être traitée par le projet « Web Security Testing Guide ».\n\nBien que l'ASVS ne soit pas uniquement destiné aux experts en sécurité, il attend du lecteur des connaissances techniques pour comprendre le contenu ou la capacité à rechercher des concepts spécifiques.\n\n### Exigence\n\nLe terme « exigence » est utilisé spécifiquement dans l'ASVS car il décrit ce qui doit être accompli pour la satisfaire. L'ASVS ne contient que des exigences (doit) et ne contient pas de recommandations (devrait) comme condition principale.\n\nEn d'autres termes, les recommandations, qu'elles constituent une solution parmi d'autres ou des considérations de style de code, ne répondent pas à la définition d'une exigence.\n\nLes exigences de l'ASVS visent à répondre à des principes de sécurité spécifiques sans être trop spécifiques à une implémentation ou à une technologie, tout en étant explicites quant à leur raison d'être. Cela signifie également que les exigences ne sont pas construites autour d'une méthode de vérification ou d'une implémentation particulière.\n\n### Décisions de sécurité documentées\n\nEn matière de sécurité logicielle, planifier la conception de la sécurité et les mécanismes à utiliser en amont permettra une implémentation plus cohérente et fiable du produit fini ou de la fonctionnalité.\n\nDe plus, pour certaines exigences, la mise en œuvre sera complexe et très spécifique aux besoins de l'application. Parmi les exemples courants, on peut citer les autorisations, la validation des entrées et les contrôles de protection autour de différents niveaux de données sensibles.\n\nPour tenir compte de cela, plutôt que de formuler des affirmations générales telles que « toutes les données doivent être chiffrées » ou de tenter de couvrir tous les cas d'utilisation possibles dans une exigence, des exigences de documentation ont été incluses, exigeant que l'approche et la configuration du développeur d'applications pour ces types de contrôles soient documentées. Ceci peut ensuite être vérifié pour en vérifier la pertinence, puis la mise en œuvre réelle peut être comparée à la documentation afin d'évaluer si elle répond aux attentes.\n\nCes exigences visent à documenter les décisions prises par l'organisation développant l'application concernant la mise en œuvre de certaines exigences de sécurité.\n\nLes exigences de documentation figurent toujours dans la première section d'un chapitre (bien que tous les chapitres n'en disposent pas) et sont toujours associées à une exigence de mise en œuvre, où les décisions documentées doivent être effectivement mises en œuvre. L'essentiel est de distinguer la vérification de la documentation et de la mise en œuvre effective.\n\nL'inclusion de ces exigences repose sur deux facteurs clés. Le premier est qu'une exigence de sécurité implique souvent l'application de règles, par exemple concernant les types de fichiers autorisés à être téléchargés, les contrôles métier à appliquer et les caractères autorisés pour un champ particulier. Ces règles diffèrent d'une application à l'autre ; par conséquent, l'ASVS ne peut pas les définir de manière prescriptive, et un aide-mémoire ou une réponse plus détaillée ne serait d'aucune utilité dans ce cas précis. De même, sans documentation de ces décisions, il sera impossible de vérifier les exigences qui les mettent en œuvre.\n\nLe deuxième facteur est que, pour certaines exigences, il est important d'offrir au développement d'applications une certaine flexibilité quant à la manière de répondre à des défis de sécurité particuliers. Par exemple, dans les versions précédentes d'ASVS, les règles d'expiration de session étaient très strictes. En pratique, de nombreuses applications, notamment celles destinées aux utilisateurs, ont des règles beaucoup plus souples et préfèrent mettre en œuvre d'autres contrôles d'atténuation. Les exigences de documentation permettent donc explicitement cette flexibilité.\n\nIl est clair que les développeurs ne sont pas censés prendre et documenter ces décisions individuellement, mais que l'organisation dans son ensemble les prend et s'assure qu'elles sont communiquées aux développeurs, qui s'assurent ensuite de les respecter.\n\nFournir aux développeurs des spécifications et des conceptions pour de nouvelles fonctionnalités est une étape standard du développement logiciel. De même, les développeurs sont censés utiliser des composants et des mécanismes d'interface utilisateur communs plutôt que de prendre leurs propres décisions à chaque fois. Par conséquent, étendre ce principe à la sécurité ne devrait pas être perçu comme surprenant ou controversé.\n\nLa manière d'y parvenir est également flexible. Les décisions de sécurité peuvent être documentées dans un document littéral, auquel les développeurs sont tenus de se référer. Alternativement, elles peuvent être documentées et implémentées dans une bibliothèque de code commune que tous les développeurs sont tenus d'utiliser. Dans les deux cas, le résultat souhaité est atteint.\n\n## Niveaux de vérification de la sécurité des applications\n\nL'ASVS définit trois niveaux de vérification de la sécurité, chaque niveau augmentant en profondeur et en complexité. L'objectif général est que les organisations commencent par le premier niveau pour répondre aux préoccupations de sécurité les plus critiques, puis progressent vers les niveaux supérieurs en fonction des besoins de l'organisation et des applications. Les niveaux peuvent être présentés comme L1, L2 et L3 dans le document et dans les textes d'exigences.\n\nChaque niveau ASVS indique les exigences de sécurité à atteindre à partir de ce niveau, les exigences des niveaux supérieurs restants étant des recommandations.\n\nAfin d'éviter les doublons ou les exigences obsolètes aux niveaux supérieurs, certaines exigences s'appliquent à un niveau particulier, mais sont soumises à des conditions plus strictes pour les niveaux supérieurs.\n\n### Évaluation des niveaux\n\nLes niveaux sont définis par une évaluation de priorité de chaque exigence, basée sur l'expérience de mise en œuvre et de test des exigences de sécurité. L'accent est mis principalement sur la balance entre la réduction des risques et les efforts nécessaires à la mise en œuvre de l'exigence. Un autre facteur clé est de maintenir une faible barrière à l'entrée.\n\nLa réduction des risques évalue dans quelle mesure l'exigence réduit le niveau de risque de sécurité au sein de l'application, en tenant compte des facteurs d'impact classiques de confidentialité, d'intégrité et de disponibilité, et en déterminant s'il s'agit d'une couche de défense principale ou d'une défense en profondeur.\n\nLes discussions rigoureuses autour des critères et des décisions de nivellement ont abouti à une répartition qui devrait s'appliquer à la grande majorité des cas, tout en admettant qu'elle ne soit pas parfaitement adaptée à toutes les situations. Cela signifie que, dans certains cas, les organisations peuvent souhaiter prioriser les exigences d'un niveau supérieur en amont, en fonction de leurs propres considérations de risque.\n\nLes types d'exigences à chaque niveau peuvent être caractérisés comme suit.\n\n### Niveau 1\n\nCe niveau contient les exigences minimales à prendre en compte pour sécuriser une application et constitue un point de départ essentiel. Il comprend environ 20 % des exigences de l'ASVS. L'objectif est de réduire au minimum les exigences afin de réduire les obstacles à l'entrée.\n\nCes exigences sont généralement critiques ou basiques, et constituent la première couche de défense pour prévenir les attaques courantes. Elles ne nécessitent pas d'autres vulnérabilités ou conditions préalables pour être exploitables.\n\nOutre les exigences de la première couche de défense, certaines exigences ont moins d'impact aux niveaux supérieurs, comme celles relatives aux mots de passe. Celles-ci sont plus importantes pour le Niveau 1, car à partir de ces niveaux, les exigences d'authentification multifacteur deviennent pertinentes.\n\nLe Niveau 1 n'est pas nécessairement testable par un testeur externe sans accès interne à la documentation ou au code (comme les tests « boîte noire »), bien que le nombre réduit d'exigences devrait faciliter sa vérification.\n\n### Niveau 2\n\nLa plupart des applications devraient s'efforcer d'atteindre ce niveau de sécurité. Environ 50 % des exigences de l'ASVS sont de niveau 2, ce qui signifie qu'une application doit implémenter environ 70 % des exigences de l'ASVS (l'ensemble des exigences de niveau 1 et 2) pour être conforme à ce niveau.\n\nCes exigences concernent généralement des attaques moins courantes ou des protections plus complexes contre les attaques courantes. Elles peuvent constituer une première couche de défense ou nécessiter certaines conditions préalables pour que l'attaque réussisse.\n\n### Niveau 3\n\nCe niveau doit être l'objectif des applications souhaitant démontrer les plus hauts niveaux de sécurité et représente environ 30 % des exigences à respecter.\n\nLes exigences de cette section concernent généralement des mécanismes de défense en profondeur ou d'autres contrôles utiles, mais difficiles à mettre en œuvre.\n\n### Quel niveau atteindre ?\n\nLes niveaux de priorité visent à refléter la maturité de l'organisation et de l'application en matière de sécurité applicative. Plutôt que d'imposer un niveau de sécurité normatif pour une application, l'organisation doit analyser ses risques et déterminer le niveau qu'elle estime approprié, en fonction de la sensibilité de l'application et, bien sûr, des attentes de ses utilisateurs.\n\nPar exemple, une jeune start-up qui ne collecte que des données sensibles limitées peut décider de se concentrer sur le niveau 1 pour ses objectifs de sécurité initiaux, tandis qu'une banque peut avoir du mal à justifier auprès de ses clients un niveau inférieur au niveau 3 pour son application de banque en ligne.\n\n## Comment utiliser l'ASVS ?\n\n### Structure de l'ASVS\n\nL'ASVS comprend environ 350 exigences, réparties en 17 chapitres, chacun étant lui-même subdivisé en sections.\n\nL'objectif de cette division est de simplifier la sélection ou le filtrage des chapitres et sections en fonction de leur pertinence pour l'application. Par exemple, pour une API machine-to-machine, les exigences du chapitre V3 relatives aux interfaces web ne seront pas pertinentes. Si OAuth ou WebRTC n'est pas utilisé, ces chapitres peuvent également être ignorés.\n\n### Stratégie de publication\n\nLes publications ASVS suivent le modèle « Majeure.Mineure.Correctif » et les numéros indiquent les modifications apportées. Pour une publication majeure, le premier numéro change, pour une publication mineure, le deuxième, et pour une publication corrective, le troisième.\n\n* Publication majeure : Réorganisation complète, presque tout peut avoir changé, y compris les numéros d'exigences. Une réévaluation de conformité sera nécessaire (par exemple, 4.0.3 -> 5.0.0).\n* Publication mineure : Des exigences peuvent être ajoutées ou supprimées, mais la numérotation globale reste inchangée. Une réévaluation de conformité sera nécessaire, mais devrait être plus simple (par exemple, 5.0.0 -> 5.1.0).\n* Publication corrective : Des exigences peuvent être supprimées (par exemple, si elles sont dupliquées ou obsolètes) ou assouplies, mais une application conforme à la publication précédente sera également conforme à la publication corrective (par exemple, 5.0.0 -> 5.0.1).\n\nLes informations ci-dessus concernent spécifiquement les exigences de l'ASVS. Les modifications apportées au texte environnant et à d'autres contenus, tels que les annexes, ne seront pas considérées comme des modifications majeures.\n\n### Flexibilité avec l'ASVS\n\nPlusieurs points décrits ci-dessus, tels que les exigences de documentation et le mécanisme de niveaux, permettent une utilisation de l'ASVS plus flexible et plus spécifique à l'organisation.\n\nDe plus, il est fortement encouragé aux organisations de créer un fork spécifique à l'organisation ou au domaine, afin d'ajuster les exigences en fonction des caractéristiques et des niveaux de risque de leurs applications. Cependant, il est important de maintenir une traçabilité afin que la conformité à l'exigence 4.1.1 soit identique pour toutes les versions.\n\nIdéalement, chaque organisation devrait créer son propre ASVS personnalisé, en supprimant les sections non pertinentes (par exemple, GraphQL, WebSockets, SOAP, si elles ne sont pas utilisées). Une version ou un supplément ASVS spécifique à l'organisation est également un bon support pour fournir des conseils d'implémentation spécifiques à l'organisation, détaillant les bibliothèques ou les ressources à utiliser pour se conformer aux exigences.\n\n### Comment référencer les exigences de l'ASVS ?\n\nChaque exigence possède un identifiant au format `<chapitre>.<section>.<exigence>`, où chaque élément est un numéro. Par exemple, « 1.11.3 ».\n\n* La valeur `<chapitre>` correspond au chapitre d'où provient l'exigence ; par exemple, toutes les exigences `1.#.#` proviennent du chapitre 'Encodage et nettoyage'.\n* La valeur `<section>` correspond à la section de ce chapitre où apparaît l'exigence ; par exemple, toutes les exigences `1.2.#` se trouvent dans la section 'Prévention des injections' du chapitre 'Encodage et nettoyage'.\n* La valeur `<exigence>` identifie l'exigence spécifique au sein du chapitre et de la section, par exemple, `1.2.5` qui, dans la version 5.0.0 de ce référentiel, est :\n\n> Vérifiez que l'application protège contre l'injection de commandes du système d'exploitation et que les appels du système d'exploitation utilisent des requêtes OS paramétrées ou un encodage contextuel de la sortie de ligne de commande.\n\nLes identifiants pouvant varier d'une version à l'autre du référentiel, il est préférable, pour les autres documents, rapports ou outils, d'utiliser le format suivant : `v<version>-<chapter>.<section>.<requirement>`, où 'version' correspond à la balise de version ASVS. Par exemple, 'v5.0.0-1.2.5' désigne spécifiquement la 5ème exigence de la section 'Prévention des injections' du chapitre 'Encodage et nettoyage' de la version 5.0.0. (Ceci pourrait être résumé par `v<version>-<identifiant_exigence>`.)\n\nRemarque : Le `v` précédant le numéro de version dans le format doit toujours être en minuscule.\n\nSi des identifiants sont utilisés sans inclure l'élément `v<version>`, ils doivent être considérés comme faisant référence au contenu le plus récent du Référentiel de vérification de la sécurité des applications. À mesure que le référentiel évolue, cela devient problématique ; c'est pourquoi les rédacteurs et les développeurs doivent inclure l'élément « version ».\n\nLes listes d'exigences de l'ASVS sont disponibles aux formats CSV, JSON et autres, utiles à des fins de référence ou d'utilisation programmatique.\n\n### Forker l'ASVS\n\nLes organisations peuvent tirer profit de l'adoption d'ASVS en choisissant l'un des trois niveaux ou en créant un fork spécifique au domaine qui ajuste les exigences en fonction du niveau de risque applicatif. Ce type de fork est encouragé, à condition de garantir la traçabilité de l'exigence 4.1.1, garantissant ainsi la même cohérence pour toutes les versions.\n\nIdéalement, chaque organisation devrait créer son propre ASVS personnalisé, en supprimant les sections non pertinentes (par exemple, GraphQL, Websockets, SOAP, si elles ne sont pas utilisées). Le fork doit commencer par le niveau 1 d'ASVS comme référence, puis progresser vers les niveaux 2 ou 3 en fonction du risque de l'application.\n\n## Cas d'utilisation de l'ASVS\n\nL'ASVS peut être utilisé pour évaluer la sécurité d'une application, ce point étant approfondi dans le chapitre suivant. Cependant, plusieurs autres utilisations potentielles de l'ASVS (ou d'une version dérivée) ont été identifiées.\n\n### En tant que conseil détaillé sur l'architecture de sécurité\n\nL'une des utilisations les plus courantes du Référentiel de vérification de la sécurité des applications (ASVS) est de servir de ressource aux architectes de sécurité. Les ressources disponibles pour construire une architecture applicative sécurisée sont limitées, notamment pour les applications modernes. L'ASVS peut combler ces lacunes en permettant aux architectes de sécurité de choisir de meilleurs contrôles pour les problèmes courants, tels que les modèles de protection des données et les stratégies de validation des entrées. Les exigences en matière d'architecture et de documentation seront particulièrement utiles à cet égard.\n\n### Référence spécialisée en developpement sécurisé\n\nL'ASVS peut servir de base à la préparation d'une référence de développement sécurisé lors du développement d'applications, aidant ainsi les développeurs à prendre en compte la sécurité lors de la création de logiciels. Bien que l'ASVS puisse servir de base, les organisations doivent élaborer leurs propres directives claires et unifiées, idéalement basées sur les recommandations des ingénieurs ou architectes de sécurité. De plus, les organisations sont encouragées, dans la mesure du possible, à préparer des mécanismes et bibliothèques de sécurité approuvés, référencés dans les directives et utilisables par les développeurs.\n\n### Guide pour les tests unitaires et d'intégration automatisés\n\nL'ASVS est conçu pour être hautement testable. Certaines vérifications seront techniques, tandis que d'autres exigences (telles que les exigences d'architecture et de documentation) pourront nécessiter une revue de documentation ou d'architecture. En créant des tests unitaires et d'intégration qui testent et analysent par fuzzing des cas d'abus spécifiques et pertinents liés aux exigences, vérifiables par des moyens techniques, il devrait être plus facile de vérifier le bon fonctionnement de ces contrôles à chaque build. Par exemple, des tests supplémentaires peuvent être créés pour la suite de tests d'un contrôleur de connexion afin de tester la présence de valeur par défaut courante pour le paramètre username, l'énumération des comptes, le force brute, l'injection LDAP et SQL, et les attaques XSS. De même, un test sur le paramètre password doit inclure les mots de passe courants, la longueur des mots de passe, l'injection d'octets nuls, la suppression du paramètre, les attaques XSS, etc.\n\n### Pour la formation au développement sécurisé\n\nL'ASVS peut également servir à définir les caractéristiques d'un logiciel sécurisé. De nombreux cours de « codage sécurisé » se résument à des cours de piratage éthique, avec quelques conseils de codage. Cela n'aide pas forcément les développeurs à écrire du code plus sécurisé. Les cours de développement sécurisé peuvent plutôt utiliser l'ASVS en mettant l'accent sur ses mécanismes positifs, plutôt que sur les 10 principes négatifs à éviter. La structure de l'ASVS offre également une structure logique pour aborder les différents sujets liés à la sécurisation d'une application.\n\n### En tant que cadre pour l'approvisionnement des logiciels sécurisés\n\nL'ASVS est un cadre idéal pour faciliter l'approvisionnement des logiciels sécurisés ou l'acquisition de services de développement de développement sur mesure. L'acheteur peut simplement exiger que le logiciel qu'il souhaite acquérir soit développé au niveau X de l'ASVS et demander au vendeur de prouver que le logiciel satisfait à ce niveau.\n\n## Appliquer l'ASVS en pratique\n\nLes menaces varient selon les motivations. Certains secteurs disposent de ressources informatiques et technologiques spécifiques et d'exigences de conformité réglementaire spécifiques à leur domaine.\n\nIl est fortement recommandé aux organisations d'analyser en profondeur les caractéristiques de risque spécifiques à leur activité et de déterminer le niveau d'ASVS approprié en fonction de ces risques et des exigences métier.\n", "timestamp": "2025-10-24T11:40:09.447150"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x04-Assessment_and_Certification.md", "content": "# Évaluation et certification\n\n## Position de l'OWASP sur les certifications et marques de confiance ASVS\n\nL'OWASP, en tant qu'organisation à but non lucratif neutre, ne certifie actuellement aucun vendeur, vérificateur ou logiciel. Toutes ces assertions d'assurance, marques de confiance ou certifications ne sont pas officiellement vérifiées, enregistrées ou certifiées par l'OWASP, de sorte qu'une organisation qui s'appuie sur ce point de vue doit être prudente quant à la confiance placée dans une tierce partie ou une marque de confiance revendiquant la certification ASVS.\n\nCela ne devrait pas empêcher les organisations d'offrir de tels services d'assurance, tant qu'elles ne revendiquent pas la certification officielle de l'OWASP.\n\n## Comment vérifier la conformité ASVS\n\nL'ASVS n'est volontairement pas prescriptif quant à la manière précise de vérifier la conformité au niveau d'un guide de tests. Il est toutefois important de souligner certains points clés.\n\n### Rapport de vérification\n\nLes tests d'intrusion traditionnels signalent les problèmes « par exception », en ne listant que les échecs. Cependant, un rapport de certification ASVS doit inclure le périmètre, un résumé de toutes les exigences vérifiées, les exigences pour lesquelles des exceptions ont été constatées et des conseils pour résoudre les problèmes. Certaines exigences peuvent ne pas être applicables (par exemple, la gestion des sessions dans les API sans état), et cela doit être mentionné dans le rapport.\n\n### Périmètre de la vérification\n\nUne organisation développant une application n'implémentera généralement pas toutes les exigences, certaines pouvant être non pertinentes ou moins importantes selon les fonctionnalités de l'application. Le vérificateur doit préciser le périmètre de la vérification, notamment le niveau que l'organisation souhaite atteindre et les exigences incluses. Il doit s'agir de ce qui a été inclus plutôt que de ce qui ne l'a pas été. Il doit également fournir un avis sur les raisons justifiant l'exclusion des exigences non implémentées.\n\nCela devrait permettre au consommateur d’un rapport de vérification de comprendre le contexte de la vérification et de prendre une décision éclairée sur le niveau de confiance qu’il peut accorder à l’application.\n\nLes organismes de certification peuvent choisir leurs méthodes de test, mais devraient les indiquer dans le rapport, et elles devraient idéalement être reproductibles. Différentes méthodes, comme les tests d'intrusion manuels ou l'analyse du code source, peuvent être utilisées pour vérifier des aspects tels que la validation des entrées, selon l'application et les exigences.\n\n### Mécanismes de vérification\n\nPlusieurs techniques différentes peuvent être utilisées pour vérifier une même exigence ASVS. Outre les tests d'intrusion (utilisant des \"credentials\" valides pour une couverture complète de l'application), la vérification des exigences ASVS peut nécessiter l'accès à la documentation, au code source, à la configuration et aux personnes impliquées dans le processus de développement. Ceci est particulièrement vrai pour la vérification des exigences L2 et L3. Il est courant de fournir des preuves solides des résultats au moyen d'une documentation détaillée, pouvant inclure des documents de travail, des captures d'écran, des scripts et des journaux de tests. L'exécution d'un outil automatisé sans tests approfondis ne suffit pas à obtenir la certification, car chaque exigence doit être testée de manière vérifiable.\n\nL'utilisation de l'automatisation pour vérifier les exigences ASVS est un sujet qui suscite un intérêt constant. Il est donc important de clarifier certains points relatifs aux tests automatisés et en boîte noire.\n\n#### Le rôle des outils de test de sécurité automatisés\n\nLorsque des outils de tests de sécurité automatisés, tels que les tests de sécurité dynamiques et statiques des applications (DAST et SAST), sont correctement implémentés dans le pipeline de développement, ils peuvent identifier des problèmes de sécurité qui ne devraient jamais exister. Cependant, sans une configuration et un réglage minutieux, ils n'offriront pas la couverture requise et leur niveau de bruit empêchera l'identification et la résolution des véritables problèmes de sécurité.\n\nBien que cela puisse couvrir certaines des exigences techniques les plus basiques et les plus simples, telles que celles relatives à l'encodage ou à l'assainissement de sortie, il est essentiel de noter que ces outils ne seront pas entièrement en mesure de vérifier bon nombre des exigences ASVS les plus complexes ou celles liées à la logique métier et au contrôle d'accès.\n\nPour les exigences moins simples, l'automatisation reste probablement envisageable, mais des vérifications spécifiques à l'application devront être écrites pour y parvenir. Ces vérifications peuvent être similaires aux tests unitaires et d'intégration déjà utilisés par l'organisation. Il est donc possible d'utiliser l'infrastructure d'automatisation des tests existante pour écrire ces tests spécifiques à ASVS. Bien que cela nécessite un investissement à court terme, les avantages à long terme de la vérification continue des exigences ASVS seront significatifs.\n\nEn résumé, testable en utilisant l'automatisation != exécuter un outil sur étagère.\n\n#### Le rôle des tests de pénétration\n\nBien que L1 dans la version 4.0 ait été optimisé pour les tests de « boîte noire » (sans documentation et sans source), même dans ce cas, le standard était clair sur le fait qu'il ne s'agissait pas d'une activité d'assurance efficace et qu'elle devait être activement découragée.\n\nLes tests sans accès aux informations supplémentaires nécessaires constituent un mécanisme sous-productifs et inefficaces de vérification de la sécurité, car ils ne permettent pas d’examiner le code source, d’identifier les menaces et les contrôles manquants, et d’effectuer un test beaucoup plus approfondi dans un délai plus court.\n\nIl est fortement encouragé d'effectuer des tests d'intrusion basés sur la documentation ou le code source (hybrides), avec un accès complet aux développeurs et à la documentation de l'application, plutôt que des tests d'intrusion traditionnels. Cela sera certainement nécessaire pour vérifier de nombreuses exigences ASVS.\n", "timestamp": "2025-10-24T11:40:09.518630"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x05-For-Users-Of-4.0.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x05-For-Users-Of-4.0.md", "content": "# Modifications par rapport à la version 4.x\n\n## Introduction\n\nLes utilisateurs familiarisés avec la version 4.x du référentiel trouveront utile de consulter les principales modifications apportées à la version 5.0, notamment les mises à jour de contenu, de périmètre et de philosophie sous-jacente.\n\nSur les 286 exigences de la version 4.0.3, seules 11 restent inchangées, tandis que 15 ont subi des ajustements grammaticaux mineurs sans altérer leur sens. Au total, 109 exigences (38 %) ne sont plus des exigences distinctes dans la version 5.0 : 50 ont été simplement supprimées, 28 ont été supprimées car doublons et 31 ont été fusionnées avec d'autres exigences. Les autres ont été révisées. Même les exigences n'ayant pas subi de modifications substantielles ont des identifiants différents à la suite d'une réorganisation ou une restructuration.\n\nPour faciliter l'adoption de la version 5.0, des documents de correspondance sont fournis pour aider les utilisateurs à identifier les correspondances entre les exigences de la version 4.x et celles de la version 5.0. Ces correspondances ne sont pas liées au numéro de version et peuvent être mises à jour ou clarifiées si nécessaire.\n\n## Philosophie des exigences\n\n### Périmètre et orientation\n\nLa version 4.x incluait des exigences qui ne correspondaient pas au périmètre prévu du référentiel ; celles-ci ont été supprimées. Les exigences qui ne répondaient pas aux critères du périmètre de la version 5.0 ou qui n'étaient pas vérifiables ont également été exclues.\n\n### Priorité aux objectifs de sécurité plutôt qu'aux mécanismes\n\nDans la version 4.x, de nombreuses exigences se concentraient sur des mécanismes spécifiques plutôt que sur les objectifs de sécurité sous-jacents. Dans la version 5.0, les exigences sont centrées sur les objectifs de sécurité, ne référençant des mécanismes particuliers que lorsqu'ils constituent la seule solution pratique, ou les fournissant à titre d'exemple ou de conseil complémentaire.\n\nCette approche reconnaît que plusieurs méthodes peuvent exister pour atteindre un objectif de sécurité donné et évite toute prescription inutile susceptible de limiter la flexibilité organisationnelle.\n\nDe plus, les exigences traitant d'une même préoccupation de sécurité ont été consolidées lorsque cela était opportun.\n\n### Décisions de sécurité documentées\n\nBien que le concept de décisions de sécurité documentées puisse paraître nouveau dans la version 5.0, il s'agit d'une évolution des exigences antérieures liées à l'application des politiques et à la modélisation des menaces dans la version 4.0. Auparavant, certaines exigences exigeaient implicitement une analyse pour éclairer la mise en œuvre des contrôles de sécurité, comme la détermination des connexions réseau autorisées.\n\nAfin de garantir la disponibilité des informations nécessaires à la mise en œuvre et à la vérification, ces attentes sont désormais explicitement définies comme des exigences de documentation, ce qui les rend claires, actionnables et vérifiables.\n\n## Modifications structurelles et nouveaux chapitres\n\nPlusieurs chapitres de la version 5.0 introduisent du contenu entièrement nouveau :\n\n* OAuth et OIDC – Compte tenu de l’adoption généralisée de ces protocoles pour la délégation d’accès et l’authentification unique, des exigences spécifiques ont été ajoutées pour répondre aux divers scénarios rencontrés par les développeurs. Ce domaine pourrait à terme évoluer vers une norme autonome, similaire à la gestion des exigences mobiles et IoT dans les versions précédentes.\n* WebRTC – Avec la popularité croissante de cette technologie, ses considérations et défis de sécurité spécifiques sont désormais abordés dans une section dédiée.\n\nDes efforts ont également été déployés pour garantir que les chapitres et sections soient organisés autour d’ensembles cohérents d’exigences connexes.\n\nCette restructuration a conduit à la création de chapitres supplémentaires :\n\n* Jetons autonomes – Auparavant regroupés sous la rubrique « gestion de session », les jetons autonomes sont désormais reconnus comme un mécanisme distinct et un élément fondamental de la communication sans état (comme dans OAuth et OIDC). En raison de leurs implications spécifiques en matière de sécurité, elles sont traitées dans un chapitre dédié, avec l'introduction de nouvelles exigences dans la version 5.x.\n* Sécurité du frontend web – Avec la complexité croissante des applications basées sur un navigateur et l'essor des architectures exclusivement basées sur des API, les exigences de sécurité du frontend ont été séparées dans un chapitre dédié.\n* Codage et architecture sécurisés – Les nouvelles exigences concernant les pratiques de sécurité générales qui ne cadraient pas avec les chapitres existants ont été regroupées ici.\n\nD'autres modifications organisationnelles ont été apportées à la version 5.0 afin de clarifier l'intention. Par exemple, les exigences de validation des entrées ont été déplacées avec la logique métier, reflétant ainsi leur rôle dans l'application des règles métier, plutôt que d'être regroupées avec le nettoyage et l'encodage.\n\nL'ancien chapitre « Architecture » ​​de la version 1 a été supprimé. Sa section initiale contenait des exigences hors du périmètre, tandis que les sections suivantes ont été redistribuées aux chapitres concernés, les exigences étant dédupliquées et clarifiées si nécessaire.\n\n## Suppression des correspondances directes avec d'autres normes\n\nLes correspondances directes avec d'autres normes ont été supprimées du corps du référentiel. L'objectif est de préparer une correspondance avec le projet OWASP Common Requirement Enumeration (CRE), qui reliera ASVS à divers projets OWASP et normes externes.\n\nLes correspondances directes avec CWE et NIST ne sont plus maintenues, comme expliqué ci-dessous.\n\n### Couplage réduit avec les directives du NIST sur l'identité numérique\n\nLes directives du NIST sur l'identité numérique (SP 800-63) (https://pages.nist.gov/800-63-3/) servent depuis longtemps de référence pour les contrôles d'authentification et d'autorisation. Dans la version 4.x, certains chapitres étaient étroitement alignés sur la structure et la terminologie du NIST.\n\nSi ces directives demeurent une référence importante, un alignement strict a engendré des difficultés, notamment une terminologie moins reconnue, la duplication d'exigences similaires et des correspondances incomplètes. La version 5.0 s'éloigne de cette approche pour plus de clarté et de pertinence.\n\n### S'éloigner de l'énumération des faiblesses communes (CWE)\n\nL'[Énumération des Faiblesses Communes (CWE)](https://cwe.mitre.org/) fournit une taxonomie utile des faiblesses de sécurité logicielle. Cependant, des défis tels que les CWE par catégorie, les difficultés de correspondance des exigences à une CWE unique et la présence de mappages imprécis dans la version 4.x ont conduit à la décision d'abandonner les mappages CWE directs dans la version 5.0.\n\n## Repenser les définitions de niveaux\n\nLa version 4.x décrivait les niveaux comme L1 (« Minimum »), L2 (« Standard ») et L3 (« Avancé »), ce qui implique que toutes les applications manipulant des données sensibles doivent au moins atteindre le niveau L2.\n\nLa version 5.0 corrige plusieurs problèmes liés à cette approche, décrits dans les paragraphes suivants.\n\nEn pratique, alors que la version 4.x utilisait des graduations pour les indicateurs de niveau, la version 5.x utilise un simple numéro pour tous les formats du référentiel, notamment Markdown, PDF, DOCX, CSV, JSON et XML. Pour des raisons de rétrocompatibilité, les anciennes versions des sorties CSV, JSON et XML utilisant encore des graduations sont également générées.\n\n### Niveau d'entrée simplifié\n\nLes retours ont indiqué que le nombre important d'exigences de niveau 1 (environ 120), combiné à sa désignation comme niveau « minimum », insuffisant pour la plupart des applications, freinait l'adoption. La version 5.0 vise à lever cet obstacle en définissant le niveau 1 principalement autour des exigences de défense de première couche, ce qui se traduit par des exigences plus claires et moins nombreuses à ce niveau. À titre d'exemple, la version 4.0.3 comptait 128 exigences de niveau 1 sur un total de 278, soit 46 %. La version 5.0.0 compte 70 exigences de niveau 1 sur un total de 345, soit 20 %.\n\n### L'illusion de la testabilité\n\nUn facteur clé dans le choix des contrôles de niveau 1 dans la version 4.x était leur aptitude à être évalués par des tests d'intrusion externes de type « boîte noire ». Cependant, cette approche n'était pas totalement conforme à l'objectif du niveau 1 en tant qu'ensemble minimal de contrôles de sécurité. Certains utilisateurs ont fait valoir que le niveau 1 était insuffisant pour sécuriser les applications, tandis que d’autres ont trouvé qu’il était trop difficile à tester.\n\nS'appuyer sur la testabilité comme critère est à la fois relatif et parfois trompeur. Le fait qu'une exigence soit testable ne garantit pas qu'elle puisse être testée de manière automatisée ou simple. De plus, les exigences les plus facilement testables ne sont pas toujours celles qui ont le plus grand impact sur la sécurité ou les plus simples à mettre en œuvre.\n\nPar conséquent, dans la version 5.0, les décisions de niveau ont été prises principalement en fonction de la réduction des risques et en tenant compte de l'effort de mise en œuvre.\n\n### Pas seulement une question de risque\n\nL'utilisation de niveaux prescriptifs, basés sur les risques, imposant un niveau spécifique à certaines applications s'est avérée trop rigide. En pratique, la priorisation et la mise en œuvre des contrôles de sécurité dépendent de multiples facteurs, notamment la réduction des risques et les efforts nécessaires à leur mise en œuvre.\n\nPar conséquent, les organisations sont encouragées à atteindre le niveau qu'elles estiment devoir atteindre en fonction de leur maturité et du message qu'elles souhaitent transmettre à leurs utilisateurs.\n", "timestamp": "2025-10-24T11:40:09.672371"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x10-V1-Encoding-and-Sanitization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x10-V1-Encoding-and-Sanitization.md", "content": "# V1 Encodage et nettoyage\n\n## Objectif de contrôle\n\nCe chapitre aborde les failles de sécurité les plus courantes des applications web liées au traitement non sécurisé de données non fiables. Ces failles peuvent entraîner diverses vulnérabilités techniques, où les données non fiables sont interprétées selon les règles syntaxiques de l'interpréteur concerné.\n\nPour les applications web modernes, il est toujours préférable d'utiliser des API plus sûres, telles que les requêtes paramétrées, l'échappement automatique ou les Framework de création de modèles. Dans le cas contraire, un encodage, un échappement ou un nettoyage des sorties soigneusement effectués deviennent essentiels à la sécurité de l'application.\n\nLa validation des entrées constitue un mécanisme de défense en profondeur contre les contenus inattendus ou dangereux. Cependant, son objectif principal étant de garantir que le contenu entrant répond aux attentes fonctionnelles et métier, les exigences afférentes sont décrites dans le chapitre « Validation et logique métier ».\n\n## V1.1 Architecture d'encodage et de nettoyage\n\nLes sections ci-dessous présentent les exigences spécifiques à la syntaxe ou à l'interpréteur pour traiter en toute sécurité les contenus non sécurisés afin d'éviter les failles de sécurité. Ces exigences précisent l'ordre et le lieu de traitement. Elles visent également à garantir que les données soient stockées dans leur état d'origine et ne soient pas stockées sous une forme encodée ou échappée (par exemple, encodage HTML), afin d'éviter les problèmes de double encodage.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **1.1.1** | Vérifiez que l'entrée est décodée ou non échappée vers une forme canonique une seule fois, elle n'est décodée que lorsque des données codées sous cette forme sont attendues, et que cela est fait avant de traiter davantage l'entrée, par exemple, elle n'est pas effectuée après la validation ou la désinfection de l'entrée. | 2 |\n| **1.1.2** | Vérifiez que l'application effectue l'encodage et l'échappement de sortie soit comme étape finale avant d'être utilisée par l'interpréteur pour lequel elle est destinée, soit par l'interpréteur lui-même. | 2 |\n\n## V1.2 Prévention des injections\n\nL'encodage ou l'échappement de sortie, effectué à proximité d'un contexte potentiellement dangereux, est essentiel pour la sécurité de toute application. Généralement, l'encodage et l'échappement de sortie ne sont pas conservés, mais servent à sécuriser la sortie pour une utilisation immédiate dans l'interpréteur approprié. Une tentative d'exécution trop précoce peut entraîner une altération du contenu ou rendre l'encodage ou l'échappement inefficaces.\n\nDans de nombreux cas, les bibliothèques logicielles incluent des fonctions sûres ou plus sûres qui exécutent cela automatiquement, même s'il est nécessaire de s'assurer qu'elles sont correctes pour le contexte actuel.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **1.2.1** | Vérifiez que l'encodage de sortie d'une réponse HTTP, d'un document HTML ou d'un document XML est pertinent pour le contexte requis, comme l'encodage des caractères pertinents pour les éléments HTML, les attributs HTML, les commentaires HTML, les CSS ou les champs d'en-tête HTTP, pour éviter de modifier la structure du message ou du document. | 1 |\n| **1.2.2** | Vérifiez que, lors de la création dynamique d'URL, les données non fiables sont encodées en fonction de leur contexte (par exemple, encodage d'URL ou encodage base64url pour les paramètres de requête ou de chemin). Assurez-vous que seuls les schémas d'URL sûrs sont autorisés (par exemple, interdire javascript: ou data:). | 1 |\n| **1.2.3** | Vérifiez que l'encodage ou l'échappement de sortie est utilisé lors de la création dynamique de contenu JavaScript (y compris JSON), pour éviter de modifier la structure du message ou du document (pour éviter l'injection JavaScript et JSON). | 1 |\n| **1.2.4** | Vérifiez que la sélection de données ou les requêtes de base de données (par exemple, SQL, HQL, NoSQL, Cypher) utilisent des requêtes paramétrées, des ORM, des Framework d'entités ou sont protégées contre les injections SQL et autres attaques par injection de base de données. Ceci est également pertinent lors de l'écriture de procédures stockées. | 1 |\n| **1.2.5** | Vérifiez que l’application protège contre l’injection de commandes du système d’exploitation et que les appels du système d’exploitation utilisent des requêtes du système d’exploitation paramétrées ou utilisent un encodage de sortie de ligne de commande contextuelle. | 1 |\n| **1.2.6** | Vérifiez que l’application protège contre les vulnérabilités d’injection LDAP ou que des contrôles de sécurité spécifiques pour empêcher l’injection LDAP ont été mis en œuvre. | 2 |\n| **1.2.7** | Vérifiez que l’application est protégée contre les attaques par injection XPath en utilisant la paramétrisation des requêtes ou des requêtes précompilées. | 2 |\n| **1.2.8** | Vérifiez que les processeurs LaTeX sont configurés de manière sécurisée (par exemple, en n'utilisant pas l'indicateur « --shell-escape ») et qu'une liste d’autorisations de commandes est utilisée pour empêcher les attaques par injection LaTeX. | 2 |\n| **1.2.9** | Vérifiez que l'application échappe les caractères spéciaux dans les expressions régulières (généralement à l'aide d'une barre oblique inverse) pour éviter qu'ils ne soient mal interprétés comme des métacaractères. | 2 |\n| **1.2.10** | Vérifiez que l'application est protégée contre les injections CSV et injections de formules. L'application doit respecter les règles d'échappement définies dans les sections 2.6 et 2.7 de la RFC 4180 lors de l'export de contenu CSV. De plus, lors de l'export au format CSV ou vers d'autres formats de tableur (tels que XLS, XLSX ou ODF), les caractères spéciaux (notamment « = », « + », « - », « @ », « \\t » (tabulation) et « \\0 » (caractère null)) doivent être protégés par une apostrophe s'ils apparaissent en premier dans une valeur de champ. | 3 |\n\nRemarque : L'utilisation de requêtes paramétrées ou l'échappement SQL ne sont pas toujours suffisants. Les parties de requête telles que les noms de table et de colonne (y compris les noms de colonne « ORDER BY ») ne peuvent pas être échappées. L'inclusion de données utilisateur échappées dans ces champs entraîne l'échec des requêtes ou une injection SQL.\n\n## V1.3 Nettoyage\n\nLa protection idéale contre l'utilisation de contenu non fiable dans un contexte dangereux est d'utiliser un encodage ou un échappement spécifique au contexte, qui conserve la même signification sémantique du contenu dangereux mais le rend sûr pour une utilisation dans ce contexte particulier, comme expliqué plus en détail dans la section précédente.\n\nLorsque cela n'est pas possible, un nettoyage devient nécessaire, supprimant les caractères ou contenus potentiellement dangereux. Dans certains cas, cela peut modifier la signification sémantique de la saisie, mais pour des raisons de sécurité, il peut n'y avoir aucune autre solution.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **1.3.1** | Vérifiez que toutes les entrées HTML non fiables provenant d'éditeurs WYSIWYG ou similaires sont nettoyées à l'aide d'une bibliothèque ou d'une fonctionnalité de Framework de nettoyage HTML bien connue et sécurisée. | 1 |\n| **1.3.2** | Vérifiez que l'application évite d'utiliser eval() ou d'autres fonctionnalités d'exécution de code dynamique telles que Spring Expression Language (SpEL). En l'absence d'alternative, toute saisie utilisateur incluse doit être nettoyée avant d'être exécutée. | 1 |\n| **1.3.3** | Vérifiez que les données transmises à un contexte potentiellement dangereux sont préalablement nettoyées pour appliquer des mesures de sécurité, telles qu'autoriser uniquement des caractères sûrs pour ce contexte et raccourcir des entrées trop longues. | 2 |\n| **1.3.4** | Vérifiez que le contenu Scalable Vector Graphics (SVG) scriptable fourni par l'utilisateur est validé ou nettoyé pour contenir uniquement des balises et des attributs (tels que des graphiques de dessin) qui sont sûrs pour l'application, par exemple, ne contiennent pas de scripts et d'objets étrangers. | 2 |\n| **1.3.5** | Vérifiez que l'application nettoie ou désactive le contenu du langage de modèle d'expression ou de script fourni par l'utilisateur, tel que les feuilles de style CSS, le Markdown ou XSL, BBCode ou similaire. | 2 |\n| **1.3.6** | Vérifiez que l'application protège contre les attaques de falsification de requête côté serveur (SSRF), en validant les données non fiables par rapport à une liste d'autorisation de protocoles, de domaines, de chemins et de ports et en nettoyant les caractères potentiellement dangereux avant d'utiliser les données pour appeler un autre service. | 2 |\n| **1.3.7** | Vérifiez que l'application se protège contre les attaques par injection de modèles en interdisant la création de modèles basés sur des entrées non fiables. En l'absence d'alternative, toute entrée non fiable incluse dynamiquement lors de la création du modèle doit être nettoyée ou rigoureusement validée. | 2 |\n| **1.3.8** | Vérifiez que l’application nettoie correctement les entrées non fiables avant utilisation dans les requêtes Java Naming and Directory Interface (JNDI) et que JNDI est configuré de manière sécurisée pour empêcher les attaques par injection JNDI. | 2 |\n| **1.3.9** | Vérifiez que l’application nettoie le contenu avant qu’il ne soit envoyé à memcache pour éviter les attaques par injection. | 2 |\n| **1.3.10** | Vérifiez que les chaînes de format susceptibles d'être résolues de manière inattendue ou malveillante lors de leur utilisation sont nettoyées avant d'être traitées. | 2 |\n| **1.3.11** | Vérifiez que l'application nettoie les entrées utilisateur avant de les transmettre aux systèmes de messagerie pour se protéger contre l'injection SMTP ou IMAP. | 2 |\n| **1.3.12** | Vérifiez que les expressions régulières sont exemptes d'éléments provoquant \"backtracking\" exponentiel et assurez-vous que les entrées non fiables sont nettoyées pour atténuer les attaques ReDoS ou Runaway Regex. | 3 |\n\n## V1.4 Mémoire, chaine de caractères et code à mémoire non-managée\n\nLes exigences suivantes traitent des risques associés à une utilisation non sécurisée de la mémoire, qui s’appliquent généralement lorsque l’application utilise un langage système ou un code à mémoire non-managée.\n\nDans certains cas, il peut être possible d'y parvenir en définissant des indicateurs de compilateur qui activent les protections contre les dépassements de tampon et les avertissements, y compris la randomisation de la pile et la prévention de l'exécution des données, et qui interrompent la construction si des opérations de pointeur, de mémoire, de chaîne de format, d'entier ou de chaine de caractères non sûres sont trouvées.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **1.4.1** | Vérifiez que l'application utilise des chaînes memory-safe, une copie de mémoire et une arithmétique de pointeur renforcée pour détecter ou empêcher les débordements de pile, de tampon ou de tas. | 2 |\n| **1.4.2** | Vérifiez que les techniques de validation du signe, de la plage et de l’entrée sont utilisées pour éviter les dépassements d’entiers. | 2 |\n| **1.4.3** | Vérifiez que la mémoire et les ressources allouées dynamiquement sont libérées et que les références ou les pointeurs vers la mémoire libérée sont supprimés ou définis à null pour éviter les \"dangling pointer\" et les vulnérabilités d'utilisation après libération. | 2 |\n\n## V1.5 Désérialisation sécurisée\n\nLa conversion de données stockées ou transmises en objets applicatifs (désérialisation) a toujours été à l'origine de diverses vulnérabilités par injection de code. Il est important d'effectuer ce processus avec précaution et de manière sécurisée pour éviter ce type de problèmes.\n\nEn particulier, certaines méthodes de désérialisation ont été identifiées par la documentation des langages de programmation ou des Framework comme étant non sécurisées et ne peuvent être sécurisées avec des données non fiables. Pour chaque mécanisme utilisé, une vérification rigoureuse doit être effectuée.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **1.5.1** | Vérifiez que l'application configure les \"parser\" XML pour utiliser une configuration restrictive et que les fonctionnalités non sûres telles que la résolution d'entités externes sont désactivées pour empêcher les attaques XML eXternal Entity (XXE). | 1 |\n| **1.5.2** | Vérifiez que la désérialisation des données non fiables garantit une gestion sécurisée des entrées, par exemple en utilisant une liste d'autorisation de types d'objets ou en limitant les types d'objets définis par le client, afin d'empêcher les attaques par désérialisation. Les mécanismes de désérialisation explicitement définis comme non sécurisés ne doivent pas être utilisés avec des entrées non fiables. | 2 |\n| **1.5.3** | Vérifiez que les différents \"parser\" utilisés dans l'application pour le même type de données (par exemple, les \"parser\" JSON, les \"parser\" XML, les \"parser\" d'URL) effectuent l'analyse de manière cohérente et utilisent le même mécanisme d'encodage de caractères pour éviter des problèmes tels que les vulnérabilités d'interopérabilité JSON ou un comportement d'analyse d'URI ou de fichier différent exploité dans les attaques d'inclusion de fichiers à distance (RFI) ou de falsification de requête côté serveur (SSRF). | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n* [OWASP Web Security Testing Guide: Client-Side Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files](https://datatracker.ietf.org/doc/html/rfc4180#section-2)\n\nPour plus d'informations, notamment sur les problèmes de désérialisation ou d'analyse, veuillez consulter :\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [An Exploration of JSON Interoperability Vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)\n* [Orange Tsai - A New Era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:09.741043"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x11-V2-Validation-and-Business-Logic.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x11-V2-Validation-and-Business-Logic.md", "content": "# V2 Validation et logique métier\n\n## Objectif de contrôle\n\nCe chapitre vise à garantir qu'une application vérifiée répond aux objectifs de haut niveau suivants :\n\n* Les entrées reçues par l'application correspondent aux attentes métier ou fonctionnelles.\n* Le flux logique métier est séquentiel, traité dans l’ordre et ne peut pas être contourné.\n* La logique métier inclut des limites et des contrôles pour détecter et prévenir les attaques automatisées, telles que les transferts continus de petits fonds ou l'ajout d'un million d'amis un par un.\n* Les flux logiques métier à haute valeur ajoutée ont pris en compte les cas d'abus et les acteurs malveillants, et disposent de protections contre l'usurpation d'identité, la falsification, la divulgation d'informations et les attaques par élévation de privilèges.\n\n## V2.1 Validation et documentation de la logique métier\n\nLa documentation de validation et de logique métier doit définir clairement les limites de la logique métier, les règles de validation et la cohérence contextuelle des éléments de données combinés, afin que ce qui doit être implémenté dans l'application soit clair.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **2.1.1** | Vérifiez que la documentation de l'application définit des règles de validation des entrées pour vérifier la validité des éléments de données par rapport à la structure attendue. Il peut s'agir de formats de données courants tels que des numéros de carte de crédit, des adresses e-mail ou des numéros de téléphone, ou d'un format de données interne. | 1 |\n| **2.1.2** | Vérifiez que la documentation de l'application définit comment valider la cohérence logique et contextuelle des éléments de données combinés, par exemple en vérifiant que la banlieue et le code postal correspondent. | 2 |\n| **2.1.3** | Vérifiez que les attentes en matière de limites et de validations de la logique métier sont documentées, y compris par utilisateur et globalement dans l'application. | 2 |\n\n## V2.2 Validation des entrées\n\nDes contrôles de validation des entrées efficaces renforcent les attentes métier ou fonctionnelles concernant le type de données que l'application s'attend à recevoir. Cela garantit une bonne qualité des données et réduit la surface d'attaque. Cependant, cela ne supprime ni ne remplace la nécessité d'utiliser un codage, un paramétrage ou un nettoyage corrects lors de l'utilisation des données dans un autre composant ou pour leur présentation en sortie.\n\nDans ce contexte, les « entrées » peuvent provenir d'une grande variété de sources, notamment des champs de formulaire HTML, des requêtes REST, des paramètres d'URL, des champs d'en-tête HTTP, des cookies, des fichiers sur disque, des bases de données et des API externes.\n\nUn contrôle de logique métier peut vérifier qu'une entrée particulière est un nombre inférieur à 100. Une attente fonctionnelle peut vérifier qu'un nombre est inférieur à un certain seuil, car ce nombre contrôle le nombre de fois qu'une boucle particulière aura lieu, et un nombre élevé pourrait entraîner un traitement excessif et une condition potentielle de déni de service.\n\nBien que la validation de schéma ne soit pas explicitement obligatoire, elle peut être le mécanisme le plus efficace pour une couverture de validation complète des API HTTP ou d'autres interfaces qui utilisent JSON ou XML.\n\nVeuillez noter les points suivants concernant la validation du schéma :\n\n* La « version publiée » de la spécification de validation du schéma JSON est considérée comme prête pour la production, mais pas à proprement parler « stable ». Lorsque vous utilisez la validation du schéma JSON, assurez-vous qu'il n'y a aucune lacune par rapport aux instructions des exigences ci-dessous.\n* Toutes les bibliothèques de validation de schéma JSON utilisées doivent également être surveillées et mises à jour si nécessaire une fois la norme formalisée.\n* La validation DTD ne doit pas être utilisée et l'évaluation DTD du Framework doit être désactivée pour éviter les problèmes liés aux attaques XXE contre les DTD.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **2.2.1** | Vérifier que les entrées sont validées afin de respecter les attentes métier ou fonctionnelles. Cette validation doit être basée sur une liste de valeurs, de modèles et de plages autorisées, ou sur la comparaison des entrées avec une structure attendue et des limites logiques selon des règles prédéfinies. Pour le niveau 1, cette validation peut se concentrer sur les entrées utilisées pour prendre des décisions métier ou de sécurité spécifiques. À partir du niveau 2, elle doit s'appliquer à toutes les entrées. | 1 |\n| **2.2.2** | Vérifiez que l'application est conçue pour appliquer la validation des entrées au niveau d'une couche de service de confiance. Bien que la validation côté client améliore l'ergonomie et doit être encouragée, elle ne doit pas être considérée comme un contrôle de sécurité. | 1 |\n| **2.2.3** | Vérifiez que l’application garantit que les combinaisons d’éléments de données associés sont raisonnables selon les règles prédéfinies. | 2 |\n\n## V2.3 Sécurité de la logique métier\n\nCette section examine les exigences clés pour garantir que l’application applique les processus de logique métier de manière correcte et n’est pas vulnérable aux attaques qui exploitent la logique et le flux de l’application.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **2.3.1** | Vérifiez que l’application traitera uniquement les flux de logique métier pour le même utilisateur dans l’ordre séquentiel attendu et sans sauter d’étapes. | 1 |\n| **2.3.2** | Vérifiez que les limites de la logique métier sont implémentées conformément à la documentation de l'application, afin d'éviter que des failles de la logique métier ne soient pas exploitées. | 2 |\n| **2.3.3** | Vérifiez que les transactions sont utilisées au niveau de la logique métier de telle sorte qu'une opération de logique métier réussisse dans son intégralité ou qu'elle soit restaurée à l'état correct précédent. | 2 |\n| **2.3.4** | Vérifiez que les mécanismes de verrouillage au niveau de la logique métier sont utilisés pour garantir que les ressources en quantité limitée (telles que les sièges de théâtre ou les créneaux de livraison) ne peuvent pas être réservées deux fois en manipulant la logique de l'application. | 2 |\n| **2.3.5** | Vérifiez que les flux logiques métier à forte valeur ajoutée nécessitent l'approbation de plusieurs utilisateurs afin d'éviter toute action non autorisée ou accidentelle. Cela peut inclure, sans s'y limiter, les transferts monétaires importants, les approbations de contrats, l'accès à des informations classifiées ou les contournements de sécurité dans le secteur manufacturier. | 3 |\n\n## V2.4 Anti-automatisation\n\nCette section comprend des contrôles anti-automatisation pour garantir que les interactions de type humaine sont requises et que les demandes automatisées excessives sont évitées.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **2.4.1** | Vérifiez que des contrôles anti-automatisation sont en place pour protéger contre les appels excessifs aux fonctions d'application qui pourraient conduire à l'exfiltration de données, à la création de données inutiles, à l'épuisement des quotas, aux violations de limites de débit, au déni de service ou à la surutilisation de ressources coûteuses. | 2 |\n| **2.4.2** | Vérifiez que les flux logiques métier nécessitent un timing humain réaliste, évitant ainsi des soumissions de transactions excessivement rapides. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide 4.2: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Web Security Testing Guide 4.2: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README)\n* La lutte contre l'automatisation peut se faire de différentes manières, notamment par l'utilisation de l'[OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n", "timestamp": "2025-10-24T11:40:09.843299"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x12-V3-Web-Frontend-Security.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x12-V3-Web-Frontend-Security.md", "content": "# V3 Sécurité du frontend Web\n\n## Objectif de contrôle\n\nCette catégorie se concentre sur les exigences visant à protéger contre les attaques exécutées via un frontend web. Ces exigences ne s'appliquent pas aux solutions \"machine-to-machine\".\n\n## V3.1 Documentation sur la sécurité du frontend Web\n\nCette section décrit les fonctionnalités de sécurité du navigateur qui doivent être spécifiées dans la documentation de l'application.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.1.1** | Vérifiez que la documentation de l'application indique les fonctionnalités de sécurité attendues que les navigateurs utilisant l'application doivent prendre en charge (telles que HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP) et autres mécanismes de sécurité HTTP pertinents). Elle doit également définir le comportement de l'application lorsque certaines de ces fonctionnalités ne sont pas disponibles (par exemple, avertir l'utilisateur ou bloquer l'accès). | 3 |\n\n## V3.2 Interprétation non intentionnelle du contenu\n\nLe rendu de contenu ou de fonctionnalité dans un contexte incorrect peut entraîner l'exécution ou l'affichage de contenu malveillant.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.2.1** | Vérifiez que des contrôles de sécurité sont en place pour empêcher les navigateurs d'afficher du contenu ou des fonctionnalités dans les réponses HTTP dans un contexte incorrect (par exemple, lorsqu'une API, un fichier téléchargé par l'utilisateur ou une autre ressource est demandée directement). Les contrôles possibles peuvent inclure : ne pas transmettre le contenu sauf si les champs d'en-tête de requête HTTP (tels que Sec-Fetch-\\*) indiquent qu'il s'agit du contexte correct, utiliser la directive sandbox du champ d'en-tête Content-Security-Policy ou utiliser le type de disposition de pièce jointe dans le champ d'en-tête Content-Disposition. | 1 |\n| **3.2.2** | Vérifiez que le contenu destiné à être affiché sous forme de texte, plutôt que rendu sous forme de HTML, est géré à l'aide de fonctions de rendu sécurisées (telles que createTextNode ou textContent) pour empêcher l'exécution involontaire de contenu tel que HTML ou JavaScript. | 1 |\n| **3.2.3** | Vérifiez que l'application évite l'écrasement du DOM lors de l'utilisation de JavaScript côté client en utilisant des déclarations de variables explicites, en effectuant une vérification de type stricte, en évitant de stocker des variables globales sur l'objet document et en implémentant l'isolation de l'espace de nommage. | 3 |\n\n## V3.3 Configuration des cookies\n\nCette section décrit les exigences de configuration sécurisée des cookies sensibles afin de fournir un niveau d'assurance plus élevé qu'ils ont été créés par l'application elle-même et d'empêcher que leur contenu ne fuite ou ne soit modifié de manière inappropriée.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.3.1** | Vérifiez que les cookies ont l'attribut « Secure » ​​défini et si le préfixe « \\__Host- » n'est pas utilisé pour le nom du cookie, le préfixe « __Secure- » doit être utilisé pour le nom du cookie. | 1 |\n| **3.3.2** | Vérifiez que la valeur de l'attribut « SameSite » de chaque cookie est définie en fonction de l'objectif du cookie, afin de limiter l'exposition aux attaques de réparation de l'interface utilisateur et aux attaques de falsification de requêtes basées sur le navigateur, communément appelées falsification de requêtes intersites (CSRF). | 2 |\n| **3.3.3** | Vérifiez que les cookies ont le préfixe « __Host- » pour le nom du cookie, sauf s'ils sont explicitement conçus pour être partagés avec d'autres hôtes. | 2 |\n| **3.3.4** | Vérifiez que si la valeur d'un cookie n'est pas censée être accessible aux scripts côté client (comme un jeton de session), le cookie doit avoir l'attribut « HttpOnly » défini et la même valeur (par exemple, un jeton de session) ne doit être transférée au client que via le champ d'en-tête « Set-Cookie ». | 2 |\n| **3.3.5** | Vérifiez que lorsque l'application écrit un cookie, la longueur combinée du nom et de la valeur du cookie ne dépasse pas 4 096 octets. Les cookies trop volumineux ne seront pas stockés par le navigateur et ne seront donc pas envoyés avec les requêtes, empêchant ainsi l'utilisateur d'utiliser les fonctionnalités de l'application qui reposent sur ce cookie. | 3 |\n\n## V3.4 En-têtes du mécanisme de sécurité du navigateur\n\nCette section décrit les en-têtes de sécurité qui doivent être définis sur les réponses HTTP pour activer les fonctionnalités et restrictions de sécurité du navigateur lors du traitement des réponses de l'application.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.4.1** | Vérifiez qu'un champ d'en-tête Strict-Transport-Security est inclus dans toutes les réponses afin d'appliquer une politique HTTP Strict Transport Security (HSTS). Une durée maximale d'au moins un an doit être définie, et pour les niveaux L2 et supérieurs, la politique doit également s'appliquer à tous les sous-domaines. | 1 |\n| **3.4.2** | Vérifiez que le champ d'en-tête Access-Control-Allow-Origin du partage de ressources cross-origine (CORS) est une valeur fixe de l'application ou, si la valeur du champ d'en-tête de requête HTTP Origin est utilisée, qu'elle est validée par rapport à une liste d'origines approuvées. Si « Access-Control-Allow-Origin: * » doit être utilisé, vérifiez que la réponse ne contient aucune information sensible. | 1 |\n| **3.4.3** | Vérifiez que les réponses HTTP incluent un champ d'en-tête de réponse Content-Security-Policy qui définit des directives garantissant que le navigateur charge et exécute uniquement du contenu ou des ressources fiables, afin de limiter l'exécution de JavaScript malveillant. Au minimum, une politique globale doit être utilisée, incluant les directives object-src 'none' et base-uri 'none', et définissant soit une lliste d’autorisations, soit des valeurs nonces ou des hachages. Pour une application L3, une politique par réponse avec des valeurs nonces ou des hachages doit être définie. | 2 |\n| **3.4.4** | Vérifiez que toutes les réponses HTTP contiennent un champ d'en-tête « X-Content-Type-Options: nosniff ». Cela indique aux navigateurs de ne pas utiliser l'analyse de contenu ni la détection du type MIME pour la réponse donnée, et d'exiger que la valeur du champ d'en-tête « Content-Type » de la réponse corresponde à la ressource de destination. Par exemple, la réponse à une demande de style n'est acceptée que si le type de contenu de la réponse est « text/css ». Cela permet également au navigateur d'utiliser la fonctionnalité de blocage de lecture inter-origines (CORB). | 2 |\n| **3.4.5** | Vérifiez que l'application définit une politique de référencement afin d'empêcher la fuite de données techniquement sensibles vers des services tiers via le champ d'en-tête de requête HTTP « Referer ». Cela peut être effectué via le champ d'en-tête de réponse HTTP « Referrer-Policy » ou via les attributs d'élément HTML. Les données sensibles peuvent inclure le chemin d'accès et les données de requête dans l'URL, et pour les applications internes non publiques, le nom d'hôte. | 2 |\n| **3.4.6** | Vérifiez que l'application Web utilise la directive frame-ancestors du champ d'en-tête Content-Security-Policy pour chaque réponse HTTP afin de garantir qu'elle ne peut pas être intégrée par défaut et que l'intégration de ressources spécifiques n'est autorisée qu'en cas de nécessité. Notez que le champ d'en-tête X-Frame-Options, bien que pris en charge par les navigateurs, est obsolète et n'est pas forcément fiable. | 2 |\n| **3.4.7** | Vérifiez que le champ d’en-tête Content-Security-Policy spécifie un emplacement pour signaler les violations. | 3 |\n| **3.4.8** | Vérifiez que toutes les réponses HTTP qui lancent le rendu d'un document (comme les réponses de type text/html) incluent le champ d'en-tête 'Cross-Origin-Opener-Policy' avec la directive 'same-origin' ou s'ame-origin-allow-popups', selon les besoins. Cela empêche les attaques abusant de l'accès partagé aux objets Window, telles que le tabnabbing et le comptage d'images. | 3 |\n\n## V3.5 Séparation de l'origine du navigateur\n\nLorsqu'elle accepte une demande d'accès à une fonctionnalité sensible du côté du serveur, l'application doit s'assurer que la demande est initiée par l'application elle-même ou par un tiers de confiance et qu'elle n'a pas été falsifiée par un attaquant.\n\nLes fonctionnalités sensibles dans ce contexte peuvent inclure l'acceptation de soumission de formulaires pour des utilisateurs authentifiés et non authentifiés (comme une demande d'authentification), des opérations de changement d'état ou des fonctionnalités exigeantes en ressources (comme l'exportation de données).\n\nLes principales protections sont les politiques de sécurité du navigateur, comme la politique de même origine pour JavaScript et la logique SameSite pour les cookies. Le mécanisme de requête de pré-vérification cross-origin CORS est une autre protection courante. Ce mécanisme est essentiel pour les \"endpoints\" conçus pour être appelés depuis une origine différente, mais il peut également constituer un mécanisme utile de prévention contre la falsification de requêtes pour les \"endpoints\" qui ne sont pas conçus pour être appelés depuis une origine différente.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.5.1** | Vérifiez que, si l'application ne s'appuie pas sur le mécanisme de requête de pré-vérification cross-origin CORS pour empêcher les requêtes inter-origines non autorisées d'utiliser des fonctionnalités sensibles, ces requêtes sont validées afin de garantir leur origine. Cela peut se faire en utilisant et en validant des jetons anti-falsification ou en exigeant des champs d'en-tête HTTP supplémentaires qui ne sont pas des champs d'en-tête de requête CORS safelist. Ceci permet de se protéger contre les attaques de falsification de requêtes basées sur le navigateur, communément appelées falsification de requêtes intersites (CSRF). | 1 |\n| **3.5.2** | Vérifiez que, si l'application s'appuie sur le mécanisme de requête de pré-vérification cross-origin CORS pour empêcher l'utilisation inter-origines non autorisée de fonctionnalités sensibles, il est impossible d'appeler la fonctionnalité avec une requête qui ne déclenche pas de requête de pré-vérification cross-origin CORS. Cela peut nécessiter de vérifier les valeurs des champs d'en-tête de requête 'Origin' et 'Content-Type' ou d'utiliser un champ d'en-tête supplémentaire qui n'est pas un champ d'en-tête de la liste de sécurité CORS. | 1 |\n| **3.5.3** | Vérifiez que les requêtes HTTP destinées aux fonctionnalités sensibles utilisent des méthodes HTTP appropriées, telles que POST, PUT, PATCH ou DELETE, et non des méthodes définies comme « sûres » par la spécification HTTP, telles que HEAD, OPTIONS ou GET. Une validation stricte des champs d'en-tête de requête Sec-Fetch-* peut également être utilisée pour garantir que la requête ne provient pas d'un appel inter-origines inapproprié, d'une requête de navigation ou d'un chargement de ressources (comme une source d'image) inattendu. | 1 |\n| **3.5.4** | Vérifiez que des applications distinctes sont hébergées sur des noms d'hôte différents pour tirer parti des restrictions fournies par la politique de même origine, y compris la manière dont les documents ou scripts chargés par une origine peuvent interagir avec les ressources d'une autre origine et les restrictions basées sur le nom d'hôte sur les cookies. | 2 |\n| **3.5.5** | Vérifiez que les messages reçus par l'interface postMessage sont rejetés si l'origine du message n'est pas digne de confiance ou si la syntaxe du message n'est pas valide. | 2 |\n| **3.5.6** | Vérifiez que la fonctionnalité JSONP n'est activée nulle part dans l'application pour éviter les attaques Cross-Site Script Inclusion (XSSI). | 3 |\n| **3.5.7** | Vérifiez que les données nécessitant une autorisation ne sont pas incluses dans les réponses des ressources de script, comme les fichiers JavaScript, pour empêcher les attaques par inclusion de script intersite (XSSI). | 3 |\n| **3.5.8** | Vérifiez que les ressources authentifiées (telles que les images, les vidéos, les scripts et autres documents) peuvent être chargées ou intégrées pour le compte de l'utilisateur uniquement lorsque cela est prévu. Cela peut être réalisé en validant strictement les champs d'en-tête de requête HTTP Sec-Fetch-* afin de garantir que la requête ne provient pas d'un appel cross-origin inapproprié, ou en définissant un champ d'en-tête de réponse HTTP Cross-Origin-Resource-Policy restrictif pour indiquer au navigateur de bloquer le contenu renvoyé. | 3 |\n\n## V3.6 Intégrité des ressources externes\n\nCette section fournit des conseils pour l’hébergement sécurisé de contenu sur des sites tiers.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.6.1** | Vérifiez que les ressources côté client, telles que les bibliothèques JavaScript, les feuilles de style CSS ou les polices web, sont hébergées en externe (par exemple, sur un réseau de diffusion de contenu) uniquement si la ressource est statique et versionnée, et si l'intégrité des sous-ressources (SRI) est utilisée pour valider l'intégrité de la ressource. Si cela n'est pas possible, une décision de sécurité documentée doit justifier cette décision pour chaque ressource. | 3 |\n\n## V3.7 Autres considérations sur la sécurité du navigateur\n\nCette section comprend divers autres contrôles de sécurité et fonctionnalités de sécurité de navigateur modernes nécessaires pour la sécurité du navigateur côté client.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **3.7.1** | Vérifiez que l'application utilise uniquement des technologies côté client toujours prises en charge et considérées comme sécurisées. Parmi les technologies qui ne répondent pas à cette exigence figurent les plugins NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL ou les applets Java côté client. | 2 |\n| **3.7.2** | Vérifiez que l'application redirigera automatiquement l'utilisateur vers un nom d'hôte ou un domaine différent (qui n'est pas contrôlé par l'application) uniquement lorsque la destination apparaît sur une liste d'autorisation. | 2 |\n| **3.7.3** | Vérifiez que le domaine de premier niveau de l'application (par exemple, site.tld) ​​est ajouté à la liste de préchargement publique pour HTTP Strict Transport Security (HSTS). Cela garantit que l'utilisation de TLS pour l'application est intégrée directement dans les principaux navigateurs, plutôt que de dépendre uniquement du champ d'en-tête de réponse Strict-Transport-Security. | 3 |\n| **3.7.4** | Vérifiez que l'application affiche une notification lorsque l'utilisateur est redirigé vers une URL hors du contrôle de l'application, avec une option pour annuler la navigation. | 3 |\n| **3.7.5** | Vérifiez que l'application se comporte comme documenté (par exemple, en avertissant l'utilisateur ou en bloquant l'accès) si le navigateur utilisé pour accéder à l'application ne prend pas en charge les fonctionnalités de sécurité attendues. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes)\n* [OWASP Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [HSTS Browser Preload List submission form](https://hstspreload.org/)\n* [OWASP DOM Clobbering Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_Clobbering_Prevention_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:09.957510"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x13-V4-API-and-Web-Service.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x13-V4-API-and-Web-Service.md", "content": "# V4 API et service Web\n\n## Objectif de contrôle\n\nPlusieurs considérations s'appliquent spécifiquement aux applications exposant des API destinées aux navigateurs web ou à d'autres consommateurs (généralement via JSON, XML ou GraphQL). Ce chapitre présente les configurations et mécanismes de sécurité pertinents à appliquer.\n\nNotez que les problèmes d’authentification, de gestion de session et de validation des entrées des autres chapitres s’appliquent également aux API. Ce chapitre ne peut donc pas être sorti de son contexte ni testé de manière isolée.\n\n## V4.1 Sécurité du service Web générique\n\nCette section aborde les considérations générales sur la sécurité des services Web et, par conséquent, les pratiques d’hygiène de base des services Web.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **4.1.1** | Vérifiez que chaque réponse HTTP avec un corps de message contient un champ d'en-tête Content-Type qui correspond au contenu réel de la réponse, y compris le paramètre charset pour spécifier un codage de caractères sécurisé (par exemple, UTF-8, ISO-8859-1) conformément aux types de médias IANA, tels que « text/ », « /+xml » et « /xml ». | 1 |\n| **4.1.2** | Vérifiez que seuls les terminaux utilisateurs (destinés à l'accès manuel via un navigateur web) redirigent automatiquement de HTTP vers HTTPS, tandis que les autres services ou terminaux n'implémentent pas de redirections transparentes. Cela permet d'éviter qu'un client envoie par erreur des requêtes HTTP non chiffrées, mais que, comme ces requêtes sont automatiquement redirigées vers HTTPS, la fuite de données sensibles passe inaperçue. | 2 |\n| **4.1.3** | Vérifiez que tout champ d'en-tête HTTP utilisé par l'application et défini par une couche intermédiaire, telle qu'un équilibreur de charge, un proxy web ou un service backend-for-frontend, ne peut pas être remplacé par l'utilisateur final. Les exemples d'en-têtes peuvent inclure X-Real-IP, X-Forwarded-*, ou X-User-ID. | 2 |\n| **4.1.4** | Vérifiez que seules les méthodes HTTP explicitement prises en charge par l'application ou son API (y compris les OPTIONS lors des demandes de contrôle en amont) peuvent être utilisées et que les méthodes inutilisées sont bloquées. | 3 |\n| **4.1.5** | Vérifier que les signatures numériques par message sont utilisées pour fournir une assurance supplémentaire en plus des protections de transport pour les demandes ou les transactions qui sont très sensibles ou qui traversent un certain nombre de systèmes. | 3 |\n\n## V4.2 Validation de la structure des messages HTTP\n\nCette section explique comment la structure et les champs d'en-tête d'un message HTTP doivent être validés afin de prévenir les attaques telles que la contrebande de requêtes, le fractionnement de réponses, l'injection d'en-têtes et le déni de service via des messages HTTP trop longs.\n\nCes exigences sont pertinentes pour le traitement et la génération de messages HTTP généraux, mais sont particulièrement importantes lors de la conversion de messages HTTP entre différentes versions HTTP.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **4.2.1** | Vérifiez que tous les composants de l'application (y compris les équilibreurs de charge, les pares-feux et les serveurs d'applications) déterminent les limites des messages HTTP entrants à l'aide du mécanisme approprié à la version HTTP afin d'empêcher la contrebande de requêtes HTTP. Dans HTTP/1.x, si un champ d'en-tête Transfer-Encoding est présent, l'en-tête Content-Length doit être ignoré conformément à la RFC 2616. Avec HTTP/2 ou HTTP/3, si un champ d'en-tête Content-Length est présent, le récepteur doit s'assurer qu'il est cohérent avec la longueur des trames DATA. | 2 |\n| **4.2.2** | Vérifier que, lors de la génération de messages HTTP, le champ d'en-tête Content-Length n'entre pas en conflit avec la longueur du contenu déterminée par le cadrage du protocole HTTP, afin d'empêcher les attaques de type « request smuggling ». | 3 |\n| **4.2.3** | Vérifiez que l'application n'envoie ni n'accepte de messages HTTP/2 ou HTTP/3 avec des champs d'en-tête spécifiques à la connexion, tels que Transfer-Encoding, afin d'éviter les attaques par fractionnement de la réponse et par injection d'en-tête. | 3 |\n| **4.2.4** | Vérifiez que l'application n'accepte que les requêtes HTTP/2 et HTTP/3 dont les champs et valeurs d'en-tête ne contiennent pas de séquences CR (\\r), LF (\\n) ou CRLF (\\r\\n), afin d'éviter les attaques par injection d'en-tête. | 3 |\n| **4.2.5** | Vérifiez que, si l'application (backend ou frontend) construit et envoie des requêtes, elle utilise des mécanismes de validation, d'assainissement ou autres pour éviter de créer des URI (comme pour les appels API) ou des champs d'en-tête de requête HTTP (comme Authorization ou Cookie) qui sont trop longs pour être acceptés par le composant récepteur. Cela pourrait entraîner un déni de service, par exemple lors de l'envoi d'une requête trop longue (par exemple, un long champ d'en-tête de cookie), ce qui fait que le serveur répond toujours avec un statut d'erreur. | 3 |\n\n## V4.3 GraphQL\n\nGraphQL est de plus en plus utilisé pour créer des clients riches en données, peu couplés à divers services backend. Cette section aborde les considérations de sécurité pour GraphQL.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **4.3.1** | Vérifiez qu'une liste d'autorisation de requête, une limitation de profondeur, une limitation de quantité ou une analyse des coûts de requête est utilisée pour empêcher le déni de service (DoS) de GraphQL ou d'expression de la couche données en raison de requêtes imbriquées coûteuses. | 2 |\n| **4.3.2** | Vérifiez que les requêtes d’introspection GraphQL sont désactivées dans l’environnement de production, sauf si l’API GraphQL est destinée à être utilisée par d’autres parties. | 2 |\n\n## V4.4 WebSocket\n\nWebSocket est un protocole de communication qui fournit un canal de communication bidirectionnel simultané via une seule connexion TCP. Il a été normalisé par l'IETF sous la RFC 6455 en 2011 et se distingue de HTTP, bien qu'il soit conçu pour fonctionner sur les ports HTTP 443 et 80.\n\nCette section fournit les principales exigences de sécurité pour empêcher les attaques liées à la sécurité des communications et à la gestion des sessions qui exploitent spécifiquement ce canal de communication en temps réel.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **4.4.1** | Vérifiez que WebSocket sur TLS (WSS) est utilisé pour toutes les connexions WebSocket. | 1 |\n| **4.4.2** | Vérifiez que, lors de la négociation HTTP WebSocket initiale, le champ d’en-tête 'Origin' est vérifié par rapport à une liste d’origines autorisées pour l’application. | 2 |\n| **4.4.3** | Vérifiez que, si la gestion de session standard de l'application ne peut pas être utilisée, des jetons dédiés sont utilisés à cet effet, qui sont conformes aux exigences de sécurité de gestion de session pertinentes. | 2 |\n| **4.4.4** | Vérifiez que les jetons de gestion de session WebSocket dédiés sont initialement obtenus ou validés via la session HTTPS précédemment authentifiée lors de la transition d'une session HTTPS existante vers un canal WebSocket. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* Resources on GraphQL Authorization from [graphql.org](https://graphql.org/learn/authorization/) and [Apollo](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-methods).\n* [OWASP Web Security Testing Guide: GraphQL Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL)\n* [OWASP Web Security Testing Guide: Testing WebSockets](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets)\n", "timestamp": "2025-10-24T11:40:10.056525"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x14-V5-File-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x14-V5-File-Handling.md", "content": "# V5 Gestion des fichiers\n\n## Objectif de contrôle\n\nL'utilisation de fichiers peut présenter divers risques pour l'application, notamment le déni de service, l'accès non autorisé et l'épuisement de l'espace de stockage. Ce chapitre présente les exigences pour gérer ces risques.\n\n## V5.1 Documentation sur la gestion des fichiers\n\nCette section comprend l’obligation de documenter les caractéristiques attendues des fichiers acceptés par l’application, comme condition préalable nécessaire au développement et à la vérification des contrôles de sécurité pertinents.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **5.1.1** | Vérifiez que la documentation définit les types de fichiers autorisés, les extensions de fichiers attendues et la taille maximale (y compris la taille décompressée) pour chaque fonctionnalité de Téléversement. De plus, assurez-vous que la documentation précise comment les fichiers sont sécurisés pour le téléchargement et le traitement des utilisateurs finaux, par exemple le comportement de l'application lorsqu'un fichier malveillant est détecté.| 2 |\n\n## V5.2 Téléversement de fichiers et contenu\n\nLa fonctionnalité de téléversement de fichiers est une source majeure de fichiers non fiables. Cette section décrit les exigences permettant de garantir que la présence, le volume ou le contenu de ces fichiers ne nuisent pas à l'application.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **5.2.1** | Vérifiez que l'application n'acceptera que des fichiers d'une taille qu'elle peut traiter sans provoquer de perte de performances ou d'attaque par déni de service. | 1 |\n| **5.2.2** | Vérifiez que lorsque l'application accepte un fichier, seul ou dans une archive telle qu'un fichier zip, elle vérifie si l'extension de fichier correspond à une extension attendue et que le contenu correspond au type représenté par l'extension. Cela inclut, sans s'y limiter, la vérification des « octets magiques » initiaux, la réécriture d'images et l'utilisation de bibliothèques spécialisées pour la validation du contenu des fichiers. Pour le niveau L1, cela peut se concentrer uniquement sur les fichiers utilisés pour prendre des décisions métier ou de sécurité spécifiques. À partir du niveau L2, cela doit s'appliquer à tous les fichiers acceptés. | 1 |\n| **5.2.3** | Vérifiez que l'application vérifie les fichiers compressés (par exemple, zip, gz, docx, odt) par rapport à la taille maximale autorisée non compressée et au nombre maximal de fichiers avant de décompresser le fichier. | 2 |\n| **5.2.4** | Vérifiez qu'un quota de taille de fichier et un nombre maximal de fichiers par utilisateur sont appliqués pour garantir qu'un seul utilisateur ne puisse pas remplir le stockage avec trop de fichiers ou des fichiers excessivement volumineux. | 3 |\n| **5.2.5** | Vérifiez que l'application n'autorise pas le téléversement de fichiers compressés contenant des liens symboliques, sauf si cela est spécifiquement requis (auquel cas il sera nécessaire d'appliquer une liste d'autorisation des fichiers vers lesquels il est possible de créer des liens symboliques).| 3 |\n| **5.2.6** | Vérifiez que l'application rejette les images téléversées avec une taille de pixel supérieure au maximum autorisé, afin d'éviter les attaques par inondation de pixels.| 3 |\n\n## V5.3 Stockage de fichiers\n\nCette section comprend des exigences visant à empêcher l'exécution inappropriée des fichiers après leur téléversement, à détecter le contenu dangereux et à éviter que des données non fiables ne soient utilisées pour contrôler l'emplacement de stockage des fichiers.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **5.3.1** | Vérifiez que les fichiers téléversés ou générés par une entrée non fiable et stockés dans un dossier public ne sont pas exécutés en tant que code de programme côté serveur lorsqu'ils sont accessibles directement avec une requête HTTP. | 1 |\n| **5.3.2** | Vérifiez que lorsque l'application crée des chemins d'accès pour les opérations sur les fichiers, elle utilise des données générées en interne ou fiables plutôt que des noms de fichiers soumis par l'utilisateur. Si des noms de fichiers ou des métadonnées de fichiers soumis par l'utilisateur doivent être utilisés, une validation et un nettoyage stricts doivent être appliqués. Ceci permet de se protéger contre les attaques par traversée de chemin, l'inclusion de fichiers locaux ou distants (LFI, RFI) et la falsification de requêtes côté serveur (SSRF). | 1 |\n| **5.3.3** | Vérifiez que le traitement des fichiers côté serveur, comme la décompression des fichiers, ignore les informations de chemin fournies par l'utilisateur pour éviter les vulnérabilités telles que le \"zip slip\". | 3 |\n\n## V5.4 Téléchargement de fichier\n\nCette section décrit les exigences visant à atténuer les risques liés au téléchargement de fichiers, notamment les attaques par traversée de chemin et par injection. Elle s'assure également qu'ils ne contiennent pas de contenu dangereux.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **5.4.1** | Vérifiez que l’application valide ou ignore les noms de fichiers soumis par l’utilisateur, y compris dans un paramètre JSON, JSONP ou URL et spécifie un nom de fichier dans le champ d’en-tête Content-Disposition de la réponse. | 2 |\n| **5.4.2** | Vérifiez que les noms de fichiers servis (par exemple, dans les champs d'en-tête de réponse HTTP ou les pièces jointes aux e-mails) sont encodés ou nettoyés (par exemple, conformément à la RFC 6266) pour préserver la structure du document et empêcher les attaques par injection. | 2 |\n| **5.4.3** | Vérifiez que les fichiers obtenus à partir de sources non fiables sont analysés par des scanners antivirus pour empêcher la diffusion de contenu malveillant connu. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)\n* [Example of using symlinks for arbitrary file read](https://hackerone.com/reports/1439593)\n* [Explanation of \"Magic Bytes\" from Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures)\n", "timestamp": "2025-10-24T11:40:10.220889"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x15-V6-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x15-V6-Authentication.md", "content": "# V6 Authentification\n\n## Objectif de contrôle\n\nL'authentification est le processus permettant d'établir ou de confirmer l'authenticité d'une personne ou d'un appareil. Elle consiste à vérifier les déclarations d'une personne ou d'un appareil, à garantir la résistance à l'usurpation d'identité et à empêcher la récupération ou l'interception des mots de passe.\n\nLe [NIST SP 800-63](https://pages.nist.gov/800-63-3/) est une norme moderne, fondée sur des preuves, qui est précieuse pour les organisations du monde entier, mais qui est particulièrement pertinente pour les agences américaines et ceux qui intéragissent avec les agences américaines.\n\nBien que de nombreuses exigences de ce chapitre soient basées sur la deuxième section de la norme (appelée NIST SP 800-63B « Directives relatives à l'identité numérique - Authentification et gestion du cycle de vie »), ce chapitre se concentre sur les menaces courantes et les faiblesses d'authentification fréquemment exploitées. Il ne prétend pas couvrir tous les points de la norme de manière exhaustive. Pour les cas où une conformité totale à la norme NIST SP 800-63 est nécessaire, veuillez vous référer à cette dernière.\n\nDe plus, la terminologie du NIST SP 800-63 peut parfois différer, et ce chapitre utilise souvent une terminologie plus communément comprise pour améliorer la clarté.\n\nUne fonctionnalité commune aux applications plus avancées est la possibilité d'adapter les étapes d'authentification requises en fonction de divers facteurs de risque. Cette fonctionnalité est abordée dans le chapitre « Autorisation », car ces mécanismes doivent également être pris en compte dans les décisions d'autorisation.\n\n## V6.1 Documentation d'authentification\n\nCette section détaille les exigences relatives à la documentation d'authentification à conserver pour une application. Elle est essentielle à la mise en œuvre et à l'évaluation de la configuration des contrôles d'authentification pertinents.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.1.1** | Vérifiez que la documentation de l'application définit comment les contrôles, tels que la limitation de débit, l'anti-automatisation et la réponse adaptative, sont utilisés pour se défendre contre les attaques telles que le « credential stuffing » et la force brute des mots de passe. La documentation doit expliquer clairement comment ces contrôles sont configurés et empêcher le blocage malveillant des comptes. | 1 |\n| **6.1.2** | Vérifiez qu'une liste de mots spécifiques au contexte est documentée afin d'empêcher leur utilisation dans les mots de passe. Cette liste peut inclure des permutations de noms d'organisations, de produits, d'identifiants de systèmes, de noms de codes de projets, de noms de services ou de rôles, etc. | 2 |\n| **6.1.3** | Vérifiez que, si l'application inclut plusieurs voies d'authentification, celles-ci sont toutes documentées avec les contrôles de sécurité et la force d'authentification qui doivent être appliqués de manière cohérente. | 2 |\n\n## V6.2 Sécurité des mots de passe\n\nLes mots de passe, appelés « secrets mémorisés » par la norme NIST SP 800-63, comprennent les mots de passe, les phrases de passe, les codes PIN, les schémas de déverrouillage et choisir « le bon chaton » ou d'un autre élément d'image. Ils sont généralement considérés comme « quelque chose que vous connaissez » et sont souvent utilisés comme mécanisme d'authentification à facteur unique.\n\nCette section contient donc des exigences visant à garantir la création et la gestion sécurisées des mots de passe. La plupart des exigences sont de niveau 1, car elles sont les plus importantes à ce niveau. À partir du niveau 2, des mécanismes d'authentification multifacteur sont requis, les mots de passe pouvant être l'un de ces facteurs.\n\nLes exigences de cette section concernent principalement le chapitre [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) du [Guide du NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.2.1** | Vérifiez que les mots de passe définis par l'utilisateur comportent au moins 8 caractères, bien qu'un minimum de 15 caractères soit fortement recommandé. | 1 |\n| **6.2.2** | Vérifiez que les utilisateurs peuvent modifier leur mot de passe. | 1 |\n| **6.2.3** | Vérifiez que la fonctionnalité de changement de mot de passe nécessite le mot de passe actuel et le nouveau mot de passe de l'utilisateur. | 1 |\n| **6.2.4** | Vérifiez que les mots de passe soumis lors de l'enregistrement du compte ou du changement de mot de passe sont vérifiés par rapport à un ensemble disponible d'au moins 3 000 mots de passe principaux qui correspondent à la politique de mot de passe de l'application, par exemple la longueur minimale. | 1 |\n| **6.2.5** | Vérifiez que les mots de passe peuvent être utilisés, quelle que soit leur composition, sans restriction quant au type de caractères autorisés. Aucun nombre minimal de majuscules ou de minuscules, de chiffres ou de caractères spéciaux ne doit être exigé. | 1 |\n| **6.2.6** | Vérifiez que les champs de saisie du mot de passe utilisent type=password pour masquer la saisie. Les applications peuvent permettre à l'utilisateur d'afficher temporairement l'intégralité du mot de passe masqué ou le dernier caractère saisi. | 1 |\n| **6.2.7** | Vérifiez que la fonctionnalité « coller », les assistants de mot de passe du navigateur et les gestionnaires de mots de passe externes sont autorisés. | 1 |\n| **6.2.8** | Vérifiez que l'application vérifie le mot de passe de l'utilisateur exactement tel qu'il a été reçu de l'utilisateur, sans aucune modification telle qu'une troncature ou une transformation de casse. | 1 |\n| **6.2.9** | Vérifiez que les mots de passe d’au moins 64 caractères sont autorisés. | 2 |\n| **6.2.10** | Vérifiez que le mot de passe d'un utilisateur reste valide jusqu'à ce qu'il soit découvert comme compromis ou qu'il soit renouvelé. L'application ne doit pas exiger de renouvellement périodique des identifiants. | 2 |\n| **6.2.11** | Vérifiez que la liste documentée de mots spécifiques au contexte est utilisée pour éviter la création de mots de passe faciles à deviner. | 2 |\n| **6.2.12** | Vérifiez que les mots de passe soumis lors de l'enregistrement du compte ou des modifications de mot de passe sont vérifiés par rapport à un ensemble de mots de passe fuités. | 2 |\n\n## V6.3 Sécurité générale de l'authentification\n\nCette section contient les exigences générales relatives à la sécurité des mécanismes d'authentification et définit les différentes attentes en matière de niveaux. Les applications L2 doivent recourir à l'authentification multifacteur (MFA). Les applications L3 doivent utiliser une authentification matérielle, réalisée dans un environnement d'exécution certifié et approuvé (TEE). Cela peut inclure des clés d'accès liées à l'appareil, des authentificateurs eIDAS à niveau d'assurance élevé (LoA), des authentificateurs avec l'assurance NIST Authenticator Assurance Level 3 (AAL3) ou un mécanisme équivalent.\n\nBien qu'il s'agisse d'une position relativement agressive concernant l'authentification multifacteur, il est essentiel de relever le niveau à ce sujet pour protéger les utilisateurs, et toute tentative d'assouplissement de ces exigences doit être accompagnée d'un plan clair sur la manière dont les risques liés à l'authentification seront atténués, en tenant compte des orientations et des recherches du NIST sur le sujet.\n\nVeuillez noter qu'au moment de la publication, la norme NIST SP 800-63 considère l'email comme [non acceptable](https://pages.nist.gov/800-63-FAQ/#q-b11) comme mécanisme d'authentification ([copie archivée](https://pages.nist.gov/800-63-FAQ/#q-b11)).\n\nLes exigences de cette section concernent diverses sections du [Guide du NIST](https://pages.nist.gov/800-63-3/sp800-63b.html), incluant : [&sect; 4.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#421-permitted-authenticator-types), [&sect; 4.3.1](https://pages.nist.gov/800-63-3/sp800-63b.html#431-permitted-authenticator-types), [&sect; 5.2.2](https://pages.nist.gov/800-63-3/sp800-63b.html#522-rate-limiting-throttling), et [&sect; 6.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-612-post-enrollment-binding).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.3.1** | Vérifiez que les contrôles visant à empêcher les attaques telles que le bourrage d'informations d'identification et la force brute des mots de passe sont mis en œuvre conformément à la documentation de sécurité de l'application. | 1 |\n| **6.3.2** | Vérifiez que les comptes d’utilisateur par défaut (par exemple, « root », « admin » ou « sa ») ne sont pas présents dans l’application ou sont désactivés. | 1 |\n| **6.3.3** | Vérifiez que l’application exige que les utilisateurs utilisent un mécanisme d’authentification multifacteur ou une combinaison de mécanismes d’authentification à facteur unique. | 2 |\n| **6.3.4** | Vérifiez que, si l’application inclut plusieurs voies d’authentification, il n’existe aucune voie non documentée et que les contrôles de sécurité et la force d’authentification sont appliqués de manière cohérente. | 2 |\n| **6.3.5** | Vérifiez que les utilisateurs sont informés des tentatives d'authentification suspectes (réussies ou non). Il peut s'agir de tentatives d'authentification provenant d'un emplacement ou d'un client inhabituel, d'une authentification partiellement réussie (un seul facteur parmi plusieurs), d'une tentative d'authentification après une longue période d'inactivité ou d'une authentification réussie après plusieurs tentatives infructueuses. | 3 |\n| **6.3.6** | Vérifiez que le courrier électronique n’est pas utilisé comme mécanisme d’authentification à facteur unique ou à facteurs multiples. | 3 |\n| **6.3.7** | Vérifiez que les utilisateurs sont avertis après les mises à jour des détails d'authentification, telles que les réinitialisations d'informations d'identification ou la modification du nom d'utilisateur ou de l'adresse e-mail. | 3 |\n| **6.3.8** | Vérifiez que les utilisateurs valides ne peuvent pas être déduits d'échecs d'authentification, par exemple en se basant sur des messages d'erreur, des codes de réponse HTTP ou des temps de réponse différents. Les fonctionnalités d'inscription et de mot de passe oublié doivent également bénéficier de cette protection. | 3 |\n\n## V6.4 Cycle de vie et récupération du facteur d'authentification\n\nLes facteurs d'authentification peuvent inclure des mots de passe, des jetons logiciels, des jetons matériels et des dispositifs biométriques. La gestion sécurisée du cycle de vie de ces mécanismes est essentielle à la sécurité d'une application, et cette section présente les exigences afférentes.\n\nLes exigences de cette section concernent principalement les chapitres [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) ou [&sect; 6.1.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#replacement) of [Guide du NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.4.1** | Vérifiez que les mots de passe initiaux ou les codes d'activation générés par le système sont générés de manière aléatoire et sécurisée, qu'ils respectent la politique de mots de passe en vigueur et qu'ils expirent après une courte période ou après leur première utilisation. Ces secrets initiaux ne doivent pas devenir des mots de passe permanents. | 1 |\n| **6.4.2** | Vérifiez que les indices de mot de passe ou l'authentification basée sur les connaissances (appelées « questions secrètes ») ne sont pas présents. | 1 |\n| **6.4.3** | Vérifiez qu'un processus sécurisé de réinitialisation d'un mot de passe oublié est mis en œuvre, qui ne contourne aucun mécanisme d'authentification multifacteur activé. | 2 |\n| **6.4.4** | Vérifiez que si un facteur d'authentification multifacteur est perdu, la preuve de vérification d'identité est effectuée au même niveau que lors de l'inscription. | 2 |\n| **6.4.5** | Vérifiez que les instructions de renouvellement des mécanismes d'authentification qui expirent sont envoyées avec suffisamment de temps pour être exécutées avant l'expiration de l'ancien mécanisme d'authentification, en configurant des rappels automatiques si nécessaire. | 3 |\n| **6.4.6** | Vérifiez que les administrateurs peuvent initier la réinitialisation du mot de passe de l'utilisateur, mais que cela ne leur permet pas de modifier ou de choisir son mot de passe. Cela évite qu'ils ne connaissent le mot de passe de l'utilisateur. | 3 |\n\n## V6.5 Exigences générales en matière d'authentification multifacteur\n\nCette section fournit des conseils généraux qui seront pertinents pour différentes méthodes d’authentification multifacteur.\n\nLes mécanismes comprennent :\n\n* Secret recherché dans une table\n* Mots de passe à usage unique basés sur le temps (TOTP)\n* Mécanismes out-of-band\n\nLes secrets de recherche sont des listes pré-générées de codes secrets, similaires aux numéros d'autorisation de transaction (TAN), aux codes de récupération des réseaux sociaux ou à une grille contenant un ensemble de valeurs aléatoires. Ce type de mécanisme d'authentification est considéré comme « quelque chose que vous possédez », car les codes sont volontairement non mémorisables et doivent donc être stockés quelque part.\n\nLes mots de passe à usage unique basés sur le temps (TOTP) sont des jetons physiques ou logiciels qui affichent un code pseudo-aléatoire à usage unique et changeant en permanence. Ce type de mécanisme d'authentification est considéré comme « quelque chose que vous possédez ». Les TOTP multifactoriels sont similaires aux TOTP à simple facteur\", mais nécessitent la saisie d'un code PIN valide, un déverrouillage biométrique, une clé USB ou un appairage NFC, ou d'une valeur supplémentaire (comme des calculateurs de signature de transaction) pour créer le mot de passe à usage unique (OTP) final.\n\nDes détails sur les mécanismes out-of-band seront fournis dans la section suivante.\n\nLes exigences de ces sections concernent principalement les chapitres [&sect; 5.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-512-look-up-secrets), [&sect; 5.1.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-513-out-of-band-devices), [&sect; 5.1.4.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5142-single-factor-otp-verifiers), [&sect; 5.1.5.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5152-multi-factor-otp-verifiers), [&sect; 5.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#521-physical-authenticators), et [&sect; 5.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#523-use-of-biometrics) du [Guide du NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.5.1** | Vérifiez que les secrets de recherche, les demandes ou codes d'authentification out-of-band et les mots de passe à usage unique basés sur le temps (TOTP) ne peuvent être utilisés avec succès qu'une seule fois. | 2 |\n| **6.5.2** | Vérifiez que, lors de leur stockage dans le backend de l'application, les secrets de recherche comportant moins de 112 bits d'entropie (19 caractères alphanumériques aléatoires ou 34 chiffres aléatoires) sont hachés avec un algorithme de hachage de stockage de mots de passe approuvé, intégrant un sel aléatoire de 32 bits. Une fonction de hachage standard peut être utilisée si le secret comporte 112 bits d'entropie ou plus. | 2 |\n| **6.5.3** | Vérifiez que les secrets de recherche, le code d'authentification out-of-band et les mots de passe à usage unique basés sur le temps sont générés à l'aide d'un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé (CSPRNG) pour éviter les valeurs prévisibles. | 2 |\n| **6.5.4** | Vérifiez que les secrets de recherche et les codes d'authentification out-of-band ont un minimum de 20 bits d'entropie (généralement 4 caractères alphanumériques aléatoires ou 6 chiffres aléatoires suffisent). | 2 |\n| **6.5.5** | Vérifiez que les requêtes, codes ou jetons d'authentification out-of-band, ainsi que les mots de passe à usage unique (TOTP), ont une durée de vie définie. Les requêtes out-of-band doivent avoir une durée de vie maximale de 10 minutes et les TOTP, de 30 secondes. | 2 |\n| **6.5.6** | Vérifiez que tout facteur d’authentification (y compris les appareils physiques) peut être révoqué en cas de vol ou autre perte. | 3 |\n| **6.5.7** | Vérifiez que les mécanismes d’authentification biométrique ne sont utilisés que comme facteurs secondaires, avec quelque chose que vous possédez ou quelque chose que vous savez. | 3 |\n| **6.5.8** | Vérifiez que les mots de passe à usage unique basés sur le temps (TOTP) sont vérifiés en fonction d'une source temporelle provenant d'un service de confiance et non d'une heure non fiable ou fournie par le client. | 3 |\n\n## V6.6 Mécanismes d'authentification out-of-band\n\nCela implique généralement que le serveur d'authentification communique avec un appareil physique via un canal secondaire sécurisé. Par exemple, l'envoi de notifications push aux appareils mobiles. Ce type de mécanisme d'authentification est considéré comme « quelque chose que vous possédez ».\n\nLes mécanismes d'authentification out-of-band non sécurisés tels que le courrier électronique et la VoIP ne sont pas autorisés. L'authentification PSTN et SMS est actuellement considérée comme des [mécanismes d'authentification « restreints »](https://pages.nist.gov/800-63-FAQ/#q-b01) par le NIST et devrait être déconseillée au profit des mots de passe à usage unique basés sur le temps (TOTP), d'un mécanisme cryptographique ou similaire. La norme NIST SP 800-63B [&sect; 5.1.3.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-5133-authentication-using-the-public-switched-telephone-network) recommande de traiter les risques d'échange d'appareil, de changement de carte SIM, de portage de numéro ou d'autres comportements anormaux, si l'authentification out-of-band par téléphone ou SMS doit absolument être prise en charge. Bien que cette section ASVS n'impose pas cela comme une exigence, le fait de ne pas prendre ces précautions pour une application L2 sensible ou une application L3 doit être considéré comme un signal d'alarme important.\n\nNotez que le NIST a également récemment publié des directives [déconseillant l'utilisation des notifications push](https://pages.nist.gov/800-63-4/sp800-63b/authenticators/#fig-3). Bien que cette section ASVS ne le fasse pas, il est important d'être conscient des risques de « push bombing ».\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.6.1** | Vérifier que les mécanismes d'authentification utilisant le réseau téléphonique public commuté (RTPC) pour la transmission de mots de passe à usage unique (OTP) par téléphone ou SMS ne sont proposés que lorsque le numéro de téléphone a été préalablement validé. D'autres méthodes plus robustes (telles que les mots de passe à usage unique à durée déterminée) sont également proposées, et que le service informe les utilisateurs des risques de sécurité qu'elles présentent. Pour les applications de niveau 3, le téléphone et les SMS ne doivent pas être disponibles. | 2 |\n| **6.6.2** | Vérifiez que les demandes d’authentification out-of-band, les codes ou les jetons sont liés à la demande d’authentification d’origine pour laquelle ils ont été générés et ne sont pas utilisables pour une demande précédente ou ultérieure. | 2 |\n| **6.6.3** | Vérifiez qu'un mécanisme d'authentification out-of-band basé sur du code est protégé contre les attaques par force brute grâce au \"rate limiting\". Envisagez également d'utiliser un code avec au moins 64 bits d'entropie. | 2 |\n| **6.6.4** | Vérifiez que, lorsque les notifications push sont utilisées pour l'authentification multifacteur, le \"rate limiting\" est appliqué afin d'empêcher les attaques de type « push bombing ». La concordance des numéros peut également atténuer ce risque. | 3 |\n\n## V6.7 Mécanisme d'authentification cryptographique\n\nLes mécanismes d'authentification cryptographique incluent les cartes à puce ou les clés FIDO. L'utilisateur doit connecter ou appairer le dispositif cryptographique à l'ordinateur pour finaliser l'authentification. Le serveur d'authentification envoie un nonce de défi au dispositif ou au logiciel cryptographique, qui calcule une réponse à partir d'une clé cryptographique stockée de manière sécurisée. Les exigences de cette section fournissent des conseils spécifiques à la mise en œuvre de ces mécanismes, les conseils sur les algorithmes cryptographiques étant traités dans le chapitre « Cryptographie ».\n\nLorsque des clés partagées ou secrètes sont utilisées pour l'authentification cryptographique, elles doivent être stockées à l'aide des mêmes mécanismes que les autres secrets système, comme documenté dans la section « Gestion des secrets » du chapitre « Configuration ».\n\nLes exigences de cette section concernent principalement le chapitre [&sect; 5.1.7.2](https://pages.nist.gov/800-63-3/sp800-63b.html#sfcdv) du [Guide du NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.7.1** | Vérifiez que les certificats utilisés pour vérifier les assertions d’authentification cryptographique sont stockés de manière à les protéger contre toute modification. | 3 |\n| **6.7.2** | Vérifiez que le nonce de défi a une longueur d'au moins 64 bits et qu'il est statistiquement unique ou unique sur toute la durée de vie du périphérique cryptographique. | 3 |\n\n## V6.8 Authentification avec un fournisseur d'identité\n\nLes fournisseurs d'identité (IdP) fournissent une identité fédérée aux utilisateurs. Ces derniers possèdent souvent plusieurs identités auprès de plusieurs IdP, comme une identité d'entreprise utilisant Azure AD, Okta, Ping Identity ou Google, ou une identité grand public utilisant Facebook, Twitter, Google ou WeChat, pour ne citer que quelques alternatives courantes. Cette liste ne constitue pas une recommandation pour ces entreprises ou services, mais simplement un encouragement aux développeurs à prendre en compte le fait que de nombreux utilisateurs possèdent de nombreuses identités établies. Les organisations devraient envisager l'intégration avec les identités utilisateur existantes, en fonction du profil de risque lié à la fiabilité de la vérification d'identité de l'IdP. Par exemple, il est peu probable qu'une organisation gouvernementale accepte une identité de réseau social comme identifiant pour des systèmes sensibles, car il est facile de créer de fausses identités ou des identités jetables, tandis qu'une entreprise de jeux mobiles pourrait avoir besoin de s'intégrer aux principales plateformes de réseaux sociaux pour développer sa base de joueurs actifs.\n\nL'utilisation sécurisée de fournisseurs d'identité externes nécessite une configuration et une vérification rigoureuses afin d'éviter l'usurpation d'identité ou la falsification d'assertions. Cette section décrit les exigences pour gérer ces risques.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **6.8.1** | Vérifiez que, si l'application prend en charge plusieurs fournisseurs d'identité (IdP), l'identité de l'utilisateur ne peut pas être usurpée via un autre fournisseur d'identité pris en charge (par exemple, en utilisant le même identifiant utilisateur). La mesure standard consisterait à ce que l'application enregistre et identifie l'utilisateur à l'aide d'une combinaison de l'ID du fournisseur d'identité (servant d'espace de noms) et de l'ID de l'utilisateur dans le fournisseur d'identité. | 2 |\n| **6.8.2** | Vérifiez que la présence et l'intégrité des signatures numériques sur les assertions d'authentification (par exemple sur les assertions JWT ou SAML) sont toujours validées, en rejetant toutes les assertions non signées ou ayant des signatures non valides. | 2 |\n| **6.8.3** | Vérifiez que les assertions SAML sont traitées de manière unique et utilisées une seule fois au cours de la période de validité pour éviter les attaques par rejeu. | 2 |\n| **6.8.4** | Si une application utilise un fournisseur d'identité (IdP) distinct et attend une force, des méthodes ou une date d'authentification spécifiques pour des fonctions spécifiques, vérifiez que l'application les vérifie à l'aide des informations renvoyées par l'IdP. Par exemple, si OIDC est utilisé, cela peut être réalisé en validant les affirmations de jeton d'identification telles que « acr », « amr » et « auth_time » (le cas échéant). Si l'IdP ne fournit pas ces informations, l'application doit disposer d'une approche de secours documentée qui suppose que le mécanisme d'authentification de force minimale a été utilisé (par exemple, une authentification à facteur unique avec nom d'utilisateur et mot de passe). | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [NIST SP 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST SP 800-63B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST SP 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Web Security Testing Guide: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing)\n* [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Forgot Password Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Choosing and Using Security Questions Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n* [CISA Guidance on \"Number Matching\"](https://www.cisa.gov/sites/default/files/publications/fact-sheet-implement-number-matching-in-mfa-applications-508c.pdf)\n* [Details on the FIDO Alliance](https://fidoalliance.org/)\n", "timestamp": "2025-10-24T11:40:10.335529"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x16-V7-Session-Management.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x16-V7-Session-Management.md", "content": "# V7 Gestion des sessions\n\n## Objectif de contrôle\n\nLes mécanismes de gestion de session permettent aux applications de corréler les interactions entre utilisateurs et appareils au fil du temps, même avec des protocoles de communication sans état (comme HTTP). Les applications modernes peuvent utiliser plusieurs jetons de session aux caractéristiques et objectifs distincts. Un système de gestion de session sécurisé empêche les attaquants d'obtenir, d'utiliser ou d'abuser de la session d'une victime. Les applications gérant des sessions doivent garantir le respect des exigences de gestion de session de haut niveau suivantes :\n\n* Les sessions sont uniques à chaque individu et ne peuvent être ni devinées ni partagées.\n* Les sessions sont invalidées lorsqu'elles ne sont plus nécessaires et expirent pendant les périodes d'inactivité.\n\nDe nombreuses exigences de ce chapitre concernent des contrôles sélectionnés de [NIST SP 800-63 Digital Identity Guidelines](https://pages.nist.gov/800-63-4/), en se concentrant sur les menaces courantes et les faiblesses d'authentification couramment exploitées.\n\nNotez que les exigences relatives aux détails d’implémentation spécifiques de certains mécanismes de gestion de session peuvent être trouvées ailleurs :\n\n* Les cookies HTTP sont un mécanisme courant de sécurisation des jetons de session. Les exigences de sécurité spécifiques aux cookies sont décrites dans le chapitre « Sécurité de l'interface web ».\n* Les jetons autonomes sont fréquemment utilisés pour maintenir les sessions. Les exigences de sécurité spécifiques sont décrites dans le chapitre « Jetons autonomes ».\n\n## V7.1 Documentation sur la gestion des sessions\n\nIl n'existe pas de modèle unique convenant à toutes les applications. Il est donc impossible de définir des limites universelles et adaptées à tous les cas. Une analyse des risques, accompagnée de décisions de sécurité documentées relatives à la gestion des sessions, doit être réalisée avant la mise en œuvre et les tests. Cela garantit que le système de gestion des sessions est adapté aux exigences spécifiques de l'application.\n\nQue le mécanisme de session choisi soit avec ou sans état, l'analyse doit être complète et documentée afin de démontrer que la solution sélectionnée est capable de satisfaire à toutes les exigences de sécurité pertinentes. L'interaction avec les mécanismes d'authentification unique (SSO) utilisés doit également être prise en compte.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.1.1** | Vérifiez que le délai d'inactivité de la session de l'utilisateur et la durée de vie maximale absolue de la session sont documentés, sont appropriés en combinaison avec d'autres contrôles et que la documentation inclut une justification de tout écart par rapport aux exigences de réauthentification NIST SP 800-63B. | 2 |\n| **7.1.2** | Vérifiez que la documentation définit le nombre de sessions simultanées (parallèles) autorisées pour un compte ainsi que les comportements et actions prévus à entreprendre lorsque le nombre maximal de sessions actives est atteint. | 2 |\n| **7.1.3** | Vérifiez que tous les systèmes qui créent et gèrent des sessions utilisateur dans le cadre d'un écosystème de gestion des identités fédérées (tels que les systèmes SSO) sont documentés avec des contrôles pour coordonner la durée de vie des sessions, la résiliation et toute autre condition nécessitant une réauthentification. | 2 |\n\n## V7.2 Sécurité fondamentale de la gestion des sessions\n\nCette section satisfait aux exigences essentielles des sessions sécurisées en vérifiant que les jetons de session sont générés et validés de manière sécurisée.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.2.1** | Vérifiez que l’application effectue toutes les vérifications des jetons de session à l’aide d’un service backend de confiance. | 1 |\n| **7.2.2** | Vérifiez que l'application utilise des jetons autonomes ou de référence générés dynamiquement pour la gestion des sessions, c'est-à-dire sans utiliser de secrets et de clés d'API statiques. | 1 |\n| **7.2.3** | Vérifiez que si des jetons par référence sont utilisés pour représenter les sessions utilisateur, ils sont uniques et générés à l'aide d'un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé (CSPRNG) et possèdent au moins 128 bits d'entropie. | 1 |\n| **7.2.4** | Vérifiez que l’application génère un nouveau jeton de session lors de l’authentification de l’utilisateur, y compris la réauthentification, et met fin au jeton de session actuel. | 1 |\n\n## V7.3 Délai d'expiration de la session\n\nLes mécanismes de temporisation de session servent à minimiser les risques de détournement de session et autres formes d'abus. Les temporisations doivent respecter des décisions de sécurité documentées.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.3.1** | Vérifiez qu’il existe un délai d’inactivité tel que la réauthentification soit appliquée conformément à l’analyse des risques et aux décisions de sécurité documentées. | 2 |\n| **7.3.2** | Vérifiez qu'il existe une durée de vie maximale absolue de la session de sorte que la réauthentification soit appliquée conformément à l'analyse des risques et aux décisions de sécurité documentées. | 2 |\n\n## V7.4 Fin de session\n\nLa fin de session peut être gérée soit par l'application elle-même, soit par le fournisseur d'authentification unique (SSO) si ce dernier gère la session à sa place. Il peut être nécessaire de déterminer si le fournisseur d'authentification unique est concerné par les exigences de cette section, car certaines peuvent être contrôlées par lui.\n\nLa fin de session doit entraîner une réauthentification et être effective dans l'ensemble de l'application, de la connexion fédérée (si présente) et de toutes les parties utilisatrices.\n\nPour les mécanismes de session avec état, la terminaison implique généralement l'invalidation de la session sur le serveur principal. Dans le cas de jetons autonomes, des mesures supplémentaires sont nécessaires pour révoquer ou bloquer ces jetons, car ils pourraient sinon rester valides jusqu'à leur expiration.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.4.1** | Vérifiez que lorsque la fin de session est déclenchée (par exemple, déconnexion ou expiration), l'application interdit toute utilisation ultérieure de la session. Pour les jetons par référence ou les sessions avec état, cela implique l'invalidation des données de session au niveau du backend de l'application. Les applications utilisant des jetons autonomes nécessiteront une solution, comme la gestion d'une liste des jetons terminés, l'interdiction des jetons produits avant une date et une heure spécifique à chaque utilisateur ou la rotation d'une clé de signature spécifique à chaque utilisateur. | 1 |\n| **7.4.2** | Vérifiez que l'application met fin à toutes les sessions actives lorsqu'un compte utilisateur est désactivé ou supprimé (par exemple, lorsqu'un employé quitte l'entreprise). | 1 |\n| **7.4.3** | Vérifiez que l'application offre la possibilité de mettre fin à toutes les autres sessions actives après une modification ou une suppression réussie de tout facteur d'authentification (y compris la modification du mot de passe via une réinitialisation ou une récupération et, le cas échéant, une mise à jour des paramètres MFA). | 2 |\n| **7.4.4** | Vérifiez que toutes les pages nécessitant une authentification disposent d’un accès facile et visible à la fonctionnalité de déconnexion. | 2 |\n| **7.4.5** | Vérifiez que les administrateurs d’applications sont en mesure de mettre fin aux sessions actives pour un utilisateur individuel ou pour tous les utilisateurs. | 2 |\n\n## V7.5 Défenses contre les abus de session\n\nCette section décrit les exigences visant à atténuer le risque posé par les sessions actives détournées ou utilisées abusivement par des vecteurs s'appuyant sur l'existence et les capacités des sessions utilisateur actives. Par exemple, l'exécution de contenu malveillant pour forcer un navigateur authentifié à effectuer une action en utilisant la session de la victime.\n\nVeuillez noter que les instructions spécifiques au niveau dans le chapitre « Authentification » doivent être prises en compte lors de l'examen des exigences de cette section.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.5.1** | Vérifiez que l'application nécessite une réauthentification complète avant d'autoriser les modifications des attributs de compte sensibles qui peuvent affecter l'authentification, tels que l'adresse e-mail, le numéro de téléphone, la configuration MFA ou d'autres informations utilisées dans la récupération de compte. | 2 |\n| **7.5.2** | Vérifiez que les utilisateurs peuvent afficher et (après s'être authentifiés à nouveau avec au moins un facteur) terminer une ou toutes les sessions actuellement actives. | 2 |\n| **7.5.3** | Vérifiez que l’application nécessite une authentification supplémentaire avec au moins un facteur ou une vérification secondaire avant d’effectuer des transactions ou des opérations hautement sensibles. | 3 |\n\n## V7.6 Réauthentification fédérée\n\nCette section s'adresse aux développeurs de code de partie utilisatrice (RP) ou de fournisseur d'identité (IdP). Ces exigences découlent de la norme [NIST SP 800-63C](https://pages.nist.gov/800-63-4/sp800-63c.html) relative à la fédération et aux assertions.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **7.6.1** | Vérifiez que la durée de vie et la fin de la session entre les parties de confiance (RP) et les fournisseurs d'identité (IdP) se comportent comme documenté, en exigeant une réauthentification si nécessaire, par exemple lorsque le temps maximal entre les événements d'authentification IdP est atteint. | 2 |\n| **7.6.2** | Vérifiez que la création d'une session nécessite soit le consentement de l'utilisateur, soit une action explicite, empêchant ainsi la création de nouvelles sessions d'application sans interaction de l'utilisateur. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:10.437299"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x17-V8-Authorization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x17-V8-Authorization.md", "content": "# V8 Autorisation\n\n## Objectif de contrôle\n\nL'autorisation garantit que l'accès est accordé uniquement aux utilisateurs autorisés (utilisateurs, serveurs et autres clients). Pour appliquer le principe du moindre privilège (POLP), les applications vérifiées doivent répondre aux exigences générales suivantes :\n\n* Documenter les règles d'autorisation des documents, y compris les facteurs de prise de décision et les contextes environnementaux.\n* Les consommateurs ne devraient avoir accès qu'aux ressources autorisées par leurs droits définis.\n\n## V8.1 Documentation d'autorisation\n\nUne documentation exhaustive des autorisations est essentielle pour garantir que les décisions de sécurité sont appliquées de manière cohérente, vérifiables et conformes aux politiques de l'organisation. Cela réduit le risque d'accès non autorisé en clarifiant les exigences de sécurité et en les rendant applicables aux développeurs, administrateurs et testeurs.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **8.1.1** | Vérifiez que la documentation d’autorisation définit des règles de restriction de l’accès au niveau de la fonction et aux données en fonction des autorisations du consommateur et des attributs des ressources. | 1 |\n| **8.1.2** | Vérifiez que la documentation d'autorisation définit les règles de restriction d'accès au niveau des champs (lecture et écriture) en fonction des autorisations des consommateurs et des attributs des ressources. Notez que ces règles peuvent dépendre d'autres valeurs d'attributs de l'objet de données concerné, telles que l'état ou le statut. | 2 |\n| **8.1.3** | Vérifiez que la documentation de l'application définit les attributs environnementaux et contextuels (y compris, mais sans s'y limiter, l'heure de la journée, l'emplacement de l'utilisateur, l'adresse IP ou l'appareil) qui sont utilisés dans l'application pour prendre des décisions de sécurité, y compris celles relatives à l'authentification et à l'autorisation. | 3 |\n| **8.1.4** | Vérifier que la documentation d'authentification et d'autorisation définit l'utilisation des facteurs environnementaux et contextuels dans la prise de décision, en plus des autorisations au niveau des fonctions, des données et des champs. Cela doit inclure les attributs évalués, les seuils de risque et les actions entreprises (par exemple, autorisation, contestation, refus, renforcement de l'authentification). | 3 |\n\n## V8.2 Conception d'autorisation générale\n\nLa mise en œuvre de contrôles d’autorisation granulaires aux niveaux de la fonction, des données et des champs garantis que les consommateurs ne pourront accéder qu’à ce qui leur a été explicitement accordé.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **8.2.1** | Vérifiez que l’application garantit que l’accès basé sur la fonction est limité aux consommateurs disposant d’autorisations explicites. | 1 |\n| **8.2.2** | Vérifiez que l'application garantit que l'accès spécifique aux données est limité aux consommateurs disposant d'autorisations explicites sur des éléments de données spécifiques afin d'atténuer les références d'objet directes non sécurisées (IDOR) et les autorisations de niveau d'objet rompues (BOLA). | 1 |\n| **8.2.3** | Vérifiez que l'application garantit que l'accès au niveau du champ est limité aux consommateurs disposant d'autorisations explicites sur des champs spécifiques afin d'atténuer les problèmes d'autorisation au niveau de la propriété d'objet (BOPLA). | 2 |\n| **8.2.4** | Vérifiez que les contrôles de sécurité adaptatifs basés sur les attributs environnementaux et contextuels du consommateur (tels que l'heure, la localisation, l'adresse IP ou l'appareil) sont mis en œuvre pour les décisions d'authentification et d'autorisation, comme défini dans la documentation de l'application. Ces contrôles doivent être appliqués lorsque le consommateur tente de démarrer une nouvelle session et également pendant une session existante. | 3 |\n\n## V8.3 Autorisation par opération\n\nL'application immédiate des modifications d'autorisation dans le niveau approprié de l'architecture d'une application est essentielle pour empêcher les actions non autorisées, en particulier dans les environnements dynamiques.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **8.3.1** | Vérifier que l'application applique les règles d'autorisations au niveau de la couche service de confiance et ne s’appuie pas sur des contrôles qu’un consommateur non approuvé pourrait manipuler, comme JavaScript côté client. | 1 |\n| **8.3.2** | Vérifiez que les modifications apportées aux valeurs sur lesquelles reposent les décisions d'autorisation sont appliquées immédiatement. Lorsque les modifications ne peuvent pas être appliquées immédiatement (par exemple, en s'appuyant sur des données de jetons autonomes), des contrôles d'atténuation doivent être mis en place pour alerter un consommateur lorsqu'il effectue une action alors qu'il n'est plus autorisé à le faire et annuler la modification. Notez que cette solution alternative ne limiterait pas les fuites d'informations. | 3 |\n| **8.3.3** | Vérifiez que l'accès à un objet repose sur les autorisations du sujet d'origine (par exemple, le consommateur), et non sur celles d'un intermédiaire ou d'un service agissant en son nom. Par exemple, si un consommateur appelle un service web à l'aide d'un jeton d'authentification autonome, et que ce service demande ensuite des données à un autre service, ce dernier utilisera le jeton du consommateur, plutôt qu'un jeton inter-machine du premier service, pour prendre les décisions d'autorisation. | 3 |\n\n## V8.4 Autres considérations relatives à l'autorisation\n\nDes considérations supplémentaires concernant l’autorisation, en particulier pour les interfaces administratives et les environnements multi-tenants, aident à empêcher tout accès non autorisé.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **8.4.1** | Vérifiez que les applications multi-tenants utilisent des contrôles inter-tenants pour garantir que les opérations des consommateurs n'affecteront jamais les tenants avec lesquels ils ne sont pas autorisés à interagir. | 2 |\n| **8.4.2** | Vérifiez que l'accès aux interfaces administratives intègre plusieurs couches de sécurité, notamment la vérification continue de l'identité du consommateur, l'évaluation de la posture de sécurité des appareils et l'analyse contextuelle des risques, garantissant que l'emplacement du réseau ou les endpoints approuvés ne sont pas les seuls facteurs d'autorisation, même s'ils peuvent réduire la probabilité d'accès non autorisé. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide: Authorization](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/05-Authorization_Testing)\n* [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:10.536485"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x18-V9-Self-contained-Tokens.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x18-V9-Self-contained-Tokens.md", "content": "# V9 Jetons autonomes\n\n## Objectif de contrôle\n\nLe concept de jeton autonome est mentionné dans la RFC 6749 OAuth 2.0 originale de 2012. Il désigne un jeton contenant des données ou des déclarations sur lesquelles un service récepteur s'appuie pour prendre des décisions de sécurité. Il convient de le distinguer d'un simple jeton contenant uniquement un identifiant, qu'un service récepteur utilise pour rechercher des données localement. Les exemples les plus courants de jetons autonomes sont les jetons Web JSON (JWT) et les assertions SAML.\n\nL'utilisation de jetons autonomes est devenue très répandue, même en dehors d'OAuth et d'OIDC. Parallèlement, la sécurité de ce mécanisme repose sur la capacité à valider l'intégrité du jeton et à garantir sa validité dans un contexte particulier. Ce processus présente de nombreux pièges, et ce chapitre détaille les mécanismes que les applications devraient mettre en place pour les éviter.\n\n## V9.1 Source et intégrité du jeton\n\nCette section comprend des exigences visant à garantir que le jeton a été produit par une partie de confiance et n’a pas été falsifié.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **9.1.1** | Vérifiez que les jetons autonomes sont validés à l'aide de leur signature numérique ou MAC pour les protéger contre toute falsification avant d'accepter le contenu du jeton. | 1 |\n| **9.1.2** | Vérifiez que seuls les algorithmes d'une liste d’autorisations peuvent être utilisés pour créer et vérifier des jetons autonomes, dans un contexte donné. La liste d'autorisation doit inclure les algorithmes autorisés, idéalement symétriques ou asymétriques, et ne doit pas inclure l'algorithme « Aucun ». Si les algorithmes symétriques et asymétriques doivent être pris en charge, des contrôles supplémentaires seront nécessaires pour éviter toute confusion de clés. | 1 |\n| **9.1.3** | Vérifiez que les clés utilisées pour valider les jetons autonomes proviennent de sources préconfigurées et fiables pour l'émetteur du jeton, empêchant ainsi les attaquants de spécifier des sources et des clés non fiables. Pour les JWT et autres structures JWS, les en-têtes tels que « jku », « x5u » et « jwk » doivent être validés par rapport à une liste d'autorisation de sources fiables. | 1 |\n\n## V9.2 Contenu du jeton\n\nAvant de prendre des décisions de sécurité basées sur le contenu d'un jeton autonome, il est nécessaire de vérifier que le jeton a été présenté pendant sa période de validité et qu'il est destiné à être utilisé par le service destinataire et pour l'usage pour lequel il a été présenté. Cela permet d'éviter toute utilisation croisée non sécurisée entre différents services ou avec différents types de jetons provenant du même émetteur.\n\nLes exigences spécifiques pour OAuth et OIDC sont couvertes dans le chapitre dédié.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **9.2.1** | Vérifiez que, si une période de validité est indiquée dans les données du jeton, celui-ci et son contenu ne sont acceptés que si la date de vérification est comprise dans cette période. Par exemple, pour les JWT, les déclarations « nbf » et « exp » doivent être vérifiées. | 1 |\n| **9.2.2** | Vérifiez que le service recevant un jeton valide le type de jeton et son utilisation avant d'en accepter le contenu. Par exemple, seuls les jetons d'accès peuvent être acceptés pour les décisions d'autorisation, et seuls les jetons d'identification peuvent être utilisés pour prouver l'authentification des utilisateurs. | 2 |\n| **9.2.3** | Vérifiez que le service accepte uniquement les jetons destinés à être utilisés avec ce service (audience). Pour les JWT, cela peut être réalisé en validant la déclaration « aud » par rapport à une liste d'autorisation définie dans le service. | 2 |\n| **9.2.4** | Si un émetteur de jetons utilise la même clé privée pour émettre des jetons destinés à différentes audiences, vérifiez que les jetons émis contiennent une restriction d'audience identifiant de manière unique les audiences visées. Cela empêchera la réutilisation d'un jeton avec une audience non prévue. Si l'identifiant d'audience est provisionné dynamiquement, l'émetteur de jetons doit valider ces audiences afin de garantir qu'elles n'entraînent pas d'usurpation d'identité. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP JSON Web Token Cheat Sheet for Java Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html) (mais il contient des orientations générales utiles)\n", "timestamp": "2025-10-24T11:40:10.681463"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x19-V10-OAuth-and-OIDC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x19-V10-OAuth-and-OIDC.md", "content": "# V10 Oauth et OIDC\n\n## Objectif de contrôle\n\nOAuth2 (appelé OAuth dans ce chapitre) est un framework standard pour l'autorisation déléguée. Par exemple, grâce à OAuth, une application cliente peut accéder aux API (ressources serveur) au nom d'un utilisateur, à condition que ce dernier l'ait autorisée.\n\nOAuth n'est pas conçu pour l'authentification dOauth et OIDCes utilisateurs. Le Framework OpenID Connect (OIDC) étend OAuth en ajoutant une couche d'identité utilisateur. OIDC prend en charge des fonctionnalités telles que la standardisation des informations utilisateur, l'authentification unique (SSO) et la gestion des sessions. OIDC étant une extension d'OAuth, les exigences OAuth décrites dans ce chapitre s'appliquent également à OIDC.\n\nLes rôles suivants sont définis dans OAuth :\n\n* Le client OAuth est l'application qui tente d'accéder aux ressources du serveur (par exemple, en appelant une API à l'aide du jeton d'accès émis). Il s'agit souvent d'une application côté serveur.\n    * Un client confidentiel est un client capable de maintenir la confidentialité des informations d’identification qu’il utilise pour s’authentifier auprès du serveur d’autorisation.\n    * Un client public n'est pas en mesure de préserver la confidentialité des informations d'identification nécessaires à l'authentification auprès du serveur d'autorisation. Par conséquent, au lieu de s'authentifier (par exemple, à l'aide des paramètres « client_id » et « client_secret »), il s'identifie uniquement (à l'aide du paramètre « client_id »).\n* Le serveur de ressources OAuth (RS) est l’API du serveur qui expose les ressources aux clients OAuth.\n* Le serveur d'autorisation OAuth (AS) est une application serveur qui émet des jetons d'accès aux clients OAuth. Ces jetons permettent aux clients OAuth d'accéder aux ressources RS, soit pour le compte d'un utilisateur final, soit pour leur propre compte. L'AS est souvent une application distincte, mais (le cas échéant) il peut être intégré à un RS approprié.\n* Le propriétaire de la ressource (RO) est l'utilisateur final qui autorise les clients OAuth à obtenir en son nom un accès limité aux ressources hébergées sur le serveur de ressources. Le propriétaire de la ressource consent à cette autorisation déléguée en interagissant avec le serveur d'autorisation.\n\nLes rôles suivants sont définis dans OIDC :\n\n* La partie de confiance (RP) est l'application cliente qui demande l'authentification de l'utilisateur final via le fournisseur OpenID. Elle joue le rôle de client OAuth.\n* Le fournisseur OpenID (OP) est un AS OAuth capable d'authentifier l'utilisateur final et de fournir des déclarations OIDC à un RP. L'OP peut être le fournisseur d'identité (IdP), mais dans les scénarios fédérés, l'OP et le fournisseur d'identité (où l'utilisateur final s'authentifie) peuvent être des applications serveur différentes.\n\nOAuth et OIDC ont été initialement conçus pour les applications tierces. Aujourd'hui, ils sont également souvent utilisés par les applications propriétaires. Cependant, lorsqu'ils sont utilisés dans des scénarios propriétaires, comme l'authentification et la gestion de session, le protocole ajoute une certaine complexité, ce qui peut engendrer de nouveaux défis de sécurité.\n\nOAuth et OIDC peuvent être utilisés pour de nombreux types d'applications, mais l'accent d'ASVS et les exigences de ce chapitre portent sur les applications Web et les API.\n\nÉtant donné que OAuth et OIDC peuvent être considérés comme une logique au-dessus des technologies Web, les exigences générales des autres chapitres s'appliquent toujours et ce chapitre ne peut pas être sorti de son contexte.\n\nCe chapitre présente les meilleures pratiques actuelles pour OAuth2 et OIDC, conformément aux spécifications disponibles sur <https://oauth.net/2/> et <https://openid.net/developers/specs/>. Même si les RFC sont considérées comme matures, elles sont fréquemment mises à jour. Il est donc important de se conformer aux dernières versions lors de l'application des exigences de ce chapitre. Consultez la section Références pour plus de détails.\n\nCompte tenu de la complexité du domaine, il est essentiel qu’une solution OAuth ou OIDC sécurisée utilise des serveurs d’autorisation standard bien connus du secteur et applique la configuration de sécurité recommandée.\n\nLa terminologie utilisée dans ce chapitre est conforme aux RFC OAuth et aux spécifications OIDC ; mais notez que la terminologie OIDC n'est utilisée que pour les exigences spécifiques à OIDC, sinon, la terminologie OAuth est utilisée.\n\nDans le contexte d'OAuth et d'OIDC, le terme « jeton » dans ce chapitre fait référence à :\n\n* Les jetons d'accès, qui ne peuvent être consommés que par le serveur de sécurité (RS) et qui peuvent être des jetons de référence validés par introspection ou des jetons autonomes validés à l'aide d'un matériau clé.\n* Jetons de rafraîchissement, qui ne seront consommés que par le serveur d'autorisation qui a émis le jeton.\n* Jetons d'identification OIDC, qui ne doivent être consommés que par le client qui a déclenché le flux d'autorisation.\n\nLes niveaux de risque pour certaines exigences de ce chapitre varient selon que le client est confidentiel ou public. L'utilisation d'une authentification client forte limitant de nombreux vecteurs d'attaque, certaines exigences peuvent être assouplies lors de l'utilisation d'un client confidentiel pour les applications L1.\n\n## V10.1 Sécurité générique OAuth et OIDC\n\nCette section couvre les exigences architecturales génériques qui s’appliquent à toutes les applications utilisant OAuth ou OIDC.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.1.1** | Vérifiez que les jetons sont envoyés uniquement aux composants qui en ont absolument besoin. Par exemple, lors de l'utilisation d'un modèle backend-for-frontend pour les applications JavaScript basées sur un navigateur, les jetons d'accès et d'actualisation ne doivent être accessibles qu'au backend. | 2 |\n| **10.1.2** | Vérifiez que le client n'accepte les valeurs du serveur d'autorisation (telles que le code d'autorisation ou le jeton d'identification) que si elles résultent d'un flux d'autorisation initié par la même session d'agent utilisateur et la même transaction. Cela nécessite que les secrets générés par le client, tels que la clé de preuve pour l'échange de codes (PKCE) « code_verifier », « state » ou le nonce OIDC, ne puissent être devinés, soient spécifiques à la transaction et soient liés de manière sécurisée au client et à la session d'agent utilisateur au cours de laquelle la transaction a été initiée. | 2 |\n\n## V10.2 Client OAuth\n\nCes exigences détaillent les responsabilités des applications clientes OAuth. Le client peut être, par exemple, un serveur web backend (souvent utilisé comme backend pour frontend, BFF), une intégration de service backend ou une application monopage frontend (SPA, également appelée application basée sur un navigateur).\n\nEn général, les clients backend sont considérés comme confidentiels et les clients frontend comme publics. Cependant, les applications natives exécutées sur l'appareil de l'utilisateur final peuvent être considérées comme confidentielles lorsqu'elles s'enregistrent dynamiquement des clients OAuth.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.2.1** | Vérifiez que, si le flux de code est utilisé, le client OAuth dispose d'une protection contre les attaques de falsification de requêtes basées sur le navigateur, communément appelées falsification de requêtes intersites (CSRF), qui déclenchent des demandes de jetons, soit en utilisant la fonctionnalité de clé de preuve pour l'échange de code (PKCE), soit en vérifiant le paramètre « state » envoyé dans la demande d'autorisation. | 2 |\n| **10.2.2** | Vérifiez que, si le client OAuth peut interagir avec plusieurs serveurs d'autorisation, il dispose d'une protection contre les attaques par confusion. Par exemple, il peut exiger que le serveur d'autorisation renvoie la valeur du paramètre « iss » et la valide dans la réponse d'autorisation et la réponse du jeton. | 2 |\n| **10.2.3** | Vérifiez que le client OAuth demande uniquement les portées requises (ou d’autres paramètres d’autorisation) dans les requêtes adressées au serveur d’autorisation. | 3 |\n\n## V10.3 Serveur de ressources OAuth\n\nDans le contexte d'ASVS et de ce chapitre, le serveur de ressources est une API. Pour fournir un accès sécurisé, le serveur de ressources doit :\n\n* Valider le jeton d'accès, conformément au format du jeton et aux spécifications du protocole, par exemple, validation JWT ou introspection du jeton OAuth.\n* S'il est valide, appliquer les décisions d'autorisation en fonction des informations du jeton d'accès et des autorisations accordées. Par exemple, le serveur de ressources doit vérifier que le client (agissant au nom du RO) est autorisé à accéder à la ressource demandée.\n\nPar conséquent, les exigences répertoriées ici sont spécifiques à OAuth ou OIDC et doivent être exécutées après la validation du jeton et avant d'effectuer l'autorisation basée sur les informations du jeton.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.3.1** | Vérifiez que le serveur de ressources accepte uniquement les jetons d'accès destinés à être utilisés avec ce service (audience). L'audience peut être incluse dans un jeton d'accès structuré (comme la déclaration « aud » dans JWT) ou vérifiée à l'aide du endpoint d'introspection de jeton. | 2 |\n| **10.3.2** | Vérifiez que le serveur de ressources applique les décisions d'autorisation en fonction des déclarations du jeton d'accès définissant l'autorisation déléguée. Si des déclarations telles que « sub », « scope » et « authorization_details » sont présentes, elles doivent être prises en compte dans la décision. | 2 |\n| **10.3.3** | Vérifiez que si une décision de contrôle d'accès nécessite l'identification d'un utilisateur unique à partir d'un jeton d'accès (JWT ou réponse d'introspection de jeton associé), le serveur de ressources identifie l'utilisateur à partir de déclarations non ré attribuables à d'autres utilisateurs. En général, cela implique l'utilisation d'une combinaison de déclarations « iss » et « sub ». | 2 |\n| **10.3.4** | Si le serveur de ressources requiert une force d'authentification, des méthodes ou une date d'expiration spécifiques, vérifiez que le jeton d'accès présenté respecte ces contraintes. Par exemple, s'il est présent, utilisez les déclarations OIDC « acr », « amr » et « auth_time » respectivement. | 2 |\n| **10.3.5** | Vérifiez que le serveur de ressources empêche l'utilisation de jetons d'accès volés ou la relecture de jetons d'accès (de parties non autorisées) en exigeant des jetons d'accès limités par l'expéditeur, soit Mutual TLS pour OAuth 2, soit OAuth 2 Demonstration of Proof of Possession (DPoP). | 3 |\n\n## V10.4 Serveur d'autorisation OAuth\n\nCes exigences détaillent les responsabilités des serveurs d’autorisation OAuth, y compris les fournisseurs OpenID.\n\nPour l'authentification client, la méthode « self_signed_tls_client_auth » est autorisée avec les prérequis requis par la [section 2.2](https://datatracker.ietf.org/doc/html/rfc8705#name-self-signed-certificate-mut) de la [RFC 8705](https://datatracker.ietf.org/doc/html/rfc8705).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.4.1** | Vérifiez que le serveur d'autorisation valide les URI de redirection en fonction d'une liste d'autorisation spécifique au client d'URI préenregistrés à l'aide d'une comparaison de chaînes exacte. | 1 |\n| **10.4.2** | Vérifiez que, si le serveur d'autorisation renvoie le code d'autorisation dans la réponse, celui-ci ne peut être utilisé qu'une seule fois pour une demande de jeton. Pour la deuxième demande valide avec un code d'autorisation déjà utilisé pour émettre un jeton d'accès, le serveur d'autorisation doit rejeter la demande de jeton et révoquer tous les jetons émis liés au code d'autorisation. | 1 |\n| **10.4.3** | Vérifiez que le code d'autorisation est de courte durée. La durée de vie maximale peut atteindre 10 minutes pour les applications L1 et L2 et 1 minute pour les applications L3. | 1 |\n| **10.4.4** | Vérifiez que, pour un client donné, le serveur d'autorisation autorise uniquement l'utilisation des autorisations nécessaires à ce client. Notez que les autorisations « token » (flux implicite) et « password » (flux d'informations d'identification du propriétaire de la ressource) ne doivent plus être utilisées. | 1 |\n| **10.4.5** | Vérifiez que le serveur d'autorisation atténue les attaques par rejeu de jetons d'actualisation pour les clients publics, de préférence en utilisant des jetons d'actualisation limités par l'expéditeur, par exemple des jetons DPoP (Demonstrating Proof of Possession) ou des jetons d'accès liés à un certificat utilisant le protocole TLS mutuel (mTLS). Pour les applications L1 et L2, la rotation des jetons d'actualisation peut être utilisée. Si cette rotation est utilisée, le serveur d'autorisation doit invalider le jeton d'actualisation après utilisation et révoquer tous les jetons d'actualisation de cette autorisation si un jeton d'actualisation déjà utilisé et invalidé est fourni. | 1 |\n| **10.4.6** | Vérifiez que, si l'octroi de code est utilisé, le serveur d'autorisation atténue les attaques par interception de code en exigeant une clé de preuve pour l'échange de code (PKCE). Pour les demandes d'autorisation, le serveur d'autorisation doit exiger une valeur « code_challenge » valide et ne doit pas accepter une valeur « plain » pour « code_challenge_method ». Pour une demande de jeton, il doit exiger la validation du paramètre « code_verifier ». | 2 |\n| **10.4.7** | Vérifiez que si le serveur d'autorisation prend en charge l'enregistrement dynamique des clients non authentifiés, il réduit le risque d'applications clientes malveillantes. Il doit valider les métadonnées clientes, telles que les URI enregistrés, garantir le consentement de l'utilisateur et l'avertir avant de traiter une demande d'autorisation avec une application cliente non approuvée. | 2 |\n| **10.4.8** | Vérifiez que les jetons d’actualisation ont une expiration absolue, y compris si l’expiration du jeton d’actualisation glissant est appliquée. | 2 |\n| **10.4.9** | Vérifiez que les jetons d'actualisation et les jetons d'accès de référence peuvent être révoqués par un utilisateur autorisé à l'aide de l'interface utilisateur du serveur d'autorisation, afin d'atténuer le risque de clients malveillants ou de jetons volés. | 2 |\n| **10.4.10** | Vérifiez que le client confidentiel est authentifié pour les demandes de back-channel client-serveur autorisé telles que les demandes de jeton, les demandes d'autorisation poussée (PAR) et les demandes de révocation de jeton. | 2 |\n| **10.4.11** | Vérifiez que le client confidentiel est authentifié pour les demandes de back-channel client-serveur autorisé telles que les demandes de jeton, les demandes d'autorisation poussée (PAR) et les demandes de révocation de jeton. | 2 |\n| **10.4.12** | Vérifiez que, pour un client donné, le serveur d'autorisation autorise uniquement la valeur « response_mode » dont ce client a besoin. Par exemple, en vérifiant cette valeur par rapport aux valeurs attendues ou en utilisant une requête d'autorisation poussée (PAR) ou une requête d'autorisation sécurisée par JWT (JAR). | 3 |\n| **10.4.13** | Vérifiez que le type d'Autorisation « code » est toujours utilisé avec les demandes d'autorisation poussées (PAR). | 3 |\n| **10.4.14** | Vérifiez que le serveur d'autorisation émet uniquement des jetons d'accès limités à l'expéditeur (preuve de possession), soit avec des jetons d'accès liés au certificat utilisant TLS mutuel (mTLS), soit avec des jetons d'accès liés au DPoP (démonstration de preuve de possession). | 3 |\n| **10.4.15** | Vérifiez que, pour un client côté serveur (non exécuté sur l'appareil de l'utilisateur final), le serveur d'autorisation garantit que la valeur du paramètre « authorization_details » provient du backend client et que l'utilisateur ne l'a pas altérée. Par exemple, en exigeant l'utilisation d'une demande d'autorisation poussée (PAR) ou d'une demande d'autorisation sécurisée par JWT (JAR). | 3 |\n| **10.4.16** | Vérifiez que le client est confidentiel et que le serveur d'autorisation requiert l'utilisation de méthodes d'authentification client fortes (basées sur la cryptographie à clé publique et résistantes aux attaques par relecture), telles que TLS mutuel ('tls_client_auth', 'self_signed_tls_client_auth') ou JWT à clé privée ('private_key_jwt'). | 3 |\n\n## V10.5 Client OIDC\n\nÉtant donné que la partie utilisatrice d'OIDC agit en tant que client OAuth, les exigences de la section « Client OAuth » s'appliquent également.\n\nNotez que la section « Authentification avec un fournisseur d’identité » du chapitre « Authentification » contient également des exigences générales pertinentes.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.5.1** | Vérifiez que le client (en tant que partie utilisatrice) atténue les attaques par rejeu de jeton d'identification. Par exemple, en vous assurant que la valeur « nonce » du jeton d'identification correspond à la valeur « nonce » envoyée dans la demande d'authentification au fournisseur OpenID (appelée demande d'autorisation envoyée au serveur d'autorisation dans OAuth2). | 2 |\n| **10.5.2** | Vérifiez que le client identifie de manière unique l'utilisateur à partir des déclarations de jeton d'identification, généralement la déclaration « sub », qui ne peut pas être réaffectée à d'autres utilisateurs (pour la portée d'un fournisseur d'identité). | 2 |\n| **10.5.3** | Vérifiez que le client rejette les tentatives d'un serveur d'autorisation malveillant d'usurper l'identité d'un autre serveur d'autorisation via ses métadonnées. Le client doit rejeter les métadonnées du serveur d'autorisation si l'URL de l'émetteur figurant dans ces métadonnées ne correspond pas exactement à l'URL d'émetteur préconfigurée attendue par le client. | 2 |\n| **10.5.4** | Vérifiez que le client valide que le jeton d'identification est destiné à être utilisé pour ce client (audience) en vérifiant que la déclaration « aud » du jeton est égale à la valeur « client_id » pour le client. | 2 |\n| **10.5.5** | Vérifiez que, lors de l'utilisation de la déconnexion du back-channel OIDC, la partie utilisatrice atténue les risques de déni de service liés à la déconnexion forcée et à la confusion entre JWT dans le flux de déconnexion. Le client doit vérifier que le jeton de déconnexion est correctement typé avec la valeur « logout+jwt », qu'il contient la déclaration « event » avec le nom de membre correct et qu'il ne contient pas de déclaration « nonce ». Il est également recommandé d'utiliser une expiration courte (par exemple, 2 minutes). | 2 |\n\n## V10.6 Fournisseur OpenID\n\nÉtant donné que les fournisseurs OpenID agissent comme des serveurs d'autorisation OAuth, les exigences de la section « Serveur d'autorisation OAuth » s'appliquent également.\n\nNotez que si vous utilisez le flux de jeton d'identification (et non le flux de code), aucun jeton d'accès n'est émis et de nombreuses exigences pour OAuth AS ne sont pas applicables.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.6.1** | Vérifiez que le fournisseur OpenID n'autorise que les valeurs « code », « ciba », « id_token » ou « id_token code » pour le mode de réponse. Notez que « code » est préférable à « id_token code » (flux hybride OIDC) et que « token » (tout flux implicite) ne doit pas être utilisé. | 2 |\n| **10.6.2** | Vérifiez que le fournisseur OpenID atténue les risques de déni de service liés à la déconnexion forcée. Pour ce faire, obtenez une confirmation explicite de l'utilisateur final ou, le cas échéant, validez les paramètres de la requête de déconnexion (initiée par la partie utilisatrice), comme « id_token_hint ». | 2 |\n\n## V10.7 Gestion du consentement\n\nCes exigences couvrent la vérification du consentement de l'utilisateur par le serveur d'autorisation. Sans vérification appropriée du consentement de l'utilisateur, un acteur malveillant peut obtenir des autorisations au nom de l'utilisateur par usurpation d'identité ou ingénierie sociale.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **10.7.1** | Vérifiez que le serveur d'autorisation garantit le consentement de l'utilisateur à chaque demande d'autorisation. Si l'identité du client ne peut être garantie, le serveur d'autorisation doit toujours demander explicitement le consentement de l'utilisateur. | 2 |\n| **10.7.2** | Vérifiez que lorsque le serveur d'autorisation demande le consentement de l'utilisateur, il fournit des informations claires et suffisantes sur ce qui est consenti. Le cas échéant, ces informations doivent inclure la nature des autorisations demandées (généralement en fonction de la portée, du serveur de ressources et des détails d'autorisation RAR), l'identité de l'application autorisée et la durée de vie de ces autorisations. | 2 |\n| **10.7.3** | Vérifiez que l’utilisateur peut consulter, modifier et révoquer les consentements qu’il a accordés via le serveur d’autorisation. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [oauth.net](https://oauth.net/)\n* [OWASP OAuth 2.0 Protocol Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)\n\nPour les exigences liées à OAuth dans ASVS, les RFC publiées et à l'état de projet suivantes sont utilisées :\n\n* [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)\n* [RFC6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)\n* [RFC6819 OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)\n* [RFC7636 Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636)\n* [RFC7591 OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591)\n* [RFC8628 OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)\n* [RFC8707 Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)\n* [RFC9068 JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068)\n* [RFC9126 OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9126)\n* [RFC9207 OAuth 2.0 Authorization Server Issuer Identification](https://datatracker.ietf.org/doc/html/rfc9207)\n* [RFC9396 OAuth 2.0 Rich Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9396)\n* [RFC9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)\n* [RFC9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700)\n* [draft OAuth 2.0 for Browser-Based Applications](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)<!-- recheck on release -->\n* [draft The OAuth 2.1 Authorization Framework](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)<!-- recheck on release -->\n\nPour plus d'informations sur OpenID Connect, veuillez consulter :\n\n* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)\n* [FAPI 2.0 Security Profile](https://openid.net/specs/fapi-security-profile-2_0-final.html)\n", "timestamp": "2025-10-24T11:40:10.778029"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x20-V11-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x20-V11-Cryptography.md", "content": "# V11 Cryptographie\n\n## Objectif de contrôle\n\nL'objectif de ce chapitre est de définir les meilleures pratiques pour l'utilisation générale de la cryptographie, ainsi que d'inculquer une compréhension fondamentale des principes cryptographiques et d'encourager une évolution vers des approches plus résilientes et modernes. Il encourage les actions suivantes :\n\n* Mise en œuvre de systèmes cryptographiques robustes, sécurisés, adaptables à l'évolution des menaces et pérennes.\n* Utilisation de mécanismes cryptographiques sécurisés et conformes aux meilleures pratiques du secteur.\n* Maintien d'un système de gestion des clés cryptographiques sécurisé, avec des contrôles d'accès et des audits appropriés.\n* Évaluation régulière du paysage cryptographique pour identifier les nouveaux risques et adapter les algorithmes en conséquence.\n* Identification et gestion des cas d'utilisation cryptographiques tout au long du cycle de vie de l'application afin de garantir la prise en compte et la sécurité de tous les actifs cryptographiques.\n\nOutre les principes généraux et les bonnes pratiques, ce document fournit également des informations techniques plus détaillées sur les exigences de l'annexe V – Normes de cryptographie. Cela inclut les algorithmes et les modes considérés comme « approuvés » aux fins des exigences de ce chapitre.\n\nLes exigences qui utilisent la cryptographie pour résoudre un problème distinct, comme la gestion des secrets ou la sécurité des communications, figureront dans différentes parties de la norme.\n\n## V11.1 Inventaire et documentation cryptographiques\n\nLes applications doivent être conçues avec une architecture cryptographique robuste afin de protéger les données selon leur classification. Chiffrer tout est un gaspillage ; ne rien chiffrer est une négligence juridique. Un équilibre doit être trouvé, généralement lors de la conception architecturale ou de haut niveau, des sprints de conception ou des pics d'architecture. Concevoir la cryptographie au fur et à mesure ou la moderniser coûtera inévitablement beaucoup plus cher à mettre en œuvre de manière sécurisée que de l'intégrer dès le départ.\n\nIl est important de veiller à ce que tous les actifs cryptographiques soient régulièrement découverts, inventoriés et évalués. Veuillez consulter l'annexe pour plus d'informations sur la procédure à suivre.\n\nIl est également crucial de pérenniser les systèmes cryptographiques face à l'essor futur de l'informatique quantique. La cryptographie post-quantique (PQC) désigne les algorithmes cryptographiques conçus pour résister aux attaques des ordinateurs quantiques, qui sont susceptibles de casser des algorithmes largement utilisés tels que RSA et la cryptographie à courbe elliptique (ECC).\n\nVeuillez consulter l'annexe pour obtenir des conseils actualisés sur les primitives et les normes PQC approuvées.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.1.1** | Vérifiez qu’il existe une politique documentée pour la gestion des clés cryptographiques et un cycle de vie des clés cryptographiques qui suit une norme de gestion des clés telle que NIST SP 800-57. Cela devrait inclure la garantie que les clés ne sont pas sur-partagées (par exemple, avec plus de deux entités pour les secrets partagés et plus d’une entité pour les clés privées). | 2 |\n| **11.1.2** | Vérifiez qu'un inventaire cryptographique est réalisé, maintenu et régulièrement mis à jour, et qu'il inclut toutes les clés, algorithmes et certificats cryptographiques utilisés par l'application. Il doit également documenter les emplacements du système où les clés peuvent ou non être utilisées, ainsi que les types de données qui peuvent ou non être protégées par ces clés. | 2 |\n| **11.1.3** | Vérifiez que les mécanismes de découverte cryptographique sont utilisés pour identifier toutes les instances de cryptographie dans le système, y compris les opérations de chiffrement, de hachage et de signature. | 3 |\n| **11.1.4** | Vérifier la tenue d'un inventaire cryptographique. Celui-ci doit inclure un plan documenté décrivant la migration vers de nouvelles normes cryptographiques, telles que la cryptographie post-quantique, afin de réagir aux menaces futures. | 3 |\n\n## V11.2 Mise en œuvre sécurisée de la cryptographie\n\nCette section définit les exigences relatives à la sélection, à la mise en œuvre et à la gestion continue des algorithmes cryptographiques de base d'une application. L'objectif est de garantir que seules des primitives cryptographiques robustes et reconnues par l'industrie soient déployées, conformément aux normes en vigueur (par exemple, NIST, ISO/IEC) et aux meilleures pratiques. Les organisations doivent s'assurer que chaque composant cryptographique est sélectionné sur la base de preuves validées par des pairs et de tests de sécurité pratiques.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.2.1** | Vérifiez que les implémentations validées par l’industrie (y compris les bibliothèques et les implémentations accélérées par le matériel) sont utilisées pour les opérations cryptographiques. | 2 |\n| **11.2.2** | Vérifiez que l'application est conçue avec une agilité cryptographique, de sorte que les nombres aléatoires, le chiffrement authentifié, le MAC ou les algorithmes de hachage, les longueurs de clés, les tours, les chiffrements et les modes puissent être reconfigurés, mis à niveau ou échangés à tout moment, afin de se protéger contre les failles cryptographiques. De même, il doit être possible de remplacer les clés et les mots de passe, ainsi que de rechiffrer les données. Cela permettra des mises à niveau transparentes vers la cryptographie post-quantique (PQC), une fois que des implémentations hautement sécurisées de schémas ou de normes PQC approuvés seront largement disponibles. | 2 |\n| **11.2.3** | Vérifiez que toutes les primitives cryptographiques utilisent un minimum de 128 bits de sécurité en fonction de l'algorithme, de la taille de la clé et de la configuration. Par exemple, une clé ECC de 256 bits offre environ 128 bits de sécurité, tandis que RSA nécessite une clé de 3072 bits pour atteindre 128 bits de sécurité. | 2 |\n| **11.2.4** | Vérifiez que toutes les opérations cryptographiques sont à temps constant, sans opérations de « court-circuit » dans les comparaisons, les calculs ou les retours, pour éviter toute fuite d'informations. | 3 |\n| **11.2.5** | Vérifiez que tous les modules cryptographiques échouent en toute sécurité et que les erreurs sont gérées de manière à ne pas permettre de vulnérabilités, telles que les attaques Padding Oracle. | 3 |\n\n## V11.3 Algorithmes de chiffrement\n\nLes algorithmes de chiffrement authentifiés basés sur AES et CHACHA20 constituent l’épine dorsale de la pratique cryptographique moderne.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.3.1** | Vérifiez que les modes de bloc non sécurisés (par exemple, ECB) et les schémas de remplissage faibles (par exemple, PKCS#1 v1.5) ne sont pas utilisés. | 1 |\n| **11.3.2** | Vérifiez que seuls les chiffrements et modes approuvés tels que AES avec GCM sont utilisés. | 1 |\n| **11.3.3** | Vérifiez que les données chiffrées sont protégées contre toute modification non autorisée, de préférence en utilisant une méthode de chiffrement authentifiée approuvée ou en combinant une méthode de chiffrement approuvée avec un algorithme MAC approuvé. | 2 |\n| **11.3.4** | Vérifiez que les nonces, les vecteurs d'initialisation et autres nombres à usage unique ne sont pas utilisés pour plus d'une paire clé de chiffrement/élément de données. La méthode de génération doit être adaptée à l'algorithme utilisé. | 3 |\n| **11.3.5** | Vérifiez que toute combinaison d'un algorithme de chiffrement et d'un algorithme MAC fonctionne en mode chiffrement puis MAC. | 3 |\n\n## V11.4 Hachage et fonctions basées sur le hachage\n\nLes hachages cryptographiques sont utilisés dans une grande variété de protocoles cryptographiques, tels que les signatures numériques, HMAC, les fonctions de dérivation de clés (KDF), la génération de bits aléatoires et le stockage de mots de passe. La sécurité d'un système cryptographique dépend des fonctions de hachage sous-jacentes utilisées. Cette section décrit les exigences relatives à l'utilisation de fonctions de hachage sécurisées dans les opérations cryptographiques.\n\nPour le stockage des mots de passe, ainsi que pour l'annexe sur la cryptographie, la [OWASP Password Storage Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms) fournira également un contexte et des conseils utiles.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.4.1** | Vérifiez que seules les fonctions de hachage approuvées sont utilisées pour les cas d'utilisation cryptographiques généraux, notamment les signatures numériques, HMAC, KDF et la génération de bits aléatoires. Les fonctions de hachage non autorisées, telles que MD5, ne doivent pas être utilisées à des fins cryptographiques. | 1 |\n| **11.4.2** | Vérifiez que les mots de passe sont stockés à l'aide d'une fonction de dérivation de clés approuvée et gourmande en ressources de calcul (également appelée « fonction de hachage de mots de passe »), dont les paramètres sont configurés conformément aux directives en vigueur. Ces paramètres doivent équilibrer sécurité et performances afin de rendre les attaques par force brute suffisamment difficiles pour le niveau de sécurité requis. | 2 |\n| **11.4.3** | Vérifiez que les fonctions de hachage utilisées dans les signatures numériques, dans le cadre de l'authentification ou de l'intégrité des données, sont résistantes aux collisions et possèdent des longueurs de bits appropriées. Si la résistance aux collisions est requise, la longueur de sortie doit être d'au moins 256 bits. Si seule la résistance aux attaques de seconde pré-image est requise, la longueur de sortie doit être d'au moins 128 bits. | 2 |\n| **11.4.4** | Vérifiez que l'application utilise des fonctions de dérivation de clés approuvées avec des paramètres d'extension de clés lors de la dérivation de clés secrètes à partir de mots de passe. Les paramètres utilisés doivent concilier sécurité et performances afin d'empêcher les attaques par force brute de compromettre la clé cryptographique obtenue. | 2 |\n\n## V11.5 Valeurs aléatoires\n\nLa génération de nombres pseudo-aléatoires cryptographiquement sécurisée (CSPRNG) est extrêmement difficile à mettre en œuvre. En général, les bonnes sources d'entropie d'un système s'épuisent rapidement si elles sont surexploitées, tandis que des sources moins aléatoires peuvent conduire à des clés et des secrets prévisibles.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.5.1** | Vérifiez que tous les nombres et chaînes aléatoires destinés à être non devinables doivent être générés à l'aide d'un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé (CSPRNG) et posséder au moins 128 bits d'entropie. Notez que les UUID ne respectent pas cette condition. | 2 |\n| **11.5.2** | Vérifiez que le mécanisme de génération de nombres aléatoires utilisé est conçu pour fonctionner en toute sécurité, même en cas de forte demande. | 3 |\n\n## V11.6 Cryptographie à clé publique\n\nLa cryptographie à clé publique sera utilisée lorsqu'il est impossible ou non souhaitable de partager une clé secrète entre plusieurs parties.\n\nDans ce contexte, des mécanismes d'échange de clés approuvés, tels que Diffie-Hellman et Elliptic Curve Diffie-Hellman (ECDH), sont nécessaires pour garantir la sécurité du cryptosystème face aux menaces modernes. Le chapitre « Communication sécurisée » décrit les exigences pour TLS. Les exigences de cette section sont donc destinées aux situations où la cryptographie à clé publique est utilisée dans des cas d'utilisation autres que TLS.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.6.1** | Vérifier que seuls des algorithmes cryptographiques et des modes opératoires approuvés sont utilisés pour la génération et l'amorçage des clés, ainsi que pour la génération et la vérification des signatures numériques. Les algorithmes de génération de clés ne doivent pas générer de clés non sécurisées et vulnérables aux attaques connues, par exemple les clés RSA vulnérables à la factorisation de Fermat. | 2 |\n| **11.6.2** | Vérifiez que des algorithmes cryptographiques approuvés sont utilisés pour l'échange de clés (tels que Diffie-Hellman), en veillant à ce que les mécanismes d'échange de clés utilisent des paramètres sécurisés. Cela permettra d'éviter les attaques contre le processus d'établissement des clés, susceptibles de conduire à des attaques de type « adversaire du milieu » ou à des failles cryptographiques. | 3 |\n\n## V11.7 Cryptographie des données en cours d'utilisation\n\nLa protection des données pendant leur traitement est \"le nec plus ultra\". Des techniques telles que le chiffrement intégral de la mémoire, le chiffrement des données en transit et s'assurer que le les données sont chiffrés le plus tôt possible après utilisation.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **11.7.1** | Vérifiez que le chiffrement complet de la mémoire est utilisé pour protéger les données sensibles pendant leur utilisation, empêchant ainsi l'accès par des utilisateurs ou des processus non autorisés. | 3 |\n| **11.7.2** | Vérifiez que la minimisation des données garantit que la quantité minimale de données est exposée pendant le traitement et assurez-vous que les données sont chiffrées immédiatement après utilisation ou dès que possible. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide: Testing for Weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography)\n* [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-3](https://csrc.nist.gov/pubs/fips/140-3/final)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:40:10.851584"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x21-V12-Secure-Communication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x21-V12-Secure-Communication.md", "content": "# V12 Communication sécurisée\n\n## Objectif de contrôle\n\nCe chapitre comprend des exigences relatives aux mécanismes spécifiques qui doivent être mis en place pour protéger les données en transit, à la fois entre un client utilisateur final et un service backend, ainsi qu'entre les services internes et backend.\n\nLes concepts généraux promus par ce chapitre sont les suivants\n\n* S'assurer que les communications sont chiffrées à l'extérieur et, idéalement, à l'intérieur.\n* Configurer les mécanismes de chiffrement en utilisant les dernières recommandations, y compris les algorithmes et les chiffrements préférés.\n* S'assurer que les communications ne sont pas interceptées par des parties non autorisées à l'aide de certificats signés.\n\nOutre les principes généraux et les meilleures pratiques, l'ASVS fournit également des informations techniques plus approfondies sur la puissance cryptographique dans l'annexe C - Normes de cryptographie.\n\n## V12.1 Conseils généraux de sécurité TLS\n\nCette section fournit des conseils initiaux sur la sécurisation des communications TLS. Des outils à jour doivent être utilisés pour vérifier régulièrement la configuration TLS.\n\nBien que l'utilisation de certificats TLS génériques ne soit pas intrinsèquement dangereuse, la compromission d'un certificat déployé dans tous les environnements (par exemple, production, préproduction, développement et test) peut compromettre la sécurité des applications qui l'utilisent. Une protection et une gestion appropriées, ainsi que l'utilisation de certificats TLS distincts dans différents environnements, sont recommandées si possible.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **12.1.1** | Vérifiez que seules les dernières versions recommandées du protocole TLS sont activées, telles que TLS 1.2 et TLS 1.3. La dernière version du protocole TLS doit être privilégiée. | 1 |\n| **12.1.2** | Vérifiez que seules les suites de chiffrement recommandées sont activées, les suites de chiffrement les plus puissantes étant définies comme préférées. Les applications L3 doivent uniquement prendre en charge les suites de chiffrement assurant la confidentialité persistante (forward secrecy). | 2 |\n| **12.1.3** | Vérifiez que l’application valide que les certificats clients mTLS sont approuvés avant d’utiliser l’identité du certificat pour l’authentification ou l’autorisation. | 2 |\n| **12.1.4** | Vérifiez que la révocation de certification appropriée, telle que l'agrafage du protocole OCSP (Online Certificate Status Protocol), est activée et configurée. | 3 |\n| **12.1.5** | Vérifiez que Encrypted Client Hello (ECH) est activé dans les paramètres TLS de l'application pour empêcher l'exposition de métadonnées sensibles, telles que l'indication du nom du serveur (SNI), pendant les processus de négociation TLS. | 3 |\n\n## V12.2 Communication HTTPS avec des services externes\n\nAssurez-vous que tout le trafic HTTP vers les services externes exposés par l'application est envoyé chiffré, avec des certificats de confiance publique.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **12.2.1** | Vérifiez que TLS est utilisé pour toute connectivité entre un client et des services externes basés sur HTTP, et ne recourt pas à des communications non sécurisées ou non chiffrées. | 1 |\n| **12.2.2** | Vérifiez que les services externes utilisent des certificats TLS publiquement approuvés. | 1 |\n\n## V12.3 Sécurité des communications entre services généraux\n\nLes communications serveur (internes et externes) ne se limitent pas au protocole HTTP. Les connexions vers et depuis d'autres systèmes doivent également être sécurisées, idéalement via TLS.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **12.3.1** | Vérifiez qu'un protocole chiffré tel que TLS est utilisé pour toutes les connexions entrantes et sortantes vers et depuis l'application, y compris les systèmes de surveillance, les outils de gestion, l'accès à distance et SSH, les intergiciels, les bases de données, les mainframes, les systèmes partenaires ou les API externes. Le serveur ne doit pas recourir à des protocoles non sécurisés ou non chiffrés. | 2 |\n| **12.3.2** | Vérifiez que les clients TLS valident les certificats reçus avant de communiquer avec un serveur TLS. | 2 |\n| **12.3.3** | Vérifiez que TLS ou un autre mécanisme de chiffrement de transport approprié est utilisé pour toute connectivité entre les services internes basés sur HTTP au sein de l'application et ne se replie pas vers des communications non sécurisées ou non chiffrées. | 2 |\n| **12.3.4** | Vérifiez que les connexions TLS entre les services internes utilisent des certificats de confiance. Lorsque des certificats générés en interne ou auto-signés sont utilisés, le service consommateur doit être configuré pour n'approuver que des autorités de certification internes spécifiques et des certificats auto-signés spécifiques. | 2 |\n| **12.3.5** | Vérifiez que les services communiquant en interne au sein d'un système (communications intra-services) utilisent une authentification forte pour garantir la vérification de chaque endpoint. Des méthodes d'authentification forte, telles que l'authentification client TLS, doivent être utilisées pour garantir l'identité, en utilisant une infrastructure à clé publique et des mécanismes résistants aux attaques par rejeu. Pour les architectures de microservices, envisagez d'utiliser un maillage de services pour simplifier la gestion des certificats et renforcer la sécurité. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP - Transport Layer Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n* [Mozilla's Server Side TLS configuration guide](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* [Mozilla's tool to generate known good TLS configurations](https://ssl-config.mozilla.org/).\n* [O-Saft - OWASP Project to validate TLS configuration](https://owasp.org/www-project-o-saft/)\n", "timestamp": "2025-10-24T11:40:10.942560"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x22-V13-Configuration.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x22-V13-Configuration.md", "content": "# V13 Configuration\n\n## Objectif de contrôle\n\nLa configuration par défaut de l'application doit être sécurisée pour une utilisation sur Internet.\n\nCe chapitre fournit des conseils sur les différentes configurations nécessaires pour y parvenir, y compris celles appliquées pendant le développement, la construction et le déploiement.\n\nLes sujets abordés incluent la prévention des fuites de données, la gestion sécurisée des communications entre les composants et la protection des secrets.\n\n## V13.1 Documentation de configuration\n\nCette section décrit les exigences de documentation relatives à la communication de l'application avec les services internes et externes, ainsi que les techniques permettant d'éviter toute perte de disponibilité due à l'inaccessibilité des services. Elle aborde également la documentation relative aux secrets.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **13.1.1** | Vérifiez que tous les besoins de communication de l'application sont documentés. Cela doit inclure les services externes dont l'application dépend et les cas où un utilisateur final pourrait fournir un emplacement externe auquel l'application se connectera. | 2 |\n| **13.1.2** | Vérifiez que pour chaque service utilisé par l'application, la documentation définit le nombre maximal de connexions simultanées (par exemple, les limites du pool de connexions) et le comportement de l'application lorsque cette limite est atteinte, y compris les mécanismes de secours ou de récupération, pour éviter les conditions de déni de service. | 3 |\n| **13.1.3** | Vérifiez que la documentation de l'application définit des stratégies de gestion des ressources pour chaque système ou service externe utilisé (par exemple, bases de données, descripteurs de fichiers, threads, connexions HTTP). Cela doit inclure les procédures de libération des ressources, les paramètres de délai d'expiration, la gestion des échecs et l'implémentation de la logique de nouvelle tentative, en spécifiant les limites de nouvelle tentative, les délais et les algorithmes de retour arrière. Pour les opérations de requête-réponse HTTP synchrones, la documentation doit imposer des délais d'expiration courts et soit désactiver les nouvelles tentatives, soit les limiter strictement afin d'éviter les retards en cascade et l'épuisement des ressources. | 3 |\n| **13.1.4** | Vérifiez que la documentation de l'application définit les secrets essentiels à la sécurité de l'application et un calendrier de rotation de ceux-ci, en fonction du modèle de menace et des exigences commerciales de l'organisation. | 3 |\n\n## V13.2 Configuration de la communication backend\n\nLes applications interagissent avec plusieurs services, notamment des API, des bases de données ou d'autres composants. Ceux-ci peuvent être considérés comme internes à l'application, mais non inclus dans les mécanismes de contrôle d'accès standard de l'application, ou être entièrement externes. Dans les deux cas, il est nécessaire de configurer l'application pour interagir en toute sécurité avec ces composants et, si nécessaire, de protéger cette configuration.\n\nRemarque : le chapitre « Communication sécurisée » fournit des conseils pour le chiffrement en transit.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **13.2.1** | Vérifiez que les communications entre les composants de l'application backend qui ne prennent pas en charge le mécanisme de session utilisateur standard de l'application, notamment les API, les intergiciels et les couches de données, sont authentifiées. L'authentification doit utiliser des comptes de service individuels, des jetons à court terme ou une authentification par certificat, et non des identifiants immuables tels que des mots de passe, des clés API ou des comptes partagés avec accès privilégié. | 2 |\n| **13.2.2** | Vérifiez que les communications entre les composants de l'application backend, y compris les services locaux ou du système d'exploitation, les API, les intergiciels et les couches de données, sont effectuées avec des comptes dotés des privilèges les moins nécessaires. | 2 |\n| **13.2.3** | Vérifiez que si des informations d’identification doivent être utilisées pour l’authentification du service, les informations d’identification utilisées par le consommateur ne sont pas des informations d’identification par défaut (par exemple, root/root ou admin/admin). | 2 |\n| **13.2.4** | Vérifiez qu'une liste d’autorisations est utilisée pour définir les ressources ou systèmes externes avec lesquels l'application est autorisée à communiquer (par exemple, pour les requêtes sortantes, les chargements de données ou l'accès aux fichiers). Cette liste d'autorisation peut être implémentée au niveau de la couche applicative, du serveur web, du pare-feu ou d'une combinaison de différentes couches. | 2 |\n| **13.2.5** | Vérifiez que le serveur Web ou d’application est configuré avec une liste autorisée de ressources ou de systèmes vers lesquels le serveur peut envoyer des requêtes ou charger des données ou des fichiers. | 2 |\n| **13.2.6** | Vérifiez que lorsque l'application se connecte à des services distincts, elle suit la configuration documentée pour chaque connexion, comme le nombre maximal de connexions parallèles, le comportement lorsque le nombre maximal de connexions autorisées est atteint, les délais d'expiration de connexion et les stratégies de nouvelle tentative. | 3 |\n\n## V13.3 Gestion des secrets\n\nLa gestion des secrets est une tâche de configuration essentielle pour garantir la protection des données utilisées dans l'application. Les exigences spécifiques en matière de cryptographie sont décrites dans le chapitre « Cryptographie », mais cette section se concentre sur les aspects de gestion et de traitement des secrets.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **13.3.1** | Vérifiez qu'une solution de gestion des secrets, telle qu'un coffre-fort de clés, est utilisée pour créer, stocker, contrôler l'accès et détruire en toute sécurité les secrets backend. Ceux-ci peuvent inclure des mots de passe, du matériel de clé, des intégrations avec des bases de données et des systèmes tiers, des clés et des graines pour des jetons temporels, d'autres secrets internes et des clés API. Les secrets ne doivent pas être inclus dans le code source de l'application ni dans les artefacts de build. Pour une application L3, cela doit impliquer une solution matérielle telle qu'un HSM. | 2 |\n| **13.3.2** | Vérifiez que l’accès aux ressources secrètes respecte le principe du moindre privilège. | 2 |\n| **13.3.3** | Vérifiez que toutes les opérations cryptographiques sont effectuées à l'aide d'un module de sécurité isolé (tel qu'un coffre-fort ou un module de sécurité matériel) pour gérer et protéger en toute sécurité le matériel clé contre toute exposition en dehors du module de sécurité. | 3 |\n| **13.3.4** | Vérifiez que les secrets sont configurés pour expirer et être renouvelés en fonction de la documentation de l'application. | 3 |\n\n## V13.4 Fuite d'informations involontaire\n\nLes configurations de production doivent être renforcées afin d'éviter la divulgation de données inutiles. Nombre de ces problèmes sont rarement considérés comme des risques importants, mais sont souvent associés à d'autres vulnérabilités. Si ces problèmes ne sont pas présents par défaut, la barre est plus haute pour les attaques contre une application.\n\nPar exemple, masquer la version des composants côté serveur n'élimine pas la nécessité de corriger tous les composants, et désactiver la liste des dossiers ne supprime pas la nécessité d'utiliser des contrôles d'autorisation ou de garder les fichiers loin du dossier public, mais cela place la barre plus haut.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **13.4.1** | Vérifiez que l'application est déployée soit sans aucune métadonnée de contrôle de source, y compris les dossiers .git ou .svn, soit de manière à ce que ces dossiers soient inaccessibles à la fois en externe et à l'application elle-même. | 1 |\n| **13.4.2** | Vérifiez que les modes de débogage sont désactivés pour tous les composants dans les environnements de production afin d’éviter l’exposition des fonctionnalités de débogage et la fuite d’informations. | 2 |\n| **13.4.3** | Vérifiez que les serveurs Web n’exposent pas les listes de répertoires aux clients, sauf si cela est explicitement prévu. | 2 |\n| **13.4.4** | Vérifiez que l’utilisation de la méthode HTTP TRACE n’est pas prise en charge dans les environnements de production, afin d’éviter toute fuite d’informations potentielle. | 2 |\n| **13.4.5** | Vérifiez que la documentation (comme pour les API internes) et les endpoints de surveillance ne sont pas exposés, sauf si cela est explicitement prévu. | 2 |\n| **13.4.6** | Vérifiez que l’application n’expose pas d’informations de version détaillées des composants backend. | 3 |\n| **13.4.7** | Vérifiez que la couche web est configuré pour servir uniquement les fichiers avec des extensions de fichier spécifiques afin d’éviter toute fuite involontaire d’informations, de configuration et de code source. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing)\n", "timestamp": "2025-10-24T11:40:11.040102"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x23-V14-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x23-V14-Data-Protection.md", "content": "# V14 Protection des données\n\n## Objectif de contrôle\n\nLes applications ne peuvent pas prendre en compte tous les modèles d’utilisation et comportements des utilisateurs et doivent donc mettre en œuvre des contrôles pour limiter l’accès non autorisé aux données sensibles sur les appareils clients.\n\nCe chapitre comprend les exigences relatives à la définition des données à protéger, de la manière dont elles doivent être protégées et des mécanismes spécifiques à mettre en œuvre ou des pièges à éviter.\n\nUn autre élément à prendre en compte pour la protection des données est l'extraction massive, la modification ou l'utilisation excessive. Les exigences de chaque système étant probablement très différentes, déterminer ce qui est « anormal » doit tenir compte du modèle de menace et du risque métier. Du point de vue d'ASVS, la détection de ces problèmes est traitée dans le chapitre « Journalisation de sécurité et gestion des erreurs », et la définition de limites dans le chapitre « Validation et logique métier ».\n\n## V14.1 Documentation sur la protection des données\n\nUne condition préalable essentielle à la protection des données est de catégoriser les données considérées comme sensibles. Il existe probablement plusieurs niveaux de sensibilité, et pour chaque niveau, les contrôles requis pour protéger les données seront différents.\n\nIl existe diverses réglementations et lois sur la confidentialité qui régissent la manière dont les applications doivent gérer le stockage, l'utilisation et la transmission des informations personnelles sensibles. Cette section ne vise plus à reproduire ces types de législation sur la protection des données ou la confidentialité, mais se concentre plutôt sur les considérations techniques clés pour la protection des données sensibles. Veuillez consulter les lois et réglementations locales et, si nécessaire, faire appel à un spécialiste de la confidentialité ou à un avocat qualifié.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **14.1.1** | Vérifiez que toutes les données sensibles créées et traitées par l'application ont été identifiées et classées selon leur niveau de protection. Cela inclut les données uniquement codées et donc facilement déchiffrables, telles que les chaînes Base64 ou la charge utile en texte clair d'un JWT. Les niveaux de protection doivent tenir compte des réglementations et normes de protection des données et de confidentialité auxquelles l'application est tenue de se conformer. | 2 |\n| **14.1.2** | Vérifier que tous les niveaux de protection des données sensibles sont assortis d'un ensemble documenté d'exigences de protection. Cela doit inclure (sans s'y limiter) les exigences relatives au chiffrement général, à la vérification de l'intégrité, à la conservation, à la journalisation des données, aux contrôles d'accès aux données sensibles dans les journaux, au chiffrement au niveau de la base de données, aux technologies de confidentialité et de renforcement de la confidentialité à utiliser, ainsi qu'aux autres exigences de confidentialité. | 2 |\n\n## V14.2 Protection générale des données\n\nCette section présente diverses exigences pratiques relatives à la protection des données. La plupart sont spécifiques à des problématiques particulières, telles que les fuites involontaires de données, mais il existe également une exigence générale de mise en œuvre de contrôles de protection en fonction du niveau de protection requis pour chaque donnée.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **14.2.1** | Vérifiez que les données sensibles sont uniquement envoyées au serveur dans les champs de corps ou d’en-tête du message HTTP, et que l’URL et la chaîne de requête ne contiennent pas d’informations sensibles, telles qu’une clé API ou un jeton de session. | 1 |\n| **14.2.2** | Vérifiez que l’application empêche la mise en cache des données sensibles dans les composants du serveur, tels que les équilibreurs de charge et les caches d’application, ou garantit que les données sont purgées en toute sécurité après utilisation. | 2 |\n| **14.2.3** | Vérifiez que les données sensibles définies ne sont pas envoyées à des parties non fiables (par exemple, des trackers d'utilisateurs) pour empêcher la collecte indésirable de données en dehors du contrôle de l'application. | 2 |\n| **14.2.4** | Vérifiez que les contrôles autour des données sensibles liés au chiffrement, à la vérification de l'intégrité, à la conservation, à la manière dont les données doivent être enregistrées, aux contrôles d'accès autour des données sensibles dans les journaux, à la confidentialité et aux technologies d'amélioration de la confidentialité, sont mis en œuvre comme défini dans la documentation pour le niveau de protection des données spécifiques. | 2 |\n| **14.2.5** | Vérifiez que les mécanismes de mise en cache sont configurés pour ne mettre en cache que les réponses dont le type de contenu est conforme à la ressource et qui ne contiennent pas de contenu sensible et dynamique. Le serveur web doit renvoyer une réponse 404 ou 302 lors de l'accès à un fichier inexistant plutôt qu'un fichier valide différent. Cela devrait empêcher les attaques par empoisonnement de cache web. | 3 |\n| **14.2.6** | Vérifiez que l'application ne renvoie que les données sensibles minimales requises pour son fonctionnement. Par exemple, ne renvoyez que certains chiffres d'un numéro de carte de crédit, et non le numéro complet. Si les données complètes sont requises, elles doivent être masquées dans l'interface utilisateur, sauf si l'utilisateur les consulte spécifiquement. | 3 |\n| **14.2.7** | Vérifiez que les informations sensibles sont soumises à une classification de conservation des données, en veillant à ce que les données obsolètes ou inutiles soient supprimées automatiquement, selon un calendrier défini ou selon les besoins de la situation. | 3 |\n| **14.2.8** | Vérifiez que les informations sensibles sont supprimées des métadonnées des fichiers soumis par l'utilisateur, sauf si le stockage est autorisé par l'utilisateur. | 3 |\n\n## V14.3 Protection des données côté client\n\nCette section contient des exigences empêchant la fuite de données de manière spécifique du côté client ou de l'agent utilisateur d'une application.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **14.3.1** | Vérifiez que les données authentifiées sont effacées du stockage client, comme le DOM du navigateur, après la fin du client ou de la session. Le champ d'en-tête de réponse HTTP « Clear-Site-Data » peut être utile, mais le côté client devrait également pouvoir effectuer la correction si la connexion au serveur n'est pas disponible à la fin de la session. | 1 |\n| **14.3.2** | Vérifiez que l'application définit suffisamment de champs d'en-tête de réponse HTTP anti-caching (c'est-à-dire Cache-Control : no-store) afin que les données sensibles ne soient pas mises en cache dans les navigateurs. | 2 |\n| **14.3.3** | Vérifiez que les données stockées dans le stockage du navigateur (telles que localStorage, sessionStorage, IndexedDB ou les cookies) ne contiennent pas de données sensibles, à l'exception des jetons de session. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [Consider using the Security Headers website to check security and anti-caching header fields](https://securityheaders.com/)\n* [Documentation about anti-caching headers by Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [Australian Privacy Principle 11 - Security of personal information](https://www.oaic.gov.au/privacy/australian-privacy-principles/australian-privacy-principles-guidelines/chapter-11-app-11-security-of-personal-information)\n* [European Union General Data Protection Regulation (GDPR) overview](https://www.edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://www.edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n* [Information on the \"Clear-Site-Data\" header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data)\n* [White paper on Web Cache Deception](https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack-wp.pdf)\n", "timestamp": "2025-10-24T11:40:11.147765"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x24-V15-Secure-Coding-and-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x24-V15-Secure-Coding-and-Architecture.md", "content": "# V15 Développement et architecture sécurisés\n\n## Objectif de contrôle\n\nDe nombreuses exigences de l'ASVS se rapportent soit à un domaine particulier de la sécurité, comme l'authentification ou l'autorisation, soit à un type particulier de fonctionnalité de l'application, comme la journalisation ou la gestion des fichiers.\n\nCe chapitre présente les exigences générales de sécurité à prendre en compte lors de la conception et du développement d'applications. Ces exigences portent non seulement sur la propreté de l'architecture et la qualité du code, mais aussi sur les pratiques spécifiques d'architecture et de codage nécessaires à la sécurité des applications.\n\n## V15.1 Documentation sur le développement et l'architecture sécurisés\n\nDe nombreuses exigences pour établir une architecture sécurisée et défendable dépendent d’une documentation claire des décisions prises concernant la mise en œuvre de contrôles de sécurité spécifiques et des composants utilisés dans l’application.\n\nCette section décrit les exigences en matière de documentation, notamment l’identification des composants considérés comme contenant des « fonctionnalités dangereuses » ou comme des « composants à risque ».\n\nUn composant présentant une « fonctionnalité dangereuse » peut être un composant développé en interne ou par un tiers, effectuant des opérations telles que la désérialisation de données non fiables, l'analyse de fichiers bruts ou binaires, l'exécution de code dynamique ou la manipulation directe de la mémoire. Les vulnérabilités dans ces types d'opérations présentent un risque élevé de compromettre l'application et d'exposer potentiellement son infrastructure sous-jacente.\n\nUn « composant à risque » est une bibliothèque tierce (c'est-à-dire non développée en interne) dont les contrôles de sécurité concernant ses processus de développement ou ses fonctionnalités sont absents ou mal implémentés. Il peut s'agir, par exemple, de composants mal entretenus, non pris en charge, en fin de vie ou présentant des antécédents de vulnérabilités importantes.\n\nCette section souligne également l’importance de définir des délais appropriés pour traiter les vulnérabilités des composants tiers.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **15.1.1** | Vérifiez que la documentation de l'application définit les délais de correction basés sur les risques pour les versions de composants tiers présentant des vulnérabilités et pour la mise à jour des bibliothèques en général, afin de minimiser les risques liés à ces composants. | 1 |\n| **15.1.2** | Vérifiez qu'un catalogue d'inventaire, tel qu'une nomenclature logicielle (SBOM), est conservé pour toutes les bibliothèques tierces utilisées, y compris en vérifiant que les composants proviennent de référentiels prédéfinis, fiables et continuellement maintenus. | 2 |\n| **15.1.3** | Vérifiez que la documentation de l'application identifie les fonctionnalités consommatrices en temps ou gourmandes en ressources. Elle doit notamment indiquer comment prévenir une perte de disponibilité due à une utilisation excessive de ces fonctionnalités et éviter que la génération d'une réponse ne prenne plus de temps que le délai d'expiration du consommateur. Les mesures de protection potentielles peuvent inclure le traitement asynchrone, l'utilisation de files d'attente et la limitation des processus parallèles par utilisateur et par application. | 2 |\n| **15.1.4** | Vérifiez que la documentation de l’application met en évidence les bibliothèques tierces qui sont considérées comme des « composants à risque ». | 3 |\n| **15.1.5** | Vérifiez que la documentation de l’application met en évidence les parties de l’application où des « fonctionnalités dangereuses » sont utilisées. | 3 |\n\n## V15.2 Architecture de sécurité et dépendances\n\nCette section inclut les exigences relatives à la gestion des dépendances et des composants risqués, obsolètes ou non sécurisés.\n\nElle inclut également l'utilisation de techniques au niveau architectural telles que le sandboxing, l'encapsulation, la conteneurisation et l'isolation du réseau pour réduire l'impact de l'utilisation d'« opérations dangereuses » ou de « composants risqués » (tels que définis dans la section précédente) et éviter la perte de disponibilité due à une utilisation excessive de fonctionnalités exigeantes en ressources.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **15.2.1** | Vérifiez que l’application contient uniquement des composants qui n’ont pas dépassé les délais de mise à jour et de correction documentés. | 1 |\n| **15.2.2** | Vérifiez que l'application a mis en œuvre des défenses contre la perte de disponibilité due à des fonctionnalités qui prennent du temps ou qui nécessitent des ressources, sur la base des décisions et stratégies de sécurité documentées à cet effet. | 2 |\n| **15.2.3** | Vérifiez que l'environnement de production inclut uniquement les fonctionnalités nécessaires au fonctionnement de l'application et n'expose pas de fonctionnalités superflues telles que du code de test, des exemples d'extraits et des fonctionnalités de développement. | 2 |\n| **15.2.4** | Vérifiez que les composants tiers et toutes leurs dépendances transitives sont inclus à partir du référentiel attendu, qu'il soit détenu en interne ou qu'il s'agisse d'une source externe, et qu'il n'y a aucun risque d'attaque par confusion de dépendances. | 3 |\n| **15.2.5** | Vérifiez que l'application implémente des protections supplémentaires autour des parties documentées comme contenant des « fonctionnalités dangereuses » ou utilisant des bibliothèques tierces considérées comme des « composants à risque ». Cela peut inclure des techniques telles que le sandboxing, l'encapsulation, la conteneurisation ou l'isolation au niveau du réseau pour retarder et dissuader les attaquants qui compromettent une partie de l'application de se propager ailleurs. | 3 |\n\n## V15.3 Développement défensif\n\nCette section couvre les types de vulnérabilités, y compris le jonglage de types, la pollution de prototypes et autres, qui résultent de l'utilisation de modèles de codage non sécurisés dans un langage particulier. Certaines peuvent ne pas être pertinentes pour tous les langages, tandis que d'autres bénéficieront de correctifs spécifiques à chaque langage ou pourront être liées à la façon dont un langage ou un Framework particulier gère une fonctionnalité telle que les paramètres HTTP. Elle aborde également le risque lié à l'absence de validation cryptographique des mises à jour d'applications.\n\nElle prend également en compte les risques liés à l'utilisation d'objets pour représenter des éléments de données, ainsi qu'à leur acceptation et leur renvoi via des API externes. Dans ce cas, l'application doit s'assurer que les champs de données non accessibles en écriture ne sont pas modifiés par l'utilisateur (affectation de masse) et que l'API sélectionne les champs de données renvoyés. Lorsque l'accès aux champs dépend des autorisations de l'utilisateur, il convient d'en tenir compte dans le contexte des exigences de contrôle d'accès au niveau des champs décrites dans le chapitre « Autorisation ».\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **15.3.1** | Vérifiez que l'application ne renvoie que le sous-ensemble requis de champs d'un objet de données. Par exemple, elle ne doit pas renvoyer un objet de données entier, car certains champs individuels ne doivent pas être accessibles aux utilisateurs. | 1 |\n| **15.3.2** | Vérifiez que lorsque le backend de l'application effectue des appels vers des URL externes, il est configuré pour ne pas suivre les redirections, sauf s'il s'agit d'une fonctionnalité prévue. | 2 |\n| **15.3.3** | Vérifiez que l'application dispose de contre-mesures pour se protéger contre les attaques d'affectation de masse en limitant les champs autorisés par contrôleur et action, par exemple, il n'est pas possible d'insérer ou de mettre à jour une valeur de champ lorsqu'elle n'était pas destinée à faire partie de cette action. | 2 |\n| **15.3.4** | Vérifiez que tous les composants proxy et middleware transfèrent correctement l'adresse IP d'origine de l'utilisateur à l'aide de champs de données fiables qui ne peuvent pas être manipulés par l'utilisateur final, et que l'application et le serveur Web utilisent cette valeur correcte pour la journalisation et les décisions de sécurité telles que la limitation du débit, en tenant compte du fait que même l'adresse IP d'origine peut ne pas être fiable en raison d'adresses IP dynamiques, de VPN ou de pare-feu d'entreprise. | 2 |\n| **15.3.5** | Vérifiez que l'application garantit explicitement que les variables sont du type correct et effectue des opérations d'égalité et de comparaison strictes. Cela permet d'éviter les vulnérabilités liées à la confusion de types, causées par des hypothèses du code de l'application sur le type d'une variable. | 2 |\n| **15.3.6** | Vérifiez que le code JavaScript est écrit de manière à éviter la pollution du prototype, par exemple en utilisant Set() ou Map() au lieu de littéraux d'objet. | 2 |\n| **15.3.7** | Vérifiez que l'application dispose de défenses contre les attaques de pollution des paramètres HTTP, en particulier si le Framework d'application ne fait aucune distinction quant à la source des paramètres de requête (chaîne de requête, paramètres de corps, cookies ou champs d'en-tête). | 2 |\n\n## V15.4 Concurrence sécurisée\n\nLes problèmes de concurrence tels que les situations de concurrence, les vulnérabilités TOCTOU (Time-of-Check-to-Time-of-Use), les interblocages, les livelock, la privation de threads et les synchronisations incorrectes peuvent entraîner des comportements imprévisibles et des risques de sécurité. Cette section présente diverses techniques et stratégies pour atténuer ces risques.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **15.4.1** | Vérifiez que les objets partagés dans le code multithread (tels que les caches, les fichiers ou les objets en mémoire accessibles par plusieurs threads) sont accessibles en toute sécurité à l'aide de types thread-safe et de mécanismes de synchronisation tels que des verrous ou des sémaphores pour éviter les conditions de concurrence et la corruption des données. | 3 |\n| **15.4.2** | Vérifiez que les vérifications de l'état d'une ressource, comme son existence ou ses autorisations, et des actions qui en dépendent, sont effectuées en une seule opération atomique afin d'éviter les situations de concurrence entre le moment de la vérification et le moment de l'utilisation (TOCTOU). Par exemple, vérifier l'existence d'un fichier avant de l'ouvrir ou l'accès d'un utilisateur avant de l'accorder. | 3 |\n| **15.4.3** | Vérifiez que les verrous sont utilisés de manière cohérente pour éviter que les threads ne se bloquent, que ce soit en s'attendant les uns les autres ou en réessayant sans fin, et que la logique de verrouillage reste dans le code responsable de la gestion de la ressource pour garantir que les verrous ne peuvent pas être modifiés par inadvertance ou de manière malveillante par des classes ou du code externes. | 3 |\n| **15.4.4** | Vérifiez que les politiques d'allocation des ressources empêchent la saturation de threads en garantissant un accès équitable aux ressources, par exemple en exploitant les pools de threads, permettant aux threads de priorité inférieure de continuer dans un délai raisonnable. | 3 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Prototype Pollution Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.html)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [OWASP CycloneDX Bill of Materials Specification](https://owasp.org/www-project-cyclonedx/)\n* [OWASP Web Security Testing Guide: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution)\n", "timestamp": "2025-10-24T11:40:11.247519"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x25-V16-Security-Logging-and-Error-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x25-V16-Security-Logging-and-Error-Handling.md", "content": "# V16 Journalisation de sécurité et gestion des erreurs\n\n## Objectif de contrôle\n\nLes journaux de sécurité se distinguent des journaux d'erreurs ou de performances et servent à enregistrer les événements liés à la sécurité, tels que les décisions d'authentification, les décisions de contrôle d'accès et les tentatives de contournement des contrôles de sécurité, comme la validation des entrées ou la validation de la logique métier. Leur objectif est de faciliter la détection, la réponse et l'investigation en fournissant des données structurées et à haut niveau de signal aux outils d'analyse tels que les SIEM.\n\nLes journaux ne doivent pas contenir de données personnelles sensibles, sauf obligation légale, et toutes les données enregistrées doivent être protégées comme des ressources de grande valeur. La journalisation ne doit pas compromettre la confidentialité ni la sécurité du système. Les applications doivent également être sécurisées, évitant toute divulgation ou interruption inutile.\n\nPour des conseils de mise en œuvre détaillés, consultez les aide-mémoire de l'OWASP indiquées dans la section Références.\n\n## V16.1 Documentation sur la journalisation de sécurité\n\nCette section garantit un inventaire clair et complet de la journalisation de l'ensemble de la pile applicative. Ceci est essentiel pour une surveillance efficace de la sécurité, une réponse aux incidents et une conformité optimale.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **16.1.1** | Vérifiez qu'il existe un inventaire documentant la journalisation effectuée à chaque couche de la pile technologique de l'application, les événements enregistrés, les formats de journal, l'endroit où cette journalisation est stockée, la manière dont elle est utilisée, la manière dont l'accès à celle-ci est contrôlé et la durée de conservation des journaux. | 2 |\n\n## V16.2 Journalisation générale\n\nLa présente section énonce des exigences visant à garantir que les journaux de sécurité sont structurés de manière cohérente et contiennent les métadonnées attendues. L'objectif est de rendre les journaux lisibles par une machine et analysables par des systèmes et des outils distribués.\n\nLes événements de sécurité impliquent souvent des données sensibles. Si ces données sont enregistrées sans surveillance, les journaux eux-mêmes deviennent classifiés et donc soumis à des exigences de chiffrement, à des politiques de conservation plus strictes et à une divulgation potentielle lors des audits.\n\nIl est donc essentiel de ne loguer que ce qui est nécessaire et de traiter les données des journaux avec le même soin que les autres ressources sensibles.\n\nLes exigences ci-dessous établissent les exigences fondamentales pour la journalisation des métadonnées, la synchronisation, le format et le contrôle.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **16.2.1** | Vérifiez que chaque entrée de journal inclut les métadonnées nécessaires (telles que quand, où, qui, quoi) qui permettraient une enquête détaillée sur la chronologie lorsqu'un événement se produit. | 2 |\n| **16.2.2** | Vérifiez que les sources de temps de tous les composants de journalisation sont synchronisées et que les horodatages des métadonnées des événements de sécurité utilisent le temps UTC ou incluent un décalage horaire explicite. L'UTC est recommandé pour garantir la cohérence entre les systèmes distribués et éviter toute confusion lors du passage à l'heure d'été. | 2 |\n| **16.2.3** | Vérifiez que l’application stocke ou diffuse uniquement les journaux vers les fichiers et services documentés dans l’inventaire des journaux. | 2 |\n| **16.2.4** | Vérifiez que les journaux peuvent être lus et corrélés par le processeur de journaux utilisé, de préférence en utilisant un format de journalisation commun. | 2 |\n| **16.2.5** | Vérifiez que l'application applique la journalisation en fonction du niveau de protection des données lors de la journalisation de données sensibles. Par exemple, certaines données, comme les identifiants ou les informations de paiement, peuvent être interdites. D'autres données, comme les jetons de session, ne peuvent être enregistrées que par hachage ou masquage, en totalité ou en partie. | 2 |\n\n## V16.3 Événements de sécurité\n\nCette section définit les exigences relatives à la journalisation des événements de sécurité au sein de l'application. La capture de ces événements est essentielle pour détecter les comportements suspects, faciliter les enquêtes et respecter les obligations de conformité.\n\nCette section décrit les types d'événements à journaliser, sans toutefois prétendre à l'exhaustivité. Chaque application présente des facteurs de risque et un contexte opérationnel spécifiques.\n\nNotez que si ASVS inclut la journalisation des événements de sécurité, les alertes et la corrélation (par exemple, les règles SIEM ou l'infrastructure de surveillance) sont considérées comme hors du périmètre et sont gérées par les systèmes opérationnels et de surveillance.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **16.3.1** | Vérifiez que toutes les opérations d'authentification sont enregistrées, y compris les tentatives réussies et infructueuses. Des métadonnées supplémentaires, telles que le type d'authentification ou les facteurs utilisés, doivent également être collectées. | 2 |\n| **16.3.2** | Vérifier que les tentatives d'autorisation infructueuses sont logguées. Pour le niveau 3, cela doit inclure la journalisation de toutes les décisions d'autorisation, y compris lors de l'accès à des données sensibles (sans journalisation des données sensibles elles-mêmes). | 2 |\n| **16.3.3** | Vérifiez que l'application enregistre les événements de sécurité définis dans la documentation et enregistre également les tentatives de contournement des contrôles de sécurité, tels que la validation des entrées, la logique métier et l'anti-automatisation. | 2 |\n| **16.3.4** | Vérifiez que l’application enregistre les erreurs inattendues et les échecs de contrôle de sécurité tels que les échecs TLS du backend. | 2 |\n\n## V16.4 Protection des journaux\n\nLes journaux sont des artefacts d'investigation précieux et doivent être protégés. S'ils peuvent être facilement modifiés ou supprimés, ils perdent leur intégrité et deviennent peu fiables pour les enquêtes sur les incidents ou les procédures légales. Ils peuvent exposer le comportement interne des applications ou des métadonnées sensibles, ce qui en fait une cible de choix pour les attaquants.\n\nCette section définit les exigences visant à garantir la protection des journaux contre les accès non autorisés, les falsifications et les divulgations, ainsi que leur transmission et leur stockage sécurisés dans des systèmes sécurisés et isolés.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **16.4.1** | Vérifiez que tous les composants de journalisation codent correctement les données pour empêcher l’injection de journaux. | 2 |\n| **16.4.2** | Vérifiez que les journaux sont protégés contre tout accès non autorisé et ne peuvent pas être modifiés. | 2 |\n| **16.4.3** | Vérifiez que les journaux sont transmis de manière sécurisée à un système logique distinct pour analyse, détection, alerte et remontée des informations. L'objectif est de garantir qu'en cas de violation de l'application, les journaux ne seront pas compromis. | 2 |\n\n## V16.5 Gestion des erreurs\n\nCette section définit les exigences visant à garantir que les applications échouent proprement et sécurisée sans divulguer de détails internes sensibles.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **16.5.1** | Vérifiez qu'un message générique est renvoyé au consommateur lorsqu'une erreur inattendue ou sensible à la sécurité se produit, garantissant ainsi l'absence d'exposition de données système internes sensibles telles que les traces de pile, les requêtes, les clés secrètes et les jetons. | 2 |\n| **16.5.2** | Vérifiez que l'application continue de fonctionner en toute sécurité lorsque l'accès aux ressources externes échoue, par exemple, en utilisant des modèles tels que des disjoncteurs ou une dégradation progressive. | 2 |\n| **16.5.3** | Vérifiez que l'application échoue proprement et sécurisée, y compris lorsqu'une exception se produit, en évitant les accès en cas d'erreur telles que le traitement d'une transaction malgré les erreurs résultant de la logique de validation. | 2 |\n| **16.5.4** | Vérifiez qu'un gestionnaire d'erreurs de « dernier recours » est défini pour intercepter toutes les exceptions non gérées. Cela permet d'éviter la perte des informations d'erreur qui doivent être loguées dans les fichiers journaux et de garantir qu'une erreur ne paralyse pas l'ensemble du processus applicatif, entraînant une perte de disponibilité. | 3 |\n\nRemarque : Certains langages (dont Swift, Go et, par des pratiques de conception courantes, de nombreux langages fonctionnels) ne prennent pas en charge les exceptions ni les gestionnaires d'événements de dernier recours. Dans ce cas, les architectes et les développeurs doivent utiliser une méthode compatible avec les modèles, les langages ou les frameworks pour garantir que les applications peuvent gérer en toute sécurité les événements exceptionnels, inattendus ou liés à la sécurité.\n\n## Références\n\nPour plus d'informations, voir également :\n\n* [OWASP Web Security Testing Guide: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n* [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* [OWASP Application Logging Vocabulary Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Vocabulary_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:11.346991"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x26-V17-WebRTC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x26-V17-WebRTC.md", "content": "# V17 WebRTC\n\n## Objectif de contrôle\n\nLa communication Web en temps réel (WebRTC) permet l'échange de voix, de vidéo et de données en temps réel dans les applications modernes. Avec l'adoption croissante de cette technologie, la sécurisation de l'infrastructure WebRTC devient cruciale. Cette section présente les exigences de sécurité pour les acteurs qui développent, hébergent ou intègrent des systèmes WebRTC.\n\nLe marché du WebRTC peut être classé en trois segments :\n\n1. Développeurs de produits : Fournisseurs propriétaires et open source qui créent et fournissent des produits et solutions WebRTC. Leur objectif est de développer des technologies WebRTC robustes et sécurisées, utilisables par d'autres.\n\n2. Plateformes de communication en tant que service (CPaaS) : fournisseurs proposant des API, des SDK et l'infrastructure ou les plateformes nécessaires pour exploiter les fonctionnalités WebRTC. Les fournisseurs CPaaS peuvent utiliser des produits de la première catégorie ou développer leur propre logiciel WebRTC pour offrir ces services.\n\n3. Fournisseurs de services : organisations qui exploitent les produits de développeurs ou de fournisseurs CPaaS, ou qui développent leurs propres solutions WebRTC. Elles créent et implémentent des applications pour les conférences en ligne, la santé, l'apprentissage en ligne et d'autres domaines où la communication en temps réel est essentielle.\n\nLes exigences de sécurité décrites ici s'adressent principalement aux développeurs de produits, aux CPaaS et aux fournisseurs de services qui :\n\n* utilisent des solutions open source pour développer leurs applications WebRTC ;\n* utilisent des produits WebRTC commerciaux au sein de leur infrastructure ;\n* utilisent des solutions WebRTC développées en interne ou intègrent divers composants dans une offre de services cohérente.\n\nIl est important de noter que ces exigences de sécurité ne s'appliquent pas aux développeurs qui utilisent exclusivement les SDK et les API fournis par les fournisseurs CPaaS. Pour ces développeurs, les fournisseurs CPaaS sont généralement responsables de la plupart des problèmes de sécurité sous-jacents à leurs plateformes, et une norme de sécurité générique comme ASVS peut ne pas répondre pleinement à leurs besoins.\n\n## V17.1 Serveur TURN\n\nCette section définit les exigences de sécurité pour les systèmes utilisant leurs propres serveurs TURN (Traversal Using Relays around NAT). Les serveurs TURN contribuent au relais des médias dans les environnements réseau restrictifs, mais peuvent présenter des risques en cas de mauvaise configuration. Ces contrôles se concentrent sur le filtrage sécurisé des adresses et la protection contre l'épuisement des ressources.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **17.1.1** | Vérifiez que le service TURN (Traversal Using Relays around NAT) autorise uniquement l'accès aux adresses IP non réservées à des fins spécifiques (par exemple, réseaux internes, diffusion, bouclage). Notez que cela s'applique aux adresses IPv4 et IPv6. | 2 |\n| **17.1.2** | Vérifiez que le service Traversal Using Relays around NAT (TURN) n'est pas susceptible d'épuiser ses ressources lorsque des utilisateurs légitimes tentent d'ouvrir un grand nombre de ports sur le serveur TURN. | 3 |\n\n## V17.2 Média\n\nCes exigences s'appliquent uniquement aux systèmes hébergeant leurs propres serveurs multimédias WebRTC, tels que les unités de transfert sélectif (SFU), les unités de contrôle multipoint (MCU), les serveurs d'enregistrement ou les serveurs de passerelle. Les serveurs multimédias gèrent et distribuent les flux multimédias, ce qui rend leur sécurité essentielle pour protéger les communications entre homologues. La protection des flux multimédias est primordiale dans les applications WebRTC pour prévenir les écoutes clandestines, les falsifications et les attaques par déni de service susceptibles de compromettre la confidentialité des utilisateurs et la qualité des communications.\n\nEn particulier, il est nécessaire de mettre en œuvre des protections contre les attaques par saturation, telles que la limitation du débit, la validation des horodatages, l'utilisation d'horloges synchronisées pour correspondre aux intervalles en temps réel et la gestion des tampons afin d'éviter les débordements et de maintenir une synchronisation correcte. Si les paquets d'une session multimédia spécifique arrivent trop rapidement, les paquets excédentaires doivent être rejetés. Il est également important de protéger le système contre les paquets malformés en implémentant la validation des entrées, en gérant en toute sécurité les dépassements d'entiers, en prévenant les dépassements de tampon et en utilisant d'autres techniques robustes de gestion des erreurs.\n\nLes systèmes qui s'appuient uniquement sur la communication multimédia peer-to-peer entre navigateurs Web, sans l'intervention de serveurs multimédias intermédiaires, sont exclus de ces exigences de sécurité spécifiques liées aux médias.\n\nCette section traite de l'utilisation de la sécurité de la couche de transport des datagrammes (DTLS) dans le contexte de WebRTC. L'exigence relative à la mise en place d'une politique documentée de gestion des clés cryptographiques est décrite dans le chapitre « Cryptographie ». Des informations sur les méthodes cryptographiques approuvées sont disponibles dans l'annexe Cryptographie de l'ASVS ou dans des documents tels que NIST SP 800-52 Rev. 2 ou BSI TR-02102-2 (version 2025-01).\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **17.2.1** | Vérifiez que la clé du certificat Datagram Transport Layer Security (DTLS) est gérée et protégée conformément à la politique documentée de gestion des clés cryptographiques. | 2 |\n| **17.2.2** | Vérifiez que le serveur multimédia est configuré pour utiliser et prendre en charge les suites de chiffrement DTLS (Datagram Transport Layer Security) approuvées et un profil de protection sécurisé pour l'extension DTLS pour l'établissement de clés pour le protocole de transport en temps réel sécurisé (DTLS-SRTP). | 2 |\n| **17.2.3** | Vérifiez que l'authentification SRTP (Secure Real-time Transport Protocol) est vérifiée sur le serveur multimédia pour empêcher les attaques par injection RTP (Real-time Transport Protocol) d'entraîner une condition de déni de service ou l'insertion de médias audio ou vidéo dans les flux multimédias. | 2 |\n| **17.2.4** | Vérifiez que le serveur multimédia est en mesure de continuer à traiter le trafic multimédia entrant lorsqu'il rencontre des paquets SRTP (Secure Real-time Transport Protocol) mal formés. | 2 |\n| **17.2.5** | Vérifiez que le serveur multimédia est en mesure de continuer à traiter le trafic multimédia entrant pendant un flot de paquets SRTP (Secure Real-time Transport Protocol) provenant d'utilisateurs légitimes. | 3 |\n| **17.2.6** | Vérifiez que le serveur multimédia n'est pas sensible à la vulnérabilité de condition de concurrence « ClientHello » dans Datagram Transport Layer Security (DTLS) en vérifiant si le serveur multimédia est publiquement connu comme étant vulnérable ou en effectuant le test de condition de concurrence. | 3 |\n| **17.2.7** | Vérifiez que tous les mécanismes d'enregistrement audio ou vidéo associés au serveur multimédia sont en mesure de continuer à traiter le trafic multimédia entrant pendant un flot de paquets SRTP (Secure Real-time Transport Protocol) provenant d'utilisateurs légitimes. | 3 |\n| **17.2.8** | Vérifiez que le certificat Datagram Transport Layer Security (DTLS) est vérifié par rapport à l'attribut d'empreinte cryptographique du protocole de description de session (SDP), en mettant fin au flux multimédia si la vérification échoue, pour garantir l'authenticité du flux multimédia. | 3 |\n\n## V17.3 Signalisation\n\nCette section définit les exigences pour les systèmes qui exploitent leurs propres serveurs de signalisation WebRTC. La signalisation coordonne les communications \"pair à pair\" et doit être résiliente face aux attaques susceptibles de perturber l'établissement ou le contrôle des sessions.\n\nPour garantir une signalisation sécurisée, les systèmes doivent gérer correctement les entrées malformées et rester disponibles sous charge.\n\n| # | Description | Niveau |\n| :---: | :--- | :---: |\n| **17.3.1** | Vérifiez que le serveur de signalisation est capable de continuer à traiter les messages de signalisation entrants légitimes lors d'une attaque par saturation. Cela peut être réalisé en implémentant une limitation de débit au niveau de la signalisation. | 2 |\n| **17.3.2** | Vérifiez que le serveur de signalisation est capable de continuer à traiter les messages de signalisation légitimes en cas de message mal formé susceptible de provoquer un déni de service. Cela peut inclure la validation des entrées, la gestion sécurisée des dépassements d'entiers, la prévention des dépassements de tampon et l'utilisation d'autres techniques robustes de gestion des erreurs. | 2 |\n\n## Références\n\nPour plus d'informations, voir également :\n\n* Le WebRTC DTLS ClientHello DoS est mieux documenté ici : [Article du blog d'Enable Security destiné aux professionnels de la sécurité](https://www.enablesecurity.com/blog/novel-dos-vulnerability-affecting-webrtc-media-servers/) et ici [livre blanc destiné aux développeurs WebRTC](https://www.enablesecurity.com/blog/webrtc-hello-race-conditions-paper/)\n* [RFC 3550 - RTP: A Transport Protocol for Real-Time Applications](https://www.rfc-editor.org/rfc/rfc3550)\n* [RFC 3711 - The Secure Real-time Transport Protocol (SRTP)](https://datatracker.ietf.org/doc/html/rfc3711)\n* [RFC 5764 - Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP))](https://datatracker.ietf.org/doc/html/rfc5764)\n* [RFC 8825 - Overview: Real-Time Protocols for Browser-Based Applications](https://www.rfc-editor.org/info/rfc8825)\n* [RFC 8826 - Security Considerations for WebRTC](https://www.rfc-editor.org/info/rfc8826)\n* [RFC 8827 - WebRTC Security Architecture](https://www.rfc-editor.org/info/rfc8827)\n* [DTLS-SRTP Protection Profiles](https://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml)\n", "timestamp": "2025-10-24T11:40:11.515057"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x90-Appendix-A_Glossary.md", "content": "# Annexe A : Glossaire\n\n* **Architecture de sécurité** – Abstraction de la conception d'une application qui identifie et décrit où et comment les contrôles de sécurité sont utilisés, et identifie et décrit également l'emplacement et la sensibilité des données utilisateur et applicatives.\n* **Address Space Layout Randomization (ASLR)** - Une technique pour rendre plus difficile l'exploitation des bugs de corruption de la mémoire.\n* **Analyse de la composition logicielle** (SCA) – Ensemble de technologies conçues pour analyser la composition, les dépendances, les bibliothèques et les packages des applications afin de détecter les vulnérabilités de sécurité des versions de composants spécifiques utilisées. À ne pas confondre avec l'analyse du code source, communément appelée SAST.\n* **Authentification** – Vérification de l'identité revendiquée par un utilisateur d'application.\n* **Authentification client TLS**, également appelée **TLS mutuel** (mTLS) - Dans une connexion TLS standard, un client peut utiliser le certificat fourni par le serveur pour valider son identité. Lorsque l'authentification client TLS est utilisée, le client utilise également sa propre clé privée et son propre certificat pour permettre au serveur de valider également son identité.\n* **Authentificateur à facteur unique** – Mécanisme permettant de vérifier l'authentification d'un utilisateur. Il peut s'agir d'un élément que vous connaissez (secrets mémorisés, mots de passe, phrases secrètes, codes PIN), d'une information que vous êtes (biométrie, empreinte digitale, reconnaissance faciale) ou d'un élément que vous possédez (jetons OTP, dispositif cryptographique tel qu'une carte à puce).\n* **Authentification multifacteur** (MFA) - Authentification qui inclut au moins deux facteurs uniques.\n* **Authentification par authentification unique** (SSO) – Elle se produit lorsqu'un utilisateur se connecte à une application et est ensuite automatiquement connecté à d'autres applications sans avoir à se réauthentifier. Par exemple, lorsqu'il se connecte à Google, il sera automatiquement connecté à d'autres services Google tels que YouTube, Google Docs et Gmail.\n* **Bill of Materials logiciels** (SBOM) – Liste structurée et complète de tous les composants, modules, bibliothèques, Framework et autres ressources nécessaires à la création ou à l'assemblage d'une application logicielle.\n* **Certificat X.509** – Un certificat X.509 est un certificat numérique qui utilise la norme internationale d'infrastructure à clés publiques (PKI) X.509, largement acceptée, pour vérifier qu'une clé publique appartient à l'identité de l'utilisateur, de l'ordinateur ou du service contenue dans le certificat.\n* **Code d'authentification de message** (MAC) - Somme de contrôle cryptographique des données, calculée par un algorithme de génération de MAC, utilisée pour garantir leur intégrité et leur authenticité.\n* **Communication Web en temps réel** (WebRTC) – Pile de protocoles et API web associée, utilisées pour le transport de flux multimédias dans les applications web, généralement dans le cadre de téléconférences. Basée sur SRTP, SRTCP, DTLS, SDP et STUN/TURN.\n* **Configuration de sécurité** – Configuration d'exécution d'une application qui affecte l'utilisation des contrôles de sécurité.\n* **Contrôle de sécurité** – Fonction ou composant qui effectue un contrôle de sécurité (par exemple, un contrôle d'autorisation) ou, lorsqu'il est appelé, produit un effet de sécurité (par exemple, la génération d'un enregistrement d'audit).\n* **Composant** – Unité de code autonome, avec des interfaces disque et réseau associées, qui communique avec d'autres composants.\n* **Couche de service sécurisé** – Tout point d'application de contrôle sécurisé, tel qu'un microservice, une API sans serveur, côté serveur, une API sécurisée sur un appareil client doté d'un démarrage sécurisé, des API partenaires ou externes, etc. Le terme « sécurisé » signifie qu'il n'y a aucun risque qu'un utilisateur non sécurisé puisse contourner ou ignorer la couche ou les contrôles implémentés à cette couche.\n* **Cross-Site Scripting** (XSS) – Vulnérabilité de sécurité généralement présente dans les applications web, permettant l'injection de scripts côté client dans le contenu.\n* **Cycle de vie du développement logiciel** (SDLC) – Processus étape par étape de développement d'un logiciel, depuis les exigences initiales jusqu'au déploiement et à la maintenance.\n* **Datagram Transport Layer Security** (DTLS) – Protocole cryptographique assurant la sécurité des communications sur une connexion réseau. Basé sur le protocole TLS, il est adapté à la protection des protocoles orientés datagrammes (généralement via UDP). Défini dans la RFC 9147 pour DTLS 1.3.\n* **Délai d'inactivité** – Durée pendant laquelle une session peut rester active en l'absence d'interaction de l'utilisateur avec l'application. Il s'agit d'un élément de l'expiration de la session.\n* **Durée de vie maximale absolue d'une session** – Également appelée « délai d'expiration global » par le NIST, il s'agit de la durée maximale pendant laquelle une session peut rester active après authentification, quelle que soit l'interaction de l'utilisateur. Il s'agit d'un élément de l'expiration de la session.\n* **Entité externe XML** (XXE) – Type d'entité XML permettant d'accéder à du contenu local ou distant via un identifiant système déclaré. Cela peut conduire à diverses attaques par injection.\n* **Énumération des faiblesses courantes** (CWE) – Liste communautaire des faiblesses courantes en matière de sécurité logicielle. Elle sert de langage commun, de critère de mesure pour les outils de sécurité logicielle et de référence pour l'identification, l'atténuation et la prévention des faiblesses.\n* **Environnement d'exécution sécurisé** (TEE) - Un environnement de traitement isolé dans lequel les applications peuvent être exécutées en toute sécurité, indépendamment du reste du système.\n* **Extension de sécurité de la couche de transport de datagrammes pour l'établissement de clés pour le protocole de transport sécurisé en temps réel** (DTLS-SRTP) – Mécanisme d'utilisation d'une négociation DTLS pour l'établissement des clés d'une session SRTP. Définie dans la RFC 5764.\n* **Falsification de requête côté serveur** (SSRF) – Attaque qui exploite les fonctionnalités du serveur pour lire ou mettre à jour des ressources internes. L'attaquant fournit ou modifie une URL, que le code exécuté sur le serveur lit ou à laquelle il soumet des données.\n* **Fast IDentity Online** (FIDO) – Ensemble de normes d'authentification permettant l'utilisation de différentes méthodes d'authentification, notamment la biométrie, les modules de plateforme sécurisée (TPM), les jetons de sécurité USB, etc.\n* **Fonction de dérivation de clé basée sur un mot de passe 2** (PBKDF2) – Algorithme unidirectionnel spécial utilisé pour créer une clé cryptographique forte à partir d'un texte d'entrée (tel qu'un mot de passe) et d'une valeur de sel aléatoire supplémentaire. Il peut donc être utilisé pour rendre plus difficile le forçage d'un mot de passe hors ligne si la valeur résultante est stockée à la place du mot de passe d'origine.\n* **Fournisseur d'identité** (IdP) – Également appelé fournisseur de services d'identification (CSP) dans les références NIST. Entité qui fournit une source d'authentification pour d'autres applications.\n* **Fournisseur de services d'identification** (CSP) – Également appelé fournisseur d'identité (IdP). Source de données utilisateur pouvant être utilisée comme source d'authentification par d'autres applications.\n* **Générateur de nombres pseudo-aléatoires cryptographiquement sécurisé** (CSPRNG) - Un générateur de nombres pseudo-aléatoires avec des propriétés qui le rendent adapté à une utilisation en cryptographie, également appelé générateur de nombres aléatoires cryptographiques (CRNG).\n* **Gestion des informations et des événements de sécurité** (SIEM) - Système de détection des menaces, de conformité et de gestion des incidents de sécurité par la collecte et l'analyse de données de sécurité provenant de diverses sources au sein de l'infrastructure informatique d'une organisation.\n* **Graphiques vectoriels évolutifs** (SVG) – Langage de balisage XML pour la description de graphiques vectoriels bidimensionnels.\n* **Hardware Security Module** (HSM) – Composant matériel qui stocke les clés cryptographiques et autres secrets de manière protégée.\n* **Hibernate Query Language** (HQL) – Langage de requête similaire au SQL utilisé par la bibliothèque Hibernate ORM.\n* **HTTP Strict Transport Security** (HSTS) – Politique qui indique au navigateur de se connecter uniquement au domaine renvoyant l'en-tête via TLS et lorsqu'un certificat valide est présenté. Elle est activée via le champ d'en-tête de réponse Strict-Transport-Security.\n* **HyperText Transfer Protocol** (HTTP) – Protocole d'application pour les systèmes d'information hypermédia distribués et collaboratifs. Il constitue le fondement de la communication de données sur le World Wide Web.\n* **Identifiant de ressource uniforme** (URI) – Chaîne de caractères unique identifiant une ressource, telle qu'une page web, une adresse e-mail, des lieux.\n* **Identifiant de session** ou **ID de session** – Clé identifiant une session avec état stockée dans le backend. Transférée vers et depuis le client, soit sous forme de jeton de référence, soit à l'intérieur d'un jeton de référence.\n* **Identifiant unique universel** (UUID) – Un numéro de référence unique utilisé comme identifiant dans un logiciel.\n* **Inclusion de fichiers distants** (RFI) – Attaque exploitant des procédures d'inclusion vulnérables dans l'application, entraînant l'inclusion de fichiers distants.\n* **Inclusion de fichiers locaux** (LFI) – Attaque exploitant les procédures d'inclusion de fichiers vulnérables d'une application, entraînant l'inclusion de fichiers locaux déjà présents sur le serveur.\n* **Inclusion de script intersite** (XSSI) – Variante d'une attaque de script intersite (XSS) dans laquelle une application web récupère du code malveillant depuis une ressource externe et l'intègre à son propre contenu.\n* **Infrastructure à clés publiques** (PKI) – Dispositif qui lie les clés publiques aux identités respectives des entités. Cette liaison est établie par un processus d'enregistrement et de délivrance de certificats auprès et par une autorité de certification (AC).\n* **Injection SQL** (SQLi) - Technique d'injection de code utilisée pour attaquer les applications pilotées par les données, dans laquelle des instructions SQL malveillantes sont insérées dans un endpoint.\n* **Jeton anti-falsification** – Mécanisme par lequel un ou plusieurs jetons sont transmis dans une requête et validés par le serveur d'app.\n* **Code d'authentification de message** (MAC) - Somme de contrôle cryptographique des données, calculée par un algorithme de génération de MAC, utilisée pour garantir leur intégrité et leur authenticité.\n* **Jeton autonome** – Jeton qui encapsule un ou plusieurs attributs indépendants de l'état côté serveur ou d'un autre stockage externe. Ces jetons garantissent l'authenticité et l'intégrité des attributs qu'ils contiennent, permettant un échange d'informations sécurisé et « sans état » entre les systèmes. Les jetons autonomes sont généralement sécurisés à l'aide de techniques cryptographiques, telles que les signatures numériques ou les codes d'authentification de messages (MAC), afin de garantir l'authenticité, l'intégrité et, dans certains cas, la confidentialité de leurs données. Les assertions SAML et les JWT en sont des exemples courants.\n* **Jeton de référence** – Type de jeton servant de pointeur ou d'identifiant vers un état ou des métadonnées stockées sur un serveur, parfois appelés jetons aléatoires ou jetons opaques. Contrairement aux jetons autonomes, qui intègrent certaines de leurs données pertinentes au sein même du jeton, les jetons de référence ne contiennent aucune information intrinsèque et dépendent du serveur pour le contexte. Le jeton de référence sera ou contiendra un identifiant de session.\n* **Jeton de session** – Expression générique utilisée dans la présente norme pour désigner le jeton ou la valeur utilisé(e) dans les mécanismes de session sans état (qui utilisent un jeton autonome) ou dans les mécanismes de session avec état (qui utilisent un jeton de référence).\n* **Jeton Web JSON** (JWT) – La RFC 7519 définit une norme pour un objet de données JSON composé d'une section d'en-tête expliquant comment valider l'objet, d'une section de corps contenant un ensemble de déclarations et d'une section de signature contenant une signature numérique permettant de valider le contenu de la section de corps. Il s'agit d'un type de jeton autonome.\n* **Liste d'autorisation** – Liste de données ou d'opérations autorisées, par exemple une liste de caractères autorisés à valider les entrées.\n* **Localisateur de ressources uniforme** (URL) – Chaîne spécifiant l'emplacement d'une ressource sur Internet.\n* **Malware** - Code introduit dans une application pendant son développement, à l'insu de son propriétaire, qui contourne la politique de sécurité prévue de l'application. Différent des logiciels malveillants tels qu'un virus ou un ver !\n* **Mappage objet-relationnel** (ORM) - Système permettant de référencer et d'interroger une base de données relationnelle/table au sein d'un programme d'application à l'aide d'un modèle objet compatible avec l'application.\n* **Mécanisme de session avec état** - Dans un mécanisme de session avec état, l'application conserve l'état de la session dans le backend, ce qui correspond généralement à un jeton de session, généré à l'aide d'un générateur de nombres pseudo-aléatoires cryptographiquement sécurisé (CSPRNG), délivré à l'utilisateur final.\n* **Mécanisme de session sans état** - Un mécanisme de session sans état utilise un jeton autonome transmis aux clients et contenant des informations de session qui ne sont pas nécessairement stockées au sein du service, qui reçoit et valide ensuite le jeton. En réalité, un service doit avoir accès à certaines informations de session (comme une liste de révocation JWT) pour pouvoir appliquer les contrôles de sécurité requis.\n* **Module cryptographique** – Matériel, logiciel et/ou micrologiciel implémentant des algorithmes cryptographiques et/ou générant des clés cryptographiques.\n* **Module de plateforme sécurisé** (TPM) – Type de HSM généralement rattaché à un composant matériel plus important, comme une carte mère, et servant de « racine de confiance » pour ce système.\n* **Mot de passe à usage unique** (OTP) - Mot de passe généré de manière unique pour une utilisation unique.\n* **Open Worldwide Application Security Project** (OWASP) – L'OWASP (Open Worldwide Application Security Project) est une communauté mondiale, libre et ouverte, qui se consacre à l'amélioration de la sécurité des logiciels applicatifs. Notre mission est de rendre la sécurité des applications visible, afin que les personnes et les organisations puissent prendre des décisions éclairées face aux risques de sécurité applicative. Voir : [https://www.owasp.org/](https://www.owasp.org/).\n* **OTP basé sur l'heure** - Méthode de génération d'un OTP où l'heure actuelle fait partie de l'algorithme de génération du mot de passe.\n* **Partie de confiance** (RP) – Généralement une application qui s'appuie sur l'authentification d'un utilisateur auprès d'un fournisseur d'authentification distinct. L'application s'appuie sur un jeton ou un ensemble d'assertions signées fournies par ce fournisseur d'authentification pour garantir que l'utilisateur est bien celui qu'il prétend être.\n* **Protocole de description de session** (SDP) - Format de message permettant de configurer une session multimédia (utilisé par exemple dans WebRTC). Défini dans la RFC 4566.\n* **Protocole de transport en temps réel** (RTP) et **Protocole de contrôle de transport en temps réel** (RTCP) - Deux protocoles utilisés conjointement pour le transport de flux multimédia. Utilisé par la pile WebRTC. Défini dans la RFC 3550.\n* **Protocole de transfert hypertexte sur SSL/TLS** (HTTPS) – Méthode de sécurisation des communications HTTP par chiffrement à l'aide du protocole TLS (Transport Layer Security).\n* **Rapport de vérification de la sécurité des applications** – Rapport documentant les résultats globaux et l'analyse justificative produite par le vérificateur pour une application donnée.\n* **Réseau téléphonique public commuté** (RTPC) – Réseau téléphonique traditionnel qui comprend à la fois les téléphones fixes et les téléphones mobiles.\n* **Secure Real-time Transport Protocol** (SRTP) et **Secure Real-time Transport Control Protocol** (SRTCP) – Profil des protocoles RTP et RTCP prenant en charge le chiffrement des messages, l'authentification et la protection de leur intégrité. Défini dans la RFC 3711.\n* **Security Assertion Markup Language** (SAML) – Une norme ouverte pour l’authentification unique basée sur la transmission d’assertions signées (généralement des objets XML) entre le fournisseur d’identité et la partie utilisatrice.\n* **Sécurité des applications** – La sécurité au niveau des applications se concentre sur l'analyse des composants de la couche applicative du modèle de référence d'interconnexion des systèmes ouverts (OSI), plutôt que sur le système d'exploitation sous-jacent ou les réseaux connectés, par exemple.\n* **Test boîte noire** – Méthode de test logiciel qui examine les fonctionnalités d'une application sans scruter ses structures ou son fonctionnement internes.\n* **Tests dynamiques de sécurité des applications** (DAST) – Technologies conçues pour détecter les conditions indiquant une vulnérabilité de sécurité dans une application en cours d'exécution.\n* **Time-of-check to time-of-use** (TOCTOU) - Situation dans laquelle une application vérifie l'état d'une ressource avant de l'utiliser, mais cet état peut être modifié entre la vérification et l'utilisation. Cela peut invalider les résultats de la vérification et entraîner des actions non valides de l'application en raison de cette incohérence d'état.\n* **Time based One-time Passwords** (TOTPs) - Méthode de génération d'un OTP dans laquelle l'heure actuelle fait partie de l'algorithme de génération du mot de passe.\n* **Transport Layer Security** (TLS) - Protocoles cryptographiques qui assurent la sécurité des communications sur une connexion réseau.\n* **Traversée utilisant des relais autour de NAT** (TURN) – Extension du protocole STUN utilisant un serveur TURN comme relais lorsque les connexions \"pair à pair\" directes ne peuvent être établies. Défini dans la RFC 8656.\n* **TLS mutuel** (mTLS) - Voir authentification client TLS.\n* **Utilitaires de traversée de session pour NAT** (STUN) - Protocole utilisé pour faciliter la traversée NAT afin d'établir des communications \"pair à pair\". Défini dans la RFC 3489.\n* **Validation des entrées** - Canonisation et validation des entrées utilisateur non fiables.\n* **Vérificateur** – Personne ou équipe qui examine une demande par rapport aux exigences ASVS de l'OWASP.\n* **Vérification automatisée** – Utilisation d'outils automatisés (analyse dynamique, analyse statique, ou les deux) qui utilisent les signatures de vulnérabilité pour détecter les problèmes.\n* **Vérification de la conception** – Évaluation technique de l'architecture de sécurité d'une application.\n* **Vérification de la sécurité des applications** – Évaluation technique d'une application par rapport à l'ASVS de l'OWASP.\n* **Vérification dynamique** – Utilisation d'outils automatisés utilisant les signatures de vulnérabilité pour détecter les problèmes lors de l'exécution d'une application.\n* **WebSocket sur TLS** (WSS) – Pratique de sécurisation des communications WebSocket en superposant WebSocket sur le protocole TLS.\n* **What You See Is What You Get** (WYSIWYG) – Éditeur de contenu riche qui montre l'apparence réelle du contenu une fois rendu, plutôt que le codage utilisé pour gérer le rendu.\n", "timestamp": "2025-10-24T11:40:11.664308"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x91-Appendix-B_References.md", "content": "# Annexe B : Références\n\nLes projets OWASP suivants sont les plus susceptibles d’être utiles aux utilisateurs/adoptants de cette norme :\n\n## Projets principaux de l'OWASP\n\n1. OWASP Top 10 Project : [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide : [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls : [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Software Assurance Maturity Model (SAMM) : [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n5. OWASP Secure Headers Project : [https://owasp.org/www-project-secure-headers/](https://owasp.org/www-project-secure-headers/)\n\n## Projet de la série de fiches aide-mémoire de l'OWASP\n\n[Ce projet](https://owasp.org/www-project-cheat-sheets/) contient plusieurs aide-mémoires qui seront pertinents pour différents sujets de l'ASVS.\n\nIl existe un mappage vers l'ASVS qui peut être trouvé ici : [https://cheatsheetseries.owasp.org/IndexASVS.html](https://cheatsheetseries.owasp.org/IndexASVS.html)\n\n## Projets liés à la sécurité mobile\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Projets Internet des objets de l'OWASP\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Projets sans serveur OWASP\n\n1. OWASP Serverless Project : [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Autres\n\nDe même, les sites Web suivants sont susceptibles d’être utiles aux utilisateurs/adoptants de cette norme\n\n1. SecLists Github : [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration : [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council : [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures : [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures : [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures : [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n7. OWASP ASVS 4.0 Testing Guide : [https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide](https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide)\n", "timestamp": "2025-10-24T11:40:11.794891"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x92-Appendix-C_Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x92-Appendix-C_Cryptography.md", "content": "# Annexe C : Standards cryptographiques\n\nLe chapitre « Cryptographie » va au-delà de la simple définition des bonnes pratiques. Il vise à améliorer la compréhension des principes de cryptographie et à encourager l'adoption de méthodes de sécurité plus résilientes et modernes. Cette annexe fournit des informations techniques détaillées sur chaque exigence, en complément des normes générales décrites dans le chapitre « Cryptographie ».\n\nCette annexe définit le niveau d'approbation des différents mécanismes cryptographiques :\n\n* Les mécanismes _Approuvés_ (A) peuvent être utilisés dans les applications.\n* Les mécanismes _Hérités_ (L) ne devraient pas être utilisés dans les applications, mais peuvent néanmoins être utilisés uniquement pour assurer la compatibilité avec les applications ou le code existants. Bien que l'utilisation de ces mécanismes ne soit pas actuellement considérée comme une vulnérabilité en soi, ils devraient être remplacés par des mécanismes plus sûrs et évolutifs dès que possible.\n* Les mécanismes _Interdits_ (D) ne devraient pas être utilisés car ils sont actuellement considérés comme cassés ou n'offrent pas une sécurité suffisante.\n\nCette liste peut être modifiée dans le contexte d'une application donnée pour diverses raisons, notamment :\n\n* nouvelles évolutions dans le domaine de la cryptographie ;\n* conformité à une réglementation.\n\n## Inventaire et documentation cryptographiques\n\nCette section fournit des informations complémentaires\nsur l'inventaire et la documentation cryptographiques V11.1.\n\nIl est important de s'assurer que tous les actifs cryptographiques, tels que les algorithmes, les clés et les certificats, sont régulièrement découverts, inventoriés et évalués. Pour le niveau 3, cela devrait inclure l'utilisation d'analyses statiques et dynamiques pour découvrir l'utilisation de la cryptographie dans une application. Des outils tels que les SAST et DAST peuvent être utiles, mais des outils dédiés pourraient être nécessaires pour une couverture plus complète. Voici quelques exemples d'outils gratuits :\n\n* [CryptoMon - Moniteur de cryptographie réseau - utilisant eBPF, écrit en python](https://github.com/Santandersecurityresearch/CryptoMon)\n* [Cryptobom Forge Tool: Generating Comprehensive CBOMs from CodeQL Outputs](https://github.com/Santandersecurityresearch/cryptobom-forge)\n\n## Forces équivalentes des paramètres cryptographiques\n\nLes niveaux de sécurité relatifs des différents systèmes cryptographiques sont présentés dans ce tableau (extrait de [NIST SP 800-57 Partie 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final), p.71) :\n\n| Force de sécurité | Algorithmes à clés symétriques | Corps finis | Factorisation d'entiers | Courbe elliptique |\n|--|--|--|--|--|\n| <= 80 | 2TDEA | L = 1024 <br> N = 160 | k = 1024 | f = 160-223 |\n| 112 | 3TDEA   | L = 2048 <br> N = 224 | k = 2048 | f = 224-255 |\n| 128 | AES-128 | L = 3072 <br> N = 256 | k = 3072 | f = 256-383 |\n| 192 | AES-192 | L = 7680 <br> N = 384 | k = 7680 | f = 384-511 |\n| 256 | AES-256 | L = 15360 <br> N = 512 | k = 15360 | f = 512+ |\n\nExemples d'applications :\n\n* Cryptographie à corps finis : DSA, FFDH, MQV\n* Cryptographie à factorisation entière : RSA\n* Cryptographie à courbes elliptiques : ECDSA, EdDSA, ECDH, MQV\n\nRemarque : cette section suppose qu'aucun ordinateur quantique n'existe ; si un tel ordinateur existait, les estimations des trois dernières colonnes ne seraient plus valides.\n\n## Valeurs aléatoires\n\nCette section fournit des informations supplémentaires\nsur les valeurs aléatoires de la version 11.5.\n\n| Nom | Version/Référence | Notes | Statut |\n|:-:|:-:|:-:|:-:|\n| `/dev/random` | Linux 4.8+ [(oct. 2016)](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=818e607b57c94ade9824dad63a96c2ea6b21baf3), également présent dans iOS, Android et d'autres systèmes d'exploitation POSIX basés sur Linux. Basé sur [RFC7539](https://datatracker.ietf.org/doc/html/rfc7539) | Utilise le flux ChaCha20. Trouvé dans iOS [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/secrandomcopybytes(_:_:_:)?language=objc) et Android [`Secure Random`](https://developer.android.com/reference/java/security/SecureRandom) avec les paramètres corrects fournis pour chacun. | A |\n| `/dev/urandom` | Fichier spécial du noyau Linux pour fournir des données aléatoires | Fournit des sources d'entropie de haute qualité à partir du caractère aléatoire matériel | A |\n| `AES-CTR-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | Tel qu'utilisé dans les implémentations courantes, telles que [l'API Windows CNG `BCryptGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) définie par [`BCRYPT_RNG_ALGORITHM`](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers). | A |\n| `HMAC-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `Hash-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `getentropy()` | [OpenBSD](https://man.openbsd.org/getentropy.2), disponible sous [Linux glibc 2.25+](https://man7.org/linux/man-pages/man3/getentropy.3.html) et [macOS 10.12+](https://support.apple.com/en-gb/guide/security/seca0c73a75b/web) | Fournit des octets aléatoires sécurisés directement depuis la source d'entropie du noyau, grâce à une API simple et minimale. Plus moderne, elle évite les pièges des anciennes API. | A |\n\nLa fonction de hachage sous-jacente utilisée avec HMAC-DRBG ou Hash-DRBG doit être approuvée pour cette utilisation.\n\n## Algorithmes de chiffrement\n\nCette section fournit des informations supplémentaires\nsur les algorithmes de chiffrement V11.3.\n\nLes algorithmes de chiffrement approuvés sont classés par ordre de préférence.\n\n| Algorithmes à clé symétrique | Référence | Statut |\n|--|--|--|\n| AES-256 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| Salsa20 | [Salsa 20 specification](https://cr.yp.to/snuffle/spec.pdf) | A |\n| XChaCha20 | [XChaCha20 Draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha-03) | A |\n| XSalsa20 | [Extending the Salsa20 nonce](https://cr.yp.to/snuffle/xsalsa-20110204.pdf) | A |\n| ChaCha20 | [RFC 8439](https://www.rfc-editor.org/info/rfc8439) | A |\n| AES-192 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| AES-128 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | L |\n| 2TDEA | | D |\n| TDEA (3DES/3DEA) | | D |\n| IDEA | | D |\n| RC4 | | D |\n| Blowfish| | D |\n| ARC4 | | D |\n| DES | | D |\n\n### Modes de chiffrement AES\n\nLes chiffrements par blocs, comme AES, peuvent être utilisés avec différents modes opératoires. De nombreux modes, comme le livre de codes électronique (ECB), ne sont pas sécurisés et ne doivent pas être utilisés. Les modes Galois/Compteur (GCM) et Compteur avec chaînage de blocs et code d'authentification de message (CCM) assurent un chiffrement authentifié et doivent être utilisés dans les applications modernes.\n\nLes modes approuvés sont classés par ordre de préférence.\n\n| Mode | Authentifié | Référence | Statut | Restriction |\n|--|--|--|--|--|\n| GCM | Oui | [NIST SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A | |\n| CCM | Oui | [NIST SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A | |\n| CBC | Non | [NIST SP 800-38A](https://csrc.nist.gov/pubs/sp/800/38/a/final) | L | |\n| CCM-8 | Oui | | D | |\n| ECB | Non | | D | |\n| CFB | Non | | D | |\n| OFB | Non | | D | |\n| CTR | Non | | D | |\n\nRemarques :\n\n* Tous les messages chiffrés doivent être authentifiés. Toute utilisation du mode CBC nécessite l'association d'un algorithme MAC de hachage pour valider le message. En général, cet algorithme doit être appliqué à la méthode « Chiffrer puis hacher » (mais TLS 1.2 utilise plutôt la méthode « Hash puis chiffrer »). Si cela ne peut être garanti, le mode CBC NE DOIT PAS être utilisé. La seule application où le chiffrement sans algorithme MAC est autorisé est le chiffrement de disque.\n* Si le mode CBC est utilisé, la vérification du remplissage doit être garantie en temps constant.\n* Lors de l'utilisation de CCM-8, la balise MAC ne dispose que de 64 bits de sécurité. Ceci n'est pas conforme à l'exigence 6.2.9 qui exige au moins 128 bits de sécurité.\n* Le chiffrement de disque est considéré comme hors du périmètre de l'ASVS. Par conséquent, cette annexe ne répertorie aucune méthode approuvée pour le chiffrement de disque. Pour cette utilisation, le chiffrement sans authentification est généralement accepté et les modes XTS, XEX et LRW sont généralement utilisés.\n\n### key wrapping\n\nL'encapsulation (et le déchiffrement) d'une clé cryptographique est une méthode de protection d'une clé existante par encapsulation (c'est-à-dire par encapsulation) grâce à un mécanisme de chiffrement supplémentaire, afin que la clé d'origine ne soit pas exposée de manière visible, par exemple lors d'un transfert. Cette clé supplémentaire, utilisée pour protéger la clé d'origine, est appelée clé d'encapsulation.\n\nCette opération peut être effectuée lorsqu'il est souhaitable de protéger des clés dans des emplacements jugés non fiables, ou d'envoyer des clés sensibles sur des réseaux non fiables ou au sein d'applications.\nCependant, il est important de bien comprendre la nature (par exemple, l'identité et la finalité) de la clé d'origine avant de s'engager dans une procédure d'encapsulation/déchiffrement, car cela peut avoir des répercussions sur les systèmes/applications sources et cibles en termes de sécurité, et notamment de conformité, ce qui peut inclure des pistes d'audit de la fonction d'une clé (par exemple, la signature) ainsi qu'un stockage approprié des clés.\n\nPlus précisément, AES-256 doit être utilisé pour l'encapsulation des clés, conformément à la norme NIST SP 800-38F (https://csrc.nist.gov/pubs/sp/800/38/f/final) et en tenant compte des dispositions prospectives contre la menace quantique. Les modes de chiffrement utilisant AES sont les suivants, par ordre de préférence :\n\n| Enveloppement de clé | Référence | Statut |\n|--|--|--|\n| KW | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n| KWP | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n\nAES-192 et AES-128 PEUVENT être utilisés si le cas d'utilisation l'exige, mais leur motivation DOIT être documentée dans l'inventaire cryptographique de l'entité.\n\n### Chiffrement authentifié\n\nÀ l'exception du chiffrement du disque, les données chiffrées doivent être protégées contre toute modification non autorisée à l'aide d'un schéma de chiffrement authentifié (AE), généralement un schéma de chiffrement authentifié avec données associées (AEAD).\n\nL'application doit de préférence utiliser un schéma AEAD approuvé. Elle peut également combiner un schéma de chiffrement approuvé et un algorithme MAC approuvé avec une construction « Chiffrer puis MAC ».\n\nLa méthode « MAC puis chiffrer » est toujours autorisée pour des raisons de compatibilité avec les applications existantes. Elle est utilisée dans TLS v1.2 avec les anciennes suites de chiffrement.\n\n| Mécanisme AEAD | Référence | Statut |\n|--------------------------|---------|-----|\n|AES-GCM | [SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A |\n|AES-CCM  | [SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A |\n|ChaCha-Poly1305 | [RFC 7539](https://datatracker.ietf.org/doc/html/rfc7539) | A |\n|AEGIS-256 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128L| [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|Encrypt-then-MAC | | A |\n|MAC-then-encrypt | | L |\n\n## Fonctions de hachage\n\nCette section fournit des informations supplémentaires\nsur le hachage V11.4 et les fonctions basées sur le hachage.\n\n### Fonctions de hachage pour les cas d'utilisation généraux\n\nLe tableau suivant répertorie les fonctions de hachage approuvées pour les cas d'utilisation cryptographiques généraux, tels que les signatures numériques :\n\n* Les fonctions de hachage approuvées offrent une forte résistance aux collisions et conviennent aux applications de haute sécurité.\n* Certains de ces algorithmes offrent une forte résistance aux attaques lorsqu'ils sont utilisés avec une gestion appropriée des clés cryptographiques. Ils sont donc également approuvés pour les fonctions HMAC, KDF et RBG.\n* Les fonctions de hachage dont le résultat est inférieur à 254 bits présentent une résistance aux collisions insuffisante et ne doivent pas être utilisées pour la signature numérique ou d'autres applications nécessitant une résistance aux collisions. Pour d'autres utilisations, elles peuvent être utilisées à des fins de compatibilité et de vérification UNIQUEMENT avec les systèmes existants, mais ne doivent pas être utilisées dans les nouvelles conceptions.\n\n| Fonction de hachage | Référence | Statut | Restrictions |\n| -------------- | ------------------------------------------------------------- |--|--|\n| SHA3-512 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-384 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-384 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512/256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA-256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHAKE256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| BLAKE2s | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE2b | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE3 | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf) | A | |\n| SHA-224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Ne convient pas aux signatures numériques HMAC, KDF, RBG |\n| SHA-512/224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Ne convient pas aux signatures numériques HMAC, KDF, RBG |\n| SHA3-224 | [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | L | Ne convient pas aux signatures numériques HMAC, KDF, RBG |\n| SHA-1 | [RFC 3174](https://www.rfc-editor.org/info/rfc3174) et [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | L | Ne convient pas aux signatures numériques HMAC, KDF, RBG |\n| CRC (toute longueur) |  | D |  |\n| MD4 | [RFC 1320](https://www.rfc-editor.org/info/rfc1320) | D | |\n| MD5 | [RFC 1321](https://www.rfc-editor.org/info/rfc1321) | D | |\n\n### Fonctions de hachage pour le stockage des mots de passe\n\nPour un hachage sécurisé des mots de passe, des fonctions de hachage dédiées doivent être utilisées. Ces algorithmes de hachage lent atténuent les attaques par force brute et par dictionnaire en augmentant la difficulté de calcul du craquage des mots de passe.\n\n| KDF | Référence | Paramètres requis | Statut |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| bcrypt | [A Future-Adaptable Password Scheme](https://www.researchgate.net/publication/2519476_A_Future-Adaptable_Password_Scheme) | coût ≥ 10 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 1,300,000 | L |\n\nLes fonctions de dérivation de clés basées sur des mots de passe approuvées peuvent être utilisées pour le stockage des mots de passe.\n\n## Fonctions de dérivations de clés (KDFs)\n\n### Fonctions de dérivations de clés générales\n\n| KDF              | Référence                                                                                     | Statut |\n| ---------------- | --------------------------------------------------------------------------------------------- | ------ |\n| HKDF             | [RFC 5869](https://www.rfc-editor.org/info/rfc5869)                                           | A      |\n| TLS 1.2 PRF      | [RFC 5248](https://www.rfc-editor.org/info/rfc5248)                                           | L      |\n| KDFs à base de MD5 | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                           | D      |\n| KDFs à base de SHA-1 | [RFC 3174](https://www.rfc-editor.org/info/rfc3174), [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | D      |\n\n### Fonctions de dérivations de clés à base de mot de passe\n\n| KDF | Référence | Paramètres requis | Statut |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | itérations ≥ 1,300,000 | L |\n\n## Mécanismes d'échange de clés\n\nCette section fournit des informations complémentaires\nsur la cryptographie à clé publique V11.6.\n\n### Systèmes KEX\n\nUne force de sécurité de 112 bits ou plus DOIT être garantie pour tous les méthodes d'échange de clés, et leur mise en œuvre DOIT suivre les choix de paramètres dans le tableau suivant.\n\n| Schéma | Paramètres du domaine | Confidentialité persistante | Statut |\n|--|--|--|--|\n| Diffie-Hellman à corps finis (FFDH) | L >= 3072 et N >= 256 | Oui | A |\n| Courbe elliptique Diffie-Hellman (ECDH) | f >= 256-383 | Oui | A |\n| Transport de clés chiffrées avec RSA-PKCS#1 v1.5 | | Non | D |\n\nOù les paramètres suivants sont :\n\n* k est la taille de la clé RSA.\n* L est la taille de la clé publique et N est la taille de la clé privée pour la cryptographie à corps finis.\n* f est la plage de tailles de clés pour ECC.\n\nToute nouvelle implémentation NE DOIT PAS utiliser de schéma non conforme aux normes [NIST SP 800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r3/final) et [B](https://csrc.nist.gov/pubs/sp/800/56/b/r2/final) et [NIST SP 800-77](https://csrc.nist.gov/pubs/sp/800/77/r1/final). Plus précisément, IKEv1 NE DOIT PAS être utilisé en production.\n\n### Groupes Diffie-Hellman\n\nLes groupes suivants sont approuvés pour la mise en œuvre de l'échange de clés Diffie-Hellman. Les niveaux de sécurité sont décrits dans la norme NIST SP 800-56A (https://csrc.nist.gov/pubs/sp/800/56/a/r3/final), l'annexe D et la norme NIST SP 800-57, partie 1, révision 5 (https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Groupe           | Statut |\n|------------------|--------|\n| P-224, secp224r1 | A      |\n| P-256, secp256r1 | A      |\n| P-384, secp384r1 | A      |\n| P-521, secp521r1 | A      |\n| K-233, sect233k1 | A      |\n| K-283, sect283k1 | A      |\n| K-409, sect409k1 | A      |\n| K-571, sect571k1 | A      |\n| B-233, sect233r1 | A      |\n| B-283, sect283r1 | A      |\n| B-409, sect409r1 | A      |\n| B-571, sect571r1 | A      |\n| Curve448         | A      |\n| Curve25519       | A      |\n| MODP-2048        | A      |\n| MODP-3072        | A      |\n| MODP-4096        | A      |\n| MODP-6144        | A      |\n| MODP-8192        | A      |\n| ffdhe2048        | A      |\n| ffdhe3072        | A      |\n| ffdhe4096        | A      |\n| ffdhe6144        | A      |\n| ffdhe8192        | A      |\n\n## Codes d'authentification des messages (MAC)\n\nLes codes d'authentification de message (MAC) sont des structures cryptographiques permettant de vérifier l'intégrité et l'authenticité d'un message. Un MAC prend en entrée un message et une clé secrète et génère une étiquette de taille fixe (la valeur MAC). Les MAC sont largement utilisés dans les protocoles de communication sécurisés (par exemple, TLS/SSL) pour garantir l'authenticité et l'intégrité des messages échangés entre les parties.\n\n| Algorithme MAC | Référence | Statut | Restrictions |\n| --------------| ----------------------------------------------------------------------------------------- | -------| ------------ |\n| HMAC-SHA-256  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) et [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-384  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) et [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-512  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) et [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| KMAC128       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| KMAC256       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| BLAKE3 (mode keyed_hash) | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf)  | A | |\n| AES-CMAC      | [RFC 4493](https://datatracker.ietf.org/doc/html/rfc4493) et [NIST SP 800-38B](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf) | A | |\n| AES-GMAC      | [NIST SP 800-38D](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)            | A | |\n| Poly1305-AES  | [The Poly1305-AES message-authentication code](https://cr.yp.to/mac/poly1305-20050329.pdf)                  | A | |\n| HMAC-SHA-1    | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) et [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | L | |\n| HMAC-MD5      | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                | D      | |\n\n## Signatures numériques\n\nLes schémas de signature DOIVENT utiliser des tailles de clés et des paramètres approuvés conformément à la norme [NIST SP 800-57 Partie 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Algorithme de signature        | Référence                                                  | Statut |\n| ------------------------------ | ---------------------------------------------------------- | ------ |\n| EdDSA (Ed25519, Ed448)         | [RFC 8032](https://www.rfc-editor.org/info/rfc8032)        | A      |\n| XEdDSA (Curve25519, Curve448)  | [XEdDSA](https://signal.org/docs/specifications/xeddsa/)   | A      |\n| ECDSA (P-256, P-384, P-521)    | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-5/final)  | A      |\n| RSA-RSSA-PSS                   | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | A      |\n| RSA-SSA-PKCS#1 v1.5            | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | D      |\n| DSA (n'importe quelle taille de clé)             | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-4/final)  | D      |\n\n## Normes de chiffrement post-quantique\n\nLes mises en œuvre de la cryptographie post-quantique (PQC) doivent respecter les normes [FIPS-203](https://csrc.nist.gov/pubs/fips/203/ipd), [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd) et [FIPS-205](https://csrc.nist.gov/pubs/fips/205/ipd). À l'heure actuelle, il n'existe pas beaucoup d'exemples de codes renforcés ou d'implémentations de référence disponibles pour ces normes. Pour plus de détails, voir [l'annonce par le NIST des trois premières normes de chiffrement post-quantique finalisées (août 2024)](https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards).\n\nLa méthode d'accord de clé TLS hybride post-quantique proposée [mlkem768x25519](https://datatracker.ietf.org/doc/draft-kwiatkowski-tls-ecdhe-mlkem/03/) est prise en charge par les principaux navigateurs tels que [Firefox version 132](https://www.mozilla.org/en-US/firefox/132.0/releasenotes/) et [Chrome version 131](https://security.googleblog.com/2024/09/a-new-path-for-kyber-on-web.html). Elle peut être utilisée dans des environnements de test cryptographique ou lorsqu'elle est disponible dans des bibliothèques approuvées par l'industrie ou le gouvernement.\n", "timestamp": "2025-10-24T11:40:11.883272"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x93-Appendix-D_Recommendations.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x93-Appendix-D_Recommendations.md", "content": "# Annexe D : Recommandations\n\n## Introduction\n\nLors de la préparation de la version 5.0 de la norme de vérification de la sécurité des applications (ASVS), il est apparu clairement que plusieurs éléments, existants ou nouvellement proposés, ne devaient pas être inclus comme exigences dans la version 5.0. Cela peut s'expliquer par le fait qu'ils n'entraient pas dans le champ d'application de l'ASVS selon la définition de la version 5.0, ou bien par le fait que, malgré leur pertinence, ils ne pouvaient être rendus obligatoires.\n\nNe voulant pas perdre tous ces éléments entièrement, certains ont été capturés dans cette annexe.\n\n## Mécanismes de périmètre recommandés\n\nLes éléments suivants sont concernés par ASVS. Ils ne devraient pas être rendus obligatoires, mais il est fortement recommandé de les prendre en compte dans le cadre d'une application sécurisée.\n\n* Un indicateur de sécurité des mots de passe devrait être fourni pour aider les utilisateurs à définir un mot de passe plus fort.\n* Créez un fichier security.txt accessible au public à la racine ou dans le répertoire .well-known de l'application, définissant clairement un lien ou une adresse e-mail permettant de contacter les propriétaires en cas de problème de sécurité.\n* La validation des entrées côté client devrait être appliquée en plus de la validation au niveau d'une couche de service de confiance, car cela permet de détecter si un utilisateur a contourné les contrôles côté client pour tenter d'attaquer l'application.\n* Empêchez l'affichage de pages sensibles et accessibles accidentellement dans les moteurs de recherche à l'aide d'un fichier robots.txt, de l'en-tête de réponse X-Robots-Tag ou d'une balise méta HTML robots.\n* Lorsque vous utilisez GraphQL, implémentez la logique d'autorisation au niveau de la couche logique métier plutôt que dans la couche GraphQL ou du résolveur afin d'éviter de gérer l'autorisation sur chaque interface distincte.\n\nRéférences :\n\n* [Plus d'informations sur security.txt, y compris un lien vers la RFC](https://securitytxt.org/)\n\n## Principes de sécurité des logiciels\n\nLes éléments suivants figuraient déjà dans ASVS, mais ne constituent pas de véritables exigences. Il s'agit plutôt de principes à prendre en compte lors de la mise en œuvre de contrôles de sécurité, dont le respect permettra de renforcer la robustesse. Parmi ceux-ci :\n\n* Les contrôles de sécurité doivent être centralisés, simples (économie de conception), vérifiables et réutilisables. Cela permet d'éviter les contrôles dupliqués, manquants ou inefficaces.\n* Dans la mesure du possible, utilisez des implémentations de contrôle de sécurité préalablement écrites et bien contrôlées plutôt que de vous fier à la mise en œuvre de contrôles à partir de zéro.\n* Idéalement, un mécanisme de contrôle d'accès unique devrait être utilisé pour accéder aux données et ressources protégées. Toutes les requêtes devraient transiter par ce mécanisme unique afin d'éviter les copier-coller ou les chemins alternatifs non sécurisés.\n* Le contrôle d'accès basé sur les attributs ou les fonctionnalités est un modèle recommandé : le code vérifie l'autorisation de l'utilisateur pour une fonctionnalité ou un élément de données, plutôt que simplement son rôle. Les autorisations doivent toujours être attribuées à l'aide de rôles.\n\n## Processus de sécurité des logiciels\n\nPlusieurs processus de sécurité ont été supprimés d'ASVS 5.0, mais restent pertinents. Le projet OWASP SAMM pourrait être une bonne source d'inspiration pour une mise en œuvre efficace de ces processus. Parmi les éléments précédemment présents dans ASVS, on peut citer :\n\n* Vérifier l'utilisation d'un cycle de vie sécurisé pour le développement de logiciels qui prend en compte la sécurité à tous les stades du développement.\n* Vérifier l'utilisation de la modélisation des menaces pour chaque changement de conception ou planification de sprint afin d'identifier les menaces, de planifier les contre-mesures, de faciliter les réponses appropriées aux risques et d'orienter les tests de sécurité.\n* Vérifier que toutes les histoires d'utilisateurs et les caractéristiques contiennent des contraintes de sécurité fonctionnelles, telles que \"En tant qu'utilisateur, je devrais être en mesure de voir et de modifier mon profil. Je ne dois pas pouvoir consulter ou modifier le profil de quelqu'un d'autre\"\n* Vérifier la disponibilité d'une liste de contrôle de codage sécurisé, d'exigences de sécurité, de lignes directrices ou d'une politique pour tous les développeurs et les testeurs.\n* Vérifier l'existence d'un processus permanent visant à garantir que le code source de l'application est exempt de portes dérobées, de codes malveillants (attaques par salami, bombes logiques, bombes à retardement) et de caractéristiques non documentées ou cachées (œufs de Pâques, outils de débogage non sécurisés). Il n'est pas possible de se conformer à cette section sans un accès complet au code source, y compris aux bibliothèques tierces, et cela ne convient donc probablement qu'aux applications exigeant les niveaux de sécurité les plus élevés.\n* Vérifier que des mécanismes sont en place pour détecter les dérives de configuration dans les environnements déployés et y répondre. Il peut s'agir de l'utilisation d'une infrastructure immuable, d'un redéploiement automatisé à partir d'une base sécurisée ou d'outils de détection de dérive qui comparent l'état actuel aux configurations approuvées.\n* Vérifier que le durcissement de la configuration est effectué sur tous les produits tiers, les bibliothèques,\n\nRéférences:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/securityengineering/sdl/)\n", "timestamp": "2025-10-24T11:40:11.995754"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/fr/0x94-Appendix-E_Contributors.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/fr/0x94-Appendix-E_Contributors.md", "content": "# Appendix E - Contributeurs\n\nNous remercions les personnes suivantes pour leurs contributions, leurs commentaires et leurs demandes d'extension depuis la publication de ASVS 4.0.0.\n\nSi vous avez connaissance d'erreurs ou si vous souhaitez que votre nom apparaisse différemment, merci de nous le faire savoir.\n\n| | | | |\n|---|---|---|---|\n| Johan Sydseter ([sydseter](https://github.com/sydseter)) | luis servin ([lfservin](https://github.com/lfservin)) | Oleksii Dovydkov ([oleksiidov](https://github.com/oleksiidov)) | IZUKA Masahiro ([maizuka](https://github.com/maizuka))  |\n| James Sulinski ([jsulinski](https://github.com/jsulinski)) | Eli Saad ([ThunderSon](https://github.com/ThunderSon)) | [kkshitish9](https://github.com/kkshitish9) | Andrew van der Stock ([vanderaj](https://github.com/vanderaj))  |\n| Rick M ([kingthorin](https://github.com/kingthorin)) | Bankde Eakasit ([Bankde](https://github.com/Bankde)) | Michael Gargiullo ([mgargiullo](https://github.com/mgargiullo)) | Raphael Dunant ([Racater](https://github.com/Racater))  |\n| Cesar Kohl ([cesarkohl](https://github.com/cesarkohl)) | [inaz0](https://github.com/inaz0) | Joerg Bruenner ([JoergBruenner](https://github.com/JoergBruenner)) | David Deatherage ([securitydave](https://github.com/securitydave))  |\n| John Carroll  ([yosignals](https://github.com/yosignals)) | Jim Fenton ([jimfenton](https://github.com/jimfenton)) | Matteo Pace ([M4tteoP](https://github.com/M4tteoP)) | Sebastien gioria ([SPoint42](https://github.com/SPoint42))  |\n| Steven van der Baan ([vdbaan](https://github.com/vdbaan)) | Jeremy Bonghwan Choi ([jeremychoi](https://github.com/jeremychoi)) | [craig-shony](https://github.com/craig-shony) | Riccardo Sirigu ([ricsirigu](https://github.com/ricsirigu))  |\n| Tomasz Wrobel ([tw2as](https://github.com/tw2as)) | Alena Dubeshko ([belalena](https://github.com/belalena)) | Rafael Green ([RafaelGreen1](https://github.com/RafaelGreen1)) | [mjang-cobalt](https://github.com/mjang-cobalt)  |\n| [clallier94](https://github.com/clallier94) | Kevin W. Wall ([kwwall](https://github.com/kwwall)) | Jordan Sherman ([jsherm-fwdsec](https://github.com/jsherm-fwdsec) / [deleterepo](https://github.com/deleterepo)) | Ingo Rauner ([ingo-rauner](https://github.com/ingo-rauner))  |\n| Dirk Wetter ([drwetter](https://github.com/drwetter)) | Moshe Zioni ([moshe-apiiro](https://github.com/moshe-apiiro)) | Patrick Dwyer ([coderpatros](https://github.com/coderpatros)) | David Clarke ([davidclarke-au](https://github.com/davidclarke-au))  |\n| Takaharu Ogasa ([takaharuogasa](https://github.com/takaharuogasa)) | Arkadii Yakovets ([arkid15r](https://github.com/arkid15r)) | Motoyasu Saburi ([motoyasu-saburi](https://github.com/motoyasu-saburi)) | [leirn](https://github.com/leirn)  |\n| [wet-certitude](https://github.com/wet-certitude) | [timhemel](https://github.com/timhemel) | RL Thornton ([thornshadow99](https://github.com/thornshadow99)) | Thomas Bandt ([aspnetde](https://github.com/aspnetde))  |\n| Roel Storms ([roelstorms](https://github.com/roelstorms)) | Jeroen Willemsen ([commjoen](https://github.com/commjoen)) | [anonymous-31](https://github.com/anonymous-31) | Kamran Saifullah ([deFr0ggy](https://github.com/deFr0ggy))  |\n| Steve Springett ([stevespringett](https://github.com/stevespringett)) | Spyros ([northdpole](https://github.com/northdpole)) | Hans Herrera ([hansphp](https://github.com/hansphp)) | [Marx314](https://github.com/Marx314)  |\n| [CarlosAllendes](https://github.com/CarlosAllendes) | Yonah Russ ([yruss972](https://github.com/yruss972)) | Sander Maijers ([sanmai-NL](https://github.com/sanmai-NL)) | Luboš Bretschneider  ([bretik](https://github.com/bretik))  |\n| Eva Sarafianou ([esarafianou](https://github.com/esarafianou)) | Ata Seren [ataseren](https://github.com/ataseren) | Steve Thomas ([Sc00bz](https://github.com/Sc00bz)) | Dominique RIGHETTO ([righettod](https://github.com/righettod))  |\n| Steven van der Baan ([svdb-ncc](https://github.com/svdb-ncc)) | Michael Vacarella ([Aif4thah](https://github.com/Aif4thah)) | Tonimir Kisasondi ([tkisason](https://github.com/tkisason)) | Stefan Streichsbier ([streichsbaer](https://github.com/streichsbaer))  |\n| [hi-unc1e](https://github.com/hi-unc1e) | sb3k ([starbuck3000](https://github.com/starbuck3000)) | [mario-platt](https://github.com/mario-platt) | Devdatta Akhawe ([devd](https://github.com/devd))  |\n| Michael Gissing ([scolytus](https://github.com/scolytus)) | Jet Anderson ([thatsjet](https://github.com/thatsjet)) | Dave Wichers ([davewichers](https://github.com/davewichers)) | Jonny Schnittger ([JonnySchnittger](https://github.com/JonnySchnittger))  |\n| Silvia Väli ([silviavali](https://github.com/silviavali)) | [jackgates73](https://github.com/jackgates73) | [1songb1rd](https://github.com/1songb1rd) | Timur - ([timurozkul](https://github.com/timurozkul))  |\n| Gareth Heyes ([hackvertor](https://github.com/hackvertor)) | [appills](https://github.com/appills) | [suvikaartinen](https://github.com/suvikaartinen) | chaals ([chaals](https://github.com/chaals))  |\n| DanielPharos ([AtlasHackert](https://github.com/AtlasHackert)) | will Farrell ([willfarrell](https://github.com/willfarrell)) | Alina Vasiljeva ([avasiljeva](https://github.com/avasiljeva)) | Paul McCann ([ismisepaul](https://github.com/ismisepaul))  |\n| Sage ([SajjadPourali](https://github.com/SajjadPourali)) | [rbsec](https://github.com/rbsec) | Benedikt Bauer ([mastacheata](https://github.com/mastacheata)) | James Jardine ([jamesjardine](https://github.com/jamesjardine))  |\n| Mark Burnett ([m8urnett](https://github.com/m8urnett)) | [dschwarz91](https://github.com/dschwarz91) | Cyber-AppSec ([Cyber-AppSec](https://github.com/Cyber-AppSec)) | [Tib3rius](https://github.com/Tib3rius)  |\n| BitnessWise ([bitnesswise](https://github.com/bitnesswise)) | damienbod ([damienbod](https://github.com/damienbod)) | Jared Meit ([jmeit-fwdsec](https://github.com/jmeit-fwdsec)) | Stefan Seelmann ([sseelmann](https://github.com/sseelmann))  |\n| Brendan O'Connor ([ussjoin](https://github.com/ussjoin)) | Andrei Titov ([andrettv](https://github.com/andrettv)) | Hans-Petter Fjeld ([atluxity](https://github.com/atluxity)) | [markehack](https://github.com/markehack)  |\n| Neil Madden ([NeilMadden](https://github.com/NeilMadden)) | Michael Geramb ([mgeramb](https://github.com/mgeramb)) | Osama Elnaggar ([ossie-git](https://github.com/ossie-git)) | [mackowski](https://github.com/mackowski)  |\n| Ravi Balla ([raviballa](https://github.com/raviballa)) | Hazana ([hazanasec](https://github.com/hazanasec)) | David Means ([dmeans82](https://github.com/dmeans82)) | Alexander Stein ([tohch4](https://github.com/tohch4))  |\n| BaeSenseii ([baesenseii](https://github.com/baesenseii)) | Vincent De Schutter ([VincentDS](https://github.com/VincentDS)) | S Bani ([sbani](https://github.com/sbani)) | Mitsuaki Akiyama ([mak1yama](https://github.com/mak1yama))  |\n| Christopher Loessl ([hashier](https://github.com/hashier)) | [victorxm](https://github.com/victorxm) | Michal Rada ([michalradacz](https://github.com/michalradacz)) | Veeresh Devireddy ([drveresh](https://github.com/drveresh))  |\n| [MaknaSEO](https://github.com/MaknaSEO) | [darkzero2022](https://github.com/darkzero2022) | Liam ([LiamDobbelaere](https://github.com/LiamDobbelaere)) | Frank Denis ([jedisct1](https://github.com/jedisct1))  |\n| Otto Sulin ([ottosulin](https://github.com/ottosulin)) | [carllaw6885](https://github.com/carllaw6885) | Anders Johan Holmefjord ([aholmis](https://github.com/aholmis)) | Richard Fritsch ([rfricz](https://github.com/rfricz))  |\n| [mesutgungor](https://github.com/mesutgungor) | Scott Helme ([ScottHelme](https://github.com/ScottHelme)) | Carlo Reggiani ([carloreggiani](https://github.com/carloreggiani)) | Suyash Srivastava ([suyash5053](https://github.com/suyash5053))  |\n| Mark Potter ([markonweb](https://github.com/markonweb)) | Arjan Lamers ([alamers](https://github.com/alamers)) | Gøran Breivik ([gobrtg](https://github.com/gobrtg)) | [flo-blg](https://github.com/flo-blg)  |\n| Guillaume Déflache ([guillaume-d](https://github.com/guillaume-d)) | Toufik Airane ([toufik-airane](https://github.com/toufik-airane)) | Keith Hoodlet ([securingdev](https://github.com/securingdev)) | Sinner ([SoftwareSinner](https://github.com/SoftwareSinner))  |\n| [iloving](https://github.com/iloving) | Jeroen Beckers ([TheDauntless](https://github.com/TheDauntless)) | Joubin Jabbari ([joubin](https://github.com/joubin)) | yu fujioka ([fujiokayu](https://github.com/fujiokayu))  |\n| execjosh ([execjosh](https://github.com/execjosh)) | Alicja Kario ([tomato42](https://github.com/tomato42)) | Sidney Ribeiro ([srjsoftware](https://github.com/srjsoftware)) | Gabriel Marquet ([Gby56](https://github.com/Gby56))  |\n| Drew Schulz ([drschulz](https://github.com/drschulz)) | [bedirhan](https://github.com/bedirhan) | [muralito](https://github.com/muralito) | Ronnie Flathers ([ropnop](https://github.com/ropnop))  |\n| Philippe De Ryck ([philippederyck](https://github.com/philippederyck)) | Malte ([mal33](https://github.com/mal33)) | [MazeOfThoughts](https://github.com/MazeOfThoughts) | Andreas Falk ([andifalk](https://github.com/andifalk))  |\n| Javi ([javixeneize](https://github.com/javixeneize)) | Daniel Hahn ([averell23](https://github.com/averell23)) | [borislav-c](https://github.com/borislav-c) | Robin Wood ([digininja](https://github.com/digininja))  |\n| [miro2ns](https://github.com/miro2ns) | Jan Dockx ([jandockx](https://github.com/jandockx)) | [vipinsaini434](https://github.com/vipinsaini434) | [priyanshukumar397](https://github.com/priyanshukumar397)  |\n| Nat Sakimura ([sakimura](https://github.com/sakimura)) | Benjamin Häublein ([BenjaminHae](https://github.com/BenjaminHae)) | [unknown-user-from](https://github.com/unknown-user-from) | Ali Ramazan TAŞDELEN ([alitasdln](https://github.com/alitasdln))  |\n| Pedro Escaleira ([oEscal](https://github.com/oEscal)) | Josh ([josh-hemphill](https://github.com/josh-hemphill)) | Tim Würtele ([SECtim](https://github.com/SECtim)) | AviD ([avidouglen](https://github.com/avidouglen))  |\n| SheHacksPurple ([shehackspurple](https://github.com/shehackspurple)) | [fcerullo-cycubix](https://github.com/fcerullo-cycubix) | Hector Eryx Paredes Camacho ([heryxpc](https://github.com/heryxpc)) | Irene Michlin ([irene221b](https://github.com/irene221b))  |\n| Jonah Y-M ([TG-Techie](https://github.com/TG-Techie)) | Dhiraj Bahroos ([bahroos](https://github.com/bahroos)) | Jef Meijvis ([jefmeijvis](https://github.com/jefmeijvis)) | [IzmaDoesItbeta](https://github.com/IzmaDoesItbeta)  |\n| Abdessamad TEMMAR ([TmmmmmR](https://github.com/TmmmmmR)) | [sectroyer](https://github.com/sectroyer) | Soh Satoh ([sohsatoh](https://github.com/sohsatoh)) | [regoravalaz](https://github.com/regoravalaz)  |\n| james-t ([james-bitherder](https://github.com/james-bitherder)) | Aram Hovsepyan ([aramhovsepyan](https://github.com/aramhovsepyan)) | [JaimeGomezGarciaSan](https://github.com/JaimeGomezGarciaSan) | [ValdiGit01](https://github.com/ValdiGit01)  |\n| iwatachan ([ishowta](https://github.com/ishowta)) | Vinod Anandan ([VinodAnandan](https://github.com/VinodAnandan)) | Kevin Kien ([KevinKien](https://github.com/KevinKien)) | [paul-williamson-swoop](https://github.com/paul-williamson-swoop)  |\n| [endergzr](https://github.com/endergzr) | Radhwan Alshamamri ([Rado0z](https://github.com/Rado0z)) | Grant Ongers ([rewtd](https://github.com/rewtd)) | Cure53 ([cure53](https://github.com/cure53))  |\n| [AliR2Linux](https://github.com/AliR2Linux) | Ads Dawson ([GangGreenTemperTatum](https://github.com/GangGreenTemperTatum)) | William Reyor ([BillReyor](https://github.com/BillReyor)) | gabe ([gcrow](https://github.com/gcrow))  |\n| [mascotter](https://github.com/mascotter) | [luissaiz](https://github.com/luissaiz) | Suren Manukyan ([vx-sec](https://github.com/vx-sec)) | Piotr Gliźniewicz  ([pglizniewicz](https://github.com/pglizniewicz))  |\n| Tadeusz Wachowski ([tadeuszwachowski](https://github.com/tadeuszwachowski)) | Nasir aka Nate ([andesec](https://github.com/andesec)) | [settantasette](https://github.com/settantasette) | Lars Haulin ([LarsH](https://github.com/LarsH))  |\n| Terence Eden ([edent](https://github.com/edent)) | [JasmineScholz](https://github.com/JasmineScholz) | Arun Sivadasan ([teavanist](https://github.com/teavanist)) | Yusuf GÜR ([yusuffgur](https://github.com/yusuffgur))  |\n| Troy Marshall ([troymarshall](https://github.com/troymarshall)) | Tanner Prynn ([tprynn](https://github.com/tprynn)) | Nick K. ([nickific](https://github.com/nickific)) | [raoul361](https://github.com/raoul361)  |\n| Azeem Ilyas ([TheAxZim](https://github.com/TheAxZim)) | Evo Stamatov ([avioli](https://github.com/avioli)) | Tim Potter ([timpotter87](https://github.com/timpotter87)) | Gavin Ray ([GavinRay97](https://github.com/GavinRay97))  |\n| monis ([demideus](https://github.com/demideus)) | Marcin Hoppe ([MarcinHoppe](https://github.com/MarcinHoppe)) | Grambulf ([ramshazar](https://github.com/ramshazar)) | Jordan Pike ([computersarebad](https://github.com/computersarebad))  |\n| Jason Rogers ([jason-invision](https://github.com/jason-invision)) | Ben Hall ([benbhall](https://github.com/benbhall)) | JamesPoppyCock ([jamesly123](https://github.com/jamesly123)) | WhiteHackLabs ([whitehacklabs](https://github.com/whitehacklabs))  |\n| Alex Gaynor ([alex](https://github.com/alex)) | Filip van Laenen ([filipvanlaenen](https://github.com/filipvanlaenen)) | [jeurgen](https://github.com/jeurgen) | [GraoMelo](https://github.com/GraoMelo)  |\n| Andreas Kurtz ([ay-kay](https://github.com/ay-kay)) | Tom Tervoort ([TomTervoort](https://github.com/TomTervoort)) | old man ([deveras](https://github.com/deveras)) | Marco Schnüriger ([marcortw](https://github.com/marcortw))  |\n| [stiiin](https://github.com/stiiin) | infoseclearn ([teaminfoseclearn](https://github.com/teaminfoseclearn)) | [hljupkij](https://github.com/hljupkij) | Noe ([nmarher](https://github.com/nmarher))  |\n| Lyz ([lyz-code](https://github.com/lyz-code)) | Martin Riedel ([mrtnrdl](https://github.com/mrtnrdl)) | KIM Jaesuck ([tcaesvk](https://github.com/tcaesvk)) | Barbara Schachner ([bschach](https://github.com/bschach))  |\n| René Reuter ([AresSec](https://github.com/AresSec)) | [carhackpils](https://github.com/carhackpils) | Tyler ([tyler2cr](https://github.com/tyler2cr)) | Hugo ([hasousa](https://github.com/hasousa))  |\n| Wouter Bloeyaert ([Someniak](https://github.com/Someniak)) | Mark de Rijk ([markderijkinfosec](https://github.com/markderijkinfosec)) | Ramin ([picohub](https://github.com/picohub)) | Philip D. Turner ([philipdturner](https://github.com/philipdturner))  |\n| Will Chatham ([willc](https://github.com/willc))  | | | |\n", "timestamp": "2025-10-24T11:40:12.068703"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/mappings/README.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/mappings/README.md", "content": "# Mapping files\n\nVersions:\n\n* v4.0.3 - latest v4 release\n* v5.0.be - \"bleeding edge\" version for v5.0 development, where all v4.0 structure and numbers were kept directly or as placeholders\n* v5.0 - v5.0 after re-structuring and re-numbering everything\n\nMapping files:\n\n* `mapping_v5.0.be_to_v5.0.0.yml` - from v5.0.be to v5.0.0\n* `mapping_v4.0.3_to_v5.0.0.yml` - from v4.0.3 to v5.0.0\n* `mapping_v5.0.0_to_v4.0.3.yml` - from v5.0.0 to v4.0.3\n\nTemporary mapping files before re-numbering everything:\n\n* `mapping_v4.0.3_to_v5.0.be.yml` - from v4.0.3 to v5.0.be\n* `mapping_v5.0.be_to_v4.0.3.yml` - from v5.0.be to v4.0.3\n\nJust-in-case exports before deleted from v5.0.be:\n\n* `nist.md` - v5.0.be requirement ids and mapping to NIST 800-63B identifiers before those were removed\n* `v5.0.be_cwe_mapping.json` - v5.0.be requirement ids and mapping to CWE identifiers before those were removed\n", "timestamp": "2025-10-24T11:40:12.717874"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/mappings/nist.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/mappings/nist.md", "content": "# Mapping requirements to NIST (07-Nov-2024)\n\n| # | [NIST §](https://pages.nist.gov/800-63-3/sp800-63b.html) |\n| :---: | :---: |\n| **2.1.1** | 5.1.1.2 |\n| **2.1.2** | 5.1.1.2 |\n| **2.1.3** | 5.1.1.2 |\n| **2.1.4** |  |\n| **2.1.5** | 5.1.1.2 |\n| **2.1.6** | 5.1.1.2 |\n| **2.1.7** | 5.1.1.2 |\n| **2.1.8** |  |\n| **2.1.9** | 5.1.1.2 |\n| **2.1.10** | 5.1.1.2 |\n| **2.1.11** | 5.1.1.2 |\n| **2.1.12** | 5.1.1.2 |\n| **2.1.13** | 5.1.1.2 |\n| **2.1.14** | 5.1.1.2 |\n| **2.2.1** | 5.2.2 |\n| **2.2.2** |  |\n| **2.2.3** | 6.1.2 |\n| **2.2.4** | 4.3.1 |\n| **2.2.5** |  |\n| **2.2.6** |  |\n| **2.2.7** |  |\n| **2.2.8** |  |\n| **2.2.9** | 4.2.1 |\n| **2.2.10** |  |\n| **2.2.11** |  |\n| **2.3.1** | 5.1.1.2 / A.3 |\n| **2.3.2** |  |\n| **2.3.3** | 6.1.4 |\n| **2.3.4** |  |\n| **2.4.1** |  |\n| **2.4.2** |  |\n| **2.4.3** |  |\n| **2.4.4** |  |\n| **2.4.5** |  |\n| **2.4.6** |  |\n| **2.5.1** |  |\n| **2.5.2** | 5.1.1.2 |\n| **2.5.3** |  |\n| **2.5.4** |  |\n| **2.5.5** |  |\n| **2.5.6** | 5.1.1.2 |\n| **2.5.7** | 6.1.2.3 |\n| **2.6.1** | 5.1.2.2 |\n| **2.6.2** | 5.1.2.2 |\n| **2.6.3** | 5.1.2.2 |\n| **2.6.4** | 5.1.2.1 |\n| **2.7.1** | 5.1.3.2, 5.1.3.3, 5.2.10 |\n| **2.7.2** | 5.1.3.2 |\n| **2.7.3** | 5.1.3.2 |\n| **2.7.4** | 5.1.3.2 |\n| **2.7.5** |  |\n| **2.7.6** | 5.1.3.2 |\n| **2.7.7** | 5.1.3.2 |\n| **2.7.8** |  |\n| **2.8.1** | 5.1.4.2 / 5.1.5.2 |\n| **2.8.2** | 5.1.4.2 / 5.1.5.2 |\n| **2.8.3** | 5.1.4.2 / 5.1.5.2 |\n| **2.8.4** | 5.1.4.2 / 5.1.5.2 |\n| **2.8.5** |  |\n| **2.8.6** | 5.2.1 |\n| **2.8.7** | 5.2.3 |\n| **2.8.8** | 5.1.4.2 / 5.1.5.2 |\n| **2.9.1** | 5.1.7.2 |\n| **2.9.2** | 5.1.7.2 |\n| **2.9.3** | 5.1.7.2 |\n| **2.10.1** |  |\n| **2.10.2** |  |\n| **2.10.3** |  |\n| **2.10.4** |  |\n| **2.11.1** |  |\n| **2.11.2** |  |\n| **2.11.3** |  |\n| **3.1.1** |  |\n| **3.1.2** |  |\n| **3.1.3** | 7.1 |\n| **3.1.4** |  |\n| **3.2.1** | 7.1 |\n| **3.2.2** |  |\n| **3.2.3** |  |\n| **3.2.4** |  |\n| **3.2.5** |  |\n| **3.3.1** |  |\n| **3.3.2** |  |\n| **3.3.3** |  |\n| **3.3.4** |  |\n| **3.3.5** | 7.2 |\n| **3.4.1** | 7.1.1 |\n| **3.4.2** | 7.1.1 |\n| **3.4.3** | 7.1.1 |\n| **3.4.4** | 7.1.1 |\n| **3.4.5** |  |\n| **3.5.1** | 7.1.2 |\n| **3.5.2** |  |\n| **3.5.3** |  |\n| **3.5.4** |  |\n| **3.5.5** |  |\n| **3.5.6** |  |\n| **3.6.1** | 7.2.1 |\n| **3.6.2** |  |\n| **3.7.1** |  |\n| **3.7.2** |  |\n| **3.8.1** | 7.1 |\n| **3.8.2** |  |\n| **3.8.3** |  |\n| **3.8.4** |  |\n| **3.8.5** | 7.1 |\n", "timestamp": "2025-10-24T11:40:12.787676"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x01-Frontispiece.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x01-Frontispiece.md", "content": "# Фронтиспис\n\n## О стандарте\n\nСтандарт верификации требований к безопасности приложений — это перечень требований к безопасности приложений (тестов), которыми могут пользоваться архитекторы, разработчики, тестировщики, специалисты по безопасности, разработчики инструментов и конечные пользователи для проектирования, разработки, тестирования и контроля безопасных приложений.\n\n## Авторские права и лицензия\n\nВерсия 5.0.0, май 2025\n\n![лицензия](../images/license.png)\n\nCopyright © 2008-2025 The OWASP Foundation.\n\nЭтот документ выпущен под [лицензией Creative Commons Attribution-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/).\n\nПри воспроизведении или распространении этого документа необходимо разъяснить условия лицензии на него.\n\n## Руководители проекта\n\n|                       |                  |\n|---------------------- |----------------- |\n| Elar Lang             | Josh C Grossman  |\n| Jim Manico            | Daniel Cuthbert  |\n\n## Рабочая группа\n\n|                 |                   |                    |                  |\n|---------------- |------------------ |------------------- |----------------- |\n| Tobias Ahnoff   | Ralph Andalis     | Ryan Armstrong     | Gabriel Corona   |\n| Meghan Jacquot  | Shanni Prutchi    | Iman Sharafaldin   | Eden Yardeni     |\n\n## Основные участники\n\n|                   |                   |\n|-------------------|-------------------|\n| Sjoerd Langkemper | Isaac Lewis       |\n| Mark Carney       | Sandro Gauci      |\n\n## Другие участники и рецензенты\n\nСписок остальных участников перечислен в Приложении E.\n\nЕсли Вы — участник проекта, но Вашего имени нет в приведенном выше списке, пожалуйста, зарегистрируйте issue на GitHub для признания в будущих обновлениях.\n\nПятая версия стандарта верификации требований к безопасности приложений опирается на предыдущие версии ASVS, начиная с первой, вышедшей в 2008 году, и до четвертой, в 2019 году. Большая часть разделов оглавления и пунктов требований, до сих пор присутствующих в ASVS, изначально были написаны Эндрю ван дер Стоком, Майком Боберски, Джеффом Уильямсом и Дэйвом Уичерсом, но участников было гораздо больше - спасибо им всем. Полные списки всех, кто внес свой вклад в более ранние версии, есть в соответствующих версиях документа.\n", "timestamp": "2025-10-24T11:40:13.626917"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x02-Preface.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x02-Preface.md", "content": "# Предисловие\n\nДобро пожаловать в Стандарт верификации требований к безопасности приложений (ASVS) версии 5.0\n\n## Введение\n\nИзначально представленный в 2008 году совместными усилиями мирового сообщества, ASVS определяет исчерпывающий набор требований безопасности для проектирования, разработки и тестирования современных веб-приложений и сервисов.\n\nПосле выхода версии ASVS 4.0 в 2019 году и ее незначительного обновления (v4.0.3) в 2021 году, версия 5.0 является значительным шагом вперед — она была модернизирована, чтобы учесть последние достижения в области безопасности программного обеспечения.\n\nASVS 5.0 стал результатом масштабного вклада руководителей проекта, членов рабочей группы и широкого сообщества OWASP, направленного на обновление и совершенствование этого важного стандарта.\n\n## Ключевые принципы версии 5.0\n\nЭта масштабная редакция была разработана с учетом нескольких ключевых принципов:\n\n* Уточнение границ и целей: Данная версия стандарта была разработана для более точного соответствия основным принципам, отраженным в его названии: Приложение (Application), Безопасность (Security), Проверка (Verification), Стандарт (Standard). Требования были переформулированы - теперь они направлены на предотвращение недостатков безопасности, а не на обязательное применение конкретных технических решений. Тексты требований являются самодостаточными и поясняют свою необходимость.\n\n* Поддержка документирования решений по безопасности: ASVS 5.0 вводит требования к документированию ключевых решений по безопасности. Данный подход улучшает отслеживаемость решений и способствует контекстуально-ориентированным реализациям, предоставляя организациям возможность настраивать свою защиту в соответствии с индивидуальными требованиями и рисками.\n\n* Обновленные уровни: Несмотря на сохранение трехуровневой модели, определения уровней были пересмотрены для упрощения внедрения ASVS. Уровень 1 предназначен для начального этапа внедрения стандарта и обеспечивает базовый уровень защиты. Уровень 2 представляет собой комплексный набор стандартных практик безопасности. Уровень 3 охватывает расширенные требования для обеспечения повышенной гарантии безопасности.\n\n* Реструктуризированное и расширенное содержание: ASVS 5.0 включает приблизительно 350 требований, распределенных по 17 главам. Структура глав была переработана для большей ясности и удобства использования. Для облегчения перехода предоставлено двустороннее соответствие между версиями 4.0 и 5.0.\n\n## Взгляд в будущее\n\nТак же, как и обеспечение безопасности приложения никогда не может быть полностью завершено, работа над ASVS также никогда не прекращается. Несмотря на то, что версия 5.0 является крупным релизом, разработка стандарта продолжается. Данный выпуск позволяет сообществу воспользоваться преимуществами накопленных улучшений и дополнений, а также закладывает основу для будущего развития. Это может включать в себя инициативы сообщества по созданию руководств по внедрению и проверке, основанных на базовом наборе требований.\n\nASVS 5.0 предназначен для того, чтобы служить надежной основой для разработки безопасного программного обеспечения. Сообществу предлагается применять этот стандарт, вносить в него свой вклад и развивать его, чтобы совместно двигать вперёд состояние безопасности приложений.\n", "timestamp": "2025-10-24T11:40:13.893309"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x03-What-is-the-ASVS.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x03-What-is-the-ASVS.md", "content": "# Что такое ASVS?\n\nСтандарт верификации требований к безопасности приложений (ASVS) определяет требования безопасности для веб-приложений и сервисов, представляя собой ценный ресурс для всех, кто стремится проектировать, разрабатывать и поддерживать безопасные приложения или оценивать их уровень защищённости.\n\nВ этой главе описываются ключевые аспекты применения ASVS, включая его область действия, структуру уровней, основанных на приоритетах, и основные сценарии использования стандарта.\n\n## Область действия ASVS\n\nОбласть действия ASVS определяется его названием: Приложение (Application), Безопасность (Security), Верификация (Verification) и Стандарт (Standard). Он устанавливает, какие требования включены в стандарт, а какие — исключены из него, с глобальной целью определения основополагающих принципов безопасности, которые должны быть достигнуты. Область действия также учитывает требования к документации, которые служат основой для требований к реализации.\n\nНе существует такого понятия, как «область действия» для злоумышленника. Поэтому требования ASVS должны оцениваться в совокупности с рекомендациями по другим аспектам жизненного цикла приложения, включая процессы CI/CD, хостинг и операционную деятельность.\n\n### Приложение\n\nASVS определяет «Приложение» как разрабатываемый программный продукт, в который должны быть интегрированы механизмы безопасности. ASVS не регламентирует процессы жизненного цикла разработки и не указывает на методы сборки приложения в CI/CD. Его задача — описать требуемый уровень защищённости, который должен быть достигнут в конечном продукте.\n\nКомпоненты для обработки HTTP-трафика (WAF, балансировщики нагрузки, прокси) могут считаться частью приложения в контексте безопасности, поскольку некоторые механизмы безопасности напрямую зависят от них или могут быть реализованы с их помощью. Это касается требований по кешированию, rate limiting, а также фильтрации входящих/исходящих подключений по источнику и получателю.\n\nВ свою очередь, ASVS не включает требования, не относящиеся к приложению напрямую или находящиеся за пределами его зоны ответственности. Так, например, проблемы DNS обычно относятся в ведении отдельной команды или функции.\n\nАналогично, хотя в зону ответственности приложения входит обработка входящих данных и генерация исходящих данных, если внешний процесс взаимодействует с приложением или его данными, это считается выходящим за рамки ASVS. Например, резервное копирование приложения или его данных обычно выполняется внешними процессами и не контролируется самим приложением или его разработчиками.\n\n### Безопасность\n\nКаждое требование должно иметь очевидное влияние на безопасность. Отсутствие требования должно привести к снижению уровня защищённости приложения, а реализация требования должна либо уменьшить вероятность возникновения риска безопасности, либо смягчить последствия.\n\nВсе прочие аспекты, такие как функциональные характеристики, стиль кода или требования политик, выходят за рамки стандарта.\n\n### Верификация\n\nТребование должно быть верифицируемым, а его проверка должна приводить к однозначному решению: «не выполнено» или «выполнено».\n\n### Стандарт\n\nASVS представляет собой набор требований безопасности, которые необходимо реализовать для соответствия стандарту. Это означает, что требования ограничиваются определением целевого показателя безопасности, которого необходимо достичь. Прочая сопутствующая информация может быть надстроена на основе ASVS или связана с ним через сопоставления.\n\nВ частности, в рамках OWASP существует множество проектов, и ASVS намеренно избегает дублирования содержания других проектов. Например, у разработчиков может возникнуть вопрос: «как мне реализовать конкретное требование в моем технологическом стеке или окружении?» — на него должен отвечать проект Cheat Sheet Series. У тестировщиков может возникнуть вопрос: «как мне проверить это требование в данном окружении?» — на него должен отвечать проект Web Security Testing Guide.\n\nХотя ASVS предназначен не только для специалистов по безопасности, он ожидает, что читатель обладает техническими знаниями для понимания содержания или способен самостоятельно изучить конкретные концепции.\n\n### Требование\n\nСлово «Требование» специально используется в ASVS, поскольку оно описывает обязательное условие, которое должно быть достигнуто для его выполнения. ASVS содержит только требования (обязательные к выполнению) и не содержит рекомендаций.\n\nДругими словами, рекомендации, независимо от того, являются ли они лишь одним из многих возможных вариантов для решения проблем или вопросов стиля кода, не удовлетворяют определению требования.\n\nТребования ASVS определяют цели безопасности, не привязываясь к конкретным технологиям или методам реализации. Их назначение понятно из самого текста, и они не предписывают, как именно следует проводить проверку.\n\n### Документированные решения по безопасности\n\nВ области безопасности программного обеспечения заблаговременное планирование архитектуры безопасности и защитных механизмов позволяет добиться более последовательной и предсказуемой реализации в конечном продукте или функции.\n\nКроме того, некоторые требования сложны в реализации и зависят от специфики приложения. Например, система прав доступа, проверка вводимых данных и защита данных с разной степенью чувствительности.\n\nЧтобы учесть это, вместо общих формулировок, таких как «все данные должны быть зашифрованы», или попыток охватить каждый возможный случай в требовании, были включены требования к документации. Они предписывают, чтобы подход и конфигурация, выбранные разработчиком приложения для механизмов управления, были задокументированы. Это позволяет провести оценку целесообразности подхода, а затем сравнить фактическую реализацию с документацией, чтобы оценить, соответствует ли реализация ожиданиям.\n\nЗадача этих требований — фиксировать решения, которые организация-разработчик приняла в отношении того, каким образом реализовать определенные требования безопасности.\n\nТребования к документации всегда размещаются в первом разделе главы (хотя присутствуют не в каждой из них), и каждое из них всегда связано с соответствующим требованием к реализации, в рамках которого документированные решения должны быть воплощены на практике. Ключевая идея заключается в том, что проверка наличия документации и проверка фактической реализации — это два самостоятельных вида деятельности.\n\nСуществует две ключевые причины для включения этих требований. Первая причина заключается в том, что требование информационной безопасности часто предполагает принудительное применение правил, например, какие типы файлов разрешены для загрузки, какие бизнес-контроли должны быть реализованы, какие символы допустимы для конкретного поля. Эти правила уникальны для каждого приложения и поэтому ASVS не может предписать, какими они должны быть. Ни чек-лист, ни развернутое руководство в данном случае не будут полезны. Также, если эти решения не документированы, то невозможно проверить реализацию на соответствие требованиям.\n\nВторая причина заключается в необходимости обеспечить гибкость для разработчиков приложения в выборе подходов к решению отдельных вопросов безопасности. Например, в прошлых версиях ASVS ограничения времени жизни сессии были строго фиксированы. На практике многие приложения, особенно ориентированные на прямое взаимодействие с потребителями, применяют более мягкие правила, отдавая предпочтение иным компенсирующим механизмам защиты. Таким образом, настоящие требования к документации прямо разрешают такую гибкость.\n\nОчевидно, что предполагается, что подобные решения будут приниматься и документироваться не отдельными разработчиками, а организацией в целом. На организацию возлагается ответственность за принятие данных решений, доведение их до сведения разработчиков и обеспечение их соблюдения.\n\nПредоставление разработчикам спецификаций и проектов новых функций является стандартной практикой в процессе разработки программного обеспечения. Аналогичным образом, от разработчиков ожидается использование общепринятых компонентов и механизмов пользовательского интерфейса, а не принятие самостоятельных решений каждый раз. Таким образом, распространение данного подхода на безопасность не должно восприниматься как нечто удивительное или спорное.\n\nКроме того, существует гибкость в выборе способа достижения данной цели. Решения в области безопасности могут быть документированы в виде явного документа, с которым разработчики обязаны знакомиться. Альтернативно, эти решения могут быть документированы и реализованы в рамках общей библиотеки, которую все разработчики обязаны использовать. Результат достигается в обоих случаях.\n\n## Уровни соответствия ASVS\n\nСтандарт верификации требований к безопасности приложений определяет три уровня соответствия, каждый из которых усиливает требования предыдущего. Рекомендуемый подход для организаций — начинать с первого уровня для митигации наиболее критичных рисков безопасности с последующим переходом на более высокие уровни в зависимости от конкретных потребностей приложения и организации. В документации и требованиях используются сокращения L1, L2 и L3.\n\nКаждый уровень соответствия определяет требования безопасности, которые необходимо выполнить для его достижения. Требования же вышестоящих уровней носят рекомендательный характер.\n\nВо избежание дублирования требований или наличия требований, теряющих актуальность на более высоких уровнях, некоторые из них применяются к конкретному уровню, но предусматривают более строгие условия для последующих уровней.\n\n### Оценка уровней соответствия\n\nУровни соответствия определяются путём приоритизационной оценки каждого требования, основанной на опыте их внедрения и тестирования. Основное внимание уделяется сопоставлению снижения рисков с усилиями по реализации требования. Другим ключевым фактором является сохранение низкого порога вхождения.\n\nОценка снижения риска рассматривает, насколько требование уменьшает уровень риска безопасности в приложении. При этом принимаются во внимание классические факторы воздействия на Конфиденциальность, Целостность и Доступность, а также то, является ли данное требование основным рубежом обороны или же оно рассматривается как элемент эшелонированной защиты.\n\nВ результате тщательных обсуждений как самих критериев, так и решений по отнесению их к уровням соответствия, была выработана классификация, которая должна оставаться справедливой для подавляющего большинства случаев, при этом допуская, что она не может быть универсальной для всех ситуаций. Это означает, что в отдельных случаях организации могут пожелать отдать приоритет требованиям более высокого уровня ранее, основываясь на собственной оценке рисков.\n\nТребования на каждом уровне можно охарактеризовать следующим образом:\n\n### Уровень 1\n\nДанный уровень содержит минимальный набор требований для обеспечения безопасности приложения, и представляет собой критически важную отправную точку. На этот уровень приходится около 20% требований ASVS. Цель этого уровня — иметь как можно меньше требований для снижения порога вхождения.\n\nЭти требования, как правило, являются критически важными или базовыми, представляя собой первый рубеж защиты от распространённых атак, для эксплуатации которых не требуется наличия других уязвимостей или предварительных условий.\n\nПомимо требований первого рубежа защиты, некоторые требования имеют меньшее значение на более высоких уровнях, например, требования, связанные с паролями. Они более важны для первого уровня, поскольку, начиная с более высоких уровней становятся актуальными требования многофакторной аутентификации.\n\nПервый уровень не обязательно поддаётся полноценному тестированию на проникновение внешним специалистом без доступа ко внутренней документации или коду (например, при тестировании по методу «чёрного ящика»), хотя меньшее количество требований должно упростить процесс верификации.\n\n### Уровень 2\n\nБольшинству приложений следует стремиться к достижению данного уровня безопасности. На Уровень 2 (L2) приходится около 50% требований ASVS, что означает, что приложению необходимо реализовать порядка 70% требований ASVS (все требования уровней L1 и L2) для соответствия этому уровню.\n\nЭти требования, как правило, связаны либо с менее распространёнными атаками, либо с более сложными механизмами защиты от распространённых атак. Они могут по-прежнему представлять собой первый рубеж обороны, либо же для успешной атаки могут требоваться определённые предварительные условия.\n\n### Уровень 3\n\nДанный уровень должен быть целью для приложений, стремящихся продемонстрировать наивысший уровень защищённости, и содержит оставшиеся ~30% требований для полного соответствия.\n\nТребования в данном разделе, как правило, представляют собой либо механизмы глубокой эшелонированной обороны (defense-in-depth), либо иные полезные, но сложные в реализации средства контроля.\n\n### Какого уровня следует достичь\n\nУровни, основанные на приоритетах, призваны отражать степень зрелости системы безопасности организации и приложения. Вместо того, чтобы предписывать, какого уровня должно достигать приложение, ASVS предлагает организации проанализировать свои риски и самостоятельно определить целевой уровень, исходя из критичности приложения и, конечно же, ожиданий его пользователей.\n\nНапример, стартап на ранней стадии, собирающий лишь ограниченный объём конфиденциальных данных, может принять решение сфокусироваться на первом уровне на начальном этапе. В то же время банк не сможет объяснить клиентам выбор уровня ниже, чем Уровень 3, для своего онлайн банковского приложения.\n\n## Как применять этот стандарт\n\n### Структура ASVS\n\nASVS состоит в общей сложности из приблизительно 350 требований, которые разделены на 17 глав. Каждая глава, в свою очередь, делится на разделы.\n\nЦель такого деления на главы и разделы — упростить выбор или исключение соответствующих глав и разделов в зависимости от релевантности для конкретного приложения. Например, требования главы V3, касающиеся веб-интерфейсов, не будут актуальны в случае API для межмашинного взаимодействия. Если в системе не используется OAuth или WebRTC, то соответствующие главы также могут быть проигнорированы.\n\n### Стратегия выпусков\n\nВыпуски ASVS следуют схеме \"Major.Minor.Patch\", где номера версий указывают на характер изменений в выпуске. При мажорном выпуске изменяется первое число, при минорном — второе, а при патче — третье.\n\n* Мажорный выпуск (Major release) — Полная реорганизация. Могут быть изменены практически все элементы, включая нумерацию требований. Для подтверждения соответствия потребуется проведение повторной оценки (например, переход с версии 4.0.3 на 5.0.0).\n* Минорный выпуск (Minor release) — Требования могут добавляться или удаляться, но общая структура нумерации остаётся прежней. Для подтверждения соответствия потребуется повторная оценка, но она должна быть проще (например, переход с версии 5.0.0 на 5.1.0).\n* Выпуск патча (Patch release) — Требования могут быть удалены (например, если они являются дубликатами или устарели) или смягчены. Приложение, соответствовавшее предыдущему выпуску, будет соответствовать и патч-выпуску (например, переход с версии 5.0.0 на 5.0.1).\n\nВышеизложенное относится только к самим требованиям. Изменения в пояснительных текстах и приложениях не являются критическими.\n\n### Гибкость использования ASVS\n\nРяд рассмотренных принципов (например, требования к документации и система уровней) предоставляет возможность применять ASVS гибко, с учётом специфики организации.\n\nКроме того, организациям настоятельно рекомендуется создавать специализированные ответвления (форки) стандарта, адаптированные для организации или домена, которые корректируют требования исходя из специфических характеристик и уровней риска их приложений. Однако важно сохранять прослеживаемость (traceability), чтобы соответствие требованию, например, 4.1.1, означало одно и то же во всех версиях.\n\nВ идеале, каждой организации следует создавать собственную адаптированную версию ASVS, исключая нерелевантные разделы (например, GraphQL, WebSockets, SOAP, если они не используются). Версия ASVS, адаптированная под организацию, или дополнение к ней также является хорошим способом предоставить специфичные для организации руководства по реализации, уточняя библиотеки или ресурсы, которые следует использовать для выполнения требований.\n\n### Как ссылаться на требования ASVS\n\nКаждое требование имеет идентификатор в формате `<chapter>.<section>.<requirement>` где каждый элемент является числом, например: `1.11.3`.\n\n* Значение `<chapter>` соответствует главе, в которой находится это требование, например: все требования `1.#.#` находятся в главе 'Архитектура кодировки и нейтрализации'.\n* Значение `<section>` соответствует разделу в этой главе, где находится это требование; например, все требования `1.2.#` находятся в разделе 'Предотвращение инъекций' главы 'Архитектура кодировки и нейтрализации'.\n* Значение `<requirement>` указывает на конкретное требование в главе и разделе, например, `1.2.5`, которым в версии 5.0.0 этого стандарта является:\n\n> Убедитесь, что приложение защищено от внедрения команд ОС и что вызовы операционной системы используют параметризованные запросы к ОС или используют контекстное кодирование вывода командной строки.\n\nИдентификаторы требований могут меняться от версии к версии, поэтому желательно, чтобы другие документы, отчеты или инструменты использовали формат: `v<version>-<chapter>.<section>.<requirement>`, где: 'version' это метка версии ASVS. Например: `v5.0.0-1.2.5` будет означать 5-е требование в разделе 'Предотвращение инъекций' главы 'Архитектура кодировки и обработки' в версии 5.0.0. (Резюмируя, `v<version>-<requirement_identifier>`.)\n\nПримечание. Буква `v`, предшествующая версии, должна быть в нижнем регистре.\n\nСчитается, что если идентификаторы указаны без элемента `v<version>`, то они относятся к последней версии стандарта. По мере развития и изменения стандарта это станет проблематичным, поэтому авторы и разработчики должны включать элемент версии.\n\nСписки требований ASVS доступны в форматах CSV, JSON и других, которые могут оказаться полезными для справки или использования в программах.\n\n### Создание ответвлений ASVS\n\nОрганизации могут извлечь пользу из применения ASVS, выбрав один из трёх уровней или создав предметно-ориентированное ответвление (fork), которое адаптирует требования в соответствии с уровнем риска каждого приложения. Такой подход настоятельно рекомендуется при условии сохранения прослеживаемости (traceability), чтобы соответствие требованию, например, 4.1.1, означало одно и то же во всех версиях.\n\nВ идеале каждой организации следует создать собственную адаптированную версию ASVS, исключая нерелевантные разделы (например, GraphQL, WebSockets, SOAP, если они не используются). Создание ответвления следует начинать с использования ASVS Уровня 1 в качестве базового, с последующим переходом на Уровни 2 или 3 в зависимости от рисков, присущих приложению.\n\n## Сценарии применения ASVS\n\nASVS может быть использован для оценки безопасности приложения, и этот вопрос более глубоко исследуется в следующей главе. Тем не менее, был выявлен ряд других потенциальных вариантов использования ASVS (или его модифицированной версии).\n\n### Как подробное руководство по архитектуре безопасности\n\nОдним из наиболее распространенных вариантов использования Стандарта верификации требований к безопасности приложений является его применение в качестве ресурса для архитекторов безопасности. В настоящее время существует ограниченное количество материалов о том, как построить безопасную архитектуру современного приложения. ASVS может быть использован для восполнения этих пробелов, позволяя архитекторам безопасности выбирать более эффективные меры для решения распространенных проблем, таких как шаблоны защиты и стратегии валидации входных данных. Требования, связанные с архитектурой и документацией, будут особенно полезны для этой цели.\n\n### Как специализированное руководство по безопасной разработке\n\nASVS может быть использован как основа для подготовки руководства по безопасной разработке в процессе разработки приложения, помогая разработчикам не упускать из виду аспекты безопасности при создании программного обеспечения. Хотя ASVS может служить основой, организациям следует подготовить свои собственные конкретные руководства, которые являются четкими и унифицированными, и в идеале их следует составлять на основе рекомендаций инженеров или архитекторов безопасности. В развитие этого подхода организациям настоятельно рекомендуется, по возможности, подготовить одобренные механизмы безопасности и библиотеки, на которые можно ссылаться в руководствах и которые разработчики могут использовать.\n\n### Как руководство по автоматизированному модульному и интеграционному тестированию\n\nASVS создавался таким, чтобы его можно было легко протестировать. Некоторые проверки носят технический характер, в то время как другие требования могут потребовать анализа документации или архитектуры. Благодаря модульным и интеграционным тестам, которые проверяют характерные случаи фаззинга и недокументированного использования, связанных с требованиями, поддающимися технической верификации, можно упростить проверку корректности работы этих контролей при каждой сборке. Например, для набора тестов для контроллера входа в систему можно разработать дополнительные тесты, проверяющие атрибут username на совпадение с наиболее распространенными именами пользователей по умолчанию, перебор учетных записей, LDAP- и SQL-инъекции, а также XSS. Аналогично, проверка атрибута password должна включать перебор самых распространенных паролей, оценку длины пароля, вставку нулевого байта, удаление этого атрибута, XSS и многое другое.\n\n### Как курс по безопасной разработке\n\nASVS также можно использовать для определения характеристик защищенного программного обеспечения. Многие «курсы безопасной разработки» — это просто курсы по этичному хакингу с легким намеком на советы по безопасной разработке. Не факт, что это как-то поможет разработчикам писать более безопасный код. Вместо этого курсы по безопасной разработке должны делать упор на упреждающие меры из ASVS, а не на список того, чего делать не стоит (OWASP Top 10). Структура ASVS также предоставляет логичную основу для последовательного изучения различных тем, связанных с защитой приложения.\n\n### Как руководство по приобретению безопасного программного обеспечения\n\nASVS — это отличное руководство по приобретению безопасного программного обеспечения или заказных услуг по его разработке. Заказчику достаточно указать требование, что программное обеспечение, которое он хочет приобрести, должно быть разработано на уровне ASVS LX, и потребовать, чтобы Исполнитель доказал, что оно ему соответствует.\n\n## Применение ASVS на практике\n\nРазные угрозы имеют разную мотивацию. В отдельных отраслях имеются уникальные информационные и технологические ресурсы или отраслевые регуляторные требования.\n\nОрганизациям настоятельно рекомендуется внимательно изучить риски, присущие характеру их бизнеса, и на их основе, и с учетом бизнес-требований определить соответствующий уровень ASVS.\n", "timestamp": "2025-10-24T11:40:14.088185"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x04-Assessment_and_Certification.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x04-Assessment_and_Certification.md", "content": "# Оценка и сертификация\n\n## Позиция OWASP в отношении сертификатов и знаков доверия ASVS\n\nOWASP, будучи независимой от поставщиков некоммерческой организацией, не сертифицирует разработчиков, аудиторов или программное обеспечение. Любые заверения, знаки доверия или сертификаты, претендующие на соответствие ASVS, официально не поддерживаются OWASP, поэтому организации должны проявлять осторожность в заявлении третьих сторон о сертификации по ASVS.\n\nОрганизации могут предлагать услуги по предоставлению гарантий соответствия при условии, что они не претендуют на официальную сертификацию OWASP.\n\n## Как проверять соответствие ASVS\n\nСтандарт намеренно не предписывает конкретные методы проверки соответствия на уровне руководства по тестированию. Тем не менее, важно выделить некоторые ключевые моменты.\n\n### Отчет о проверке\n\nТрадиционные отчёты о тестировании на проникновение фиксируют только неудачные проверки. Однако отчёт о проверке соответствия ASVS должен включать в себя область исследования, сводку всех проверяемых требований, а также требования, по которым были отмечены исключения, и руководство по устранению выявленных проблем. Некоторые требования могут быть неприменимы (например, управление сессиями в stateless API), и это должно быть явно указано в отчёте.\n\n### Область исследования\n\nОрганизация, разрабатывающая приложение, как правило, реализует не все требования, поскольку некоторые из них могут быть нерелевантными или менее значимыми исходя из функциональности приложения. Аудитор должен чётко определить область проверки, включая то, какого уровня соответствия пытается достичь организация и какие требования были включены в оценку. Это должно быть представлено с точки зрения того, что было включено, а не того, что было исключено. Кроме того, аудитор должен предоставить заключение с обоснованием причин исключения требований, которые не были реализованы.\n\nЭто должно позволить заказчику отчёта о проверке понять контекст проведённого исследования и принять взвешенное решение о том, какой уровень доверия может быть предоставлен приложению.\n\nСертифицирующие организации могут выбирать свои методы тестирования, но должны раскрывать их в отчёте и в идеале эти методы должны быть воспроизводимыми. Для проверки различных аспектов (таких как валидация входных данных) в зависимости от приложения и конкретных требований могут использоваться разные методы, например, ручное тестирование на проникновение или анализ исходного кода.\n\n### Методы тестирования\n\nДля верификации конкретных требований ASVS может потребоваться применение ряда различных методик. Помимо тестирования на проникновение (с использованием действительных учётных данных для обеспечения полного охвата приложения), проверка соответствия требованиям ASVS может потребовать доступа к документации, исходному коду, конфигурациям, а также к лицам, причастным к процессу разработки. Это особенно актуально для верификации требований Уровней 2 и 3. Стандартной практикой является предоставление убедительных доказательств обнаруженных недостатков с подробным документированием, которое может включать записи тестировщика, скриншоты, скрипты и журналы тестирования. Простого запуска автоматизированного инструмента недостаточно для сертификации, поскольку каждое требование должно быть тщательно протестировано.\n\nИспользование средств автоматизации для верификации требований ASVS — это тема, которая неизменно вызывает значительный интерес. В связи с этим важно прояснить некоторые моменты, связанные с автоматизированным тестированием и тестированием по методу «чёрного ящика».\n\n#### Роль инструментов автоматизированного тестирования безопасности\n\nКогда автоматизированные инструменты динамического и статического анализа безопасности приложений (DAST и SAST) корректно интегрированы в pipeline сборки, они могут выявлять некоторые проблемы безопасности, которые не должны существовать в принципе. Однако без тщательной конфигурации и настройки они не обеспечат необходимый охват, а большое количество ложных срабатываний помешает выявлению и устранению реальных проблем безопасности.\n\nХотя это может обеспечить покрытие некоторых более базовых и простых технических требований, относящихся к кодированию или нейтрализации выходных данных, крайне важно отметить, что эти инструменты неспособны в полной мере проверить многие из более сложных требований ASVS или тех, что связаны с бизнес-логикой и контролем доступа.\n\nЧто касается менее тривиальных требований, вероятно, что автоматизацию всё же можно задействовать, однако для этого потребуется написание специфичных для приложения проверок. Они могут быть аналогичны модульным и интеграционным тестам, которые организация, возможно, уже использует. Следовательно, может оказаться возможным использовать существующую инфраструктуру автоматизации тестирования для создания этих специализированных тестов под требования ASVS. Хотя для этого потребуются краткосрочные инвестиции, долгосрочные преимущества, связанные с возможностью постоянной верификации этих требований ASVS, будут значительными.\n\nПодводя итог, автоматизированное тестирование != запуску стандартного инструмента «из коробки».\n\n#### Роль тестирования на проникновение\n\nНесмотря на то, что Уровень 1 (L1) в версии 4.0 был оптимизирован для проведения тестирования по методу «чёрного ящика» (без доступа к документации и исходному коду), даже в то время стандарт четко давал понять, что это не является эффективной деятельностью, гарантирующей соответствие, и такой подход не следует активно применять.\n\nТестирование без доступа к необходимой дополнительной информации является неэффективным и малорезультативным, поскольку при этом упускается возможность проверки исходного кода, выявления угроз и отсутствующих мер защиты, а также выполнения гораздо более тщательного тестирования в более короткие сроки.\n\nНастоятельно рекомендуется проводить тестирование на проникновение, основанное на изучении документации и исходного кода (гибридный подход), в ходе которого тестировщики имеют полный доступ к разработчикам приложения и его документации, в отличие от традиционного тестирования на проникновение. Этот подход будет необходимым для верификации многих требований ASVS.\n", "timestamp": "2025-10-24T11:40:14.167693"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x05-For-Users-Of-4.0.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x05-For-Users-Of-4.0.md", "content": "# Изменения по сравнению с v4.x\n\n## Введение\n\nПользователям, знакомым со стандартом версии 4.x, может быть полезно ознакомиться с ключевыми изменениями, внесёнными в версию 5.0, включая обновления в содержании, области применения и основополагающей философии.\n\nИз 286 требований версии 4.0.3 только 11 остались без изменений, в то время как 15 претерпели незначительные грамматические правки, не повлиявшие на их смысл. В общей сложности 109 требований (38%) более не являются отдельными требованиями в версии 5.0 – 50 были просто удалены, 28 удалены как дубликаты и 31 объединено с другими требованиями. Остальные требования были так или иначе пересмотрены. Даже требования, не претерпевшие существенных изменений, имеют новые идентификаторы из-за переупорядочивания или реструктуризации.\n\nДля облегчения перехода на версию 5.0 предоставляются документы сопоставления, которые помогают пользователям отследить, как требования из версии 4.x соотносятся с требованиями в версии 5.0. Эти сопоставления не привязаны к версиям выпусков и могут при необходимости обновляться или уточняться.\n\n## Философия требований\n\n### Целевая область применения\n\nВерсия 4.x включала требования, которые не соответствовали целевой области применения стандарта - они были удалены. Требования, которые не удовлетворяли критериям области применения для версии 5.0 или не поддавались верификации, также были исключены.\n\n### Акцент на целях безопасности, а не на механизмах\n\nВ версии 4.x многие требования были сфокусированы на конкретных механизмах, а не на лежащих в их основе целях безопасности. В версии 5.0 требования сконцентрированы на целях безопасности, ссылаясь на конкретные механизмы только в тех случаях, когда они являются единственным практическим решением, или предоставляя их в качестве примеров или дополнительного руководства.\n\nТакой подход допускает разные методы достижения цели, избегая излишних предписаний, которые могли бы ограничить гибкость компаний.\n\nКроме того, требования, касающиеся одной и той же проблемы безопасности, были объединены там, где это было необходимо.\n\n### Документированные решения по безопасности\n\nХотя концепция документированных решений по безопасности может показаться новой в версии 5.0, она является развитием более ранних требований, связанных с применением политик и моделированием угроз в версии 4.0. Ранее некоторые требования неявно предполагали проведение анализа для обоснования реализации средств контроля безопасности, такого как определение разрешенных сетевых подключений.\n\nЧтобы обеспечить доступность необходимой информации для реализации и проверки, эти ожидания теперь явно определены как требования к документации, делая их понятными, практичными и проверяемыми.\n\n## Структурные изменения и новые главы\n\nНесколько глав в версии 5.0 представляют полностью новый контент:\n\n* OAuth и OIDC – Учитывая широкое распространение этих протоколов для делегирования доступа и единого входа, были добавлены специальные требования для решения разнообразных сценариев, с которыми могут столкнуться разработчики. Эта область может в конечном итоге развиться в самостоятельный стандарт, аналогично тому, как это произошло с требованиями для мобильных устройств и IoT в предыдущих версиях.\n* WebRTC – Поскольку эта технология набирает популярность, ее уникальные проблемы и аспекты безопасности теперь рассматриваются в отдельном разделе.\n\nТакже были приложены усилия, чтобы обеспечить организацию глав и разделов вокруг логичных наборов связанных требований.\n\nЭта реструктуризация привела к созданию дополнительных глав:\n\n* Автономные токены (Self-contained Tokens) – Ранее относящиеся к управлению сессиями, автономные токены теперь признаны самостоятельным механизмом и базовым элементом для взаимодействия без сохранения состояния (такого как в OAuth и OIDC). Ввиду их уникальных аспектов безопасности, они рассматриваются в отдельной главе с некоторыми новыми требованиями, введенными в версии 5.x.\n* Безопасность веб-интерфейсов (Web Frontend Security) – В связи с растущей сложностью браузерных приложений и распространением API-ориентированных архитектур, требования к безопасности фронтенда были выделены в отдельную главу.\n* Безопасная разработка и архитектура (Secure Coding and Architecture) – Новые требования, касающиеся общих практик безопасности, которые не вписывались в существующие главы, были сгруппированы здесь.\n\nДругие организационные изменения в версии 5.0 были внесены для уточнения целей. Например, требования к валидации входных данных были помещены рядом с бизнес-логикой, а не с кодировкой и обработкой, отражая их роль в обеспечении соблюдения бизнес-правил.\n\nБывшая глава V1 «Архитектура, проектирование и моделирование угроз» была удалена. Ее начальный раздел содержал требования, которые выходили за рамки области проверки, в то время как последующие разделы были перераспределены в соответствующие главы, с удалением дубликатов и уточнениями по мере необходимости.\n\n## Удаление прямых соответствий с другими стандартами\n\nПрямые соответствия другим стандартам были удалены из основного тела стандарта. Цель состоит в подготовке соответствия с проектом OWASP Common Requirement Enumeration (CRE), который, в свою очередь, свяжет ASVS с рядом проектов OWASP и внешними стандартами.\n\nПрямые соответствия CWE и NIST более не поддерживаются, как поясняется ниже.\n\n### Снижение связи с NIST Digital Identity Guidelines\n\nРекомендации NIST [Digital Identity Guidelines (SP 800-63)](https://pages.nist.gov/800-63-3/) долгое время служили ориентиром для средств контроля аутентификации и авторизации. В версии 4.x определенные главы были тесно связаны со структурой и терминологией NIST.\n\nХотя эти рекомендации остаются важным ориентиром, строгое соответствие создавало проблемы, включая менее распространенную терминологию, дублирование схожих требований и неполные соответствия. Версия 5.0 отходит от этого подхода для повышения ясности и релевантности.\n\n### Отступление от Common Weakness Enumeration (CWE)\n\n[Common Weakness Enumeration (CWE)](https://cwe.mitre.org/) предоставляет полезную систематику уязвимостей программного обеспечения. Однако такие проблемы, как широкие классы CWЕ (category-only CWEs), трудности в сопоставлении требований с отдельным CWE, а также наличие неточных соответствий в версии 4.x, привели к решению отказаться от прямых сопоставлений с CWE в версии 5.0.\n\n## Переосмысление определений уровней\n\nВерсия 4.x описывала уровни как L1 («Минимальный»), L2 («Стандартный») и L3 («Продвинутый»), с подразумеванием, что все приложения, обрабатывающие конфиденциальные данные, должны соответствовать как минимум L2.\n\nВерсия 5.0 решает несколько проблем этого подхода, которые описаны в следующих параграфах.\n\nС практической точки зрения, в то время как версия 4.x использовала галочки для обозначения уровней, версия 5.x использует простое число во всех форматах стандарта, включая markdown, PDF, DOCX, CSV, JSON и XML. Для обратной совместимости также генерируются устаревшие версии выводов CSV, JSON и XML, которые все еще используют галочки.\n\n### Снижение порога входа\n\nОбратная связь показала, что большое количество требований Уровня 1 (~120) в сочетании с его обозначением как «минимального» уровня, которого недостаточно для большинства приложений, препятствовало внедрению. Цель версии 5.0 — уменьшить этот барьер за счет определения требований Уровня 1 как первого эшелона защиты, благодаря чему они становятся более четкими и их количество сокращается. Чтобы продемонстрировать это численно, в v4.0.3 было 128 требований L1 из общего числа в 278 требований, что составляет 46%. В 5.0.0 насчитывается 70 требований L1 из общего числа в 345 требований, что составляет 20%.\n\n### Иллюзия проверяемости\n\nКлючевым фактором при выборе средств контроля для Уровня 1 в версии 4.x была их пригодность для оценки с помощью внешнего тестирования на проникновение по методу «черного ящика». Однако этот подход не был полностью согласован с целью Уровня 1 как минимального набора средств обеспечения безопасности. Некоторые пользователи утверждали, что Уровня 1 недостаточно для защиты приложений, в то время как другие считали его слишком сложным для тестирования.\n\nОпора на проверяемость как на критерий является относительной и, в ряде случаев, вводящей в заблуждение. Тот факт, что требование является проверяемым, не гарантирует, что его можно проверить автоматизированным или простым способом. Более того, наиболее легко проверяемые требования не всегда являются теми, которые оказывают наибольшее влияние на безопасность или которые проще всего реализовать.\n\nТаким образом, в версии 5.0 решения об уровнях принимались в первую очередь с целью снижения рисков, а также с учетом необходимых усилий по реализации.\n\n### Не только оценка рисков\n\nИспользование предписывающих уровней, основанных на оценке риска, которые устанавливают определенный уровень для определенных приложений, оказалось слишком жестким. На практике расстановка приоритетов и внедрение средств безопасности зависят от множества факторов, включая как снижение рисков, так и усилия, необходимые для реализации.\n\nСледовательно, организациям следует стремиться к достижению того уровня, который они считают необходимым, исходя из своей зрелости и ценностей, которые они хотят демонстрировать своим клиентам.\n", "timestamp": "2025-10-24T11:40:14.232058"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x10-V1-Encoding-and-Sanitization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x10-V1-Encoding-and-Sanitization.md", "content": "# V1 Кодировка и нейтрализация\n\n## Задачи контроля\n\nВ этой главе рассматриваются наиболее распространенные уязвимости безопасности веб-приложений, связанные с небезопасной обработкой недоверенных (пользовательских) данных. Такие уязвимости могут привести к различным техническим уязвимостям, где такие данные интерпретируются в соответствии с правилами синтаксиса соответствующего интерпретатора.\n\nДля современных веб-приложений всегда лучше использовать более архитектурно безопасные API, такие как параметризованные запросы, автоматическое экранирование или шаблонные фреймворки. В ином случае, самостоятельное тщательное выполнение кодирования выходных данных, экранирование или нейтрализация становятся критически важными для безопасности приложения.\n\nВалидация входных данных служит механизмом многослойной/глубокоэшелонированной (defense‑in‑depth) защиты от неожидаемого или опасного контента. Однако, поскольку ее основная цель заключается в обеспечении соответствия входящих данных функциональным и бизнес-ожиданиям, требования, связанные с этим, можно найти в главе «Валидация и бизнес-логика».\n\n## V1.1 Архитектура кодировки и нейтрализации\n\nВ разделах ниже приведены требования для синтаксиса или интерпретатора, предназначенные для безопасной обработки небезопасного содержимого и предотвращения уязвимостей безопасности. Требования в этом разделе охватывают порядок, в котором должна происходить эта обработка, и где она должна происходить. Они также направлены на то, чтобы гарантировать, что при каждом сохранении данных они остаются в своем исходном состоянии и не хранятся в закодированной или экранированной форме (например, кодировка HTML), чтобы предотвратить проблемы с двойным кодированием.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **1.1.1** | Убедитесь, что входные данные декодируются или деэкранируются в каноническую форму (в стандартное представление) только один раз. Декодирование происходит только тогда, когда ожидаются закодированные данные в этой форме, и что это делается перед дальнейшей обработкой входных данных, например, это не выполняется после проверки или нейтрализации. | 2 |\n| **1.1.2** | Убедитесь, что приложение выполняет кодирование и экранирование выходных данных либо в качестве последнего шага перед использованием интерпретатором, для которого оно предназначено, либо самим интерпретатором. | 2 |\n\n## V1.2 Предотвращение инъекций\n\nКодирование или экранирование выходных данных, выполняемое близко или смежно с потенциально опасным контекстом, критично для безопасности любого приложения. Обычно кодирование и экранирование выходных данных не сохраняется, а вместо этого используется для обеспечения безопасности выходных данных для немедленного использования в соответствующем интерпретаторе. Попытка выполнить это на более ранних этапах может привести к искажению содержимого или неэффективно отобразить кодирование или экранирование.\n\nВо многих случаях библиотеки программного обеспечения включают более или полностью безопасные функции, которые выполняют это автоматически, хотя необходимо убедиться, что они корректны для текущего контекста.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **1.2.1** | Убедитесь, что выходная кодировка для ответа HTTP, документа HTML или документа XML соответствует требуемому контексту, например, кодировка соответствующих символов для элементов HTML, атрибутов HTML, комментариев HTML, CSS или полей заголовка HTTP делается таким способом, чтобы избежать изменения структуры сообщения или документа. | 1 |\n| **1.2.2** | Убедитесь, что при динамическом построении URL-адресов недоверенные данные кодируются в соответствии с их контекстом (например, кодирование URL-адресов или кодирование base64url для query или path параметров или пути). Убедитесь, что разрешены только безопасные протоколы URL-адресов (например, запрещен javascript: или data:). | 1 |\n| **1.2.3** | Убедитесь, что при динамическом построении содержимого JavaScript (включая JSON) используется кодирование или экранирование выходных данных, чтобы избежать изменения структуры сообщения или документа (чтобы избежать JavaScript и JSON-инъекций). | 1 |\n| **1.2.4** | Убедитесь, что выборка данных (Redis, Memcached, чтение из файлов, обращение по API) или запросы к базе данных (например, SQL, HQL, NoSQL, Cypher) используют параметризованные запросы, ORM, Entity Frameworks или иным образом защищены от SQL-инъекций и других атак. Это также актуально при написании хранимых процедур. | 1 |\n| **1.2.5** | Убедитесь, что приложение защищено от внедрения команд ОС и что вызовы операционной системы используют параметризованные запросы к ОС или используют контекстное кодирование вывода командной строки. | 1 |\n| **1.2.6** | Убедитесь, что приложение защищено от LDAP-инъекций, или что реализованы специальные меры безопасности для их предотвращения. | 2 |\n| **1.2.7** | Убедитесь, что приложение защищено от атак с использованием XPath-инъекций с помощью параметризации запросов или предварительно скомпилированных запросов. | 2 |\n| **1.2.8** | Убедитесь, что процессоры LaTeX настроены безопасно (например, не используется флаг «–shell‑escape») и используется разрешенный список команд для предотвращения LaTeX-инъекций. | 2 |\n| **1.2.9** | Убедитесь, что приложение экранирует специальные символы в регулярных выражениях (обычно с помощью обратной косой черты), чтобы предотвратить их ошибочную интерпретацию как метасимволов. | 2 |\n| **1.2.10** | Убедитесь, что приложение защищено от внедрения формул CSV (CSV Injection). Приложение должно следовать правилам экранирования, определенным в RFC 4180, разделы 2.6 и 2.7, при экспорте содержимого CSV. Кроме того, при экспорте в CSV или другие форматы электронных таблиц (такие как XLS, XLSX или ODF) специальные символы (включая '=', '+', '-', '@', '\\t' (табуляция), и '\\0' (нулевой символ)) должны экранироваться одинарной кавычкой, если они появляются в качестве первого символа в значении поля. | 3 |\n\nПримечание: Использование параметризованных запросов или экранирование SQL не всегда достаточно. Части запроса, такие как имена таблиц и столбцов (включая имена столбцов «ORDER BY»), не могут быть экранированы. Включение экранированных пользовательских данных в эти поля приводит к сбоям запросов или SQL-инъекции.\n\n## V1.3 Нейтрализация\n\nИдеальной защитой от использования недоверенных данных в небезопасном контексте является использование контекстно-зависимого кодирования или экранирования, которое сохраняет то же семантическое значение небезопасного контента, но делает его безопасным для использования в этом конкретном контексте, как обсуждалось более подробно в предыдущем разделе.\n\nЕсли это невозможно, необходима нейтрализация, удаляющая потенциально опасные символы или данные. В некоторых случаях это может изменить семантическое значение ввода, но по соображениям безопасности альтернативы может не быть.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **1.3.1** | Убедитесь, что все ненадежные входные данные HTML из редакторов WYSIWYG или аналогичных программ нейтрализуются с помощью известных и безопасных библиотек или функций фреймворка для санитизации HTML. | 1 |\n| **1.3.2** | Убедитесь, что приложение избегает использования eval() или других динамических функций выполнения кода, таких как Spring Expression Language (SpEL). Если нет альтернативы, любой пользовательский ввод должен быть нейтрализован перед выполнением. | 1 |\n| **1.3.3** | Убедитесь, что данные, передаваемые в потенциально опасный контекст, предварительно нейтрализованы, чтобы обеспечить соблюдение мер безопасности, таких как разрешение только тех символов, которые безопасны для данного контекста, и обрезка слишком длинного ввода. | 2 |\n| **1.3.4** | Убедитесь, что предоставленный пользователем файл .SVG проверен или нейтрализован, чтобы он содержал только теги и атрибуты (например, относящиеся к рисованию), которые безопасны для приложения, например, не содержат скриптов и foreignObject. | 2 |\n| **1.3.5** | Убедитесь, что приложение нейтралует или отключает предоставленные пользователем скриптовые данные или выражения шаблонных языков, такие как таблицы стилей Markdown, CSS или XSL, BBCode или аналогичные. | 2 |\n| **1.3.6** | Убедитесь, что приложение защищено от атак с подделкой запросов на стороне сервера (SSRF), проверяя ненадежные данные по разрешенному списку протоколов, доменов, путей и портов, а также нейтрализуя потенциально опасные символы перед использованием данных для вызова другой службы. | 2 |\n| **1.3.7** | Убедитесь, что приложение защищено от атак с внедрением шаблонов (template injection), не позволяя создавать шаблоны на основе недоверенных входных данных. Если нет альтернативы, любые недоверенные входные данные, включаемые динамически во время создания шаблона, должны быть нейтрализованы или тщательно провалидированы. | 2 |\n| **1.3.8** | Убедитесь, что приложение надлежащим образом нейтрализует недоверенные входные данные перед использованием в запросах Java Naming and Directory Interface (JNDI) и что JNDI настроен безопасно для предотвращения атак с использованием JNDI-инъекций. | 2 |\n| **1.3.9** | Убедитесь, что приложение нейтрализует данные перед отправкой в Memcache, чтобы предотвратить атаки методом инъекций. | 2 |\n| **1.3.10** | Убедитесь, что строки форматирования, которые могут быть использованы неожидаемым или вредоносным образом, нейтрализуются перед дальнейшим использованием. | 2 |\n| **1.3.11** | Убедитесь, что приложение нейтрализует вводимые пользователем данные перед передачей в почтовые системы для защиты от SMTP или IMAP-инъекций. | 2 |\n| **1.3.12** | Убедитесь, что регулярные выражения не содержат элементов, вызывающих экспоненциальный возврат, и убедитесь в нейтрализации недоверенных входных данных для предотвращения атак ReDoS или Runaway Regex. | 3 |\n\n## V1.4 Память, строки и неуправляемый код\n\nСледующие требования касаются рисков, связанных с небезопасным использованием памяти, которые обычно применяются, когда приложение использует системный язык или неуправляемый код.\n\nВ некоторых случаях этого можно добиться, установив флаги компилятора, которые включают защиту от переполнения буфера и предупреждения, включая рандомизацию стека и предотвращение выполнения данных, и которые прерывают сборку, если обнаружены небезопасные операции с указателем, памятью, строкой формата, целым числом или строкой.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **1.4.1** | Убедитесь, что для обнаружения или предотвращения ситуаций переполнения стека, буфера или кучи приложение учитывает размер доступной области памяти при строковых операциях, копировании в память, в арифметике указателей и т.п. | 2 |\n| **1.4.2** | Убедитесь, что для предотвращения целочисленного переполнения применяется контроль знака, диапазона и типа допустимых входных данных. | 2 |\n| **1.4.3** | Убедитесь, что динамически выделенная память и ресурсы освобождены, а ссылки или указатели на освобожденную память удалены или установлены в значение null, чтобы предотвратить появление висячих указателей и уязвимостей, связанных с использованием памяти после освобождения. | 2 |\n\n## V1.5 Безопасная десериализация\n\nПреобразование данных из сохраненного или переданного представления в фактические объекты приложения (десериализация) исторически было причиной различных уязвимостей внедрения кода. Важно выполнять этот процесс осторожно и безопасно, чтобы избежать подобных проблем.\n\nВ частности, некоторые методы десериализации были определены в документации по языку программирования или фреймворку как небезопасные и не могут безопасно применяться с недоверенными данными. Для каждого используемого механизма следует проводить тщательную проверку.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **1.5.1** | Убедитесь, что приложение настраивает XML-парсеры на использование строгой конфигурации и что небезопасные функции, такие как разрешение внешних сущностей, отключены для предотвращения атак XML eXternal Entity (XXE). | 1 |\n| **1.5.2** | Убедитесь, что десериализация недоверенных данных обеспечивает безопасную обработку ввода, например, используя список разрешенных типов объектов или ограничивая типы объектов, определяемые клиентом, для предотвращения атак десериализации. Механизмы десериализации, которые явно определены как небезопасные, не должны использоваться с недоверенным вводом. | 2 |\n| **1.5.3** | Убедитесь, что различные парсеры, используемые в приложении для одного и того же типа данных (например, парсеры JSON, XML, URL), выполняют парсинг согласованным образом и используют один и тот же механизм кодирования символов, чтобы избежать таких проблем, как уязвимости взаимодействия JSON (JSON Interoperability) или различное поведение анализа URI или файлов, которые могут использоваться в атаках удаленного включения файлов (RFI) или подделки запросов на стороне сервера (SSRF). | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html)\n* [OWASP Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)\n* [OWASP DOM Based Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)\n* [OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)\n* [OWASP Web Security Testing Guide: Client-Side Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing)\n* [OWASP Java Encoding Project](https://owasp.org/owasp-java-encoder/)\n* [DOMPurify - Client-side HTML Sanitization Library](https://github.com/cure53/DOMPurify)\n* [RFC4180 - Common Format and MIME Type for Comma-Separated Values (CSV) Files](https://datatracker.ietf.org/doc/html/rfc4180#section-2)\n\nДля более подробной информации о проблемах сериализации и парсинга см. также:\n\n* [OWASP Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html)\n* [An Exploration of JSON Interoperability Vulnerabilities](https://bishopfox.com/blog/json-interoperability-vulnerabilities)\n* [Orange Tsai - A New Era of SSRF Exploiting URL Parser In Trending Programming Languages](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)\n", "timestamp": "2025-10-24T11:40:14.574136"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x11-V2-Validation-and-Business-Logic.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x11-V2-Validation-and-Business-Logic.md", "content": "# V2 Валидация и бизнес-логика\n\n## Задачи контроля\n\nЦель этой главы — убедиться, что проверенное приложение соответствует следующим высокоуровневым целям:\n\n* Входные данные, полученные приложением, соответствуют бизнес- или функциональным ожиданиям.\n* Поток бизнес-логики последователен, выполняется по порядку и не может быть обойден.\n* Бизнес-логика содержит ограничения и механизмы для обнаружения и предотвращения автоматизированных атак, таких как постоянные небольшие переводы средств или добавление миллиона друзей по одному за раз.\n* Критически важные потоки бизнес-логики учитывают случаи злоупотреблений и действий злоумышленников и имеют защиту от подмены, подделки, раскрытия информации и атак с повышением привилегий.\n\n## V2.1 Документация валидации и бизнес-логики\n\nДокументация по валидации и бизнес-логике должна четко определять ограничения бизнес-логики, правила валидации и контекстную согласованность объединенных данных, чтобы было понятно, что необходимо реализовать в приложении.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **2.1.1** | Убедитесь, что в документации приложения определены правила проверки входных данных на соответствие ожидаемой структуре. Это могут быть распространённые форматы данных, такие как номера кредитных карт, адреса электронной почты, номера телефонов, или внутренний формат данных. | 1 |\n| **2.1.2** | Убедитесь, что в документации приложения указано, как проверять логическую и контекстную согласованность объединенных данных, например, проверять соответствие района и почтового индекса. | 2 |\n| **2.1.3** | Убедитесь, что ожидания относительно ограничений и проверок бизнес-логики задокументированы как для уровня отдельного пользователя, так и для глобального уровня всего приложения. | 2 |\n\n## V2.2 Валидация ввода\n\nЭффективные средства контроля валидации входных данных обеспечивают соответствие бизнес- или функциональных ожиданий приложения относительно типа данных. Такой контроль валидации обеспечивает высокое качество данных и уменьшает поверхность атаки. Однако такой контроль не устраняет и не заменяет необходимость использования корректного кодирования, параметризации или санитизации данных при использовании данных в другом компоненте или для их представления для вывода.\n\nВ данном контексте «входные данные» могут поступать из самых разных источников, включая поля HTML-форм, запросы REST, параметры URL, поля заголовков HTTP, файлы cookie, файлы на диске, базы данных и внешние API.\n\nМеханизм бизнес-логики может проверять, что конкретное входное значение представляет собой число меньше 100. Функционал будет проверять и ожидать, что число ниже определенного порогового значения, поскольку это число определяет количество повторений конкретного цикла, а большое значение может привести к чрезмерной нагрузке и потенциальному отказу в обслуживании.\n\nХотя валидация по схеме явно не предписана, она может быть наиболее эффективным механизмом для полного охвата валидацией HTTP API или других интерфейсов, использующих JSON или XML.\n\nОбратите внимание на следующие моменты при валидации по схеме:\n\n* «Опубликованная версия» спецификации валидации по JSON-схеме считается готовой к использованию, но, грубо говоря, «нестабильной». При использовании валидации по JSON-схеме убедитесь в отсутствии расхождений с приведенными ниже требованиями.\n* Любые используемые библиотеки валидации по JSON-схеме также следует отслеживать и при необходимости обновлять после формализации стандарта.\n* Валидацию DTD не следует использовать, а оценку DTD фреймворка следует отключить, чтобы избежать проблем с атаками XXE на DTD.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **2.2.1** | Убедитесь, что входные данные провалидированы для обеспечения соответствия бизнес- или функциональным ожиданиям. Валидация должна осуществляться либо по списку допустимых значений, шаблонов и диапазонов, либо путем сравнения входных данных с ожидаемой структурой и логическими ограничениями в соответствии с предопределенными правилами. Для L1 валидация может быть сосредоточена на входных данных, используемых для принятия конкретных бизнес-решений или решений, связанных с безопасностью. Для L2 и выше это должно применяться ко всем входным данным. | 1 |\n| **2.2.2** | Убедитесь, что приложение разработано с принудительной валидацией входных данных на уровне доверенного сервиса. Хотя проверка на стороне клиента повышает удобство использования и должна поощряться, на неё не следует полагаться как на средство контроля безопасности. | 1 |\n| **2.2.3** | Убедитесь, что приложение обеспечивает обоснованность комбинаций данных в соответствии с предопределенными правилам. Например: возраст должен соответствовать дате рождения; страна и почтовый индекс; количество товара в заказе и на складе. | 2 |\n\n## V2.3 Безопасность бизнес-логики\n\nВ этом разделе рассматриваются ключевые требования, гарантирующие, что приложение обеспечит корректное выполнение процессов бизнес-логики и не будет уязвимо для атак, использующих логику и поток работы приложения.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **2.3.1** | Убедитесь, что приложение обрабатывает потоки бизнес-логики для одного и того же пользователя в ожидаемом последовательном порядке шагов и без пропуска шагов. | 1 |\n| **2.3.2** | Убедитесь, что ограничения бизнес-логики реализованы в соответствии с документацией приложения, чтобы избежать эксплуатации её недостатков. | 2 |\n| **2.3.3** | Убедитесь, что транзакции используются на уровне бизнес-логики таким образом, что операция бизнес-логики либо выполняется полностью, либо откатывается к предыдущему корректному состоянию. | 2 |\n| **2.3.4** | Убедитесь, что на уровне бизнес-логики используются механизмы блокировки, чтобы гарантировать невозможность двойного бронирования ограниченных по количеству ресурсов (например, мест в театре или слотов доставки) путем манипулирования логикой приложения. | 2 |\n| **2.3.5** | Убедитесь, что для важных потоков бизнес-логики требуется многопользовательское (multi-user) одобрение, чтобы предотвратить несанкционированные или случайные действия. Потоки бизнес-логики могут включать, помимо прочего, крупные денежные переводы, утверждение контрактов, доступ к секретной информации или обход ограничений безопасности на производстве. | 3 |\n\n## V2.4 Анти-автоматизация\n\nВ этом разделе представлены меры по борьбе с автоматизацией, гарантирующие необходимость взаимодействия, аналогичного человеческому, и предотвращают чрезмерные автоматизированные запросы.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **2.4.1** | Убедитесь, что используются средства противодействия автоматизации для защиты от чрезмерных вызовов функций приложения, которые могут привести к утечке данных, созданию ненужных данных, исчерпанию квот, нарушению ограничений скорости, отказу в обслуживании или чрезмерному использованию дорогостоящих ресурсов. | 2 |\n| **2.4.2** | Убедитесь, что потоки бизнес-логики требуют реалистичного человеческого времени, предотвращая чрезмерно быструю отправку транзакций. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Input Validation Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/README.html)\n* [OWASP Web Security Testing Guide: Business Logic Testing](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/10-Business_Logic_Testing/README)\n* Анти-автоматизация может быть достигнута разными путями, включая применение [OWASP Automated Threats to Web Applications](https://owasp.org/www-project-automated-threats-to-web-applications/)\n* [OWASP Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)\n* [JSON Schema](https://json-schema.org/specification.html)\n", "timestamp": "2025-10-24T11:40:14.707536"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x12-V3-Web-Frontend-Security.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x12-V3-Web-Frontend-Security.md", "content": "# V3 Безопасность веб-интерфейса\n\n## Задачи контроля\n\nЭта категория фокусируется на требованиях, направленных на защиту от атак, воспроизводимых через веб-интерфейс. Эти требования не применяются к решениям «машина-машина».\n\n## V3.1 Документация по безопасности веб-интерфейса\n\nВ этом разделе описываются функции безопасности браузера, которые должны быть описаны в документации приложения.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.1.1** | Убедитесь, что в документации приложения описаны ожидаемые функции безопасности, которые должны поддерживать браузеры, использующие приложение (такие как HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP) и другие соответствующие механизмы безопасности HTTP). В документации также должно быть обязательно определено, как приложение должно себя вести, если некоторые из этих функций недоступны (например, предупреждать пользователя или блокировать доступ). | 3 |\n\n## V3.2 Непреднамеренная интерпретация контента\n\nОтображение контента или функциональности в неправильном контексте может привести к выполнению или отображению вредоносного контента.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.2.1** | Убедитесь, что реализованы меры безопасности, предотвращающие отображение контента или функций браузерами в HTTP-ответах в некорректном контексте (например, запрос API, загруженный пользователем файл или другой ресурс запрашивается напрямую). Возможные способы контроля включают: не обрабатывать содержимое, если поля заголовка HTTP-запроса (например, Sec-Fetch-*) не указывают на корректность контекста; использование заголовка и значения Content-Security-Policy: sandbox directive; или использование заголовка и значения Content-Disposition: attachment. | 1 |\n| **3.2.2** | Убедитесь, что данные, предназначенные для отображения в виде текста, а не визуализации в виде HTML, обрабатывается с использованием безопасных функций визуализации (таких как createTextNode или textContent), чтобы предотвратить непреднамеренное выполнение содержимого, такого как HTML или JavaScript. | 1 |\n| **3.2.3** | Убедитесь, что приложение избегает затирания DOM при использовании JavaScript на стороне клиента, применяя явные объявления переменных, выполняя строгую проверку типов, избегая сохранения глобальных переменных в объекте документа и реализуя изоляцию пространства имен. | 3 |\n\n## V3.3 Настройка файлов cookie\n\nВ этом разделе изложены требования к безопасной настройке чувствительных cookie, позволяющие обеспечить более высокий уровень уверенности в том, что они были созданы самим приложением, а также предотвратить утечку или ненадлежащее изменение их содержимого.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.3.1** | Убедитесь, что у файлов cookie установлен атрибут «Secure», и если префикс «__Host‑» не используется в названии cookie, необходимо использовать префикс «__Secure‑». | 1 |\n| **3.3.2** | Убедитесь, что значение атрибута SameSite каждой cookie установлено в соответствии с назначением cookie, чтобы ограничить подверженность атакам на восстановление пользовательского интерфейса и атакам с подделкой запросов на уровне браузера, обычно называемым подделкой межсайтовых запросов (CSRF). | 2 |\n| **3.3.3** | Убедитесь, что cookie имеют префикс «__Host‑» в названии, если только они явно не предназначены для совместного использования с другими хостами. | 2 |\n| **3.3.4** | Убедитесь, что если значение cookie не должно быть доступно для клиентских скриптов (например, сессионный токен), для cookie должен быть установлен атрибут «HttpOnly», а само значение должно передаваться клиенту только через поле заголовка «Set-Cookie». | 2 |\n| **3.3.5** | Убедитесь, что при записи cookie приложением общая длина имени и значения cookie не превышает 4096 байт. Слишком большие cookie не будут сохраняться браузером и, следовательно, не будут отправляться с запросами, что помешает пользователю использовать функции приложения, зависящие от этого cookie. | 3 |\n\n## V3.4 Заголовки механизма безопасности браузера\n\nВ этом разделе описывается, какие заголовки безопасности следует устанавливать в HTTP-ответах, чтобы включить функции безопасности браузера и ограничения при обработке ответов от приложения.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.4.1** | Убедитесь, что поле заголовка Strict‑Transport‑Security включено во все ответы для реализации политики HTTP Strict Transport Security (HSTS). Необходимо указать максимальное время не менее 1 года, а для L2 и выше политика должна применяться также ко всем поддоменам. | 1 |\n| **3.4.2** | Убедитесь, что поле заголовка Cross‑Origin Resource Sharing (CORS) «Access‑Control‑Allow‑Origin» имеет фиксированное значение, заданное приложением, или, если используется заголовок Origin, оно проверяется по списку доверенных источников. При необходимости использования «Access‑Control‑Allow‑Origin: *» убедитесь, что ответ не содержит конфиденциальной информации. | 1 |\n| **3.4.3** | Убедитесь, что HTTP-ответы содержат поле заголовка Content-Security-Policy, которое определяет директивы, гарантирующие загрузку и выполнение браузером только доверенного контента или ресурсов, чтобы ограничить выполнение вредоносного JavaScript. Как минимум, необходимо использовать глобальную политику, включающую директивы object-src «none» и base-uri «none», а также определяющую список разрешенных адресов или использующую одноразовые коды или хэши. Для приложений L3 необходимо определить политику использования 'nonce' или hash-конструкций для каждого ответа. | 2 |\n| **3.4.4** | Убедитесь, что все HTTP-ответы содержат поле заголовка «X‑Content‑Type‑Options: nosniff». Это предписывает браузерам не использовать анализ контента и определение типа MIME для данного ответа, а также требовать, чтобы значение поля заголовка Content‑Type в ответе соответствовало целевому ресурсу. Например, ответ на запрос стиля принимается только в том случае, если Content‑Type в ответе — «text/css». Это также позволяет браузеру использовать функцию Cross‑Origin Read Blocking (CORB). | 2 |\n| **3.4.5** | Убедитесь, что приложение устанавливает политику реферера для предотвращения утечки технически конфиденциальных данных сторонним сервисам через поле заголовка HTTP-запроса «Referer». Это можно сделать с помощью поля заголовка HTTP-ответа «Referrer‑Policy» или через атрибуты HTML-элемента. Конфиденциальные данные могут включать путь и данные запроса в URL-адресе, а для внутренних непубличных приложений также имя хоста. | 2 |\n| **3.4.6** | Убедитесь, что веб-приложение использует директиву frame‑ancestors поля заголовка Content‑Security‑Policy для каждого HTTP-ответа, чтобы гарантировать невозможность его внедрения по умолчанию и внедрение определённых ресурсов разрешено только при необходимости. Обратите внимание, что поле заголовка X‑Frame‑Options, хотя и поддерживается браузерами, устарело и не может быть использовано в качестве основы. | 2 |\n| **3.4.7** | Убедитесь, что в поле заголовка Content‑Security‑Policy указано место, куда следует сообщать о нарушениях. | 3 |\n| **3.4.8** | Убедитесь, что все HTTP-ответы, инициирующие рендеринг документа (например, ответы с типом содержимого text/html), включают поле заголовка Cross-Origin-Opener-Policy с директивой same-origin или same-origin-allow-popups (при необходимости). Это предотвращает атаки, злоупотребляющие общим доступом к объектам Window, такие как Tabnabbing и Frame Counting. | 3 |\n\n## V3.5 Браузерное разделение источников\n\nПринимая запрос к чувствительному функционалу на стороне сервера, приложение должно убедиться, что запрос инициирован самим приложением или доверенной стороной и не был подделан злоумышленником.\n\nК чувствительному функционалу в данном контексте могут относиться принятие форм POST для аутентифицированных и неаутентифицированных пользователей (например, запрос аутентификации), операции по изменению состояния или ресурсоемкие функции (например, экспорт данных).\n\nКлючевыми средствами защиты здесь являются политики безопасности браузера, такие как Same Origin Policy для JavaScript и логика SameSite для cookie. Другим распространённым средством защиты является механизм предварительной проверки CORS. Этот механизм критически важен для конечных точек, спроектированных и предназначенных, чтобы вызываться из другого источника, но он также может быть полезным механизмом предотвращения подделки запросов для конечных точек, которые не предназначены для вызова из другого источника.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.5.1** | Убедитесь, что, если приложение не использует механизм предварительной проверки CORS для предотвращения запрещённых кросс-доменных запросов на использование чувствительного функционала, эти запросы валидируются на предмет их происхождения от самого приложения. Это можно сделать, используя и проверяя специальные токены для защиты от подделки или требуя дополнительные поля HTTP-заголовка, не входящие в список «простых заголовков» (CORS-safelisted request-header). Это необходимо для защиты от атак с подделкой запросов через браузер, широко известных как межсайтовая подделка запросов (CSRF). | 1 |\n| **3.5.2** | Убедитесь, что если приложение использует механизм предварительной проверки CORS для предотвращения неразрешённого использования чувствительного функционала между источниками, вызов этого функционала невозможен с помощью запроса, который не запускает предварительную проверку CORS. Для этого может потребоваться проверка значений полей заголовка запроса «Origin» и «Content-Type» или использование дополнительного поля заголовка, не входящего в безопасный список CORS. | 1 |\n| **3.5.3** | Убедитесь, что HTTP-запросы к чувствительному функционалу используют соответствующие HTTP-методы, такие как POST, PUT, PATCH или DELETE, а не методы, определённые спецификацией HTTP как «безопасные», такие как HEAD, OPTIONS или GET. В качестве альтернативы можно использовать строгую валидацию полей заголовка запроса Sec‑Fetch‑*, чтобы убедиться, что запрос не исходит из недопустимого кросс-доменного вызова, навигационного запроса или загрузки ресурса (например, источника изображения), где это не ожидается. | 1 |\n| **3.5.4** | Убедитесь, что отдельные приложения размещены на разных именах хостов, чтобы использовать ограничения, предусмотренные политикой same-origin, включая то, как документы или скрипты, загруженные одним источником, могут взаимодействовать с ресурсами из другого источника, а также ограничения на cookie на основе имени хоста. | 2 |\n| **3.5.5** | Убедитесь, что сообщения, полученные интерфейсом postMessage, отвергаются, если источник сообщения не является доверенным или если синтаксис сообщения недействителен. | 2 |\n| **3.5.6** | Убедитесь, что функциональность JSONP не включена нигде в приложении, чтобы избежать атак с использованием межсайтового включения скриптов (XSSI). | 3 |\n| **3.5.7** | Убедитесь, что данные, требующие авторизации, не включены в ответы ресурсов скриптов, таких как файлы JavaScript, чтобы предотвратить атаки с использованием межсайтового включения скриптов (XSSI). | 3 |\n| **3.5.8** | Убедитесь, что аутентифицированные ресурсы (такие как изображения, видео, скрипты и другие документы) могут быть загружены или внедрены от имени пользователя только по назначению. Этого можно добиться путём строгой валидации полей заголовка HTTP-запроса Sec‑Fetch‑*, чтобы убедиться, что запрос не исходит из недопустимого кросс-доменного вызова, или путём установки ограничительного поля заголовка HTTP-ответа Cross‑Origin‑Resource‑Policy, чтобы браузер блокировал возвращаемый контент. | 3 |\n\n## V3.6 Целостность внешних ресурсов\n\nВ этом разделе приведены рекомендации по безопасному размещению контента на сторонних сайтах.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.6.1** | Убедитесь, что клиентские ресурсы, такие как библиотеки JavaScript, CSS или веб-шрифты, размещаются только на внешнем сервере (например, в сети доставки контента (Content Delivery Network)), если ресурс статический и имеет версии, а для проверки целостности ресурса используется механизм проверки целостности подресурсов (SRI). Если это невозможно, для каждого ресурса должно быть задокументировано решение по безопасности, обосновывающее это. | 3 |\n\n## V3.7 Другие соображения по безопасности браузера\n\nВ этом разделе рассматриваются различные другие элементы управления безопасностью и современные функции безопасности браузера, необходимые для обеспечения безопасности браузера на стороне клиента.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **3.7.1** | Убедитесь, что приложение использует только те клиентские технологии, которые по-прежнему поддерживаются и считаются безопасными. Примерами технологий, не соответствующих этому требованию, являются плагины NSAPI, Flash, Shockwave, ActiveX, Silverlight, NACL или клиентские Java-апплеты. | 2 |\n| **3.7.2** | Убедитесь, что приложение будет автоматически перенаправлять пользователя на другое имя хоста или домен (который не контролируется приложением), только если этот хост или домен указаны в списке разрешенных. | 2 |\n| **3.7.3** | Убедитесь, что приложение отображает уведомление, что пользователь перенаправляется на URL-адрес, находящийся вне контроля приложения, с возможностью отмены навигации. | 3 |\n| **3.7.4** | Убедитесь, что домен верхнего уровня приложения (например, site.tld) ​​добавлен в публичный список предварительной загрузки (preload list) для HTTP Strict Transport Security (HSTS). Это гарантирует, что использование TLS для приложения будет встроено непосредственно в основные браузеры, а не будет полагаться только на поле заголовка ответа Strict-Transport-Security. | 3 |\n| **3.7.5** | Убедитесь, что приложение ведет себя так, как описано в документации (например, предупреждает пользователя или блокирует доступ), если браузер, используемый для доступа к приложению, не поддерживает ожидаемые функции безопасности. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [Set-Cookie __Host- prefix details](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#cookie_prefixes)\n* [OWASP Content Security Policy Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)\n* [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)\n* [HSTS Browser Preload List submission form](https://hstspreload.org/)\n* [OWASP DOM Clobbering Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_Clobbering_Prevention_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:14.890660"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x13-V4-API-and-Web-Service.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x13-V4-API-and-Web-Service.md", "content": "# V4 API и Веб-сервис\n\n## Задачи контроля\n\nСуществует несколько моментов, применимых только к приложениям, предоставляющим API для использования веб-браузерами или другими клиентами (обычно с использованием JSON, XML или GraphQL). В этой главе рассматриваются соответствующие настройки и механизмы безопасности, которые следует применять.\n\nОбратите внимание, что вопросы аутентификации, управления сессиями и проверки входных данных, рассмотренные в других главах, также относятся к API. Поэтому эту главу нельзя рассматривать изолированно или тестировать отдельно.\n\n## V4.1 Общая безопасность веб-сервисов\n\nВ этом разделе рассматриваются общие вопросы безопасности веб-сервисов и базовые практики гигиены веб-сервисов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **4.1.1** | Убедитесь, что каждый HTTP-ответ с телом сообщения содержит заголовок Content-Type, который соответствует фактическому содержимому ответа, таким как «text/», «/+xml» и «/xml», включая параметр charset для указания безопасной кодировки символов (например, UTF-8, ISO-8859-1) согласно IANA Media Types. | 1 |\n| **4.1.2** | Убедитесь, что только конечные точки, предназначенные для взаимодействия с пользователем через веб-браузер, автоматически перенаправляют HTTP на HTTPS, в то время как другие сервисы или конечные точки не реализуют прозрачные редиректы. Это необходимо, чтобы избежать ситуации, когда клиент ошибочно отправляет незашифрованные HTTP-запросы а из-за того, что запрос по HTTP автоматически перенаправляется на HTTPS другим сервисом без обработки на входе, утечка чувствительных данных остаётся незамеченной. | 2 |\n| **4.1.3** | Убедитесь, что любой HTTP-заголовок, используемый приложением и устанавливаемый промежуточным уровнем, таким как балансировщик нагрузки, веб-прокси или backend-for-frontend сервис, не может быть переопределён конечным пользователем. Примеры заголовков: X-Real-IP, X-Forwarded-*, X-User-ID. | 2 |\n| **4.1.4** | Убедитесь, что разрешены только HTTP-методы, которые явно поддерживаются приложением или его API (включая OPTIONS для preflight-запросов), а неиспользуемые методы заблокированы. | 3 |\n| **4.1.5** | Убедитесь, что для особо чувствительных запросов или транзакций, проходящих через несколько систем, используются цифровые подписи на уровне сообщений, дополнительно к транспортным средствам защиты. | 3 |\n\n## V4.2 Валидация структуры HTTP-сообщений\n\nЭтот раздел объясняет, как должна проверяться структура и заголовки HTTP-сообщений, чтобы предотвратить атаки типа request smuggling, response splitting, header injection и отказ в обслуживании из-за слишком длинных HTTP-сообщений.\n\nЭти требования актуальны для обработки и генерации HTTP-сообщений в целом, но особенно важны при конвертации сообщений между разными версиями HTTP.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **4.2.1** | Убедитесь, что все компоненты приложения (включая балансировщики нагрузки, файрволы и серверы приложений) определяют границы входящих HTTP-сообщений с использованием механизма, соответствующего версии HTTP, чтобы предотвратить HTTP request smuggling. В HTTP/1.x, если присутствует заголовок Transfer-Encoding, заголовок Content-Length должен игнорироваться согласно RFC 2616. При использовании HTTP/2 или HTTP/3, если присутствует Content-Length, веб-сервер должен убедиться, что он совпадает с длиной DATA-фреймов. | 2 |\n| **4.2.2** | Убедитесь, что при генерации HTTP-сообщений заголовок Content-Length не конфликтует с длиной содержимого, определяемой рамками протокола HTTP, чтобы предотвратить HTTP Request Smuggling. | 3 |\n| **4.2.3** | Убедитесь, что приложение не отправляет и не принимает HTTP/2 и HTTP/3 сообщения с заголовками, специфичными для соединения, такими как Transfer-Encoding, чтобы предотвратить HTTP Response Splitting и HTTP Header Injection. | 3 |\n| **4.2.4** | Убедитесь, что приложение принимает HTTP/2 и HTTP/3 запросы только в случае, если поля заголовков и их значения не содержат последовательностей CR (\\r), LF (\\n) или CRLF (\\r\\n), чтобы предотвратить HTTP Header Injection. | 3 |\n| **4.2.5** | Убедитесь, что если приложение (бекенд или фронтенд) формирует и отправляет запросы, оно использует валидацию, очистку или другие механизмы, чтобы не создавать URI (например, для API-вызовов) или HTTP-заголовки (например, Authorization или Cookie) слишком большой длины, чтобы их не принимал приёмник. Это может привести к отказу в обслуживании, например, при отправке слишком длинного запроса (длинный cookie-заголовок), из-за чего сервер постоянно возвращает ошибку. | 3 |\n\n## V4.3 GraphQL\n\nGraphQL становится всё более популярным способом создания клиентов с большим объёмом данных, которые не жёстко связаны с разными бэкенд-сервисами. В этом разделе рассмотрены вопросы безопасности для GraphQL.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **4.3.1** | Убедитесь, что используется белый список запросов, ограничение глубины вложенности, ограничение количества или анализ стоимости запроса, чтобы предотвратить DoS-атаки на уровне GraphQL или слоя данных из-за дорогостоящих вложенных запросов. | 2 |\n| **4.3.2** | Убедитесь, что introspection-запросы GraphQL отключены в продакшен-среде, если GraphQL API не предназначен для использования сторонними клиентами. | 2 |\n\n## V4.4 WebSocket\n\nWebSocket — это протокол связи, обеспечивающий двунаправленную одновременную коммуникацию по одному TCP-соединению. Он был стандартизирован IETF в RFC 6455 в 2011 году и отличается от HTTP, хотя и работает поверх портов HTTP 443 и 80.\n\nВ этом разделе приведены основные требования по безопасности, чтобы предотвратить атаки, связанные с безопасностью коммуникаций и управлением сессиями, которые эксплуатируют этот канал реального времени.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **4.4.1** | Убедитесь, что для всех WebSocket-соединений используется WebSocket поверх TLS (WSS). | 1 |\n| **4.4.2** | Убедитесь, что при первоначальном HTTP WebSocket handshake заголовок Origin проверяется на соответствие списку разрешённых источников для приложения. | 2 |\n| **4.4.3** | Убедитесь, что если стандартное управление сессиями приложения не может быть использовано, применяются специальные токены, соответствующие требованиям безопасности управления сессиями. | 2 |\n| **4.4.4** | Убедитесь, что специальные токены управления сессиями WebSocket изначально получаются или валидируются через ранее аутентифицированную HTTPS-сессию при переходе от HTTPS к WebSocket. | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n* Ресурсы по авторизации GraphQL от [graphql.org](https://graphql.org/learn/authorization/) и [Apollo](https://www.apollographql.com/docs/apollo-server/security/authentication/#authorization-methods).\n* [OWASP Web Security Testing Guide: GraphQL Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/12-API_Testing/01-Testing_GraphQL)\n* [OWASP Web Security Testing Guide: Testing WebSockets](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/10-Testing_WebSockets)\n", "timestamp": "2025-10-24T11:40:15.039808"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x14-V5-File-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x14-V5-File-Handling.md", "content": "# V5 Работа с файлами\n\n## Задачи контроля\n\nИспользование файлов может нести различные риски для приложения, включая отказ в обслуживании (DoS), несанкционированный доступ и переполнение хранилища. В этой главе приведены требования, для предотвращения этих рисков.\n\n## V5.1 Документация по работе с файлами\n\nЭтот раздел содержит требование документировать ожидаемые характеристики файлов, принимаемых приложением, как необходимое условие для разработки и проверки соответствующих мер безопасности.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **5.1.1** | Убедитесь, что документация определяет допустимые типы файлов, ожидаемые расширения и максимальный размер (включая распакованный размер) для каждой функции загрузки. Также убедитесь, что в документации указано, как файлы обезвреживаются для конечных пользователей (например, как приложение ведёт себя при обнаружении вредоносного файла). | 2 |\n\n## V5.2 Загрузка файлов и содержимое\n\nФункциональность загрузки файлов является основным источником недоверенных файлов. Этот раздел описывает требования, обеспечивающие безопасность приложения от вреда, связанного с наличием, объёмом или содержимым этих файлов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **5.2.1** | Убедитесь, что приложение принимает только те файлы, которые может обработать без потери производительности или отказа в обслуживании. | 1 |\n| **5.2.2** | Убедитесь, что при загрузке файла (включая файлы внутри архивов, таких как ZIP) приложение проверяет, соответствует ли расширение ожидаемому, и валидирует, соответствует ли содержимое типу, указанному в расширении. Это включает проверку начальных 'magic bytes', перезапись изображений, использование специализированных библиотек. Для уровня 1 — достаточно проверок для файлов, критичных с точки зрения бизнеса или безопасности. Для уровней 2 и выше — для всех файлов. | 1 |\n| **5.2.3** | Убедитесь, что приложение проверяет архивы (например, zip, gz, docx, odt) на максимально допустимый распакованный размер и максимальное количество файлов до распаковки. | 2 |\n| **5.2.4** | Убедитесь, что для каждого пользователя установлены квоты на общий размер и количество файлов, чтобы один пользователь не мог переполнить хранилище. | 3 |\n| **5.2.5** | Убедитесь, что приложение не позволяет загружать архивы с символьными ссылками (symlinks), если это не требуется по бизнес-логике. Если требуется — разрешён только строго определённый список допустимых символьных ссылок. | 3 |\n| **5.2.6** | Убедитесь, что приложение отклоняет изображения с числом пикселей выше допустимого, чтобы предотвратить атаки 'pixel flood'. | 3 |\n\n## V5.3 Хранение файлов\n\nЭтот раздел содержит требования для предотвращения исполнения файлов после загрузки, обнаружения опасного содержимого и предотвращения использования недоверенных данных для управления путями хранения файлов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **5.3.1** | Убедитесь, что загруженные или сгенерированные из недоверенного ввода файлы, находящиеся в публичной директории, не исполняются как серверный код при обращении к ним по HTTP. | 1 |\n| **5.3.2** | Убедитесь, что при создании путей к файлам приложение использует внутренние или доверенные данные, а не пользовательские имена файлов. Если использование пользовательских имён или метаданных необходимо — требуется строгая проверка и очистка. Это защита от path traversal, LFI, RFI и SSRF. | 1 |\n| **5.3.3** | Убедитесь, что при обработке файлов на сервере (например, при распаковке) игнорируются пути, заданные пользователем, во избежание уязвимостей типа 'zip slip'. | 3 |\n\n## V5.4 Скачивание файлов\n\nЭтот раздел содержит требования для снижения рисков при выдаче файлов на загрузку, включая защиту от path traversal и инъекций, а также проверку содержимого.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **5.4.1** | Убедитесь, что приложение валидирует или игнорирует имена файлов, переданных пользователем (включая в JSON, JSONP или URL-параметре), и указывает имя файла в заголовке Content-Disposition при ответе. | 2 |\n| **5.4.2** | Убедитесь, что имена файлов, передаваемые (например, в HTTP-заголовках или вложениях в email), кодируются или очищаются (например, по RFC 6266), чтобы сохранить структуру документа и предотвратить инъекции. | 2 |\n| **5.4.3** | Убедитесь, что файлы, полученные из недоверенных источников, сканируются антивирусом, чтобы не распространять известное вредоносное содержимое. | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)\n* [Example of using symlinks for arbitrary file read](https://hackerone.com/reports/1439593)\n* [Explanation of \"Magic Bytes\" from Wikipedia](https://en.wikipedia.org/wiki/List_of_file_signatures)\n", "timestamp": "2025-10-24T11:40:15.165010"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x15-V6-Authentication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x15-V6-Authentication.md", "content": "# V6 Аутентификация\n\n## Задачи контроля\n\nАутентификация — это процесс установления или подтверждения подлинности личности или устройства. Он включает в себя проверку заявленных данных, устойчивость к подмене личности и защиту от перехвата или восстановления паролей.\n\n[Документ NIST SP 800-63](https://pages.nist.gov/800-63-3/) является современным и основанным на фактических данных стандартом, особенно актуальным для государственных структур США и организаций, взаимодействующих с ними.\n\nХотя многие требования этой главы основаны на разделе NIST SP 800-63B («Руководство по цифровой идентификации — Управление аутентификацией и жизненным циклом»), акцент сделан на распространённых угрозах и часто эксплуатируемых слабостях. Эта глава не охватывает весь стандарт. Для полной реализации NIST SP 800-63 необходимо обратиться к оригиналу.\n\nВ тексте используется более понятная терминология, отличающаяся от формулировок NIST.\n\nМногие современные приложения адаптируют этапы аутентификации в зависимости от уровня риска. Эти механизмы рассматриваются в главе «Авторизация», поскольку они также касаются авторизационных решений.\n\n## V6.1 Документация по аутентификации\n\nЭтот раздел содержит требования к документации по аутентификации, которую необходимо вести для приложения. Это критически важно для того, чтобы правильно настроить и оценить соответствующие механизмы управления аутентификацией.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.1.1** | Убедитесь, что в документации приложения описано, как используются механизмы, такие как ограничение частоты запросов (rate limiting), защита от автоматизации и адаптивные реакции, для защиты от атак, таких как подстановка учётных данных и перебор паролей. Документация должна ясно описывать конфигурацию этих механизмов и предотвращение злонамеренной блокировки аккаунтов. | 1 |\n| **6.1.2** | Убедитесь, что задокументирован список контекстно-зависимых слов, запрещённых к использованию в паролях. В него могут входить производные от названий организаций, продуктов, идентификаторов систем, кодовых названий проектов, названий отделов или ролей и тому подобное. | 2 |\n| **6.1.3** | Убедитесь, что если приложение поддерживает несколько способов аутентификации, то все они документированы вместе с описанием применяемых средств защиты и уровнем стойкости аутентификации, которые должны быть одинаково применены ко всем способам. | 2 |\n\n## V6.2 Безопасность паролей\n\nПароли (в терминологии NIST SP 800-63 — «запоминаемые секреты») включают в себя пароли, кодовые фразы, PIN-коды, графические шаблоны разблокировки и, например, выбор нужного котёнка или другого элемента на изображении. Они относятся к категории «что-то, что вам известно» и часто используются как однофакторный механизм аутентификации.\n\nСоответственно, в этом разделе перечислены требования, направленные на безопасное создание и обработку паролей. Большинство требований относятся к уровню L1, поскольку на этом уровне они наиболее важны. Начиная с уровня L2, требуется использование многофакторной аутентификации, в которой пароли могут быть одним из факторов.\n\nТребования в данном разделе в основном соответствуют [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) [руководства NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.2.1** | Убедитесь, что пользовательские пароли содержат не менее 8 символов. Рекомендуется минимальная длина в 15 символов. | 1 |\n| **6.2.2** | Убедитесь, что пользователи могут менять свои пароли. | 1 |\n| **6.2.3** | Убедитесь, что для смены пароля требуется ввести как текущий, так и новый пароль. | 1 |\n| **6.2.4** | Убедитесь, что при регистрации или смене пароля введённый пароль проверяется по списку как минимум из 3000 самых популярных паролей, соответствующих политике (например, минимальной длине). | 1 |\n| **6.2.5** | Убедитесь, что допускаются пароли любой структуры, без ограничений на использование определённых символов. Не должно быть требований по обязательному наличию заглавных/строчных букв, цифр или специальных символов. | 1 |\n| **6.2.6** | Убедитесь, что поля ввода пароля используют type=password для скрытия символов. Разрешено временное отображение всего пароля или последнего введённого символа. | 1 |\n| **6.2.7** | Убедитесь, что разрешены вставка (paste), использование менеджеров паролей браузера и внешних менеджеров паролей. | 1 |\n| **6.2.8** | Убедитесь, что пароль проверяется строго в том виде, в котором он был введён пользователем — без обрезки, изменения регистра и других модификаций. | 1 |\n| **6.2.9** | Убедитесь, что система позволяет использовать пароли длиной не менее 64 символов. | 2 |\n| **6.2.10** | Убедитесь, что пароль остаётся действительным, пока не будет скомпрометирован или не будет изменён пользователем. Приложение не должно требовать регулярной смены пароля. | 2 |\n| **6.2.11** | Убедитесь, что используется документированный список контекстно-зависимых слов (например, названия компаний, проектов и т.д.) для предотвращения использования легко угадываемых паролей. | 2 |\n| **6.2.12** | Убедитесь, что при регистрации или смене пароля проверяется, не входит ли он в список скомпрометированных (утёкших) паролей. | 2 |\n\n## V6.3 Общие требования к безопасности аутентификации\n\nВ этом разделе изложены общие требования к безопасности механизмов аутентификации, а также различные ожидания для разных уровней защиты. Для приложений уровня L2 обязательно использование многофакторной аутентификации (MFA). Для приложений уровня L3 требуется аппаратная аутентификация, выполняемая в аттестованной и доверенной среде исполнения (TEE). Это может включать: ключи passkey, привязанные к устройству; аутентификаторы, соответствующие eIDAS LoA High; аутентификаторы с уровнем доверия NIST AAL3; или эквивалентные механизмы.\n\nЭто достаточно строгий подход к MFA, но он необходим для повышения уровня защиты пользователей. Любое смягчение этих требований должно сопровождаться документированным обоснованием и чётким планом по смягчению рисков с учётом рекомендаций и исследований NIST.\n\nОбратите внимание: на момент публикации NIST SP 800-63 рассматривает email как [недопустимый](https://pages.nist.gov/800-63-FAQ/#q-b11) механизм аутентификации ([archived copy](https://web.archive.org/web/20250330115328/https://pages.nist.gov/800-63-FAQ/#q-b11)).\n\nТребования в этом разделе опираются на следующие части [руководства NIST](https://pages.nist.gov/800-63-3/sp800-63b.html), including: [&sect; 4.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#421-permitted-authenticator-types), [&sect; 4.3.1](https://pages.nist.gov/800-63-3/sp800-63b.html#431-permitted-authenticator-types), [&sect; 5.2.2](https://pages.nist.gov/800-63-3/sp800-63b.html#522-rate-limiting-throttling), и [&sect; 6.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-612-post-enrollment-binding).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.3.1** | Убедитесь, что реализованы меры защиты от атак типа credential stuffing (массовая подстановка учётных данных) и brute-force (перебор паролей), согласно документации по безопасности приложения. | 1 |\n| **6.3.2** | Убедитесь, что в приложении отсутствуют или отключены учётные записи по умолчанию (например, root, admin, sa). | 1 |\n| **6.3.3** | Убедитесь, что для доступа к приложению используется либо механизм многофакторной аутентификации, либо комбинация однофакторных. Для уровня L3 один из факторов должен быть аппаратным, обеспечивающим защиту от фишинга, устойчивость к компрометации и подтверждение намерения аутентификации через явное действие пользователя (например, нажатие кнопки на FIDO-ключе или телефоне). Ослабление этих требований допускается только при наличии обоснования и компенсирующих мер. | 2 |\n| **6.3.4** | Убедитесь, что при наличии нескольких способов аутентификации, они все задокументированы, и для них единообразно применяются меры защиты и уровни доверия. | 2 |\n| **6.3.5** | Убедитесь, что пользователи получают уведомления о подозрительных попытках аутентификации (удачных и неудачных). Это может включать попытки (например, подключения) с необычного устройства или места, частично успешную MFA, попытку после долгого отсутствия или успешную аутентификацию после серии неудачных. | 3 |\n| **6.3.6** | Убедитесь, что email не используется ни как однофакторный, ни как многофакторный механизм аутентификации. | 3 |\n| **6.3.7** | Убедитесь, что пользователи получают уведомление при изменении данных аутентификации, таких как сброс пароля или изменение логина/email. | 3 |\n| **6.3.8** | Убедитесь, что из сообщений об ошибке, HTTP-кодов ответа или различий во времени ответа нельзя определить, существует ли пользователь с таким логином. Это правило также должно применяться к функциям регистрации и восстановления пароля. | 3 |\n\n## V6.4 Жизненный цикл и восстановление факторов аутентификации\n\nФакторы аутентификации могут включать пароли, программные токены (soft tokens), аппаратные токены (hardware tokens) и биометрические устройства. Безопасное управление жизненным циклом этих механизмов критически важно для безопасности приложения, и данный раздел включает соответствующие требования.\n\nТребования в этом разделе в основном соответствуют разделам [&sect; 5.1.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) или [&sect; 6.1.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#replacement) [руководства NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.4.1** | Убедитесь, что начальные пароли или коды активации, генерируемые системой, создаются с использованием надёжного генератора случайных чисел, соответствуют текущей политике паролей и истекают через короткий период времени либо после первого использования. Эти секреты не должны использоваться как постоянные пароли. | 1 |\n| **6.4.2** | Убедитесь, что в системе отсутствуют подсказки к паролю или вопросы на знание («секретные вопросы»). | 1 |\n| **6.4.3** | Убедитесь, что реализован безопасный процесс сброса забытого пароля, который не обходит активные механизмы многофакторной аутентификации. | 2 |\n| **6.4.4** | Убедитесь, что в случае утраты одного из факторов MFA проводится удостоверение личности (identity proofing) на том же уровне, что и при первичной регистрации. | 2 |\n| **6.4.5** | Убедитесь, что инструкции по обновлению истекающих механизмов аутентификации отправляются заранее, с достаточным запасом времени для выполнения замены, при необходимости с настройкой автоматических напоминаний. | 3 |\n| **6.4.6** | Убедитесь, что администраторы могут инициировать процесс сброса пароля, но не могут задать или выбрать новый пароль за пользователя. Это исключает ситуацию, при которой администратор знает пароль пользователя. | 3 |\n\n## V6.5 Общие требования к многофакторной аутентификации\n\nЭтот раздел содержит общие рекомендации, применимые к различным методам многофакторной аутентификации (MFA).\n\nК таким механизмам относятся:\n\n* Lookup-секреты\n* Временные одноразовые пароли (TOTP)\n* Out-of-Band (внеполосные) механизмы\n\nLookup-секреты — заранее сгенерированные списки одноразовых кодов, аналогичные TAN-кодам (Transaction Authorization Numbers), кодам восстановления для соцсетей или таблицам с наборами случайных значений. Эти коды считаются фактором типа «что-то, что у вас есть», поскольку они не запоминаются и должны быть где-то сохранены.\n\nВременные одноразовые пароли (TOTP) — аппаратные или программные токены, генерирующие постоянно меняющиеся псевдослучайные коды. Это также фактор типа «что-то, что у вас есть». MFA-варианты TOTP предполагают дополнительное подтверждение — например, PIN-код, биометрию, вставку USB-ключа, NFC или дополнительные значения (например, калькуляторы для подписания транзакций).\n\nOut-of-Band (внеполосные) механизмы рассматриваются в следующем разделе.\n\nТребования этого раздела в основном соответствуют [&sect; 5.1.2](https://pages.nist.gov/800-63-3/sp800-63b.html#-512-look-up-secrets), [&sect; 5.1.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-513-out-of-band-devices), [&sect; 5.1.4.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5142-single-factor-otp-verifiers), [&sect; 5.1.5.2](https://pages.nist.gov/800-63-3/sp800-63b.html#5152-multi-factor-otp-verifiers), [&sect; 5.2.1](https://pages.nist.gov/800-63-3/sp800-63b.html#521-physical-authenticators), и [&sect; 5.2.3](https://pages.nist.gov/800-63-3/sp800-63b.html#523-use-of-biometrics) [руководства NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.5.1** | Убедитесь, что lookup-секреты, внеполосные коды/запросы и TOTP-коды можно использовать только один раз. | 2 |\n| **6.5.2** | Убедитесь, что при хранении lookup-секретов с энтропией менее 112 бит (например, 19 случайных буквенно-цифровых символов или 34 случайные цифры) они хэшируются с использованием разрешённого алгоритма хеширования паролей и случайной соли минимум 32 бита. Если у секрета ≥112 бит энтропии — допустимо использовать стандартный хэш. | 2 |\n| **6.5.3** | Убедитесь, что lookup-секреты, коды внеполосной аутентификации и сиды для TOTP генерируются с использованием криптографически стойкого генератора случайных чисел (CSPRNG), чтобы избежать предсказуемых значений. | 2 |\n| **6.5.4** | Убедитесь, что lookup-секреты и внеполосные коды аутентификации имеют минимум 20 бит энтропии (достаточно, например, 4 случайных алфавитно-цифровых символов или 6 случайных цифр). | 2 |\n| **6.5.5** | Убедитесь, что все внеполосные запросы, коды и токены, а также TOTP-коды имеют ограниченный срок действия. Максимум для out-of-band — 10 минут, для TOTP — 30 секунд. | 2 |\n| **6.5.6** | Убедитесь, что любой фактор аутентификации (включая физические устройства) может быть отозван в случае кражи или утери. | 3 |\n| **6.5.7** | Убедитесь, что биометрические механизмы аутентификации используются только как вторичный фактор — в сочетании с «чем-то, что вы знаете» или «чем-то, что у вас есть». | 3 |\n| **6.5.8** | Убедитесь, что TOTP-коды проверяются по источнику времени, полученному от доверенного сервиса, а не от клиента или недоверенного источника. | 3 |\n\n## V6.6 Внеполосные механизмы аутентификации\n\nОбычно внеполосная аутентификация предполагает, что сервер аутентификации взаимодействует с физическим устройством пользователя через безопасный вторичный канал. Например, путём отправки push-уведомления на мобильное устройство. Такой механизм считается фактором типа «что-то, что у вас есть».\n\nНебезопасные внеполосные методы аутентификации, такие как электронная почта и VOIP, не допускаются. Аутентификация через PSTN и SMS в настоящее время [считается ограниченной](https://pages.nist.gov/800-63-FAQ/#q-b01) по версии NIST и должна постепенно заменяться на временные одноразовые пароли (TOTP), криптографические механизмы или аналогичные средства. Руководство NIST SP 800-63B [&sect; 5.1.3.3](https://pages.nist.gov/800-63-3/sp800-63b.html#-5133-authentication-using-the-public-switched-telephone-network) рекомендует принимать меры против таких угроз, как замена устройства, смена SIM-карты, перенос номера и прочие аномалии, если всё же приходится использовать телефонную или SMS-аутентификацию. Хотя этот раздел ASVS не требует строго выполнять эти рекомендации, их игнорирование для чувствительных приложений уровня L2 или L3 считается серьёзным сигналом риска.\n\nТакже стоит отметить, что NIST недавно выпустил рекомендации, в которых отговаривает от [использования push-уведомлений](https://pages.nist.gov/800-63-4/sp800-63b/authenticators/#fig-3). Хотя ASVS пока этого не запрещает, важно учитывать риск push-бомбинга (массовой отправки уведомлений для перегрузки пользователя).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.6.1** | Убедитесь, что механизмы аутентификации через телефонную сеть общего пользования (PSTN) для доставки одноразовых паролей (OTP) по телефону или SMS используются только в случае предварительной валидации номера, при этом предлагаются альтернативные более безопасные методы (например, TOTP), и пользователю сообщаются риски. Для приложений уровня L3 использование телефона и SMS недопустимо. | 2 |\n| **6.6.2** | Убедитесь, что внеполосные запросы, коды или токены привязаны к исходному запросу аутентификации, для которого они были сгенерированы, и не могут быть использованы повторно для других попыток. | 2 |\n| **6.6.3** | Убедитесь, что внеполосные механизмы на основе кода защищены от атак методом подбора (brute force) путём применения ограничения частоты запросов (rate limiting). Также рекомендуется использовать коды с энтропией не менее 64 бит. | 2 |\n| **6.6.4** | Убедитесь, что при использовании push-уведомлений для MFA применяется ограничение частоты (rate limiting), чтобы предотвратить атаки push-бомбинга. Также может помочь механизм сопоставления номеров (number matching). | 3 |\n\n## V6.7 Криптографические механизмы аутентификации\n\nКриптографические механизмы аутентификации включают, например, смарт-карты или ключи FIDO, при использовании которых пользователь должен подключить или сопрячь криптографическое устройство с компьютером для завершения аутентификации. Аутентификационный сервер отправляет случайную строку (nonce) на криптографическое устройство или программное обеспечение, и устройство или программа вычисляет ответ на основе надежно хранимого криптографического ключа. Требования в этом разделе содержат рекомендации по реализации подобных механизмов. Рекомендации по выбору криптографических алгоритмов приведены в главе «Криптография».\n\nЕсли для криптографической аутентификации используются общие или секретные ключи, они должны храниться с использованием тех же механизмов, что и другие системные секреты — как указано в разделе «Управление секретами» главы «Конфигурация».\n\nТребования этого раздела в основном соответствуют пункту [&sect; 5.1.7.2](https://pages.nist.gov/800-63-3/sp800-63b.html#sfcdv) [руководства NIST](https://pages.nist.gov/800-63-3/sp800-63b.html).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.7.1** | Убедитесь, что сертификаты, используемые для проверки криптографических утверждений об аутентификации, хранятся таким образом, чтобы исключить возможность их модификации. | 3 |\n| **6.7.2** | Убедитесь, что nonce (случайная строка), используемая в процессе вызова, имеет длину не менее 64 бит и является статистически уникальной или уникальной на протяжении всего срока службы криптографического устройства. | 3 |\n\n## V6.8 Аутентификация с использованием провайдера идентификаций (IdP)\n\nПровайдеры идентификаций (IdP) предоставляют пользователям федеративную идентификацию. У одного пользователя может быть несколько различных идентификаторов через разные IdP, например, корпоративная учётная запись через Azure AD, Okta, Ping Identity или Google, а также потребительская через Facebook, Twitter, Google или WeChat. Этот перечень не является рекламой данных сервисов, а лишь отражает реальность: у многих пользователей есть уже существующие идентификации. Организациям стоит учитывать возможность интеграции с такими внешними IdP в зависимости от уровня доверия к процедурам подтверждения личности у этих провайдеров. Например, государственная система вряд ли примет соцсети в качестве логина, так как там легко создать фальшивую учётную запись, а вот мобильной игре может быть полезна авторизация через соцсети для роста пользовательской базы.\n\nБезопасное использование внешних IdP требует тщательной настройки и проверки, чтобы не допустить подделки личности или ложных утверждений (assertions). Данный раздел описывает требования, направленные на снижение этих рисков.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **6.8.1** | Убедитесь, что при поддержке несколькими IdP, невозможно подделать личность пользователя через другой IdP (например, с тем же user ID). Стандартным способом защиты является регистрация пользователя с использованием сочетания ID самого IdP (в качестве пространства имён) и пользовательского ID внутри IdP. | 2 |\n| **6.8.2** | Убедитесь, что наличие и целостность цифровой подписи в утверждениях аутентификации (например, в JWT или SAML) всегда проверяются, а неподписанные или недействительные утверждения отклоняются. | 2 |\n| **6.8.3** | Убедитесь, что SAML-утверждения обрабатываются только один раз в течение периода их действия, чтобы исключить атаки воспроизведения (replay attacks). | 2 |\n| **6.8.4** | Убедитесь, что если приложение использует внешний поставщик идентификации (IdP) и для определенных функций требуется особый уровень, метод или срок действия аутентификации, то приложение использует данные, возвращаемые IdP, для проверки этих условий. Например, при использовании OIDC можно проверить значения полей ID Token — acr, amr, auth_time (если они есть). Если IdP не предоставляет эти данные, приложение должно иметь документированный план действий по умолчанию, предполагающий использование минимально допустимой силы аутентификации (например, одноступенчатая — логин и пароль). | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [NIST SP 800-63 - Digital Identity Guidelines](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-3.pdf)\n* [NIST SP 800-63B - Authentication and Lifecycle Management](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf)\n* [NIST SP 800-63 FAQ](https://pages.nist.gov/800-63-FAQ/)\n* [OWASP Web Security Testing Guide: Testing for Authentication](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing)\n* [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)\n* [OWASP Forgot Password Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html)\n* [OWASP Choosing and Using Security Questions Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html)\n* [CISA Guidance on \"Number Matching\"](https://www.cisa.gov/sites/default/files/publications/fact-sheet-implement-number-matching-in-mfa-applications-508c.pdf)\n* [Details on the FIDO Alliance](https://fidoalliance.org/)\n", "timestamp": "2025-10-24T11:40:15.259061"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x16-V7-Session-Management.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x16-V7-Session-Management.md", "content": "# V7 Управление сессиями\n\n## Задачи контроля\n\nМеханизмы управления сессиями позволяют приложениям связывать взаимодействия пользователя и устройства во времени, даже при использовании протоколов без состояния (например, HTTP). Современные приложения могут использовать несколько токенов сессии с разными характеристиками и назначением. Безопасная система управления сессиями — это система, предотвращающая получение, использование или иное злоупотребление сессией жертвы злоумышленником. Приложения, поддерживающие сессии, должны соответствовать следующим концептуальным требованиям:\n\n* Сессии уникальны для каждого пользователя, их идентификаторы нельзя угадать, и ими нельзя «поделиться» с другими.\n* Сессии становятся недействительными, когда они больше не нужны, т.е. при бездействии пользователя срок действия сессии истекает.\n\nМногие требования в этой главе основаны на [NIST SP 800-63 Digital Identity Guidelines](https://pages.nist.gov/800-63-4/), с фокусом на распространённые угрозы и уязвимости аутентификации.\n\nОбратите внимание, что конкретные требования по реализации различных механизмов управления сессиями приведены в других разделах:\n\n* Требования по безопасности HTTP cookies — в разделе «Безопасность веб-интерфеса».\n* Требования по автономным токенам — в разделе «Автономные токены».\n\n## V7.1 Документация по управлению сессиями\n\nНет единого шаблона, подходящего для всех приложений. Поэтому необходимо проводить анализ рисков с документированием решений по безопасности, касающихся управления сессиями, до реализации и тестирования. Это обеспечивает адаптацию системы управления сессиями к конкретным требованиям приложения.\n\nНезависимо от того, используется ли механизм сессий с сохранением состояния (stateful) или без (stateless), анализ должен быть завершён и задокументирован, чтобы продемонстрировать соответствие всем требованиям безопасности. Также необходимо учесть взаимодействие с системами единого входа (SSO), если они используются.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.1.1** | Убедитесь, что тайм-аут бездействия и абсолютное максимальное время жизни сессии задокументированы, соответствуют другим контрольным мерам и сопровождаются обоснованием любых отклонений от требований повторной аутентификации NIST SP 800-63B. | 2 |\n| **7.1.2** | Убедитесь, что документация определяет допустимое количество одновременных (параллельных) сессий для одного аккаунта, а также поведение системы и действия при достижении этого лимита. | 2 |\n| **7.1.3** | Убедитесь, что все системы, создающие и управляющие сессиями пользователей в рамках федеративной идентификации (например, SSO), задокументированы вместе с механизмами координации сроков действия сессий, условий завершения и случаев, требующих повторной аутентификации. | 2 |\n\n## V7.2 Базовая безопасность сессий\n\nТребования этого раздела обеспечивают безопасное создание и валидацию сессионных токенов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.2.1** | Убедитесь, что все проверки сессионных токенов выполняются на доверенной серверной стороне. | 1 |\n| **7.2.2** | Убедитесь, что приложение использует либо автономные токены, либо ссылочные токены, которые генерируются динамически, не используя статические API-секреты или ключи. | 1 |\n| **7.2.3** | Убедитесь, что ссылочные токены являются уникальными, создаются с использованием криптографически безопасного генератора псевдослучайных чисел (CSPRNG) и обладают энтропией не менее 128 бит. | 1 |\n| **7.2.4** | Убедитесь, что при аутентификации пользователя (включая повторную) создается новый токен сессии, а текущий — аннулируется. | 1 |\n\n## V7.3 Тайм-ауты сессии\n\nМеханизмы тайм-аутов сессии уменьшают временное окно для угонов и других атак. Тайм-ауты должны соответствовать документированным решениям по безопасности.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.3.1** | Убедитесь, что есть тайм-аут бездействия, после которого требуется повторная аутентификация, в соответствии с анализом рисков и документированными решениями. | 2 |\n| **7.3.2** | Убедитесь, что установлено абсолютное максимальное время жизни сессии, по истечении которого требуется повторная аутентификация, в соответствии с анализом рисков и документированными решениями. | 2 |\n\n## V7.4 Завершение сессий\n\nЗавершение сессии может происходить как со стороны самого приложения, так и через поставщика SSO, если управление сессиями делегировано ему. Некоторые требования этого раздела могут быть реализованы на стороне поставщика SSO.\n\nЗавершение сессии должно требовать повторной аутентификации и быть эффективным во всех компонентах: приложении, федеративной аутентификации и других доверяющих сторонах.\n\nСессии с сохранением состояния обычно аннулируются на серверной стороне. self-contained токены нужно отзывать или блокировать, иначе они могут оставаться действительными до истечения срока их действия.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.4.1** | Убедитесь, что после завершения сессии (logout, истечение срока) дальнейшее её использование невозможно. Для ссылочных токенов или сессий с сохранением состояния это означает аннулирование на сервере. Для self-contained токенов необходимо реализовать механизм отзыва, например, список отозванных токенов, проверку времени выпуска или ротацию ключей подписи для каждого пользователя. | 1 |\n| **7.4.2** | Убедитесь, что при удалении или отключении пользователя все активные сессии немедленно завершаются. | 1 |\n| **7.4.3** | Убедитесь, что после изменения или удаления факторов аутентификации (например, смена пароля или MFA) приложение предлагает завершить все другие активные сессии. | 2 |\n| **7.4.4** | Убедитесь, что на всех страницах, требующих аутентификации, имеется простой и видимый способ выхода. | 2 |\n| **7.4.5** | Убедитесь, что администраторы могут завершать активные сессии конкретного пользователя или всех пользователей. | 2 |\n\n## V7.5 Защита от злоупотреблений сессией\n\nЭтот раздел направлен на снижение рисков при активных сессиях, включая атаки с использованием действующей сессии жертвы.\n\nПри рассмотрении требований этого раздела нужно учитывать рекомендации для конкретных уровней, приведенные в разделе «Аутентификация»\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.5.1** | Убедитесь, что приложение требует полной повторной аутентификации перед изменением чувствительных атрибутов аккаунта, которые могут влиять на аутентификацию (например, email, номер телефона, настройки MFA или данных восстановления доступа). | 2 |\n| **7.5.2** | Убедитесь, что пользователь может просматривать и (после повторной аутентификации хотя бы по одному фактору) завершать активные сессии. | 2 |\n| **7.5.3** | Убедитесь, что перед выполнением критически важных операций приложение требует повторной аутентификации (по крайней мере, одного фактора) или дополнительной проверки. | 3 |\n\n## V7.6 Федеративная повторная аутентификация\n\nТребования для сторон, реализующих логику Relying Party (RP) и Identity Provider (IdP), основаны на [NIST SP 800-63C](https://pages.nist.gov/800-63-4/sp800-63c.html).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **7.6.1** | Убедитесь, что срок действия и завершение сессий между RP и IdP соответствуют документации и включают повторную аутентификацию, если достигнут максимальный допустимый интервал между событиями аутентификации. | 2 |\n| **7.6.2** | Убедитесь, что создание сессии требует согласия пользователя или явного действия, предотвращающего несанкционированное создание сессий без участия пользователя. | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Session Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing)\n* [OWASP Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:15.356747"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x17-V8-Authorization.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x17-V8-Authorization.md", "content": "# V8 Авторизация\n\n## Задачи контроля\n\nМеханизмы авторизации обеспечивают доступ только разрешённым субъектам (пользователям, сервисам и другим клиентам). Для соблюдения принципа наименьших привилегий (POLP) проверяемые приложения должны соответствовать следующим концептуальным требованиям:\n\n* Документировать правила авторизации, включая факторы принятия решений и контекст окружения.\n* Субъекты должны иметь доступ только к тем ресурсам, на которые у них есть разрешения.\n\n## V8.1 Документация по авторизации\n\nПолная документация по авторизации необходима для обеспечения согласованного применения решений в области безопасности, возможности аудита и соответствия политикам организации. Это снижает риск несанкционированного доступа, делая требования безопасности понятными и выполнимыми для разработчиков, администраторов и тестировщиков.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **8.1.1** | Убедитесь, что документация по авторизации определяет правила ограничения доступа на уровне функций и на уровне данных на основе прав субъекта и атрибутов ресурса. | 1 |\n| **8.1.2** | Убедитесь, что документация по авторизации определяет правила ограничения доступа на уровне полей (как на чтение, так и на запись) на основе прав субъекта и атрибутов ресурса. Эти правила могут зависеть от других атрибутов объекта данных, например, статуса. | 2 |\n| **8.1.3** | Убедитесь, что документация определяет, какие атрибуты окружения и контекста (например, время суток, IP-адрес, местоположение, устройство) используются приложением для принятия решений в области аутентификации и авторизации. | 3 |\n| **8.1.4** | Убедитесь, что документация по аутентификации и авторизации определяет, как используются факторы окружения и контекста в принятии решений, наряду с правилами доступа к функциям, данным и полям. Документация должна содержать оцениваемые атрибуты, пороговые значения риска, действия (разрешить, отказать, повысить уровень аутентификации и др.). | 3 |\n\n## V8.2 Архитектура авторизации\n\nРеализация детализированных механизмов авторизации на уровне функций, данных и полей обеспечивает субъектам наличие прав доступа только к тем компонентам, которые были им явно предоставлены.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **8.2.1** | Убедитесь, что приложение обеспечивает доступ на уровне функций (function-level) только субъектам с явными разрешениями. | 1 |\n| **8.2.2** | Убедитесь, что приложение обеспечивает доступ на уровне данных (data-specific) только тем субъектам, которым явно предоставлены права к определённым элементам данных, чтобы предотвратить IDOR (Insecure Direct Object Reference) и BOLA-уязвимости (Broken Object Level Authorization). | 1 |\n| **8.2.3** | Убедитесь, что приложение обеспечивает доступ на уровне полей (field-level) только тем субъектам, которым явно предоставлены права к определённым полям, чтобы предотвратить BOPLA (Broken Object Property Level Authorization). | 2 |\n| **8.2.4** | Убедитесь, что реализованы адаптивные меры безопасности, основанные на атрибутах окружения и контекста субъекта (время, местоположение, IP, устройство), которые используются для принятия решений об аутентификации и авторизации, как это определено в документации приложения. Эти меры должны применяться как при попытке субъекта начать новую сессию, так и во время существующей сессии. | 3 |\n\n## V8.3 Авторизация на уровне операций\n\nНемедленное применение изменений авторизации на соответствующем уровне архитектуры критически важно для предотвращения несанкционированных действий, особенно в динамически меняющихся системах.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **8.3.1** | Убедитесь, что правила авторизации реализуются на доверенном сервисном уровне и не зависят от элементов, которые может контролировать клиент (например, JavaScript на стороне клиента). | 1 |\n| **8.3.2** | Убедитесь, что изменения значений, влияющих на авторизацию, применяются немедленно. Если это невозможно (например, при использовании автономных токенов), должны быть реализованы компенсирующие меры: оповещения о попытке несанкционированного действия и откат изменений. Обратите внимание, что данный подход не предотвращает утечку информации. | 3 |\n| **8.3.3** | Убедитесь, что доступ к объекту осуществляется на основе прав субъекта, инициировавшего запрос, а не прав промежуточного сервиса, действующего от его имени. Например, если пользователь обращается к веб-сервису с автономным токеном для аутентификации, а сервис затем запрашивает данные у другого сервиса, второй сервис должен использовать токен пользователя, а не токен первого сервиса для принятия решения о доступе. | 3 |\n\n## V8.4 Прочие аспекты авторизации\n\nДополнительные меры контроля, особенно в административных интерфейсах и многопользовательских (мультитенантных) системах, помогают предотвратить несанкционированный доступ.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **8.4.1** | Убедитесь, что в мультитенантных приложениях реализованы механизмы, предотвращающие действия потребителя в отношении арендаторов, к которым у него нет доступа. | 2 |\n| **8.4.2** | Убедитесь, что доступ к административным интерфейсам защищён несколькими уровнями контроля, включая непрерывную проверку личности, контроль защищённости устройства и анализ контекстных рисков. Недостаточно опираться только на IP-адрес или доверенные устройства. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Authorization](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/05-Authorization_Testing)\n* [OWASP Authorization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:15.467960"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x18-V9-Self-contained-Tokens.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x18-V9-Self-contained-Tokens.md", "content": "# V9 Автономные токены\n\n## Задачи контроля\n\nВ оригинальном RFC 6749 OAuth 2.0 от 2012 года упоминается концепция автономного токена (self-contained token). Она относится к токенам, которые содержат данные или утверждения (claims), на основе которых получатель будет принимать решения по безопасности. Автономный токен следует отличать от простого токена, содержащего только идентификатор, который принимающая сторона использует для локального поиска данных.\n\nНаиболее распространёнными примерами автономных токенов являются JSON Web Tokens (JWTs) и SAML Assertions. Но автономные токены получили широкое распространение даже за пределами OAuth и OIDC. Безопасность этой концепции зависит от возможности проверить целостность токена и убедиться, что он действителен для конкретного контекста. Этот процесс сопряжен с множеством подводных камней, и в этой главе подробно описываются механизмы, помогающие приложениям обходить их.\n\n## V9.1 Источник токена и его целостность\n\nВ данном разделе изложены требования, гарантирующие, что токен был выпущен доверенной стороной и не был модифицирован.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **9.1.1** | Убедитесь, что автономные токены проверяются на целостность с помощью цифровой подписи или MAC, прежде чем доверять их содержимому. | 1 |\n| **9.1.2** | Проверяйте, что автономные токены создаются и проверяются исключительно с помощью алгоритмов из списка допустимых в данном контексте. Список допустимых алгоритмов должен включать только разрешенные алгоритмы (желательно либо только симметричные, либо только асимметричные) и ни в коем случае не содержать алгоритм None. Если необходимо поддерживать оба типа алгоритмов, потребуются дополнительные средства контроля для предотвращения путаницы с ключами (key confusion). | 1 |\n| **9.1.3** | Убедитесь, что ключи, используемые для проверки автономных токенов, получены из доверенных, предварительно настроенных источников. Это предотвращает возможность указания злоумышленниками ненадёжных источников и ключей. Для JWT и других JWS структур заголовки 'jku', 'x5u' и 'jwk' должны проверяться по белому списку. | 1 |\n\n## V9.2 Содержимое токена\n\nПрежде чем принимать решения по безопасности на основе данных из токена, важно проверить два момента: что срок действия токена актуален на момент предъявления, и что токен предназначен для использования принимающим сервисом в тех целях, для которых он был передан. Это предотвращает небезопасное перекрестное использование токена между различными сервисами или использование разного типа токенов от одного и того же эмитента.\n\nКонкретные требования для OAuth и OIDC рассматриваются в соответствующей главе.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **9.2.1** | Убедитесь, что при указанном сроке действия токен и его содержимое принимаются только в том случае, если срок действия токена не истёк. Например, для JWT нужно проверить поля 'nbf' и 'exp'. | 1 |\n| **9.2.2** | Убедитесь, что сервис, принимающий токен, проверяет его тип и соответствие назначению перед обработкой содержимого токена. Например, для принятия решений об авторизации могут быть приняты только Access Token, а для подтверждения аутентификации пользователя — только ID Token. | 2 |\n| **9.2.3** | Убедитесь, что сервис принимает только токены, предназначенные для использования с этим сервисом (audience). Для JWT это можно сделать, проверив наличие утверждения «aud» по белому списку, определенному в сервисе. | 2 |\n| **9.2.4** | Убедитесь, что, если эмитент токенов использует один и тот же закрытый ключ для выпуска токенов различным сервисам (audiences), выпущенные токены содержат явное указание целевых сервисов. Это предотвратит повторное использования токенов в не предназначенных для них сервисах. Если идентификатор сервиса (audience identifier) назначается динамически, эмитент токенов должен проверить audiences для исключения подмены получателей (audience impersonation). | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP JSON Web Token Cheat Sheet for Java Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html) (но имеет полезные общие рекомендации)\n", "timestamp": "2025-10-24T11:40:15.611776"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x19-V10-OAuth-and-OIDC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x19-V10-OAuth-and-OIDC.md", "content": "# V10 OAuth и OIDC\n\n## Задачи контроля\n\nOAuth2 (в этой главе именуется просто OAuth) — это общепринятый отраслевой стандарт делегированной авторизации. Например, с помощью OAuth клиентское приложение может получить доступ к API (ресурсам сервера) от имени пользователя, если тот дал на это разрешение.\n\nСама по себе технология OAuth не предназначена для аутентификации пользователей. Фреймворк OpenID Connect (OIDC) расширяет OAuth, добавляя слой идентификации пользователя. OIDC поддерживает такие функции, как стандартизированная информация о пользователе, единый вход (SSO) и управление сессиями. Поскольку OIDC является надстройкой над OAuth, все требования, предъявляемые к OAuth, также применимы к OIDC.\n\nВ OAuth определены следующие роли:\n\n* OAuth-клиент — приложение, пытающееся получить доступ к серверным ресурсам (например, через вызов API с использованием access token). Чаще всего это серверное приложение.\n    * Конфиденциальный клиент (confidential client) — клиент, способный сохранять в тайне свои учетные данные (например, client_secret) для аутентификации на авторизационном сервере.\n    * Публичный клиент (public client) — клиент, неспособный хранить учетные данные в секрете. Вместо аутентификации (например, с использованием пары client_id и client_secret) он лишь идентифицирует себя через client_id.\n* OAuth-ресурсный сервер (Resource Server, RS) — сервер API, предоставляющий ресурсы клиентам OAuth.\n* OAuth-авторизационный сервер (Authorization Server, AS) — сервер, выдающий клиентам access token'ы. Эти токены позволяют клиенту получать доступ к ресурсам RS — либо от имени пользователя, либо от имени самого клиента. Часто AS — это отдельное приложение, но при необходимости может быть интегрирован в RS.\n* Владелец ресурса (Resource Owner, RO) — конечный пользователь, разрешающий OAuth-клиенту ограниченный доступ к своим данным на RS. Пользователь предоставляет это разрешение через взаимодействие с AS.\n\nВ OIDC определены следующие роли:\n\n* Relying Party (RP) — клиентское приложение, запрашивающее аутентификацию пользователя через OpenID-провайдера. В терминах OAuth оно также является OAuth-клиентом.\n* OpenID-провайдер (OP) — авторизационный сервер OAuth, способный аутентифицировать пользователя и предоставлять RP claims в рамках OIDC. OP может быть IdP (провайдером идентификации), но в федеративных сценариях OP и IdP могут быть разными приложениями.\n\nИзначально OAuth и OIDC были разработаны для сторонних приложений. Однако в настоящее время они часто используются и в first-party сценариях. Например, для аутентификации и управления сессиями. В таких случаях протоколы добавляют некоторую сложность, которая может привести к новым проблемам с безопасностью.\n\nOAuth и OIDC могут использоваться в различных типах приложений, однако в OWASP ASVS акцент делается на веб-приложения и API.\n\nПоскольку OAuth и OIDC работают поверх веб-технологий, на них распространяются общие требования из других глав. Этот раздел не следует рассматривать изолированно.\n\nВ этой главе рассматриваются лучшие современные практики OAuth2 и OIDC в ​​соответствии со спецификациями, представленными на <https://oauth.net/2/> и <https://openid.net/developers/specs/>. Поскольку RFC часто обновляются, при применении требований, изложенных в этой главе, следует сверяться с их последними версиями. Подробнее см. в разделе «Ссылки».\n\nС учетом сложности темы крайне важно использовать проверенные стандартные решения (например, авторизационные серверы от крупных вендоров) и применять рекомендованные параметры безопасности.\n\nТерминология в этой главе соответствует RFC OAuth и спецификациям OIDC. Однако OIDC-термины используются только в OIDC-специфичных требованиях. В остальных случаях применяется терминология OAuth.\n\nВ этом разделе под «токеном» понимается:\n\n* Access Token используется только ресурсным сервером (RS). Он может быть ссылочным (reference token), проверяемым через introspection, или автономным (self-contained), проверяемым через криптографически подписанный материал.\n* Refresh Token используется только авторизационным сервером, выдавшим токен.\n* OIDC ID Token используется только клиентским приложением, инициировавшим процесс авторизации.\n\nУровни риска для некоторых требований зависят от того, является ли клиент конфиденциальным или публичным. Поскольку сильная клиентская аутентификация снижает многие риски, в случае конфиденциальных клиентов на уровне L1 возможны послабления.\n\n## V10.1 Общие требования безопасности OAuth и OIDC\n\nВ этом разделе изложены универсальные архитектурные требования, применимые ко всем приложениям, использующим OAuth или OIDC.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.1.1** | Убедитесь, что токены передаются только тем компонентам, которым они действительно необходимы. Например, при использовании схемы backend-for-frontend для браузерных JavaScript-приложений, access и refresh токены должны быть доступны только на backend. | 2 |\n| **10.1.2** | Убедитесь, что клиент принимает значения от авторизационного сервера (например, authorization code или ID Token) только если они получены в результате авторизационного потока, инициированного в той же сессии пользовательского агента и в рамках той же транзакции. Для этого клиентские секреты, такие как proof key для code exchange (PKCE) — 'code_verifier', 'state' или OIDC 'nonce' — должны быть непредсказуемыми, специфичными для транзакции и надежно привязанными как к клиенту, так и к сессии пользовательского агента, в которой началась транзакция. | 2 |\n\n## V10.2 Клиент OAuth\n\nДанные требования описывают обязанности приложений-клиентов OAuth. Клиентом может быть, например, backend веб-сервера (часто выступающий как Backend For Frontend, BFF), интеграция backend-сервиса или frontend-приложение одностраничного типа (SPA, то есть браузерное приложение).\n\nВ общем случае backend-клиенты считаются конфиденциальными (confidential clients), а frontend — публичными (public clients). Однако нативные приложения, работающие на устройстве конечного пользователя, могут рассматриваться как конфиденциальные при использовании динамической регистрации OAuth клиента.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.2.1** | Убедитесь, что если используется механизм authorization code flow, OAuth клиент защищён от CSRF, вызывающих запросы токенов либо за счёт использования механизма proof key for code exchange (PKCE), либо за счёт проверки параметра 'state', который был отправлен в запросе авторизации. | 2 |\n| **10.2.2** | Убедитесь, что если OAuth клиент может взаимодействовать с более чем одним сервером авторизации, у него есть защита от атак смешивания (mix-up attacks). Например, клиент должен требовать, чтобы сервер авторизации возвращал параметр 'iss' и проверять его в ответах на авторизацию и токены. | 2 |\n| **10.2.3** | Убедитесь, что OAuth клиент запрашивает только необходимые области доступа (scopes) или другие параметры авторизации в запросах к серверу авторизации. | 3 |\n\n## V10.3 Сервер ресурсов OAuth\n\nВ контексте ASVS и данного раздела сервер ресурсов — это API. Для обеспечения безопасного доступа сервер ресурсов должен:\n\n* Валидировать access token в соответствии с форматом токена и спецификациями протокола, например, валидация JWT или интроспекция OAuth токена.\n* Если токен действителен, принимать решения по авторизации на основе информации из токена и предоставленных разрешений. Например, сервер ресурсов должен проверить, что клиент (действующий от имени владельца ресурса) имеет право доступа к запрошенному ресурсу.\n\nТаким образом, требования здесь специфичны для OAuth или OIDC и должны выполняться после валидации токена и перед принятием решения об авторизации на основе информации из токена.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.3.1** | Убедитесь, что сервер ресурсов принимает только те access токены, которые предназначены для использования с этим сервисом (свойство audience). Эта принадлежность сервису может быть включена в структурированный access токен (например, в поле 'aud' в JWT) или проверяться через endpoint интроспекции токена. | 2 |\n| **10.3.2** | Убедитесь, что сервер ресурсов принимает решения по авторизации на основе claims из access токена, определяющих делегированную авторизацию. Если присутствуют claims, такие как 'sub', 'scope' и 'authorization_details', они должны участвовать в принятии решения. | 2 |\n| **10.3.3** | Убедитесь, что если для принятия решения по контролю доступа необходимо однозначно идентифицировать пользователя из access токена (JWT или ответа интроспекции), сервер ресурсов использует claims, которые не могут быть переприсвоены другим пользователям. Обычно это комбинация claims 'iss' и 'sub'. | 2 |\n| **10.3.4** | Убедитесь, что если сервер ресурсов требует определённой силы аутентификации, методов или свежести аутентификации, он проверяет, что предъявленный access токен удовлетворяет этим требованиям. Например, при наличии, могут использоваться claims OIDC 'acr', 'amr' и 'auth_time'. | 2 |\n| **10.3.5** | Убедитесь, что сервер ресурсов предотвращает использование украденных access токенов или их повторное использование (replay) неавторизованными лицами, требуя access токены с подтверждением отправителя — например, Mutual TLS для OAuth 2 или OAuth 2 Demonstration of Proof of Possession (DPoP). | 3 |\n\n## V10.4 Сервер авторизации OAuth\n\nЭти требования описывают обязанности серверов авторизации OAuth, включая OpenID провайдеров.\n\nДля аутентификации клиента разрешён метод 'self_signed_tls_client_auth' при выполнении предварительных требований, указанных в [разделе 2.2](https://datatracker.ietf.org/doc/html/rfc8705#name-self-signed-certificate-mut) стандарта [RFC 8705](https://datatracker.ietf.org/doc/html/rfc8705).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.4.1** | Убедитесь, что сервер авторизации проверяет URI перенаправления (redirect URI), сверяя его с заранее зарегистрированным списком разрешённых URI для данного клиента (allowlist), используя точное сравнение строк. | 1 |\n| **10.4.2** | Убедитесь, что если сервер авторизации возвращает authorization code в ответе авторизации, этот код может быть использован только один раз для запроса токена. При втором валидном запросе с уже использованным кодом сервер должен отклонить запрос и отозвать любые токены, связанные с этим кодом. | 1 |\n| **10.4.3** | Убедитесь, что authorization code имеет короткое время жизни. Максимальная продолжительность — до 10 минут для приложений L1 и L2 и до 1 минуты для приложений L3. | 1 |\n| **10.4.4** | Убедитесь, что сервер авторизации для конкретного клиента разрешает использование только тех типов авторизации, которые необходимы этому клиенту. Обратите внимание, что тип авторизации Implicit flow и Resource Owner Password Credentials flow больше не должны использоваться. | 1 |\n| **10.4.5** | Убедитесь, что сервер авторизации предотвращает атаки повторного использования refresh токенов для публичных клиентов, предпочтительно используя sender-constrained refresh токены, такие как DPoP или сертификат-связанные токены с mutual TLS (mTLS). Для L1 и L2 допускается ротация refresh токенов с обязательной их инвалидацией после использования. Если используется ротация, сервер должен отозвать все refresh токены при попытке использовать уже инвалидированный токен. | 1 |\n| **10.4.6** | Убедитесь, что при использовании типа авторизации «Authorization Code» сервер предотвращает атаки перехвата authorization code, требуя Proof Key for Code Exchange (PKCE). В запросах авторизации сервер должен требовать валидное значение 'code_challenge' и не принимать 'code_challenge_method' со значением 'plain'. В запросах токена обязательно валидировать параметр 'code_verifier'. | 2 |\n| **10.4.7** | Убедитесь, что если сервер авторизации поддерживает динамическую регистрацию клиентов без аутентификации, он минимизирует риски вредоносных клиентов. Сервер должен валидировать метаданные клиента (например, зарегистрированные URI), обеспечивать согласие пользователя и предупреждать пользователя перед обработкой запроса авторизации от недоверенного клиента. | 2 |\n| **10.4.8** | Убедитесь, что refresh токены имеют абсолютный срок действия, включая случаи, когда применяется скользящее время истечения срока. | 2 |\n| **10.4.9** | Убедитесь, что пользователи могут отзывать refresh токены и reference access токены через пользовательский интерфейс сервера авторизации для снижения риска от вредоносных клиентов или кражи токенов. | 2 |\n| **10.4.10** | Убедитесь, что конфиденциальный клиент аутентифицируется при взаимодействии с сервером авторизации через backchannel, например при запросах токена, pushed authorization requests (PAR) и запросах на отзыв токенов. | 2 |\n| **10.4.11** | Убедитесь, что конфигурация сервера авторизации назначает OAuth клиенту только необходимые области доступа (scopes). | 2 |\n| **10.4.12** | Убедитесь, что для конкретного клиента сервер авторизации разрешает только те значения 'response_mode', которые необходимы этому клиенту. Например, сервер должен валидировать это значение против ожидаемых или использовать pushed authorization request (PAR) или JWT-secured Authorization Request (JAR). | 3 |\n| **10.4.13** | Убедитесь, что грант типа 'code' всегда используется вместе с pushed authorization requests (PAR). | 3 |\n| **10.4.14** | Убедитесь, что сервер авторизации выдаёт только sender-constrained (Proof-of-Possession) access токены, либо с сертификат-связанными токенами через mutual TLS (mTLS), либо DPoP-bound токены (Demonstration of Proof of Possession). | 3 |\n| **10.4.15** | Убедитесь, что для серверного клиента (не выполняющегося на устройстве конечного пользователя) сервер авторизации проверяет, что значение параметра 'authorization_details' исходит из клиентского backend и что пользователь не изменял его. Например, это достигается использованием pushed authorization request (PAR) или JWT-secured Authorization Request (JAR). | 3 |\n| **10.4.16** | Убедитесь, что клиент является конфиденциальным и сервер авторизации требует использования сильных методов аутентификации клиента (основанных на криптографии с открытым ключом и устойчивых к атакам повторного воспроизведения), таких как mutual TLS ('tls_client_auth', 'self_signed_tls_client_auth') или private key JWT ('private_key_jwt'). | 3 |\n\n## V10.5 Клиент OIDC\n\nПоскольку OIDC клиент (relying party) выступает в роли OAuth клиента, на него также распространяются требования из раздела «OAuth Client».\n\nОбратите внимание, что в разделе «Аутентификация с использованием провайдера идентификаций (IdP)» главы «Аутентификация» содержатся дополнительные общие требования.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.5.1** | Убедитесь, что клиент (relying party) защищается от повторного использования ID Token (replay-атак). Например, это достигается проверкой того, что значение 'nonce' в ID Token совпадает со значением 'nonce', отправленным в запросе аутентификации провайдеру OpenID (authorization server). | 2 |\n| **10.5.2** | Убедитесь, что клиент однозначно идентифицирует пользователя по утверждениям (claims) ID Token, обычно это 'sub', который не может быть переназначен другому пользователю (в пределах конкретного провайдера идентификации). | 2 |\n| **10.5.3** | Убедитесь, что клиент отклоняет попытки злоумышленного сервера авторизации выдавать себя за другой сервер авторизации через метаданные сервера авторизации. Клиент должен отклонить метаданные, если URL издателя (issuer) в метаданных не совпадает точно с преднастроенным URL издателя, ожидаемым клиентом. | 2 |\n| **10.5.4** | Убедитесь, что клиент проверяет, что ID Token предназначен для него (проверка audience), сравнивая значение 'aud' в токене с 'client_id' клиента. | 2 |\n| **10.5.5** | Убедитесь, что при использовании OIDC back-channel logout клиент снижает риск отказа в обслуживании, вызванный принудительным выходом из системы и путаницей между разными типами JWT (cross-JWT confusion) в процессе логаута. Клиент должен проверить, что токен выхода корректно типизирован со значением 'logout+jwt', содержит claim 'event' с правильным именем участника и не содержит 'nonce'. Также рекомендуется установить короткий срок действия токена (например, 2 минуты). | 2 |\n\n## V10.6 Провайдер OpenID\n\nПоскольку провайдеры OpenID выступают в роли OAuth серверов авторизации, на них также распространяются требования из раздела «Сервер авторизации OAuth».\n\nОбратите внимание, что при использовании потока ID Token (а не code flow) access токены не выдаются, и многие требования к OAuth AS в этом случае неприменимы.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.6.1** | Убедитесь, что провайдер OpenID допускает только значения 'code', 'ciba', 'id_token' или 'id_token code' для параметра response mode. При этом предпочтение отдаётся 'code' по сравнению с 'id_token code' (гибридный поток OIDC), а значение 'token' (любой Implicit flow) не должно использоваться. | 2 |\n| **10.6.2** | Убедитесь, что провайдер OpenID предотвращает отказ в обслуживании (DoS) через принудительный выход (logout), запрашивая явное подтверждение от конечного пользователя или, если применимо, проверяя параметры в запросе выхода (инициированном relying party), например параметр 'id_token_hint'. | 2 |\n\n## V10.7 Управление согласием\n\nЭти требования касаются проверки согласия пользователя авторизационным сервером. Без правильной проверки согласия пользователя злоумышленник может получить разрешения от имени пользователя с помощью подделки или социальной инженерии.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **10.7.1** | Убедитесь, что авторизационный сервер обеспечивает получение согласия пользователя для каждого запроса авторизации. Если личность клиента не может быть подтверждена, сервер авторизации всегда должен явно запрашивать согласие пользователя. | 2 |\n| **10.7.2** | Убедитесь, что при запросе согласия пользователя авторизационный сервер предоставляет достаточную и понятную информацию о том, на что даётся согласие. При необходимости это должно включать характер запрашиваемых разрешений (обычно основанных на scope, ресурсном сервере, деталях авторизации Rich Authorization Requests (RAR)), идентификацию авторизованного приложения и срок действия этих разрешений. | 2 |\n| **10.7.3** | Убедитесь, что пользователь может просматривать, изменять и отзывать согласия, которые он предоставил, через авторизационный сервер. | 2 |\n\n## Ссылки\n\nДля дополнительной информации об OAuth см.:\n\n* [oauth.net](https://oauth.net/)\n* [OWASP OAuth 2.0 Protocol Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)\n\nДля требований, связанных с OAuth, в ASVS используются следующие опубликованные и находящиеся в статусе черновика RFC:\n\n* [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)\n* [RFC6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)\n* [RFC6819 OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)\n* [RFC7636 Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636)\n* [RFC7591 OAuth 2.0 Dynamic Client Registration Protocol](https://datatracker.ietf.org/doc/html/rfc7591)\n* [RFC8628 OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)\n* [RFC8707 Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)\n* [RFC9068 JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068)\n* [RFC9126 OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9126)\n* [RFC9207 OAuth 2.0 Authorization Server Issuer Identification](https://datatracker.ietf.org/doc/html/rfc9207)\n* [RFC9396 OAuth 2.0 Rich Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9396)\n* [RFC9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)\n* [RFC9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700)\n* [draft OAuth 2.0 for Browser-Based Applications](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)<!-- recheck on release -->\n* [draft The OAuth 2.1 Authorization Framework](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12)<!-- recheck on release -->\n\nДля получения дополнительной информации об OpenID Connect см.:\n\n* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)\n* [FAPI 2.0 Security Profile](https://openid.net/specs/fapi-security-profile-2_0-final.html)\n", "timestamp": "2025-10-24T11:40:15.715587"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x20-V11-Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x20-V11-Cryptography.md", "content": "# V11 Криптография\n\n## Задачи контроля\n\nЦель этой главы - определить наилучшие методы общего использования криптографии, а также привить фундаментальное понимание ее принципов и стимулировать переход к более устойчивым и современным подходам. В ней рассмотрены следующие пункты:\n\n* Внедрение надежных криптографических систем, которые являются отказоустойчивыми, адаптируются к меняющимся угрозам и ориентированы на будущее.\n* Использование криптографических механизмов, которые одновременно являются безопасными и соответствуют лучшим практикам индустрии.\n* Поддержка безопасной системы управления криптографическими ключами с надлежащим контролем доступа и аудитом.\n* Регулярная оценка криптографической отрасли для определения рисков и соответствующей адаптации алгоритмов.\n* Обнаружение и управление криптографическими сценариями использования на протяжении всего жизненного цикла приложения с целью обеспечения учёта и защиты всех криптографических ресурсов.\n\nВ дополнение к обозначенным общим принципам и лучшим практикам данный документ также представляет более углубленную техническую информацию о требованиях в Приложении C - Стандарты криптографии. Он содержит алгоритмы и конфигурации, которые считаются «утвержденными» в соответствии с требованиями, изложенными в данном разделе.\n\nТребования для решения отдельных криптографических задач, таких как управление секретами или обеспечение безопасного соединения будут рассмотрены в разных частях стандарта.\n\n## V11.1 Инвентаризация и документирование криптографии\n\nПриложения должны проектироваться с использованием надёжной криптографической архитектуры для защиты данных в соответствии с их классификацией. Шифровать всё подряд — это расточительно, а не шифровать ничего — юридическая халатность. Необходимо найти баланс, который обычно достигается на этапе архитектурного или высокоуровневого проектирования, в ходе дизайн-спринтов или архитектурных исследований. Проектирование криптографии «на ходу» или доработка её после разработки приложения неизбежно приведёт к гораздо большим затратам на обеспечение безопасности, чем если бы она была заложена с самого начала.\n\nВажно регулярно обнаруживать, вести учёт и оценивать все криптографические активы. В приложении приведена дополнительная информация о том, как это делать.\n\nТакже критически важно подготовить криптографические системы к будущему появлению квантовых компьютеров. Постквантовая криптография (Post-Quantum Cryptography, PQC) — это криптографические алгоритмы, разработанные так, чтобы оставаться надёжными против атак квантовых компьютеров, которые, как ожидается, смогут взламывать широко используемые алгоритмы, такие как RSA и эллиптические кривые (ECC).\n\nВ приложении также содержатся текущие рекомендации по проверенным PQC-примитивам и стандартам.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.1.1** | Убедитесь, что задокументирована политика управления криптографическими ключами и описан их жизненный цикл в соответствии со стандартом управления ключей, таким как NIST SP 800-57. Убедитесь, что ключи известны только тем сущностям, которым они должны быть доступны (например, ключи не передавались более чем двум участникам для общих секретов и более чем одному участнику для приватных ключей). | 2 |\n| **11.1.2** | Убедитесь, что проводится инвентаризация криптографических средств, которая непрерывно поддерживается, регулярно обновляется и включает все криптографические ключи, алгоритмы и сертификаты, используемые в приложении. Также должна быть задокументирована информация о том, где ключи могут и не могут использоваться в системе, а также какие типы данных могут и не могут быть защищены с помощью этих ключей. | 2 |\n| **11.1.3** | Убедитесь, что используются механизмы обнаружения криптографии для идентификации всех случаев применения криптографии в системе , включая операции шифрования, хеширования и цифровой подписи. | 3 |\n| **11.1.4** | Убедитесь, что ведётся и поддерживается инвентаризация криптографических средств. В неё должен входить документированный план, описывающий переход на новые криптографические стандарты, такие как постквантовая криптография, чтобы своевременно реагировать на будущие угрозы. | 3 |\n\n## V11.2 Безопасная реализация криптографии\n\nДанный раздел содержит требования для определения (выбора), реализации и дальнейшего управления основными криптографическими алгоритмами в приложении. Основная цель - убедиться в том, что используются исключительно надежные, утвержденные криптографические примитивы в соответствии с текущими стандартами (н-р, NIST, ISO/IEC) и лучшими практиками разработки. Организации должны убедиться, что каждый криптографический компонент выбран с учетом рецензируемых исследований и практического тестирования безопасности.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.2.1** | Убедитесь, что для криптографических операций используются утвержденные в индустрии реализации (включая библиотеки и аппаратные реализации). | 2 |\n| **11.2.2** | Убедитесь, что архитектура приложения поддерживает быструю реконфигурацию, усовершенствование или смену в любой момент случайных чисел, аутентифицированного шифрования, MAC, алгоритмов хеширования, длин ключей, количества раундов, шифров и режимов шифрования для защиты от криптографических атак. Также должна поддерживаться возможность смены ключей, паролей и повторного шифрования данных. Это позволит беспрепятственно перейти на постквантовую криптографию (PQC), как только станут широко доступны высоконадёжные реализации одобренных схем или стандартов PQC. | 2 |\n| **11.2.3** | Убедитесь, что все криптографические примитивы используют как минимум 128-бит стойкости с учетом алгоритма, размера ключа и конфигурации. Например, 256-битный ECC ключ обеспечивает примерно 128 бит безопасности, тогда как для достижения того же уровня безопасности в RSA требуется ключ длиной 3072 бита. | 2 |\n| **11.2.4** | Убедитесь, что все криптографические операции выполняются за константное время, без использования «short-circuit» операций в сравнениях, вычислениях, возвратах функций для избежания утечек информации. | 3 |\n| **11.2.5** | Убедитесь, что все криптографические модули обеспечивают безопасное завершение работы при ошибках, а обработка ошибок реализована таким образом, чтобы не создавать уязвимостей, например, таких как атаки Padding Oracle. | 3 |\n\n## V11.3 Алгоритмы шифрования\n\nАлгоритмы аутентифицированного шифрования на основе AES и ChaCha20 составляют основу современной криптографической практики.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.3.1** | Убедитесь, что не используются небезопасные режимы блочного шифрования (н-р, ECB) и слабые схемы дополнения (padding) (н-р, PKCS#1 v1.5). | 1 |\n| **11.3.2** | Убедитесь, что используются только утверждённые шифры и режимы, такие как AES с GCM. | 1 |\n| **11.3.3** | Убедитесь, что зашифрованные данные защищены от несанкционированного изменения, предпочтительно с использованием утверждённого метода аутентифицированного шифрования или путём комбинирования утверждённого метода шифрования с утверждённым алгоритмом MAC. | 2 |\n| **11.3.4** | Убедитесь, что случайные числа (nonce), векторы инициализации (IV) и другие одноразовые числа не используются более одного раза для одной и той же пары ключа шифрования и элемента данных. Метод их генерации должен соответствовать требованиям используемого алгоритма. | 3 |\n| **11.3.5** | Убедитесь, что любая комбинация алгоритма шифрования и алгоритма MAC работает в режиме encrypt-then-MAC (EtM). | 3 |\n\n## V11.4 Хеширование и функции на основе хеширования\n\nКриптографические хеш-функции применяются во множестве криптографических протоколов, таких как цифровые подписи, HMAC, функции генерации ключа (KDF), генерация случайных битов и хранение паролей. Безопасность криптографической системы напрямую зависит от стойкости используемых хеш-функций. В этом разделе изложены требования к использованию надёжных хеш-функций в криптографических операциях.\n\nДля рекомендаций по хранению паролей, вместе с Приложениием C - Стандарты криптографии, рекомендуем использовать [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms)\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.4.1** | Убедитесь, что только утвержденные хэш-функции используются для стандартных сценариев использования в криптографии, включая цифровую подпись, HMAC, KDF, генерацию случайных чисел. Запрещено использовать неустойчивые хэш-функции, (н-р, MD5) для любого использования в криптографии. | 1 |\n| **11.4.2** | Убедитесь, что пароли хранятся с использованием утверждённой, вычислительно затратной функции генерации ключа (также известной как «функция хеширования паролей»), с параметрами, настроенными в соответствии с актуальными рекомендациями. Настройки должны обеспечивать баланс между безопасностью и производительностью, чтобы сделать атаки перебором достаточно сложными для требуемого уровня безопасности. | 2 |\n| **11.4.3** | Убедитесь, что хэш-функции, используемые в формировании цифровой подписи, как часть аутентификации и целостности данных, устойчивы к коллизиям и имеют достаточную длину. | 2 |\n| **11.4.4** | Убедитесь, что приложение использует утвержденную функцию генерации ключа с использованием параметров расширения ключа (key stretching) при генерации ключа из пароля. Параметры должны быть сбалансированы с точки зрения безопасности, производительности и устойчивости к атакам полного перебора при компрометации результирующего криптографического ключа. | 2 |\n\n## V11.5 Случайные значения\n\nКриптографически стойкая генерация псевдослучайных чисел (Cryptographically secure Pseudo-random Number Generation (CSPRNG)) чрезвычайно сложна для правильной реализации. Как правило, хорошие источники энтропии в системе быстро истощаются при чрезмерном использовании, тогда как источники с меньшей степенью случайности могут приводить к предсказуемым ключам и секретам.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.5.1** | Убедитесь, что все случайные числа и строки, которые должны быть непредсказуемы, должны быть сгенерированы с помощью CSPRNG и иметь хотя бы 128 бит энтропии. Учтите, что UUID не удовлетворяют данному условию. | 2 |\n| **11.5.2** | Убедитесь, что механизм генерации случайных чисел является надежным даже при высокой нагрузке. | 3 |\n\n## V11.6 Криптография с публичным ключом\n\nКриптография с публичным ключом используется там, где невозможно или нежелательно распределять ключ между несколькими сторонами.\n\nТакже существует потребность в утвержденных методах обмена ключами, таких как Diffie-Hellman (DH) и Elliptic Curve Diffie-Hellman (ECDH), чтобы убедиться, что криптосистема остается безопасной к современным угрозам. Раздел «Безопасная коммуникация» содержит требования для TLS, так что требования данной секции применимы в ситуациях, где криптография с открытым ключом используется отдельно от TLS.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.6.1** | Убедитесь, что только утвержденные криптографические алгоритмы и режимы операций используются для генерации ключа и инициализации случайного значения для его генерации (seeding), а также для генерации цифровой подписи и верификации. Алгоритмы генерации ключей не должны генерировать небезопасные ключи уязвимые к известным атакам, например, ключи RSA уязвимы к факторизации Ферма. | 2 |\n| **11.6.2** | Убедитесь, что для обмена ключами используются утверждённые криптографические алгоритмы (например, Диффи-Хеллман) с особым вниманием к обеспечению использования безопасных параметров. Это предотвратит атаки на процесс установления ключа, которые могут привести к атакам «человек посередине» или криптографическим взломам. | 3 |\n\n## V11.7 Шифрование данных в процессе использования\n\nЗащита данных во время их обработки имеет первостепенное значение. Рекомендуется использовать такие методы, как полное шифрование памяти, шифрование данных при передаче, а также обеспечение как можно более быстрого шифрования данных после их использования.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **11.7.1** | Убедитесь, что используется полное шифрование памяти, которое защищает конфиденциальные данные во время их использования, предотвращая доступ к ним неавторизованных пользователей или процессов. | 3 |\n| **11.7.2** | Убедитесь, что минимизация данных обеспечивает раскрытие минимально необходимого объёма данных во время обработки, а также что данные шифруются сразу после использования или как можно скорее. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Testing for Weak Cryptography](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography)\n* [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n* [FIPS 140-3](https://csrc.nist.gov/pubs/fips/140-3/final)\n* [NIST SP 800-57](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)\n", "timestamp": "2025-10-24T11:40:15.883182"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x21-V12-Secure-Communication.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x21-V12-Secure-Communication.md", "content": "# V12 Безопасная коммуникация\n\n## Задачи контроля\n\nВ этой главе изложены требования, связанные с механизмами защиты данных при передаче, как между клиентом конечного пользователя и серверной частью, так и между компонентами внутренней сервисной архитектуры.\n\nОсновные концепции главы:\n\n* Шифрование внешних коммуникаций, а в идеале — и внутри системы.\n* Настройку механизмов шифрования в соответствии с актуальными рекомендациями, включая предпочтительные алгоритмы и шифры.\n* Использование подписанных сертификатов для защиты от перехвата данных третьими лицами.\n\nКроме того, помимо общих принципов и лучших практик, ASVS предоставляет более глубокую техническую информацию о криптографической стойкости в Приложении C - Стандарты криптографии.\n\n## V12.1 Общие рекомендации по безопасности TLS\n\nВ этом разделе приводятся первоначальные рекомендации по обеспечению безопасности TLS-соединений. Для постоянного контроля конфигурации TLS следует использовать актуальные инструменты.\n\nХотя использование универсальных (wildcard) TLS-сертификатов само по себе не является небезопасным, компрометация такого сертификата, который используется во всех управляемых окружениях (например, в production, staging, development, test), может привести к нарушению безопасности приложений, использующих этот сертификат. Поэтому при возможности рекомендуется применять надёжную защиту, управление и использовать отдельные TLS-сертификаты для разных сред.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **12.1.1** | Убедитесь, что включены только актуальные и рекомендуемые версии протокола TLS, такие как TLS 1.2 и TLS 1.3. Наиболее свежая версия TLS должна быть выбрана как предпочтительная. | 1 |\n| **12.1.2** | Убедитесь, что включены рекомендуемые шифронаборы (cipher suites), предпочтение также стоит отдать самому сильному шифронабору. L3 приложения должны поддерживать только те наборы шифров (cipher suites), которые обеспечивают прямую (forward) секретность. Пояснение: Прямая секретность (Forward Secrecy, FS) — это криптографическая особенность, при которой сессионные ключи уникальны для каждой сессии и не зависят от долгосрочных ключей. Это гарантирует, что даже при компрометации долгосрочного ключа злоумышленник не сможет расшифровать ранее перехваченные зашифрованные сессии. | 2 |\n| **12.1.3** | Убедитесь, что приложение проверяет доверенность клиентских сертификатов mTLS, прежде чем использовать идентификацию по сертификату для аутентификации или авторизации. | 2 |\n| **12.1.4** | Убедитесь, что включена и настроена правильная проверка отзыва сертификатов, такая как Online Certificate Status Protocol (OCSP) Stapling. | 3 |\n| **12.1.5** | Убедитесь, что в настройках TLS приложения включена функция Encrypted Client Hello (ECH) для предотвращения раскрытия конфиденциальных метаданных, таких как Server Name Indication (SNI), во время процесса TLS-рукопожатия. | 3 |\n\n## V12.2 HTTPS коммуникация с внешними сервисами\n\nУбедитесь, что весь HTTP-трафик к внешним сервисам, которые предоставляет приложение, передавался в зашифрованном виде с использованием публично доверенных сертификатов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **12.2.1** | Убедитесь, что для всех соединений между клиентом и внешними HTTP-сервисами используется TLS и не происходит отката к небезопасным или незашифрованным протоколам. | 1 |\n| **12.2.2** | Убедитесь, что внешние сервисы используют публично доверенные TLS-сертификаты. | 1 |\n\n## V12.3 Общая безопасность межсервисного взаимодействия\n\nВсе взаимодействия между серверами (включая внутренние и внешние подключения) должны быть защищены, предпочтительно с применением TLS-шифрования. Соединения с другими системами также должны быть защищены, желательно с использованием TLS.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **12.3.1** | Убедитесь, что для всех входящих и исходящих соединений приложения используется зашифрованный протокол, например TLS, включая системы мониторинга, инструменты управления, удалённый доступ и SSH, промежуточное ПО, базы данных, мейнфреймы, партнёрские системы и внешние API. Сервер не должен допускать откат к небезопасным или незашифрованным протоколам. | 2 |\n| **12.3.2** | Убедитесь, что TLS-клиент проверяет сертификат сервера до установления защищенного соединения с TLS-сервером. | 2 |\n| **12.3.3** | Убедитесь, что все внутренние HTTP-взаимодействия между компонентами приложения используют TLS или другой подходящий механизм транспортного шифрования, и не происходит откат к небезопасным или незашифрованным коммуникациям. | 2 |\n| **12.3.4** | Убедитесь, что TLS-соединения между внутренними сервисами используют доверенные сертификаты. Если используются внутренние или самоподписанные сертификаты, потребляющий сервис должен быть настроен на доверие только к конкретным внутренним центрам сертификации (CA) и конкретным самоподписанным сертификатам. | 2 |\n| **12.3.5** | Убедитесь, что сервисы, взаимодействующие внутри системы (intra-service communications), используют строгую аутентификацию для проверки каждого конечного узла. Для проверки подлинности взаимодействующих сторон должны применяться методы строгой аутентификации, такие как аутентификация TLS-клиента, с использованием инфраструктуры открытых ключей и механизмов, устойчивых к атакам повтора (replay attacks). Для микросервисных архитектур рекомендуется использование service mesh для упрощения управления сертификатами и повышения безопасности. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP - Transport Layer Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n* [Mozilla's Server Side TLS configuration guide](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* [Mozilla's tool to generate known good TLS configurations](https://ssl-config.mozilla.org/).\n* [O-Saft - OWASP Project to validate TLS configuration](https://owasp.org/www-project-o-saft/)\n", "timestamp": "2025-10-24T11:40:16.064971"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x22-V13-Configuration.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x22-V13-Configuration.md", "content": "# V13 Конфигурация\n\n## Задачи контроля\n\nСтандартная конфигурация приложения должна быть безопасной для использования в Интернете.\n\nВ этой главе приводятся рекомендации по различным настройкам, необходимым для достижения этого, включая те, которые применяются на этапах разработки, сборки и развертывания.\n\nРассматриваемые темы включают предотвращение утечек данных, безопасное управление коммуникациями между компонентами и защиту секретов.\n\n## V13.1 Документация конфигурации\n\nЭтот раздел описывает требования к документации, связанные с тем, как приложение взаимодействует с внутренними и внешними сервисами, а также методы предотвращения потери доступности из-за недоступности сервисов. Также рассматриваются вопросы, касающиеся документации секретных данных.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **13.1.1** | Убедитесь, что все необходимые доступы приложения задокументированы. Сюда должны быть включены как внешние сервисы, от которых зависит приложение, так и сценарии, когда конечный пользователь может задавать адреса для внешнего подключения. | 2 |\n| **13.1.2** | Убедитесь, что для каждого сервиса, используемого приложением, в документации определено максимальное количество одновременных соединений (например, лимиты пула соединений) и описано поведение приложения при достижении этого лимита, включая любые механизмы отказоустойчивости или восстановления, чтобы предотвратить ситуации отказа в обслуживании (DoS). | 3 |\n| **13.1.3** | Убедитесь, что в документации приложения определены стратегии управления ресурсами для каждой внешней системы или сервиса, которые оно использует (например, базы данных, файловые дескрипторы, потоки, HTTP-соединения). Стратегии должны включать процедуры освобождения ресурсов, настройки таймаутов, обработку сбоев, а также, если реализована логика повторных попыток, указание лимитов, задержек и алгоритмов back-off. Для синхронных HTTP-запросов должны быть заданы короткие таймауты, а повторные запросы должны быть отключены, либо строго ограничены по числу попыток, чтобы предотвратить каскадные задержки и истощение ресурсов. | 3 |\n| **13.1.4** | Убедитесь, что в документации приложения определены секреты, критически важные для безопасности приложения, а также установлен график их ротации в соответствии с моделью угроз организации и её бизнес-требованиями. | 3 |\n\n## V13.2 Конфигурация бэкенд соединений\n\nПриложения взаимодействуют с множеством сервисов, включая API, базы данных и другие компоненты. Эти сервисы могут считаться внутренними для приложения, но не включёнными в стандартные механизмы контроля доступа приложения, либо быть полностью внешними. В любом случае необходимо настроить приложение для безопасного взаимодействия с этими компонентами и, при необходимости, защитить соответствующую конфигурацию.\n\nВажно: Глава «Безопасная коммуникация» содержит рекомендации по шифрованию данных при передаче.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **13.2.1** | Убедитесь, что коммуникации между компонентами бэкенда приложения (включая API, промежуточное ПО и уровни данных), которые не поддерживают стандартный механизм пользовательских сессий, проходят с аутентификацией. Аутентификация должна использовать индивидуальные сервисные аккаунты, краткосрочные токены или аутентификацию на основе сертификатов, а не постоянные учётные данные, такие как пароли, API-ключи или общие аккаунты с привилегированным доступом. | 2 |\n| **13.2.2** | Убедитесь, что коммуникации между компонентами бэкенда приложения, включая локальные или системные службы, API, промежуточное ПО и уровни данных, выполняются с использованием аккаунтов, которым назначены минимально необходимые привилегии. | 2 |\n| **13.2.3** | Убедитесь, что если для аутентификации в сервисе используются учётные данные, то используемые потребителем учётные данные не являются стандартными (например, root/root или admin/admin). | 2 |\n| **13.2.4** | Убедитесь, что используется белый список (allowlist) для определения внешних ресурсов или систем, с которыми приложению разрешено взаимодействовать (например, для исходящих запросов, загрузки данных или доступа к файлам). Этот белый список может быть реализован на уровне приложения, веб-сервера, межсетевого экрана или комбинации различных уровней. | 2 |\n| **13.2.5** | Убедитесь, что веб- или прикладной сервер настроен с белым списком ресурсов или систем, к которым сервер может отправлять запросы или из которых может загружать данные и файлы. | 2 |\n| **13.2.6** | Убедитесь, что при подключении приложения к другим сервисам соблюдается задокументированная конфигурация для каждого соединения, включая максимальное количество параллельных соединений, поведение при достижении их максимума, таймауты и стратегии повторных попыток подключения. | 3 |\n\n## V13.3 Управление секретами\n\nУправление секретами — это важная задача конфигурации, необходимая для обеспечения защиты данных, используемых в приложении. Конкретные требования к криптографии изложены в главе «Криптография», а данный раздел сосредоточен на аспектах управления и обработки секретов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **13.3.1** | Убедитесь, что для безопасного создания, хранения, контроля доступа и уничтожения секретов бэкенда используется решение для управления секретами, например, хранилище ключей (key vault). Секретами могут быть пароли, ключевой материал, интеграции с базами данных и сторонними системами, ключи и seed-значения для токенов с ограниченным временем действия, другие внутренние секреты и API-ключи. Секреты не должны включаться в исходный код приложения или артефакты сборки. Для приложений уровня L3 необходимо использовать аппаратное решение, например, аппаратный модуль безопасности (HSM). | 2 |\n| **13.3.2** | Убедитесь, что доступ к секретным ресурсам осуществляется в соответствии с принципом минимально необходимых привилегий (least privilege). | 2 |\n| **13.3.3** | Убедитесь, что все криптографические операции выполняются с использованием изолированного модуля безопасности (например, хранилища ключей или аппаратного модуля безопасности), чтобы надежно управлять ключевым материалом и защищать его от утечки за пределы модуля безопасности. | 3 |\n| **13.3.4** | Убедитесь, что секреты настроены на срок действия и ротацию в соответствии с документацией приложения. | 3 |\n\n## V13.4 Непреднамеренная утечка информации\n\nКонфигурации в промышленной среде должны быть усилены, чтобы избежать раскрытия избыточных данных. Многие из подобных проблем редко оцениваются как значительные риски, но часто используются в связке с другими уязвимостями. Если таких проблем нет по умолчанию, это повышает уровень защиты приложения.\n\nНапример, скрытие версии серверных компонентов не отменяет необходимости обновлять все компоненты, а отключение отображения содержимого папок не исключает необходимости использовать механизмы авторизации или хранить файлы вне публичных каталогов, но всё это повышает уровень безопасности.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **13.4.1** | Убедитесь, что приложение развернуто либо без метаданных систем контроля версий (включая папки .git или .svn), либо так, чтобы эти папки были недоступны как извне, так и для самого приложения. | 1 |\n| **13.4.2** | Убедитесь, что режимы отладки отключены для всех компонентов в промышленной среде, чтобы предотвратить раскрытие функций отладки и утечку информации. | 2 |\n| **13.4.3** | Убедитесь, что веб-серверы не показывают клиентам списки содержимого каталогов, если это явно не предусмотрено. | 2 |\n| **13.4.4** | Убедитесь, что метод HTTP TRACE не поддерживается в продуктовой среде, чтобы избежать потенциальной утечки информации. | 2 |\n| **13.4.5** | Убедитесь, что документация (например, по внутренним API) и мониторинговые эндпоинты не доступны, если это явно не предусмотрено. | 2 |\n| **13.4.6** | Убедитесь, что приложение не раскрывает подробную информацию о версиях компонентов бэкенда. | 3 |\n| **13.4.7** | Убедитесь, что веб-слой настроен на обслуживание только файлов с определёнными расширениями, чтобы предотвратить непреднамеренную утечку информации, конфигураций и исходного кода. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Configuration and Deployment Management Testing](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing)\n", "timestamp": "2025-10-24T11:40:16.165917"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x23-V14-Data-Protection.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x23-V14-Data-Protection.md", "content": "# V14 Защита информации\n\n## Задачи контроля\n\nПриложения не могут предусмотреть все сценарии использования и поведение пользователей, поэтому они должны реализовывать механизмы, ограничивающие несанкционированный доступ к конфиденциальным данным на устройствах клиентов.\n\nВ эту главу входят требования, связанные с определением перечня данных, подлежащих защите, методы их защиты, а также конкретные механизмы реализации и ошибки, которых следует избегать.\n\nЕщё один важный аспект защиты данных — предотвращение массового извлечения, изменения или чрезмерного использования данных. Требования для каждой системы, вероятно, будут сильно различаться, поэтому определение «аномального» поведения должно основываться на модели угроз и бизнес-рисках. С точки зрения ASVS, обнаружение таких проблем рассматривается в главе «Журналирование событий безопасности и обработка ошибок», а установка ограничений — в главе «Валидация и бизнес-логика».\n\n## V14.1 Документация по защите информации\n\nКлючевым условием для защиты данных является классификация данных по уровню конфиденциальности. Данные следует классифицировать по нескольким уровням конфиденциальности, где для каждого уровня требуются разные меры защиты.\n\nСуществует множество законов и нормативных актов в области защиты персональных данных, которые определяют то, как приложения должны подходить к хранению, использованию и передаче конфиденциальных данных. Этот раздел не пытается дублировать такие законы и нормы, а сосредоточен на ключевых технических аспектах защиты чувствительных данных. При работе с данными следует учитывать требования местного законодательства и нормативных актов, а при необходимости консультироваться с профильным специалистом по защите данных или юристом.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **14.1.1** | Убедитесь, что все конфиденциальные данные, создаваемые и обрабатываемые приложением, идентифицированы и классифицированы по уровням защиты. Включая закодированные данные, которые легко декодируются, например, строки Base64 или незашифрованные данные в полезной нагрузке JWT. Уровни защиты должны учитывать требования по защите данных и конфиденциальности, которым должно соответствовать приложение. | 2 |\n| **14.1.2** | Убедитесь, что для каждого уровня защиты конфиденциальных данных требования к защите задокументированы. Они должны включать (но не ограничиваться) требования по шифрованию, проверке целостности, срокам хранения, способам логирования данных, контролю доступа к чувствительным данным в логах, шифрованию на уровне базы данных, применению технологий повышения конфиденциальности, а также другим требованиям по конфиденциальности. | 2 |\n\n## V14.2 Базовые меры по защите информации\n\nЭтот раздел содержит различные практические требования, связанные с защитой данных. Большинство из них направлены на непреднамеренную утечку данных, но также есть общее требование — реализовывать меры защиты в зависимости от необходимого уровня защиты для каждого типа данных.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **14.2.1** | Убедитесь, что конфиденциальные данные передаются на сервер только в теле HTTP-запроса или в заголовках. URL и строка запроса не должны содержать конфиденциальную информацию, такую как API-ключ или сессионный токен. | 1 |\n| **14.2.2** | Убедитесь, что приложение предотвращает кэширование конфиденциальных данных в серверных компонентах, таких как балансировщики нагрузки и кэши приложений, либо гарантирует их надежное удаление после использования. | 2 |\n| **14.2.3** | Убедитесь, что заранее определённые конфиденциальные данные не отправляются ненадёжным сторонам (например, системам трекинга пользователей), чтобы предотвратить нежелательный сбор данных вне контроля приложения. | 2 |\n| **14.2.4** | Убедитесь, что для конфиденциальных данных реализованы меры по шифрованию, проверке целостности, срокам хранения, способам логирования, контролю доступа к данным в логах, а также применяются технологии повышения конфиденциальности в соответствии с документацией для соответствующего уровня защиты данных. | 2 |\n| **14.2.5** | Убедитесь, что механизмы кэширования настроены так, чтобы кэшировать только ответы с ожидаемым типом содержимого для данного ресурса и не содержать конфиденциального динамического контента. При обращении к несуществующему файлу, веб-сервер должен возвращать ответ 404 или 302, а не подменять на другой существующий файл, что позволит предотвратить атаки типа Web Cache Deception. | 3 |\n| **14.2.6** | Убедитесь, что приложение возвращает только минимально необходимый объем конфиденциальных данных для выполнения своей функциональности. Например, показывает только часть цифр номера кредитной карты, а не полный номер. Если требуется отображение полных данных, они должны быть замаскированы в пользовательском интерфейсе, пока пользователь специально не запросил их просмотр. | 3 |\n| **14.2.7** | Убедитесь, что конфиденциальная информация подлежит классификации по срокам хранения, чтобы устаревшие или ненужные данные удалялись автоматически, по расписанию или по мере необходимости. | 3 |\n| **14.2.8** | Убедитесь, что конфиденциальная информация удаляется из метаданных файлов, загружаемых пользователями, если пользователь явно не согласился на ее хранение. | 3 |\n\n## V14.3 Защита данных на стороне клиента\n\nВ этом разделе содержатся требования, направленные на предотвращение утечки данных на стороне клиента или user agent приложения.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **14.3.1** | Убедитесь, что аутентифицированные данные очищаются из клиентского хранилища, например, из DOM браузера, после завершения работы клиента или сессии. Заголовок HTTP-ответа Clear-Site-Data может помочь в этом, но клиентская сторона также должна уметь очищать данные, если соединение с сервером недоступно при завершении сессии. | 1 |\n| **14.3.2** | Убедитесь, что приложение устанавливает HTTP-заголовки, достаточные для предотвращения кэширования (например, Cache-Control: no-store), чтобы конфиденциальные данные не сохранялись в браузерах. | 2 |\n| **14.3.3** | Убедитесь, что данные, хранящиеся в браузерном хранилище (например, localStorage, sessionStorage, IndexedDB или cookie), не содержат конфиденциальной информации, за исключением сессионных токенов. | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [Consider using the Security Headers website to check security and anti-caching header fields](https://securityheaders.com/)\n* [Documentation about anti-caching headers by Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)\n* [OWASP Secure Headers project](https://owasp.org/www-project-secure-headers/)\n* [OWASP Privacy Risks Project](https://owasp.org/www-project-top-10-privacy-risks/)\n* [OWASP User Privacy Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/User_Privacy_Protection_Cheat_Sheet.html)\n* [Australian Privacy Principle 11 - Security of personal information](https://www.oaic.gov.au/privacy/australian-privacy-principles/australian-privacy-principles-guidelines/chapter-11-app-11-security-of-personal-information)\n* [European Union General Data Protection Regulation (GDPR) overview](https://www.edps.europa.eu/data-protection_en)\n* [European Union Data Protection Supervisor - Internet Privacy Engineering Network](https://www.edps.europa.eu/data-protection/ipen-internet-privacy-engineering-network_en)\n* [Information on the \"Clear-Site-Data\" header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data)\n* [White paper on Web Cache Deception](https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack-wp.pdf)\n", "timestamp": "2025-10-24T11:40:16.330258"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x24-V15-Secure-Coding-and-Architecture.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x24-V15-Secure-Coding-and-Architecture.md", "content": "# V15 Безопасная разработка и архитектура\n\n## Задачи контроля\n\nМногие требования ASVS относятся либо к конкретной области безопасности, такой как аутентификация или авторизация, либо к определённому типу функциональности приложения, например, к логированию или работе с файлами.\n\nВ этой главе представлены общие требования безопасности, которые следует учитывать при проектировании и разработке приложений. Эти требования касаются не только чистоты архитектуры и качества кода, но и конкретных практик проектирования и программирования, необходимых для обеспечения безопасности приложений.\n\n## V15.1 Документация по безопасной разработке и архитектуре\n\nМногие требования по созданию безопасной и защищенной архитектуры зависят от четкого документирования решений, принятых в отношении реализации конкретных механизмов безопасности и компонентов, используемых в приложении.\n\nВ этом разделе излагаются требования к документации, включая определение компонентов, которые считаются содержащими «опасную функциональность» или «рискованными компонентами».\n\nКомпонент с «опасной функциональностью» может быть разработан внутри компании или представлять собой внешнюю зависимость, который выполняет такие операции, как десериализация ненадежных данных, парсинг необработанных файлов или двоичных данных, динамическое выполнение кода или непосредственное управление памятью. Уязвимости в таких операциях создают высокий риск компрометации приложения и его инфраструктуры.\n\n«Компонент с повышенным риском» — это сторонняя библиотека (т.е. не разработанная внутри компании) с отсутствующими или неэффективно реализованными средствами контроля безопасности в отношении процессов разработки или функциональности. Примерами служат компоненты, которые не поддерживаются, находятся на этапе завершения жизненного цикла или ранее содержали серьезные уязвимости.\n\nВ этом разделе также подчеркивается важность определения соответствующих сроков устранения уязвимостей в сторонних компонентах.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **15.1.1** | Убедитесь, что в документации по приложению определены сроки устранения уязвимостей на основе оценки рисков для внешних зависимостей с уязвимостями и для обновления библиотек в целом, чтобы минимизировать риск, связанный с этими компонентами. | 1 |\n| **15.1.2** | Убедитесь, что ведется реестр всех используемых сторонних библиотек (например, Software Bill of Materials, SBOM), с обязательной проверкой, что компоненты получены из предопределенных, доверенных и регулярно поддерживаемых репозиториев. | 2 |\n| **15.1.3** | Убедитесь, что в документации приложения указан функционал, требующий значительных временных или вычислительных ресурсов. Необходимо указать, как предотвратить потерю доступности из-за чрезмерного использования этого функционала и как избежать ситуаций, когда формирование ответа занимает больше времени, чем установленный системой таймаут. Возможные меры защиты могут включать асинхронную обработку, использование очередей и ограничение количества параллельных процессов для каждого пользователя и приложения. | 2 |\n| **15.1.4** | Убедитесь, что в документации приложения указаны внешние библиотеки, которые считаются «компонентами с повышенным риском». | 3 |\n| **15.1.5** | Убедитесь, что в документации приложения выделены те части приложения, в которых используются «функционал с повышенным риском». | 3 |\n\n## V15.2 Архитектура безопасности и зависимости\n\nВ этом разделе содержатся требования по работе с уязвимыми, устаревшими и небезопасными зависимостями и компонентами посредством управления зависимостями.\n\nОн также включает использование методов архитектурного уровня, таких как «песочница», инкапсуляция, контейнеризация и сетевая изоляция, для снижения влияния использования «операций с повышенным риском» и «компонентов с повышенным риском» (как определено в предыдущем разделе) и предотвращения потери доступности из-за чрезмерного использования ресурсоемких функций.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **15.2.1** | Убедитесь, что приложение содержит только те компоненты, которые не нарушили задокументированные сроки обновления и исправления. | 1 |\n| **15.2.2** | Убедитесь, что в приложении реализованы меры защиты от потери доступности из-за функциональности, требующей много времени или ресурсов, на основе задокументированных решений и стратегий безопасности для этого. | 2 |\n| **15.2.3** | Убедитесь, что производственная среда включает только те функции, которые необходимы для работы приложения, и не предоставляет лишние функции, такие как тестовый код, примеры кода и инструменты разработки. | 2 |\n| **15.2.4** | Убедитесь, что сторонние компоненты и все их транзитивные зависимости загружаются только из ожидаемых репозиториев (внутренних или внешних) и отсутствует риск атаки через подмену зависимостей (dependency confusion attack) | 3 |\n| **15.2.5** | Убедитесь, что приложение реализует дополнительные меры защиты для тех частей приложения, которые документированы как содержащие «функционал с повышенным риском» или использующие сторонние библиотеки, считающиеся «функционалом с повышенным риском». Это могут быть такие методы, как «песочница», инкапсуляция, контейнеризация или изоляция на сетевом уровне, чтобы задержать и предотвратить продвижение (pivoting) злоумышленников, скомпрометировавших одну часть приложения, к другим частям приложения. | 3 |\n\n## V15.3 Безопасное программирование\n\nВ этом разделе рассматриваются типы уязвимостей, включая type juggling, prototype pollution и другие, возникающие из-за использования небезопасных паттернов программирования на конкретном языке. Некоторые уязвимости актуальны не для всех языков, тогда как другие требуют исправлений, зависящих от конкретного языка программирования, или связаны с особенностями обработки функций (например, HTTP-параметров) в конкретном языке или фреймворке. Также рассматривается риск установки обновлений приложения без криптографической проверки.\n\nВ данном разделе также рассматриваются риски, связанные с использованием объектов для представления данных и их передачей через внешние API. В этом случае приложение должно гарантировать, что поля данных, которые не должны быть доступны для записи, не будут изменены пользовательским вводом (mass assignment), и что API избирательно определяет, какие поля данных возвращаются. Если доступ к полю зависит от прав пользователя, это следует рассматривать в контексте требования к контролю доступа на уровне полей в главе «Авторизация».\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **15.3.1** | Убедитесь, что приложение возвращает только необходимое подмножество полей из объекта данных. Например, оно не должно возвращать весь объект данных, поскольку некоторые отдельные поля должны быть недоступны пользователям. | 1 |\n| **15.3.2** | Убедитесь, что при вызовах внешних URL-адресов бэкэнд приложения настроен так, чтобы не выполнять перенаправления, если только это не предусмотрено функционалом. | 2 |\n| **15.3.3** | Убедитесь, что в приложении реализованы защитные механизмы против атак типа массового присвоения (mass assignment) путем строгого ограничения разрешенных полей для каждого контроллера и действия, исключая возможность добавления или изменения значений полей, которые не должны быть доступны для данной конкретной операции. | 2 |\n| **15.3.4** | Убедитесь, что все прокси и промежуточное ПО корректно передают исходный IP-адрес пользователя, используя доверенные поля данных, которые не могут быть изменены конечным пользователем, а приложение и веб-сервер используют это правильное значение для ведения логирования и принятия решений по безопасности, таких как ограничение запросов. При этом следует учитывать, что даже исходный IP-адрес может быть ненадежным из-за динамических IP-адресов, VPN или корпоративных файрволов. | 2 |\n| **15.3.5** | Убедитесь, что приложение явно проверяет соответствие переменных ожидаемому типу данных и использует строгие операции сравнения. Это необходимо для предотвращения уязвимостей, связанных с type juggling и type confusion, вызванных тем, что код приложения делает предположения о типе переменной. | 2 |\n| **15.3.6** | Убедитесь, что JavaScript-код написан таким образом, чтобы предотвратить prototype pollution, например, используя Set() или Map() вместо обычных литералов объекта. | 2 |\n| **15.3.7** | Убедитесь, что приложение защищено от атак типа HTTP Parameter Pollution (HPP), особенно если используемый фреймворк не различает источники параметров запроса (строка запроса, тело запроса, куки или заголовки). | 2 |\n\n## V15.4 Безопасная работа с параллельными процессами\n\nПроблемы безопасности работы параллельных процессов, такие как состояния гонки (race conditions), уязвимости типа «проблем синхронизации проверки и использования ресурсов» (TOCTOU), взаимные блокировки (deadlocks), постоянно повторяющиеся блокировки (livelocks), нехватка ресурсов у потоков (thread starvation) и некорректная синхронизация (improper synchronization), могут приводить к неожиданному поведению системы и создавать угрозы безопасности. В этом разделе рассматриваются различные методы и стратегии, помогающие снизить эти риски.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **15.4.1** | Убедитесь, что к общим объектам в многопоточном коде (например, кэшам, файлам или объектам в памяти, используемым несколькими потоками) используется безопасный многопоточный доступ и механизмов синхронизации, таких как блокировки или семафоры, чтобы избежать состояний гонки и повреждения данных. | 3 |\n| **15.4.2** | Убедитесь, что проверки состояния ресурса, например его существования или разрешений, а также зависящие от него действия выполняются как одна атомарная операция, чтобы предотвратить условия гонки времени проверки и времени использования (TOCTOU). Например, проверка существования файла перед его открытием или проверка прав доступа пользователя перед его предоставлением. | 3 |\n| **15.4.3** | Убедитесь, что блокировки применяются согласованно, чтобы предотвратить взаимные блокировки потоков (deadlocks) или их бесконечные повторы, а также что логика блокировки инкапсулирована в коде, отвечающем за управление ресурсом. Это гарантирует, что блокировки не могут быть случайно или намеренно изменены внешними классами или кодом. | 3 |\n| **15.4.4** | Убедитесь, что политики распределения ресурсов предотвращают нехватку ресурсов у потоков, обеспечивая справедливый доступ к ресурсам, например, используя пулы потоков, позволяя потокам с более низким приоритетом выполняться в течение разумного периода времени. | 3 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Prototype Pollution Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Prototype_Pollution_Prevention_Cheat_Sheet.html)\n* [OWASP Mass Assignment Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html)\n* [OWASP CycloneDX Bill of Materials Specification](https://owasp.org/www-project-cyclonedx/)\n* [OWASP Web Security Testing Guide: Testing for HTTP Parameter Pollution](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution)\n", "timestamp": "2025-10-24T11:40:16.586053"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x25-V16-Security-Logging-and-Error-Handling.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x25-V16-Security-Logging-and-Error-Handling.md", "content": "# V16 Журналирование событий безопасности и обработка ошибок\n\n## Задачи контроля\n\nЖурналы безопасности отличаются от журналов ошибок или производительности и служат для записи событий, связанных с безопасностью, таких как решения по аутентификации, контроль доступа или попытки обхода механизмов защиты (например, проверка входных данных или бизнес-логики). Их основная задача — обеспечить обнаружение, реагирование и расследование инцидентов за счёт предоставления структурированных данных с высокой информативной ценностью для аналитических систем, таких как SIEM.\n\nЖурналы не должны содержать конфиденциальные персональные данные, если это не предусмотрено законом, а все залогированные сведения должны защищаться как актив высокой важности. Процесс журналирования не должен нарушать конфиденциальность или безопасность системы. Кроме того, приложения должны отрабатывать ошибки безопасным образом, исключая необоснованное раскрытие информации или disruption (нарушение работы).\n\nПодробные инструкции по внедрению см. в OWASP Cheat Sheets в разделе ссылок.\n\n## V16.1 Документация по ведению логов\n\nЭтот раздел обеспечивает четкий и полный учет журналирования во всем стеке приложения. Это необходимо для эффективного мониторинга безопасности, реагирования на инциденты и соответствия требованиям.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **16.1.1** | Убедитесь в существовании реестра, в котором документируется ведение журнала на каждом уровне технологического стека приложения, включая какие события регистрируются, форматы логов, где хранятся эти журналы, как они используются, как контролируется доступ к ним и как долго хранятся журналы. | 2 |\n\n## V16.2 Общее журналирование\n\nВ этом разделе устанавливаются требования, обеспечивающие единообразную структуру журналов безопасности и наличие метаданных. Цель — обеспечить машиночитаемость логов и возможность их анализа в распределённых системах и инструментах мониторинга.\n\nЕстественно, события безопасности часто связаны с конфиденциальными данными. Если такие данные регистрируются без должного внимания, сами журналы становятся секретными и, следовательно, подпадают под действие требований шифрования (прим. автора - законодательства), более строгих политик хранения и могут быть раскрыты в ходе аудита.\n\nКрайне важно регистрировать только необходимые данные и обращаться с данными журналов с той же осторожностью, что и с другими конфиденциальными активами.\n\nПриведенные ниже требования устанавливают основополагающие требования к регистрации метаданных, синхронизации, форматированию и контролю.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **16.2.1** | Убедитесь, что каждая запись журнала содержит необходимые метаданные (например, когда, где, кто, что), которые позволят провести подробное исследование временной шкалы, когда произошло событие. | 2 |\n| **16.2.2** | Убедитесь, что все источники времени компонентов системы журналирования синхронизированы, а временные метки в метаданных событий безопасности используют UTC или содержат явное указание смещения часового пояса. Рекомендуется применять UTC для обеспечения согласованности в распределённых системах и предотвращения ошибок при переходе на летнее/зимнее время. | 2 |\n| **16.2.3** | Убедитесь, что приложение записывает и передаёт логи исключительно в те файлы и сервисы, которые указаны в реестре журналирования. | 2 |\n| **16.2.4** | Убедитесь, что логи могут быть прочитаны и коррелированы используемой системой обработки журналов, предпочтительно с использованием общего стандартного формата логирования. | 2 |\n| **16.2.5** | Убедитесь, что приложение применяет соответствующие меры защиты при логировании конфиденциальных данных в зависимости от уровня их чувствительности: например, полностью запрещает запись в логи таких данных, как учетные данные или платежные реквизиты, а для других данных (например, сессионных токенов) использует хеширование или частичное/полное маскирование. | 2 |\n\n## V16.3 Инциденты безопасности\n\nВ этом разделе определяются требования к журналированию событий безопасности в приложении. Фиксация этих событий критически важна для выявления подозрительной активности, проведения расследований и выполнения нормативных требований.\n\nВ этом разделе описываются типы регистрируемых событий, но он не претендует на исчерпывающую информацию. Каждое приложение имеет уникальные факторы риска и эксплуатационный контекст.\n\nОбратите внимание, что, хотя ASVS включает регистрацию событий безопасности в свою область применения, функции оповещения и корреляции (например, правила SIEM или инфраструктура мониторинга) не входят в сферу применения и обрабатываются операционными системами и системами мониторинга.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **16.3.1** | Убедитесь, что все операции аутентификации регистрируются, включая успешные и неудачные попытки. Также следует фиксировать дополнительные метаданные, такие как тип аутентификации или использованные факторы проверки. | 2 |\n| **16.3.2** | Убедитесь, что ведется журнал неудачных попыток авторизации. Для уровня L3 это должно включать в себя журналирование всех решений об авторизации, включая журналирование доступа к конфиденциальным данным (без регистрации самих конфиденциальных данных). | 2 |\n| **16.3.3** | Убедитесь, что приложение регистрирует все события безопасности, определенные в документации, а также фиксирует попытки обхода механизмов защиты, включая проверку входных данных, бизнес-логики и системы защиты от автоматизированных атак. | 2 |\n| **16.3.4** | Убедитесь, что приложение регистрирует в журналах неожиданные ошибки и сбои механизмов безопасности, включая, например, ошибки TLS-соединения на стороне сервера. | 2 |\n\n## V16.4 Защита журналов\n\nЖурналы представляют собой ценные источники forensic-данных и должны быть надёжно защищены. Если логи можно легко изменить или удалить, они теряют целостность и становятся ненадёжными для расследования инцидентов или судебных разбирательств. Кроме того, журналы могут раскрывать внутреннюю логику работы приложения или содержать конфиденциальные метаданные, что делает их привлекательной целью для злоумышленников.\n\nВ данном разделе определены требования, обеспечивающие защиту журналов от несанкционированного доступа, изменений и раскрытия и безопасную передачу и хранение в изолированных защищённых системах.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **16.4.1** | Убедитесь, что все компоненты системы логирования корректно кодируют данные, чтобы предотвратить атаки типа внедрения в журналы (log injection). | 2 |\n| **16.4.2** | Убедитесь, что логи защищены от неавторизованного доступа и не могут быть модифицированы. | 2 |\n| **16.4.3** | Убедитесь, что логи безопасно передаются в логически изолированную систему для анализа, обнаружения угроз, генерации оповещений и эскалации инцидентов. Это гарантирует сохранность журналов даже в случае компрометации основного приложения. | 2 |\n\n## V16.5 Обработка ошибок\n\nДанный раздел определяет требования к безопасному и корректному завершению работы приложений в случае сбоев, исключающему раскрытие конфиденциальной внутренней информации.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **16.5.1** | Убедитесь, что при возникновении непредвиденной или связанной с безопасностью ошибки пользователю возвращается только общее сообщение, гарантируя отсутствие раскрытия конфиденциальных внутренних данных системы, таких как трассировки стека, запросы, секретные ключи и токены. | 2 |\n| **16.5.2** | Убедитесь, что приложение продолжает работать в безопасном режиме при недоступности внешних ресурсов, используя такие механизмы, как автоматические выключатели (circuit breakers) или плавное снижение функциональности (graceful degradation). | 2 |\n| **16.5.3** | Убедитесь, что приложение корректно и безопасно завершает работу при возникновении исключений, предотвращая опасные сценарии по типу «fail-open», когда, например, транзакция ошибочно выполняется, несмотря на ошибки в логике валидации. | 2 |\n| **16.5.4** | Убедитесь, что определён обработчик ошибок «крайние меры», который будет перехватывать все необработанные ошибки. Это необходимо как для предотвращения потери информации об ошибках, которая должна быть записана в файлы журналов, так и для того, чтобы ошибка не остановила весь процесс приложения, что привело бы к потере доступности. | 3 |\n\nПримечание: Некоторые языки программирования (включая Swift, Go и многие функциональные языки в силу их парадигмы) не поддерживают исключения или обработчики событий «крайней меры». В таких случаях архитекторам и разработчикам следует использовать подходы, соответствующие паттернам, языковым особенностям или возможностям фреймворка, чтобы гарантировать безопасную обработку исключительных, непредвиденных или связанных с безопасностью событий.\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* [OWASP Web Security Testing Guide: Testing for Error Handling](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/08-Testing_for_Error_Handling/README)\n* [OWASP Authentication Cheat Sheet section about error messages](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-and-error-messages)\n* [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)\n* [OWASP Application Logging Vocabulary Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Vocabulary_Cheat_Sheet.html)\n", "timestamp": "2025-10-24T11:40:16.744483"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x26-V17-WebRTC.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x26-V17-WebRTC.md", "content": "# V17 WebRTC\n\n## Задачи контроля\n\nWeb Real-Time Communication (WebRTC) — технология, обеспечивающая передачу голоса, видео и данных в реальном времени в современных приложениях. По мере роста WebRTC обеспечение безопасности инфраструктуры WebRTC становится критически важным. В данном разделе представлены требования по безопасности для разработчиков, хостинг-провайдеров и интеграторов решений на основе WebRTC.\n\nРынок WebRTC можно разделить на три основных сегмента:\n\n1. Разработчики продуктов — поставщики, создающие и поставляющие продукты и решения WebRTC как с собственным, так и с открытым исходным кодом. Они специализируются на разработке надежных и безопасных технологий WebRTC, которые могут использоваться другими.\n\n2. Платформы коммуникаций как услуга (CPaaS) — провайдеры, предлагающие API, SDK и инфраструктуру для реализации WebRTC-функциональности. Они могут использовать продукты первой категории или разрабатывать собственное ПО WebRTC для предоставления этих услуг.\n\n3. Поставщики услуг — организации, внедряющие WebRTC-решения (на базе готовых продуктов или собственных разработок) для создания приложений для онлайн-конференций, здравоохранения, электронного обучения и других областей, где критически важна коммуникация в режиме реального времени.\n\nИзложенные здесь требования безопасности в первую очередь ориентированы на разработчиков продуктов, CPaaS-провайдеров, поставщиков услуг, которые:\n\n* Используют open-source решения для создания своих WebRTC-приложений.\n* Применяют коммерческие WebRTC-продукты как часть своей инфраструктуры.\n* Разрабатывают собственные WebRTC-решения или интегрируют различные компоненты в единый сервис.\n\nВажно отметить, что эти требования безопасности не распространяются на разработчиков, использующих исключительно SDK и API, предоставляемые поставщиками CPaaS. Для таких разработчиков CPaaS-провайдеры обычно несут ответственность за обеспечение базовой безопасности своей платформы, и универсальные стандарты безопасности (например, ASVS) могут не полностью покрывать их потребности.\n\n## V17.1 TURN-сервер\n\nВ этом разделе определяются требования безопасности для систем, использующих собственные серверы TURN (Traversal Using Relays around NAT). Серверы TURN помогают ретранслировать медиаданные в сетевых средах с ограничениями, но могут представлять опасность при неправильной настройке. Эти меры контроля направлены на безопасную фильтрацию адресов и защиту от исчерпания ресурсов.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **17.1.1** | Убедитесь, что сервис TURN (Traversal Using Relays around NAT) разрешает доступ только к IP-адресам, не зарезервированным для специальных целей (например, внутренние сети, широковещательная рассылка, loopback-адреса). Данное требование применяется как к IPv4, так и к IPv6 адресам. | 2 |\n| **17.1.2** | Убедитесь, что сервис TURN (Traversal Using Relays around NAT) защищен от исчерпания ресурсов при попытках легитимных пользователей открыть чрезмерное количество портов на сервере. | 3 |\n\n## V17.2 Требования к медиасерверам\n\nДанные требования применяются только к системам, использующим собственные WebRTC-медиасерверы, такие как, SFU (Selective Forwarding Units), MCU (Multipoint Control Units), серверы записи, шлюзовые серверы. Медиасерверы обрабатывают и распределяют медиапотоки, поэтому их безопасность критически важна для защиты взаимодействия между участниками. Обеспечение безопасности медиапотоков в WebRTC-приложениях является приоритетной задачей для предотвращения перехвата данных, манипуляций с трафиком, атак типа «отказ в обслуживании». Эти угрозы могут нарушить конфиденциальность пользователей и качество связи.\n\nВ частности, необходимо реализовать защиту от флуд-атак, включая: ограничение частоты запросов (rate limiting), проверку временных меток, использование синхронизированных часов для контроля временных интервалов и управление буферами для предотвращения переполнения и поддержания правильной временной синхронизации. Если пакеты для конкретного медиасеанса прибывают слишком быстро, избыточные пакеты должны отбрасываться. Также важно защитить систему от некорректных пакетов путем валидации входных данных, безопасной обработки целочисленных переполнений, предотвращения переполнения буферов и применения других надежных методов обработки ошибок.\n\nСистемы, использующие исключительно peer-to-peer медиакоммуникацию между веб-браузерами без промежуточных медиасерверов, не подпадают под эти специфические требования к медиабезопасности.\n\nДанный раздел относится к использованию Datagram Transport Layer Security (DTLS) в контексте WebRTC. Требования к документированной политике управления криптографическими ключами приведены в главе «Криптография». Информацию об одобренных криптографических методах можно найти в Приложении С - Криптография ASVS или в таких документах, как NIST SP 800-52 Rev. 2 или BSI TR-02102-2 (версия 2025-01).\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **17.2.1** | Убедитесь, что ключ сертификата Datagram Transport Layer Security (DTLS) управляется и защищается в соответствии с документированной политикой управления криптографическими ключами. | 2 |\n| **17.2.2** | Убедитесь, что медиасервер настроен на использование только одобренных наборов шифров Datagram Transport Layer Security (DTLS) и защищенного профиля безопасности для расширения DTLS, применяемого при установке ключей для Secure Real-time Transport Protocol (DTLS-SRTP). | 2 |\n| **17.2.3** | Убедитесь, что медиасервер проверяет аутентификацию Secure Real-time Transport Protocol (SRTP) для предотвращения атак с внедрением Real-time Transport Protocol (RTP), которые могут привести к отказу в обслуживании (Denial of Service) или вставке поддельного аудио-/видеоконтента в медиапотоки. | 2 |\n| **17.2.4** | Убедитесь, что медиасервер способен продолжать обработку входящего медиатрафика при получении некорректных пакетов Secure Real-time Transport Protocol (SRTP). | 2 |\n| **17.2.5** | Убедитесь, что медиасервер способен продолжать обработку входящего медиатрафика даже при флуде (массовой атаке) пакетами Secure Real-time Transport Protocol (SRTP) от легитимных пользователей. | 3 |\n| **17.2.6** | Убедитесь, что медиасервер не подвержен уязвимости «Гонка ClientHello» (ClientHello Race Condition) в Datagram Transport Layer Security (DTLS), проверив наличие известных уязвимостей в публичных источниках или выполнив тестирование на воспроизведение условий гонки. | 3 |\n| **17.2.7** | Убедитесь, что механизмы аудио- и видеозаписи, связанные с медиасервером, способны продолжать обработку входящего медиатрафика даже при флуде (массовой атаке) пакетов Secure Real-time Transport Protocol (SRTP) от легитимных пользователей. | 3 |\n| **17.2.8** | Убедитесь, что сертификат Datagram Transport Layer Security (DTLS) проверяется на соответствие атрибуту отпечатка (fingerprint) в Session Description Protocol (SDP), с немедленным прекращением медиапотока в случае несоответствия — это гарантирует подлинность передаваемых данных. | 3 |\n\n## V17.3 Сигнализация\n\nДанный раздел устанавливает требования для систем, использующих собственные серверы сигнализации WebRTC. Сигнализация координирует peer-to-peer (P2P) взаимодействие и должна быть устойчива к атакам, способным нарушить установление сеансов или управление соединениями.\n\nДля обеспечения безопасной сигнализации системы должны корректно обрабатывать некорректные входные данные и оставаться доступными под нагрузкой.\n\n| # | Описание | Уровень |\n| :---: | :--- | :---: |\n| **17.3.1** | Убедитесь, что сигнальный сервер способен продолжать обработку легитимных входящих сообщений сигнализации даже в условиях флуд-атаки. Для этого необходимо реализовать механизм ограничения частоты запросов (rate limiting) на уровне сигнализации. | 2 |\n| **17.3.2** | Убедитесь, что сигнальный сервер способен продолжать обработку легитимных сообщений сигнализации даже при получении некорректных сообщений, которые могут вызвать отказ в обслуживании (Denial of Service, DoS). Для этого необходимо реализовать: проверку входных данных (input validation), безопасную обработку целочисленных переполнений (integer overflows), защиту от переполнения буферов (buffer overflows) и другие надежные методы обработки ошибок. | 2 |\n\n## Ссылки\n\nДля дополнительной информации см. также:\n\n* DoS-атака WebRTC DTLS ClientHello лучше всего документирована [в записи блога Enable Security для специалистов по безопасности](https://www.enablesecurity.com/blog/novel-dos-vulnerability-affecting-webrtc-media-servers/) и соответствующем [техническом документе для разработчиков WebRTC](https://www.enablesecurity.com/blog/webrtc-hello-race-conditions-paper/)\n* [RFC 3550 - RTP: A Transport Protocol for Real-Time Applications](https://www.rfc-editor.org/rfc/rfc3550)\n* [RFC 3711 - The Secure Real-time Transport Protocol (SRTP)](https://datatracker.ietf.org/doc/html/rfc3711)\n* [RFC 5764 - Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP))](https://datatracker.ietf.org/doc/html/rfc5764)\n* [RFC 8825 - Overview: Real-Time Protocols for Browser-Based Applications](https://www.rfc-editor.org/info/rfc8825)\n* [RFC 8826 - Security Considerations for WebRTC](https://www.rfc-editor.org/info/rfc8826)\n* [RFC 8827 - WebRTC Security Architecture](https://www.rfc-editor.org/info/rfc8827)\n* [DTLS-SRTP Protection Profiles](https://www.iana.org/assignments/srtp-protection/srtp-protection.xhtml)\n", "timestamp": "2025-10-24T11:40:16.905298"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x90-Appendix-A_Glossary.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x90-Appendix-A_Glossary.md", "content": "# Приложение A: Термины и сокращения\n\n* **Absolute Maximum Session Lifetime** (абсолютный максимальный срок действия сессии) — также известный как \"Overall Timeout\" в NIST, это максимальное время, в течение которого сеанс может оставаться активным после аутентификации, независимо от действий пользователя. Это составная часть механизма завершения сессии.\n* **Allowlist** — список разрешённых данных или операций, например список символов, разрешённых форматно-логическим контролем.\n* **Anti-forgery token** (токен защиты от подделки) — механизм, при котором один или несколько токенов передаются в запросе и проверяются сервером приложения, чтобы гарантировать, что запрос поступил из ожидаемой конечной точки.\n* **Application Security** (безопасность приложений) — это анализ компонентов, составляющих прикладной уровень эталонной модели взаимодействия открытых систем (модели OSI), и в меньшей степени – инфраструктуры, например, операционных систем или сетей.\n* **Application Security Verification** (верификация требований к безопасности приложений) — технический анализ приложения по стандарту OWASP ASVS.\n* **Application Security Verification Report** — отчёт по тестированию конкретного приложения, в котором аудитор документирует общие результаты и даёт сопроводительные пояснения.\n* **Authentication** (аутентификация) — проверка учетных данных, предъявленных пользователем приложения.\n* **Automated Verification** (автоматизированная проверка) – поиск сигнатур уязвимостей с помощью автоматизированных инструментов динамического и/или статического анализа безопасности кода.\n* **Black box testing** (метод «чёрного ящика») — метод тестирования программного обеспечения, который проверяет функциональность приложения, не заглядывая в его внутреннюю структуру и операции.\n* **Common Weakness Enumeration** (CWE, список общих недостатков) – разработанный сообществом список распространенных недостатков безопасности программного обеспечения. Он служит общим языком, мерилом для средств обеспечения безопасности программного обеспечения, а также основой для выявления недостатков, их устранения и предотвращения.\n* **Component** (компонент) – автономный блок кода со связанными дисковыми и сетевыми интерфейсами, который взаимодействует с другими компонентами.\n* **Credential Service Provider** (CSP) — также называемый поставщиком идентификационных данных (IdP). Источник пользовательских данных, который может использоваться другими приложениями для аутентификации.\n* **Cross-Site Script Inclusion** (XSSI) — разновидность атаки межсайтового скриптинга (XSS), при которой веб-приложение загружает вредоносный код из внешнего источника и включает его в состав собственного содержимого.\n* **Cross-Site Scripting** (XSS, межсайтовый скриптинг) — уязвимость в системе безопасности, обычно обнаруживаемая в web-приложениях, позволяющая внедрять скрипты в контент на стороне клиента.\n* **Cryptographic module** (криптографический модуль) — аппаратное, программное и/или микропрограммное обеспечение, реализующее криптографические алгоритмы и/или генерирующее криптографические ключи.\n* **Cryptographically secure pseudo-random number generator** (CSPRNG, криптографически стойкий генератор псевдослучайных чисел) — генератор псевдослучайных чисел со свойствами, делающими его пригодным для использования в криптографии, также называется криптографическим генератором случайных чисел (cryptographic random number generator, CRNG).\n* **Datagram Transport Layer Security** (DTLS) — криптографический протокол, обеспечивающий безопасность связи по сетевому соединению. Он основан на протоколе TLS, но адаптирован для защиты ориентированных на датаграммы протоколов (обычно поверх UDP). Версия DTLS 1.3 стандартизирована в RFC 9147.\n* **Datagram Transport Layer Security Extension to Establish Keys for the Secure Real-time Transport Protocol** (DTLS-SRTP) — механизм использования DTLS-рукопожатия для формирования ключей сеанса SRTP. Стандартизирован в RFC 5764.\n* **Design Verification** (верификация архитектуры) — технический анализ архитектуры безопасности приложения.\n* **Dynamic Application Security Testing** (DAST, динамический анализ приложения) — технологии, предназначенные для обнаружения условий, указывающих на уязвимость системы безопасности в приложении, производящийся во время его выполнения.\n* **Dynamic Verification** (динамическая верификация) — использование автоматизированных инструментов, использующих сигнатуры уязвимостей для поиска проблем во время выполнения приложения.\n* **Fast IDentity Online** (FIDO) — набор стандартов аутентификации, которые позволяют использовать различные методы аутентификации, включая биометрические данные, модули доверенной платформы (TPM), USB-токены и т.д.\n* **Hardware Security Module** (HSM, аппаратный модуль безопасности) — аппаратный компонент, способный хранить криптографические ключи и другие секреты в защищённом виде.\n* **Hibernate Query Language** (HQL) — язык запросов, внешне похожий на SQL, используемый библиотекой Hibernate ORM.\n* **HTTP Strict Transport Security** (HSTS) — политика, которая предписывает браузеру подключаться к домену, возвращающему заголовок, только через TLS и при наличии действительного сертификата. Активируется с помощью поля заголовка ответа Strict-Transport-Security.\n* **HyperText Transfer Protocol** (HTTP) — протокол приложений для распределенных, гипермедиа (гипертекст+мультимедиа)-систем и совместной работы. Основа для передачи данных в World Wide Web.\n* **HyperText Transfer Protocol over SSL/TLS** (HTTPS) — Способ защиты HTTP-соединения путём его шифрования с использованием TLS.\n* **Identity Provider** (IdP) — также называется провайдером услуг аутентификации (CSP) в ссылках NIST. Сущность, которая предоставляет источник аутентификации для других приложений.\n* **Inactivity Timeout** (таймаут бездействия) — промежуток времени, в течение которого сессия может оставаться активной при отсутствии взаимодействия пользователя с приложением. Это составная часть механизма завершения сессии.\n* **Input Validation** (форматно-логический контроль) — нормализация и проверка корректности недоверенных входных данных.\n* **JSON Web Token** (JWT) – RFC 7519 определяет стандарт для объекта данных JSON, состоящего из раздела заголовка (header), который объясняет, как проверять объект, раздела тела (body), содержащего набор утверждений (claims), и раздела подписи (signature), содержащей цифровую подпись для проверки содержимого раздела тела. Это тип автономного (self-contained) токена.\n* **Local File Inclusion** (LFI) – атака, использующая уязвимые процедуры включения файлов в приложении, что приводит к подключению локальных файлов, уже присутствующих на сервере.\n* **Malicious Code** (вредоносный код) — код, попавший в приложение во время его разработки без ведома владельца, который обходит имеющуюся политику безопасности приложения. Не путать с вредоносным ПО, таким как вирусы или черви.\n* **Malware** (вредоносное ПО) — исполняемый код, который попадает в приложение во время выполнения без ведома пользователя или администратора приложения.\n* **Message authentication code** (MAC) — криптографическая контрольная сумма данных, вычисляемая алгоритмом генерации MAC, которая используется для обеспечения целостности и подлинности.\n* **Multi-factor authentication** (MFA, многофакторная аутентификация) — аутентификация, использующая два или более различных факторов.\n* **Mutual TLS** (mTLS) – См. TLS client authentication.\n* **Object-relational Mapping** (ORM) – система, позволяющая приложению делать запросы к реляционной/табличной базе данных, используя объектную модель, совместимую с приложением.\n* **One-time Password** (OTP, одноразовый пароль) — уникальный пароль, сгенерированный для одноразового использования.\n* **Open Worldwide Application Security Project** (OWASP) – бесплатно распространяемый проект и открытое международное сообщество, занимающееся повышением безопасности прикладного программного обеспечения. Наша миссия — сделать безопасность приложений «видимой», чтобы люди и организации могли принимать обоснованные решения о рисках безопасности приложений. См.: [https://www.owasp.org/](https://www.owasp.org/).\n* **Password-Based Key Derivation Function 2** (PBKDF2) – специальный односторонний алгоритм для формирования стойкого криптографического ключа на основе введённого текста (например, пароля) и дополнительного случайного значения — соли, которая затрудняет взлом пароля в режиме offline, если вместо исходного пароля хранится результирующее значение.\n* **Public Key Infrastructure** (PKI, инфраструктура открытых ключей) — механизм, который связывает открытые ключи с соответствующими идентификаторами сущностей. Привязка устанавливается посредством процесса регистрации и выдачи сертификатов в центре сертификации (CA) и с его помощью.\n* **Public Switched Telephone Network** (PSTN, коммутируемая телефонная сеть общего пользования, ТСОП, ТфОП) — традиционная телефонная сеть, соединяющая как стационарные, так и мобильные телефоны.\n* **Real-time Transport Protocol** (RTP) и **Real-time Transport Control Protocol** (RTCP) — два протокола, используемые совместно для передачи мультимедийных потоков. Применяются в стеке WebRTC. Стандартизированы в RFC 3550.\n* **Reference Token** (ссылочный токен) — тип токена, который служит указателем или идентификатором для состояния или метаданных, хранящихся на сервере, также известен как случайный или непрозрачный токен. В отличие от автономных (self-contained) токенов, сслылочный токен не содержат собственной информации, а зависят от контекста сервера. Ссылочный токен либо является идентификатором сессии, либо содержит его.\n* **Relying Party** (RP, проверяющая сторона) — как правило, приложение, которое полагается на то, что пользователь прошёл аутентификацию у отдельного поставщика аутентификации. Приложение проверяет токен или набор подписанных утверждений, предоставляемых этим поставщиком, чтобы убедиться, что пользователь является тем, за кого себя выдает.\n* **Remote File Inclusion** (RFI, подключение удалённых файлов) — атака, эксплуатирующая уязвимые процедуры включения файлов в приложении, что приводит к подключению удалённых файлов.\n* **Scalable Vector Graphics** (SVG, масштабируемая векторная графика) — язык разметки на основе XML для описания двумерной векторной графики.\n* **Secure Real-time Transport Protocol** (SRTP) и **Secure Real-time Transport Control Protocol** (SRTCP) – расширение протоколов RTP и RTCP, предоставляющее функции шифрования сообщений, проверки подлинности и обеспечения целостности. Стандартизирован в RFC 3711.\n* **Security Architecture** (архитектура безопасности) — абстракция дизайна приложения, которая определяет и описывает, где и как применяются меры безопасности, а также местоположение и категории информации.\n* **Security Assertion Markup Language** (SAML) — открытый стандарт для единого входа (SSO), основанный на передаче подписанных утверждений (обычно в формате XML) между поставщиком идентификации и проверяющей стороной.\n* **Security Configuration** (конфигурация безопасности) — конфигурация среды выполнения приложения, которая влияет на то, как применяются меры безопасности.\n* **Security Control** (мера обеспечения безопасности) — функция или компонент, который контролирует (например, меры контроля доступа) или приводит к действию по обеспечению безопасности (например, регистрирует запись в журнале аудита).\n* **Security information and event management** (SIEM) — система для обнаружения угроз, обеспечения соответствия требованиям и управления инцидентами безопасности путём сбора и анализа связанных с безопасностью данных из различных источников ИТ-инфраструктуры организации.\n* **Self-Contained Token** (автономный токен) — токен, который инкапсулирует один или несколько атрибутов, не зависящих от серверного состояния или другого внешнего хранилища. Эти токены обеспечивают подлинность и целостность содержащихся в них атрибутов, позволяя осуществлять безопасный обмен информацией между системами «без сохранения состояния». Автономные токены обычно защищаются с помощью криптографических методов, таких как цифровые подписи или коды аутентификации сообщений (MAC), для обеспечения подлинности, целостности, а в некоторых случаях и конфиденциальности своих данных. Распространёнными примерами являются SAML Assertions и JWT.\n* **Server-side Request Forgery** (SSRF, подделка запросов на стороне сервера) — атака, которая злоупотребляет функциональными возможностями сервера для чтения или обновления внутренних ресурсов путем предоставления или изменения URL-адреса, по которому код, запущенный на сервере, будет читать или отправлять данные.\n* **Session Description Protocol** (SDP) — формат сообщений для настройки мультимедийного сеанса (используется, например, в WebRTC). Стандартизирован в RFC 4566.\n* **Session Identifier** или **Session ID** (идентификатор сессии) — ключ, который идентифицирует сессию с сохранением состояния, хранящийся на серверной стороне. Передаётся клиенту и обратно с помощью ссылочного токена (reference token).\n* **Session Token** (сессионный токен) — общий термин, используемый в данном стандарте для обозначения токена или значения, применяемого в сессиях без сохранения состояния (которые используют автономный токен) или в сессиях с сохранением состояния (которые используют ссылочный токен).\n* **Session Traversal Utilities for NAT** (STUN) — протокол, используемый для преодоления ограничений NAT с целью установления одноранговой связи. Стандартизирован в RFC 3489.\n* **Single-factor authenticator** — Механизм проверки аутентификации пользователя. Фактором аутентификации может быть что-то, что вы знаете (запоминаемые секреты, пароли, парольные фразы, PIN-коды), что-то, что вы представляете собой (биометрия, отпечатки пальцев, сканы лица), или что-то, чем вы владеете (OTP-токены, криптографическое устройство, такое как смарт-карта).\n* **Single Sign-on Authentication** (SSO, аутентификация единого входа) — пользователь входит в одно приложение, одновременно получая возможность войти в несколько других, без необходимости повторной аутентификации. Например, когда вы входите в Google, вы автоматически входите в другие сервисы Google, такие как YouTube, Google Docs, Gmail и т.д.\n* **Software bill of materials** (SBOM) — структурированный и исчерпывающий перечень всех компонентов, модулей, библиотек, фреймворков и других ресурсов, необходимых для сборки или компиляции программного приложения.\n* **Software Composition Analysis** (SCA, композиционный анализ) — Совокупность технологий, предназначенных для анализа состава приложений, зависимостей, библиотек и пакетов на наличие уязвимостей безопасности в используемых версиях компонентов. Не следует путать с анализом исходного кода, который теперь обычно обозначается как SAST.\n* **Software development lifecycle** (SDLC, жизненный цикл разработки программного обеспечения) – пошаговый процесс разработки ПО, начиная с первоначальных требований, и заканчивая развертыванием и сопровождением.\n* **SQL Injection** (SQLi, SQL-инъекция) — метод внедрения кода, используемый для атаки приложений, управляемых данными, в котором вредоносные SQL-выражения вставляются в точку входа.\n* **Stateful Session Mechanism** (механизм сессии с сохранением состояния) — механизм управления сессией, когда приложение сохраняет состояние сеанса на серверной стороне, который обычно соответствует токену сеанса, сгенерированному с использованием криптографически стойкого генератора псевдослучайных чисел (CSPRNG), и выданному конечному пользователю.\n* **Stateless Session Mechanism** (механизм сессии без сохранения состояния) — механизм управления сессией, который использует автономный токен, который передаётся клиентам и содержит информацию о сеансе, не обязательно хранящуюся в службе, которая затем получает и проверяет токен. На практике службе потребуется доступ к некоторой информации о сеансе (например, к списку отозванных JWT), чтобы иметь возможность применять необходимые меры безопасности.\n* **Static application security testing** (SAST, статический анализ безопасности приложений) — набор технологий, предназначенных для анализа исходного кода, байт-кода и бинарных файлов приложения с целью выявления условий на уровне кода или архитектуры, указывающих на уязвимости безопасности. Решения SAST анализируют приложение «изнутри наружу» в статическом состоянии (без выполнения).\n* **Threat Modeling** (моделирование угроз) — метод, состоящий в совершенствовании архитектур безопасности для выявления нарушителей, границ доверия, мер безопасности, а также ключевых технических и бизнес-активов.\n* **Time-of-check to time-of-use** (TOCTOU) — ситуация, когда приложение проверяет состояние ресурса перед его использованием, но состояние ресурса может быть изменено между проверкой и использованием. Это может сделать результаты проверки недействительными и привести к ситуации, когда приложение выполняет некорректные действия из-за несоответствия состояния.\n* **Time based One-time Passwords** (TOTPs) — метод создания OTP, при котором текущее время является входным аргументом для алгоритма формирования пароля.\n* **TLS client authentication**, также называемый **Mutual TLS** (mTLS) — в стандартном TLS-соединении клиент может использовать сертификат, предоставленный сервером, для проверки подлинности сервера. При использовании mTLS клиент также использует свой собственный закрытый ключ и сертификат, чтобы позволить серверу проверить подлинность клиента.\n* **Transport Layer Security** (TLS, безопасность транспортного уровня) — криптографические протоколы, обеспечивающие безопасность канала связи по сетевому соединению.\n* **Traversal Using Relays around NAT** (TURN) — расширение протокола STUN, использующее TURN-сервер в качестве ретранслятора, когда прямое одноранговое соединение не может быть установлено. Стандартизировано в RFC 8656.\n* **Trusted execution environment** (TEE) — изолированная среда выполнения, обеспечивающая безопасное исполнение приложений вне зависимости от состояния остальной системы.\n* **Trusted Platform Module** (TPM, модуль доверенной платформы) — тип HSM, который обычно является компонентом другого оборудования, например, материнской платы, и выступает в роли «корня доверия» для этой системы.\n* **Trusted Service Layer** (уровень доверенных служб) — любая доверенная точка принудительного контроля, такая как микросервис, бессерверный API, серверная часть, доверенный API на клиентском устройстве с безопасной загрузкой, партнёрские или внешние API и т.д. «Доверенный» означает, что нет опасений, что недоверенный пользователь сможет обойти или пропустить слой или элементы управления, реализованные на этом уровне.\n* **Uniform Resource Identifier** (URI, унифицированный идентификатор ресурса) — это строка символов, используемая для идентификации ресурса, например, веб-страницы, почтового адреса, места.\n* **Uniform Resource Locator** (URL, унифицированный адрес ресурса) — это строка, указывающая местоположение ресурса в Интернете.\n* **Universally Unique Identifier** (UUID, универсальный уникальный идентификатор) — уникальный номер-идентификатор, используемый в качестве средства идентификации в программном обеспечении.\n* **Verifier** (верификатор/аудитор) — лицо или группа людей, которые анализируют безопасность приложения на соответствие требованиям OWASP ASVS.\n* **Web Real-Time Communication** (WebRTC) — стек протоколов и связанный с ним веб-API, используемые для передачи мультимедийных потоков в веб-приложениях, обычно в контексте телеконференций. Основан на SRTP, SRTCP, DTLS, SDP и STUN/TURN.\n* **WebSocket over TLS** (WSS) — практика защиты WebSocket-соединения путём размещения протокола WebSocket поверх протокола TLS.\n* **What You See Is What You Get** (WYSIWYG) – тип редактора гипермедиа, который показывает, как на самом деле будет выглядеть содержимое при отображении, а не код разметки, управляющий отображением.\n* **X.509 Certificate** — электронный сертификат, соответствующий общепринятому международному стандарту инфраструктуры открытых ключей X.509 (PKI) для проверки принадлежности открытого ключа идентификатору пользователя, компьютера или сервиса, указанному в сертификате.\n* **XML eXternal Entity** (XXE) — тип элемента XML, который может получать доступ к локальному или удаленному содержимому через объявленный идентификатор. Может привести к атакам инъекции.\n", "timestamp": "2025-10-24T11:40:17.070561"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x91-Appendix-B_References.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x91-Appendix-B_References.md", "content": "# Приложение B: Полезные ссылки\n\nСледующие проекты OWASP, скорее всего, будут полезны для читателей/последователей этого стандарта:\n\n## Основные проекты OWASP\n\n1. Проект OWASP Top 10: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)\n2. OWASP Web Security Testing Guide: [https://owasp.org/www-project-web-security-testing-guide/](https://owasp.org/www-project-web-security-testing-guide/)\n3. OWASP Proactive Controls: [https://owasp.org/www-project-proactive-controls/](https://owasp.org/www-project-proactive-controls/)\n4. OWASP Software Assurance Maturity Model (SAMM): [https://owasp.org/www-project-samm/](https://owasp.org/www-project-samm/)\n5. OWASP Secure Headers Project: [https://owasp.org/www-project-secure-headers/](https://owasp.org/www-project-secure-headers/)\n\n## Проект OWASP Cheat Sheet Series\n\n[В этом проекте](https://owasp.org/www-project-cheat-sheets/) есть памятки, которые будут актуальны для многих требований ASVS.\n\nСопоставление памяток с требованиями ASVS можно найти здесь: [https://cheatsheetseries.owasp.org/IndexASVS.html](https://cheatsheetseries.owasp.org/IndexASVS.html)\n\n## Проекты Mobile Security\n\n1. OWASP Mobile Security Project: [https://owasp.org/www-project-mobile-security/](https://owasp.org/www-project-mobile-security/)\n2. OWASP Mobile Top 10 Risks: [https://owasp.org/www-project-mobile-top-10/](https://owasp.org/www-project-mobile-top-10/)\n3. OWASP Mobile Security Testing Guide and Mobile Application Security Verification Standard: [https://owasp.org/www-project-mobile-security-testing-guide/](https://owasp.org/www-project-mobile-security-testing-guide/)\n\n## Проект OWASP Internet of Things\n\n1. OWASP Internet of Things Project: [https://owasp.org/www-project-internet-of-things/](https://owasp.org/www-project-internet-of-things/)\n\n## Проект OWASP Serverless\n\n1. OWASP Serverless Project: [https://owasp.org/www-project-serverless-top-10/](https://owasp.org/www-project-serverless-top-10/)\n\n## Другие\n\nСледующие веб-сайты, скорее всего, также будут полезны для читателей/последователей этого стандарта:\n\n1. SecLists Github: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)\n2. MITRE Common Weakness Enumeration: [https://cwe.mitre.org/](https://cwe.mitre.org/)\n3. PCI Security Standards Council: [https://www.pcisecuritystandards.org/](https://www.pcisecuritystandards.org/)\n4. PCI Data Security Standard (DSS) v3.2.1 Requirements and Security Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)\n5. PCI Software Security Framework - Secure Software Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-Software-Standard-v1_0.pdf)\n6. PCI Secure Software Lifecycle (Secure SLC) Requirements and Assessment Procedures: [https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf](https://www.pcisecuritystandards.org/documents/PCI-Secure-SLC-Standard-v1_0.pdf)\n7. OWASP ASVS 4.0 Testing Guide [https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide](https://github.com/BlazingWind/OWASP-ASVS-4.0-testing-guide)\n", "timestamp": "2025-10-24T11:40:17.211064"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x92-Appendix-C_Cryptography.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x92-Appendix-C_Cryptography.md", "content": "# Приложение C: Стандарты криптографии\n\nГлава «Криптография» выходит за рамки простого описания передовых практик. Она направлена ​​на углубление понимания принципов криптографии и поощрение внедрения более надёжных и современных методов безопасности. В этом приложении представлена ​​подробная техническая информация по каждому требованию, дополняющая общие стандарты, изложенные в главе «Криптография».\n\nВ этом приложении определяются уровни допустимости различных криптографических механизмов:\n\n* Допустимые механизмы (A) могут использоваться в приложениях.\n* Устаревшие механизмы (L) не должны использоваться в приложениях, но могут использоваться только для обеспечения совместимости с существующими устаревшими приложениями или кодом. Хотя использование таких механизмов в настоящее время само по себе не считается уязвимостью, их следует как можно скорее заменить более безопасными и перспективными механизмами.\n* Запрещенные механизмы (D) не должны использоваться, поскольку в настоящее время они считаются ненадежными или не обеспечивают достаточной безопасности.\n\nЭтот список может быть переопределен в контексте конкретного приложения по разным причинам, включая:\n\n* новые разработки в области криптографии;\n* соблюдение нормативных требований.\n\n## Инвентаризация и документирование криптографии\n\nВ этом разделе представлена ​​дополнительная информация\nдля V11.1 «Инвентаризация и документирование криптографии».\n\nВажно обеспечить регулярное обнаружение, инвентаризацию и оценку всех криптографических активов, таких как алгоритмы, ключи и сертификаты. Для уровня 3 это должно включать статическое и динамическое сканирование для обнаружения использования криптографии в приложении. Такие инструменты, как SAST и DAST, могут помочь в этом, но для более полного охвата могут потребоваться специализированные инструменты. Примеры бесплатных инструментов:\n\n* [CryptoMon - Network Cryptography Monitor - using eBPF, written in python](https://github.com/Santandersecurityresearch/CryptoMon)\n* [Cryptobom Forge Tool: Generating Comprehensive CBOMs from CodeQL Outputs](https://github.com/Santandersecurityresearch/cryptobom-forge)\n\n## Эквивалентная стойкость криптографических параметров\n\nОтносительные уровни безопасности различных криптографических систем приведены в следующей таблице (из [NIST SP 800-57 Часть 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final), стр.71):\n\n| Количество бит стойкости | Симметричные алгоритмы | Конечное поле | Целочисленная факторизация | Эллиптическая кривая |\n|--|--|--|--|--|\n| <= 80 | 2TDEA | L = 1024 <br> N = 160 | k = 1024 | f = 160-223 |\n| 112 | 3TDEA   | L = 2048 <br> N = 224 | k = 2048 | f = 224-255 |\n| 128 | AES-128 | L = 3072 <br> N = 256 | k = 3072 | f = 256-383 |\n| 192 | AES-192 | L = 7680 <br> N = 384 | k = 7680 | f = 384-511 |\n| 256 | AES-256 | L = 15360 <br> N = 512 | k = 15360 | f = 512+ |\n\nПримеры применения:\n\n* Криптография на конечных полях: DSA, FFDH, MQV\n* Криптография на целочисленной факторизации: RSA\n* Криптография на эллиптических кривых: ECDSA, EdDSA, ECDH, MQV\n\nПримечание: в этом разделе предполагается, что квантового компьютера не существует; если бы такой компьютер существовал, оценки для последних трех столбцов стали бы недействительными.\n\n## Случайные значения\n\nВ этом разделе представлена ​​дополнительная информация\nдля V11.5 «Случайные значения».\n\n| Имя | Версия/Ссылка | Примечания | Статус |\n|:-:|:-:|:-:|:-:|\n| `/dev/random` | Linux 4.8+ [(Окт 2016)](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=818e607b57c94ade9824dad63a96c2ea6b21baf3), также встречается в iOS, Android и других операционных системах POSIX на базе Linux. Основан на [RFC7539](https://datatracker.ietf.org/doc/html/rfc7539) | Использование ChaCha20. Найдено в iOS [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/secrandomcopybytes(_:_:_:)?language=objc) и Android [`Secure Random`](https://developer.android.com/reference/java/security/SecureRandom) с правильными настройками, предоставленными для каждого. | A |\n| `/dev/urandom` | Специальный файл ядра Linux для предоставления случайных данных | Обеспечивает высококачественный источник энтропии на основе аппаратной случайности. | A |\n| `AES-CTR-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | Используется в распространенных реализациях, таких как [Windows CNG API `BCryptGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) при установке [`BCRYPT_RNG_ALGORITHM`](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-identifiers). | A |\n| `HMAC-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `Hash-DRBG` | [NIST SP800-90A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf) | | A |\n| `getentropy()` | [OpenBSD](https://man.openbsd.org/getentropy.2), доступный в [Linux glibc 2.25+](https://man7.org/linux/man-pages/man3/getentropy.3.html) и [macOS 10.12+](https://support.apple.com/en-gb/guide/security/seca0c73a75b/web) | Обеспечивает безопасный доступ к случайным байтам непосредственно из источника энтропии ядра с помощью простого и минималистичного API. Он более современный и позволяет избежать ошибок, связанных со старыми API. | A |\n\nБазовая хэш-функция, используемая с HMAC-DRBG или Hash-DRBG, должна быть допустима для такого применения.\n\n## Алгоритмы шифрования\n\nВ этом разделе представлена ​​дополнительная информация\nдля V11.3 «Алгоритмы шифрования».\n\nДопустимые алгоритмы шифрования перечислены в порядке предпочтения.\n\n| Симметричные алгоритмы | Ссылка | Статус |\n|--|--|--|\n| AES-256 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| Salsa20 | [Salsa 20 specification](https://cr.yp.to/snuffle/spec.pdf) | A |\n| XChaCha20 | [XChaCha20 Draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha-03) | A |\n| XSalsa20 | [Extending the Salsa20 nonce](https://cr.yp.to/snuffle/xsalsa-20110204.pdf) | A |\n| ChaCha20 | [RFC 8439](https://www.rfc-editor.org/info/rfc8439) | A |\n| AES-192 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | A |\n| AES-128 | [FIPS 197](https://csrc.nist.gov/pubs/fips/197/final) | L |\n| 2TDEA | | D |\n| TDEA (3DES/3DEA) | | D |\n| IDEA | | D |\n| RC4 | | D |\n| Blowfish| | D |\n| ARC4 | | D |\n| DES | | D |\n\n### Режимы шифрования AES\n\nБлочные шифры, такие как AES, могут использоваться в различных режимах работы. Многие режимы работы, такие как Electronic codebook (ECB), небезопасны и не должны использоваться. Режимы работы Galois/Counter Mode (GCM) и «Счётчик с кодом аутентификации сообщений цепочки блоков шифра» (CCM) обеспечивают аутентифицированное шифрование и должны использоваться в современных приложениях.\n\nДопустимые режимы перечислены в порядке предпочтения.\n\n| Режим | Поддержка аутентификации | Ссылка | Статус | Ограничение |\n|--|--|--|--|--|\n| GCM | Yes | [NIST SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A | |\n| CCM | Yes | [NIST SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A | |\n| CBC | No | [NIST SP 800-38A](https://csrc.nist.gov/pubs/sp/800/38/a/final) | L | |\n| CCM-8 | Yes | | D | |\n| ECB | No | | D | |\n| CFB | No | | D | |\n| OFB | No | | D | |\n| CTR | No | | D | |\n\nПримечания:\n\n* Все зашифрованные сообщения должны быть аутентифицированы. Для ЛЮБОГО использования режима CBC ОБЯЗАТЕЛЬНО должен быть соответствующий алгоритм хеширования MAC для проверки сообщения. Как правило, он ДОЛЖЕН применяться в методе «Шифрование-затем-хеширование» (но в TLS 1.2 вместо этого используется «Хеширование-затем-шифрование»). Если это невозможно гарантировать, то CBC НЕ ДОЛЖЕН использоваться. Единственной опцией, где разрешено шифрование без алгоритма MAC, является шифрование диска.\n* При использовании CBC должно быть гарантировано, что проверка заполнения выполняется за константное время.\n* При использовании CCM-8 тег MAC имеет только 64 бита стойкости. Это не соответствует требованию 6.2.9, которое требует не менее 128 бит стойкости.\n* Шифрование диска считается выходящим за рамки ASVS. Поэтому в данном приложении не перечислены какие-либо утверждённые методы шифрования диска. В этом случае обычно допускается шифрование без аутентификации, и обычно используются режимы XTS, XEX и LRW.\n\n### Шифрование ключей\n\nШифрование ключа (key wrap) и соответствующее расшифрование ключа (key unwrap) — это метод защиты существующего ключа путём его инкапсуляции с использованием дополнительного механизма шифрования, чтобы исходный ключ не был явно раскрыт, например, во время передачи. Этот дополнительный ключ, используемый для защиты исходного ключа, называется ключом обёртывания (wrap key).\n\nЭта операция может выполняться в случае необходимости защиты ключей в местах, которые считаются недоверенными, а также для передачи конфиденциальных ключей по ненадежным сетям или внутри приложений.\nОднако перед началом процедуры шифрования/расшифрования ключей необходимо оценить характер исходного ключа (например, идентичность и назначение). Это может повлиять на безопасность и соответствие требованиям как исходных (до передачи), так и целевых систем/приложений, включая требования по аудиту действий с ключами (например, подпись) и хранению ключей.\n\nВ частности, для шифрования ключей ОБЯЗАТЕЛЬНО должен использоваться алгоритм AES-256, соответствующий [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) и с учётом перспективных мер защиты от квантовых угроз. Режимы шифрования с использованием AES применяются в следующем порядке предпочтения:\n\n| Шифрование ключа | Ссылка | Статус |\n|--|--|--|\n| KW | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n| KWP | [NIST SP 800-38F](https://csrc.nist.gov/pubs/sp/800/38/f/final) | A |\n\nAES-192 и AES-128 МОГУТ использоваться, если того требует сценарий использования, но обоснование этого ДОЛЖНО быть задокументировано в реестре криптографии организации.\n\n### Аутентифицированное шифрование\n\nЗа исключением шифрования диска, зашифрованные данные должны быть защищены от несанкционированного изменения с использованием какой-либо схемы аутентифицированного шифрования (AE), обычно с использованием схемы аутентифицированного шифрования с соответствующими данными (AEAD).\n\nПредпочтительно, чтобы приложение использовало утверждённую схему AEAD. В качестве альтернативы, оно может комбинировать утверждённую схему шифрования и утверждённый алгоритм MAC с конструкцией Encrypt-then-MAC.\n\nMAC-then-encrypt по-прежнему разрешен для совместимости со старыми приложениями. Он используется в TLS версии 1.2 со старыми наборами шифров.\n\n| Схема AEAD | Ссылка | Статус |\n|--------------------------|---------|-----|\n|AES-GCM | [SP 800-38D](https://csrc.nist.gov/pubs/sp/800/38/d/final) | A |\n|AES-CCM  | [SP 800-38C](https://csrc.nist.gov/pubs/sp/800/38/c/upd1/final) | A |\n|ChaCha-Poly1305 | [RFC 7539](https://datatracker.ietf.org/doc/html/rfc7539) | A |\n|AEGIS-256 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128 | [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|AEGIS-128L| [AEGIS: A Fast Authenticated Encryption Algorithm (v1.1)](https://competitions.cr.yp.to/round3/aegisv11.pdf) | A |\n|Encrypt-then-MAC | | A |\n|MAC-then-encrypt | | L |\n\n## Хэш-функции\n\nВ этом разделе представлена ​​дополнительная информация\nдля V11.4 «Хеширование и функции на основе хеширования».\n\n### Основные случаи использования хэш функций\n\nВ следующей таблице перечислены хэш-функции, допустимые для основных случаев использования криптографии, таких как цифровые подписи:\n\n* Допустимые хеш-функции обеспечивают высокую устойчивость к коллизиям и подходят для приложений с высоким уровнем безопасности.\n* Некоторые из этих алгоритмов обеспечивают высокую устойчивость к атакам при использовании с надлежащим управлением криптографическими ключами, поэтому они дополнительно допустимы для функций HMAC, KDF и RBG.\n* Хэш-функции с длиной выходного значения менее 254 бит обладают недостаточной устойчивостью к коллизиям и не должны использоваться для цифровой подписи или других приложений, требующих устойчивости к коллизиям. В других случаях они могут использоваться ТОЛЬКО для обеспечения совместимости и верификации с устаревшими системами, но не должны использоваться в новых разработках.\n\n| Хэш-функция | Ссылка | Статус | Ограничения |\n| -------------- | ------------------------------------------------------------- |--|--|\n| SHA3-512 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-384 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-384 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA3-256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| SHA-512/256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHA-256 |[FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | A | |\n| SHAKE256 |[FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | A | |\n| BLAKE2s | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE2b | [BLAKE2: simpler, smaller, fast as MD5](https://eprint.iacr.org/2013/322) | A | |\n| BLAKE3 | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf) | A | |\n| SHA-224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA-512/224 | [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA3-224 | [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| SHA-1 | [RFC 3174](https://www.rfc-editor.org/info/rfc3174) & [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | L | Not suitable for HMAC, KDF, RBG, digital signatures |\n| CRC (any length) |  | D |  |\n| MD4 | [RFC 1320](https://www.rfc-editor.org/info/rfc1320) | D | |\n| MD5 | [RFC 1321](https://www.rfc-editor.org/info/rfc1321) | D | |\n\n### Хэш-функции для хранения паролей\n\nДля безопасного хеширования паролей необходимо использовать специальные хеш-функции. Эти медленные алгоритмы хеширования снижают риск атак методом перебора и перебора по словарю, увеличивая вычислительную сложность взлома паролей.\n\n| KDF | Ссылка | Обязательные параметры | Статус |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| bcrypt | [A Future-Adaptable Password Scheme](https://www.researchgate.net/publication/2519476_A_Future-Adaptable_Password_Scheme) | cost ≥ 10 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 1,300,000 | L |\n\nДля хранения паролей можно использовать допустимые функции формирования ключей на основе паролей.\n\n## Функции формирования ключа (KDFs)\n\n### Основные функции формирования ключа\n\n| KDF              | Ссылка                                                                                        | Статус |\n| ---------------- | --------------------------------------------------------------------------------------------- | ------ |\n| HKDF             | [RFC 5869](https://www.rfc-editor.org/info/rfc5869)                                           | A      |\n| TLS 1.2 PRF      | [RFC 5248](https://www.rfc-editor.org/info/rfc5248)                                           | L      |\n| MD5-based KDFs   | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                           | D      |\n| SHA-1-based KDFs | [RFC 3174](https://www.rfc-editor.org/info/rfc3174) & [RFC 6194](https://www.rfc-editor.org/info/rfc6194) | D      |\n\n### Функции формирования ключа на основе пароля\n\n| KDF | Ссылка | Обязательные параметры | Статус |\n| --- | --------- | ------------------- | ------ |\n| argon2id | [RFC 9106](https://www.rfc-editor.org/info/rfc9106) | t = 1: m ≥ 47104 (46 MiB), p = 1<br>t = 2: m ≥ 19456 (19 MiB), p = 1<br>t ≥ 3: m ≥ 12288 (12 MiB), p = 1 | A |\n| scrypt | [RFC 7914](https://www.rfc-editor.org/info/rfc7914) | p = 1: N ≥ 2^17 (128 MiB), r = 8<br>p = 2: N ≥ 2^16 (64 MiB), r = 8<br>p ≥ 3: N ≥ 2^15 (32 MiB), r = 8 | A |\n| PBKDF2-HMAC-SHA-512 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 210,000 | A |\n| PBKDF2-HMAC-SHA-256 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 600,000 | A |\n| PBKDF2-HMAC-SHA-1 | [NIST SP 800-132](https://csrc.nist.gov/pubs/sp/800/132/final), [FIPS 180-4](https://csrc.nist.gov/pubs/fips/180-4/upd1/final) | iterations ≥ 1,300,000 | L |\n\n## Механизмы обмена ключами\n\nВ этом разделе представлена ​​дополнительная информация\nдля V11.6 «Криптография с публичным ключом».\n\n### Схемы KEX\n\nДля всех схем обмена ключами ДОЛЖНА быть обеспечена стойкость в 112 бит или выше, а их реализация ДОЛЖНА соответствовать выбору параметров, представленному в следующей таблице.\n\n| Схема | Параметры | Прямая секретность | Статус |\n|--|--|--|--|\n| Диффи-Хеллман на конечных полях (FFDH) | L >= 3072 & N >= 256 | Yes | A |\n| Диффи-Хеллман на эллиптических кривых (ECDH) | f >= 256-383 | Yes | A |\n| Передача зашифрованного ключа с помощью RSA-PKCS#1 v1.5 | | No | D |\n\nГде следующие параметры:\n\n* k — длина ключа для RSA.\n* L — длина открытого ключа, а N — длина закрытого ключа для криптографии на конечном поле.\n* f — диапазон длин ключей для ECC.\n\nЛюбая новая реализация НЕ ДОЛЖНА использовать схему, НЕ соответствующую [NIST SP 800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r3/final) & [B](https://csrc.nist.gov/pubs/sp/800/56/b/r2/final) и [NIST SP 800-77](https://csrc.nist.gov/pubs/sp/800/77/r1/final). В частности, IKEv1 НЕ ДОЛЖЕН использоваться в промышленной среде.\n\n### Группы Диффи-Хеллмана\n\nСледующие группы допустимы для реализации обмена ключами Диффи-Хеллмана. Уровни безопасности описаны в [NIST SP 800-56A](https://csrc.nist.gov/pubs/sp/800/56/a/r3/final), Приложение D, и [NIST SP 800-57 Часть 1, Ред. 5](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Группа           | Статус |\n|------------------|--------|\n| P-224, secp224r1 | A      |\n| P-256, secp256r1 | A      |\n| P-384, secp384r1 | A      |\n| P-521, secp521r1 | A      |\n| K-233, sect233k1 | A      |\n| K-283, sect283k1 | A      |\n| K-409, sect409k1 | A      |\n| K-571, sect571k1 | A      |\n| B-233, sect233r1 | A      |\n| B-283, sect283r1 | A      |\n| B-409, sect409r1 | A      |\n| B-571, sect571r1 | A      |\n| Curve448         | A      |\n| Curve25519       | A      |\n| MODP-2048        | A      |\n| MODP-3072        | A      |\n| MODP-4096        | A      |\n| MODP-6144        | A      |\n| MODP-8192        | A      |\n| ffdhe2048        | A      |\n| ffdhe3072        | A      |\n| ffdhe4096        | A      |\n| ffdhe6144        | A      |\n| ffdhe8192        | A      |\n\n## Коды аутентификации сообщений (MAC)\n\nКоды аутентификации сообщений (MAC) — это криптографические конструкции, используемые для проверки целостности и подлинности сообщения. MAC принимает сообщение и секретный ключ в качестве входных данных и создаёт тег фиксированного размера (значение MAC). MAC широко используется в протоколах защищённой связи (например, TLS/SSL) для обеспечения подлинности и целостности сообщений, которыми обмениваются стороны.\n\n| Алгоритм MAC  | Ссылка                                                                                    | Статус | Ограничения  |\n| --------------| ----------------------------------------------------------------------------------------- | -------| ------------ |\n| HMAC-SHA-256  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-384  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| HMAC-SHA-512  | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | A | |\n| KMAC128       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| KMAC256       | [NIST SP 800-185](https://csrc.nist.gov/pubs/sp/800/185/final)                             | A | |\n| BLAKE3 (keyed_hash mode) | [BLAKE3 one function, fast everywhere](https://github.com/BLAKE3-team/BLAKE3-specs/raw/master/blake3.pdf)  | A | |\n| AES-CMAC      | [RFC 4493](https://datatracker.ietf.org/doc/html/rfc4493) & [NIST SP 800-38B](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38b.pdf) | A | |\n| AES-GMAC      | [NIST SP 800-38D](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)            | A | |\n| Poly1305-AES  | [The Poly1305-AES message-authentication code](https://cr.yp.to/mac/poly1305-20050329.pdf)                  | A | |\n| HMAC-SHA-1    | [RFC 2104](https://www.rfc-editor.org/info/rfc2104) & [FIPS 198-1](https://csrc.nist.gov/pubs/fips/198-1/final) | L | |\n| HMAC-MD5      | [RFC 1321](https://www.rfc-editor.org/info/rfc1321)                                | D      | |\n\n## Цифровые подписи\n\nСхемы подписи ДОЛЖНЫ использовать утвержденные размеры ключей и параметры согласно [NIST SP 800-57 Часть 1](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final).\n\n| Алгоритм подписи               | Ссылка                                                     | Статус |\n| ------------------------------ | ---------------------------------------------------------- | ------ |\n| EdDSA (Ed25519, Ed448)         | [RFC 8032](https://www.rfc-editor.org/info/rfc8032)        | A      |\n| XEdDSA (Curve25519, Curve448)  | [XEdDSA](https://signal.org/docs/specifications/xeddsa/)   | A      |\n| ECDSA (P-256, P-384, P-521)    | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-5/final)  | A      |\n| RSA-RSSA-PSS                   | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | A      |\n| RSA-SSA-PKCS#1 v1.5            | [RFC 8017](https://www.rfc-editor.org/info/rfc8017)        | D      |\n| DSA (any key size)             | [FIPS 186-4](https://csrc.nist.gov/pubs/fips/186-4/final)  | D      |\n\n## Стандарты постквантового шифрования\n\nРеализации постквантовой криптографии (PQC) должны соответствовать стандартам [FIPS-203](https://csrc.nist.gov/pubs/fips/203/ipd), [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd) и [FIPS-205](https://csrc.nist.gov/pubs/fips/205/ipd). В настоящее время для этих стандартов доступно не так много примеров эталонных реализаций. Подробнее см. [объявление NIST о первых трёх финализированных постквантовых стандартах шифрования (август 2024 г.)](https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards).\n\nПредлагаемый постквантовый гибридный метод согласования ключей TLS [mlkem768x25519](https://datatracker.ietf.org/doc/draft-kwiatkowski-tls-ecdhe-mlkem/03/) поддерживается основными браузерами, такими как [Firefox версии 132](https://www.mozilla.org/en-US/firefox/132.0/releasenotes/) и [Chrome версии 131](https://security.googleblog.com/2024/09/a-new-path-for-kyber-on-web.html). Он может использоваться в средах тестирования криптографии или при наличии в библиотеках, допустимых отраслевыми или государственными органами.\n", "timestamp": "2025-10-24T11:40:17.324139"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x93-Appendix-D_Recommendations.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x93-Appendix-D_Recommendations.md", "content": "# Приложение D: Рекомендации\n\n## Введение\n\nПри подготовке версии 5.0 Стандарта верификации требований к безопасности приложений (ASVS) стало очевидно, что ряд существующих и вновь предложенных пунктов не следует включать в требования версии 5.0. Это могло быть связано с тем, что они не входят в область действия ASVS согласно определению для версии 5.0, или же потому, что, хотя эти идеи и представлялись полезными, их нельзя было сделать обязательными.\n\nНе желая полностью потерять все эти материалы, некоторые из них были включены в это приложение.\n\n## Рекомендуемые механизмы, входящие в область применения\n\nСледующие пункты входят в область действия ASVS. Они не должны быть обязательными, но настоятельно рекомендуется рассматривать их как часть безопасного приложения.\n\n* Необходимо предоставить индикатор надежности пароля, чтобы помочь пользователям установить более стойкий пароль.\n* Создайте общедоступный файл security.txt в корневом каталоге или каталоге .well-known приложения, в котором будет чётко указана ссылка или адрес электронной почты, по которым пользователи смогут связаться с владельцами по вопросам безопасности.\n* В дополнение к проверке на уровне доверенных служб следует применять проверку входных данных на стороне клиента, поскольку это даёт хорошую возможность обнаружить, когда кто-то обходит клиентские средства защиты при попытке атаки на приложение.\n* Предотвращайте появление в поисковых системах случайно доступных и конфиденциальных страниц с помощью файла robots.txt, заголовка ответа X-Robots-Tag или метатега robots.html.\n* При использовании GraphQL реализуйте логику авторизации на уровне бизнес-логики, а не на уровне GraphQL или резолвера, чтобы избежать необходимости обрабатывать авторизацию на каждом отдельном интерфейсе.\n\nСсылки:\n\n* [Дополнительная информация о security.txt, включая ссылку на RFC](https://securitytxt.org/)\n\n## Принципы безопасности программного обеспечения\n\nСледующие пункты ранее присутствовали в ASVS, но они не являются требованиями. Скорее, это принципы, которые следует учитывать при реализации мер безопасности, соблюдение которых приведет к повышению надежности этих мер. К ним относятся:\n\n* Средства управления безопасностью должны быть централизованными, простыми (экономия времени), проверяемо безопасными и допускающими повторное использование. Это позволит избежать дублирования, отсутствия или неэффективности средств управления.\n* По возможности используйте ранее написанные и проверенные реализации средств управления безопасностью, а не полагайтесь на их реализацию с нуля.\n* В идеале для доступа к защищённым данным и ресурсам следует использовать единый механизм управления доступом. Все запросы должны проходить через этот механизм, чтобы избежать копирования и вставки или небезопасных альтернативных путей.\n* Управление доступом на основе атрибутов или функций — рекомендуемый шаблон, при котором код проверяет авторизацию пользователя для функции или элемента данных, а не только его роль. Разрешения по-прежнему должны предоставляться с использованием ролей.\n\n## Процессы обеспечения безопасности программного обеспечения\n\nРяд процессов обеспечения безопасности были исключены из ASVS 5.0, но всё ещё представляют собой хорошую идею. Проект OWASP SAMM может стать хорошим источником информации о том, как эффективно реализовать эти процессы. Ранее в ASVS присутствовали следующие элементы:\n\n* Убедитесь в использовании безопасного жизненного цикла разработки программного обеспечения, который обеспечивает безопасность на всех этапах разработки.\n* Убедитесь в применении моделирования угроз для каждого изменения дизайна или планирования спринта, чтобы выявлять угрозы, планировать контрмеры, способствовать надлежащему реагированию на риски и управлять тестированием безопасности.\n* Убедитесь, что все пользовательские истории и функции содержат функциональные ограничения безопасности. Например, \"Как пользователь, я должен иметь возможность просматривать и редактировать свой профиль, но не должен иметь возможности просматривать или редактировать чужой профиль\".\n* Убедитесь в наличии чек-листа для безопасной разработки, требований, политик и стандартов безопасности, а также в их доступности для разработчиков и тестировщиков.\n* Убедитесь, что существует непрерывный процесс, гарантирующий отсутствие в исходном коде приложения бэкдоров, вредоносного кода (такого как атаки типа «нарезка салями», обход логики или «логические бомбы») и недокументированных или скрытых функций (например, «пасхальных яиц», небезопасных инструментов отладки). Выполнение требований этого раздела невозможно без полного доступа к исходному коду, включая сторонние библиотеки, и поэтому, вероятно, подходит только для приложений, требующих высочайшего уровня безопасности.\n* Убедитесь, что в средах развертывания реализованы механизмы обнаружения и реагирования на отклонения конфигурации. Это может включать использование неизменяемой инфраструктуры, автоматическое повторное развертывание с безопасной базовой конфигурацией или инструменты обнаружения отклонений, сравнивающие текущее состояние с утверждёнными конфигурациями.\n* Убедитесь, что усиление защиты конфигурации выполняется для всех сторонних продуктов, библиотек, фреймворков и служб в соответствии с их индивидуальными рекомендациями.\n\nСсылки:\n\n* [OWASP Threat Modeling Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)\n* [OWASP Threat modeling](https://owasp.org/www-community/Application_Threat_Modeling)\n* [OWASP Software Assurance Maturity Model Project](https://owasp.org/www-project-samm/)\n* [Microsoft SDL](https://www.microsoft.com/en-us/securityengineering/sdl/)\n", "timestamp": "2025-10-24T11:40:17.429161"}
{"source": "github", "repo": "OWASP/ASVS", "file": "5.0/ru/0x94-Appendix-E_Contributors.md", "url": "https://github.com/OWASP/ASVS/blob/master/5.0/ru/0x94-Appendix-E_Contributors.md", "content": "# Приложение E: Участники\n\nМы выражаем благодарность следующим людям, которые комментировали или открывали пул-реквесты после выпуска ASVS 4.0.0.\n\nЕсли вам известно о каких-либо ошибках или вы хотите, чтобы ваше имя отображалось иначе, пожалуйста, сообщите нам об этом.\n\n| | | | |\n|---|---|---|---|\n| Johan Sydseter ([sydseter](https://github.com/sydseter)) | luis servin ([lfservin](https://github.com/lfservin)) | Oleksii Dovydkov ([oleksiidov](https://github.com/oleksiidov)) | IZUKA Masahiro ([maizuka](https://github.com/maizuka))  |\n| James Sulinski ([jsulinski](https://github.com/jsulinski)) | Eli Saad ([ThunderSon](https://github.com/ThunderSon)) | [kkshitish9](https://github.com/kkshitish9) | Andrew van der Stock ([vanderaj](https://github.com/vanderaj))  |\n| Rick M ([kingthorin](https://github.com/kingthorin)) | Bankde Eakasit ([Bankde](https://github.com/Bankde)) | Michael Gargiullo ([mgargiullo](https://github.com/mgargiullo)) | Raphael Dunant ([Racater](https://github.com/Racater))  |\n| Cesar Kohl ([cesarkohl](https://github.com/cesarkohl)) | [inaz0](https://github.com/inaz0) | Joerg Bruenner ([JoergBruenner](https://github.com/JoergBruenner)) | David Deatherage ([securitydave](https://github.com/securitydave))  |\n| John Carroll  ([yosignals](https://github.com/yosignals)) | Jim Fenton ([jimfenton](https://github.com/jimfenton)) | Matteo Pace ([M4tteoP](https://github.com/M4tteoP)) | Sebastien gioria ([SPoint42](https://github.com/SPoint42))  |\n| Steven van der Baan ([vdbaan](https://github.com/vdbaan)) | Jeremy Bonghwan Choi ([jeremychoi](https://github.com/jeremychoi)) | [craig-shony](https://github.com/craig-shony) | Riccardo Sirigu ([ricsirigu](https://github.com/ricsirigu))  |\n| Tomasz Wrobel ([tw2as](https://github.com/tw2as)) | Alena Dubeshko ([belalena](https://github.com/belalena)) | Rafael Green ([RafaelGreen1](https://github.com/RafaelGreen1)) | [mjang-cobalt](https://github.com/mjang-cobalt)  |\n| [clallier94](https://github.com/clallier94) | Kevin W. Wall ([kwwall](https://github.com/kwwall)) | Jordan Sherman ([jsherm-fwdsec](https://github.com/jsherm-fwdsec) / [deleterepo](https://github.com/deleterepo)) | Ingo Rauner ([ingo-rauner](https://github.com/ingo-rauner))  |\n| Dirk Wetter ([drwetter](https://github.com/drwetter)) | Moshe Zioni ([moshe-apiiro](https://github.com/moshe-apiiro)) | Patrick Dwyer ([coderpatros](https://github.com/coderpatros)) | David Clarke ([davidclarke-au](https://github.com/davidclarke-au))  |\n| Takaharu Ogasa ([takaharuogasa](https://github.com/takaharuogasa)) | Arkadii Yakovets ([arkid15r](https://github.com/arkid15r)) | Motoyasu Saburi ([motoyasu-saburi](https://github.com/motoyasu-saburi)) | [leirn](https://github.com/leirn)  |\n| [wet-certitude](https://github.com/wet-certitude) | [timhemel](https://github.com/timhemel) | RL Thornton ([thornshadow99](https://github.com/thornshadow99)) | Thomas Bandt ([aspnetde](https://github.com/aspnetde))  |\n| Roel Storms ([roelstorms](https://github.com/roelstorms)) | Jeroen Willemsen ([commjoen](https://github.com/commjoen)) | [anonymous-31](https://github.com/anonymous-31) | Kamran Saifullah ([deFr0ggy](https://github.com/deFr0ggy))  |\n| Steve Springett ([stevespringett](https://github.com/stevespringett)) | Spyros ([northdpole](https://github.com/northdpole)) | Hans Herrera ([hansphp](https://github.com/hansphp)) | [Marx314](https://github.com/Marx314)  |\n| [CarlosAllendes](https://github.com/CarlosAllendes) | Yonah Russ ([yruss972](https://github.com/yruss972)) | Sander Maijers ([sanmai-NL](https://github.com/sanmai-NL)) | Luboš Bretschneider  ([bretik](https://github.com/bretik))  |\n| Eva Sarafianou ([esarafianou](https://github.com/esarafianou)) | Ata Seren [ataseren](https://github.com/ataseren) | Steve Thomas ([Sc00bz](https://github.com/Sc00bz)) | Dominique RIGHETTO ([righettod](https://github.com/righettod))  |\n| Steven van der Baan ([svdb-ncc](https://github.com/svdb-ncc)) | Michael Vacarella ([Aif4thah](https://github.com/Aif4thah)) | Tonimir Kisasondi ([tkisason](https://github.com/tkisason)) | Stefan Streichsbier ([streichsbaer](https://github.com/streichsbaer))  |\n| [hi-unc1e](https://github.com/hi-unc1e) | sb3k ([starbuck3000](https://github.com/starbuck3000)) | [mario-platt](https://github.com/mario-platt) | Devdatta Akhawe ([devd](https://github.com/devd))  |\n| Michael Gissing ([scolytus](https://github.com/scolytus)) | Jet Anderson ([thatsjet](https://github.com/thatsjet)) | Dave Wichers ([davewichers](https://github.com/davewichers)) | Jonny Schnittger ([JonnySchnittger](https://github.com/JonnySchnittger))  |\n| Silvia Väli ([silviavali](https://github.com/silviavali)) | [jackgates73](https://github.com/jackgates73) | [1songb1rd](https://github.com/1songb1rd) | Timur - ([timurozkul](https://github.com/timurozkul))  |\n| Gareth Heyes ([hackvertor](https://github.com/hackvertor)) | [appills](https://github.com/appills) | [suvikaartinen](https://github.com/suvikaartinen) | chaals ([chaals](https://github.com/chaals))  |\n| DanielPharos ([AtlasHackert](https://github.com/AtlasHackert)) | will Farrell ([willfarrell](https://github.com/willfarrell)) | Alina Vasiljeva ([avasiljeva](https://github.com/avasiljeva)) | Paul McCann ([ismisepaul](https://github.com/ismisepaul))  |\n| Sage ([SajjadPourali](https://github.com/SajjadPourali)) | [rbsec](https://github.com/rbsec) | Benedikt Bauer ([mastacheata](https://github.com/mastacheata)) | James Jardine ([jamesjardine](https://github.com/jamesjardine))  |\n| Mark Burnett ([m8urnett](https://github.com/m8urnett)) | [dschwarz91](https://github.com/dschwarz91) | Cyber-AppSec ([Cyber-AppSec](https://github.com/Cyber-AppSec)) | [Tib3rius](https://github.com/Tib3rius)  |\n| BitnessWise ([bitnesswise](https://github.com/bitnesswise)) | damienbod ([damienbod](https://github.com/damienbod)) | Jared Meit ([jmeit-fwdsec](https://github.com/jmeit-fwdsec)) | Stefan Seelmann ([sseelmann](https://github.com/sseelmann))  |\n| Brendan O'Connor ([ussjoin](https://github.com/ussjoin)) | Andrei Titov ([andrettv](https://github.com/andrettv)) | Hans-Petter Fjeld ([atluxity](https://github.com/atluxity)) | [markehack](https://github.com/markehack)  |\n| Neil Madden ([NeilMadden](https://github.com/NeilMadden)) | Michael Geramb ([mgeramb](https://github.com/mgeramb)) | Osama Elnaggar ([ossie-git](https://github.com/ossie-git)) | [mackowski](https://github.com/mackowski)  |\n| Ravi Balla ([raviballa](https://github.com/raviballa)) | Hazana ([hazanasec](https://github.com/hazanasec)) | David Means ([dmeans82](https://github.com/dmeans82)) | Alexander Stein ([tohch4](https://github.com/tohch4))  |\n| BaeSenseii ([baesenseii](https://github.com/baesenseii)) | Vincent De Schutter ([VincentDS](https://github.com/VincentDS)) | S Bani ([sbani](https://github.com/sbani)) | Mitsuaki Akiyama ([mak1yama](https://github.com/mak1yama))  |\n| Christopher Loessl ([hashier](https://github.com/hashier)) | [victorxm](https://github.com/victorxm) | Michal Rada ([michalradacz](https://github.com/michalradacz)) | Veeresh Devireddy ([drveresh](https://github.com/drveresh))  |\n| [MaknaSEO](https://github.com/MaknaSEO) | [darkzero2022](https://github.com/darkzero2022) | Liam ([LiamDobbelaere](https://github.com/LiamDobbelaere)) | Frank Denis ([jedisct1](https://github.com/jedisct1))  |\n| Otto Sulin ([ottosulin](https://github.com/ottosulin)) | [carllaw6885](https://github.com/carllaw6885) | Anders Johan Holmefjord ([aholmis](https://github.com/aholmis)) | Richard Fritsch ([rfricz](https://github.com/rfricz))  |\n| [mesutgungor](https://github.com/mesutgungor) | Scott Helme ([ScottHelme](https://github.com/ScottHelme)) | Carlo Reggiani ([carloreggiani](https://github.com/carloreggiani)) | Suyash Srivastava ([suyash5053](https://github.com/suyash5053))  |\n| Mark Potter ([markonweb](https://github.com/markonweb)) | Arjan Lamers ([alamers](https://github.com/alamers)) | Gøran Breivik ([gobrtg](https://github.com/gobrtg)) | [flo-blg](https://github.com/flo-blg)  |\n| Guillaume Déflache ([guillaume-d](https://github.com/guillaume-d)) | Toufik Airane ([toufik-airane](https://github.com/toufik-airane)) | Keith Hoodlet ([securingdev](https://github.com/securingdev)) | Sinner ([SoftwareSinner](https://github.com/SoftwareSinner))  |\n| [iloving](https://github.com/iloving) | Jeroen Beckers ([TheDauntless](https://github.com/TheDauntless)) | Joubin Jabbari ([joubin](https://github.com/joubin)) | yu fujioka ([fujiokayu](https://github.com/fujiokayu))  |\n| execjosh ([execjosh](https://github.com/execjosh)) | Alicja Kario ([tomato42](https://github.com/tomato42)) | Sidney Ribeiro ([srjsoftware](https://github.com/srjsoftware)) | Gabriel Marquet ([Gby56](https://github.com/Gby56))  |\n| Drew Schulz ([drschulz](https://github.com/drschulz)) | [bedirhan](https://github.com/bedirhan) | [muralito](https://github.com/muralito) | Ronnie Flathers ([ropnop](https://github.com/ropnop))  |\n| Philippe De Ryck ([philippederyck](https://github.com/philippederyck)) | Malte ([mal33](https://github.com/mal33)) | [MazeOfThoughts](https://github.com/MazeOfThoughts) | Andreas Falk ([andifalk](https://github.com/andifalk))  |\n| Javi ([javixeneize](https://github.com/javixeneize)) | Daniel Hahn ([averell23](https://github.com/averell23)) | [borislav-c](https://github.com/borislav-c) | Robin Wood ([digininja](https://github.com/digininja))  |\n| [miro2ns](https://github.com/miro2ns) | Jan Dockx ([jandockx](https://github.com/jandockx)) | [vipinsaini434](https://github.com/vipinsaini434) | [priyanshukumar397](https://github.com/priyanshukumar397)  |\n| Nat Sakimura ([sakimura](https://github.com/sakimura)) | Benjamin Häublein ([BenjaminHae](https://github.com/BenjaminHae)) | [unknown-user-from](https://github.com/unknown-user-from) | Ali Ramazan TAŞDELEN ([alitasdln](https://github.com/alitasdln))  |\n| Pedro Escaleira ([oEscal](https://github.com/oEscal)) | Josh ([josh-hemphill](https://github.com/josh-hemphill)) | Tim Würtele ([SECtim](https://github.com/SECtim)) | AviD ([avidouglen](https://github.com/avidouglen))  |\n| SheHacksPurple ([shehackspurple](https://github.com/shehackspurple)) | [fcerullo-cycubix](https://github.com/fcerullo-cycubix) | Hector Eryx Paredes Camacho ([heryxpc](https://github.com/heryxpc)) | Irene Michlin ([irene221b](https://github.com/irene221b))  |\n| Jonah Y-M ([TG-Techie](https://github.com/TG-Techie)) | Dhiraj Bahroos ([bahroos](https://github.com/bahroos)) | Jef Meijvis ([jefmeijvis](https://github.com/jefmeijvis)) | [IzmaDoesItbeta](https://github.com/IzmaDoesItbeta)  |\n| Abdessamad TEMMAR ([TmmmmmR](https://github.com/TmmmmmR)) | [sectroyer](https://github.com/sectroyer) | Soh Satoh ([sohsatoh](https://github.com/sohsatoh)) | [regoravalaz](https://github.com/regoravalaz)  |\n| james-t ([james-bitherder](https://github.com/james-bitherder)) | Aram Hovsepyan ([aramhovsepyan](https://github.com/aramhovsepyan)) | [JaimeGomezGarciaSan](https://github.com/JaimeGomezGarciaSan) | [ValdiGit01](https://github.com/ValdiGit01)  |\n| iwatachan ([ishowta](https://github.com/ishowta)) | Vinod Anandan ([VinodAnandan](https://github.com/VinodAnandan)) | Kevin Kien ([KevinKien](https://github.com/KevinKien)) | [paul-williamson-swoop](https://github.com/paul-williamson-swoop)  |\n| [endergzr](https://github.com/endergzr) | Radhwan Alshamamri ([Rado0z](https://github.com/Rado0z)) | Grant Ongers ([rewtd](https://github.com/rewtd)) | Cure53 ([cure53](https://github.com/cure53))  |\n| [AliR2Linux](https://github.com/AliR2Linux) | Ads Dawson ([GangGreenTemperTatum](https://github.com/GangGreenTemperTatum)) | William Reyor ([BillReyor](https://github.com/BillReyor)) | gabe ([gcrow](https://github.com/gcrow))  |\n| [mascotter](https://github.com/mascotter) | [luissaiz](https://github.com/luissaiz) | Suren Manukyan ([vx-sec](https://github.com/vx-sec)) | Piotr Gliźniewicz  ([pglizniewicz](https://github.com/pglizniewicz))  |\n| Tadeusz Wachowski ([tadeuszwachowski](https://github.com/tadeuszwachowski)) | Nasir aka Nate ([andesec](https://github.com/andesec)) | [settantasette](https://github.com/settantasette) | Lars Haulin ([LarsH](https://github.com/LarsH))  |\n| Terence Eden ([edent](https://github.com/edent)) | [JasmineScholz](https://github.com/JasmineScholz) | Arun Sivadasan ([teavanist](https://github.com/teavanist)) | Yusuf GÜR ([yusuffgur](https://github.com/yusuffgur))  |\n| Troy Marshall ([troymarshall](https://github.com/troymarshall)) | Tanner Prynn ([tprynn](https://github.com/tprynn)) | Nick K. ([nickific](https://github.com/nickific)) | [raoul361](https://github.com/raoul361)  |\n| Azeem Ilyas ([TheAxZim](https://github.com/TheAxZim)) | Evo Stamatov ([avioli](https://github.com/avioli)) | Tim Potter ([timpotter87](https://github.com/timpotter87)) | Gavin Ray ([GavinRay97](https://github.com/GavinRay97))  |\n| monis ([demideus](https://github.com/demideus)) | Marcin Hoppe ([MarcinHoppe](https://github.com/MarcinHoppe)) | Grambulf ([ramshazar](https://github.com/ramshazar)) | Jordan Pike ([computersarebad](https://github.com/computersarebad))  |\n| Jason Rogers ([jason-invision](https://github.com/jason-invision)) | Ben Hall ([benbhall](https://github.com/benbhall)) | JamesPoppyCock ([jamesly123](https://github.com/jamesly123)) | WhiteHackLabs ([whitehacklabs](https://github.com/whitehacklabs))  |\n| Alex Gaynor ([alex](https://github.com/alex)) | Filip van Laenen ([filipvanlaenen](https://github.com/filipvanlaenen)) | [jeurgen](https://github.com/jeurgen) | [GraoMelo](https://github.com/GraoMelo)  |\n| Andreas Kurtz ([ay-kay](https://github.com/ay-kay)) | Tom Tervoort ([TomTervoort](https://github.com/TomTervoort)) | old man ([deveras](https://github.com/deveras)) | Marco Schnüriger ([marcortw](https://github.com/marcortw))  |\n| [stiiin](https://github.com/stiiin) | infoseclearn ([teaminfoseclearn](https://github.com/teaminfoseclearn)) | [hljupkij](https://github.com/hljupkij) | Noe ([nmarher](https://github.com/nmarher))  |\n| Lyz ([lyz-code](https://github.com/lyz-code)) | Martin Riedel ([mrtnrdl](https://github.com/mrtnrdl)) | KIM Jaesuck ([tcaesvk](https://github.com/tcaesvk)) | Barbara Schachner ([bschach](https://github.com/bschach))  |\n| René Reuter ([AresSec](https://github.com/AresSec)) | [carhackpils](https://github.com/carhackpils) | Tyler ([tyler2cr](https://github.com/tyler2cr)) | Hugo ([hasousa](https://github.com/hasousa))  |\n| Wouter Bloeyaert ([Someniak](https://github.com/Someniak)) | Mark de Rijk ([markderijkinfosec](https://github.com/markderijkinfosec)) | Ramin ([picohub](https://github.com/picohub)) | Philip D. Turner ([philipdturner](https://github.com/philipdturner))  |\n| Will Chatham ([willc](https://github.com/willc)) | | | |\n", "timestamp": "2025-10-24T11:40:17.511106"}
{"source": "github", "repo": "OWASP/ASVS", "file": "COMPILING.md", "url": "https://github.com/OWASP/ASVS/blob/master/COMPILING.md", "content": "# Document Builder\n\n<img src=\"https://owasp.org/www-project-application-security-verification-standard/assets/images/OWASP_ASVS_Linkedin_Banner-01.jpg\" width=\"700px\">\n\n## Github Actions\n\nThis is the recommended mechanism. The Github Actions in this repository will automatically rebuild the output formats every time on merge requests and on commits to main. It is likely to be easier to use this then to try and build locally.\n\nThe Actions will detect whether the v4.x content or the v5.x content has changed and rebuild the documents accordingly.\n\nWhilst the output scripts can also be run locally, this may not be currently stable.\n\n## Local Generation\n\n**Note:** This method is still in testing and may or may not function depending on your environment and underlying Operating System.\n\nStabilizing this is on our todo list but not a top priority.\n\n### Document Compilation Instructions\n1. Install Docker on your computer (see instructions for different architectures [in the Docker docs](https://docs.docker.com/engine/install/))\n2. If running WSL or WSL2 make sure that you can talk to the Docker Daemon from the console\n3. Build the docker image: `docker build ./docker --tag ghcr.io/owasp/asvs/documentbuilder:latest`\n4. Run `make` in this directory. It will compile the latest bleeding edge to the `dist` directory of the latest release. You can specify a \nparticular target version, i.e. `make 4.0`, or you can run `make all` to compile all versions.\n\n### Running Manually\nTo build the docker image manually, use this command:\n\n```\ndocker build ./docker --tag ghcr.io/owasp/asvs/documentbuilder:latest\n```\n\nTo run the document builder manually, use the following. The Volume you are mounting (`-v `) needs to be shared in the docker settings console for this to work:\n\n```\ndocker run --rm -v \"/Path/to/the/repo/4.0:/data\" ghcr.io/owasp/asvs/documentbuilder\n```\n\nTo download the docker image from the repository, first create a Personal Access Token with read access to packages.\nThen you can download the docker image from the asvs package repository: `https://github.com/OWASP/ASVS/pkgs/container/asvs%2Fdocumentbuilder`\n\n```\n$ echo <TOKEN> | docker login ghcr.io -u <USERNAME> --password-stdin\n$ docker pull ghcr.io/owasp/asvs/documentbuilder:latest\n```\n\n### Background\n\n#### Future Changes\n* Hosted *public* image to pull, so users don't have to build the docker image themselves or log in to ghcr.\n* Watcher to build files when source files change\n* Ability to select only certain format compilers from main Makefile\n\n#### Philosophy behind this effort\nIt should be easy and repeatable to create the documents. We need to provide the build environment in order to keep the effort low. This will allow for \nfuture interactions with a CI in GitLab.\n", "timestamp": "2025-10-24T11:40:28.140770"}
{"source": "github", "repo": "OWASP/ASVS", "file": "CONTRIBUTING.md", "url": "https://github.com/OWASP/ASVS/blob/master/CONTRIBUTING.md", "content": "# Contributing\n\n<img src=\"https://owasp.org/www-project-application-security-verification-standard/assets/images/OWASP_ASVS_Linkedin_Banner-01.jpg\" width=\"700px\">\n\n**Last Update:** This document has been updated as of the v5.0.0 release in May 2025.\n\n## Introduction\n\n### What is [OWASP](https://owasp.org/)?\n\nThe Open Worldwide Application Security Project (OWASP) is a nonprofit organization that works to improve the security of software. It has many programs to work towards this goal. One of those programs is the ASVS.\n\n### What is the [ASVS](https://owasp.org/www-project-application-security-verification-standard/)?\n\nThe OWASP Application Security Verification Standard (ASVS) Project provides a basis for testing web application technical security controls and also provides developers with a list of requirements for secure development.\n\nThe primary aim of the OWASP Application Security Verification Standard (ASVS) Project is to normalize the range in the coverage and level of rigor available in the market when it comes to performing Web application security verification using a commercially-workable open standard.\n\n### What is the Current Status of ASVS development?\n\nThe ASVS project released v5.0.0 during May 2025 which was a complete revamp compared to the previous version 4.0.3.\n\nYou can see the static version of this release on the v5.0.0 branch within the 5.0 folder. The master branch continues to be the \"bleeding edge\" and will contain any incremental changes made following the v5.0.0 release.\n\nWe will no longer be accepting changes to the 4.0 folder which is now fixed at the 4.0.3 release.\n\n### Release strategy\n\nASVS releases follow the pattern \"Major.Minor.Patch\" and the numbers provide information on what has changed within the release. In a major release, the first number will change, in a minor release, the second number will change, and in a patch release, the third number will change.\n\n* Major release - Full reorganization, almost everything may have changed, including requirement numbers and chapter and section structure. Reevaluation for compliance will be necessary (for example, 4.0.3 -> 5.0.0).\n* Minor release - Requirements may be added, removed, split, or merged but overall numbering and the section structure will stay the same with no additions or removals. Reevaluation for compliance will be necessary, but should be easier (for example, 5.0.0 -> 5.1.0). The restrictions mean that requirements within a sections may not be in ascending level order. Levels may be increased or decreased.\n* Patch release - Requirements may be removed (for example, if they are duplicates or outdated) or made less stringent, but an application that complied with the previous release will comply with the patch release as well (for example, 5.0.0 -> 5.0.1). A level number may be increased but not decreased.\n\nThe above specifically relates to the requirements in the ASVS. Changes to surrounding text and other content such as the appendices will not be considered to be a breaking change.\n\n## How can I help?\n\nWe would be glad to receive feedback to help us to further enhance the ASVS. Note however that having had intensive efforts to get out the recent release, there may be some delays in responses. Be assured that all issues will eventually be reviewed.\n\nAt this stage, we are most likely to immediately accept changes to surrounding text and other content such as the appendices which is not considered a breaking change for release purposes.\n\nThe next ASVS release is likely to be a \"patch\" release containing changes which are considered \"non-breaking\". This means that requirements may be removed (for example, if they are duplicates or outdated) or made less stringent, but an application that complied with the previous release will comply with the patch release as well. We are open to integrating changes that satisfy this definition although we need to decide on a tracking mechanism, which may also lead to a delay. \n\nIf you feel there are other important changes but they would be considered breaking for a patch release, you are welcome to open an issue but please note that the issue may not be progressed until we are considering a new minor or major release, for which there is currently no fixed timeline.\n\n## Additional Details for Helping\n\n### Before you open a Pull Request\n\nPlease do not open a pull request without first opening an associated issue. Please do not open an issue until you have used the search functionality to ensure that the issue has not previously been discussed and that there are no currently open issues relating to it. For example, [this link](https://github.com/OWASP/ASVS/issues?q=is%3Aissue+bcrypt) searches for issues (open and closed) related to bcrypt.\n\n### Numbering changes compared to the issues.\n\nNote that since there were major numbering changes between v4.0.3 and the bleeding edge version of v5.0.0 (known as v5.0.be), and between v5.0.be and the final v5.0.0 release. As such, a lot of the requirement numbers in the issues may be different, depending on when the discussion was taking place. The following rough guide to numbering applies:\n\n* The v4.0.3 numberings were valid at the time of its release in October 2021.\n* The v5.0.be numberings cover the period from then until the major renumbering around 27th March 2025\n* The v5.0.0 numberings cover the period from the major renumbering until the v5.0.0 release at the end of May 2025. \n\nThe mappings in the [mappings folder](https://github.com/OWASP/ASVS/tree/master/5.0/mappings/) can be used to check what number the requirement was at the point in time it was being discussed:\n\nIf you are comfortable that your query has not been previously discussed, you can open an issue. Please try and include the ASVS requirement number and text you are talking about in the issue to save having to jump back and forth and please carry out all discussion in the associated issue and not in a PR discussion.\n\n<!-- COMMENTING OUT FOR FUTURE USE\n\n  * Mapping from v4.0.3 to v5.0.0:\n    * <https://github.com/OWASP/ASVS/blob/master/5.0/mappings/mapping_v4.0.3_to_v5.0.0.yml> - mapping file\n    * <https://asvs.dev/mapping_v4.0.3_to_v5.0.0.html> - formatted output\n  * Mapping from v5.0.0 to v4.0.3:\n    * <https://github.com/OWASP/ASVS/blob/master/5.0/mappings/mapping_v5.0.0_to_v4.0.3.yml> - mapping file\n    * <https://asvs.dev/mapping_v5.0.0_to_v4.0.3.html> - formatted output\n\nTags in new (v5.0.0) mapping file:\n\n  * `ADDED` - new requirement\n  * `MOVED FROM x.y.z` - reference to the requirement number from v4.0.3. Must have a matching `MOVE TO` tag in the old mapping file.\n    * `GRAMMAR` - indicates that there are grammar or language corrections in the moved requirement, which don't change the requirement's meaning.\n    * `MODIFIED` - indicates that the meaning of the moved requirement was changed (more than just a language or grammar change).\n  * `SPLIT FROM x.y.z` - the v4.0.3 requirement was split to multiple requirements in v5.0.0. Must have a matching `SPLIT TO` in the old mapping file.\n  * `MERGED FROM x.y.z` - the v4.0.3 requirement has been merged with another requirement for v5.0.0. Must have a matching `MERGED TO` tag in the old mapping file.\n  * `COVERS x.y.z` - the v5.0.0 requirement covers the content of this v4.0.3 requirement. Must have a matching `COVERED BY x.y.z` tag in the old mapping file.\n\nTags in old (v4.0.3) mapping file:\n\n  * `DELETED` - the v4.0.3 requirement is deleted in the new version, with a reason.\n    * `DELETED, NOT IN SCOPE` - requirement has been decided to be out of the redefined scope of ASVS.\n    * `DELETED, INCORRECT` - requirement was invalid or provided inadvisable advice.\n    * `DELETED, NOT PRACTICAL` - the requirement was not practical (enough) to implement in reality.\n    * `DELETED, INSUFFICIENT IMPACT` - the requirement provided insufficient benefit to be worthwhile.\n    * `DELETED, MERGED TO x.y.z` - the requirement was merged to another requirement for v5.0.0. Must have a matching `MERGED FROM` tag in the new mapping file.\n    * `DELETED, COVERED BY x.y.z` - the requirement was a duplicate of or is covered by another requirement in v5.0.0. Must have a matching `COVERS` tag in the new mapping file.\n  * `MOVED TO x.y.z` - reference to the requirement number from v5.0.0. Must have a matching `MOVED FROM` tag in the new version\n  * `SPLIT TO x.y.z, i.j.k` - the v4.0.3 requirement is divided into multiple requirements in v5.0.0. Must have matching `SPLIT FROM` tags in the new mapping file.\n\n-->\n\n## Translations\n\nWe are now keen to receive translations for v5.0.0 of ASVS!\n\nNote that we are ONLY accepting translations based on markdown and not preformatted translations in Word or PDF format to make tracking and maintenance easier. \n\nIf you are interested in creating a translation, here are some pointers for how you can help us:\n\n* Please first of all search the repository to see if there is already a translation for your proposed language. We currently have completed or in-progress translations in the following languages (but please search anyway in case this list is superseded!):\n    * In-progress\n        * Persian (Farsi), [#3172](https://github.com/OWASP/ASVS/issues/3172)\n        * Ukrainian, see [#3174](https://github.com/OWASP/ASVS/issues/3174)\n        * Portuguese, see [#3182](https://github.com/OWASP/ASVS/issues/3182)\n        * Simplified Chinese, see [#3191](https://github.com/OWASP/ASVS/issues/3191)\n        * Korean, see [#3204](https://github.com/OWASP/ASVS/issues/3204)\n        * Spanish, see [#3238](https://github.com/OWASP/ASVS/issues/3238)\n        * Panjabi, see[#3252](https://github.com/OWASP/ASVS/issues/3252)\n    * v5.0.0\n        * [Turkish](./5.0/tr/)\n        * [Russian](./5.0/ru/)\n        * [French](./5.0/fr/)\n* If the language you are interested in appears, it would be great if you could reach out to the translator to see if you can help them.\n* Often there is work to do in creating markdown files or updating the translation to keep it up to date with latest changes.\n* We would request that you base your translation on the 5.0/en folder in the v5.0.0 branch as this is now static at the 5.0.0 version.\n* In order to start a translation, please start by forking the ASVS repository.\n* Take a copy of the /en folder and rename it to the 2 character language code which will be used for the translation.\n* You can then edit the markdown files to include your translation rather than the original English.\n* When you have completed the translation, please open a Pull Request against the v5.0.0 ASVS branch and one of the leaders will look at integrating it.\n* The leader will also use the relevant scripts to create the documents from the raw markdown (or you can if you want to save us some trouble).\n* Finally, the leader will back port the translation into the branch containing the ASVS version which was targeted (at this point, presumably v5.0.0).\n\nThank you for your help!!\n", "timestamp": "2025-10-24T11:40:28.384227"}
{"source": "github", "repo": "OWASP/ASVS", "file": "LICENSE.md", "url": "https://github.com/OWASP/ASVS/blob/master/LICENSE.md", "content": "Attribution-ShareAlike 4.0 International\n\n=======================================================================\n\nCreative Commons Corporation (\"Creative Commons\") is not a law firm and\ndoes not provide legal services or legal advice. Distribution of\nCreative Commons public licenses does not create a lawyer-client or\nother relationship. Creative Commons makes its licenses and related\ninformation available on an \"as-is\" basis. Creative Commons gives no\nwarranties regarding its licenses, any material licensed under their\nterms and conditions, or any related information. Creative Commons\ndisclaims all liability for damages resulting from their use to the\nfullest extent possible.\n\nUsing Creative Commons Public Licenses\n\nCreative Commons public licenses provide a standard set of terms and\nconditions that creators and other rights holders may use to share\noriginal works of authorship and other material subject to copyright\nand certain other rights specified in the public license below. The\nfollowing considerations are for informational purposes only, are not\nexhaustive, and do not form part of our licenses.\n\n     Considerations for licensors: Our public licenses are\n     intended for use by those authorized to give the public\n     permission to use material in ways otherwise restricted by\n     copyright and certain other rights. Our licenses are\n     irrevocable. Licensors should read and understand the terms\n     and conditions of the license they choose before applying it.\n     Licensors should also secure all rights necessary before\n     applying our licenses so that the public can reuse the\n     material as expected. Licensors should clearly mark any\n     material not subject to the license. This includes other CC-\n     licensed material, or material used under an exception or\n     limitation to copyright. More considerations for licensors:\n    wiki.creativecommons.org/Considerations_for_licensors\n\n     Considerations for the public: By using one of our public\n     licenses, a licensor grants the public permission to use the\n     licensed material under specified terms and conditions. If\n     the licensor's permission is not necessary for any reason--for\n     example, because of any applicable exception or limitation to\n     copyright--then that use is not regulated by the license. Our\n     licenses grant only permissions under copyright and certain\n     other rights that a licensor has authority to grant. Use of\n     the licensed material may still be restricted for other\n     reasons, including because others have copyright or other\n     rights in the material. A licensor may make special requests,\n     such as asking that all changes be marked or described.\n     Although not required by our licenses, you are encouraged to\n     respect those requests where reasonable. More considerations\n     for the public:\n    wiki.creativecommons.org/Considerations_for_licensees\n\n=======================================================================\n\nCreative Commons Attribution-ShareAlike 4.0 International Public\nLicense\n\nBy exercising the Licensed Rights (defined below), You accept and agree\nto be bound by the terms and conditions of this Creative Commons\nAttribution-ShareAlike 4.0 International Public License (\"Public\nLicense\"). To the extent this Public License may be interpreted as a\ncontract, You are granted the Licensed Rights in consideration of Your\nacceptance of these terms and conditions, and the Licensor grants You\nsuch rights in consideration of benefits the Licensor receives from\nmaking the Licensed Material available under these terms and\nconditions.\n\n\nSection 1 -- Definitions.\n\n  a. Adapted Material means material subject to Copyright and Similar\n     Rights that is derived from or based upon the Licensed Material\n     and in which the Licensed Material is translated, altered,\n     arranged, transformed, or otherwise modified in a manner requiring\n     permission under the Copyright and Similar Rights held by the\n     Licensor. For purposes of this Public License, where the Licensed\n     Material is a musical work, performance, or sound recording,\n     Adapted Material is always produced where the Licensed Material is\n     synched in timed relation with a moving image.\n\n  b. Adapter's License means the license You apply to Your Copyright\n     and Similar Rights in Your contributions to Adapted Material in\n     accordance with the terms and conditions of this Public License.\n\n  c. BY-SA Compatible License means a license listed at\n     creativecommons.org/compatiblelicenses, approved by Creative\n     Commons as essentially the equivalent of this Public License.\n\n  d. Copyright and Similar Rights means copyright and/or similar rights\n     closely related to copyright including, without limitation,\n     performance, broadcast, sound recording, and Sui Generis Database\n     Rights, without regard to how the rights are labeled or\n     categorized. For purposes of this Public License, the rights\n     specified in Section 2(b)(1)-(2) are not Copyright and Similar\n     Rights.\n\n  e. Effective Technological Measures means those measures that, in the\n     absence of proper authority, may not be circumvented under laws\n     fulfilling obligations under Article 11 of the WIPO Copyright\n     Treaty adopted on December 20, 1996, and/or similar international\n     agreements.\n\n  f. Exceptions and Limitations means fair use, fair dealing, and/or\n     any other exception or limitation to Copyright and Similar Rights\n     that applies to Your use of the Licensed Material.\n\n  g. License Elements means the license attributes listed in the name\n     of a Creative Commons Public License. The License Elements of this\n     Public License are Attribution and ShareAlike.\n\n  h. Licensed Material means the artistic or literary work, database,\n     or other material to which the Licensor applied this Public\n     License.\n\n  i. Licensed Rights means the rights granted to You subject to the\n     terms and conditions of this Public License, which are limited to\n     all Copyright and Similar Rights that apply to Your use of the\n     Licensed Material and that the Licensor has authority to license.\n\n  j. Licensor means the individual(s) or entity(ies) granting rights\n     under this Public License.\n\n  k. Share means to provide material to the public by any means or\n     process that requires permission under the Licensed Rights, such\n     as reproduction, public display, public performance, distribution,\n     dissemination, communication, or importation, and to make material\n     available to the public including in ways that members of the\n     public may access the material from a place and at a time\n     individually chosen by them.\n\n  l. Sui Generis Database Rights means rights other than copyright\n     resulting from Directive 96/9/EC of the European Parliament and of\n     the Council of 11 March 1996 on the legal protection of databases,\n     as amended and/or succeeded, as well as other essentially\n     equivalent rights anywhere in the world.\n\n  m. You means the individual or entity exercising the Licensed Rights\n     under this Public License. Your has a corresponding meaning.\n\n\nSection 2 -- Scope.\n\n  a. License grant.\n\n       1. Subject to the terms and conditions of this Public License,\n          the Licensor hereby grants You a worldwide, royalty-free,\n          non-sublicensable, non-exclusive, irrevocable license to\n          exercise the Licensed Rights in the Licensed Material to:\n\n            a. reproduce and Share the Licensed Material, in whole or\n               in part; and\n\n            b. produce, reproduce, and Share Adapted Material.\n\n       2. Exceptions and Limitations. For the avoidance of doubt, where\n          Exceptions and Limitations apply to Your use, this Public\n          License does not apply, and You do not need to comply with\n          its terms and conditions.\n\n       3. Term. The term of this Public License is specified in Section\n          6(a).\n\n       4. Media and formats; technical modifications allowed. The\n          Licensor authorizes You to exercise the Licensed Rights in\n          all media and formats whether now known or hereafter created,\n          and to make technical modifications necessary to do so. The\n          Licensor waives and/or agrees not to assert any right or\n          authority to forbid You from making technical modifications\n          necessary to exercise the Licensed Rights, including\n          technical modifications necessary to circumvent Effective\n          Technological Measures. For purposes of this Public License,\n          simply making modifications authorized by this Section 2(a)\n          (4) never produces Adapted Material.\n\n       5. Downstream recipients.\n\n            a. Offer from the Licensor -- Licensed Material. Every\n               recipient of the Licensed Material automatically\n               receives an offer from the Licensor to exercise the\n               Licensed Rights under the terms and conditions of this\n               Public License.\n\n            b. Additional offer from the Licensor -- Adapted Material.\n               Every recipient of Adapted Material from You\n               automatically receives an offer from the Licensor to\n               exercise the Licensed Rights in the Adapted Material\n               under the conditions of the Adapter's License You apply.\n\n            c. No downstream restrictions. You may not offer or impose\n               any additional or different terms or conditions on, or\n               apply any Effective Technological Measures to, the\n               Licensed Material if doing so restricts exercise of the\n               Licensed Rights by any recipient of the Licensed\n               Material.\n\n       6. No endorsement. Nothing in this Public License constitutes or\n          may be construed as permission to assert or imply that You\n          are, or that Your use of the Licensed Material is, connected\n          with, or sponsored, endorsed, or granted official status by,\n          the Licensor or others designated to receive attribution as\n          provided in Section 3(a)(1)(A)(i).\n\n  b. Other rights.\n\n       1. Moral rights, such as the right of integrity, are not\n          licensed under this Public License, nor are publicity,\n          privacy, and/or other similar personality rights; however, to\n          the extent possible, the Licensor waives and/or agrees not to\n          assert any such rights held by the Licensor to the limited\n          extent necessary to allow You to exercise the Licensed\n          Rights, but not otherwise.\n\n       2. Patent and trademark rights are not licensed under this\n          Public License.\n\n       3. To the extent possible, the Licensor waives any right to\n          collect royalties from You for the exercise of the Licensed\n          Rights, whether directly or through a collecting society\n          under any voluntary or waivable statutory or compulsory\n          licensing scheme. In all other cases the Licensor expressly\n          reserves any right to collect such royalties.\n\n\nSection 3 -- License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the\nfollowing conditions.\n\n  a. Attribution.\n\n       1. If You Share the Licensed Material (including in modified\n          form), You must:\n\n            a. retain the following if it is supplied by the Licensor\n               with the Licensed Material:\n\n                 i. identification of the creator(s) of the Licensed\n                    Material and any others designated to receive\n                    attribution, in any reasonable manner requested by\n                    the Licensor (including by pseudonym if\n                    designated);\n\n                ii. a copyright notice;\n\n               iii. a notice that refers to this Public License;\n\n                iv. a notice that refers to the disclaimer of\n                    warranties;\n\n                 v. a URI or hyperlink to the Licensed Material to the\n                    extent reasonably practicable;\n\n            b. indicate if You modified the Licensed Material and\n               retain an indication of any previous modifications; and\n\n            c. indicate the Licensed Material is licensed under this\n               Public License, and include the text of, or the URI or\n               hyperlink to, this Public License.\n\n       2. You may satisfy the conditions in Section 3(a)(1) in any\n          reasonable manner based on the medium, means, and context in\n          which You Share the Licensed Material. For example, it may be\n          reasonable to satisfy the conditions by providing a URI or\n          hyperlink to a resource that includes the required\n          information.\n\n       3. If requested by the Licensor, You must remove any of the\n          information required by Section 3(a)(1)(A) to the extent\n          reasonably practicable.\n\n  b. ShareAlike.\n\n     In addition to the conditions in Section 3(a), if You Share\n     Adapted Material You produce, the following conditions also apply.\n\n       1. The Adapter's License You apply must be a Creative Commons\n          license with the same License Elements, this version or\n          later, or a BY-SA Compatible License.\n\n       2. You must include the text of, or the URI or hyperlink to, the\n          Adapter's License You apply. You may satisfy this condition\n          in any reasonable manner based on the medium, means, and\n          context in which You Share Adapted Material.\n\n       3. You may not offer or impose any additional or different terms\n          or conditions on, or apply any Effective Technological\n          Measures to, Adapted Material that restrict exercise of the\n          rights granted under the Adapter's License You apply.\n\n\nSection 4 -- Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that\napply to Your use of the Licensed Material:\n\n  a. for the avoidance of doubt, Section 2(a)(1) grants You the right\n     to extract, reuse, reproduce, and Share all or a substantial\n     portion of the contents of the database;\n\n  b. if You include all or a substantial portion of the database\n     contents in a database in which You have Sui Generis Database\n     Rights, then the database in which You have Sui Generis Database\n     Rights (but not its individual contents) is Adapted Material,\n     including for purposes of Section 3(b); and\n\n  c. You must comply with the conditions in Section 3(a) if You Share\n     all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not\nreplace Your obligations under this Public License where the Licensed\nRights include other Copyright and Similar Rights.\n\n\nSection 5 -- Disclaimer of Warranties and Limitation of Liability.\n\n  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE\n     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS\n     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF\n     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,\n     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,\n     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR\n     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,\n     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT\n     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT\n     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\n\n  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE\n     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,\n     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,\n     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,\n     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR\n     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN\n     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR\n     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR\n     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\n\n  c. The disclaimer of warranties and limitation of liability provided\n     above shall be interpreted in a manner that, to the extent\n     possible, most closely approximates an absolute disclaimer and\n     waiver of all liability.\n\n\nSection 6 -- Term and Termination.\n\n  a. This Public License applies for the term of the Copyright and\n     Similar Rights licensed here. However, if You fail to comply with\n     this Public License, then Your rights under this Public License\n     terminate automatically.\n\n  b. Where Your right to use the Licensed Material has terminated under\n     Section 6(a), it reinstates:\n\n       1. automatically as of the date the violation is cured, provided\n          it is cured within 30 days of Your discovery of the\n          violation; or\n\n       2. upon express reinstatement by the Licensor.\n\n     For the avoidance of doubt, this Section 6(b) does not affect any\n     right the Licensor may have to seek remedies for Your violations\n     of this Public License.\n\n  c. For the avoidance of doubt, the Licensor may also offer the\n     Licensed Material under separate terms or conditions or stop\n     distributing the Licensed Material at any time; however, doing so\n     will not terminate this Public License.\n\n  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public\n     License.\n\n\nSection 7 -- Other Terms and Conditions.\n\n  a. The Licensor shall not be bound by any additional or different\n     terms or conditions communicated by You unless expressly agreed.\n\n  b. Any arrangements, understandings, or agreements regarding the\n     Licensed Material not stated herein are separate from and\n     independent of the terms and conditions of this Public License.\n\n\nSection 8 -- Interpretation.\n\n  a. For the avoidance of doubt, this Public License does not, and\n     shall not be interpreted to, reduce, limit, restrict, or impose\n     conditions on any use of the Licensed Material that could lawfully\n     be made without permission under this Public License.\n\n  b. To the extent possible, if any provision of this Public License is\n     deemed unenforceable, it shall be automatically reformed to the\n     minimum extent necessary to make it enforceable. If the provision\n     cannot be reformed, it shall be severed from this Public License\n     without affecting the enforceability of the remaining terms and\n     conditions.\n\n  c. No term or condition of this Public License will be waived and no\n     failure to comply consented to unless expressly agreed to by the\n     Licensor.\n\n  d. Nothing in this Public License constitutes or may be interpreted\n     as a limitation upon, or waiver of, any privileges and immunities\n     that apply to the Licensor or You, including from the legal\n     processes of any jurisdiction or authority.\n\n\n=======================================================================\n\nCreative Commons is not a party to its public\nlicenses. Notwithstanding, Creative Commons may elect to apply one of\nits public licenses to material it publishes and in those instances\nwill be considered the “Licensor.” The text of the Creative Commons\npublic licenses is dedicated to the public domain under the CC0 Public\nDomain Dedication. Except for the limited purpose of indicating that\nmaterial is shared under a Creative Commons public license or as\notherwise permitted by the Creative Commons policies published at\ncreativecommons.org/policies, Creative Commons does not authorize the\nuse of the trademark \"Creative Commons\" or any other trademark or logo\nof Creative Commons without its prior written consent including,\nwithout limitation, in connection with any unauthorized modifications\nto any of its public licenses or any other arrangements,\nunderstandings, or agreements concerning use of licensed material. For\nthe avoidance of doubt, this paragraph does not form part of the\npublic licenses.\n\nCreative Commons may be contacted at creativecommons.org.\n\n", "timestamp": "2025-10-24T11:40:28.635366"}
{"source": "github", "repo": "OWASP/ASVS", "file": "README.md", "url": "https://github.com/OWASP/ASVS/blob/master/README.md", "content": "# OWASP Application Security Verification Standard\n\n<img src=\"https://owasp.org/www-project-application-security-verification-standard/assets/images/OWASP_ASVS_Linkedin_Banner-01.jpg\" width=\"700px\">\n\n[![CC BY-SA 4.0][cc-by-sa-shield]][cc-by-sa]\n\nThis work is licensed under a\n[Creative Commons Attribution-ShareAlike 4.0 International License][cc-by-sa].\n\n[![CC BY-SA 4.0][cc-by-sa-image]][cc-by-sa]\n\n[cc-by-sa]: http://creativecommons.org/licenses/by-sa/4.0/\n[cc-by-sa-image]: https://licensebuttons.net/l/by-sa/4.0/88x31.png\n[cc-by-sa-shield]: https://img.shields.io/badge/License-CC%20BY--SA%204.0-blue.svg\n\n🎉🎉🎉 **Welcome to Version 5.0 of the ASVS!** 🎉🎉🎉 \n\n**Released LIVE on stage at Global AppSec EU Barcelona 2025!**\n\n## Introduction\n\nThe primary aim of the OWASP Application Security Verification Standard (ASVS) Project is to provide an open application security standard for web apps and web services of all types.\n\nOriginally launched in 2008 through a global community collaboration, the ASVS defines a comprehensive set of security requirements for designing, developing, and testing modern web applications and services.\n\nFollowing the release of ASVS 4.0 in 2019 and its minor update (v4.0.3) in 2021, Version 5.0 represents a significant milestone—modernized to reflect the latest advances in software security.\n\nWe gratefully recognize the organizations who have supported the project either through significant time provision or financially on our \"[Supporters](SUPPORTERS.md)\" page!\n\n**Please [log issues](https://github.com/OWASP/ASVS/issues) if you find any bugs or if you have ideas. We may subsequently ask you to [open a pull request](https://github.com/OWASP/ASVS/pulls) based on the discussion in the issue. We are also actively looking for [translations of the 5.n branch](CONTRIBUTING.md#translations).**\n\n## Project Leaders and Working Group\n\nThe project is led by the four project leaders [Daniel Cuthbert](https://github.com/danielcuthbert), [Jim Manico](https://github.com/jmanico), [Josh Grossman](https://github.com/tghosth), and [Elar Lang](https://github.com/elarlang).\n\nThey are supported by the ASVS Working Group which consists of [Shanni Prutchi](https://github.com/EnigmaRosa), [Ralph Andalis](https://github.com/csfreak92), [Meghan Jacquot](https://github.com/meghanjacquot), [Iman Sharafaldin](https://github.com/ImanSharaf), [Ryan Armstrong](https://github.com/ryarmst), [Gabriel Corona](https://github.com/randomstuff), [Tobias Ahnoff](https://github.com/TobiasAhnoff), and [Eden Yardeni](https://github.com/cronchie). \n\n## Latest Stable Version - 5.0.0\n\nThe latest stable version is version 5.0.0 (dated May 2025), which can be found:\n\n* [OWASP Application Security Verification Standard 5.0.0 English (PDF)](https://github.com/OWASP/ASVS/raw/v5.0.0/5.0/OWASP_Application_Security_Verification_Standard_5.0.0_en.pdf)\n* [OWASP Application Security Verification Standard 5.0.0 English (Word)](https://github.com/OWASP/ASVS/raw/v5.0.0/5.0/docs_en/OWASP_Application_Security_Verification_Standard_5.0.0_en.docx)\n* [OWASP Application Security Verification Standard 5.0.0 English (CSV)](https://github.com/OWASP/ASVS/raw/v5.0.0/5.0/docs_en/OWASP_Application_Security_Verification_Standard_5.0.0_en.csv)\n* [OWASP Application Security Verification Standard 5.0.0 (GitHub Branch)](https://github.com/OWASP/ASVS/tree/v5.0.0)\n\nThe master branch of this repository will always be the \"bleeding edge version\" which might have in-progress changes or other edits open. The next release target will be a patch release, version **5.0.1**. For details on the ASVS release strategy, see [the release strategy section of CONTRIBUTING.md](CONTRIBUTING.md#release-strategy).\n\n### Translations\n\nThe OWASP Community effort with regards to translations is a best effort. Whilst we do our utmost to ensure the content is valid, from a structural perspective, there is only so much we can do to ensure the translations are correct. We rely on you, the community, to help make the ASVS as usable as possible to all around the globe, and translating the main branch into your language is important to the project.\n\nIf you think you can help with translations, or indeed ensuring the current list of translations below are correct, we'd love for you to join the community and make the ASVS amazing for all. For more information on translating the ASVS see the [translations section of CONTRIBUTING.md](CONTRIBUTING.md#translations).\n\nCurrently available translations:\n\n* [OWASP Application Security Verification Standard 5.0.0 Turkish (PDF)](5.0/OWASP_Application_Security_Verification_Standard_5.0.0_tr.pdf) and [other formats](5.0/docs_tr). (Thanks to [Ata Seren](https://github.com/ataseren))\n* [OWASP Application Security Verification Standard 5.0.0 Russian (PDF)](5.0/OWASP_Application_Security_Verification_Standard_5.0.0_ru.pdf) and [other formats](5.0/docs_ru). (Thanks to [Khalina Daria](https://github.com/whitealisia), [Shnayder Eugenia](https://github.com/ZhenyaShnayder), [Smirnov Vyacheslav](https://github.com/Borgc), [Mukovkin Dmitry](https://github.com/shipko), [Nadezhda](https://github.com/yoshtvoumed), [Fomin Danil](https://github.com/EvtDanya), Sluzhevsky Anton, [Zolotarev Maxim](https://github.com/kibertard), [Gorky Kirill](https://github.com/ToxicSnail), [Nosenko Aleksei](https://github.com/avnosenko))\n* [OWASP Application Security Verification Standard 5.0.0 French (PDF)](5.0/OWASP_Application_Security_Verification_Standard_5.0.0_fr.pdf) and [other formats](5.0/docs_fr). (Thanks to [Cédric Lallier](https://github.com/clallier94), [Alexandre Joly](https://github.com/inaz0), [Michael Vacarella](https://github.com/Aif4thah), [Sebastien Gioria](https://github.com/SPoint42) and [Gabriel Corona](https://github.com/randomstuff))\n\nHistoric translations of the v4.x versions can be found in the [TRANSLATIONS.md file](4.0/TRANSLATIONS.md) in the 4.0 folder.\n\n## How To Reference ASVS Requirements\n\nEach requirement has an identifier in the format `<chapter>.<section>.<requirement>`, where each element is a number. For example, `1.11.3`.\n\n* The `<chapter>` value corresponds to the chapter from which the requirement comes; for example, all `1.#.#` requirements are from the 'Encoding and Sanitization' chapter.\n* The `<section>` value corresponds to the section within that chapter where the requirement appears, for example: all `1.2.#` requirements are in the 'Injection Prevention' section of the 'Encoding and Sanitization' chapter.\n* The `<requirement>` value identifies the specific requirement within the chapter and section, for example, `1.2.5` which as of version 5.0.0 of this standard is:\n\n> Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.\n\nSince the identifiers may change between versions of the standard, it is preferable for other documents, reports, or tools to use the following format: `v<version>-<chapter>.<section>.<requirement>`, where: 'version' is the ASVS version tag. For example: `v5.0.0-1.2.5` would be understood to mean specifically the 5th requirement in the 'Injection Prevention' section of the 'Encoding and Sanitization' chapter from version 5.0.0. (This could be summarized as `v<version>-<requirement_identifier>`.)\n\nNote: The `v` preceding the version number in the format should always be lowercase.\n\nIf identifiers are used without including the `v<version>` element then they should be assumed to refer to the latest Application Security Verification Standard content. As the standard grows and changes this becomes problematic, which is why writers or developers should include the version element.\n\n## License\n\nThe entire project content is under the **[Creative Commons Attribution-Share Alike v4.0](https://creativecommons.org/licenses/by-sa/4.0/)** license.\n", "timestamp": "2025-10-24T11:40:29.111379"}
{"source": "github", "repo": "OWASP/ASVS", "file": "SUPPORTERS.md", "url": "https://github.com/OWASP/ASVS/blob/master/SUPPORTERS.md", "content": "# ASVS Supporters\n\n<img src=\"https://owasp.org/www-project-application-security-verification-standard/assets/images/OWASP_ASVS_Linkedin_Banner-01.jpg\" width=\"700px\">\n\n<!--Don't forget to update https://github.com/OWASP/ASVS/issues/1888 -->\n<!--Don't forget to update https://docs.google.com/spreadsheets/d/1OrbrYy6R4ux_BuE2rJ17jQurBYbGz4bwAPJWFK4opew/edit#gid=0-->\n\n## Introduction\n\nWithin the ASVS project, we gratefully recognize the following organizations who support the OWASP Application Security Verification Standard project through monetary donations or allowing contributors to spend significant time working on the standard as part of their work with the organization.\n\nWe recognize various tiers of support and the amount of time the supporter is recognized for depends on the supporter level.\n\nOn this page and the project web page, we will display the supporter's logo and link to their website and we will publicise via Social Media as well.\n\nIf you would like to directly become a Primary, Secondary or Tertiary supporter, you can make a [donation to OWASP](https://owasp.org/donate/) of $1,000 or more and choose to \"restrict your gift\". Alternatively, when you pay your corporate membership you can choose to [allocate part of your membership fee to the ASVS](https://owasp.org/supporters/benefits#corporate-sponsorship-of-participating-projects-or-chapters) where the allocated amount will govern which level of supporter you become.\n\n## Maintaining Supporters (through time provision)\n\nOrganizations who have allowed contributors to spend significant time working on the standard as part of their working day with the organization. This will be evaluated at the sole discretion of the project leaders. Supporter will be listed 2 years from the end of the time provision.\n\n[<img src=\"./images/supporters/clarifiedlogo.png\" height=105>](https://www.clarifiedsecurity.com/)\n\n[<img src=\"./images/supporters/bounce.svg\" height=105>](https://www.bouncesecurity.com)\n\n[<img src=\"./images/supporters/manicode.svg\" height=105>](https://www.manicode.com)\n\n## Primary supporters\n\nOrganizations who have donated $7,000 or more to the project via OWASP. Supporter will be listed in this section for 3 years from the date of the donation.\n<!--95-->\n\n## Secondary supporters\n\nOrganizations who have donated $3,000 or more to the project via OWASP. Supporter will be listed in this section for 2 years from the date of the donation.\n<!--80-->\n\n[<img src=\"./images/supporters/jitlogo.svg\" height=80>](https://www.jit.io)\n\n## Tertiary supporters\n\nOrganizations who have donated $500 or more to the project via OWASP. Supporter will be listed in this section for 1 year from the date of the donation.\n<!--65-->\n\n<!--[<img src=\"./images/supporters/oneconsult.svg\" height=65](https://www.oneconsult.com)-->\n\n[<img src=\"./images/supporters/forwardseclogo.jpg\" height=65>](https://forwardsecurity.com/)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<img src=\"./images/supporters/omegapointlogo.png\" height=65>](https://en.omegapoint.se/)\n\n## Associate supporters \n\nOrganizations who have donated another amount to the project via OWASP. Supporter will be listed in this section for 1 year from the date of the donation.\n<!--50-->\n\n<!--Don't forget to update https://github.com/OWASP/ASVS/issues/1888 -->\n<!--Don't forget to update https://docs.google.com/spreadsheets/d/1OrbrYy6R4ux_BuE2rJ17jQurBYbGz4bwAPJWFK4opew/edit#gid=0-->\n", "timestamp": "2025-10-24T11:40:29.369454"}
{"source": "github", "repo": "OWASP/ASVS", "file": "Security.md", "url": "https://github.com/OWASP/ASVS/blob/master/Security.md", "content": "# OWASP Application Security Verification Standard (ASVS) Security Policy\n\nThe ASVS leaders and community take all security bugs seriously. We appreciate your efforts to disclose the issue responsibly, and will make every effort to acknowledge your contributions. To help us with the vulnerability(s) you have identified, it would be great if you could please follow the reporting guidelines below to submit your finding. \n\nWe aim to reply within **3** days of receiving your finding. If a finding is accepted, we aim to publish a patch within **6** days. If it is declined, we will reply to let you know.\n\n## Reporting Guidelines\n\nEmail jim@owasp.org with the following information:\n\n1. Name / affiliation\n2. Vulnerability description\n3. Steps to reproduce the issue\n4. Current public knowledge of this vulnerability (e.g. related CVE, security advisory, etc.)\n\n## Supported Versions\n\nAt this time, only the following versions of **ASVS** are supported:\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 5.0.x   | :white_check_mark: |\n| 4.0.x   | :white_check_mark: |\n\n## Our security acknowledgments page\nAcknowledgments: https://github.com/OWASP/ASVS/blob/master/hall_of-fame.md\n", "timestamp": "2025-10-24T11:40:29.648177"}
{"source": "github", "repo": "OWASP/ASVS", "file": "hall_of-fame.md", "url": "https://github.com/OWASP/ASVS/blob/master/hall_of-fame.md", "content": "# OWASP Application Security Verification Standard (ASVS) Hall of Fame\n\n<img src=\"https://owasp.org/www-project-application-security-verification-standard/assets/images/OWASP_ASVS_Linkedin_Banner-01.jpg\" width=\"700px\">\n\nThank you to those who have discovered or will discover security bugs in our scripts or infrastructure!", "timestamp": "2025-10-24T11:40:33.521061"}
