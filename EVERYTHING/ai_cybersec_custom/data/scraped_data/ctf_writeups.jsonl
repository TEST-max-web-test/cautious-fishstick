{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Code.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Code.md", "content": "# Code\n\n---\n\n## 项目\n\n### 重构\n\n- [七年三次大重构，聊聊我的重构成长史](https://shuyi.tech/archives/my-refactor-experiment)\n\n### 代码质量\n\n- [代码腐烂可以避免的吗？](https://shuyi.tech/archives/talk-about-code-decay)\n\n### 成本\n\n- [研发团队资源成本优化实践](https://tech.meituan.com/2019/02/21/rd-team-resource-cost-optimization-practice.html)\n\n---\n\n## 团队\n\n- [技术Leader一定要懂所有业务细节吗？](https://shuyi.tech/archives/tl-need-to-know-all-details)\n", "timestamp": "2025-10-19T19:25:17.693943"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/GO.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/GO.md", "content": "# GO\n\n---\n\n**推荐工具/资源书籍**\n- [Go - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ms-vscode.Go)\n- [GoLand: A Clever IDE to Go by JetBrains](https://www.jetbrains.com/go/)\n- [re4lity/Hacking-With-Golang](https://github.com/re4lity/Hacking-With-Golang) - Golang安全资源合集\n- [Quorafind/golang-developer-roadmap-cn](https://github.com/Quorafind/golang-developer-roadmap-cn) - Go 开发者路线图\n\n---\n\n## 常见报错\n\n- **fatal error: can’t find import: fmt**\n\n\t说明你的环境变量没有配置正确\n\n---\n\n## IDE\n\n### vscode\n\n- [在VsCode中搭建Go开发环境，手把手教你配置](https://juejin.im/post/5cdd811fe51d45475d5e8e0c)\n\n### Goland 常用快捷键\n\n**文件操作相关**\n- `Ctrl + E` \t打开最近浏览过的文件\n- `Ctrl + N` \t快速打开某个 struct 结构体所在的文件\n- `Ctrl + Shift + N` \t快速打开文件\n- `Shift + F6` \t重命名文件夹、文件、方法、变量名等\n\n**代码格式化相关**\n- `Ctrl + Alt + L` \t格式化代码\n- `Ctrl + 空格` \t代码提示\n- `Ctrl + /` \t单行注释\n- `Ctrl + Shift + /` \t多行注释\n- `Ctrl + B 或 F4` \t快速跳转到结构体或方法的定义位置(需将光标移动到结构体或方法的名称上)\n- `Ctrl + \"+ 或 -\"` \t可以将当前(光标所在位置)的方法进行展开或折叠\n\n**查找和定位相关**\n- `Ctrl + R`    替换文本\n- `Ctrl + F` \t查找文本\n- `Ctrl + Shift + F` \t全局查找\n- `Ctrl + G` \t显示当前光标所在行的行号\n- `Ctrl + Shift + Alt + N` \t查找类中的方法或变量\n\n**编辑代码相关**\n- `Ctrl + J` \t快速生成一个代码片段\n- `Shift+Enter` \t向光标的下方插入一行,并将光标移动到该行的开始位置\n- `Ctrl + X` \t删除当前光标所在行\n- `Ctrl + D` \t复制当前光标所在行\n- `Ctrl + Shift + 方向键上或下` \t将光标所在的行进行上下移动(也可以使用 Alt+Shift+方向键上或下)\n- `Alt + 回车` \t自动导入需要导入的包\n- `Ctrl + Shift + U` \t将选中的内容进行大小写转化\n- `Alt + Insert` \t生成测试代码\n- `Alt + Up/Down` \t快速移动到上一个或下一个方法\n- `Ctrl + Alt + Space` \t类名或接口名提示(代码提示)\n- `Ctrl + P` \t提示方法的参数类型(需在方法调用的位置使用,并将光标移动至( )的内部或两侧)\n\n**编辑器相关**\n- `Ctrl + Alt + left/right` \t返回至上次浏览的位置\n- `Alt + left/right` \t切换代码视图\n- `Ctrl + W` \t快速选中代码\n- `Alt + F3` \t逐个向下查找选中的代码,并高亮显示\n- `Tab` \t代码标签输入完成后,按 Tab,生成代码\n- `F2 或 Shift + F2` \t快速定位错误或警告\n- `Alt + Shift + C` \t查看最近的操作\n- `Alt + 1` \t快速打开或隐藏工程面板\n\n---\n\n## 安装/配置/报错\n### 安装\n\n**windows**\n\n默认情况下 `.msi` 文件会安装在 `c:\\Go` 目录下.且环境变量自动配置好.`GOPATH` 变量请自己指定\n\n**linux**\n```bash\n访问 https://golang.org/dl/ 下载最新版本包\n\ntar -C /usr/local -xzf 相应文件.tar.gz\n\nexport PATH=$PATH:/usr/local/go/bin\nexport GOROOT=/usr/local/go\nexport GOPATH=$HOME/Applications/Go\nsource $HOME/.profile\nsource ~/.bash_profile\n# $GOPATH 可以包含多个工作目录,取决于你的个人情况.如果你设置了多个工作目录,那么当你在之后使用 go get(远程包安装命令)时远程包将会被安装在第一个目录下.\ngo version\n```\n\n**安装目录清单**\n\n你的 Go 安装目录的文件夹结构应该如下所示:\n\n- api   每个版本的 api 变更差异\n- bin   go 源码包编译出的编译器(go)、文档工具(godoc)、格式化工具(gofmt)\n- doc   英文版的 Go 文档\n- lib   引用的一些库文件\n- misc  杂项用途的文件,例如 Android 平台的编译、git 的提交钩子等\n- pkg   Windows 平台编译好的中间文件\n- src   标准库的源码\n- test  测试用例\n\n---\n\n### 配置\n\n**Go 环境变量**\n\nGo 开发环境依赖于一些操作系统环境变量,你最好在安装 Go 之间就已经设置好他们.如果你使用的是 Windows 的话,你完全不用进行手动设置,Go 将被默认安装在目录 `c:/go` 下.这里列举几个最为重要的环境变量:\n\n- $GOROOT 表示 Go 在你的电脑上的安装位置,它的值一般都是 `$HOME/go`,当然,你也可以安装在别的地方.\n- $GOARCH 表示目标机器的处理器架构,它的值可以是 386、amd64 或 arm.\n- $GOOS 表示目标机器的操作系统,它的值可以是 darwin、freebsd、linux 或 windows.\n- $GOBIN 表示编译器和链接器的安装位置,默认是 `$GOROOT/bin`,如果你使用的是 Go 1.0.3 及以后的版本,一般情况下你可以将它的值设置为空,Go 将会使用前面提到的默认值.\n\n目标机器是指你打算运行你的 Go 应用程序的机器.\n\nGo 编译器支持交叉编译,也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序,也就是说编写源代码的机器可以和目标机器有完全不同的特性(操作系统与处理器架构).\n\n为了区分本地机器和目标机器,你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置目标机器的参数,这两个变量只有在进行交叉编译的时候才会用到,如果你不进行显示设置,他们的值会和本地机器($GOOS 和 $GOARCH)一样.\n\n\n> Mac 下编译 Linux 和 Windows 64位可执行程序\n```\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go\n```\n\n> Linux 下编译 Mac 和 Windows 64位可执行程序\n```\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go\n```\n\n> Windows 下编译 Mac 和 Linux 64位可执行程序\n```\nSET CGO_ENABLED=0\nSET GOOS=darwin\nSET GOARCH=amd64\ngo build main.go\n\nSET CGO_ENABLED=0\nSET GOOS=linux\nSET GOARCH=amd64\ngo build main.go\n```\n\n- $GOPATH 默认采用和 $GOROOT 一样的值,但从 Go 1.1 版本开始,你必须修改为其它路径.它可以包含多个包含 Go 语言源码文件、包文件和可执行文件的路径,而这些路径下又必须分别包含三个规定的目录:src、pkg 和 bin,这三个目录分别用于存放源码文件、包文件和可执行文件.\n- $GOARM 专门针对基于 arm 架构的处理器,它的值可以是 5 或 6,默认为 6.\n- $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数.\n\n---\n\n### Test\n\n```bash\nmkdir -p $HOME/Applications/Go\ncd $HOME/Applications/Go\n```\n```vim\nvim hello.go\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"hello, world\\n\")\n}\n```\n```bash\ngo build\n./Go\n```\n\n### 报错\n\n**解决 Golang https 请求时，x509: certificate signed by unknown authority 问题**\n- http://www.honlyc.com/post/golang-x509-certificate-unknown-authority/\n\n---\n\n## 简介知识\n### 工程结构\n\n**工作区**\n\n一般情况下,Go 语言的源码文件必须放在工作区中.但是对于命令源码文件来说,这不是必需的.工作区其实就是一个对应于特定工程的目录,它应包含 3 个子目录:src 目录、pkg 目录和 bin 目录,下面逐一说明.\n\n- src 目录\n\n    用于以代码包的形式组织并保存 Go 源码文件,这里的代码包与 src 下的子目录一一对应.例如,若一个源码文件被声明属于代码包 log,那么它就应当保存在 src/log 目录中.\n\n    当然,也可以把 Go 源码文件直接放在 src 目录下,但这样的 Go 源码文件就只能被声明属于 main 代码包了.除非用于临时测试或演示,一般还是建议把 Go 源码文件放入特定的代码包中.\n\n- pkg 目录\n\n    用于存放通过 go install 命令安装后的代码包的归档文件.前提是代码包中必须包含 Go 库源码文件.归档文件是指那些名称以\".a\"结尾的文件.该目录与 GOROOT 目录下的 pkg 目录功能类似.区别在于,工作区中的 pkg 目录专门用来存放用户代码的归档文件.\n\n    编译和安装用户代码的过程一般会以代码包为单位进行.比如 log 包被编译安装后,将生成一个名为 log.a 的归档文件,并存放在当前工作区的 pkg 目录下的平台相关目录中.\n\n- bin 目录\n\n    与 pkg 目录类似,在通过 go install 命令完成安装后,保存由 Go 命令源码文件生成的可执行文件.在类 Unix 操作系统下,这个可执行文件一般来说名称与源码文件的主文件名相同.而在 Windows 操作系统下,这个可执行文件的名称则是源码文件主文件名加 .exe 后缀.\n\n**GOPATH**\n\n我们需要将工作区的目录路径添加到环境变量 GOPATH 中.否则,即使处于同一工作区,代码之间也无法通过绝对代码包路径调用.在实际开发环境中,工作区可以只有一个,也可以有多个,这些工作区的目录路径都需要添加到 GOPATH 中.与 GOROOT 一样,我们应该确保 GOPATH 一直有效.\n\n需要注意一下两点:\n1. GOPATH 中不要包含 Go 语言的根目录,以便将 Go 语言本身的工作区同用户工作区严格分开.\n2. 通过 Go 工具中的代码获取命令 go get,可将指定项目的源码下载到我们在 GOPATH 中设定的第一个工作区中,并在其中完成编译和安装.\n\n**源码文件**\n\nGo 的源码文件有 3 个种类,即命令源码文件、库源码文件和测试源码文件,下面详细说明这 3 类源码文件.\n\n- 命令源码文件\n\n    如果一个源码文件被声明属于 main 代码包,且该文件代码中包含无参数声明和结果声明的 main 函数,则它就是命令源码文件.命令源码文件可通过 go run 命令直接启动运行.\n\n    同一个代码包中的所有源码文件,其所属代码包的名称必须一致.如果命令源码文件和库源码文件处于同一个代码包中,那么在该包中就无法正确执行 go build 和 go install 命令.换句话说,这些源码文件将无法通过常规方法编译和安装.\n\n    因此,命令源码文件通常会单独放在一个代码包中.这是合理且必要的,因为通常一个程序模块或软件的启动入口只有一个.\n\n    同一个代码包中可以有多个命令源码文件,可通过 go run 命令分别运行,但这会使 go build 和 go install 命令无法编译和安装该代码包.所以,我们也不应该把多个命令源码文件放在同一个代码包中.\n\n    当代码包中有且仅有一个命令源码文件时,在文件所在目录中执行 go build 命令,即可在该目录下生成一个与目录同名的可执行文件;而若使用 go install 则可在当前工作区的 bin 目录下生成相应的可执行文件.例如,代码包 gopcp.v2/helper/ds 中只有一个源码文件 showds.go,且它是命令源码文件,则相关操作和结果如下:\n    ```bash\n    root:~/golang/example.v2/src/gopcp.v2/helper/ds$ Is\n    showds.go\n    root:~/golang/example.v2/src/gopcp.v2/helper/ds$ go build\n    root:~/golang/example.v2/src/gopcp.v2/helper/ds$ Is\n    ds showds.go\n    root: ~/golang/example.v2/src/gopcp.v2/helper/ds$ go install\n    root:~/golang/example.v2/src/gopcp・v2/helper/ds$ Is ../../../../bin\n    ds\n    ```\n    需要特别注意,只有当环境变量 GOPATH 中只包含一个工作区的目录路径时,go install 命令才会把命令源码文件安装到当前工作区的 bin 目录下;否则,像这样执行 go install 命令就会失败.此时必须设置环境变量 GOBIN,该环境变量的值是一个目录的路径,该目录用于存放所有因安装 Go 命令源码文件而生成的可执行文件.\n\n- 库源码文件\n\n    通常,库源码文件声明的包名会与它直接所属的代码包(目录)名一致,且库源码文件中不包含无参数声明和无结果声明的 main 函数.下面来安装(其中包含编译)gopcp.v2/helper/log 包,其中含有若干库源码文件:\n    ```bash\n    root:~/golang/example.v2/src/gopcp.v2/helper/log$ ls\n    base    logger.go    logger_test.go logrus\n    root: ~/golang/example.v2/src/gopcp.v2/helper/log$ go install\n    root:~/golang/example.v2/src/gopcp.v2/helper/log$ ls    ../../../pkg\n    linux_amd64\n    root:~/golang/example.v2/src/gopcp.v2/helper/log$ ls    ../../../pkg/linux_amd64/gopcp.v2/helper\n    log    log.a\n    root:~/golang/example.v2/src/gopcp.v2/helper/log$ ls ../../../../pkg/linux_amd64/gopcp.v2/helper/log\n    base.a    field.a    logrus.a\n    ```\n    这里,我们通过在 gopcp.v2/helper/log 代码包的目录下执行 go install 命令,成功安装了该包并生成了若干归档文件.这些归档文件的存放目录由以下规则产生.\n\n    安装库源码文件时所生成的归档文件会被存放到当前工作区的 pkg 目录中.example.v2 项目的 gopcp.v2/helper/log 包所属工作区的根目录是 ~/golang/example.v2.因此,上面所说的 pkg 目录即 ~/golang/example.v2/pkg.\n\n    根据被编译时的目标计算环境,归档文件会被放在该 pkg 目录下的平台相关目录中.例如,我是在 64 位的 Linux 计算环境下安装的,对应的平台相关目录就是 linux_amd64,那么归档文件一定会被存放到 ~/golang/example.v2/pkg/linux_amd64 目录中的某个地方.\n\n    存放归档文件的目录的相对路径与被安装的代码包的上一级代码包的相对路径一致.第一个相对路径是相对于工作区的 pkg 目录下的平台相关目录而言的,而第二个相对路径是相对于工作区的 src 目录而言的.\n\n    例如,gopcp.v2/helper/log 包的归档文件 log.a 一定会被存放到 ~/golang/example.v2/pkg/linux_amd64/gopcp.v2/helper 这个目录下.而它的子代码包 gopcp.v2/helper/log/base 的归档文件 base.a,则一定会被存放到 ~/golang/example.v2/pkg/linux_amd64/gopcp.v2/helper/log 目录下.\n\n- 测试源码文件\n\n    测试源码文件是一种特殊的库文件,可以通过执行 go test 命令运行当前代码包下的所有测试源码文件.成为测试源码文件的充分条件有两个,如下.\n    - 文件名需要以\"_test.go\"结尾.\n    - 文件中需要至少包含一个名称以 Test 开头或 Benchmark 开头,且拥有一个类型为 *testing.T 或 *testing.B 的参数的函数.testing.T 和 testing.B 是两个结构体类型.而 *testing.T 和 *testing.B 则分别为前两者的指针类型.它们分别是功能测试和基准测试所需的.\n\n    当在一个代码包中执行 go test 命令时,该代码包中的所有测试源码文件会被找到并运行.我们依然以 gopcp.v2/helper/log 包为例:\n    ```bash\n    root:~/golang/example.v2/src/gopcp.v2/helper/log$ go test\n    PASS\n    ok    gopcp.v2/helper/log    0.008s\n    ```\n    这里使用 go test 命令在 gopcp.v2/helper/log 包中找到并运行了测试源码文件 logger_test.go,且调用其中所有的测试函数.命令行的回显信息表示我们通过了测试,并且运行测试源码文件中的测试程序共花费了 0.080 S.\n\n    最后插一句,Go 代码的文本文件需要以 UTF-8 编码存储.如果源码文件中出现了非 UTF-8 编码的字符,那么在运行、编译或安装的时候,Go 命令会抛出 illegal UTF-8 sequence 错误.\n\n**代码包**\n\n在 Go 中,代码包是代码编译和安装的基本单元,也是非常直观的代码组织形式.\n\n- 包声明\n\n    在 example.v2 项目的代码包中,多数源码文件名称看似都与包名没什么关系.实际上,在 Go 语言中,代码包中的源码文件可以任意命名.另外,这些任意名称的源码文件都必须以包声明语句作为文件中代码的第一行.比如,gopcp.v2/helper/log/base 包中的所有源码文件都要先声明自己属于某一个代码包:\n    ```go\n    package \"base\"\n    ```\n    其中 package 是 Go 中用于包声明语句的关键字.Go 规定包声明中的包名是代码包路径的最后一个元素.比如,`gopcp.v2/helper/log/base` 包的源码文件包声明中的包名是 base.但是,不论命令源码文件存放在哪个代码包中,它都必须声明属于 main 包.\n\n-  包导入\n\n    代码包 `gopcp.v2/helper/log` 中的 logger.go 需要依赖 base 子包和 logrus 子包,因此需要在源码文件中使用代码包导入语句,如下所示:\n    ```go\n    import \"gopcp.v2/helper/log/base\"\n    import \"gopcp.v2/helper/log/logrus\"\n    ```\n    这需要用到代码包导入路径,即代码包在工作区的 src 目录下的相对路径.\n\n    当导入多个代码包时,可以用圆括号括起它们,且每个代码包名独占一行.在使用被导入代码包中公开的程序实体时,需要使用包路径的最后一个元素加的方式指定代码所在的包.\n\n    因此,上述语句可以写成:\n    ```go\n    import (\n        \"gopcp.v2/helper/log/base\"\n        \"gopcp.v2/helper/log/logrus\"\n    )\n    ```\n    同一个源码文件中导入的多个代码包的最后一个元素不能重复,否则一旦使用其中的程序实体,就会引起编译错误.但是,如果你只导入不使用,同样会引起编译错误.一个解决方法是为其中一个起个别名,比如:\n    ```go\n    import (\n        \"github.com/Sirupsen/logrus\"\n        mylogrus \"gopcp.v2/helper/log/logrus\"\n    )\n    ```\n    如果我们想不加前缀而直接使用某个依赖包中的程序实体,就可以用\".\"来代替别名,如下所示:\n    ```go\n    import (\n        . \"gopcp.v2/helper/log/logrus\"\n    )\n    ```\n    看到那个\".\"了吗？之后,在当前源码文件中,我们就可以这样做了:\n    ```go\n    var logger = NewLogger(\"gopcp\") // NewLogger 是 gopcp.v2/helper/log/logrus 包中的函数\n    ```\n    这里强调一下,Go 中的变量、常量、函数和类型声明可统称为程序实体,而它们的名称统称为标识符.标识符可以是 Unicode 字符集中任意能表示自然语言文字的字符、数字以及下划线 (_).标识符不能以数字或下划线开头.\n\n    实际上,标识符的首字符的大小写控制着对应程序实体的访问权限.如果标识符的首字符是大写形式,那么它所对应的程序实体就可以被本代码包之外的代码访问到,也称为可导出的或公开的;否则,对应的程序实体就只能被本包内的代码访问,也称为不可导岀的或包级私有的.要想成为可导出的程序实体,还需要额外满足以下两个条件.\n\n    - 程序实体必须是非局部的.局部的程序实体是指:它被定义在了函数或结构体的内部.\n    - 代码包所属目录必须包含在 GOPATH 中定义的工作区目录中.\n\n    代码包导入还有另外一种情况:如果只想初始化某个代码包,而不需要在当前源码文件中使用那个代码包中的任何程序实体,就可以用\"_\"来代替别名:\n    ```go\n    import (\n        _ \"github.com/Simpsen/logrus\"\n    )\n    ```\n    这种情况下,我们只是触发了这个代码包中的初始化操作(如果有的话).符号\"_\"就像一个垃圾桶,它在代码中使用很广泛,在后续的学习中还可以看到它的身影.\n\n-  包初始化\n\n    在Go语言中,可以有专门的函数负责代码包初始化,称为代码包初始化函数.这个函数需要无任何参数声明和结果声明,且名称必须为 init,如下所示:\n    ```go\n    func init() {\n        fmt.Println(\"Initialize...\")\n    }\n    ```\n    Go 会在程序真正执行前对整个程序的依赖进行分析,并初始化相关的代码包.也就是说,所有的代码包初始化函数都会在 main 函数(命令源码文件中的入口函数)执行前执行完毕,而且只会执行一次.另外,对于每一个代码包来说,其中的所有全局变量的初始化,都会在代码包的初始化函数执行前完成.这避免了在代码包初始化函数对某个变量进行赋值之后,又被该变量声明中赋予的值覆盖掉的问题.\n\n    下面的代码展示了全局赋值语句、代码包初始化函数以及主函数的执行顺序.其中,双斜杠及其右边的内容为代码注释,Go 编译器在编译的时候会将其忽略.\n    ```go\n    package main //命令源码文件必须在这里声明自己属于main包\n    import ( //导入标准库代码包fmt和runtime\n        \"fmt\"\n        \"runtime\"\n    )\n    func init() { //代码包初始化函数\n        fmt.Printf(\"Map: %v\\n\", m)  // 格式化的打印\n        //通过调用runtime包的代码获取当前机器的操作系统和计算架构.\n        //而后通过fmt包的Sprintf方法进行格式化字符串生成并赋值给变量info\n        info = fmt.Sprintf(\"OS: %s, Arch: %s\", runtime.GOOS, runtime.GOARCH)\n    }\n    //非局部变量,map类型,且已初始化\n    var m = map[int]string{1: \"A\", 2: \"B\", 3: \"C\"}\n    //非局部变量,string类型,未被初始化\n    var info string\n    func main() {         //命令源码文件必须有的入口函数,也称主函数\n        fmt.Println(info) // 打印变量 info\n    }\n    ```\n\n    运行这个文件:\n    ```\n    D:\\code>go run main.go\n    Map: map[1:A 2:B 3:C]\n    OS: windows, Arch: amd64\n    ```\n    关于每行代码的用途,在源码文件中我已经作了基本的解释.这里只解释这个小程序的输出.\n\n    第一行是对变量 m 的值格式化后的结果.可以看到,在函数 init 的第一条语句执行时,变量 m 已经被初始化并赋值了.这验证了:当前代码包中所有全局变量的初始化会在代码包初始化函数执行前完成.\n\n    第二行是对变量 info 的值格式化后的结果.变量 info 被定义时并没有显式赋值,因此它被赋予类型 string 的零值——\"\"(空字符串).之后,变量 info 在代码包初始化函数 init 中被赋值,并在入口函数 main 中输出.这验证了:所有的代码包初始化函数都会在 main 函数执行前执行完毕.\n\n    同一个代码包中可以存在多个代码包初始化函数,甚至代码包内的每一个源码文件都可以定义多个代码包初始化函数.Go 不会保证同一个代码包中多个代码包初始化函数的执行顺序.此外,被导入的代码包的初始化函数总是会先执行.在上例中,fmt 和 runtime 包中的 init 函数(如果有的话)会先执行,然后当前文件中的 init 函数才会执行.\n\n### 跨平台编译\n\nWindows下编译Mac平台64位可执行程序：\n```bash\nSET CGO_ENABLED=0\nSET GOOS=darwin\nSET GOARCH=amd64\ngo build\n```\n\nMac 下编译 Linux 和 Windows平台 64位 可执行程序：\n```bash\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build\n```\n\nLinux 下编译 Mac 和 Windows 平台64位可执行程序：\n```bash\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build\n```\n\n---\n\n## 一些项目\n\n**图形化**\n- [fyne](https://github.com/fyne-io/fyne) - web框架\n\n**网络操作**\n- [caucy/batch_ping](https://github.com/caucy/batch_ping) - 多主机 ping\n- [hdm/nextnet](https://github.com/hdm/nextnet) - 专门扫描 137 端口存活主机\n\n**系统信息**\n- [gopsutil](https://github.com/shirou/gopsutil)\n- [wmi](https://github.com/StackExchange/wmi)\n\n**web**\n- [gin](https://github.com/gin-gonic/gin)\n\n**Crypto**\n- [tjfoc/gmsm: GM SM2/3/4 library based on Golang (基于Go语言的国密SM2/SM3/SM4算法库)](https://github.com/tjfoc/gmsm)\n\n**通知**\n- [notify](https://github.com/nikoksr/notify)\n\n**telegram bot**\n- [telebot](https://github.com/tucnak/telebot)\n- [telegram-bot-api](https://github.com/go-telegram-bot-api/telegram-bot-api)\n\n**配置**\n- [go-ini/ini](https://github.com/go-ini/ini) - 在Go中提供了ini文件的读写功能\n\n**花里胡哨**\n- [gookit/color](https://github.com/gookit/color) - 给终端输出加颜色\n- https://github.com/fatih/color - Color package for Go (golang)\n\n**格式化**\n- [tidwall/gjson](https://github.com/tidwall/gjson) - Get JSON values quickly - JSON parser for Go\n\n**反虚拟机**\n- https://github.com/p3tr0v/chacal\n\n**语言**\n- [mozillazg/go-pinyin](https://github.com/mozillazg/go-pinyin) - 汉字转拼音\n", "timestamp": "2025-10-19T19:25:18.139332"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/GoReleaser.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/GoReleaser.md", "content": "# GoReleaser\n\n- https://github.com/goreleaser/goreleaser\n\n---\n\n自动化打包工具\n\n---\n\n**安装**\n\n- https://github.com/goreleaser/goreleaser/releases\n\n---\n\n**使用**\n\n在目标目录执行 goreleaser init ，将会生成一个 `.goreleaser.yml` 配置文件\n\n修改配置,例如\n```yml\n# This is an example .goreleaser.yml file with some sane defaults.\n# Make sure to check the documentation at http://goreleaser.com\nbefore:\n  hooks:\n    # You may remove this if you don't use go modules.\n    #- go mod tidy\n    # you may remove this if you don't need go generate\n    #- go generate ./...\nbuilds:\n  - env:\n      - CGO_ENABLED=0\n    id: \"anewproject\"\n    binary: \"anew\"\n    goos:\n      - linux\n      - windows\n      - darwin\n    goarch:\n      - amd64\narchives:\n  - replacements:\n      darwin: Darwin\n      linux: Linux\n      windows: Windows\n      386: i386\n      amd64: x86_64\nchecksum:\n  name_template: 'checksums.txt'\nsnapshot:\n  name_template: \"v1.0.0-snapshot\"\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n      - '^docs:'\n      - '^test:'\n```\n\n**打包**\n\n```\ngoreleaser --snapshot --skip-publish --rm-dist\n```\n\n这里可能会提示\n\n```\n⨯ release failed after 2.94s error=failed to build for darwin_amd64: go: cannot find main module, but found .git/config in C:\\xxx\n```\n\n直接\n```\ngo mod init hello\n```\n再运行一遍就可以了\n\n如果提示一下报错\n```\ncouldn't guess project_name, please add it to your config\n```\n\n添加一行就行\n```yaml\nproject_name: myproject\n```\n\n**main.go 不在根目录的情况**\n\n```yaml\n# .goreleaser.yaml\nbuilds:\n- main: ./path/to/your/main/pkg/\n```\n", "timestamp": "2025-10-19T19:25:18.583457"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/flag包.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/flag%E5%8C%85.md", "content": "# flag 包\n\n---\n\n**Source & Reference**\n\n- [Go语言flag包:命令行参数解析](http://c.biancheng.net/view/5573.html)\n\n---\n\n几个概念:\n- 命令行参数(或参数):是指运行程序提供的参数\n- 已定义命令行参数:是指程序中通过 flag.Xxx 等这种形式定义了的参数\n- 非 flag(non-flag)命令行参数(或保留的命令行参数):先可以简单理解为 flag 包不能解析的参数\n\n```go\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n)\n\nvar (\n    h, H bool\n\n    v bool\n    q *bool\n\n    D    string\n    Conf string\n)\n\nfunc init() {\n    flag.BoolVar(&h, \"h\", false, \"帮助信息\")\n    flag.BoolVar(&h, \"H\", false, \"帮助信息\")\n\n    flag.BoolVar(&v, \"v\", false, \"显示版本号\")\n\n    //\n    flag.StringVar(&D, \"D\", \"deamon\", \"set descripton \")\n    flag.StringVar(&Conf, \"Conf\", \"/dev/conf/cli.conf\", \"set Conf filename \")\n\n    // 另一种绑定方式\n    q = flag.Bool(\"q\", false, \"退出程序\")\n\n    // 像flag.Xxx函数格式都是一样的，第一个参数表示参数名称，\n    // 第二个参数表示默认值，第三个参数表示使用说明和描述.\n    // flag.XxxVar这样的函数第一个参数换成了变量地址，\n        // 后面的参数和flag.Xxx是一样的.\n\n    // 改变默认的 Usage\n\n    flag.Usage = usage\n\n    flag.Parse()\n\n    var cmd string = flag.Arg(0)\n\n    fmt.Printf(\"-----------------------\\n\")\n    fmt.Printf(\"cli non=flags      : %s\\n\", cmd)\n\n    fmt.Printf(\"q: %b\\n\", *q)\n\n    fmt.Printf(\"descripton:  %s\\n\", D)\n    fmt.Printf(\"Conf filename : %s\\n\", Conf)\n\n    fmt.Printf(\"-----------------------\\n\")\n    fmt.Printf(\"there are %d non-flag input param\\n\", flag.NArg())\n    for i, param := range flag.Args() {\n        fmt.Printf(\"#%d    :%s\\n\", i, param)\n    }\n\n}\n\nfunc main() {\n    flag.Parse()\n\n    if h || H {\n        flag.Usage()\n    }\n}\n\nfunc usage() {\n    fmt.Fprintf(os.Stderr, `CLI: 8.0\nUsage: Cli [-hvq] [-D descripton] [-Conf filename]\n\n`)\n    flag.PrintDefaults()\n}\n```\n\nflag 包实现了命令行参数的解析，大致需要几个步骤:\n\n**flag 参数定义或绑定**\n\n定义 flags 有两种方式:\n\n1. flag.Xxx()，其中 Xxx 可以是 Int、String 等;返回一个相应类型的指针，如:\n```go\nvar ip = flag.Int(\"flagname\", 1234, \"help message for flagname\")\n```\n\n2. flag.XxxVar()，将 flag 绑定到一个变量上，如:\n```go\nvar flagvar int\nflag.IntVar(&flagvar, \"flagname\", 1234, \"help message for flagname\")\n```\n另外，还可以创建自定义 flag，只要实现 flag.Value 接口即可(要求 receiver 是指针)，这时候可以通过如下方式定义该 flag:\n```go\nflag.Var(&flagVal, \"name\", \"help message for flagname\")\n```\n命令行 flag 的语法有如下三种形式:-flag // 只支持 bool 类型 -flag=x -flag x // 只支持非 bool 类型\n\n**flag 参数解析**\n\n在所有的 flag 定义完成之后，可以通过调用 `flag.Parse()` 进行解析.\n\n根据 `Parse()` 中 for 循环终止的条件，当 parseOne 返回 false，nil 时，Parse 解析终止.\n```go\ns := f.args[0]\nif len(s) == 0 || s[0] != '-' || len(s) == 1 {\n    return false, nil\n}\n```\n\n当遇到单独的一个\"-\"或不是\"-\"开始时，会停止解析.比如:./cli - -f 或 ./cli -f，这两种情况，-f 都不会被正确解析.像这些参数，我们称之为 non-flag 参数.\n\nparseOne 方法中接下来是处理 -flag=x，然后是 -flag(bool 类型)(这里对 bool 进行了特殊处理)，接着是 -flag x 这种形式，最后，将解析成功的 Flag 实例存入 FlagSet 的 actual map 中.\n\n`Arg(i int)` 和 `Args()`、`NArg()`、`NFlag()` `Arg(i int)` 和 `Args()` 这两个方法就是获取 non-flag 参数的;`NArg()` 获得 non-flag 个数;`NFlag()` 获得 FlagSet 中 actual 长度(即被设置了的参数个数).\n\nflag 解析遇到 non-flag 参数就停止了.所以如果我们将 non-flag 参数放在最前面，flag 什么也不会解析，因为 flag 遇到了这个就停止解析了.\n\n**分支程序**\n\n根据参数值，代码进入分支程序，执行相关功能.上面代码提供了 -h 参数的功能执行.\n```go\nif h || H {\n        flag.Usage()\n    }\n```\n\n总体而言，从例子上看，flag package 很有用，但是并没有强大到解析一切的程度.如果入参解析非常复杂，flag 可能捉襟见肘.\n", "timestamp": "2025-10-19T19:25:18.770955"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/goland远程调试.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/goland%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.md", "content": "# goland 远程调试\n\n---\n\n本地的gopath和远端机器不需要一致，go版本也不需要一致\n\n---\n\n## 远端机器\n\n**go**\n\n需要安装 go 环境,可以用 f8x 装\n```bash\nwget -O f8x https://f8x.io/ && mv --force f8x /usr/local/bin/f8x && chmod +x /usr/local/bin/f8x\nf8x -go\n```\n\n**dlv**\n\n装一个delve\n- https://github.com/go-delve/delve/tree/master/Documentation/installation\n\n```bash\nexport GO111MODULE=on && export GOPROXY=https://goproxy.io\ngo install -v github.com/go-delve/delve/cmd/dlv@latest\nwhich dlv\nln -s /root/go/bin/dlv /usr/local/bin/dlv\ndlv\n```\n\n---\n\n## 本地\n\n检测下 goland 是否自带 `FTP/SFTP/WebDAV Connectivity` 插件\n\n**添加远程服务器信息**\n\n点击tools->deployment->configuration\n\n添加一个 sftp\n\n添加远程服务器,添加映射\n\n**测试上传**\n\ntools->deployment->upload to\n\n**开始调试**\n\n右上角的配置,选择go remote\n\n配置远程服务器信息，端口使用默认\n\n会给出远端需要运行的命令\n```bash\ndlv debug --headless --listen=:2345 --api-version=2\n```\n\n远端运行后,即可正常调试\n", "timestamp": "2025-10-19T19:25:18.977103"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/os包.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/os%E5%8C%85.md", "content": "# OS 包\n\n---\n\n**Source & Reference**\n\n- [Go语言os包用法简述](http://c.biancheng.net/view/5572.html)\n\n---\n\nos 标准包，是一个比较重要的包，顾名思义，主要是在服务器上进行系统的基本操作，如文件操作，目录操作，执行命令，信号与中断，进程，系统状态等等.在 os 包下，有 exec，signal，user 三个子包.\n\n**启动外部命令和程序**\n\n写命令行程序时需要对命令参数进行解析，这时我们可以使用 os 库.os 库可以通过变量 Args 来获取命令参数，os.Args 返回一个字符串数组，其中第一个参数就是执行文件本身.\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    fmt.Println(os.Args)\n}\n```\n\n编译执行后执行\n```\n$ ./cmd -user=\"root\"\n[./cmd -user=root]\n```\n\n这种方式对于简单的参数格式还能使用，一旦面对复杂的参数格式，比较费时费劲，所以这时我们会选择 flag 库.\n\n在 os 包中，相关函数名字和作用有较重的 Unix 风，比如:\n```go\nfunc Chdir(dir string) error //chdir 将当前工作目录更改为 dir 目录\nfunc Getwd() (dir string, err error) //获取当前目录\nfunc Chmod(name string, mode FileMode) error //更改文件的权限\nfunc Chown(name string, uid, gid int) error //更改文件拥有者 owner\nfunc Chtimes(name string, atime time.Time, mtime time.Time) error func Clearenv() //清除所有环境变量(慎用)\nfunc Environ() []string //返回所有环境变量\nfunc Exit(code int) //系统退出，并返回 code，其中 0 表示执行成功并退出，非 0 表示错误并退出\n```\n\n在 os 包中，有关文件的处理也有很多方法，如:\n```go\nfunc Create(name string) (file File, err error) // Create 采用模式 0666 创建一个名为 name 的文件，如果文件已存在会截断它(为空文件)\nfunc Open(name string) (file File, err error) // Open 打开一个文件用于读取.\nfunc (f File) Stat() (fi FileInfo, err error) // Stat 返回描述文件 f 的 FileInfo 类型值\nfunc (f File) Readdir(n int) (fi []FileInfo, err error) // Readdir 读取目录 f 的内容，返回一个有 n 个成员的 []FileInfo\nfunc (f File) Read(b []byte) (n int, err error) // Read 方法从 f 中读取最多 len(b) 字节数据并写入 b\nfunc (f File) WriteString(s string) (ret int, err error) // 向文件中写入字符串\nfunc (f File) Sync() (err error) // Sync 递交文件的当前内容进行稳定的存储.\nfunc (f File) Close() error // Close 关闭文件 f\n```\n\n在 os 包中有一个 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件;它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体.\n\n这个函数返回被启动进程的 `id(pid)`，或者启动失败返回错误.\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    // 1) os.StartProcess //\n    /*********************/\n    /* Linux: */\n    env := os.Environ()\n    procAttr := &os.ProcAttr{\n        Env: env,\n        Files: []*os.File{\n            os.Stdin,\n            os.Stdout,\n            os.Stderr,\n        },\n    }\n    // 1st example: list files\n    Pid, err := os.StartProcess(\"/bin/ls\", []string{\"ls\", \"-l\"}, procAttr)\n    if err != nil {\n        fmt.Printf(\"Error %v starting process!\", err) //\n        os.Exit(1)\n    }\n    fmt.Printf(\"The process id is %v\", pid)\n}\n```\n\n**os/signal 信号处理**\n\n一个运行良好的程序在退出(正常退出或者强制退出，如 ctrl+c，kill 等)时是可以执行一段清理代码，将收尾工作做完后再真正退出.一般采用系统 Signal 来通知系统退出，如 kill pid.在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理.\n\nGo 语言的系统信号处理主要涉及 os 包、os.signal 包以及 syscall 包.其中最主要的函数是 signal 包中的 Notify 函数:\n```go\nfunc Notify(c chan<- os.Signal, sig …os.Signal)\n```\n\n该函数会将进程收到的系统 Signal 转发给 channel c.如果没有传入 sig 参数，那么 Notify 会将系统收到的所有信号转发给 channel c.\n\nNotify 会根据传入的 os.Signal，监听对应 Signal 信号，`Notify()` 方法会将接收到对应 os.Signal 往一个 channel c 中发送.\n\n下面代码以 syscall.SIGUSR2 信息为例，说明了具体实现:\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n)\n\nfunc main() {\n    go signalListen()\n    for {\n        time.Sleep(10 * time.Second)\n    }\n}\n\nfunc signalListen() {\n    c := make(chan os.Signal)\n    signal.Notify(c, syscall.SIGUSR2)\n    for {\n        s := <-c\n        //收到信号后的处理，这里只是输出信号内容，可以做一些更有意思的事\n        fmt.Println(\"get signal:\", s)\n    }\n}\n```\n", "timestamp": "2025-10-19T19:25:19.146417"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/time包.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/time%E5%8C%85.md", "content": "# time 包\n\n---\n\n**Source & Reference**\n\n- [Go语言time包:时间和日期](http://c.biancheng.net/view/5392.html)\n\n---\n\ntime 包为我们提供了一个数据类型 time.Time(作为值使用)以及显示和测量时间和日期的功能函数.\n\n当前时间可以使用 `time.Now()` 获取，或者使用 `t.Day()`、`t.Minute()` 等等来获取时间的一部分;甚至可以自定义时间格式化字符串，例如:`fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())` 将会输出 21.07.2011.\n\nDuration 类型表示两个连续时刻所相差的纳秒数，类型为 int64.Location 类型映射某个时区的时间，UTC 表示通用协调世界时间.\n\n包中的一个预定义函数 func (t Time) Format(layout string) string 可以根据一个格式化字符串来将一个时间 t 转换为相应格式的字符串，可以使用一些预定义的格式，如:time.ANSIC 或 time.RFC822.\n\n一般的格式化设计是通过对于一个标准时间的格式化描述来展现的，这听起来很奇怪，但看下面这个例子就会一目了然:\n```go\nfmt.Println(t.Format(\"02 Jan 2006 15:04\"))\n```\n\n输出:\n```\n16 Oct 2019 16:31\n```\n\n---\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nvar week time.Duration\nfunc main() {\n    t := time.Now()\n    fmt.Println(t)  // 2019-10-16 16:32:19.6001046 +0800 CST m=+0.009992501\n\n    fmt.Printf(\"%02d.%02d.%4d\\n\", t.Day(), t.Month(), t.Year())\n    // 16.10.2019\n\n    t = time.Now().UTC()\n    fmt.Println(t)          // 2019-10-16 08:32:58.7242797 +0000 UTC\n\n    fmt.Println(time.Now()) // 2019-10-16 16:33:27.3045405 +0800 CST m=+0.080952501\n\n    // calculating times:\n    week = 60 * 60 * 24 * 7 * 1e9 // must be in nanosec\n    week_from_now := t.Add(week)\n    fmt.Println(week_from_now)    // 2019-10-23 08:33:53.6846208 +0000 UTC\n\n    // formatting times:\n    fmt.Println(t.Format(time.RFC822)) // 16 Oct 19 08:34 UTC\n\n    fmt.Println(t.Format(time.ANSIC))  // Wed Oct 16 08:34:26 2019\n\n    fmt.Println(t.Format(\"02 Jan 2006 15:04\")) // 16 Oct 2019 08:34\n\n    s := t.Format(\"20060102\")\n    fmt.Println(t, \"=>\", s)\n    // 2019-10-16 08:34:26.5230908 +0000 UTC => 20191016\n}\n```\n\n如果需要在应用程序在经过一定时间或周期执行某项任务(事件处理的特例)，则可以使用 time.After 或者 time.Ticker.另外，time.Sleep(Duration d)可以实现对某个进程(实质上是 goroutine)时长为 d 的暂停.\n", "timestamp": "2025-10-19T19:25:19.315380"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Golang/笔记/格式化输出.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Golang/%E7%AC%94%E8%AE%B0/%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA.md", "content": "# 格式化输出\n\n---\n\n**Source & Reference**\n\n- http://c.biancheng.net/view/41.html\n\n---\n\n格式化在逻辑中非常常用.使用格式化函数，要注意写法:\n```\nfmt.Sprintf(格式化样式, 参数列表…)\n```\n\n- 格式化样式:字符串形式，格式化动词以 % 开头.\n- 参数列表:多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错.\n\n```go\nvar progress = 2\nvar target = 8\n\n// 两参数格式化\ntitle := fmt.Sprintf(\"已采集%d个药草, 还需要%d个完成任务\", progress, target)\n\nfmt.Println(title)\n\npi := 3.14159\n// 按数值本身的格式输出\nvariant := fmt.Sprintf(\"%v %v %v\", \"月球基地\", pi, true)\n\nfmt.Println(variant)\n\n// 匿名结构体声明, 并赋予初值\nprofile := &struct {\n    Name string\n    HP   int\n}{\n    Name: \"rat\",\n    HP:   150,\n}\n\nfmt.Printf(\"使用'%%+v' %+v\\n\", profile)\n\nfmt.Printf(\"使用'%%#v' %#v\\n\", profile)\n\nfmt.Printf(\"使用'%%T' %T\\n\", profile)\n```\n\n代码输出如下:\n```\n已采集2个药草, 还需要8个完成任务\n\"月球基地\" 3.14159 true\n使用'%+v' &{Name:rat HP:150}\n使用'%#v' &struct { Name string; HP int }{Name:\"rat\", HP:150}\n使用'%T' *struct { Name string; HP int }C语言中, 使用%d代表整型参数\n```\n\n下表中标出了常用的一些格式化样式中的动词及功能.\n```\n%v \t按值的本来值输出\n%+v \t在 %v 基础上，对结构体字段名和值进行展开\n%#v \t输出 Go 语言语法格式的值\n%T \t输出 Go 语言语法格式的类型和值\n%% \t输出 % 本体\n%b \t整型以二进制方式显示\n%o \t整型以八进制方式显示\n%d \t整型以十进制方式显示\n%x \t整型以十六进制方式显示\n%X \t整型以十六进制、字母大写方式显示\n%U \tUnicode 字符\n%f \t浮点数\n%p \t指针，十六进制方式显示\n```\n", "timestamp": "2025-10-19T19:25:19.488535"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/Java.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/Java.md", "content": "# Java\n\n---\n\n**推荐工具/资源书籍**\n- [JAVACORE](https://dunwu.github.io/javacore/)\n- [Java Web安全](https://javasec.org/) - 一个不定期更新的免费开源的 Java Web 安全相关知识归纳总结、培训的项目。\n- [jenv/jenv](https://github.com/jenv/jenv) - Manage your Java environment\n\n**推荐的 IntelliJ IDEA 插件**\n- Material Theme UI\n- Rainbow Brackets\n- codeGlance\n\n---\n\n## 常见报错\n\n**Error:java: 源发行版 13 与 --enable-preview 一起使用时无效   （仅发行版 14 支持预览语言功能）**\n* 修改 Project Structure 中的 Project SDK 或 Language Level.\n* 点击\"Settings\"-->\"Bulid, Execution,Deployment\"-->\"Compiler\"-->\"Java Compiler\"，Target bytecode version设为本地Java版本。\n* 在 maven地址\\conf\\settings.xml中设置默认jdk版本\n    ```xml\n    <profile>\n      <id>development</id>\n      <activation>\n        <jdk>11</jdk>\n        <activeByDefault>true</activeByDefault>\n      </activation>\n      <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <maven.compiler.compilerVersion>11</maven.compiler.compilerVersion>\n      </properties>\n    </profile>\n    ```\n\n**Windows不能用鼠标双击运行jar文件**\n* https://jingyan.baidu.com/article/200957617c3619cb0621b44d.html\n\n--\n\n## 简介\n\nJava 最早是由 SUN 公司（已被 Oracle 收购）的詹姆斯·高斯林（高司令，人称 Java 之父）在上个世纪90年代初开发的一种编程语言，最初被命名为 Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让 Oak 重新焕发了生机，于是 SUN 公司改造了 Oak，在 1995 年以 Java 的名称正式发布，原因是 Oak 已经被人注册了，因此 SUN 注册了 Java 这个商标。随着互联网的高速发展，Java 逐渐成为最重要的网络编程语言。\n\nJava 介于编译型语言和解释型语言之间。编译型语言如 C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM 等）CPU 的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如 Python、Ruby 没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而 Java 是将代码编译成一种“字节码”，它类似于抽象的 CPU 指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对 Java 开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行 Java 字节码，SUN 公司制定了一系列的 Java 虚拟机规范。从实践的角度看，JVM 的兼容性做得非常好，低版本的 Java 字节码完全可以正常运行在高版本的 JVM 上。\n\n随着 Java 的发展，SUN 给 Java 又分出了三个不同版本：\n- Java EE(Java Platform Enterprise Edition-Java 平台企业版)\n    - Java EE 指的是 Java 平台企业版（Java Platform Enterprise Edition），之前称为 Java 2 Platform, Enterprise Edition(J2EE)，2017年的9月 Oracle 将 Java EE 捐赠给 Eclipse 基金会，由于 Oracle 持有 Java 商标原因，Eclipse 基金于2018年3月将 Java EE 更名为 Jakarta EE。\n\n- Java SE(Java Platform, Standard Edition-Java 平台标准版)\n    - Java SE 是 JDK 自带的标准 API，内容涉及范围甚广\n\n- Java ME(Java Platform, Micro Edition-Java 平台微型版)。\n\n![](../../../assets/img/Develop/Java/1.png)\n\n简单来说，Java SE 就是标准版，包含标准的 JVM 和标准库，而 Java EE 是企业版，它只是在 Java SE 的基础上加上了大量的 API 和库，以便方便开发 Web 应用、数据库、消息服务等，Java EE 的应用使用的虚拟机和 Java SE 完全相同。\n\nJava ME 就和 Java SE 不同，它是一个针对嵌入式设备的“瘦身版”，Java SE 的标准库无法在 Java ME 上使用，Java ME 的虚拟机也是“瘦身版”。\n\n毫无疑问，Java SE 是整个 Java 平台的核心，而 Java EE 是进一步学习 Web 应用所必须的。我们熟悉的 Spring 等框架都是 Java EE 开源生态系统的一部分。不幸的是，Java ME 从来没有真正流行起来，反而是 Android 开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习 Java ME。\n\n---\n\n## Java 版本\n\n从1995年发布1.0版本开始，到目前为止，版本如下:\n| 时间\t    | 版本 |\n| - | - |\n| 1995\t    | 1.0 |\n| 1998\t    | 1.2 |\n| 2000\t    | 1.3 |\n| 2002\t    | 1.4 |\n| 2004\t    | 1.5 / 5.0 |\n| 2005\t    | 1.6 / 6.0 |\n| 2011\t    | 1.7 / 7.0 |\n| 2014\t    | 1.8 / 8.0 |\n| 2017/9\t| 1.9 / 9.0 |\n| 2018/3\t| 10 |\n| 2018/9\t| 11 |\n| 2019/3\t| 12 |\n| 2019/9\t| 13 |\n| 2020/3\t| 14 |\n\n---\n\n## JDK 和 JRE\n\n- JDK：Java Development Kit\n- JRE：Java Runtime Environment\n\n简单地说，JRE 就是运行 Java 字节码的虚拟机。但是，如果只有 Java 源码，要编译成 Java 字节码，就需要 JDK，因为 JDK 除了包含 JRE，还提供了编译器、调试器等开发工具。\n\n二者关系如下：\n\n![](../../../assets/img/Develop/Java/2.png)\n\n---\n\n## JSR 和 JCP\n\n- JSR 规范：Java Specification Request\n    - 为了保证 Java 语言的规范性，SUN 公司搞了一个 JSR 规范，凡是想给 Java 平台加一个功能，比如说访问数据库的功能，大家要先创建一个 JSR 规范，定义好接口，这样，各个数据库厂商都按照规范写出 Java 驱动程序，开发者就不用担心自己写的数据库代码在 MySQL 上能跑，却不能跑在 PostgreSQ L上。所以 JSR 是一系列的规范，从 JVM 的内存模型到 Web 程序接口，全部都标准化了。\n\n- JCP 组织：Java Community Process\n    - 负责审核 JSR 的组织就是 JCP。\n\n\n一个 JSR 规范发布时，为了让大家有个参考，还要同时发布一个“参考实现”，以及一个“兼容性测试套件”：\n- RI：Reference Implementation\n- TCK：Technology Compatibility Kit\n\n比如有人提议要搞一个基于 Java 开发的消息服务器，这个提议很好啊，但是光有提议还不行，得贴出真正能跑的代码，这就是 RI。如果有其他人也想开发这样一个消息服务器，如何保证这些消息服务器对开发者来说接口、功能都是相同的？所以还得提供 TCK。\n\n通常来说，RI 只是一个“能跑”的正确的代码，它不追求速度，所以，如果真正要选择一个 Java 的消息服务器，一般是没人用 RI 的，大家都会选择一个有竞争力的商用或开源产品。\n\n---\n\n## 一些项目\n\n- [HaberHe/pdf-export](https://github.com/HaberHe/pdf-export) - pdf转jpg\n", "timestamp": "2025-10-19T19:25:19.880721"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/JVM/字节码.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/JVM/%E5%AD%97%E8%8A%82%E7%A0%81.md", "content": "# 字节码\n\n---\n\nJava 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。\n\n`.class` 文件是一组以 8 位字节为基础单位的二进制流，各个数据项严格按照顺序紧凑地排列在 `.class` 文件中，中间没有添加任何分隔符。整个 `.class` 文件本质上就是一张表。\n\n---\n\n## 字节码\n\n### 什么是字节码\n\n之所以被称之为字节码，是因为字节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取。在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个 `.java` 文件从编译到运行的示例如下图所示。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/1.png)\n\n对于开发人员，了解字节码可以更准确、直观地理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观地看到 Volatile 关键字如何在字节码上生效。另外，字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于 JVM 规范的存在，只要最终可以生成符合规范的字节码就可以在 JVM 上运行，因此这就给了各种运行在 JVM 上的语言（如 Scala、Groovy、Kotlin）一种契机，可以扩展 Java 所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。\n\n### 字节码结构\n\n.java 文件通过 javac 编译后将得到一个.class 文件，如下：\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/2.png)\n\n编译后生成 .class 文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图右侧部分所示。\n\nJVM 对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？\n\nJVM 规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如下所示。接下来我们将一一介绍这十部分：\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/3.png)\n\n#### 魔数（Magic Number）\n\n每个 `.class` 文件的头 4 个字节称为 魔数（magic number），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 `.class` 文件。魔数的固定值为：`0xCAFEBABE`。\n\n有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。\n\n#### 版本号（Version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。\n\n举例来说，如果版本号为：“00 00 00 34”。那么，次版本号转化为十进制为 0，主版本号转化为十进制为 52，在 Oracle 官网中查询序号 52 对应的主版本号为 1.8，所以编译该文件的 Java 版本号为 1.8.0。\n\n#### 常量池（Constant Pool）\n\n紧接着主版本号之后的字节为常量池入口。\n\n常量池主要存放两类常量：\n\n* 字面量 - 如文本字符串、声明为 final 的常量值。\n* 符号引用\n    * 类和接口的全限定名\n    * 字段的名称和描述符\n    * 方法的名称和描述符\n\n常量池整体上分为两部分：常量池计数器以及常量池数据区，如下图\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/4.png)\n\n* 常量池计数器（constant_pool_count） - 由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。图中示例代码的字节码前 10 个字节如下图所示，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/5.png)\n\n* 常量池数据区 - 数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。在字节码中共有 14 种类型的 cp_info，每种类型的结构都是固定的。\n\n具体以 CONSTANT_utf8_info 为例。首先一个字节“tag”，它的值取自上图中对应项的 Tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 Length，然后 Length 个字节为这个字符串具体的值。从字节码摘取一个 cp_info 结构，如下图所示。将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n| 长度 | 名称 | 值 |\n| - | - | - |\n| 1字节 | tag | 01 表示 utf8 类型 |\n| 2字节 | length | 该 utf8 字符串的长度 |\n| length个字节 | bytes | length 个字节的具体数据 |\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/6.png)\n\n其他类型的 cp_info 结构不再赘述，整体结构大同小异，都是先通过 Tag 来标识类型，然后后续 n 个字节来描述长度和（或）数据。\n\n先知其所以然，以后可以通过 javap -verbose xxx 命令，查看 JVM 反编译后的完整常量池，如下图所示。可以看到反编译结果将每一个 cp_info 结构的类型和值都很明确地呈现了出来。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/7.png)\n\n#### 访问标志\n\n紧接着的 2 个字节代表访问标志，这个标志用于识别一些类或者接口的访问信息，描述该 Class 是类还是接口，以及是否被 public、abstract、final 等修饰符修饰。\n\nJVM 规范规定了如下图的访问标志（Access_Flag）。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/8.png)\n\n#### 当前类名\n\n访问标志后的 2 个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。\n\n#### 父类名称\n\n当前类名后的 2 个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。\n\n#### 接口信息\n\n父类名称后为 2 字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的 n 个字节是所有接口名称的字符串常量的索引值。\n\n#### 字段表\n\n字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息 fields_info。字段表结构如下图所示：\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/9.png)\n\n以字节码的字段表为例，如下图所示。其中字段的访问标志查图 9，0002 对应为 Private。通过索引下标在图 8 中常量池分别得到字段名为“a”，描述符为“I”（代表 int）。综上，就可以唯一确定出一个类中声明的变量 private int a。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/10.png)\n\n#### 方法表\n\n字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/11.png)\n\n方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。而“方法的属性”这一部分较为复杂，直接借助 javap -verbose 将其反编译为人可以读懂的信息进行解读，如下图所示。可以看到属性中包括以下三个部分：\n\n“Code 区”：源代码对应的 JVM 指令操作码，在进行字节码增强时重点操作的就是“Code 区”这一部分。\n“LineNumberTable”：行号表，将 Code 区的操作码和源代码中的行号对应，Debug 时会起到作用（源代码走一行，需要走多少个 JVM 指令操作码）。\n“LocalVariableTable”：本地变量表，包含 This 和局部变量，之所以可以在每一个方法内部都可以调用 This，是因为 JVM 将 This 作为每一个方法的第一个参数隐式进行传入。当然，这是针对非 Static 方法而言。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/12.png)\n\n#### 附加属性表\n\n字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。\n\n### 字节码操作集合\n\n在上图中，Code 区的红色编号 0 ～ 14，就是.java 中的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看 Oracle 官方文档进行了解，在需要用到时进行查阅即可。\n\n比如第一个助记符为 iconst_2，对应到字节码为 0x05，用处是将 int 值 2 压入操作数栈中。以此类推，对 0~17 的助记符理解后，就是完整的 `add()` 方法的实现。\n\n### 操作数栈和字节码\n\nJVM 的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个 FILO 结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在 CPU 的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。\n\n上文所说的操作码或者操作集合，其实控制的就是这个 JVM 的操作数栈。\n\n### 字节码工具\n\n* Idea 插件 : [jclasslib](https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer)\n\n代码编译后在菜单栏\"View\"中选择\"Show Bytecode With jclasslib\"，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/13.png)\n\n---\n\n## 字节码增强\n\n### Asm\n\n对于需要手动操纵字节码的需求，可以使用 Asm，它可以直接生产 .class字节码文件，也可以在类被加载入 JVM 之前动态修改类行为。\n\nAsm 的应用场景有 AOP（Cglib 就是基于 Asm）、热部署、修改其他 jar 包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。\n\n![](../../../../../assets/img/Develop/Java/笔记/JVM/字节码/14.png)\n\nAsm 有两类 API：核心 API 和树形 API\n\n#### 核心 API\n\nAsm Core API 可以类比解析 XML 文件中的 SAX 方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用 Core API。在 Core API 中有以下几个关键类：\n* ClassReader：用于读取已经编译好的 .class 文件。\n* ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。\n* 各种 Visitor 类：如上所述，CoreAPI 根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的 Visitor，比如用于访问方法的 MethodVisitor、用于访问类变量的 FieldVisitor、用于访问注解的 AnnotationVisitor 等。为了实现 AOP，重点要使用的是 MethodVisitor。\n\n#### #树形 API\n\nAsm Tree API 可以类比解析 XML 文件中的 DOM 方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi 不同于 CoreAPI，TreeAPI 通过各种 Node 类来映射字节码的各个区域，类比 DOM 节点，就可以很好地理解这种编程方式。\n\n### Javassist\n\n利用 Javassist 实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。\n\n其中最重要的是 ClassPool、CtClass、CtMethod、CtField 这四个类：\n\n* `CtClass（compile-time class）` - 编译时类信息，它是一个 class 文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个 CtClass 对象，用来表示这个类文件。\n* `ClassPool` - 从开发视角来看，ClassPool 是一张保存 CtClass 信息的 HashTable，key 为类名，value 为类名对应的 CtClass 对象。当我们需要对某个类进行修改时，就是通过 pool.getCtClass(\"className\")方法从 pool 中获取到相应的 CtClass。\n* `CtMethod`、`CtField` - 这两个比较好理解，对应的是类中的方法和属性。\n\n---\n\n## Source & Reference\n\n- https://dunwu.github.io/javacore/jvm/jvm-bytecode.html\n", "timestamp": "2025-10-19T19:25:20.537551"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Maven.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Maven.md", "content": "# Maven\n\n---\n\n## 简介\n\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。\n\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\n\n一个 Java 项目需要确定引入哪些依赖包。例如，如果我们需要用到 commons logging，我们就必须把 commons logging 的 jar 包放入 classpath。如果我们还需要 log4j，就需要把 log4j 相关的 jar 包都放到 classpath 中。这些就是依赖包的管理。\n\n其次，我们要确定项目的目录结构。例如，src 目录存放 Java 源码，resources 目录存放配置文件，bin 目录存放编译生成的. class 文件。\n\n此外，我们还需要配置环境，例如 JDK 的版本，编译打包的流程，当前代码的版本号。\n\n最后，除了使用 Eclipse 这样的 IDE 进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。\n\n这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的 Java 项目管理和构建工具。\n\nMaven 就是是专门为 Java 项目打造的管理和构建工具，它的主要功能有：\n* 提供了一套标准化的项目结构；\n* 提供了一套标准化的构建流程（编译，测试，打包，发布……）；\n* 提供了一套依赖管理机制。\n\n---\n\n## Maven 特点\n\n* 项目设置遵循统一的规则。\n* 任意工程中共享。\n* 依赖管理包括自动更新。\n* 一个庞大且不断增长的库。\n* 可扩展，能够轻松编写 Java 或脚本语言的插件。\n* 只需很少或不需要额外配置即可即时访问新功能。\n* `基于模型的构建` − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。\n* `项目信息的一致性站点` − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。\n* `发布管理和发布单独的输出` − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven 能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。\n* `向后兼容性` − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。\n* 子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号，\n* `并行构建` − 编译的速度能普遍提高20 - 50 %。\n* `更好的错误报告` − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。\n\n---\n\n## 约定配置\n\nMaven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：\n\n| 目录\t| 目的 |\n| - | - |\n| ${basedir}\t                        | 存放 pom.xml 和所有的子目录 |\n| ${basedir}/src/main/java\t            | 项目的 java 源代码 |\n| ${basedir}/src/main/resources\t        | 项目的资源，比如说 property 文件，springmvc.xml |\n| ${basedir}/src/test/java\t            | 项目的测试类，比如说 Junit 代码 |\n| ${basedir}/src/test/resources\t        | 测试用的资源 |\n| ${basedir}/src/main/webapp/WEB-INF\t| web 应用文件目录，web 项目的信息，比如存放 web.xml、本地图片、jsp 视图页面 |\n| ${basedir}/target\t                    | 打包输出目录 |\n| ${basedir}/target/classes\t            | 编译输出目录 |\n| ${basedir}/target/test-classes\t    | 测试编译输出目录 |\n| Test.java\t                            | Maven 只会自动运行符合该命名规则的测试类 |\n| ~/.m2/repository\t                    | Maven 默认的本地仓库目录位置 |\n\n---\n\n## Maven 环境配置\n\nMaven 下载地址：http://maven.apache.org/download.cgi\n\n下载包后解压\n\n添加系统变量 MAVEN_HOME\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/1.png)\n\n编辑系统变量 Path，添加变量值：%MAVEN_HOME%\\bin\n\n输入 mvn -version，查看 Maven 的版本信息\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/3.png)\n\n---\n\n## Maven 项目结构\n\n一个使用 Maven 管理的普通的 Java 项目，它的目录结构默认如下：\n```\na-maven-project\n├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   └── resources\n│   └── test\n│       ├── java\n│       └── resources\n└── target\n```\n\n项目的根目录 a-maven-project 是项目名，它有一个项目描述文件 pom.xml，存放 Java 源码的目录是 src/main/java，存放资源文件的目录是 src/main/resources，存放测试源码的目录是 src/test/java，存放测试资源的目录是 src/test/resources，最后，所有编译、打包生成的文件都放在 target 目录里。这些就是一个 Maven 项目的标准目录结构。\n\n所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven 就可以正常使用。\n\n最关键是项目描述文件 pom.xml\n\n---\n\n## Maven POM\n\nPOM(Project Object Model，项目对象模型) 是 Maven 工程的基本工作单元，是一个 XML 文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。\n\n执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\nPOM 中可以指定以下配置：\n* 项目依赖\n* 插件\n* 执行目标\n* 项目构建 profile\n* 项目版本\n* 项目开发者列表\n* 相关邮件列表信息\n\n所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。\n* project\t    工程的根标签。\n* modelVersion\t模型版本需要设置为 4.0。\n* groupId\t    这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.bank.project 拥有和银行相关的项目。\n* artifactId\t这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。\n* version       这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。\n\n```xml\n<project xmlns = \"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0\n    http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\n    <!-- 模型版本 -->\n    <modelVersion>4.0.0</modelVersion>\n    <!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.bank.project，maven会将该项目打成的jar包放本地路径：/com/bank/project -->\n    <groupId>com.bank.project</groupId>\n\n    <!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 -->\n    <artifactId>project</artifactId>\n\n    <!-- 版本号 -->\n    <version>1.0</version>\n</project>\n```\n\ngroupId 类似于 Java 的包名，通常是公司或组织名称，artifactId 类似于 Java 的类名，通常是项目名称，再加上 version，一个 Maven 工程就是由 groupId，artifactId 和 version 作为唯一标识。我们在引用其他第三方库的时候，也是通过这 3 个变量确定。例如，依赖 commons-logging：\n```xml\n<dependency>\n    <groupId>commons-logging</groupId>\n    <artifactId>commons-logging</artifactId>\n    <version>1.2</version>\n</dependency>\n```\n\n使用 `<dependency>` 声明一个依赖后，Maven 就会自动下载这个依赖包并把它放到 classpath 中。\n\n### Super POM\n\nSuper POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 http://repo1.maven.org/maven2 去下载。\n\nMaven 使用 effective pom（Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 pom.xml 中做尽可能少的配置，当然这些配置可以被重写。\n\n创建目录 MVN/project，在该目录下创建 pom.xml，内容如下：\n\n在命令控制台，进入 MVN/project 目录，执行以下命令：\n```\nmvn help:effective-pom\n```\n\nMaven 将会开始处理并显示 effective-pom。\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/2.png)\n\nMaven 提供了大量的原型插件来创建工程，包括工程结构和 pom.xml。\n\n---\n\n## 依赖管理\n\n如果我们的项目依赖第三方的 jar 包，例如 commons logging，那么问题来了：commons logging 发布的 jar 包在哪下载？\n\n如果我们还希望依赖 log4j，那么使用 log4j 需要哪些 jar 包？\n\n类似的依赖还包括：JUnit，JavaMail，MySQL 驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载 zip 包，解压，放入 classpath。但是，这个过程非常繁琐。\n\nMaven 解决了依赖管理问题。例如，我们的项目依赖 abc 这个 jar 包，而 abc 又依赖 xyz 这个 jar 包：\n```\nSample Project -->  abc  -->  xyz\n```\n当我们声明了 abc 的依赖时，Maven 自动把 abc 和 xyz 都加入了我们的项目依赖，不需要我们自己去研究 abc 是否需要依赖 xyz。\n\n因此，Maven 的第一个作用就是解决依赖管理。我们声明了自己的项目需要 abc，Maven 会自动导入 abc 的 jar 包，再判断出 abc 需要 xyz，又会自动导入 xyz 的 jar 包，这样，最终我们的项目会依赖 abc 和 xyz 两个 jar 包。\n\n我们来看一个复杂依赖示例：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <version>1.4.2.RELEASE</version>\n</dependency>\n```\n\n当我们声明一个 spring-boot-starter-web 依赖时，Maven 会自动解析并判断最终需要大概二三十个其他依赖：\n\n```\nspring-boot-starter-web\n  spring-boot-starter\n    spring-boot\n    sprint-boot-autoconfigure\n    spring-boot-starter-logging\n      logback-classic\n        logback-core\n        slf4j-api\n      jcl-over-slf4j\n        slf4j-api\n      jul-to-slf4j\n        slf4j-api\n      log4j-over-slf4j\n        slf4j-api\n    spring-core\n    snakeyaml\n  spring-boot-starter-tomcat\n    tomcat-embed-core\n    tomcat-embed-el\n    tomcat-embed-websocket\n      tomcat-embed-core\n  jackson-databind\n  ...\n```\n如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。\n\n### 依赖关系\n\nMaven 定义了几种依赖关系，分别是 compile、test、runtime 和 provided：\n\n| scope\t        | 说明\t                            | 示例 |\n| - | - | - |\n| compile\t    | 编译时需要用到该 jar 包（默认）\t        | commons-logging |\n| test\t        | 编译 Test 时需要用到该 jar 包\t            | junit |\n| runtime\t    | 编译时不需要，但运行时需要用到      \t    | mysql |\n| provided\t    | 编译时需要用到，但运行时由 JDK 或某个服务器提供\t| servlet-api |\n\n其中，默认的 compile 是最常用的，Maven 会把这种类型的依赖直接放入 classpath。\n\ntest 依赖表示仅在测试时使用，正常运行时并不需要。最常用的 test 依赖就是 JUnit：\n\n```xml\n<dependency>\n    <groupId>org.junit.jupiter</groupId>\n    <artifactId>junit-jupiter-api</artifactId>\n    <version>5.3.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nruntime 依赖表示编译时不需要，但运行时需要。最典型的 runtime 依赖是 JDBC 驱动，例如 MySQL 驱动：\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.48</version>\n    <scope>runtime</scope>\n</dependency>\n```\n\nprovided 依赖表示编译时需要，但运行时不需要。最典型的 provided 依赖是 Servlet API，编译的时候需要，但是运行时，Servlet 服务器内置了相关的 jar，所以运行期不需要：\n\n```xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>4.0.0</version>\n    <scope>provided</scope>\n</dependency>\n```\n\nMaven 如何知道从何处下载所需的依赖？也就是相关的 jar 包？答案是 Maven 维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的 jar 以及相关信息上传至中央仓库，Maven 就可以从中央仓库把所需依赖下载到本地。\n\nMaven 并不会每次都从中央仓库下载 jar 包。一个 jar 包一旦被下载过，就会被 Maven 自动缓存在本地目录（用户主目录的. m2 目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的 jar 包。\n\n### 唯一ID\n\n对于某个依赖，Maven 只需要 3 个变量即可唯一确定某个 jar 包：\n* groupId：属于组织的名称，类似 Java 的包名；\n* artifactId：该 jar 包自身的名称，类似 Java 的类名；\n* version：该 jar 包的版本。\n\n通过上述 3 个变量，即可唯一确定某个 jar 包。Maven 通过对 jar 包进行 PGP 签名确保任何一个 jar 包一经发布就无法修改。修改已发布 jar 包的唯一方法是发布一个新版本。\n\n因此，某个 jar 包一旦被 Maven 下载过，即可永久地安全缓存在本地。\n\n注：只有以 -SNAPSHOT 结尾的版本号会被 Maven 视为开发版本，开发版本每次都会重复下载，这种 SNAPSHOT 版本只能用于内部私有的 Maven repo，公开发布的版本不允许出现 SNAPSHOT。\n\n---\n\n## Maven镜像\n\n国内用户可以使用阿里云提供的 Maven 镜像仓库。使用 Maven 镜像仓库需要一个配置，进入maven 的conf目录，编辑 settings.xml 配置文件，内容如下：\n\n```xml\n<mirror>\n  <id>aliyunmaven</id>\n  <mirrorOf>*</mirrorOf>\n  <name>阿里云公共仓库</name>\n  <url>https://maven.aliyun.com/repository/public</url>\n</mirror>\n```\n\n配置镜像仓库后，Maven的下载速度就会非常快。\n\n如果是 idea 自带的,根据 idea 里的配置来改\n\n具体可以参考阿里云的教程\n- https://developer.aliyun.com/mvn/guide\n\n---\n\n## 命令行编译\n\n在命令中，进入到 pom.xml 所在目录，输入以下命令：\n\n```\nmvn clean package\n```\n\n如果一切顺利，即可在 target 目录下获得编译后自动打包的 jar。\n\n---\n\n## lifecycle\n\n### phase\n\nMaven 的生命周期由一系列阶段（phase）构成，以内置的生命周期 default 为例，它包含以下 phase：\n* validate\n* initialize\n* generate-sources\n* process-sources\n* generate-resources\n* process-resources\n* compile\n* process-classes\n* generate-test-sources\n* process-test-sources\n* generate-test-resources\n* process-test-resources\n* test-compile\n* process-test-classes\n* test\n* prepare-package\n* package\n* pre-integration-test\n* integration-test\n* post-integration-test\n* verify\n* install\n* deploy\n\n如果我们运行 mvn package，Maven 就会执行 default 生命周期，它会从开始一直运行到 package 这个 phase 为止：\n* validate\n* ...\n* package\n\n如果我们运行 mvn compile，Maven 也会执行 default 生命周期，但这次它只会运行到 compile，即以下几个 phase：\n* validate\n* ...\n* compile\n\nMaven 另一个常用的生命周期是 clean，它会执行 3 个 phase：\n* pre-clean\n* clean （注意这个clean不是lifecycle而是phase）\n* post-clean\n\n所以，我们使用 mvn 这个命令时，后面的参数是 phase，Maven 自动根据生命周期运行到指定的 phase。\n\n更复杂的例子是指定多个 phase，例如，运行 mvn clean package，Maven 先执行 clean 生命周期并运行到 clean 这个 phase，然后执行 default 生命周期并运行到 package 这个 phase，实际执行的 phase 如下：\n* pre-clean\n* clean （注意这个 clean 是 phase）\n* validate\n* ...\n* package\n\n在实际开发过程中，经常使用的命令有：\n```\nmvn clean           清理所有生成的 class 和 jar；\nmvn clean compile   先清理，再执行到 compile；\nmvn clean test      先清理，再执行到 test，因为执行 test 前必须执行 compile，所以这里不必指定 compile；\nmvn clean package   先清理，再执行到 package。\n```\n大多数 phase 在执行过程中，因为我们通常没有在 pom.xml 中配置相关的设置，所以这些 phase 什么事情都不做。\n\n经常用到的 phase 其实只有几个：\n* clean：清理\n* compile：编译\n* test：运行测试\n* package：打包\n\n### Goal\n\n| 执行的 Phase\t    | 对应执行的 Goal |\n| - | - |\n| compile\t        | compiler:compile |\n| test\t            | compiler:testCompile && surefire:test |\n\ngoal 的命名总是 abc:xyz 这种形式。\n\nlifecycle 相当于 Java 的 package，它包含一个或多个 phase；\n\nphase 相当于 Java 的 class，它包含一个或多个 goal；\n\ngoal 相当于 class 的 method，它其实才是真正干活的。\n\n大多数情况，我们只要指定 phase，就默认执行这些 phase 默认绑定的 goal，只有少数情况，我们可以直接指定运行一个 goal，例如，启动 Tomcat 服务器：\n```\nmvn tomcat:run\n```\n\n---\n\n## 插件\n\n使用 Maven 构建项目就是执行 lifecycle，执行到指定的 phase 为止。每个 phase 会执行自己默认的一个或多个 goal。goal 是最小任务单元。\n\n我们以 compile 这个 phase 为例，如果执行：\n\n```\nmvn compile\n```\n\nMaven 将执行 compile 这个 phase，这个 phase 会调用 compiler 插件执行关联的 compiler:compile 这个 goal。\n\n实际上，执行每个 phase，都是通过某个插件（plugin）来执行的，Maven 本身其实并不知道如何执行 compile，它只是负责找到对应的 compiler 插件，然后执行默认的 compiler:compile 这个 goal 来完成编译。\n\n所以，使用 Maven，实际上就是配置好需要使用的插件，然后通过 phase 调用它们。\n\nMaven已经内置了一些常用的标准插件：\n\n| 插件名称\t    | 对应执行的phase |\n| - | - |\n| clean\t        | clean |\n| compiler\t    | compile |\n| surefire\t    | test |\n| jar\t        | package |\n\n---\n\n## 模块管理\n\n在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：\n\n对于 Maven 工程来说，原来是一个大项目，现在可以分拆成 3 个模块：\n\n```\nmutiple-project\n├── module-a\n│   ├── pom.xml\n│   └── src\n├── module-b\n│   ├── pom.xml\n│   └── src\n└── module-c\n    ├── pom.xml\n    └── src\n```\n\n如果模块 A 和模块 B 的 pom.xml 高度相似，那么，我们可以提取出共同部分作为 parent：\n\n```\nmultiple-project\n├── pom.xml\n├── parent\n│   └── pom.xml\n├── module-a\n│   ├── pom.xml\n│   └── src\n├── module-b\n│   ├── pom.xml\n│   └── src\n└── module-c\n    ├── pom.xml\n    └── src\n```\n\n模块 B、模块 C 都可以直接从 parent 继承，大幅简化了 pom.xml 的编写。\n\n如果模块 A 依赖模块 B，则模块 A 需要模块 B 的 jar 包才能正常编译，我们需要在模块 A 中引入模块 B\n\n```xml\n    ...\n    <dependencies>\n        <dependency>\n            <groupId>com.itranswarp.learnjava</groupId>\n            <artifactId>module-b</artifactId>\n            <version>1.0</version>\n        </dependency>\n    </dependencies>\n```\n\n最后，在编译的时候，需要在根目录创建一个 pom.xml 统一编译：\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.itranswarp.learnjava</groupId>\n    <artifactId>build</artifactId>\n    <version>1.0</version>\n    <packaging>pom</packaging>\n    <name>build</name>\n\n    <modules>\n        <module>parent</module>\n        <module>module-a</module>\n        <module>module-b</module>\n        <module>module-c</module>\n    </modules>\n</project>\n```\n\n这样，在根目录执行 mvn clean package 时，Maven 根据根目录的 pom.xml 找到包括 parent 在内的共 4 个 `<module>`，一次性全部编译。\n\n---\n\n## eclipse使用maven\n\n### 安装插件\n\n从 Eclipse Marketplace 上获取 m2eclipse 并安装：\n\n首先要在 Eclipse 中安装插件：在 Help->install new software, 输入下面地址 http://download.eclipse.org/technology/m2e/releases\n\n像安装其他插件那样一路下一步就OK了。\n\n### 配置插件\n\nPreference --> maven\n\n可以设置 Installations 和 User Setting\n\n### 创建一个maven项目\n\nnew 一个 project ,选择 Maven Project\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/4.png)\n\n选择默认的工程位置\n\n创建工程，这里可以选择 org.apache.maven.archetype\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/5.png)\n\n填写相关的groupId artifactId version等信息\n\n点击完成就创建好了一个简单的maven工程。\n\n### 目录结构\n\n创建完毕后,目录结构如下\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/6.png)\n\n* pom.xml：用于定义或者添加 jar 包的依赖\n* src-main：用于存放 java 源文件\n* src-test：用于存放测试用例。\n\n也许工程下还会出现 target 文件夹，这个是用来生成对应的 class 文件或发布的 jar 包。\n\n### 常见报错\n\n**XXX中没有主清单属性**\n\n打包后的 jar 文件中的 MANIFEST.MF 缺少项目启动项，即没有 Main-Class 和 Start-Class\n\npom.xml 添加插件即可\n```xml\n\t\t<plugin>\n\t\t    <groupId>org.apache.maven.plugins</groupId>\n\t\t    <artifactId>maven-jar-plugin</artifactId>\n\t\t    <version>3.0.2</version>\n\t\t    <configuration>\n\t\t        <archive>\n\t\t            <manifest>\n\t\t                <addClasspath>true</addClasspath>\n\t\t                <mainClass>com.test.first_maven.App</mainClass> <!-- 此处为主入口-->\n\t\t            </manifest>\n\t\t        </archive>\n\t\t    </configuration>\n\t\t</plugin>\n```\n\n---\n\n## idea 使用 maven\n\nsetting --> Build,Execution,Deployment --> Build Tools --> Maven\n\n![](../../../../assets/img/Develop/Java/笔记/Maven/7.png)\n\n---\n\n## POM 文件样本\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>BETA-Reptile</groupId>\n    <artifactId>BETA-P</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <properties>\n        <argLine>-Dfile.encoding=UTF-8</argLine>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>1.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>[主类]</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n    <dependencies>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n            <scope>runtime</scope>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n---\n\n### JAVAFX\n\n```xml\n将布局 fxml 文件放在 target 文件夹中\n\n <build>\n\t<resources>\n\t\t<resource>\n\t\t\t<!-- 这里是放在 src/main/java-->\n\t\t\t<directory>src/main/java</directory>\n\t\t\t<includes>\n\t\t\t\t<include>**/*.properties</include>\n\t\t\t\t<include>**/*.fxml</include>\n\t\t\t\t<include>**/fxml/*.fxml</include>\n\t\t\t\t<!-- 如果想要弄个包名专门放fxml文件，像上一行这样添加设置 -->\n\t\t\t\t<!-- 之后，使用getResource(\"fxml/xx.fxml\")这样子 -->\n\t\t\t</includes>\n\t\t\t<filtering>false</filtering>\n\t\t</resource>\n\t</resources>\n</build>\n```\n\n---\n\n## SpringBoot 打包插件\n\n```xml\n <build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-marven-plugin</artifactId>\n        <plugin>\n    <plugins>\n <build>\n\n <plugin>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-maven-plugin</artifactId>\n    <version>2.3.7.RELEASE</version>\n    <configuration>\n        <mainClass>code.landgrey.Application</mainClass>\n    </configuration>\n    <executions>\n        <execution>\n            <id>repackage</id>\n            <goals>\n                <goal>repackage</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n---\n\n## idea marven 添加本地 jar 到本地仓库\n\n```\nmvn install:install-file -Dfile=<Jar包的地址>\n           -DgroupId=<Jar包的GroupId>\n           -DartifactId=<Jar包的引用名称>\n           -Dversion=<Jar包的版本>\n           -Dpackaging=<Jar的打包方式>\n\nmvn install:install-file -Dfile=ojdbc8.jar -DgroupId=com.github.noraui -DartifactId=ojdbc8  -Dversion=12.2.0.1 -Dpackaging=jar\n```\n\n---\n\n## maven 打包加入本地 jar\n\n我们需要将本地 jar 也加入到 pom.xml 的依赖配置项中，而本地 jar 最好是放在项目路径下，比如 lib 目录。\n\n在 pom.xml 配置文件中增加一个 dependency 的配置，groupId,artifactId,version 均随意指定，因为最终起决定作用的是 scope 属性以及 systemPath 属性。\n\n```xml\n<dependency>\n    <groupId>asnrt</groupId>\n    <artifactId>javase</artifactId>\n    <version>3.14.15</version>\n    <scope>system</scope>\n    <systemPath>${project.basedir}/lib/asnrt.jar</systemPath>\n</dependency>\n```\n\n只需要这么配置，我们进行 mvn package 的时候，就不会报错，而且打出的 jar 包直接运行也不会报错。\n\n本地运行没有报错，是有个警告，构建成功，放到 gitlab，自动构建，最后运行，出现了以下警告：\n\n```\n[WARNING] Some problems were encountered while building the effective model for com.huali.mec:mec-tcp-receiver:jar:1.0.0\n[WARNING] 'dependencies.dependency.systemPath' for asnrt:javase:jar should not point at files within the project directory, ${project.basedir}/lib/asnrt.jar will be unresolvable by dependent projects @ line 99, column 17\n```\n意思是不能使用项目目录中的 jar，也有人遇到了这样的问题：https://www.phpsong.com/3536.html，根据他的提示，需要将 `${project.basedir}` 改为 `${pom.basedir}` 。\n\n---\n\n## Source & Reference\n\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1309301146648610\n- https://www.runoob.com/maven/maven-tutorial.html\n- https://www.cnblogs.com/xdp-gacl/p/3498271.html\n- https://blog.csdn.net/u012052268/article/details/78916196\n- https://blog.csdn.net/banjing_1993/article/details/83073210\n- https://blog.csdn.net/qq_32588349/article/details/51461182\n", "timestamp": "2025-10-19T19:25:20.747870"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/IoC容器.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/IoC%E5%AE%B9%E5%99%A8.md", "content": "# IoC容器\n\n---\n\n## 什么是容器\n\n容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat 就是一个 Servlet 容器，它可以为 Servlet 的运行提供运行环境。类似 Docker 这样的软件也是一个容器，它提供了必要的 Linux 环境以便运行一个特定的 Linux 进程。\n\n通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet 容器底层实现了 TCP 连接，解析 HTTP 协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像 Servlet 这样代码简单，功能强大的组件。早期的 JavaEE 服务器提供的 EJB 容器最重要的功能就是通过声明式事务服务，使得 EJB 组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。\n\nSpring 的核心就是提供了一个 IoC 容器，它可以管理所有轻量级的 JavaBean 组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP 支持，以及建立在 AOP 基础上的声明式事务服务等。\n", "timestamp": "2025-10-19T19:25:21.146506"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/Spring.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/Spring.md", "content": "# Spring\n\n---\n\n## Spring 是什么\n\nSpring 是一个支持快速开发 Java EE 应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发 Java EE 应用程序的必备。\n\n随着 Spring 越来越受欢迎，在 Spring Framework 基础上，又诞生了 Spring Boot、Spring Cloud、Spring Data、Spring Security 等一系列基于 Spring Framework 的项目。\n\n## Spring Boot\n\n**Spring Boot 是什么**\n\nSpring Boot 是一个基于 Spring 的套件，它帮我们预组装了 Spring 的一系列组件，以便以尽可能少的代码和配置来开发基于 Spring 的 Java 应用程序。\n\n以汽车为例，如果我们想组装一辆汽车，我们需要发动机、传动、轮胎、底盘、外壳、座椅、内饰等各种部件，然后把它们装配起来。Spring 就相当于提供了一系列这样的部件，但是要装好汽车上路，还需要我们自己动手。而 Spring Boot 则相当于已经帮我们预装好了一辆可以上路的汽车，如果有特殊的要求，例如把发动机从普通款换成涡轮增压款，可以通过修改配置或编写少量代码完成。\n\n因此，Spring Boot 和 Spring 的关系就是整车和零部件的关系，它们不是取代关系，试图跳过 Spring 直接学习 Spring Boot 是不可能的。\n\nSpring Boot 的目标就是提供一个开箱即用的应用程序架构，我们基于 Spring Boot 的预置结构继续开发，省时省力。\n\nSpring Boot 让我们的 Spring 应用变的更轻量化。我们不必像以前那样繁琐的构建项目、打包应用、部署到 Tomcat 等应用服务器中来运行我们的业务服务。通过 Spring Boot 实现的服务，只需要依靠一个 Java 类，把它打包成 jar，并通过 java -jar 命令就可以运行起来。这一切相较于传统 Spring 应用来说，已经变得非常的轻便、简单。\n\n**学习资源**\n- [程序猿DD/SpringBoot-Learning](https://gitee.com/didispace/SpringBoot-Learning/tree/master/2.x)\n- [lenve/javaboy-code-samples](https://github.com/lenve/javaboy-code-samples)\n- [gf-huanchupk/SpringBootLearning](https://github.com/gf-huanchupk/SpringBootLearning)\n\n### 创建第一个项目\n\n- [创建第一个项目](./springboot/创建第一个项目.md)\n\n---\n\n## Source & Reference\n\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1266265175882464\n", "timestamp": "2025-10-19T19:25:21.310533"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/API开发.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/API%E5%BC%80%E5%8F%91.md", "content": "# API开发\n\n---\n\n## 构建 RESTful API 与单元测试\n\n回顾在入门案例中使用的 @Controller、@RestController、@RequestMapping 注解。\n- @Controller：修饰 class，用来创建处理 http 请求的对象\n- @RestController：Spring4 之后加入的注解，原来在 @Controller 中返回 json 需要 @ResponseBody 来配合，如果直接用 @RestController 替代 @Controller 就不需要再配置 @ResponseBody，默认返回 json 格式\n- @RequestMapping：配置 url 映射。现在更多的也会直接用以 Http Method 直接关联的映射注解来定义，比如：GetMapping、PostMapping、DeleteMapping、PutMapping 等\n\n下面我们通过使用 Spring MVC 来实现一组对 User 对象操作的 RESTful API，配合注释详细说明在 Spring MVC 中如何映射 HTTP 请求、如何传参、如何编写单元测试。\n\nRESTful API具体设计如下：\n| 请求类型 | URL | 功能说明 |\n| - | - | - |\n| GET | /users | 查询用户列表 |\n| POST | /users | 创建一个用户 |\n| GET | /users/id | 根据 id 查询一个用户 |\n| PUT | /users/id | 根据 id 更新一个用户 |\n| DELETE | /users/id | 根据 id 删除一个用户 |\n\n定义 User 实体\n```java\n@Data\npublic class User {\n\n    private Long id;\n    private String name;\n    private Integer age;\n\n}\n```\n\n注意：相比 1.x 版本中自定义 set 和 get 函数的方式，这里使用 @Data 注解可以实现在编译器自动添加 set 和 get 函数的效果。该注解是 lombok 提供的，只需要在 pom 中引入加入下面的依赖就可以支持：\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n```\n\n实现对 User 对象的操作接口\n```java\n@RestController\n@RequestMapping(value = \"/users\")     // 通过这里配置使下面的映射都在/users下\npublic class UserController {\n\n    // 创建线程安全的Map，模拟users信息的存储\n    static Map<Long, User> users = Collections.synchronizedMap(new HashMap<Long, User>());\n\n    /**\n     * 处理\"/users/\"的GET请求，用来获取用户列表\n     *\n     * @return\n     */\n    @GetMapping(\"/\")\n    public List<User> getUserList() {\n        // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递\n        List<User> r = new ArrayList<User>(users.values());\n        return r;\n    }\n\n    /**\n     * 处理\"/users/\"的POST请求，用来创建User\n     *\n     * @param user\n     * @return\n     */\n    @PostMapping(\"/\")\n    public String postUser(@RequestBody User user) {\n        // @RequestBody注解用来绑定通过http请求中application/json类型上传的数据\n        users.put(user.getId(), user);\n        return \"success\";\n    }\n\n    /**\n     * 处理\"/users/{id}\"的GET请求，用来获取url中id值的User信息\n     *\n     * @param id\n     * @return\n     */\n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // url中的id可通过@PathVariable绑定到函数的参数中\n        return users.get(id);\n    }\n\n    /**\n     * 处理\"/users/{id}\"的PUT请求，用来更新User信息\n     *\n     * @param id\n     * @param user\n     * @return\n     */\n    @PutMapping(\"/{id}\")\n    public String putUser(@PathVariable Long id, @RequestBody User user) {\n        User u = users.get(id);\n        u.setName(user.getName());\n        u.setAge(user.getAge());\n        users.put(id, u);\n        return \"success\";\n    }\n\n    /**\n     * 处理\"/users/{id}\"的DELETE请求，用来删除User\n     *\n     * @param id\n     * @return\n     */\n    @DeleteMapping(\"/{id}\")\n    public String deleteUser(@PathVariable Long id) {\n        users.remove(id);\n        return \"success\";\n    }\n\n}\n```\n\n这里相较 1.x 版本，用更细化的 `@GetMapping` 、`@PostMapping` 等系列注解替换了以前的 `@RequestMaping` 注解；另外，还使用 `@RequestBody` 替换了 `@ModelAttribute` 的参数绑定。\n\n至此，我们通过引入 web 模块（没有做其他的任何配置），就可以轻松利用 Spring MVC 的功能，以非常简洁的代码完成了对 User 对象的 RESTful API 的创建以及单元测试的编写。其中同时介绍了 Spring MVC 中最为常用的几个核心注解：@RestController,RequestMapping 以及一些参数绑定的注解：@PathVariable,@RequestBody 等。\n\n---\n\n## 使用 Swagger\n\n随着前后端分离架构和微服务架构的流行，我们使用 Spring Boot 来构建 RESTful API 项目的场景越来越多。通常我们的一个 RESTful API 就有可能要服务于多个不同的开发人员或开发团队：IOS 开发、Android 开发、Web 开发甚至其他的后端服务等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法就是创建一份 RESTful API 文档来记录所有接口细节，然而这样的做法有以下几个问题：\n- 由于接口众多，并且细节复杂（需要考虑不同的 HTTP 请求类型、HTTP 头部信息、HTTP 请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。\n- 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。\n\n为了解决上面这样的问题，可以使用 Swagger2，它可以轻松的整合到 Spring Boot 中，并与 Spring MVC 程序配合组织出强大 RESTful API 文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外 Swagger2 也提供了强大的页面测试功能来调试每个 RESTful API。\n\n首先，需要一个 Spring Boot 实现的 RESTful API 工程, 可以用上面的内容\n\n整合 Swagger2, 添加 swagger-spring-boot-starter 依赖\n- https://github.com/SpringForAll/spring-boot-starter-swagger\n\n在 pom.xml 中加入依赖，具体如下：\n```xml\n<dependency>\n    <groupId>com.spring4all</groupId>\n    <artifactId>swagger-spring-boot-starter</artifactId>\n    <version>1.9.0.RELEASE</version>\n</dependency>\n```\n\n应用主类中添加 @EnableSwagger2Doc 注解，具体如下\n```java\n@EnableSwagger2Doc\n@SpringBootApplication\npublic class testApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(testApplication.class, args);\n    }\n\n}\n```\n\napplication.properties 中配置文档相关内容，比如\n```conf\nswagger.title=spring-boot-starter-swagger\nswagger.description=Starter for swagger 2.x\nswagger.version=1.4.0.RELEASE\nswagger.license=Apache License, Version 2.0\nswagger.licenseUrl=https://www.apache.org/licenses/LICENSE-2.0.html\nswagger.termsOfServiceUrl=https://github.com/dyc87112/spring-boot-starter-swagger\nswagger.contact.name=test\nswagger.contact.url=http://blog.test.com\nswagger.contact.email=test@qq.com\nswagger.base-package=com.test\nswagger.base-path=/**\n```\n\n各参数配置含义如下：\n- swagger.title：标题\n- swagger.description：描述\n- swagger.version：版本\n- swagger.license：许可证\n- swagger.licenseUrl：许可证URL\n- swagger.termsOfServiceUrl：服务条款URL\n- swagger.contact.name：维护人\n- swagger.contact.url：维护人URL\n- swagger.contact.email：维护人email\n- swagger.base-package：swagger扫描的基础包，默认：全扫描\n- swagger.base-path：需要处理的基础URL规则，默认：/**\n\n启动应用，访问：http://localhost:8080/swagger-ui.html\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/1.png)\n\n如果启动失败可以看下这几个链接,大部分情况是 spring boot 版本问题\n- https://github.com/springfox/springfox/issues/3791\n- https://gitee.com/didispace/SpringBoot-Learning/tree/master/2.x/chapter2-2\n- https://cloud.tencent.com/developer/article/1815129\n- https://www.cnblogs.com/rainbow70626/p/15680184.html\n\n**添加文档内容**\n\n在整合完 Swagger 之后，在 http://localhost:8080/swagger-ui.html 页面中可以看到，关于各个接口的描述还都是英文或遵循代码定义的名称产生的。这些内容对用户并不友好，所以我们需要自己增加一些说明来丰富文档内容。如下所示，我们通过 @Api，@ApiOperation 注解来给 API 增加说明、通过 @ApiImplicitParam、@ApiModel、@ApiModelProperty 注解来给参数增加说明。\n```java\n@Api(tags = \"用户管理\")\n@RestController\n@RequestMapping(value = \"/users\")     // 通过这里配置使下面的映射都在/users下\npublic class UserController {\n\n    // 创建线程安全的Map，模拟users信息的存储\n    static Map<Long, User> users = Collections.synchronizedMap(new HashMap<>());\n\n    @GetMapping(\"/\")\n    @ApiOperation(value = \"获取用户列表\")\n    public List<User> getUserList() {\n        List<User> r = new ArrayList<>(users.values());\n        return r;\n    }\n\n    @PostMapping(\"/\")\n    @ApiOperation(value = \"创建用户\", notes = \"根据User对象创建用户\")\n    public String postUser(@RequestBody User user) {\n        users.put(user.getId(), user);\n        return \"success\";\n    }\n\n    @GetMapping(\"/{id}\")\n    @ApiOperation(value = \"获取用户详细信息\", notes = \"根据url的id来获取用户详细信息\")\n    public User getUser(@PathVariable Long id) {\n        return users.get(id);\n    }\n    @PutMapping(\"/{id}\")\n    @ApiImplicitParam(paramType = \"path\", dataType = \"Long\", name = \"id\", value = \"用户编号\", required = true, example = \"1\")\n    @ApiOperation(value = \"更新用户详细信息\", notes = \"根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息\")\n    public String putUser(@PathVariable Long id, @RequestBody User user) {\n        User u = users.get(id);\n        u.setName(user.getName());\n        u.setAge(user.getAge());\n        users.put(id, u);\n        return \"success\";\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @ApiOperation(value = \"删除用户\", notes = \"根据url的id来指定删除对象\")\n    public String deleteUser(@PathVariable Long id) {\n        users.remove(id);\n        return \"success\";\n    }\n\n}\n\n@Data\n@ApiModel(description=\"用户实体\")\npublic class User {\n\n    @ApiModelProperty(\"用户编号\")\n    private Long id;\n    @ApiModelProperty(\"用户姓名\")\n    private String name;\n    @ApiModelProperty(\"用户年龄\")\n    private Integer age;\n\n}\n```\n\n完成上述代码添加后，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html，就能看到下面这样带中文说明的文档了\n\n---\n\n## JSR-303 实现请求参数校验\n\n请求参数的校验是很多新手开发非常容易犯错，或存在较多改进点的常见场景。比较常见的问题主要表现在以下几个方面：\n- 仅依靠前端框架解决参数校验，缺失服务端的校验。这种情况常见于需要同时开发前后端的时候，虽然程序的正常使用不会有问题，但是开发者忽略了非正常操作。比如绕过前端程序，直接模拟客户端请求，这时候就会突然在前端预设的各种限制，直击各种数据访问接口，使得我们的系统存在安全隐患。\n- 大量地使用if/else语句嵌套实现，校验逻辑晦涩难通，不利于长期维护。\n\n所以，针对上面的问题，建议服务端开发在实现接口的时候，对于请求参数必须要有服务端校验以保障数据安全与稳定的系统运行。同时，对于参数的校验实现需要足够优雅，要满足逻辑易读、易维护的基本特点。\n\n**什么是 JSR-303**\n\nJSR 是 Java Specification Requests 的缩写，意思是 Java 规范提案。是指向 JCP(Java Community Process) 提出新增一个标准化技术规范的正式请求。任何人都可以提交 JSR，以向 Java 平台增添新的 API 和服务。JSR 已成为 Java 界的一个重要标准。\n\n**JSR-303定义的是什么标准**\n\nJSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。\n\n例如:\n- @AssertFalse\t被注释的元素必须为 false\n- @AssertTrue\t被注释的元素必须为 true\n- @DecimalMax\t被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n- @DecimalMin\t被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n\n等\n\n在JSR-303的标准之下，可以通过这些注解，优雅的定义各个请求参数的校验。\n\n**手动实现参数的校验**\n\n拿任何一个使用Spring Boot 2.x构建的提供RESTful API的项目作为基础\n\n先来做一个简单的例子，比如：定义字段不能为Null\n\n在要校验的字段上添加上@NotNull注解\n```java\n@Data\n@ApiModel(description=\"用户实体\")\npublic class User {\n\n    @ApiModelProperty(\"用户编号\")\n    private Long id;\n\n    @NotNull\n    @ApiModelProperty(\"用户姓名\")\n    private String name;\n\n    @NotNull\n    @ApiModelProperty(\"用户年龄\")\n    private Integer age;\n\n}\n```\n\n在需要校验的参数实体前添加 @Valid 注解\n```java\n@PostMapping(\"/\")\n@ApiOperation(value = \"创建用户\", notes = \"根据User对象创建用户\")\npublic String postUser(@Valid @RequestBody User user) {\n    users.put(user.getId(), user);\n    return \"success\";\n}\n```\n\n完成上面配置之后，启动应用，并用POST请求访问localhost:8080/users/接口，body中不包含 age 参数\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/2.png)\n\n**尝试一些其他校验**\n\n在完成了上面的例子之后，我们还可以增加一些校验规则，比如：校验字符串的长度、校验数字的大小、校验字符串格式是否为邮箱等。下面我们就来定义一些复杂的校验定义，比如：\n```java\n@Data\n@ApiModel(description=\"用户实体\")\npublic class User {\n\n    @ApiModelProperty(\"用户编号\")\n    private Long id;\n\n    @NotNull\n    @Size(min = 2, max = 5)\n    @ApiModelProperty(\"用户姓名\")\n    private String name;\n\n    @NotNull\n    @Max(100)\n    @Min(10)\n    @ApiModelProperty(\"用户年龄\")\n    private Integer age;\n\n    @NotNull\n    @Email\n    @ApiModelProperty(\"用户邮箱\")\n    private String email;\n\n}\n```\n\n**Swagger 文档中的体现**\n\nSwagger 自身对 JSR-303 有一定的支持，但是支持的并那么完善，并没有覆盖所有的注解的。\n\n比如，上面我们使用的注解是可以自动生成的，启动上面我们的实验工程，然后访问 http://localhost:8080/swagger-ui.html，在 Models 不是，我们可以看到如下图所示的内容：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/3.png)\n\n其中：name 和 age 字段相比上一篇教程中的文档描述，多了一些关于校验相关的说明；而 email 字段则没有体现相关校验说明。目前，Swagger 共支持以下几个注解：@NotNull、@Max、@Min、@Size、@Pattern。在实际开发过程中，我们需要分情况来处理，对于 Swagger 支自动生成的可以利用原生支持来产生，如果有部分字段无法产生，则可以在 @ApiModelProperty 注解的描述中他，添加相应的校验说明，以便于使用方查看。\n\n**当请求参数校验出现错误信息的时候，错误格式可以修改吗？**\n\n答案是肯定的。这里的错误信息实际上由 Spring Boot 的异常处理机制统一组织并返回的.\n\n**spring-boot-starter-validation是必须的吗？**\n\n在 Spring Boot 2.1 版本中，该依然其实已经包含在了 spring-boot-starter-web 依赖中.\n\n---\n\n## Swagger 接口的分组\n\n我们在 Spring Boot 中定义各个接口是以 Controller 作为第一级维度来进行组织的，Controller 与具体接口之间的关系是一对多的关系。我们可以将同属一个模块的接口定义在一个 Controller 里。默认情况下，Swagger 是以 Controller 为单位，对接口进行分组管理的。这个分组的元素在 Swagger 中称为 Tag，但是这里的 Tag 与接口的关系并不是一对多的，它支持更丰富的多对多关系。\n\n**默认分组**\n\n首先，我们通过一个简单的例子，来看一下默认情况，Swagger 是如何根据 Controller 来组织 Tag 与接口关系的。定义两个 Controller，分别负责教师管理与学生管理接口，比如下面这样：\n```java\n@RestController\n@RequestMapping(value = \"/teacher\")\nstatic class TeacherController {\n\n    @GetMapping(\"/xxx\")\n    public String xxx() {\n        return \"xxx\";\n    }\n\n}\n\n@RestController\n@RequestMapping(value = \"/student\")\nstatic class StudentController {\n\n    @ApiOperation(\"获取学生清单\")\n    @GetMapping(\"/list\")\n    public String bbb() {\n        return \"bbb\";\n    }\n\n    @ApiOperation(\"获取教某个学生的老师清单\")\n    @GetMapping(\"/his-teachers\")\n    public String ccc() {\n        return \"ccc\";\n    }\n\n    @ApiOperation(\"创建一个学生\")\n    @PostMapping(\"/aaa\")\n    public String aaa() {\n        return \"aaa\";\n    }\n\n}\n```\n\n启动应用之后，我们可以看到 Swagger 中这两个 Controller 是这样组织的：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/4.png)\n\n**自定义默认分组的名称**\n\n通过 @Api 注解来自定义 Tag\n```java\n@Api(tags = \"教师管理\")\n@RestController\n@RequestMapping(value = \"/teacher\")\nstatic class TeacherController {\n\n    // ...\n\n}\n\n@Api(tags = \"学生管理\")\n@RestController\n@RequestMapping(value = \"/student\")\nstatic class StudentController {\n\n    // ...\n\n}\n```\n\n再次启动应用之后，我们就看到了如下的分组内容，代码中 @Api 定义的 tags 内容替代了默认产生的 teacher-controller 和 student-controller。\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/5.png)\n\n**合并 Controller 分组**\n\n到这里，我们还都只是使用了 Tag 与 Controller 一一对应的情况，Swagger 中还支持更灵活的分组！\n\n我们可以通过定义同名的 Tag 来汇总 Controller 中的接口，比如我们可以定义一个 Tag 为 “教学管理”，让这个分组同时包含教师管理和学生管理的所有接口，可以这样来实现：\n```java\n@Api(tags = {\"教师管理\", \"教学管理\"})\n@RestController\n@RequestMapping(value = \"/teacher\")\nstatic class TeacherController {\n\n    // ...\n\n}\n\n@Api(tags = {\"学生管理\", \"教学管理\"})\n@RestController\n@RequestMapping(value = \"/student\")\nstatic class StudentController {\n\n    // ...\n\n}\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/6.png)\n\n**更细粒度的接口分组**\n\n通过 @Api 可以实现将 Controller 中的接口合并到一个 Tag 中，但是如果我们希望精确到某个接口的合并呢？比如这样的需求：“教学管理”包含 “教师管理” 中所有接口以及 “学生管理” 管理中的 “获取学生清单” 接口（不是全部接口）。\n\n那么上面的实现方式就无法满足了。这时候发，我们可以通过使用 @ApiOperation 注解中的 tags 属性做更细粒度的接口分类定义，比如上面的需求就可以这样子写：\n```java\n@Api(tags = {\"教师管理\",\"教学管理\"})\n@RestController\n@RequestMapping(value = \"/teacher\")\nstatic class TeacherController {\n\n    @ApiOperation(value = \"xxx\")\n    @GetMapping(\"/xxx\")\n    public String xxx() {\n        return \"xxx\";\n    }\n\n}\n\n@Api(tags = {\"学生管理\"})\n@RestController\n@RequestMapping(value = \"/student\")\nstatic class StudentController {\n\n    @ApiOperation(value = \"获取学生清单\", tags = \"教学管理\")\n    @GetMapping(\"/list\")\n    public String bbb() {\n        return \"bbb\";\n    }\n\n    @ApiOperation(\"获取教某个学生的老师清单\")\n    @GetMapping(\"/his-teachers\")\n    public String ccc() {\n        return \"ccc\";\n    }\n\n    @ApiOperation(\"创建一个学生\")\n    @PostMapping(\"/aaa\")\n    public String aaa() {\n        return \"aaa\";\n    }\n\n}\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/7.png)\n\n---\n\n## Swagger 元素排序\n\n- https://blog.didispace.com/spring-boot-learning-21-2-4/\n\n---\n\n## Swagger 静态文档的生成\n\nSwagger2Markup是Github上的一个开源项目。该项目主要用来将Swagger自动生成的文档转换成几种流行的格式以便于静态部署和使用，比如：AsciiDoc、Markdown、Confluence。\n- https://github.com/Swagger2Markup/swagger2markup\n\n准备一个使用了Swagger的Web项目\n\n生成 AsciiDoc 文档\n\n生成 AsciiDoc 文档的方式有两种：\n\n**通过Java代码来生成**\n\n编辑pom.xml增加需要使用的相关依赖和仓库\n```xml\n<dependencies>\n    ...\n\n    <dependency>\n        <groupId>io.github.swagger2markup</groupId>\n        <artifactId>swagger2markup</artifactId>\n        <version>1.3.3</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\n<repositories>\n    <repository>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n        <id>jcenter-releases</id>\n        <name>jcenter</name>\n        <url>https://jcenter.bintray.com</url>\n    </repository>\n</repositories>\n```\n\n本身这个工具主要就临时用一下，所以这里我们把scope设置为test，这样这个依赖就不会打包到正常运行环境中去。\n\n编写一个单元测试用例来生成执行生成文档的代码\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)\npublic class DemoApplicationTests {\n\n    @Test\n    public void generateAsciiDocs() throws Exception {\n\n        URL remoteSwaggerFile = new URL(\"http://localhost:8080/v2/api-docs\");\n        Path outputDirectory = Paths.get(\"src/docs/asciidoc/generated\");\n\n        //    输出Ascii格式\n        Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder()\n                .withMarkupLanguage(MarkupLanguage.ASCIIDOC)\n                .build();\n\n\n        Swagger2MarkupConverter.from(remoteSwaggerFile)\n                .withConfig(config)\n                .build()\n                .toFolder(outputDirectory);\n    }\n\n}\n```\n\n以上代码内容很简单，大致说明几个关键内容：\n- MarkupLanguage.ASCIIDOC：指定了要输出的最终格式。除了 ASCIIDOC 之外，还有 MARKDOWN 和 CONFLUENCE_MARKUP，分别定义了其他格式，后面会具体举例。\n- from(remoteSwaggerFile)：指定了生成静态部署文档的源头配置，可以是这样的 URL 形式，也可以是符合 Swagger 规范的 String 类型或者从文件中读取的流。如果是对当前使用的 Swagger 项目，我们通过使用访问本地 Swagger 接口的方式，如果是从外部获取的 Swagger 文档配置文件，就可以通过字符串或读文件的方式\n- toFolder(outputDirectory)：指定最终生成文件的具体目录位置\n\n在执行了上面的测试用例之后，我们就能在当前项目的 src 目录下获得如下内容：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/8.png)\n\n可以看到，这种方式在运行之后就生成出了4个不同的静态文件。\n\n**输出到单个文件**\n\n如果不想分割结果文件，也可以通过替换 toFolder(Paths.get(\"src/docs/asciidoc/generated\")) 为 toFile(Paths.get(\"src/docs/asciidoc/generated/all\"))，将转换结果输出到一个单一的文件中，这样可以最终生成 html 的也是单一的。\n\n**通过 Maven 插件来生成**\n\n除了通过上面编写 Java 代码来生成的方式之外，swagger2markup 还提供了对应的 Maven 插件来使用。对于上面的生成方式，完全可以通过在 pom.xml 中增加如下插件来完成静态内容的生成。\n```xml\n<plugin>\n    <groupId>io.github.swagger2markup</groupId>\n    <artifactId>swagger2markup-maven-plugin</artifactId>\n    <version>1.3.3</version>\n    <configuration>\n        <swaggerInput>http://localhost:8080/v2/api-docs</swaggerInput>\n        <outputDir>src/docs/asciidoc/generated-by-plugin</outputDir>\n        <config>\n            <swagger2markup.markupLanguage>ASCIIDOC</swagger2markup.markupLanguage>\n        </config>\n    </configuration>\n</plugin>\n```\n\n在使用插件生成前，需要先启动应用。然后执行插件，就可以在 src/docs/asciidoc/generated-by-plugin 目录下看到也生成了上面一样的 adoc 文件了。\n\n**生成HTML**\n\n在完成了从 Swagger 文档配置文件到 AsciiDoc 的源文件转换之后，就是如何将 AsciiDoc 转换成可部署的 HTML 内容了。这里继续在上面的工程基础上，引入一个 Maven 插件来完成。\n```xml\n<plugin>\n    <groupId>org.asciidoctor</groupId>\n    <artifactId>asciidoctor-maven-plugin</artifactId>\n    <version>1.5.6</version>\n    <configuration>\n   \t    <sourceDirectory>src/docs/asciidoc/generated</sourceDirectory>\n   \t    <outputDirectory>src/docs/asciidoc/html</outputDirectory>\n   \t    <backend>html</backend>\n   \t    <sourceHighlighter>coderay</sourceHighlighter>\n   \t    <attributes>\n            <toc>left</toc>\n  \t    </attributes>\n  \t</configuration>\n</plugin>\n```\n\n通过上面的配置，执行该插件的 asciidoctor:process-asciidoc 命令之后，就能在 src/docs/asciidoc/html 目录下生成最终可用的静态部署 HTML 了。在完成生成之后，可以直接通过浏览器来看查看，你就能看到类似下图的静态部署结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/9.png)\n\n## 找回启动日志中的请求路径列表\n\nSpring构建的Web应用在启动的时候，都会输出当前应用创建的HTTP接口列表。\n\n这些日志接口信息是由 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 类在启动的时候，通过扫描 Spring MVC 的 @Controller、@RequestMapping 等注解去发现应用提供的所有接口信息。然后在日志中打印，以方便开发者排查关于接口相关的启动是否正确。\n\n从Spring Boot 2.1.0版本开始，就不再打印这些信息了，完整的启动日志变的非常少.\n\n**找回日志中请求路径列表**\n\n为什么在Spring Boot 2.1.x版本中不再打印请求路径列表呢？\n\n主要是由于从该版本开始，将这些日志的打印级别做了调整：从原来的INFO调整为TRACE。所以，当我们希望在应用启动的时候打印这些信息的话，只需要在配置文件增增加对RequestMappingHandlerMapping类的打印级别设置即可，比如在application.properties中增加下面这行配置：\n```conf\nlogging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping=trace\n```\n\n在增加了上面的配置之后重启应用，便可以看到更多的日志打印\n\n---\n\n## 使用SpringFox3生成Swagger文档\n\n创建一个Spring Boot项目\n\npom.xml中添加依赖\n```xml\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-boot-starter</artifactId>\n    <version>3.0.0</version>\n</dependency>\n```\n\n应用主类增加注解 @EnableOpenApi 和 @EnableWebMvc\n```java\n@EnableWebMvc\n@EnableOpenApi\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n}\n```\n\n配置一些接口例子\n```java\n@Api(tags=\"用户管理\")\n@RestController\npublic class UserController {\n\n    @ApiOperation(\"创建用户\")\n    @PostMapping(\"/users\")\n    public User create(@RequestBody @Valid User user) {\n        return user;\n    }\n\n    @ApiOperation(\"用户详情\")\n    @GetMapping(\"/users/{id}\")\n    public User findById(@PathVariable Long id) {\n        return new User(\"bbb\", 21, \"上海\", \"aaa@bbb.com\");\n    }\n\n    @ApiOperation(\"用户列表\")\n    @GetMapping(\"/users\")\n    public List<User> list(@ApiParam(\"查看第几页\") @RequestParam int pageIndex,\n                           @ApiParam(\"每页多少条\") @RequestParam int pageSize) {\n        List<User> result = new ArrayList<>();\n        result.add(new User(\"aaa\", 50, \"北京\", \"aaa@ccc.com\"));\n        result.add(new User(\"bbb\", 21, \"广州\", \"aaa@ddd.com\"));\n        return result;\n    }\n\n    @ApiIgnore\n    @DeleteMapping(\"/users/{id}\")\n    public String deleteById(@PathVariable Long id) {\n        return \"delete user : \" + id;\n    }\n\n}\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@ApiModel(\"用户基本信息\")\npublic class User {\n\n    @ApiModelProperty(\"姓名\")\n    @Size(max = 20)\n    private String name;\n    @ApiModelProperty(\"年龄\")\n    @Max(150)\n    @Min(1)\n    private Integer age;\n    @NotNull\n    private String address;\n    @Pattern(regexp = \"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\\\.[a-zA-Z0-9_-]+)+$\")\n    private String email;\n\n}\n```\n\n启动应用！访问 swagger 页面：http://localhost:8080/swagger-ui/index.html\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/API开发/10.png)\n\nSpringFox3 移除了原来默认的 swagger 页面路径：http://host/context-path/swagger-ui.html，新增了两个可访问路径：http://host/context-path/swagger-ui/index.html 和 http://host/context-path/swagger-ui/\n\n通过调整日志级别，还可以看到新版本的 swagger 文档接口也有新增，除了以前老版本的文档接口 /v2/api-docs 之外，还多了一个新版本的 /v3/api-docs 接口。\n\n---\n\n## 使用消息转换器扩展XML格式的请求和响应\n\nSpring Boot 中处理 HTTP 请求的实现是采用的 Spring MVC。而在 Spring MVC 中有一个消息转换器这个概念，它主要负责处理各种不同格式的请求数据进行处理，并包转换成对象，以提供更好的编程体验。\n\n在 Spring MVC 中定义了 HttpMessageConverter 接口，抽象了消息转换器对类型的判断、对读写的判断与操作，具体可见如下定义：\n```java\npublic interface HttpMessageConverter<T> {\n    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);\n    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);\n    List<MediaType> getSupportedMediaTypes();\n    T read(Class<? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;\n    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;\n\n}\n```\n\nHTTP 请求的 Content-Type 有各种不同格式定义，如果要支持 Xml 格式的消息转换，就必须要使用对应的转换器。Spring MVC 中默认已经有一套采用 Jackson 实现的转换器 MappingJackson2XmlHttpMessageConverter。\n\n**引入Xml消息转换器**\n\n在传统Spring应用中，我们可以通过如下配置加入对Xml格式数据的消息转换实现：\n```java\n@Configuration\npublic class MessageConverterConfig1 extends WebMvcConfigurerAdapter {\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();\n        builder.indentOutput(true);\n        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));\n    }\n}\n```\n\n在 Spring Boot 应用不用像上面这么麻烦，只需要加入 jackson-dataformat-xml 依赖，Spring Boot 就会自动引入 MappingJackson2XmlHttpMessageConverter 的实现：\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n```\n\n同时，为了配置Xml数据与维护对象属性的关系所要使用的注解也在上述依赖中，所以这个依赖也是必须的。\n\n**定义对象与Xml的关系**\n\n做好了基础扩展之后，下面就可以定义Xml内容对应的Java对象了，比如：\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@JacksonXmlRootElement(localName = \"User\")\npublic class User {\n\n    @JacksonXmlProperty(localName = \"name\")\n    private String name;\n    @JacksonXmlProperty(localName = \"age\")\n    private Integer age;\n\n}\n```\n\n其中：@Data、@NoArgsConstructor、@AllArgsConstructor是lombok简化代码的注解，主要用于生成get、set以及构造函数。@JacksonXmlRootElement、@JacksonXmlProperty注解是用来维护对象属性在xml中的对应关系。\n\n上述配置的User对象，其可以映射的Xml样例如下\n```xml\n<User>\n\t<name>aaaa</name>\n\t<age>10</age>\n</User>\n```\n\n**创建接收xml请求的接口**\n\n完成了要转换的对象之后，可以编写一个接口来接收xml并返回xml，比如：\n```java\n@Controller\npublic class UserController {\n\n    @PostMapping(value = \"/user\",\n        consumes = MediaType.APPLICATION_XML_VALUE,\n        produces = MediaType.APPLICATION_XML_VALUE)\n    @ResponseBody\n    public User create(@RequestBody User user) {\n        user.setName(\"didispace.com : \" + user.getName());\n        user.setAge(user.getAge() + 100);\n        return user;\n    }\n\n}\n```\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：构建RESTful API与单元测试](https://blog.didispace.com/spring-boot-learning-21-2-1/)\n- [Spring Boot 2.x基础教程：使用Swagger2构建强大的API文档](https://blog.didispace.com/spring-boot-learning-21-2-2/)\n- [Spring Boot 2.x基础教程：JSR-303实现请求参数校验](https://blog.didispace.com/spring-boot-learning-21-2-3/)\n- [spring boot中使用Bean Validation做优雅的参数校验](https://blog.csdn.net/w57685321/article/details/106783433)\n- [Spring Boot 2.x基础教程：Swagger接口分类与各元素排序问题详解](https://blog.didispace.com/spring-boot-learning-21-2-4/)\n- [Spring Boot 2.x基础教程：Swagger静态文档的生成](https://blog.didispace.com/spring-boot-learning-21-2-5/)\n- [Spring Boot 2.x基础教程：找回启动日志中的请求路径列表](https://blog.didispace.com/spring-boot-learning-21-2-6/)\n- [Spring Boot 2.x基础教程：使用SpringFox 3生成Swagger文档](https://blog.didispace.com/spring-boot-learning-21-2-7/)\n- [Spring Boot 2.x基础教程：如何扩展XML格式的请求和响应](https://blog.didispace.com/spring-boot-learning-21-2-8/)\n", "timestamp": "2025-10-19T19:25:21.789000"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/Web开发.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/Web%E5%BC%80%E5%8F%91.md", "content": "# Web开发\n\n---\n\n## Thymeleaf\n\n静态资源访问\n\n在我们开发 Web 应用的时候，需要引用大量的 js、css、图片等静态资源。Spring Boot 默认提供静态资源目录位置需置于 classpath 下，目录名需符合如下规则：\n- /static\n- /public\n- /resources\n- /META-INF/resources\n\n举例：我们可以在 src/main/resources/ 目录下创建 static，在该位置放置一个图片文件。启动程序后，尝试访问 http://localhost:8080/D.jpg。如能显示图片，配置成功。\n\n新建一个 Spring Boot 应用，在 pom.xml 中加入所需的模板引擎模块，比如使用 thymeleaf 的话，只需要引入下面依赖：\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n创建一个 Spring MVC 的传统 Controller，用来处理根路径的请求，将解决渲染到 index 页面上，具体实现如下\n```java\n@Controller\npublic class HelloController {\n\n    @GetMapping(\"/\")\n    public String index(ModelMap map) {\n        map.addAttribute(\"host\", \"http://www.abc.com\");\n        return \"index\";\n    }\n\n}\n```\n\n简要说明：\n- 在渲染到 index 页面的时候，通过 ModelMap，往页面中增加一个 host 参数，其值为 http://www.abc.com\n- return 的值 index 代表了要使用的模板页面名称，默认情况下，它将对应到 src/main/resources/templates / 目录下的 index.html 模板页面\n\n根据上一步要映射的模板，去模板路径 src/main/resources/templates 下新建模板文件 index.html，内容如下：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\" />\n    <title></title>\n</head>\n<body>\n<h1 th:text=\"${host}\">Hello World</h1>\n</body>\n</html>\n```\n\n在该页面的 body 中，包含了一个带有 Thymeleaf 属性的 h1 标签，该便签内容将绑定 host 参数的值。\n\n由于 Thymeleaf 通过属性绑定的特性。该模板页面同其他模板引擎不同，直接通过浏览器打开 html 页面，它是可以正常运作的，将会直接展现 Hello World 标题。这有利于开发页面的时候可以在非启动环境下验证应前端样式的正确性。\n\n如果启动程序后，访问http://localhost:8080/\n\n**Thymeleaf 的配置参数**\n\n如有需要修改默认配置的时候，只需复制下面要修改的属性到 application.properties 中，并修改成需要的值：\n```conf\n# Enable template caching.\nspring.thymeleaf.cache=true\n# Check that the templates location exists.\nspring.thymeleaf.check-template-location=true\n# Content-Type value.\nspring.thymeleaf.content-type=text/html\n# Enable MVC Thymeleaf view resolution.\nspring.thymeleaf.enabled=true\n# Template encoding.\nspring.thymeleaf.encoding=UTF-8\n# Comma-separated list of view names that should be excluded from resolution.\nspring.thymeleaf.excluded-view-names=\n# Template mode to be applied to templates. See also StandardTemplateModeHandlers.\nspring.thymeleaf.mode=HTML5\n# Prefix that gets prepended to view names when building a URL.\nspring.thymeleaf.prefix=classpath:/templates/\n# Suffix that gets appended to view names when building a URL.\nspring.thymeleaf.suffix=.html  spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.\n```\n\n举几个我们常用的配置内容：\n\n- 不想每次修改页面都重启\n\n    修改 spring.thymeleaf.cache 参数，设置为 false\n\n- 不想使用 template 目录存放模板文件\n\n    修改 spring.thymeleaf.prefix 参数，设置为你想放置模板文件的目录\n\n- 不想使用 index 作为模板文件的扩展名\n\n    修改 spring.thymeleaf.suffix 参数，设置为你想用的扩展名\n\n- HTML5 的严格校验很烦人\n\n    修改 spring.thymeleaf.mode 参数，设置为 LEGACYHTML5\n\n---\n\n## ECharts\n\nECharts是百度开源的一个前端组件。它是一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n\n它提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。\n\n除了已经内置的包含了丰富功能的图表，ECharts 还提供了自定义系列，只需要传入一个renderItem函数，就可以从数据映射到任何你想要的图形，更棒的是这些都还能和已有的交互组件结合使用而不需要操心其它事情。\n\n在resources/templates目录下创建index.html页面\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\" />\n    <title>Spring Boot中使用ECharts</title>\n    <script src=\"https://cdn.bootcss.com/echarts/4.6.0/echarts.min.js\"></script>\n</head>\n<body>\n<div id=\"main\" style=\"width: 1000px;height:400px;\"></div>\n</body>\n\n<script type=\"text/javascript\">\n    // 初始化ECharts组件到id为main的元素上\n    let myChart = echarts.init(document.getElementById('main'));\n    // 定义图标的配置项\n    let option = {\n        title: {\n            text: 'Spring Boot中使用ECharts'\n        },\n        tooltip: {},\n        // x轴配置\n        xAxis: {\n            data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n        },\n        // y轴配置\n        yAxis: {},\n        series: [{\n            // 数据集（也可以从后端的Controller中传入）\n            data: [820, 932, 901, 934, 1290, 1330, 1320],\n            // 图表类型，这里使用line，为折线图\n            type: 'line'\n        }]\n    };\n    myChart.setOption(option);\n</script>\n</html>\n```\n\n在页面内容中主要包含三部分：\n- `<head>` 中通过 `<script>` 标签引入 ECharts 的组件 JS，这里使用了 bootcss 的免费公共 cdn。如果用于自己生产环境，不建议使用这类免费 CDN 的 JS 或者 CSS 等静态资源。可以从官网下载所需的静态内容，放到 Spring Boot 的静态资源位置（如果不知道在哪，可见上一篇），或是放到自己公司的静态资源管理的服务器上，实现动静分离。\n- `<body>` 中定义了一个 id 为 main 的 `<div>` 标签，这个标签后续将用来渲染 EChart 组件\n- 最后的一段 `<script>` 内容则是具体的 EChart 图标的展现初始化和配置。具体配置内容可见代码中的注释信息。\n\n启动应用，访问 localhost:8080，如果上面操作均无差错，那就会得到折线图\n\n---\n\n## 文件上传\n\n在pom.xml中引入模版引擎依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n你也可以选择其他你熟悉的模版引擎，比如：Freemarker。\n\n在resources目录下，创建新目录templates；在templates目录下再创建一个文件上传的页面upload.html，内容如下：\n```html\n<!DOCTYPE html>\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\" />\n    <title>文件上传页面</title>\n</head>\n<body>\n<h1>文件上传页面</h1>\n<form method=\"post\" action=\"/upload\" enctype=\"multipart/form-data\">\n    选择要上传的文件：<input type=\"file\" name=\"file\"><br>\n    <hr>\n    <input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n创建文件上传的处理控制器，命名为UploadController\n```java\n@Controller\n@Slf4j\npublic class UploadController {\n\n    @Value(\"${file.upload.path}\")\n    private String path;\n\n    @GetMapping(\"/\")\n    public String uploadPage() {\n        return \"upload\";\n    }\n\n    @PostMapping(\"/upload\")\n    @ResponseBody\n    public String create(@RequestPart MultipartFile file) throws IOException {\n        String fileName = file.getOriginalFilename();\n        String filePath = path + fileName;\n\n        File dest = new File(filePath);\n        Files.copy(file.getInputStream(), dest.toPath());\n        return \"Upload file success : \" + dest.getAbsolutePath();\n    }\n\n}\n```\n\n其中包含这几个重要元素：\n- 成员变量 path，通过 @Value 注入配置文件中的 file.upload.path 属性。这个配置用来定义文件上传后要保存的目录位置。\n- GET 请求，路径 /，用于显示 upload.html 这个文件上传页面。\n- POST 请求。路径 /upload，用于处理上传的文件，即：保存到 file.upload.path 配置的路径下面。\n\n编辑application.properties配置文件\n```conf\nspring.servlet.multipart.max-file-size=2MB\nspring.servlet.multipart.max-request-size=2MB\n\nfile.upload.path=/Users/didi/\n```\n\n前两个参数用于限制了上传请求和上传文件的大小，而file.upload.path是上面我们自己定义的用来保存上传文件的路径。\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：使用 Thymeleaf开发Web页面](https://blog.didispace.com/spring-boot-learning-21-4-1/)\n- [Spring Boot 2.x基础教程：使用 ECharts 绘制各种华丽的数据图表](https://blog.didispace.com/spring-boot-learning-21-4-2/)\n- [Spring Boot 2.x基础教程：实现文件上传](https://blog.didispace.com/spring-boot-learning-21-4-3/)\n", "timestamp": "2025-10-19T19:25:21.962633"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/创建第一个项目.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE.md", "content": "# 创建第一个项目\n\n---\n\n## 使用 IntelliJ IDEA 创建\n\n> Intellij 中的 Spring Initializr 虽然还是基于官方 Web 实现，但是通过工具来进行调用并直接将结果构建到我们的本地文件系统中，让整个构建流程变得更加顺畅\n\n创建一个空项目\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/1.png)\n\n进入主界面, 新建 spring boot 模块\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/2.png)\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/3.png)\n\n填写项目信息\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/4.png)\n\n选择依赖\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/5.png)\n\n此时的项目结构\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/6.png)\n\n新建包 controller, 再新建类Hello\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/7.png)\n\n写入如下内容\n```java\npackage com.demo1.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class Hello {\n    @RequestMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World !!!\";\n    }\n\n}\n```\n\n到 Demo1Application 空白处右键，点击运行\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/8.png)\n\n无误后，访问自己 127.0.0.1/hello 即可\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/9.png)\n\n---\n\n## 通过访问 Spring Initializr 创建\n\n访问 Spring Initializr：https://start.spring.io/\n\n如图所示，几个选项说明：\n\n- Project：使用什么构建工具，Maven 还是 Gradle；\n- Language：使用什么编程语言，Java、Kotlin 还是 Groovy；\n- Spring Boot：选用的 Spring Boot 版本；\n- Project Metadata：项目的元数据；其实就是 Maven 项目的基本元素；\n- Dependencies：选择要加入的 Spring Boot 组件；\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/10.png)\n\n选择 web 组件\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/11.png)\n\n点击 \"Generate\" 按钮生成项目；此时浏览器会下载一个与上面 Artifact 名称一样的压缩包。\n\n解压项目包，并用编译器以 Maven 项目导入，以 IntelliJ IDEA 为例：\n\n菜单中选择：File -> New -> Project from Existing Sources…\n\n选择解压后的项目文件夹，点击 OK\n\n点击：Import project from external model，并选择 Maven，点击 Next 到底为止。\n\n若你的环境有多个版本的 JDK，注意到选择 Java SDK 的时候请选择相应的 java 版本（具体根据你在第一步中选择的 Java 版本为准）\n\n通过上面步骤完成了基础项目的创建。\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/12.png)\n\nSpring Boot 的基础结构共三个文件（具体路径根据用户生成项目时填写的 Group 所有差异）\n- src/main/java 下的程序入口: DemoApplication\n- src/main/resources 下的配置文件: application.properties\n- src/test/ 下的测试入口: DemoApplicationTests\n\n生成的 DemoApplication 和 DemoApplicationTests 类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或 Web 模块，程序会在加载完 Spring 之后结束运行。\n\n项目依赖解析\n\n打开pom.xml，看看Spring Boot项目的依赖：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.6.6</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.example</groupId>\n\t<artifactId>demo</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>demo</name>\n\t<description>Demo project for Spring Boot</description>\n\t<properties>\n\t\t<java.version>11</java.version>\n\t</properties>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n```\n\n如上所示，主要有四个部分：\n- 项目元数据：创建时候输入的 Project Metadata 部分，也就是 Maven 项目的基本元素，包括：groupId、artifactId、version、name、description 等\n- parent：继承 spring-boot-starter-parent 的依赖管理，控制版本与打包等内容\n- dependencies：项目具体依赖，这里包含了 spring-boot-starter-web 用于实现 HTTP 接口（该依赖中包含了 Spring MVC）；spring-boot-starter-test 用于编写单元测试的依赖包。更多功能模块的使用我们将在后面的教程中逐步展开。\n- build：构建配置部分。默认使用了 spring-boot-maven-plugin，配合 spring-boot-starter-parent 就可以把 Spring Boot 应用打包成 JAR 来直接运行。\n\n编写一个 HTTP 接口\n\n创建 package 命名为 com.example.demo.web（根据实际情况修改）\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/创建第一个项目/13.png)\n\n创建 HelloController 类，内容如下：\n\n```java\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String index() {\n        return \"Hello World\";\n    }\n\n}\n```\n\n在 DemoApplication 启动主程序,发起请求：http://localhost:8080/hello ，可以看到页面返回：Hello World\n\n---\n\n## Source & Reference\n\n- https://blog.csdn.net/m0_52559040/article/details/123284034\n- https://blog.didispace.com/spring-boot-learning-21-1-1/", "timestamp": "2025-10-19T19:25:22.164183"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/工程结构.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84.md", "content": "# 工程结构推荐\n\n---\n\nSpring Boot 框架本身并没有对工程结构有特别的要求，但是按照最佳实践的工程结构可以帮助我们减少可能会遇见的坑，尤其是 Spring 包扫描机制的存在，如果您使用最佳实践的工程结构，可以免去不少特殊的配置工作。\n\n## 典型示例\n\n以下结构是比较推荐的 package 组织方式：\n```\ncom\n  +- example\n    +- myproject\n      +- Application.java\n      |\n      +- domain\n      |  +- Customer.java\n      |  +- CustomerRepository.java\n      |\n      +- service\n      |  +- CustomerService.java\n      |\n      +- web\n      |  +- CustomerController.java\n      |\n```\n\n- root package：com.example.myproject，所有的类和其他 package 都在 root package 之下。\n- 应用主类：Application.java，该类直接位于 root package 下。通常我们会在应用主类中做一些框架配置扫描等配置，我们放在 root package 下可以帮助程序减少手工配置来加载到我们希望被 Spring 加载的内容\n- com.example.myproject.domain 包：用于定义实体映射关系与数据访问相关的接口和实现\n- com.example.myproject.service 包：用于编写业务逻辑相关的接口与实现\n- com.example.myproject.web：用于编写 Web 层相关的实现，比如：Spring MVC 的 Controller 等\n\n上面的结构中，root package 与应用主类的位置是整个结构的关键。由于应用主类在 root package 中，所以按照上面的规则定义的所有其他类都处于 root package 下的其他子包之后。默认情况下，Spring Boot 的应用主类会自动扫描 root package 以及所有子包下的所有类来进行初始化。\n\n举个例子，假设我们将 com.example.myproject.web 包与上面所述的 root package：com.example.myproject 放在同一级，像下面这样：\n```\ncom\n  +- example\n    +- myproject\n      +- Application.java\n      |\n      +- domain\n      |  +- Customer.java\n      |  +- CustomerRepository.java\n      |\n      +- service\n      |  +- CustomerService.java\n      |\n    +- web\n    |  +- CustomerController.java\n    |\n```\n\n这个时候，应用主类 Application.java 在默认情况下就无法扫描到 com.example.myproject.web 中的 Controller 定义，就无法初始化 Controller 中定义的接口。\n\n## 非典型结构下的初始化\n\n那么如果，我们一定要加载非 root package 下的内容怎么办呢？\n\n方法一：使用 @ComponentScan 注解指定具体的加载包，比如：\n```java\n@SpringBootApplication\n@ComponentScan(basePackages=\"com.example\")\npublic class Bootstrap {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Bootstrap.class, args);\n    }\n\n}\n```\n\n这种方法通过注解直接指定要扫描的包，比较直观。如果有这样的需求也是可以用的，但是原则上还是推荐以上面的典型结构来定义，这样也可以少写一些注解，代码更加简洁。\n\n方法二：使用 @Bean 注解来初始化，比如：\n```java\n@SpringBootApplication\npublic class Bootstrap {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Bootstrap.class, args);\n    }\n\n    @Bean\n    public CustomerController customerController() {\n        return new CustomerController();\n    }\n\n}\n```\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：工程结构推荐](https://blog.didispace.com/spring-boot-learning-21-1-2/)\n", "timestamp": "2025-10-19T19:25:22.335705"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/性能监控.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7.md", "content": "# 性能监控\n\n---\n\n## Actuator监控\n\n### Actuator 简介\n\n在生产环境中，往往需要对系统实际运行的情况（例如 cpu、io、disk、db、业务功能等指标）进行监控运维。在 SpringBoot 项目中 Actuator 模块提供了众多 HTTP 接口端点（Endpoint），来提供应用程序运行时的内部状态信息。\n\nActuator 模块提供了一个监控和管理生产环境的模块，可以使用 http、jmx、ssh、telnet 等来管理和监控应用。包括应用的审计（Auditing）、健康（health）状态信息、数据采集（metrics gathering）统计等监控运维的功能。同时，提供了可以扩展 Actuator 端点（Endpoint）自定义监控指标。这些指标都是以 JSON 接口数据的方式呈现。\n\n需要注意的是，SpringBoot 1.x 和 2.x 的 Actuator 监控设置差别很大，不仅提供的 endpoint 路径不一樣，连 application.properties 的配置也不一样\n\n---\n\n### 使用 Spring Boot Actuator\n\n如果要使用 Spring Boot Actuator 提供的监控功能，需要先加入相关的 maven dependency依赖\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.3</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n\n<!-- actuator 依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n </dependency>\n\n<!-- WEB 依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n只要加上了这个 maven dependency，SpringBoot在运行时就会自动开启/actuator/health和/actuator/info这两个 endpoint，然后就可以通过这两个 endpoint查看当前 SpringBoot应用程序的运行情况，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等。\n\n为了保证 actuator 暴露的监控接口的安全性，需要添加安全控制的依赖 spring-boot-start-security 依赖，访问应用监控端点时，都需要输入验证信息。\n```xml\n<dependency>\n    <!--Security 依赖 -->\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n如果添加了security安全管理，只需要在配置文件配置用户名和密码就可以了\n```yaml\nspring:\n  security:\n    user:\n      name: admin\n      password: 123456\n```\n\n---\n\n### 开启 Actuator 所有 endpoints\n\n- https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html\n\napplication.properties\n```conf\nmanagement.endpoints.web.exposure.include=*\n```\n\n---\n\n### 配置 jmx 形式的监控\n```conf\nmanagement.endpoints.jmx.exposure.include=*\n```\n\n---\n\n## Prometheus\n\n**添加依赖**\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n  <groupId>io.micrometer</groupId>\n  <artifactId>micrometer-core</artifactId>\n</dependency>\n<dependency>\n  <groupId>io.micrometer</groupId>\n  <artifactId>micrometer-registry-prometheus</artifactId>\n</dependency>\n```\n\n打开 Prometheus 监控接口 application.properties\n```conf\nserver.port=8088\nspring.application.name=springboot2-prometheus\nmanagement.endpoints.web.exposure.include=*\nmanagement.metrics.tags.application=${spring.application.name}\n```\n\n访问 /actuator/prometheus\n\n---\n\n## Source & Reference\n\n- https://blog.51cto.com/u_15287666/3109393\n- https://www.mobaijun.com/posts/283491354.html\n- https://blog.csdn.net/shuofxz/article/details/118213813\n- https://juejin.cn/post/6844904052417904653#heading-29\n", "timestamp": "2025-10-19T19:25:22.535759"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/数据访问.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE.md", "content": "# 数据访问\n\n**什么是JDBC？**\n\nJava 数据库连接（Java Database Connectivity，简称 JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC 也是 Sun Microsystems 的商标。我们通常说的 JDBC 是面向关系型数据库的。\n\nJDBC API 主要位于 JDK 中的 java.sql 包中（之后扩展的内容位于 javax.sql 包中），主要包括（斜体代表接口，需驱动程序提供者来具体实现）：\n- DriverManager：负责加载各种不同驱动程序（Driver），并根据不同的请求，向调用者返回相应的数据库连接（Connection）。\n- Driver：驱动程序，会将自身加载到 DriverManager 中去，并处理相应的请求并返回相应的数据库连接（Connection）。\n- Connection：数据库连接，负责与进行数据库间通讯，SQL 执行以及事务处理都是在某个特定 Connection 环境中进行的。可以产生用以执行 SQL 的 Statement。\n- Statement：用以执行 SQL 查询和更新（针对静态 SQL 语句和单次执行）。PreparedStatement：用以执行包含动态参数的 SQL 查询和更新（在服务器端编译，允许重复执行以提高效率）。\n- CallableStatement：用以调用数据库中的存储过程。\n- SQLException：代表在数据库连接的建立和关闭和 SQL 语句的执行过程中发生了例外情况（即错误）。\n\n**什么是数据源？**\n\n可以看到，在 java.sql 中并没有数据源（Data Source）的概念。这是由于在 java.sql 中包含的是 JDBC 内核 API，另外还有个 javax.sql 包，其中包含了 JDBC 标准的扩展 API。而关于数据源（Data Source）的定义，就在 javax.sql 这个扩展包中。\n\n实际上，在 JDBC 内核 API 的实现下，就已经可以实现对数据库的访问了，那么我们为什么还需要数据源呢？主要出于以下几个目的：\n1. 封装关于数据库访问的各种参数，实现统一管理\n2. 通过对数据库的连接池管理，节省开销并提高效率\n\n---\n\n## JdbcTemplate\n\n**数据源配置**\n\n首先，为了连接数据库需要引入 jdbc 支持，在 pom.xml 中引入如下配置：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n\n**嵌入式数据库支持**\n\n嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot 提供自动配置的嵌入式数据库有 H2、HSQL、Derby，你不需要提供任何连接配置就能使用。\n\n比如，我们可以在 pom.xml 中引入如下配置使用 HSQL\n```xml\n<dependency>\n    <groupId>org.hsqldb</groupId>\n    <artifactId>hsqldb</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\n**连接生产数据源**\n\n以 MySQL 数据库为例，先引入 MySQL 连接的依赖包，在 pom.xml 中加入：\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n在 src/main/resources/application.properties 中配置数据源信息\n```conf\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n注意：因为 Spring Boot 2.1.x 默认使用了 MySQL 8.0 的驱动，所以这里采用 com.mysql.cj.jdbc.Driver，而不是老的 com.mysql.jdbc.Driver.\n\n**连接JNDI数据源**\n\n当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入 JNDI 数据源。\n```\nspring.datasource.jndi-name=java:jboss/datasources/customers\n```\n\n## 使用JdbcTemplate操作数据库\n\nSpring 的 JdbcTemplate 是自动配置的，你可以直接使用 @Autowired 或构造函数（推荐）来注入到你自己的 bean 中来使用。\n\n**准备数据库**\n\n先创建 User 表，包含属性 name、age。可以通过执行下面的建表语句：：\n```sql\nCREATE TABLE `User` (\n  `name` varchar(100) COLLATE utf8mb4_general_ci NOT NULL,\n  `age` int NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci\n```\n\n**编写领域对象**\n\n根据数据库中创建的 User 表，创建领域对象：\n```java\n@Data\n@NoArgsConstructor\npublic class User {\n\n    private String name;\n    private Integer age;\n\n}\n```\n\n这里使用了 Lombok 的 @Data 和 @NoArgsConstructor 注解来自动生成各参数的 Set、Get 函数以及不带参数的构造函数。\n\n**编写数据访问对象**\n\n定义包含有插入、删除、查询的抽象接口 UserService\n```java\npublic interface UserService {\n\n    /**\n     * 新增一个用户\n     *\n     * @param name\n     * @param age\n     */\n    int create(String name, Integer age);\n\n    /**\n     * 根据name查询用户\n     *\n     * @param name\n     * @return\n     */\n    List<User> getByName(String name);\n\n    /**\n     * 根据name删除用户\n     *\n     * @param name\n     */\n    int deleteByName(String name);\n\n    /**\n     * 获取用户总量\n     */\n    int getAllUsers();\n\n    /**\n     * 删除所有用户\n     */\n    int deleteAllUsers();\n\n}\n```\n\n通过 JdbcTemplate 实现 UserService 中定义的数据访问操作\n```java\n@Service\npublic class UserServiceImpl implements UserService {\n\n    private JdbcTemplate jdbcTemplate;\n\n    UserServiceImpl(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public int create(String name, Integer age) {\n        return jdbcTemplate.update(\"insert into USER(NAME, AGE) values(?, ?)\", name, age);\n    }\n\n    @Override\n    public List<User> getByName(String name) {\n        List<User> users = jdbcTemplate.query(\"select NAME, AGE from USER where NAME = ?\", (resultSet, i) -> {\n            User user = new User();\n            user.setName(resultSet.getString(\"NAME\"));\n            user.setAge(resultSet.getInt(\"AGE\"));\n            return user;\n        }, name);\n        return users;\n    }\n\n    @Override\n    public int deleteByName(String name) {\n        return jdbcTemplate.update(\"delete from USER where NAME = ?\", name);\n    }\n\n    @Override\n    public int getAllUsers() {\n        return jdbcTemplate.queryForObject(\"select count(1) from USER\", Integer.class);\n    }\n\n    @Override\n    public int deleteAllUsers() {\n        return jdbcTemplate.update(\"delete from USER\");\n    }\n\n}\n```\n\n---\n\n## Hikari\n\n由于 Spring Boot 的自动化配置机制，大部分对于数据源的配置都可以通过配置参数的方式去改变。只有一些特殊情况，比如：更换默认数据源，多数据源共存等情况才需要去修改覆盖初始化的 Bean 内容。\n\n在 Spring Boot 自动化配置中，对于数据源的配置可以分为两类：\n\n通用配置：以 `spring.datasource.*` 的形式存在，主要是对一些即使使用不同数据源也都需要配置的一些常规内容。比如：数据库链接地址、用户名、密码等。这里就不做过多说明了，通常就这些配置：\n```conf\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n```\n数据源连接池配置：以 `spring.datasource.<数据源名称>.*` 的形式存在，比如：Hikari 的配置参数就是 `spring.datasource.hikari.*` 形式。下面这个是我们最常用的几个配置项及对应说明：\n```conf\nspring.datasource.hikari.minimum-idle=10\nspring.datasource.hikari.maximum-pool-size=20\nspring.datasource.hikari.idle-timeout=500000\nspring.datasource.hikari.max-lifetime=540000\nspring.datasource.hikari.connection-timeout=60000\nspring.datasource.hikari.connection-test-query=SELECT 1\n```\n\n这些配置的含义：\n- spring.datasource.hikari.minimum-idle: 最小空闲连接，默认值 10，小于 0 或大于 maximum-pool-size，都会重置为 maximum-pool-size\n- spring.datasource.hikari.maximum-pool-size: 最大连接数，小于等于 0 会被重置为默认值 10；大于零小于 1 会被重置为 minimum-idle 的值\n- spring.datasource.hikari.idle-timeout: 空闲连接超时时间，默认值 600000（10 分钟），大于等于 max-lifetime 且 max-lifetime>0，会被重置为 0；不等于 0 且小于 10 秒，会被重置为 10 秒。\n- spring.datasource.hikari.max-lifetime: 连接最大存活时间，不等于 0 且小于 30 秒，会被重置为默认值 30 分钟. 设置应该比 mysql 设置的超时时间短\n- spring.datasource.hikari.connection-timeout: 连接超时时间：毫秒，小于 250 毫秒，否则被重置为默认值 30 秒\n- spring.datasource.hikari.connection-test-query: 用于测试连接是否可用的查询语句\n\n---\n\n## Druid\n\n**配置 Druid 数据源**\n\n在 pom.xml 中引入 druid 官方提供的 Spring Boot Starter 封装。\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.21</version>\n</dependency>\n```\n\n在 application.properties 中配置数据库连接信息。\n\nDruid 的配置都以 spring.datasource.druid 作为前缀，所以根据之前的配置，稍作修改即可：\n```conf\nspring.datasource.druid.url=jdbc:mysql://localhost:3306/test\nspring.datasource.druid.username=root\nspring.datasource.druid.password=\nspring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n配置 Druid 的连接池\n\n与 Hikari 一样，要用好一个数据源，就要对其连接池做好相应的配置，比如下面这样：\n```conf\nspring.datasource.druid.initialSize=10\nspring.datasource.druid.maxActive=20\nspring.datasource.druid.maxWait=60000\nspring.datasource.druid.minIdle=1\nspring.datasource.druid.timeBetweenEvictionRunsMillis=60000\nspring.datasource.druid.minEvictableIdleTimeMillis=300000\nspring.datasource.druid.testWhileIdle=true\nspring.datasource.druid.testOnBorrow=true\nspring.datasource.druid.testOnReturn=false\nspring.datasource.druid.poolPreparedStatements=true\nspring.datasource.druid.maxOpenPreparedStatements=20\nspring.datasource.druid.validationQuery=SELECT 1\nspring.datasource.druid.validation-query-timeout=500\nspring.datasource.druid.filters=stat\n```\n\n**Druid监控**\n\n在 pom.xml 中引入 spring-boot-starter-actuator 模块\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n在 application.properties 中添加 Druid 的监控配置\n```conf\nspring.datasource.druid.stat-view-servlet.enabled=true\nspring.datasource.druid.stat-view-servlet.url-pattern=/druid/*\nspring.datasource.druid.stat-view-servlet.reset-enable=true\nspring.datasource.druid.stat-view-servlet.login-username=admin\nspring.datasource.druid.stat-view-servlet.login-password=admin\n```\n\n上面的配置主要用于开启 stat 监控统计的界面以及监控内容的相关配置，具体释意如下：\n- spring.datasource.druid.stat-view-servlet.url-pattern：访问地址规则\n- spring.datasource.druid.stat-view-servlet.reset-enable：是否允许清空统计数据\n- spring.datasource.druid.stat-view-servlet.login-username：监控页面的登录账户\n- spring.datasource.druid.stat-view-servlet.login-password：监控页面的登录密码\n\n针对之前实现的 UserService 内容，我们创建一个 Controller 来通过接口去调用数据访问操作：\n```java\n@Data\n@AllArgsConstructor\n@RestController\npublic class UserController {\n\n    private UserService userService;\n\n    @PostMapping(\"/user\")\n    public int create(@RequestBody User user) {\n        return userService.create(user.getName(), user.getAge());\n    }\n\n    @GetMapping(\"/user/{name}\")\n    public List<User> getByName(@PathVariable String name) {\n        return userService.getByName(name);\n    }\n\n    @DeleteMapping(\"/user/{name}\")\n    public int deleteByName(@PathVariable String name) {\n        return userService.deleteByName(name);\n    }\n\n    @GetMapping(\"/user/count\")\n    public int getAllUsers() {\n        return userService.getAllUsers();\n    }\n\n    @DeleteMapping(\"/user/all\")\n    public int deleteAllUsers() {\n        return userService.deleteAllUsers();\n    }\n\n}\n```\n\n完成上面所有配置之后，启动应用，访问 Druid 的监控页面 http://localhost:8080/druid/，可以看到登录页面\n\n- Sorry, you are not permitted to view this page.\n\n    deny优先于allow，如果在deny列表中，就算在allow列表中，也会被拒绝。如果allow没有配置或者为空，则允许所有访问\n    ```conf\n    spring.datasource.druid.stat-view-servlet.allow=\n    ```\n\n---\n\n## Spring Data JPA\n\n在实际开发过程中，对数据库的操作大多可以归结为：“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句几乎都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。\n\n为了解决这些大量枯燥的数据操作语句，诞生了非常多的优秀框架，比如：Hibernate。通过整合Hibernate，我们能够以操作Java实体的方式来完成对数据的操作，通过框架的帮助，对Java实体的变更最终将自动地映射到数据库表中。\n\n在Hibernate的帮助下，Java实体映射到数据库表数据完成之后，再进一步解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。\n\n由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring Data JPA的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子：\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findByName(String name);\n\n    @Query(\"from User u where u.name=:name\")\n    User findUser(@Param(\"name\") String name);\n\n}\n```\n\n在 pom.xml 中添加相关依赖，加入以下内容：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n```\n\n在 application.xml 中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用 mysql 的情况如下：\n```conf\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.jpa.properties.hibernate.hbm2ddl.auto=create-drop\n```\n\nspring.jpa.properties.hibernate.hbm2ddl.auto 是 hibernate 的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：\n- create：每次加载 hibernate 时都会删除上一次的生成的表，然后根据你的 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。\n- create-drop：每次加载 hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭, 表就自动删除。\n- update：最常用的属性，第一次加载 hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 hibernate 时根据 model 类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n- validate：每次加载 hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\n\n**创建实体**\n\n创建一个 User 实体，包含 id（主键）、name（姓名）、age（年龄）属性，通过 ORM 框架其会被映射到数据库表中，由于配置了 hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。\n```java\n@Entity\n@Data\n@NoArgsConstructor\npublic class User {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String name;\n    private Integer age;\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n- @Entity 注解标识了 User 类是一个持久化的实体\n- @Data 和 @NoArgsConstructor 是 Lombok 中的注解。用来自动生成各参数的 Set、Get 函数以及不带参数的构造函数。\n- @Id 和 @GeneratedValue 用来标识 User 对应对应数据库表中的主键\n\n**创建数据访问接口**\n\n下面针对 User 实体创建对应的 Repository 接口实现对该实体的数据访问，如下代码：\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    User findByName(String name);\n\n    User findByNameAndAge(String name, Integer age);\n\n    @Query(\"from User u where u.name=:name\")\n    User findUser(@Param(\"name\") String name);\n\n}\n```\n\n在 Spring Data JPA 中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。\n\n下面对上面的 UserRepository 做一些解释，该接口继承自 JpaRepository，通过查看 JpaRepository 接口的 API 文档，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。\n\n在我们实际开发中，JpaRepository 接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。\n\n在上例中，我们可以看到下面两个函数：\n- User findByName(String name)\n- User findByNameAndAge(String name, Integer age)\n它们分别实现了按 name 查询 User 实体和按 name 和 age 查询 User 实体，可以看到我们这里没有任何类 SQL 语句就完成了两个条件查询方法。这就是 Spring-data-jpa 的一大特性：通过解析方法名创建查询。\n\n除了通过解析方法名来创建查询外，它也提供通过使用 @Query 注解来创建查询，您只需要编写 JPQL 语句，并通过类似 “:name” 来映射 @Param 指定的参数，就像例子中的第三个 findUser 函数一样。\n\n**单元测试**\n\n在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    public void test() throws Exception {\n\n        // 创建10条记录\n        userRepository.save(new User(\"AAA\", 10));\n        userRepository.save(new User(\"BBB\", 20));\n        userRepository.save(new User(\"CCC\", 30));\n        userRepository.save(new User(\"DDD\", 40));\n        userRepository.save(new User(\"EEE\", 50));\n        userRepository.save(new User(\"FFF\", 60));\n        userRepository.save(new User(\"GGG\", 70));\n        userRepository.save(new User(\"HHH\", 80));\n        userRepository.save(new User(\"III\", 90));\n        userRepository.save(new User(\"JJJ\", 100));\n\n        // 测试findAll, 查询所有记录\n        Assert.assertEquals(10, userRepository.findAll().size());\n\n        // 测试findByName, 查询姓名为FFF的User\n        Assert.assertEquals(60, userRepository.findByName(\"FFF\").getAge().longValue());\n\n        // 测试findUser, 查询姓名为FFF的User\n        Assert.assertEquals(60, userRepository.findUser(\"FFF\").getAge().longValue());\n\n        // 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User\n        Assert.assertEquals(\"FFF\", userRepository.findByNameAndAge(\"FFF\", 60).getName());\n\n        // 测试删除姓名为AAA的User\n        userRepository.delete(userRepository.findByName(\"AAA\"));\n\n        // 测试findAll, 查询所有记录, 验证上面的删除是否成功\n        Assert.assertEquals(9, userRepository.findAll().size());\n\n    }\n}\n```\n\n---\n\n## MyBatis\n\n新建 Spring Boot 项目，在 pom.xml 中引入 MyBatis 的 Starter 以及 MySQL Connector 依赖，具体如下：\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.1</version>\n</dependency>\n\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n关于 mybatis-spring-boot-starter 的版本需要注意：\n- 2.1.x 版本适用于：MyBatis 3.5+、Java 8+、Spring Boot 2.1+\n- 2.0.x 版本适用于：MyBatis 3.5+、Java 8+、Spring Boot 2.0/2.1\n- 1.3.x 版本适用于：MyBatis 3.4+、Java 6+、Spring Boot 1.5\n其中，目前还在维护的是 2.1.x 版本和 1.3.x 版本。\n\n同之前介绍的使用 jdbc 模块和 jpa 模块连接数据库一样，在 application.properties 中配置 mysql 的连接配置\n```conf\nspring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n也可以不用默认数据源，使用 Druid 作为数据库连接池\n\nMysql 中创建一张用来测试的表，比如：User 表，其中包含 id(BIGINT)、age(INT)、name(VARCHAR) 字段。\n```sql\nCREATE TABLE `USER` (\n  `id` bigint NOT NULL AUTO_INCREMENT,\n  `name` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL,\n  `age` int DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci\n```\n\n创建 User 表的映射对象 User：\n```java\n@Data\n@NoArgsConstructor\npublic class User {\n\n    private Long id;\n\n    private String name;\n    private Integer age;\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n创建 User 表的操作接口：UserMapper。在接口中定义两个数据操作，一个插入，一个查询，用于后续单元测试验证。\n```java\n@Mapper\npublic interface UserMapper {\n\n    @Select(\"SELECT * FROM USER WHERE NAME = #{name}\")\n    User findByName(@Param(\"name\") String name);\n\n    @Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\")\n    int insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n\n}\n```\n\n创建 Spring Boot 主类\n```java\n@SpringBootApplication\npublic class Chapter35Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Chapter35Application.class, args);\n\t}\n\n}\n```\n\n创建单元测试\n\n插入一条 name=AAA，age=20 的记录，然后根据 name=AAA 查询，并判断 age 是否为 20\n\n测试结束回滚数据，保证测试单元每次运行的数据环境独立\n```java\n@Slf4j\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Chapter35ApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    @Rollback\n    public void test() throws Exception {\n        userMapper.insert(\"AAA\", 20);\n        User u = userMapper.findByName(\"AAA\");\n        Assert.assertEquals(20, u.getAge().intValue());\n    }\n\n}\n```\n\n**使用@Param**\n\n在之前的整合示例中我们已经使用了这种最简单的传参方式，如下：\n```java\n@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\")\nint insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n```\n这种方式很好理解，`@Param` 中定义的 `name` 对应了 SQL 中的 `#{name}`，`age` 对应了 SQL 中的 `#{age}`。\n\n**使用Map**\n\n如下代码，通过 `Map<String, Object>` 对象来作为传递参数的容器：\n```java\n@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER})\")\nint insertByMap(Map<String, Object> map);\n```\n\n对于 Insert 语句中需要的参数，我们只需要在 map 中填入同名的内容即可，具体如下面代码所示：\n```java\nMap<String, Object> map = new HashMap<>();\nmap.put(\"name\", \"CCC\");\nmap.put(\"age\", 40);\nuserMapper.insertByMap(map);\n```\n\n**使用对象**\n\n除了 Map 对象，我们也可直接使用普通的 Java 对象来作为查询条件的传参，比如我们可以直接使用 User 对象:\n```java\n@Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\")\nint insertByUser(User user);\n```\n\n这样语句中的 `#{name}`、`#{age}` 就分别对应了 User 对象中的 name 和 age 属性。\n\n**增删改查**\n\nMyBatis 针对不同的数据库操作分别提供了不同的注解来进行配置，在之前的示例中演示了 `@Insert`，下面针对 User 表做一组最基本的增删改查作为示例：\n\n```java\npublic interface UserMapper {\n\n    @Select(\"SELECT * FROM USER WHERE name = #{name}\")\n    User findByName(@Param(\"name\") String name);\n\n    @Insert(\"INSERT INTO USER(name, age) VALUES(#{name}, #{age})\")\n    int insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n\n    @Update(\"UPDATE USER SET age=#{age} WHERE name=#{name}\")\n    void update(User user);\n\n    @Delete(\"DELETE FROM USER WHERE id =#{id}\")\n    void delete(Long id);\n}\n```\n\n在完成了一套增删改查后，不妨我们试试下面的单元测试来验证上面操作的正确性：\n```java\n@Transactional\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserMapper userMapper;\n\n\t@Test\n\t@Rollback\n\tpublic void testUserMapper() throws Exception {\n\t\t// insert一条数据，并select出来验证\n\t\tuserMapper.insert(\"AAA\", 20);\n\t\tUser u = userMapper.findByName(\"AAA\");\n\t\tAssert.assertEquals(20, u.getAge().intValue());\n\t\t// update一条数据，并select出来验证\n\t\tu.setAge(30);\n\t\tuserMapper.update(u);\n\t\tu = userMapper.findByName(\"AAA\");\n\t\tAssert.assertEquals(30, u.getAge().intValue());\n\t\t// 删除这条数据，并select验证\n\t\tuserMapper.delete(u.getId());\n\t\tu = userMapper.findByName(\"AAA\");\n\t\tAssert.assertEquals(null, u);\n\t}\n}\n```\n\n**返回结果绑定**\n\n对于增、删、改操作相对变化较小。而对于 “查” 操作，我们往往需要进行多表关联，汇总计算等操作，那么对于查询的结果往往就不再是简单的实体对象了，往往需要返回一个与数据库实体不同的包装类，那么对于这类情况，就可以通过 `@Results` 和 `@Result` 注解来进行绑定，具体如下：\n```java\n@Results({\n    @Result(property = \"name\", column = \"name\"),\n    @Result(property = \"age\", column = \"age\")\n})\n@Select(\"SELECT name, age FROM user\")\nList<User> findAll();\n```\n\n在上面代码中，`@Result` 中的 `property` 属性对应 User 对象中的成员名，column 对应 SELECT 出的字段名。在该配置中故意没有查出 id 属性，只对 User 对应中的 name 和 age 对象做了映射配置，这样可以通过下面的单元测试来验证查出的 id 为 `null`，而其他属性不为 `null`：\n```java\n@Test\n@Rollback\npublic void testUserMapper() throws Exception {\n\tList<User> userList = userMapper.findAll();\n\tfor(User user : userList) {\n\t\tAssert.assertEquals(null, user.getId());\n\t\tAssert.assertNotEquals(null, user.getName());\n\t}\n}\n```\n\n---\n\n## 使用MyBatis的XML配置方式\n\n在应用主类中增加mapper的扫描包配置\n```java\n@MapperScan(\"com.didispace.chapter36.mapper\")\n@SpringBootApplication\npublic class Chapter36Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Chapter36Application.class, args);\n\t}\n\n}\n```\n\n在第一步中指定的Mapper包下创建User表的Mapper定义\n```java\npublic interface UserMapper {\n\n    User findByName(@Param(\"name\") String name);\n\n    int insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n\n}\n```\n\n在配置文件中通过mybatis.mapper-locations参数指定xml配置的位置：\n```conf\nmybatis.mapper-locations=classpath:mapper/*.xml\n```\n\n在第三步中指定的xml配置目录下创建User表的mapper配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.didispace.chapter36.mapper.UserMapper\">\n    <select id=\"findByName\" resultType=\"com.didispace.chapter36.entity.User\">\n        SELECT * FROM USER WHERE NAME = #{name}\n    </select>\n\n    <insert id=\"insert\">\n        INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\n    </insert>\n</mapper>\n```\n\n到这里从注解方式的MyBatis使用方式就改为了XML的配置方式了，为了验证是否运行正常，可以通过下面的单元测试来尝试对数据库的写和读操作：\n```java\n@Slf4j\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@Transactional\npublic class Chapter36ApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    @Rollback\n    public void test() throws Exception {\n        userMapper.insert(\"AAA\", 20);\n        User u = userMapper.findByName(\"AAA\");\n        Assert.assertEquals(20, u.getAge().intValue());\n    }\n\n}\n```\n\n---\n\n## MyBatis的多数据源配置\n\n**添加多数据源的配置**\n\n先在Spring Boot的配置文件application.properties中设置两个你要链接的数据库配置，比如这样：\n```conf\nspring.datasource.primary.jdbc-url=jdbc:mysql://localhost:3306/test1\nspring.datasource.primary.username=root\nspring.datasource.primary.password=123456\nspring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.datasource.secondary.jdbc-url=jdbc:mysql://localhost:3306/test2\nspring.datasource.secondary.username=root\nspring.datasource.secondary.password=123456\nspring.datasource.secondary.driver-class-name=com.mysql.cj.jdbc.Driver\n```\n\n多数据源配置的时候，与单数据源不同点在于spring.datasource之后多设置一个数据源名称primary和secondary来区分不同的数据源配置，这个前缀将在后续初始化数据源的时候用到。\n\n数据源连接配置2.x和1.x的配置项是有区别的：2.x使用spring.datasource.secondary.jdbc-url，而1.x版本使用spring.datasource.secondary.url。如果你在配置的时候发生了这个报错java.lang.IllegalArgumentException: jdbcUrl is required with driverClassName.，那么就是这个配置项的问题。\n\n可以看到，不论使用哪一种数据访问框架，对于数据源的配置都是一样的。\n\n**初始化数据源与MyBatis配置**\n\n完成多数据源的配置信息之后，就来创建个配置类来加载这些配置信息，初始化数据源，以及初始化每个数据源要用的MyBatis配置。\n\n单独建一个多数据源的配置类\n```java\n@Configuration\npublic class DataSourceConfiguration {\n\n    @Primary\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.primary\")\n    public DataSource primaryDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.secondary\")\n    public DataSource secondaryDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n}\n```\n\n可以看到内容跟JdbcTemplate、Spring Data JPA的时候是一模一样的。通过 `@ConfigurationProperties` 可以知道这两个数据源分别加载了 `spring.datasource.primary.*` 和 `spring.datasource.secondary.*` 的配置。@Primary注解指定了主数据源，就是当我们不特别指定哪个数据源的时候，就会使用这个Bean真正差异部分在下面的JPA配置上。\n\n分别创建两个数据源的MyBatis配置。\n\nPrimary数据源的JPA配置：\n```java\n@Configuration\n@MapperScan(\n        basePackages = \"com.didispace.chapter39.p\",\n        sqlSessionFactoryRef = \"sqlSessionFactoryPrimary\",\n        sqlSessionTemplateRef = \"sqlSessionTemplatePrimary\")\npublic class PrimaryConfig {\n\n    private DataSource primaryDataSource;\n\n    public PrimaryConfig(@Qualifier(\"primaryDataSource\") DataSource primaryDataSource) {\n        this.primaryDataSource = primaryDataSource;\n    }\n\n    @Bean\n    public SqlSessionFactory sqlSessionFactoryPrimary() throws Exception {\n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n        bean.setDataSource(primaryDataSource);\n        return bean.getObject();\n    }\n\n    @Bean\n    public SqlSessionTemplate sqlSessionTemplatePrimary() throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactoryPrimary());\n    }\n\n}\n```\n\nSecondary数据源的JPA配置：\n```java\n@Configuration\n@MapperScan(\n        basePackages = \"com.didispace.chapter39.s\",\n        sqlSessionFactoryRef = \"sqlSessionFactorySecondary\",\n        sqlSessionTemplateRef = \"sqlSessionTemplateSecondary\")\npublic class SecondaryConfig {\n\n    private DataSource secondaryDataSource;\n\n    public SecondaryConfig(@Qualifier(\"secondaryDataSource\") DataSource secondaryDataSource) {\n        this.secondaryDataSource = secondaryDataSource;\n    }\n\n    @Bean\n    public SqlSessionFactory sqlSessionFactorySecondary() throws Exception {\n        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n        bean.setDataSource(secondaryDataSource);\n        return bean.getObject();\n    }\n\n    @Bean\n    public SqlSessionTemplate sqlSessionTemplateSecondary() throws Exception {\n        return new SqlSessionTemplate(sqlSessionFactorySecondary());\n    }\n\n}\n```\n\n配置类上使用@MapperScan注解来指定当前数据源下定义的Entity和Mapper的包路径；另外需要指定sqlSessionFactory和sqlSessionTemplate，这两个具体实现在该配置类中类中初始化。\n\n配置类的构造函数中，通过@Qualifier注解来指定具体要用哪个数据源，其名字对应在DataSourceConfiguration配置类中的数据源定义的函数名。\n\n配置类中定义SqlSessionFactory和SqlSessionTemplate的实现，注意具体使用的数据源正确。\n\n根据上面Primary数据源的定义，在com.didispace.chapter39.p包下，定义Primary数据源要用的实体和数据访问对象，比如下面这样：\n```java\n@Data\n@NoArgsConstructor\npublic class UserPrimary {\n\n    private Long id;\n\n    private String name;\n    private Integer age;\n\n    public UserPrimary(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\npublic interface UserMapperPrimary {\n\n    @Select(\"SELECT * FROM USER WHERE NAME = #{name}\")\n    UserPrimary findByName(@Param(\"name\") String name);\n\n    @Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\")\n    int insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n\n    @Delete(\"DELETE FROM USER\")\n    int deleteAll();\n\n}\n```\n\n根据上面Secondary数据源的定义，在com.didispace.chapter39.s包下，定义Secondary数据源要用的实体和数据访问对象，比如下面这样：\n```java\n@Data\n@NoArgsConstructor\npublic class UserSecondary {\n\n    private Long id;\n\n    private String name;\n    private Integer age;\n\n    public UserSecondary(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\npublic interface UserMapperSecondary {\n\n    @Select(\"SELECT * FROM USER WHERE NAME = #{name}\")\n    UserSecondary findByName(@Param(\"name\") String name);\n\n    @Insert(\"INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})\")\n    int insert(@Param(\"name\") String name, @Param(\"age\") Integer age);\n\n    @Delete(\"DELETE FROM USER\")\n    int deleteAll();\n}\n```\n\n测试验证\n```java\n@Slf4j\n@RunWith(SpringRunner.class)\n@SpringBootTest\n@Transactional\npublic class Chapter39ApplicationTests {\n\n    @Autowired\n    private UserMapperPrimary userMapperPrimary;\n    @Autowired\n    private UserMapperSecondary userMapperSecondary;\n\n    @Before\n    public void setUp() {\n        // 清空测试表，保证每次结果一样\n        userMapperPrimary.deleteAll();\n        userMapperSecondary.deleteAll();\n    }\n\n    @Test\n    public void test() throws Exception {\n        // 往Primary数据源插入一条数据\n        userMapperPrimary.insert(\"AAA\", 20);\n\n        // 从Primary数据源查询刚才插入的数据，配置正确就可以查询到\n        UserPrimary userPrimary = userMapperPrimary.findByName(\"AAA\");\n        Assert.assertEquals(20, userPrimary.getAge().intValue());\n\n        // 从Secondary数据源查询刚才插入的数据，配置正确应该是查询不到的\n        UserSecondary userSecondary = userMapperSecondary.findByName(\"AAA\");\n        Assert.assertNull(userSecondary);\n\n        // 往Secondary数据源插入一条数据\n        userMapperSecondary.insert(\"BBB\", 20);\n\n        // 从Primary数据源查询刚才插入的数据，配置正确应该是查询不到的\n        userPrimary = userMapperPrimary.findByName(\"BBB\");\n        Assert.assertNull(userPrimary);\n\n        // 从Secondary数据源查询刚才插入的数据，配置正确就可以查询到\n        userSecondary = userMapperSecondary.findByName(\"BBB\");\n        Assert.assertEquals(20, userSecondary.getAge().intValue());\n    }\n\n}\n```\n\n---\n\n## PostgreSQL\n\n在pom.xml中引入访问PostgreSQL需要的两个重要依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.postgresql</groupId>\n    <artifactId>postgresql</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n\n这里postgresql是必须的，spring-boot-starter-data-jpa的还可以替换成其他的数据访问封装框架，比如：MyBatis等，具体根据你使用习惯来替换依赖即可。\n\n在配置文件中为PostgreSQL数据库配置数据源、以及JPA的必要配置。\n```conf\nspring.datasource.url=jdbc:postgresql://localhost:5432/test\nspring.datasource.username=postgres\nspring.datasource.password=123456\nspring.datasource.driver-class-name=org.postgresql.Driver\n\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\nspring.jpa.properties.hibernate.hbm2ddl.auto=create\n```\n\n创建用户信息实体，映射user_info表\n```java\n@Entity\n@Data\n@NoArgsConstructor\npublic class UserInfo {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String name;\n    private Integer age;\n\n    public UserInfo(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n创建用户信息实体的增删改查\n```java\npublic interface UserInfoRepository extends JpaRepository<UserInfo, Long> {\n\n    UserInfo findByName(String name);\n\n    UserInfo findByNameAndAge(String name, Integer age);\n\n    @Query(\"from UserInfo u where u.name=:name\")\n    UserInfo findUser(@Param(\"name\") String name);\n\n}\n```\n\n创建单元测试，尝试一下增删改查操作。\n```java\n@Slf4j\n@SpringBootTest\npublic class ApplicationTests {\n\n    @Autowired\n    private UserInfoRepository userRepository;\n\n    @Test\n    public void test() throws Exception {\n        // 创建10条记录\n        userRepository.save(new UserInfo(\"AAA\", 10));\n        userRepository.save(new UserInfo(\"BBB\", 20));\n        userRepository.save(new UserInfo(\"CCC\", 30));\n        userRepository.save(new UserInfo(\"DDD\", 40));\n        userRepository.save(new UserInfo(\"EEE\", 50));\n        userRepository.save(new UserInfo(\"FFF\", 60));\n        userRepository.save(new UserInfo(\"GGG\", 70));\n        userRepository.save(new UserInfo(\"HHH\", 80));\n        userRepository.save(new UserInfo(\"III\", 90));\n        userRepository.save(new UserInfo(\"JJJ\", 100));\n\n        // 测试findAll, 查询所有记录\n        Assertions.assertEquals(10, userRepository.findAll().size());\n\n        // 测试findByName, 查询姓名为FFF的User\n        Assertions.assertEquals(60, userRepository.findByName(\"FFF\").getAge().longValue());\n\n        // 测试findUser, 查询姓名为FFF的User\n        Assertions.assertEquals(60, userRepository.findUser(\"FFF\").getAge().longValue());\n\n        // 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User\n        Assertions.assertEquals(\"FFF\", userRepository.findByNameAndAge(\"FFF\", 60).getName());\n\n        // 测试删除姓名为AAA的User\n        userRepository.delete(userRepository.findByName(\"AAA\"));\n\n        // 测试findAll, 查询所有记录, 验证上面的删除是否成功\n        Assertions.assertEquals(9, userRepository.findAll().size());\n\n    }\n\n}\n```\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：使用JdbcTemplate访问MySQL数据库](https://blog.didispace.com/spring-boot-learning-21-3-1/)\n- [Spring Boot 2.x基础教程：默认数据源Hikari的配置详解](https://blog.didispace.com/spring-boot-learning-21-3-2/)\n- [Spring Boot 2.x基础教程：使用国产数据库连接池Druid](https://blog.didispace.com/spring-boot-learning-21-3-3/)\n- [Spring Boot 2.x基础教程：使用Spring Data JPA访问MySQL](https://blog.didispace.com/spring-boot-learning-21-3-4/)\n- [Spring Boot 2.x基础教程：使用MyBatis访问MySQL](https://blog.didispace.com/spring-boot-learning-21-3-5/)\n- [Spring Boot 2.x基础教程：使用MyBatis的XML配置方式](https://blog.didispace.com/spring-boot-learning-21-3-6/)\n- [Spring Boot 2.x基础教程：使用PostgreSQL数据库](https://blog.didispace.com/spring-boot-learning-2-6-4/)\n- [Spring Boot 2.x基础教程：MyBatis的多数据源配置](https://blog.didispace.com/spring-boot-learning-21-3-9/)\n", "timestamp": "2025-10-19T19:25:22.719143"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/日志管理.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86.md", "content": "# 日志管理\n\n---\n\n## Log4j2\n\n在 pom.xml 中引入 Log4j2 的 Starter 依赖 spring-boot-starter-log4j2 ，同时排除默认引入的 spring-boot-starter-logging，比如下面这样：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n    <exclusions>\n        <exclusion>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```\n\n在配置文件 application.properties 中，通过 logging.config 配置指定 log4j2 的配置文件位置，比如下面这样：\n```conf\nlogging.config=classpath:log4j2.xml\n```\n\n在 resource 目录下新建 log4j2.xml（这里不绝对，根据第二步中配置的内容来创建），然后加入 log4j2 的日志配置，比如，下面这样：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration status=\"INFO\">\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n        </Console>\n    </Appenders>\n    <Loggers>\n        <Root level=\"INFO\">\n            <AppenderRef ref=\"Console\"/>\n        </Root>\n    </Loggers>\n</Configuration>\n```\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：使用Log4j2记录日志](https://blog.didispace.com/spring-boot-learning-2-8-2/)\n", "timestamp": "2025-10-19T19:25:22.910530"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/权限管控.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E6%9D%83%E9%99%90%E7%AE%A1%E6%8E%A7.md", "content": "# 权限管控\n\n---\n\n## Spring Security\n\n\n\n\n\n---\n\n## Apache Shiro\n\n### 原生的整合\n\n创建一个 Spring Boot 项目，加入 Shiro 相关的依赖，完整的 pom.xml 文件中的依赖如下：\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-web</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n</dependencies>\n```\n\n**创建 Realm**\n\n接下来我们来自定义核心组件 Realm：\n```java\npublic class MyRealm extends AuthorizingRealm {\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        return null;\n    }\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String username = (String) token.getPrincipal();\n        if (!\"test\".equals(username)) {\n            throw new UnknownAccountException(\"账户不存在!\");\n        }\n        return new SimpleAuthenticationInfo(username, \"123456\", getName());\n    }\n}\n```\n在 Realm 中实现简单的认证操作即可，不做授权\n\n**配置 Shiro**\n\n接下来进行 Shiro 的配置：\n```java\n@Configuration\npublic class ShiroConfig {\n    @Bean\n    MyRealm myRealm() {\n        return new MyRealm();\n    }\n\n    @Bean\n    SecurityManager securityManager() {\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\n        manager.setRealm(myRealm());\n        return manager;\n    }\n\n    @Bean\n    ShiroFilterFactoryBean shiroFilterFactoryBean() {\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n        bean.setSecurityManager(securityManager());\n        bean.setLoginUrl(\"/login\");\n        bean.setSuccessUrl(\"/index\");\n        bean.setUnauthorizedUrl(\"/unauthorizedurl\");\n        Map<String, String> map = new LinkedHashMap<>();\n        map.put(\"/doLogin\", \"anon\");\n        map.put(\"/**\", \"authc\");\n        bean.setFilterChainDefinitionMap(map);\n        return bean;\n    }\n}\n```\n\n在这里进行 Shiro 的配置主要配置 3 个 Bean ：\n1. 首先需要提供一个 Realm 的实例。\n2. 需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm。\n3. 配置一个 ShiroFilterFactoryBean ，在 ShiroFilterFactoryBean 中指定路径拦截规则等。\n4. 配置登录和测试接口。\n\n其中，ShiroFilterFactoryBean 的配置稍微多一些，配置含义如下：\n- setSecurityManager 表示指定 SecurityManager。\n- setLoginUrl 表示指定登录页面。\n- setSuccessUrl 表示指定登录成功页面。\n- 接下来的 Map 中配置了路径拦截规则，注意，要有序。\n\n这些东西都配置完成后，接下来配置登录 Controller:\n```java\n@RestController\npublic class LoginController {\n    @PostMapping(\"/doLogin\")\n    public void doLogin(String username, String password) {\n        Subject subject = SecurityUtils.getSubject();\n        try {\n            subject.login(new UsernamePasswordToken(username, password));\n            System.out.println(\"登录成功!\");\n        } catch (AuthenticationException e) {\n            e.printStackTrace();\n            System.out.println(\"登录失败!\");\n        }\n    }\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"hello\";\n    }\n    @GetMapping(\"/login\")\n    public String  login() {\n        return \"please login!\";\n    }\n}\n```\n\n测试时，首先访问 /hello 接口，由于未登录，所以会自动跳转到 /login 接口\n\n然后调用 /doLogin 接口完成登录\n\n### 使用 Shiro Starter\n\n上面这种配置方式实际上相当于把 SSM 中的 XML 配置拿到 Spring Boot 中用 Java 代码重新写了一遍，除了这种方式之外，我们也可以直接使用 Shiro 官方提供的 Starter 。\n\n创建成功后，添加 shiro-spring-boot-web-starter ，这个依赖可以代替之前的 shiro-web 和 shiro-spring 两个依赖，pom.xml 文件如下：\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring-boot-web-starter</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n</dependencies>\n```\n\n**创建 Realm**\n\n这里的 Realm 和前面的一样，不再赘述。\n\n**配置 Shiro 基本信息**\n\n接下来在 application.properties 中配置 Shiro 的基本信息：\n```conf\nshiro.sessionManager.sessionIdCookieEnabled=true\nshiro.sessionManager.sessionIdUrlRewritingEnabled=true\nshiro.unauthorizedUrl=/unauthorizedurl\nshiro.web.enabled=true\nshiro.successUrl=/index\nshiro.loginUrl=/login\n```\n\n配置解释：\n1. 第一行表示是否允许将sessionId 放到 cookie 中\n2. 第二行表示是否允许将 sessionId 放到 Url 地址拦中\n3. 第三行表示访问未获授权的页面时，默认的跳转路径\n4. 第四行表示开启 shiro\n5. 第五行表示登录成功的跳转页面\n6. 第六行表示登录页面\n\n配置 ShiroConfig\n```java\n@Configuration\npublic class ShiroConfig {\n    @Bean\n    MyRealm myRealm() {\n        return new MyRealm();\n    }\n    @Bean\n    DefaultWebSecurityManager securityManager() {\n        DefaultWebSecurityManager manager = new DefaultWebSecurityManager();\n        manager.setRealm(myRealm());\n        return manager;\n    }\n    @Bean\n    ShiroFilterChainDefinition shiroFilterChainDefinition() {\n        DefaultShiroFilterChainDefinition definition = new DefaultShiroFilterChainDefinition();\n        definition.addPathDefinition(\"/doLogin\", \"anon\");\n        definition.addPathDefinition(\"/**\", \"authc\");\n        return definition;\n    }\n}\n```\n\n这里的配置和前面的比较像，但是不再需要 ShiroFilterFactoryBean 实例了，替代它的是 ShiroFilterChainDefinition ，在这里定义 Shiro 的路径匹配规则即可。\n\n这里定义完之后，接下来的登录接口定义以及测试方法都和前面的一致\n\n---\n\n## Source & Reference\n\n- https://mp.weixin.qq.com/s/JU_-gn-yZ4VJJXTZvo7nZQ\n- https://cloud.tencent.com/developer/article/1643122\n", "timestamp": "2025-10-19T19:25:23.088234"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Spring/springboot/配置文件.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Spring/springboot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md", "content": "# 配置文件\n\n---\n\nSpring Boot 针对我们常用的开发场景提供了一系列自动化配置来减少原本复杂而又几乎很少改动的模板化配置内容。但是，我们还是需要去了解如何在 Spring Boot 中修改这些自动化的配置内容，以应对一些特殊的场景需求，比如：我们在同一台主机上需要启动多个基于 Spring Boot 的 web 应用，若我们不为每个应用指定特别的端口号，那么默认的 8080 端口必将导致冲突。\n\n## 配置基础\n\nsrc/main/resources 目录是 Spring Boot 的配置目录，所以我们要为应用创建配置个性化配置时，就是在该目录之下。\n\nSpring Boot 的默认配置文件位置为： src/main/resources/application.properties。\n\n关于 Spring Boot 应用的配置内容都集中在该文件中，根据我们引入的不同 Starter 模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。\n\n比如，我们需要自定义 web 模块的服务端口号，可以在 application.properties 中添加 `server.port=8888` 来指定服务端口为 8888，也可以通过 `spring.application.name=hello` 来指定应用名（该名字在 Spring Cloud 应用中会被注册为服务名）。\n\nSpring Boot 的配置文件除了可以使用传统的 properties 文件之外，还支持现在被广泛推荐使用的 YAML 文件。\n\n如下\n```yaml\nenvironments:\n    dev:\n        url: http://dev.bar.com\n        name: Developer Setup\n    prod:\n        url: http://foo.bar.com\n        name: My Cool App\n```\n\n与其等价的properties配置如下。\n```conf\nenvironments.dev.url=http://dev.bar.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://foo.bar.com\nenvironments.prod.name=My Cool App\n```\n\n通过 YAML 的配置方式，我们可以看到配置信息利用阶梯化缩进的方式，其结构显得更为清晰易读，同时配置内容的字符量也得到显著的减少。除此之外，YAML 还可以在一个单个文件中通过使用 spring.profiles 属性来定义多个不同的环境配置。\n\n例如下面的内容，在指定为 test 环境时，server.port 将使用 8882 端口；而在 prod 环境，server.port 将使用 8883 端口；如果没有指定环境，server.port 将使用 8881 端口。\n```yaml\nserver:\n  port: 8881\n---\nspring:\n  profiles: test\nserver:\n  port: 8882\n---\nspring:\n  profiles: prod\nserver:\n  port: 8883\n```\n\n---\n\n## 自定义参数\n\n我们除了可以在 Spring Boot 的配置文件中设置各个 Starter 模块中预定义的配置属性，也可以在配置文件中定义一些我们需要的自定义属性。比如在 application.properties 中添加：\n```conf\nbook.name=SpringCloudInAction\nbook.author=zhangsan\n```\n\n然后，在应用中我们可以通过 @Value 注解来加载这些自定义的参数，比如：\n```java\n@Component\npublic class Book {\n\n    @Value(\"${book.name}\")\n    private String name;\n    @Value(\"${book.author}\")\n    private String author;\n\n    // 省略getter和setter\n}\n```\n\n@Value 注解加载属性值的时候可以支持两种表达式来进行配置：\n- 一种是我们上面介绍的 PlaceHolder 方式，格式为 `${...}` ，大括号内为 PlaceHolder\n- 另外还可以使用 SpEL 表达式（Spring Expression Language）， 格式为 `#{...}` ，大括号内为 SpEL 表达式\n\n---\n\n## 参数引用\n\n在 application.properties 中的各个参数之间，我们也可以直接通过使用 PlaceHolder 的方式来进行引用，就像下面的设置：\n```\nbook.name=SpringCloud\nbook.author=zhangsan\nbook.desc=${book.author}  is writing《${book.name}》\n```\n\nbook.desc 参数引用了上文中定义的 book.name 和 book.author 属性，最后该属性的值就是 zhangsan is writing《SpringCloud》。\n\n---\n\n## 使用随机数\n\n在一些特殊情况下，有些参数我们希望它每次加载的时候不是一个固定的值，比如：密钥、服务端口等。在 Spring Boot 的属性配置文件中，我们可以通过使用 `${random}` 配置来产生随机的 int 值、long 值或者 string 字符串，这样我们就可以容易的通过配置来属性的随机生成，而不是在程序中通过编码来实现这些逻辑。\n\n`${random}` 的配置方式主要有以下几种\n\n```conf\n# 随机字符串\ncom.example.blog.value=${random.value}\n# 随机int\ncom.example.blog.number=${random.int}\n# 随机long\ncom.example.blog.bignumber=${random.long}\n# 10以内的随机数\ncom.example.blog.test1=${random.int(10)}\n# 10-20的随机数\ncom.example.blog.test2=${random.int[10,20]}\n```\n\n---\n\n## 命令行参数\n\n我们可以使用命令 java -jar 命令来启动的方式启动 Spring Boot 应用。该命令除了启动应用之外，还可以在命令行中来指定应用的参数，比如：`java -jar xxx.jar --server.port=8888` ，直接以命令行的方式，来设置 server.port 属性，另启动应用的端口设为 8888。\n\n在命令行方式启动 Spring Boot 应用时，连续的两个减号 `--` 就是对 application.properties 中的属性值进行赋值的标识。所以，`java -jar xxx.jar --server.port=8888` 命令，等价于我们在 application.properties 中添加属性 `server.port=8888`。\n\n通过命令行来修改属性值是 Spring Boot 非常重要的一个特性，通过此特性，理论上已经使得我们应用的属性在启动前是可变的，所以其中端口号也好、数据库连接也好，都是可以在应用启动时发生改变，而不同于以往的 Spring 应用通过 Maven 的 Profile 在编译器进行不同环境的构建。其最大的区别就是，Spring Boot 的这种方式，可以让应用程序的打包内容，贯穿开发、测试以及线上部署，而 Maven 不同 Profile 的方案每个环境所构建的包，其内容本质上是不同的。但是，如果每个参数都需要通过命令行来指定，这显然也不是一个好的方案，所以我们可以在 Spring Boot 中实现多环境的配置。\n\n---\n\n## 多环境配置\n\n我们在开发任何应用的时候，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。\n\n对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。\n\n在 Spring Boot 中多环境配置文件名需要满足 `application-{profile}.properties` 的格式，其中 `{profile}` 对应你的环境标识，比如：\n- application-dev.properties：开发环境\n- application-test.properties：测试环境\n- application-prod.properties：生产环境\n\n至于哪个具体的配置文件会被加载，需要在 application.properties 文件中通过 spring.profiles.active 属性来设置，其值对应配置文件中的 `{profile}` 值。如：spring.profiles.active=test 就会加载 application-test.properties 配置文件内容。\n\n下面，以不同环境配置不同的服务端口为例，进行样例实验。\n\n针对各环境新建不同的配置文件 application-dev.properties、application-test.properties、application-prod.properties\n\n在这三个文件均都设置不同的 server.port 属性，如：dev 环境设置为 1111，test 环境设置为 2222，prod 环境设置为 3333\n\napplication.properties 中设置 `spring.profiles.active=dev` ，就是说默认以 dev 环境设置\n\n测试不同配置的加载\n- 执行 java -jar xxx.jar，可以观察到服务端口被设置为 1111，也就是默认的开发环境（dev）\n- 执行 java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为 2222，也就是测试环境的配置（test）\n- 执行 java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为 3333，也就是生产环境的配置（prod）\n\n按照上面的实验，可以如下总结多环境的配置思路：\n- application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置\n- application-{profile}.properties中配置各个环境不同的内容\n- 通过命令行方式去激活不同环境的配置\n\n---\n\n## 加载顺序\n\n在上面的例子中，我们将 Spring Boot 应用需要的配置内容都放在了项目工程中，虽然我们已经能够通过 spring.profiles.active 或是通过 Maven 来实现多环境的支持。但是，当我们的团队逐渐壮大，分工越来越细致之后，往往我们不需要让开发人员知道测试或是生成环境的细节，而是希望由每个环境各自的负责人（QA 或是运维）来集中维护这些信息。那么如果还是以这样的方式存储配置内容，对于不同环境配置的修改就不得不去获取工程内容来修改这些配置内容，当应用非常多的时候就变得非常不方便。同时，配置内容都对开发人员可见，本身这也是一种安全隐患。对此，现在出现了很多将配置内容外部化的框架和工具，后续将要介绍的 Spring Cloud Config 就是其中之一，为了后续能更好的理解 Spring Cloud Config 的加载机制，我们需要对 Spring Boot 对数据文件的加载机制有一定的了解。\n\nSpring Boot 为了能够更合理的重写各属性的值，使用了下面这种较为特别的属性加载顺序：\n1. 命令行中传入的参数。\n2. SPRING_APPLICATION_JSON 中的属性. SPRING_APPLICATION_JSON 是以 JSON 格式配置在系统环境变量中的内容。\n3. java:comp/env 中的 JNDI 属性。\n4. Java 的系统属性，可以通过 `System.getProperties()` 获得的内容。\n5. 操作系统的环境变量\n6. 通过 random.* 配置的随机属性\n7. 位于当前应用 jar 包之外，针对不同 `{profile}` 环境的配置文件内容，例如：`application-{profile}.properties` 或是 YAML 定义的配置文件\n8. 位于当前应用 jar 包之内，针对不同 `{profile}` 环境的配置文件内容，例如：`application-{profile}.properties` 或是 YAML 定义的配置文件\n9. 位于当前应用 jar 包之外的 application.properties 和 YAML 配置内容\n10. 位于当前应用 jar 包之内的 application.properties 和 YAML 配置内容\n11. 在 `@Configuration` 注解修改的类中，通过 `@PropertySource` 注解定义的属性\n12. 应用默认属性，使用 `SpringApplication.setDefaultProperties` 定义的内容\n\n优先级按上面的顺序有高到低，数字越小优先级越高。\n\n可以看到，其中第 7 项和第 9 项都是从应用 jar 包之外读取配置文件，所以，实现外部化配置的原理就是从此切入，为其指定外部配置文件的加载位置来取代 jar 包之内的配置内容。通过这样的实现，我们的工程在配置中就变的非常干净，我们只需要在本地放置开发需要的配置即可，而其他环境的配置就可以不用关心，由其对应环境的负责人去维护即可。\n\n---\n\n## 配置元数据\n\n元数据信息,可以帮助IDE来完成配置联想和配置提示的展示\n\n配置元数据的自动生成\n\n第一步：创建一个配置类，定义一个自定义配置\n```java\n@Data\n@Configuration\n@ConfigurationProperties(prefix = \"com.test\")\npublic class testProperties {\n\n    /**\n     * 这是一个测试配置\n     */\n    private String from;\n\n}\n```\n\n第二步：在pom.xml中添加自动生成配置元数据的依赖\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n</dependency>\n```\n\n第三步：mvn install下这个项目。\n\n此时我们可以在工程target目录下找到元数据文件.\n\n---\n\n## 加密配置中的敏感信息\n\n**为什么要加密**\n\n可能很多初学者，对于配置信息的加密并不敏感，因为开始主要接触本地的开发，对于很多安全问题并没有太多的考虑。而现实中，我们的配置文件中，其实包含着大量与安全相关的敏感信息，比如：数据库的账号密码、一些服务的密钥等。这些信息一旦泄露，对于企业的重要数据资产，那是相当危险的。 所以，对于这些配置文件中存在的敏感信息进行加密，是每个成熟开发团队都一定会去的事。\n\n**jasypt-spring-boot**\n\n- https://github.com/ulisesbocchio/jasypt-spring-boot\n\n先创建一个基础的Spring Boot项目\n\n设计一个参数和单元测试，用来输出这个配置信息\n\n准备加密的配置：\n```\ndatasource.password=test.com\n```\n\n用来输出配置信息的单元测试：\n```java\n@Slf4j\n@SpringBootTest\npublic class PropertiesTest {\n\n    @Value(\"${datasource.password:}\")\n    private String password;\n\n    @Test\n    public void test() {\n        log.info(\"datasource.password : {}\", password);\n    }\n\n}\n```\n\n执行这个单元测试，会输出：\n```\n2022-04-14 10:46:05.808  INFO 25707 --- [           main] com.example.demo2.PropertiesTest         : datasource.password : test.com\n```\n\n这里没加密，下面开始引入加密的操作\n\n在 pom.xml 中引入 jasypt 提供的 Spring Boot Starter\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>3.0.3</version>\n</dependency>\n```\n\n在插件配置中加入：\n```xml\n<plugin>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-maven-plugin</artifactId>\n    <version>3.0.3</version>\n</plugin>\n```\n\n在配置文件中加入加密需要使用的密码\n```\njasypt.encryptor.password=test\n```\n\n同时，修改要加密的内容，用 DEC() 将待加密内容包裹起来，比如：\n```\ndatasource.password=DEC(test.com)\n```\n\n使用 jasypt-maven-plugin 插件来给 DEC() 包裹的内容实现批量加密。\n```\nmvn jasypt:encrypt -Djasypt.encryptor.password=test\n```\n\n> 注意：这里 -Djasypt.encryptor.password 参数必须与配置文件中的一致，不然后面会解密失败。\n\n执行之后，重新查看配置文件，可以看到，自动变成了\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/配置文件/2.png)\n\n其中，ENC() 跟 DEC() 一样都是 jasypt 提供的标识，分别用来标识括号内的是加密后的内容和待加密的内容。\n\n如果当前配置文件已经都是 ENC() 内容了，那么我们可以通过下面的命令来解密配置文件，查看原始信息：\n```\nmvn jasypt:decrypt -Djasypt.encryptor.password=test\n```\n\n该操作不会修改配置文件，只会在控制台输出解密结果，比如：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/配置文件/3.png)\n\n此时，我们的配置文件中的敏感信息已经被 ENC() 修饰了，再执行一下单元测试，不出意外的话，依然可以得到之前一样的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/spring/springboot/配置文件/4.png)\n\n而此时，配置文件中已经是加密内容了，敏感信息得到了保护。\n\n---\n\n## 2.x 新特性\n\n在Spring Boot 2.0中推出了Relaxed Binding 2.0，对原有的属性绑定功能做了非常多的改进以帮助我们更容易的在Spring应用中加载和读取配置信息。下面本文就来说说Spring Boot 2.0中对配置的改进。\n\n### 配置文件绑定\n\n**简单类型**\n\n在Spring Boot 2.0中对配置属性加载的时候会除了像1.x版本时候那样移除特殊字符外，还会将配置均以全小写的方式进行匹配和加载。所以，下面的4种配置方式都是等价的：\n\nproperties格式：\n```conf\nspring.jpa.databaseplatform=mysql\nspring.jpa.database-platform=mysql\nspring.jpa.databasePlatform=mysql\nspring.JPA.database_platform=mysql\n```\n\nyaml格式：\n```yaml\nspring:\n  jpa:\n    databaseplatform: mysql\n    database-platform: mysql\n    databasePlatform: mysql\n    database_platform: mysql\n```\n\n推荐使用全小写配合-分隔符的方式来配置，比如: `spring.jpa.database-platform=mysql`\n\n**List类型**\n\n在properties文件中使用[]来定位列表类型，比如：\n```conf\nspring.my-example.url[0]=http://example.com\nspring.my-example.url[1]=http://spring.io\n```\n也支持使用逗号分割的配置方式，上面与下面的配置是等价的：\n```conf\nspring.my-example.url=http://example.com,http://spring.io\n```\n\n而在yaml文件中使用可以使用如下配置：\n```yaml\nspring:\n  my-example:\n    url:\n      - http://example.com\n      - http://spring.io\n```\n\n也支持逗号分割的方式：\n```yaml\nspring:\n  my-example:\n    url: http://example.com, http://spring.io\n```\n\n注意：在Spring Boot 2.0中对于List类型的配置必须是连续的，不然会抛出UnboundConfigurationPropertiesException异常，所以如下配置是不允许的：\n```\nfoo[0]=a\nfoo[2]=b\n```\n\n在Spring Boot 1.x中上述配置是可以的，foo[1]由于没有配置，它的值会是null\n\n**Map类型**\n\nMap类型在properties和yaml中的标准配置方式如下：\n\nproperties格式：\n```conf\nspring.my-example.foo=bar\nspring.my-example.hello=world\n```\n\nyaml格式：\n```yaml\nspring:\n  my-example:\n    foo: bar\n    hello: world\n```\n\n注意：如果Map类型的key包含非字母数字和-的字符，需要用[]括起来，比如：\n```yaml\nspring:\n  my-example:\n    '[foo.baz]': bar\n```\n\n### 环境属性绑定\n\n**简单类型**\n\n在环境变量中通过小写转换与 `.` 替换 `_` 来映射配置文件中的内容，比如：环境变量 `SPRING_JPA_DATABASEPLATFORM=mysql` 的配置会产生与在配置文件中设置 `spring.jpa.databaseplatform=mysql` 一样的效果。\n\n**List类型**\n\n由于环境变量中无法使用 `[` 和 `]` 符号，所以使用 `_` 来替代。任何由下划线包围的数字都会被认为是 `[]` 的数组形式。比如：\n```conf\nMY_FOO_1_ = my.foo[1]\nMY_FOO_1_BAR = my.foo[1].bar\nMY_FOO_1_2_ = my.foo[1][2]\n```\n另外，最后环境变量最后是以数字和下划线结尾的话，最后的下划线可以省略，比如上面例子中的第一条和第三条等价于下面的配置：\n```conf\nMY_FOO_1 = my.foo[1]\nMY_FOO_1_2 = my.foo[1][2]\n```\n\n### 系统属性绑定\n\n**简单类型**\n\n系统属性与文件配置中的类似，都以移除特殊字符并转化小写后实现绑定，比如下面的命令行参数都会实现配置 spring.jpa.databaseplatform=mysql 的效果：\n```\n-Dspring.jpa.database-platform=mysql\n-Dspring.jpa.databasePlatform=mysql\n-Dspring.JPA.database_platform=mysql\n```\n\n**List类型**\n\n系统属性的绑定也与文件属性的绑定类似，通过 `[]` 来标示，比如：\n\n```\n-D\"spring.my-example.url[0]=http://example.com\"\n-D\"spring.my-example.url[1]=http://spring.io\"\n```\n\n同样的，他也支持逗号分割的方式，比如：\n```\n-Dspring.my-example.url=http://example.com,http://spring.io\n```\n\n### 属性的读取\n\n上文介绍了 Spring Boot 2.0 中对属性绑定的内容，可以看到对于一个属性我们可以有多种不同的表达，但是如果我们要在 Spring 应用程序的 environment 中读取属性的时候，每个属性的唯一名称符合如下规则：\n- 通过 `.` 分离各个元素\n- 最后一个 `.` 将前缀与属性名称分开\n- 必须是字母（a-z）和数字 (0-9)\n- 必须是小写字母\n- 用连字符 `-` 来分隔单词\n- 唯一允许的其他字符是 `[` 和 `]`，用于 List 的索引\n- 不能以数字开头\n\n所以，如果我们要读取配置文件中 spring.jpa.database-platform 的配置，可以这样写：\n```\nthis.environment.containsProperty(\"spring.jpa.database-platform\")\n```\n\n而下面的方式是无法获取到 spring.jpa.database-platform 配置内容的：\n```\nthis.environment.containsProperty(\"spring.jpa.databasePlatform\")\n```\n注意：使用 @Value 获取配置内容的时候也需要这样的特点\n\n### 全新的绑定API\n\n在 Spring Boot 2.0 中增加了新的绑定 API 来帮助我们更容易的获取配置信息。\n\n**例子一：简单类型**\n\n假设在 propertes 配置中有这样一个配置：com.example.foo=bar\n\n我们为它创建对应的配置类：\n```java\n@Data\n@ConfigurationProperties(prefix = \"com.example\")\npublic class FooProperties {\n\n    private String foo;\n\n}\n```\n\n接下来，通过最新的 Binder 就可以这样来拿配置信息了：\n```java\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        ApplicationContext context = SpringApplication.run(Application.class, args);\n\n        Binder binder = Binder.get(context.getEnvironment());\n\n        // 绑定简单配置\n        FooProperties foo = binder.bind(\"com.example\", Bindable.of(FooProperties.class)).get();\n        System.out.println(foo.getFoo());\n    }\n}\n```\n\n**例子二：List类型**\n\n如果配置内容是 List 类型呢？比如：\n```conf\ncom.example.post[0]=Why Spring Boot\ncom.example.post[1]=Why Spring Cloud\n\ncom.example.posts[0].title=Why Spring Boot\ncom.example.posts[0].content=It is perfect!\ncom.example.posts[1].title=Why Spring Cloud\ncom.example.posts[1].content=It is perfect too!\n```\n\n要获取这些配置依然很简单，可以这样实现：\n```java\nApplicationContext context = SpringApplication.run(Application.class, args);\n\nBinder binder = Binder.get(context.getEnvironment());\n\n// 绑定List配置\nList<String> post = binder.bind(\"com.example.post\", Bindable.listOf(String.class)).get();\nSystem.out.println(post);\n\nList<PostInfo> posts = binder.bind(\"com.example.posts\", Bindable.listOf(PostInfo.class)).get();\nSystem.out.println(posts);\n```\n\n---\n\n## Source & Reference\n\n- [Spring Boot 2.x基础教程：配置文件详解](https://blog.didispace.com/spring-boot-learning-21-1-3/)\n- [Spring Boot 2.x基础教程：配置元数据的应用](https://blog.didispace.com/spring-boot-learning-24-1-6/)\n- [Spring Boot 2.x基础教程：加密配置中的敏感信息](https://blog.didispace.com/spring-boot-learning-2-1-5/)\n", "timestamp": "2025-10-19T19:25:23.281239"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/EL.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/EL.md", "content": "# EL\n\n---\n\nEL 的全称是 Expression Language 是一种表达式语言，该语言主要用于替换 jsp 页面中 java 的代码。\n\n语法：\n\n```\n${表达式}\n```\n\njsp 默认是支持 el 表达式的，如果要忽略表达式的作用，需要在 jsp 中 page 指令的 isELIgnored 为 true。\n\n或者说直接使用反斜杠注释\n```\n\\$(2*3)\n```\n\nEL 运算符：\n\n* 算数运算符： + - * /(div) %(mod)\n* 逻辑运算符： &&(and) ||(or) !(not)\n* 空运算符： empty\n    * 功能：用于判断字符串、集合、数组对象是否为 null 或者长度是否为 0\n    * ${empty list}: 判断字符串、集合、数组对象是否为 null 或者长度为 0\n    * ${not empty str}: 表示判断字符串、集合、数组对象是否不为 null 并且 长度 > 0\n\n获取值:\n\nEL 表达式需要从域对象中获取值\n\n获取值语法：\n```\n${域名称.键名}：从指定域中获取指定键的值\n```\n\n在这里来看看几个域名称都有哪些\n\n域名称：\n1. pageScope\n2. requestScope\n3. sessionScope\n4. applicationScope\n\n代码：\n```java\n<%\n  request.setAttribute(\"name\",\"name\");\n%>\n${requestScope.name}\n${name}\n```\n\n这里可以直接使用键名获取，会依次从最小的域里面去查找是否有对应的值。\n\n获取集合的值：\n\n获取对象、List 集合、Map 集合的值\n\n* 对象：${域名称. 键名. 属性名} 本质上会去调用对象的 getter 方法\n* List 集合：${域名称. 键名 [索引]}\n* Map 集合：\n    * ${域名称. 键名. key 名称}\n    * ${域名称. 键名 [\"key 名称\"]}\n\n---\n\n## Source & Reference\n\n- https://www.cnblogs.com/nice0e3/p/13544143.html\n", "timestamp": "2025-10-19T19:25:23.712652"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/Filter与Listener/Filter与Listener.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/Filter%E4%B8%8EListener/Filter%E4%B8%8EListener.md", "content": "# Filter与Listener\n\n---\n\n在一些登录点或者是登录后才能使用的一些功能点里面，需要该用户登录后才去才能去访问或使用这些功能。但我们如果每个 servlet 都去进行一个判断是否登录，这些会有很多重复代码，而且效率也比较低。那么我们可以把这些代码都放到 Filter 过滤器里面去进行编写。\n\nweb 里面有三大组件：servlet、Filter、Listener。\n\n---\n\n## Filter 过滤器\n\nfilter 作用：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。\n\n在一个比较复杂的 Web 应用程序中，通常都有很多 URL 映射，对应的，也会有多个 Servlet 来处理 URL。\n\n我们考察这样一个论坛应用程序：\n```\n            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n               /             ┌──────────────┐\n            │ ┌─────────────>│ IndexServlet │ │\n              │              └──────────────┘\n            │ │/signin       ┌──────────────┐ │\n              ├─────────────>│SignInServlet │\n            │ │              └──────────────┘ │\n              │/signout      ┌──────────────┐\n┌───────┐   │ ├─────────────>│SignOutServlet│ │\n│Browser├─────┤              └──────────────┘\n└───────┘   │ │/user/profile ┌──────────────┐ │\n              ├─────────────>│ProfileServlet│\n            │ │              └──────────────┘ │\n              │/user/post    ┌──────────────┐\n            │ ├─────────────>│ PostServlet  │ │\n              │              └──────────────┘\n            │ │/user/reply   ┌──────────────┐ │\n              └─────────────>│ ReplyServlet │\n            │                └──────────────┘ │\n             ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─\n```\n\n各个 Servlet 设计功能如下：\n- IndexServlet：浏览帖子；\n- SignInServlet：登录；\n- SignOutServlet：登出；\n- ProfileServlet：修改用户资料；\n- PostServlet：发帖；\n- ReplyServlet：回复。\n\n其中，ProfileServlet、PostServlet 和 ReplyServlet 都需要用户登录后才能操作，否则，应当直接跳转到登录页面。\n\n我们可以直接把判断登录的逻辑写到这 3 个 Servlet 中，但是，同样的逻辑重复 3 次没有必要，并且，如果后续继续加 Servlet 并且也需要验证登录时，还需要继续重复这个检查逻辑。\n\n为了把一些公用逻辑从各个 Servlet 中抽离出来，JavaEE 的 Servlet 规范还提供了一种 Filter 组件，即过滤器，它的作用是，在 HTTP 请求到达 Servlet 之前，可以被一个或多个 Filter 预处理，类似打印日志、登录检查等逻辑，完全可以放到 Filter 中。\n\n我们编写一个最简单的 EncodingFilter，它强制把输入和输出的编码设置为 UTF-8：\n```java\n@WebFilter(urlPatterns = \"/*\")\npublic class EncodingFilter implements Filter {\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"EncodingFilter:doFilter\");\n        request.setCharacterEncoding(\"UTF-8\");\n        response.setCharacterEncoding(\"UTF-8\");\n        chain.doFilter(request, response);\n    }\n}\n```\n\n编写 Filter 时，必须实现 Filter 接口，在 `doFilter()` 方法内部，要继续处理请求，必须调用 `chain.doFilter()`。最后，用 `@WebFilter` 注解标注该 Filter 需要过滤的 URL。这里的 `/*` 表示所有路径。\n\n添加了 Filter 之后，整个请求的处理架构如下：\n```\n            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n                                   /             ┌──────────────┐\n            │                     ┌─────────────>│ IndexServlet │ │\n                                  │              └──────────────┘\n            │                     │/signin       ┌──────────────┐ │\n                                  ├─────────────>│SignInServlet │\n            │                     │              └──────────────┘ │\n                                  │/signout      ┌──────────────┐\n┌───────┐   │   ┌──────────────┐  ├─────────────>│SignOutServlet│ │\n│Browser│──────>│EncodingFilter├──┤              └──────────────┘\n└───────┘   │   └──────────────┘  │/user/profile ┌──────────────┐ │\n                                  ├─────────────>│ProfileServlet│\n            │                     │              └──────────────┘ │\n                                  │/user/post    ┌──────────────┐\n            │                     ├─────────────>│ PostServlet  │ │\n                                  │              └──────────────┘\n            │                     │/user/reply   ┌──────────────┐ │\n                                  └─────────────>│ ReplyServlet │\n            │                                    └──────────────┘ │\n```\n\n还可以继续添加其他 Filter，例如 LogFilter：\n```java\n@WebFilter(\"/*\")\npublic class LogFilter implements Filter {\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"LogFilter: process \" + ((HttpServletRequest) request).getRequestURI());\n        chain.doFilter(request, response);\n    }\n}\n```\n\n多个 Filter 会组成一个链，每个请求都被链上的 Filter 依次处理：\n```\n                                        ┌────────┐\n                                     ┌─>│ServletA│\n                                     │  └────────┘\n    ┌──────────────┐    ┌─────────┐  │  ┌────────┐\n───>│EncodingFilter│───>│LogFilter│──┼─>│ServletB│\n    └──────────────┘    └─────────┘  │  └────────┘\n                                     │  ┌────────┐\n                                     └─>│ServletC│\n                                        └────────┘\n```\n\n有多个 Filter 的时候，Filter 的顺序如何指定？多个 Filter 按不同顺序处理会造成处理结果不同吗？\n\n答案是 Filter 的顺序确实对处理的结果有影响。但遗憾的是，Servlet 规范并没有对 `@WebFilter` 注解标注的 Filter 规定顺序。如果一定要给每个 Filter 指定顺序，就必须在 `web.xml` 文件中对这些 Filter 再配置一遍。\n\n注意到上述两个 Filter 的过滤路径都是 `/*`，即它们会对所有请求进行过滤。也可以编写只对特定路径进行过滤的 Filter，例如 AuthFilter：\n```java\n@WebFilter(\"/user/*\")\npublic class AuthFilter implements Filter {\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"AuthFilter: check authentication\");\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse resp = (HttpServletResponse) response;\n        if (req.getSession().getAttribute(\"user\") == null) {\n            // 未登录，自动跳转到登录页:\n            System.out.println(\"AuthFilter: not signin!\");\n            resp.sendRedirect(\"/signin\");\n        } else {\n            // 已登录，继续处理:\n            chain.doFilter(request, response);\n        }\n    }\n}\n```\n\n注意到 AuthFilter 只过滤以 `/user/` 开头的路径，因此：\n* 如果一个请求路径类似 `/user/profile`，那么它会被上述 3 个 Filter 依次处理；\n* 如果一个请求路径类似 `/test`，那么它会被上述 2 个 Filter 依次处理（不会被 `AuthFilter` 处理）。\n\n再注意观察 `AuthFilter`，当用户没有登录时，在 `AuthFilter` 内部，直接调用 `resp.sendRedirect()` 发送重定向，且没有调用 `chain.doFilter()`，因此，当用户没有登录时，请求到达 `AuthFilter` 后，不再继续处理，即后续的 Filter 和任何 Servlet 都没有机会处理该请求了。\n\n可见，Filter 可以有针对性地拦截或者放行 HTTP 请求。\n\n如果一个 Filter 在当前请求中生效，但什么都没有做：\n```java\n@WebFilter(\"/*\")\npublic class MyFilter implements Filter {\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        // TODO\n    }\n}\n```\n那么，用户将看到一个空白页，因为请求没有继续处理，默认响应是 200 + 空白输出。\n\n如果 Filter 要使请求继续被处理，就一定要调用 `chain.doFilter()` ！\n\n---\n\n定义步骤：\n\n1. 定义一个类，实现接口Filter\n2. 复写方法\n3. 配置拦截路径\n\n配置拦截路径有 2 种方式，分别是 web.xml 和注解进行配置。\n\n### 注解配置拦截路径\n\n```java\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@WebFilter(\"/*\")\npublic class FilerDemo1 implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"filterdemo执行\");\n        filterChain.doFilter(servletRequest, servletResponse);  //放行\n\n\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n### web.xml 配置拦截路径\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <filter>\n        <filter-name>demo1</filter-name>  //声明名字\n        <filter-class>cn.test.web.filter.FilerDemo1</filter-class> //声明对应的filter过滤器\n    </filter>\n\n    <filter-mapping>\n        <filter-name>demo1</filter-name>\n        <url-pattern>/*</url-pattern>     //声明filter拦截资源\n    </filter-mapping>\n</web-app>\n```\n\n这里可以看到 filter 类，需要重写 3 个方法，这里的三个方法的作用分别是：\n\n1. init: 在服务器启动后，会创建 Filter 对象，然后调用 init 方法。只执行一次。用于加载资源\n2. doFilter: 每一次请求被拦截资源时，会执行。执行多次\n3. destroy: 在服务器关闭后，Filter 对象被销毁。如果服务器是正常关闭，则会执行 destroy 方法。只执行一次。用于释放资源\n\n服务器会先执行过滤器，再执行过滤器放行的资源，最好再执行过滤器放行后面的代码。\n\n上面的代码直接拦截了所有的资源，定义的时候过滤器有多种的定义方式\n\n1. 具体资源路径： /index.jsp   只有访问 index.jsp 资源时，过滤器才会被执行\n2. 拦截目录： /user/*\t访问 / user 下的所有资源时，过滤器都会被执行\n3. 后缀名拦截： *.jsp\t\t访问所有后缀名为 jsp 资源时，过滤器都会被执行\n4. 拦截所有资源：/*\t\t访问所有资源时，过滤器都会被执行\n\n我们可以将后台的一些功能 servlet 定义为 amdin/addUserserlvlet, 定义多一层目录，拦截器可以直接定义拦截路径为 admin/* 这样，如果携带了登录的 session 后，才选择放行。\n\n### 定义拦截方式\n\n注解里面定义拦截路径，默认是 REQUEST 方式，也就是浏览器直接访问，使用转发或者或者是其他这些方式访问一样是会被拦截器给拦截的。\n\n如果我们需要使用转发访问资源不被拦截器拦截，可以在注解中配置 dispatcherTypes 属性的值。\n\ndispatcherTypes 五种属性：\n1. REQUEST：默认值。浏览器直接请求资源\n2. FORWARD：转发访问资源\n3. INCLUDE：包含访问资源\n4. ERROR：错误跳转资源\n5. ASYNC：异步访问资源\n\n代码：\n```java\npackage cn.test.web.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@WebFilter(value = \"/*\",dispatcherTypes = {DispatcherType.REQUEST,DispatcherType.FORWARD})  //定义浏览器请求和转发拦截器被执行\npublic class FilerDemo1 implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        System.out.println(\"filterdemo执行\");\n        filterChain.doFilter(servletRequest, servletResponse);  //放行\n\n\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n}\n```\n\n如果是在 web.xml 里面进行配置，那么我们只需要加入\n\nREQUEST\n\nweb.xml 配置：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <filter>\n        <filter-name>demo1</filter-name>\n        <filter-class>cn.test.web.filter.FilerDemo1</filter-class>\n    </filter>\n\n    <filter-mapping>\n        <filter-name>demo1</filter-name>\n        <url-pattern>/*</url-pattern>\n\n        <dispatcher>REQUEST</dispatcher>\n    </filter-mapping>\n\n</web-app>\n```\n\n登陆过滤器案例：\n```java\npackage cn.test.web.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n@WebFilter(\"/*\")\npublic class loginFilter implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n            System.out.println(req);\n            //强制转换成 HttpServletRequest\n            HttpServletRequest request = (HttpServletRequest) req;\n\n            //获取资源请求路径\n            String uri = request.getRequestURI();\n            //判断是否包含登录相关资源路径,排除掉 css/js/图片/验证码等资源\n            if(uri.contains(\"/login.jsp\") || uri.contains(\"/loginServlet\") || uri.contains(\"/css/\") || uri.contains(\"/js/\") || uri.contains(\"/fonts/\") || uri.contains(\"/checkCodeServlet\")  ){\n                //包含，用户就是想登录。放行\n                chain.doFilter(req, resp);\n            }else{\n                //不包含，需要验证用户是否登录\n                //从获取session中获取user\n                Object user = request.getSession().getAttribute(\"user\");\n                if(user != null){\n                    //登录了。放行\n                    chain.doFilter(req, resp);\n                }else{\n                    //没有登录。跳转登录页面\n\n                    request.setAttribute(\"login_msg\",\"您尚未登录，请登录\");\n                    request.getRequestDispatcher(\"/login.jsp\").forward(request,resp);\n                }\n            }\n\n            // chain.doFilter(req, resp);\n        }\n\n    public void init(FilterConfig config) throws ServletException {\n\n    }\n\n}\n```\n\n---\n\n### 修改请求\n\nFilter 可以对请求进行预处理，因此，我们可以把很多公共预处理逻辑放到 Filter 中完成。\n\n考察这样一种需求：我们在 Web 应用中经常需要处理用户上传文件，例如，一个 UploadServlet 可以简单地编写如下：\n```java\n@WebServlet(urlPatterns = \"/upload/file\")\npublic class UploadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 读取Request Body:\n        InputStream input = req.getInputStream();\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        byte[] buffer = new byte[1024];\n        for (;;) {\n            int len = input.read(buffer);\n            if (len == -1) {\n                break;\n            }\n            output.write(buffer, 0, len);\n        }\n        // TODO: 写入文件:\n        // 显示上传结果:\n        String uploadedText = output.toString(StandardCharsets.UTF_8);\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<h1>Uploaded:</h1>\");\n        pw.write(\"<pre><code>\");\n        pw.write(uploadedText);\n        pw.write(\"</code></pre>\");\n        pw.flush();\n    }\n}\n```\n\n是要保证文件上传的完整性怎么办？如果在上传文件的同时，把文件的哈希也传过来，服务器端做一个验证，就可以确保用户上传的文件一定是完整的。\n\n这个验证逻辑非常适合写在 ValidateUploadFilter 中，因为它可以复用。\n\n我们先写一个简单的版本，快速实现ValidateUploadFilter的逻辑：\n```java\n@WebFilter(\"/upload/*\")\npublic class ValidateUploadFilter implements Filter {\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse resp = (HttpServletResponse) response;\n        // 获取客户端传入的签名方法和签名:\n        String digest = req.getHeader(\"Signature-Method\");\n        String signature = req.getHeader(\"Signature\");\n        if (digest == null || digest.isEmpty() || signature == null || signature.isEmpty()) {\n            sendErrorPage(resp, \"Missing signature.\");\n            return;\n        }\n        // 读取Request的Body并验证签名:\n        MessageDigest md = getMessageDigest(digest);\n        InputStream input = new DigestInputStream(request.getInputStream(), md);\n        byte[] buffer = new byte[1024];\n        for (;;) {\n            int len = input.read(buffer);\n            if (len == -1) {\n                break;\n            }\n        }\n        String actual = toHexString(md.digest());\n        if (!signature.equals(actual)) {\n            sendErrorPage(resp, \"Invalid signature.\");\n            return;\n        }\n        // 验证成功后继续处理:\n        chain.doFilter(request, response);\n    }\n\n    // 将byte[]转换为hex string:\n    private String toHexString(byte[] digest) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : digest) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n\n    // 根据名称创建MessageDigest:\n    private MessageDigest getMessageDigest(String name) throws ServletException {\n        try {\n            return MessageDigest.getInstance(name);\n        } catch (NoSuchAlgorithmException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    // 发送一个错误响应:\n    private void sendErrorPage(HttpServletResponse resp, String errorMessage) throws IOException {\n        resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<html><body><h1>\");\n        pw.write(errorMessage);\n        pw.write(\"</h1></body></html>\");\n        pw.flush();\n    }\n}\n```\n\n`ValidateUploadFilter` 对签名进行验证的逻辑是没有问题的，但是，`UploadServlet` 并未读取到任何数据！\n\n这里的原因是对 `HttpServletRequest` 进行读取时，只能读取一次。如果 Filter 调用 `getInputStream()` 读取了一次数据，后续 Servlet 处理时，再次读取，将无法读到任何数据。怎么办？\n\n这个时候，我们需要一个 “伪造” 的 `HttpServletRequest`，具体做法是使用代理模式，对 `getInputStream()` 和 `getReader()` 返回一个新的流：\n```java\nclass ReReadableHttpServletRequest extends HttpServletRequestWrapper {\n    private byte[] body;\n    private boolean open = false;\n\n    public ReReadableHttpServletRequest(HttpServletRequest request, byte[] body) {\n        super(request);\n        this.body = body;\n    }\n\n    // 返回InputStream:\n    public ServletInputStream getInputStream() throws IOException {\n        if (open) {\n            throw new IllegalStateException(\"Cannot re-open input stream!\");\n        }\n        open = true;\n        return new ServletInputStream() {\n            private int offset = 0;\n\n            public boolean isFinished() {\n                return offset >= body.length;\n            }\n\n            public boolean isReady() {\n                return true;\n            }\n\n            public void setReadListener(ReadListener listener) {\n            }\n\n            public int read() throws IOException {\n                if (offset >= body.length) {\n                    return -1;\n                }\n                int n = body[offset] & 0xff;\n                offset++;\n                return n;\n            }\n        };\n    }\n\n    // 返回Reader:\n    public BufferedReader getReader() throws IOException {\n        if (open) {\n            throw new IllegalStateException(\"Cannot re-open reader!\");\n        }\n        open = true;\n        return new BufferedReader(new InputStreamReader(new ByteArrayInputStream(body), \"UTF-8\"));\n    }\n}\n```\n\n注意观察 `ReReadableHttpServletRequest` 的构造方法，它保存了 `ValidateUploadFilter` 读取的 `byte[]` 内容，并在调用 `getInputStream()` 时通过 `byte[]` 构造了一个新的 ServletInputStream。\n\n然后，我们在 `ValidateUploadFilter` 中，把 `doFilter()` 调用时传给下一个处理者的 `HttpServletRequest` 替换为我们自己 “伪造” 的 `ReReadableHttpServletRequest`：\n```java\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n        throws IOException, ServletException {\n    ...\n    chain.doFilter(new ReReadableHttpServletRequest(req, output.toByteArray()), response);\n}\n```\n\n再注意到我们编写 ReReadableHttpServletRequest 时，是从 HttpServletRequestWrapper 继承，而不是直接实现 HttpServletRequest 接口。这是因为，Servlet 的每个新版本都会对接口增加一些新方法，从 HttpServletRequestWrapper 继承可以确保新方法被正确地覆写了，因为 HttpServletRequestWrapper 是由 Servlet 的 jar 包提供的，目的就是为了让我们方便地实现对 HttpServletRequest 接口的代理。\n\n我们总结一下对 `HttpServletRequest` 接口进行代理的步骤：\n\n1. 从 `HttpServletRequestWrapper` 继承一个 `XxxHttpServletRequest`，需要传入原始的 `HttpServletRequest` 实例；\n2. 覆写某些方法，使得新的 `XxxHttpServletRequest` 实例看上去 “改变” 了原始的 `HttpServletRequest` 实例；\n3. 在 `doFilter()` 中传入新的 `XxxHttpServletRequest` 实例。\n\n虽然整个 Filter 的代码比较复杂，但它的好处在于：这个 Filter 在整个处理链中实现了灵活的 “可插拔” 特性，即是否启用对 Web 应用程序的其他组件（Filter、Servlet）完全没有影响。\n\n### 修改响应\n\n既然我们能通过 `Filter` 修改 `HttpServletRequest`，自然也能修改 HttpServletResponse，因为这两者都是接口。\n\n我们来看一下在什么情况下我们需要修改 HttpServletResponse。\n\n假设我们编写了一个 Servlet，但由于业务逻辑比较复杂，处理该请求需要耗费很长的时间：\n```java\n@WebServlet(urlPatterns = \"/slow/hello\")\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html\");\n        // 模拟耗时1秒:\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n        }\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<h1>Hello, world!</h1>\");\n        pw.flush();\n    }\n}\n```\n\n好消息是每次返回的响应内容是固定的，因此，如果我们能使用缓存将结果缓存起来，就可以大大提高 Web 应用程序的运行效率。\n\n缓存逻辑最好不要在 Servlet 内部实现，因为我们希望能复用缓存逻辑，所以，编写一个 CacheFilter 最合适：\n```java\n@WebFilter(\"/slow/*\")\npublic class CacheFilter implements Filter {\n    // Path到byte[]的缓存:\n    private Map<String, byte[]> cache = new ConcurrentHashMap<>();\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse resp = (HttpServletResponse) response;\n        // 获取Path:\n        String url = req.getRequestURI();\n        // 获取缓存内容:\n        byte[] data = this.cache.get(url);\n        resp.setHeader(\"X-Cache-Hit\", data == null ? \"No\" : \"Yes\");\n        if (data == null) {\n            // 缓存未找到,构造一个伪造的Response:\n            CachedHttpServletResponse wrapper = new CachedHttpServletResponse(resp);\n            // 让下游组件写入数据到伪造的Response:\n            chain.doFilter(request, wrapper);\n            // 从伪造的Response中读取写入的内容并放入缓存:\n            data = wrapper.getContent();\n            cache.put(url, data);\n        }\n        // 写入到原始的Response:\n        ServletOutputStream output = resp.getOutputStream();\n        output.write(data);\n        output.flush();\n    }\n}\n```\n\n实现缓存的关键在于，调用 `doFilter()` 时，我们不能传入原始的 `HttpServletResponse`，因为这样就会写入 Socket，我们也就无法获取下游组件写入的内容。如果我们传入的是 “伪造” 的 `HttpServletResponse`，让下游组件写入到我们预设的 `ByteArrayOutputStream`，我们就 “截获” 了下游组件写入的内容，于是，就可以把内容缓存起来，再通过原始的 `HttpServletResponse` 实例写入到网络。\n\n这个 `CachedHttpServletResponse` 实现如下：\n```java\nclass CachedHttpServletResponse extends HttpServletResponseWrapper {\n    private boolean open = false;\n    private ByteArrayOutputStream output = new ByteArrayOutputStream();\n\n    public CachedHttpServletResponse(HttpServletResponse response) {\n        super(response);\n    }\n\n    // 获取Writer:\n    public PrintWriter getWriter() throws IOException {\n        if (open) {\n            throw new IllegalStateException(\"Cannot re-open writer!\");\n        }\n        open = true;\n        return new PrintWriter(output, false, StandardCharsets.UTF_8);\n    }\n\n    // 获取OutputStream:\n    public ServletOutputStream getOutputStream() throws IOException {\n        if (open) {\n            throw new IllegalStateException(\"Cannot re-open output stream!\");\n        }\n        open = true;\n        return new ServletOutputStream() {\n            public boolean isReady() {\n                return true;\n            }\n\n            public void setWriteListener(WriteListener listener) {\n            }\n\n            // 实际写入ByteArrayOutputStream:\n            public void write(int b) throws IOException {\n                output.write(b);\n            }\n        };\n    }\n\n    // 返回写入的byte[]:\n    public byte[] getContent() {\n        return output.toByteArray();\n    }\n}\n```\n\n可见，如果我们想要修改响应，就可以通过 `HttpServletResponseWrapper` 构造一个 “伪造” 的 `HttpServletResponse`，这样就能拦截到写入的数据。\n\n修改响应时，最后不要忘记把数据写入原始的 `HttpServletResponse` 实例。\n\n这个 `CacheFilter` 同样是一个 “可插拔” 组件，它是否启用不影响 Web 应用程序的其他组件（Filter、Servlet）。\n\n---\n\n## Listener 监听器\n\n除了 Servlet 和 Filter 外，JavaEE 的 Servlet 规范还提供了第三种组件：Listener。\n\n事件监听机制：\n* 事件\t：一件事情\n* 事件源 ：事件发生的地方\n* 监听器 ：一个对象\n* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码\n\nListener 顾名思义就是监听器，有好几种 Listener，其中最常用的是 `ServletContextListener`，我们编写一个实现了 `ServletContextListener` 接口的类如下：\n```java\n@WebListener\npublic class AppListener implements ServletContextListener {\n    // 在此初始化WebApp,例如打开数据库连接池等:\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"WebApp initialized.\");\n    }\n\n    // 在此清理WebApp,例如关闭数据库连接池等:\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\"WebApp destroyed.\");\n    }\n}\n```\n\n任何标注为 `@WebListener`，且实现了特定接口的类会被 Web 服务器自动初始化。上述 `AppListener` 实现了 `ServletContextListener` 接口，它会在整个 Web 应用程序初始化完成后，以及 Web 应用程序关闭后获得回调通知。我们可以把初始化数据库连接池等工作放到 `contextInitialized()` 回调方法中，把清理资源的工作放到 `contextDestroyed()` 回调方法中，因为 Web 服务器保证在 `contextInitialized()` 执行后，才会接受用户的 HTTP 请求。\n\n很多第三方 Web 框架都会通过一个 `ServletContextListener` 接口初始化自己。\n\n除了 `ServletContextListener` 外，还有几种 Listener：\n\n* HttpSessionListener：监听 HttpSession 的创建和销毁事件；\n* ServletRequestListener：监听 ServletRequest 请求的创建和销毁事件；\n* ServletRequestAttributeListener：监听 ServletRequest 请求的属性变化事件（即调用 `ServletRequest.setAttribute()` 方法）；\n* ServletContextAttributeListener：监听 ServletContext 的属性变化事件（即调用 `ServletContext.setAttribute()` 方法）；\n\n### ServletContext\n\n一个 Web 服务器可以运行一个或多个 WebApp，对于每个 WebApp，Web 服务器都会为其创建一个全局唯一的 `ServletContext` 实例，我们在 `AppListener` 里面编写的两个回调方法实际上对应的就是 `ServletContext` 实例的创建和销毁：\n\n```java\npublic void contextInitialized(ServletContextEvent sce) {\n    System.out.println(\"WebApp initialized: ServletContext = \" + sce.getServletContext());\n}\n```\n\n`ServletRequest`、`HttpSession` 等很多对象也提供 `getServletContext()` 方法获取到同一个 `ServletContext` 实例。`ServletContext` 实例最大的作用就是设置和共享全局信息。\n\n此外，`ServletContext` 还提供了动态添加 Servlet、Filter、Listener 等功能，它允许应用程序在运行期间动态添加一个组件，虽然这个功能不是很常用。\n\n---\n\n## Source & Reference\n\n- https://www.cnblogs.com/nice0e3/p/13551701.html\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1266264823560128\n", "timestamp": "2025-10-19T19:25:24.166111"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/JSTL.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/JSTL.md", "content": "# JSTL\n\n---\n\nJSTL全称是JavaServer Pages Tag Library JSP标准标签库\n\n导入 jstl 包\n```java\n<%@taglib prefix=\"c\" uri=\"http://java.sun.com/jstl/core\" %>\n```\n\n* if 标签 ，test 必须属性，接受 boolean 表达式\n* choose: 相当于 java 代码的 switch 语句\n    1. 使用 choose 标签声明         \t\t\t相当于 switch 声明\n    2. 使用 when 标签做判断         \t\t\t相当于 case\n    3. 使用 otherwise 标签做其他情况的声明    \t相当于 default\n* foreach: 相当于 java 代码的 for 语句\n\n遍历 list 代码：\n\n```java\n<%@ page import=\"java.util.List\" %>\n<%@ page import=\"java.util.ArrayList\" %><%--\n\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\"  %>\n<html>\n  <head>\n    <title>$Title$</title>\n  </head>\n  <%@taglib prefix=\"c\" uri=\"http://java.sun.com/jstl/core\" %>\n\n  <%\n    List list = new ArrayList();\n    list.add(\"aaa\");\n    list.add(\"bbb\");\n    list.add(\"ccc\");\n\n    request.setAttribute(\"list\",list);\n\n\n  %>\n\n  <c:forEach begin=\"1\" end=\"10\" var=\"i\" step=\"2\" varStatus=\"s\">\n    ${i} <h3>${s.index}</h3> <h4> ${s.count} </h4><br>\n\n    </c:forEach>\n\n  </body>\n</html>\n```\n\n---\n\n## Source & Reference\n\n- https://www.cnblogs.com/nice0e3/p/13544143.html\n", "timestamp": "2025-10-19T19:25:24.355009"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/MVC/MVC.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/MVC/MVC.md", "content": "# MVC\n\n---\n\n## 什么是 MVC 框架\n\n假设我们已经编写了几个JavaBean：\n```java\npublic class User {\n    public long id;\n    public String name;\n    public School school;\n}\n\npublic class School {\n    public String name;\n    public String address;\n}\n```\n\n在 `UserServlet` 中，我们可以从数据库读取 User、School 等信息，然后，把读取到的 JavaBean 先放到 `HttpServletRequest` 中，再通过 `forward()` 传给 `user.jsp` 处理：\n```java\n@WebServlet(urlPatterns = \"/user\")\npublic class UserServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 假装从数据库读取:\n        School school = new School(\"No.1 Middle School\", \"101 South Street\");\n        User user = new User(123, \"Bob\", school);\n        // 放入Request中:\n        req.setAttribute(\"user\", user);\n        // forward给user.jsp:\n        req.getRequestDispatcher(\"/WEB-INF/user.jsp\").forward(req, resp);\n    }\n}\n```\n\n在 `user.jsp` 中，我们只负责展示相关 JavaBean 的信息，不需要编写访问数据库等复杂逻辑：\n```java\n<%@ page import=\"bean.*\"%>\n<%\n    User user = (User) request.getAttribute(\"user\");\n%>\n<html>\n<head>\n    <title>Hello World - JSP</title>\n</head>\n<body>\n    <h1>Hello <%= user.name %>!</h1>\n    <p>School Name:\n    <span style=\"color:red\">\n        <%= user.school.name %>\n    </span>\n    </p>\n    <p>School Address:\n    <span style=\"color:red\">\n        <%= user.school.address %>\n    </span>\n    </p>\n</body>\n</html>\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/MVC/1.png)\n\n* 需要展示的 User 被放入 `HttpServletRequest` 中以便传递给 JSP，因为一个请求对应一个 HttpServletRequest，我们也无需清理它，处理完该请求后 `HttpServletRequest` 实例将被丢弃；\n* 把 `user.jsp` 放到 `/WEB-INF/` 目录下，是因为 `WEB-INF` 是一个特殊目录，Web Server 会阻止浏览器对 `WEB-INF` 目录下任何资源的访问，这样就防止用户通过 `/user.jsp` 路径直接访问到 JSP 页面；\n* JSP 页面首先从 `request` 变量获取 `User` 实例，然后在页面中直接输出，此处未考虑 HTML 的转义问题，有潜在安全风险。\n\n在浏览器访问 http://localhost:8080/user，请求首先由 `UserServlet` 处理，然后交给 user.jsp 渲染\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/MVC/2.png)\n\n我们把 `UserServlet` 看作业务逻辑处理，把 User 看作模型，把 `user.jsp` 看作渲染，这种设计模式通常被称为 MVC：Model-View-Controller，即 `UserServlet` `作为控制器（Controller），User` 作为模型（Model），`user.jsp` 作为视图（View），整个 MVC 架构如下：\n```\n                   ┌───────────────────────┐\n             ┌────>│Controller: UserServlet│\n             │     └───────────────────────┘\n             │                 │\n┌───────┐    │           ┌─────┴─────┐\n│Browser│────┘           │Model: User│\n│       │<───┐           └─────┬─────┘\n└───────┘    │                 │\n             │                 ▼\n             │     ┌───────────────────────┐\n             └─────│    View: user.jsp     │\n                   └───────────────────────┘\n```\n\n使用 MVC 模式的好处是，Controller 专注于业务处理，它的处理结果就是 Model。Model 可以是一个 JavaBean，也可以是一个包含多个对象的 Map，Controller 只负责把 Model 传递给 View，View 只负责把 Model 给 “渲染” 出来，这样，三者职责明确，且开发更简单，因为开发 Controller 时无需关注页面，开发 View 时无需关心如何创建 Model。\n\n---\n\n## MVC高级开发\n\n通过结合 Servlet 和 JSP 的 MVC 模式，我们可以发挥二者各自的优点：\n* Servlet 实现业务逻辑；\n* JSP 实现展示逻辑。\n\n但是，直接把 MVC 搭在 Servlet 和 JSP 之上还是不太好，原因如下：\n* Servlet 提供的接口仍然偏底层，需要实现 Servlet 调用相关接口；\n* JSP 对页面开发不友好，更好的替代品是模板引擎；\n* 业务逻辑最好由纯粹的 Java 类实现，而不是强迫继承自 Servlet。\n\n能不能通过普通的 Java 类实现 MVC 的 Controller？类似下面的代码：\n```java\npublic class UserController {\n    @GetMapping(\"/signin\")\n    public ModelAndView signin() {\n        ...\n    }\n\n    @PostMapping(\"/signin\")\n    public ModelAndView doSignin(SignInBean bean) {\n        ...\n    }\n\n    @GetMapping(\"/signout\")\n    public ModelAndView signout(HttpSession session) {\n        ...\n    }\n}\n```\n\n上面的这个 Java 类每个方法都对应一个 GET 或 POST 请求，方法返回值是 `ModelAndView`，它包含一个 View 的路径以及一个 Model，这样，再由 MVC 框架处理后返回给浏览器。\n\n如果是 GET 请求，我们希望 MVC 框架能直接把 URL 参数按方法参数对应起来然后传入：\n```java\n@GetMapping(\"/hello\")\npublic ModelAndView hello(String name) {\n    ...\n}\n```\n\n如果是 POST 请求，我们希望 MVC 框架能直接把 Post 参数变成一个 JavaBean 后通过方法参数传入：\n```java\n@PostMapping(\"/signin\")\npublic ModelAndView doSignin(SignInBean bean) {\n    ...\n}\n```\n\n为了增加灵活性，如果 Controller 的方法在处理请求时需要访问 `HttpServletRequest`、`HttpServletResponse`、`HttpSession` 这些实例时，只要方法参数有定义，就可以自动传入：\n```java\n@GetMapping(\"/signout\")\npublic ModelAndView signout(HttpSession session) {\n    ...\n}\n```\n\n以上就是我们在设计 MVC 框架时，上层代码所需要的一切信息。\n\n---\n\n## 设计 MVC 框架\n\n如何设计一个 MVC 框架？在上文中，我们已经定义了上层代码编写 Controller 的一切接口信息，并且并不要求实现特定接口，只需返回 `ModelAndView` 对象，该对象包含一个 `View` 和一个 `Model`。实际上 `View` 就是模板的路径，而 `Model` 可以用一个 `Map<String, Object>` 表示，因此，`ModelAndView` 定义非常简单：\n\n```java\npublic class ModelAndView {\n    Map<String, Object> model;\n    String view;\n}\n```\n\n比较复杂的是我们需要在 MVC 框架中创建一个接收所有请求的 `Servlet`，通常我们把它命名为 `DispatcherServlet`，它总是映射到 `/`，然后，根据不同的 `Controller` 的方法定义的 `@Get` 或 `@Post` 的 Path 决定调用哪个方法，最后，获得方法返回的 `ModelAndView` 后，渲染模板，写入 `HttpServletResponse`，即完成了整个 MVC 的处理。\n\n这个 MVC 的架构如下：\n\n```\n   HTTP Request    ┌─────────────────┐\n──────────────────>│DispatcherServlet│\n                   └─────────────────┘\n                            │\n               ┌────────────┼────────────┐\n               ▼            ▼            ▼\n         ┌───────────┐┌───────────┐┌───────────┐\n         │Controller1││Controller2││Controller3│\n         └───────────┘└───────────┘└───────────┘\n               │            │            │\n               └────────────┼────────────┘\n                            ▼\n   HTTP Response ┌────────────────────┐\n<────────────────│render(ModelAndView)│\n                 └────────────────────┘\n```\n\n其中，`DispatcherServlet` 以及如何渲染均由 MVC 框架实现，在 MVC 框架之上只需要编写每一个 Controller。\n\n我们来看看如何编写最复杂的 `DispatcherServlet`。首先，我们需要存储请求路径到某个具体方法的映射：\n\n```java\n@WebServlet(urlPatterns = \"/\")\npublic class DispatcherServlet extends HttpServlet {\n    private Map<String, GetDispatcher> getMappings = new HashMap<>();\n    private Map<String, PostDispatcher> postMappings = new HashMap<>();\n}\n```\n\n处理一个 GET 请求是通过 `GetDispatcher` 对象完成的，它需要如下信息：\n```java\nclass GetDispatcher {\n    Object instance; // Controller实例\n    Method method; // Controller方法\n    String[] parameterNames; // 方法参数名称\n    Class<?>[] parameterClasses; // 方法参数类型\n}\n```\n\n有了以上信息，就可以定义 `invoke()` 来处理真正的请求：\n```java\nclass GetDispatcher {\n    ...\n    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {\n        Object[] arguments = new Object[parameterClasses.length];\n        for (int i = 0; i < parameterClasses.length; i++) {\n            String parameterName = parameterNames[i];\n            Class<?> parameterClass = parameterClasses[i];\n            if (parameterClass == HttpServletRequest.class) {\n                arguments[i] = request;\n            } else if (parameterClass == HttpServletResponse.class) {\n                arguments[i] = response;\n            } else if (parameterClass == HttpSession.class) {\n                arguments[i] = request.getSession();\n            } else if (parameterClass == int.class) {\n                arguments[i] = Integer.valueOf(getOrDefault(request, parameterName, \"0\"));\n            } else if (parameterClass == long.class) {\n                arguments[i] = Long.valueOf(getOrDefault(request, parameterName, \"0\"));\n            } else if (parameterClass == boolean.class) {\n                arguments[i] = Boolean.valueOf(getOrDefault(request, parameterName, \"false\"));\n            } else if (parameterClass == String.class) {\n                arguments[i] = getOrDefault(request, parameterName, \"\");\n            } else {\n                throw new RuntimeException(\"Missing handler for type: \" + parameterClass);\n            }\n        }\n        return (ModelAndView) this.method.invoke(this.instance, arguments);\n    }\n\n    private String getOrDefault(HttpServletRequest request, String name, String defaultValue) {\n        String s = request.getParameter(name);\n        return s == null ? defaultValue : s;\n    }\n}\n```\n\n上述代码比较繁琐，但逻辑非常简单，即通过构造某个方法需要的所有参数列表，使用反射调用该方法后返回结果。\n\n类似的，`PostDispatcher` 需要如下信息：\n\n```java\nclass PostDispatcher {\n    Object instance; // Controller实例\n    Method method; // Controller方法\n    Class<?>[] parameterClasses; // 方法参数类型\n    ObjectMapper objectMapper; // JSON映射\n}\n```\n\n和 GET 请求不同，POST 请求严格地来说不能有 URL 参数，所有数据都应当从 Post Body 中读取。这里我们为了简化处理，只支持 JSON 格式的 POST 请求，这样，把 Post 数据转化为 JavaBean 就非常容易。\n\n\n```java\nclass PostDispatcher {\n    ...\n    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {\n        Object[] arguments = new Object[parameterClasses.length];\n        for (int i = 0; i < parameterClasses.length; i++) {\n            Class<?> parameterClass = parameterClasses[i];\n            if (parameterClass == HttpServletRequest.class) {\n                arguments[i] = request;\n            } else if (parameterClass == HttpServletResponse.class) {\n                arguments[i] = response;\n            } else if (parameterClass == HttpSession.class) {\n                arguments[i] = request.getSession();\n            } else {\n                // 读取JSON并解析为JavaBean:\n                BufferedReader reader = request.getReader();\n                arguments[i] = this.objectMapper.readValue(reader, parameterClass);\n            }\n        }\n        return (ModelAndView) this.method.invoke(instance, arguments);\n    }\n}\n```\n\n最后，我们来实现整个 `DispatcherServlet` 的处理流程，以 `doGet()` 为例：\n\n```java\npublic class DispatcherServlet extends HttpServlet {\n    ...\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html\");\n        resp.setCharacterEncoding(\"UTF-8\");\n        String path = req.getRequestURI().substring(req.getContextPath().length());\n        // 根据路径查找GetDispatcher:\n        GetDispatcher dispatcher = this.getMappings.get(path);\n        if (dispatcher == null) {\n            // 未找到返回404:\n            resp.sendError(404);\n            return;\n        }\n        // 调用Controller方法获得返回值:\n        ModelAndView mv = dispatcher.invoke(req, resp);\n        // 允许返回null:\n        if (mv == null) {\n            return;\n        }\n        // 允许返回`redirect:`开头的view表示重定向:\n        if (mv.view.startsWith(\"redirect:\")) {\n            resp.sendRedirect(mv.view.substring(9));\n            return;\n        }\n        // 将模板引擎渲染的内容写入响应:\n        PrintWriter pw = resp.getWriter();\n        this.viewEngine.render(mv, pw);\n        pw.flush();\n    }\n}\n```\n\n这里有几个小改进：\n* 允许 Controller 方法返回 `null`，表示内部已自行处理完毕；\n* 允许 Controller 方法返回以 `redirect`: 开头的 view 名称，表示一个重定向。\n\n这样使得上层代码编写更灵活。例如，一个显示用户资料的请求可以这样写：\n\n```java\n@GetMapping(\"/user/profile\")\npublic ModelAndView profile(HttpServletResponse response, HttpSession session) {\n    User user = (User) session.getAttribute(\"user\");\n    if (user == null) {\n        // 未登录，跳转到登录页:\n        return new ModelAndView(\"redirect:/signin\");\n    }\n    if (!user.isManager()) {\n        // 权限不够，返回403:\n        response.sendError(403);\n        return null;\n    }\n    return new ModelAndView(\"/profile.html\", Map.of(\"user\", user));\n}\n```\n\n最后一步是在 `DispatcherServlet` 的 `init()` 方法中初始化所有 Get 和 Post 的映射，以及用于渲染的模板引擎：\n\n```java\npublic class DispatcherServlet extends HttpServlet {\n    private Map<String, GetDispatcher> getMappings = new HashMap<>();\n    private Map<String, PostDispatcher> postMappings = new HashMap<>();\n    private ViewEngine viewEngine;\n\n    @Override\n    public void init() throws ServletException {\n        this.getMappings = scanGetInControllers();\n        this.postMappings = scanPostInControllers();\n        this.viewEngine = new ViewEngine(getServletContext());\n    }\n    ...\n}\n```\n\n如何扫描所有 Controller 以获取所有标记有 `@GetMapping` 和 `@PostMapping` 的方法？当然是使用反射了。\n\n这样，整个 MVC 框架就搭建完毕。\n\n---\n\n## 实现渲染\n\n如何使用模板引擎进行渲染有疑问，即如何实现上述的 `ViewEngine`？其实 `ViewEngine` 非常简单，只需要实现一个简单的 `render()` 方法：\n\n```java\npublic class ViewEngine {\n    public void render(ModelAndView mv, Writer writer) throws IOException {\n        String view = mv.view;\n        Map<String, Object> model = mv.model;\n        // 根据view找到模板文件:\n        Template template = getTemplateByPath(view);\n        // 渲染并写入Writer:\n        template.write(writer, model);\n    }\n}\n```\n\nJava 有很多开源的模板引擎，常用的有：\n* Thymeleaf\n* FreeMarker\n* Velocity\n\n他们的用法都大同小异。这里我们推荐一个使用 Jinja 语法的模板引擎 Pebble，它的特点是语法简单，支持模板继承，编写出来的模板类似：\n```html\n<html>\n<body>\n  <ul>\n  {% for user in users %}\n    <li><a href=\"{{ user.url }}\">{{ user.username }}</a></li>\n  {% endfor %}\n  </ul>\n</body>\n</html>\n```\n\n即变量用 `{{ xxx }}` 表示，控制语句用 `{% xxx %}` 表示。\n\n使用 Pebble 渲染只需要如下几行代码：\n```java\npublic class ViewEngine {\n    private final PebbleEngine engine;\n\n    public ViewEngine(ServletContext servletContext) {\n        // 定义一个ServletLoader用于加载模板:\n        ServletLoader loader = new ServletLoader(servletContext);\n        // 模板编码:\n        loader.setCharset(\"UTF-8\");\n        // 模板前缀，这里默认模板必须放在`/WEB-INF/templates`目录:\n        loader.setPrefix(\"/WEB-INF/templates\");\n        // 模板后缀:\n        loader.setSuffix(\"\");\n        // 创建Pebble实例:\n        this.engine = new PebbleEngine.Builder()\n            .autoEscaping(true) // 默认打开HTML字符转义，防止XSS攻击\n            .cacheActive(false) // 禁用缓存使得每次修改模板可以立刻看到效果\n            .loader(loader).build();\n    }\n\n    public void render(ModelAndView mv, Writer writer) throws IOException {\n        // 查找模板:\n        PebbleTemplate template = this.engine.getTemplate(mv.view);\n        // 渲染:\n        template.evaluate(writer, mv.model);\n    }\n}\n```\n\n最后我们来看看整个工程的结构：\n```\nweb-mvc\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── com\n        │       └── itranswarp\n        │           └── learnjava\n        │               ├── Main.java\n        │               ├── bean\n        │               │   ├── SignInBean.java\n        │               │   └── User.java\n        │               ├── controller\n        │               │   ├── IndexController.java\n        │               │   └── UserController.java\n        │               └── framework\n        │                   ├── DispatcherServlet.java\n        │                   ├── FileServlet.java\n        │                   ├── GetMapping.java\n        │                   ├── ModelAndView.java\n        │                   ├── PostMapping.java\n        │                   └── ViewEngine.java\n        └── webapp\n            ├── WEB-INF\n            │   ├── templates\n            │   │   ├── _base.html\n            │   │   ├── hello.html\n            │   │   ├── index.html\n            │   │   ├── profile.html\n            │   │   └── signin.html\n            │   └── web.xml\n            └── static\n                ├── css\n                │   └── bootstrap.css\n                └── js\n                    ├── bootstrap.js\n                    └── jquery.js\n```\n\n其中，`framework` 包是 MVC 的框架，完全可以单独编译后作为一个 Maven 依赖引入，`controller` 包才是我们需要编写的业务逻辑。\n\n我们还硬性规定模板必须放在 `webapp/WEB-INF/templates` 目录下，静态文件必须放在 `webapp/static` 目录下，因此，为了便于开发，我们还顺带实现一个 `FileServlet` 来处理静态文件：\n```java\n@WebServlet(urlPatterns = { \"/favicon.ico\", \"/static/*\" })\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 读取当前请求路径:\n        ServletContext ctx = req.getServletContext();\n        // RequestURI包含ContextPath,需要去掉:\n        String urlPath = req.getRequestURI().substring(ctx.getContextPath().length());\n        // 获取真实文件路径:\n        String filepath = ctx.getRealPath(urlPath);\n        if (filepath == null) {\n            // 无法获取到路径:\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        Path path = Paths.get(filepath);\n        if (!path.toFile().isFile()) {\n            // 文件不存在:\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        // 根据文件名猜测Content-Type:\n        String mime = Files.probeContentType(path);\n        if (mime == null) {\n            mime = \"application/octet-stream\";\n        }\n        resp.setContentType(mime);\n        // 读取文件并写入Response:\n        OutputStream output = resp.getOutputStream();\n        try (InputStream input = new BufferedInputStream(new FileInputStream(filepath))) {\n            input.transferTo(output);\n        }\n        output.flush();\n    }\n}\n```\n\n运行代码，在浏览器中输入 URL http://localhost:8080/hello?name=Bob 可以看到如下页面：\n\n为了把方法参数的名称编译到 class 文件中，以便处理 `@GetMapping` 时使用，我们需要打开编译器的一个参数，在 Eclipse 中勾选 Preferences-Java-Compiler-Store information about method parameters (usable via reflection)；在 Idea 中选择 Preferences-Build, Execution, Deployment-Compiler-Java Compiler-Additional command line parameters，填入 - parameters；在 Maven 的 pom.xml 添加一段配置如下：\n```xml\n<project ...>\n    <modelVersion>4.0.0</modelVersion>\n    ...\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <configuration>\n                    <compilerArgs>\n                        <arg>-parameters</arg>\n                    </compilerArgs>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n本次实现的这个 MVC 框架，上层代码使用的公共类如 `GetMapping`、`PostMapping` 和 `ModelAndView` 都和 Spring MVC 非常类似。实际上，我们这个 MVC 框架主要参考就是 Spring MVC，通过实现一个 “简化版”MVC，可以掌握 Java Web MVC 开发的核心思想与原理，对将来直接使用 Spring MVC 是非常有帮助的。\n\n---\n\n## Source & Reference\n\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1266264917931808\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009\n", "timestamp": "2025-10-19T19:25:24.758386"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/SpEL.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/SpEL.md", "content": "# SpEL\n\n---\n\n## SpEL简介\n\n在 Spring 3 中引入了 Spring 表达式语言（Spring Expression Language，简称 SpEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于 XML 和基于注解的 Spring 配置还有 bean 定义一起使用。\n\n在 Spring 系列产品中，SpEL 是表达式计算的基础，实现了与 Spring 生态系统所有产品无缝对接。Spring 框架的核心功能之一就是通过依赖注入的方式来管理 Bean 之间的依赖关系，而 SpEL 可以方便快捷的对 ApplicationContext 中的 Bean 进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量 Java 代码。\n\nSpEL 有许多特性：\n- 使用 Bean 的 ID 来引用 Bean\n- 可调用方法和访问对象的属性\n- 可对值进行算数、关系和逻辑运算\n- 可使用正则表达式进行匹配\n- 可进行集合操作\n\n## SpEL 定界符——#{}\n\nSpEL 使用 `#{}` 作为定界符，所有在大括号中的字符都将被认为是 SpEL 表达式，在其中可以使用 SpEL 运算符、变量、引用 bean 及其属性和方法等。\n\n这里需要注意 `#{}` 和 `${}` 的区别：\n\n- `#{}` 就是 SpEL 的定界符，用于指明内容未 SpEL 表达式并执行；\n- `${}` 主要用于加载外部属性文件中的值；\n\n两者可以混合使用，但是必须 `#{}` 在外面，`${}` 在里面，如 `#{'${}'}`，注意单引号是字符串类型才添加的；\n\n## SpEL 表达式类型\n\n### 字面值\n\n最简单的 SpEL 表达式就是仅包含一个字面值。\n\n下面我们在 XML 配置文件中使用 SpEL 设置类属性的值为字面值，此时需要用到 `#{}` 定界符，注意若是指定为字符串的话需要添加单引号括起来：\n```xml\n<property name=\"message1\" value=\"#{666}\"/>\n<property name=\"message2\" value=\"#{'test'}\"/>\n```\n\n还可以直接与字符串混用：\n```xml\n<property name=\"message\" value=\"the value is #{666}\"/>\n```\n\nJava 基本数据类型都可以出现在 SpEL 表达式中，表达式中的数字也可以使用科学计数法：\n```xml\n<property name=\"salary\" value=\"#{1e4}\"/>\n```\n\nDemo\n```java\n// HelloWorld.java\npackage com.test;\n\npublic class HelloWorld {\n    private String message;\n\n    public void setMessage(String message){\n        this.message  = message;\n    }\n\n    public void getMessage(){\n        System.out.println(\"Your Message : \" + message);\n    }\n}\n```\n\n```java\n// MainApp.java\npackage com.test;\n\nimport com.test.service.AccountService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\");\n        HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\");\n        obj.getMessage();\n    }\n}\n```\n\nBeans.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \">\n\n    <bean id=\"helloWorld\" class=\"com.test.HelloWorld\">\n        <property name=\"message\" value=\"#{'test'} is #{666}\" />\n    </bean>\n\n</beans>\n```\n\n运行输出：\n```\nYour Message : test is 666\n```\n", "timestamp": "2025-10-19T19:25:24.939099"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/jsp/jsp.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/jsp/jsp.md", "content": "# jsp\n\n---\n\n## 什么是 JavaServer Pages？\n\nJavaServer Pages(JSP) 是一种技术，能够开发支持动态内容的网页，可以帮助开发人员在 HTML 页面中利用特殊的 JSP 标签插入 Java 代码，其中大部分标签是以 `<%` 开始，以 `%>` 结束的。\n\nJavaServer Pages 组件是 Java Servlet 的一种，旨在为 Java web 应用程序实现一个用户界面。Web 开发人员编写 JSP 作为文本文件，结合 HTML 或 XHTML 代码，XML 元素，并嵌入 JSP 操作和命令。\n\n使用 JSP，你可以通过 web 页面的形式收集来自用户的输入，来自数据库或其他资源的当前记录并动态地创建 web 页面。\n\nJSP 标签可用于各种用途，如从数据库检索信息或注册用户首选项，访问 javabean 组件，在页面之间传递控制，在请求、页面之间共享信息等。\n\n---\n\n## 为什么使用 JSP？\n\nJavaServer Pages 的服务通常与通用网关接口(CGI)实现程序一样。但 JSP 与 CGI 相比，有几个优势。\n\n性能更好，因为 JSP 允许在 HTML 页面本身嵌入动态元素而不需要创建一个单独的 CGI 文件。\n\nJSP 总是在服务器处理之前进行编译，不像 CGI/Perl，每次请求页面时都需要服务器加载一个解释器和目标脚本。\n\nJavaServer Pages 是建立在 Java servlet API 之上的，就像 servlet，JSP 也可以访问所有强大的 Enterprise Java API，包括 JDBC，JNDI，EJB，JAXP 等等。\n\nJSP 页面可以与 servlet 结合使用，来处理业务逻辑，该模型是由 Java servlet 模板引擎支持的。\n最后，JSP 还是 Java EE 不可分割的一部分，是 enterprise 级别应用程序的一个完整平台。这意味着 JSP 可以用于从最简单的应用程序到最复杂的应用程序中，并实现要求。\n\n---\n\n## JSP 的优点\n\n下列是 JSP 优于其他技术的另外的优点：\n\n* 与 Active Server Pages(ASP) 相比： JSP 的优点是双重的。首先，动态的部分是用 Java 编写的，而不是用 Visual Basic 或其他特定的语言编写，所以它使用起来更强大并且更容易。第二，它可以移植到其他操作系统和非 microsoft 的 Web 服务器中。\n* 与 Pure Servlets 相比： 与用大量的 println 语句生成 HTML 相比，JSP 能够更方便的写 (和修改!) 常规的 HTML。\n* 与 Server-Side Includes(SSI)相比： SSI 只是用于简单的包含物，而不是用于使用表单数据、创建数据库链接等的 “真正的” 程序。\n* 与 JavaScript 相比： JavaScript 可以在客户端动态地生成 HTML，但很难与 web 服务器交互来执行复杂的任务，如数据库访问、图像处理等。\n\n与 Static HTML 相比： 当然，常规的 HTML 不能包含动态的信息。\n\n---\n\n## JSP 案例\n\nServlet 就是一个能处理 HTTP 请求，发送 HTTP 响应的小程序，而发送响应无非就是获取 PrintWriter，然后输出 HTML：\n```\nPrintWriter pw = resp.getWriter();\npw.write(\"<html>\");\npw.write(\"<body>\");\npw.write(\"<h1>Welcome, \" + name + \"!</h1>\");\npw.write(\"</body>\");\npw.write(\"</html>\");\npw.flush();\n```\n只不过，用 PrintWriter 输出 HTML 比较痛苦，因为不但要正确编写 HTML，还需要插入各种变量。如果想在 Servlet 中输出一个类似新浪首页的 HTML，写对 HTML 基本上不太可能。\n\nJSP 是 Java Server Pages 的缩写，它的文件必须放到 `/src/main/webapp` 下，文件名必须以. jsp 结尾，整个文件与 HTML 并无太大区别，但需要插入变量，或者动态输出的地方，使用特殊指令 `<% ... %>`。\n\n我们来编写一个 hello.jsp，内容如下：\n```java\n<html>\n<head>\n    <title>Hello World - JSP</title>\n</head>\n<body>\n    <%-- JSP Comment --%>\n    <h1>Hello World!</h1>\n    <p>\n    <%\n         out.println(\"Your IP address is \");\n    %>\n    <span style=\"color:red\">\n        <%= request.getRemoteAddr() %>\n    </span>\n    </p>\n</body>\n</html>\n```\n\n整个 JSP 的内容实际上是一个 HTML，但是稍有不同：\n\n包含在 `<%--` 和 `--%>` 之间的是 JSP 的注释，它们会被完全忽略；\n包含在 `<%` 和 `%>` 之间的是 Java 代码，可以编写任意 Java 代码；\n如果使用 `<%= xxx %>` 则可以快捷输出一个变量的值。\n\nJSP 页面内置了几个变量：\n* out：表示 HttpServletResponse 的 PrintWriter；\n* session：表示当前 HttpSession 对象；\n* request：表示 HttpServletRequest 对象。\n\n这几个变量可以直接使用。\n\n访问 JSP 页面时，直接指定完整路径。例如，http://localhost:8080/hello.jsp，浏览器显示如下：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/jsp/jsp/1.png)\n\nJSP 和 Servlet 有什么区别？其实它们没有任何区别，因为 JSP 在执行前首先被编译成一个 Servlet。在 Tomcat 的临时目录下，可以找到一个 hello_jsp.java 的源文件，这个文件就是 Tomcat 把 JSP 自动转换成的 Servlet 源码\n\n可见 JSP 本质上就是一个 Servlet，只不过无需配置映射路径，Web Server 会根据路径查找对应的 .jsp 文件，如果找到了，就自动编译成 Servlet 再执行。在服务器运行过程中，如果修改了 JSP 的内容，那么服务器会自动重新编译。\n\n---\n\n## JSP 高级功能\n\nJSP 的指令非常复杂，除了 <% ... %> 外，JSP 页面本身可以通过 page 指令引入 Java 类：\n\n```java\n<%@ page import=\"java.io.*\" %>\n<%@ page import=\"java.util.*\" %>\n```\n\n这样后续的 Java 代码才能引用简单类名而不是完整类名。\n\n使用 include 指令可以引入另一个 JSP 文件：\n```java\n<html>\n<body>\n    <%@ include file=\"header.jsp\"%>\n    <h1>Index Page</h1>\n    <%@ include file=\"footer.jsp\"%>\n</body>\n```\n\n**Jsp 的定义格式：**\n\n1. `<%  代码 %>`：定义的 java 代码，在 service 方法中。service 方法中可以定义什么，该脚本中就可以定义什么。\n2. `<%! 代码 %>`：定义的 java 代码，在 jsp 转换后的 java 类的成员位置。\n3. `<%= 代码 %>`：定义的 java 代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。\n\n```\n<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>\n```\n\n**Jsp 指令：**\n\n1. page ：配置 JSP 页面的\n\t* contentType：等同于 `response.setContentType()`\n\t\t1. 设置响应体的 mime 类型以及字符集\n\t\t2. 设置当前 jsp 页面的编码（只能是高级的 IDE 才能生效，如果使用低级工具，则需要设置 pageEncoding 属性设置当前页面的字符集）\n\t* import：导包\n\t* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面\n\t* isErrorPage：标识当前也是是否是错误页面。\n\t\t* true：是，可以使用内置对象 exception\n\t\t* false：否。默认值。不可以使用内置对象 exception\n\n2. include ：页面包含的。导入页面的资源文件\n\t* `<%@include file=\"top.jsp\"%>`\n\n3. taglib ：导入资源\n\t* `<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>`\n\t\t* prefix：前缀，自定义的\n\n---\n\n## JSP Tag\n\nJSP 还允许自定义输出的 tag，例如：\n```java\n<c:out value = \"${sessionScope.user.name}\"/>\n```\n\nJSP Tag 需要正确引入 taglib 的 jar 包，并且还需要正确声明，使用起来非常复杂，对于页面开发来说，不推荐使用 JSP Tag，因为我们后续会介绍更简单的模板引擎，这里我们不再介绍如何使用 taglib。\n\n---\n\n## Source & Reference\n\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1266262958498784\n- https://www.cnblogs.com/nice0e3/p/13544145.html\n", "timestamp": "2025-10-19T19:25:25.390891"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/servlet/servlet-1.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/servlet/servlet-1.md", "content": "# servlet-1\n\n---\n\n## 基础概念\n\nJava servlet 是运行在 Web 或应用服务器上的程序，作为在来自 Web 浏览器或其他 HTTP 客户机的请求和在 HTTP 服务器上的数据库或应用程序的中间层。\n\nServlet 其实就是一个接口，定义了 Java 的类被浏览器访问到 tomcat 的规则，后面会定义一个实现类，来实现 Servlet 接口的方法。\n\nServlet 为构建基于 Web 的应用程序提供了一个基于组件的、独立于平台的方法，没有 CGI 程序的性能限制。Servlet 访问 Java API 的整个家族，包括 JDBC API 来访问企业数据库。\n\n代码文件不能放在 WEB-INF 文件目录下，放在该文件目录下是无法执行的。\n\n在我们部署 jsp 网站的时候通常都是将文件打包成 war 包，然后再进行上传，上传后会自动进行解压，那么我们来看看 war 包的结构。\n\n```\nWebContent                  站点根目录\n|\n|--META-INF                 META-INF文件夹\n|   |---MANIFEST.MF         配置清单文件\n|---WEB-INF                 WEB-INF文件夹\n|   |---web.xml             站点配置文件\n|   |---lib                 第三方库文件夹\n|   |   |---*.jar           程序需要的jar包\n|   |---classes             放置字节码文件的目录\n|       |---*.class         class文件\n|---<userdir>               自定义的目录\n|   |---*.jsp,*.js,*.css    自定义的资源文件\n|---<userfiles>             自定义的资源文件\n```\n\ntomcat网站虚拟路径配置\n```xml\n配置conf/server.xml文件\n在<Host>标签体中配置\n\n<Context docBase=\"D:\\hello\" path=\"/hehe\" />\n\n* docBase:项目存放的路径\n* path：虚拟目录\n```\n\n配置完成后，我们访问 127.0.0.1:8080/hehe 的时候，tomcat 中间件会查找本机 d 盘下的 hello 目录。\n\n还有种方法是直接写 xx.xml 到 tomcat\\conf\\Catalina\\localhost 目录下，这样也能实现同样的效果。\n```xml\n在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写\n<Context docBase=\"D:\\hello\" />\n* 虚拟目录：xml文件的名称\n```\n\n**Servlets 任务**\n\nServlet 执行以下主要任务：\n\n* 读取由客户端（浏览器）发送的显式数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。\n\n* 读取由客户端（浏览器）发送的隐式 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。\n\n* 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算响应。\n\n* 发送显式数据（即文档）到客户端（浏览器）。该文档可以以多种多样的格式被发送，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。\n\n* 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。\n\n---\n\n## 环境配置\n\n设置 Java 开发工具包,确保 `java`、`javac` 都可以正常输出\n\n如果你运行的是 Windows 操作系统且 SDK 安装在 C:\\jdk1.6.0_20 中，那么在你的 C:\\autoexec.bat 文件中放入下列的行：\n```bash\nset PATH=C:\\jdk1.5.0_20\\bin;%PATH%\nset JAVA_HOME=C:\\jdk1.5.0_20\n```\n\n在 Linux 操作系统中，如果 SDK 安装在 /usr/local/jdk1.6.0_20 中,则在你的 ~/.bash_profile 文件中放入下列的行：\n```bash\nPATH=$PATH:/usr/local/jdk1.6.0_20/bin\nJAVA_HOME=/usr/local/jdk1.6.0_20\n```\n\n设置 Web 服务器：Tomcat\n\nApache Tomcat 是 Java Servlet 和 JavaServer Pages 技术的开源软件实现，可以作为测试 servlets 的独立服务器，而且可以用 Apache Web 服务器集成。下面是在你的电脑上安装 Tomcat 的步骤：\n\n从 http://tomcat.apache.org/ 上下载最新版本的 Tomcat。\n\n一旦你下载了 Tomcat，将该二进制发布包解压缩到一个方便的位置。例如，如果你使用的是 Windows操作系统，则解压缩到 C:\\apache-tomcat-5.5.29 中，如果你使用的是 Linux/Unix 操作系统，则解压缩到 /usr/local/apache-tomcat-5.5.29 中，并创建指向这些位置的 CATALINA_HOME 环境变量。\n\n在 Windows 操作系统的计算机上，可以通过执行下述命令来启动 Tomcat：\n```bash\n%CATALINA_HOME%\\bin\\startup.bat\n\nor\n\nC:\\apache-tomcat-5.5.29\\bin\\startup.bat\n```\n\n在 Unix（Solaris、Linux 等）操作系统的计算机上，可以通过执行下述命令来启动 Tomcat：\n```bash\n$CATALINA_HOME/bin/startup.sh\n\nor\nchmod 777 -R /root/apache-tomcat-5.5.29/bin/\n/root/apache-tomcat-5.5.29/bin/startup.sh\n```\n\nTomcat 启动后，通过访问 http://localhost:8080/，Tomcat 包含的默认 web 应用程序会变得可用。如果一切顺利，那么启动后会显示默认页面\n\n在 Windows 操作系统的计算机上，可以通过执行下面的命令来停止 Tomcat：\n```bash\nC:\\apache-tomcat-5.5.29\\bin\\shutdown\n```\n\n在 Unix（Solaris、Linux 等）操作系统的计算机上，可以通过执行下面的命令来停止 Tomcat：\n```bash\n/root/apache-tomcat-5.5.29/bin/shutdown.sh\n```\n\n**设置 CLASSPATH**\n\n由于 servlets 不是 Java 平台标准版的组成部分，所以你必须为编译器指定 servlet 类。\n\n如果你运行的是 Windows 操作系统，则需要在你的 C:\\autoexec.bat 文件中放入下列的行：\n```\nset CATALINA=C:\\apache-tomcat-5.5.29\nset CLASSPATH=%CATALINA%\\lib\\servlet-api.jar;%CLASSPATH%\n```\n\n在 Unix（Solaris、Linux 等）操作系统中，如果你使用的是 C shell，则需要在你的 .cshrc 文件中放入下列的行：\n```\nCATALINA=/root/apache-tomcat-8.5.68\nCLASSPATH=$CLASSPATH:$CATALINA/lib/servlet-api.jar\n```\n注意：假设你的开发目录是 C:\\ServletDevel（Windows 操作系统中）或 /user/ServletDevel（UNIX 操作系统中），那么你还需要在 CLASSPATH 中添加这些目录，添加方式与上面的添加方式类似。\n\n---\n\n## 生命周期\n\nServlet 生命周期可被定义为从它被创建直到被销毁的整个过程。以下是 servlet 遵循的过程：\n* 通过调用 `init()` 方法 servlet 被初始化。\n* Servlet 调用 `service()` 方法来处理客户端的请求。\n* 通过调用 `destroy()` 方法 servlet 终止。\n* 最后，servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/1.png)\n\n上图显示了一个典型的 servlet 生命周期场景。\n\n最先到达服务器的 HTTP 请求被委派到 servlet 容器。\n\n在调用 `service()` 方法之前 servlet 容器加载 servlet。\n\n然后 servlet 容器通过产生多个线程来处理多个请求，每个线程执行 servlet 的单个实例的 `service()` 方法。\n\n### init() 方法\n\ninit 方法被设计成只调用一次。它在第一次创建 servlet 时被调用，在后续每次用户请求时不再调用。因此，它用于一次性初始化，与 applets 的 init 方法一样。\n\n通常情况下，当用户第一次调用对应于该 servlet 的 URL 时，servlet 被创建，但是当服务器第一次启动时，你也可以指定 servlet 被加载。\n\n当用户调用 servlet 时，每个 servlet 的一个实例就会被创建，并且每一个用户请求都会产生一个新的线程，该线程在适当的时候移交给 doGet 或 doPost 方法。`init()` 方法简单地创建或加载一些数据，这些数据将被用于 servlet 的整个生命周期。\n\ninit 方法的定义如下：\n```java\npublic void init() throws ServletException {\n  // Initialization code...\n}\n```\n\n### service() 方法\n\n`service()` 方法是执行实际任务的主要方法。Servlet 容器（即 web 服务器）调用 `service()` 方法来处理来自客户端（浏览器）的请求，并将格式化的响应写回到客户端。\n\n每次服务器接收到一个 servlet 请求时，服务器会产生一个新的线程并调用服务。`service()` 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。\n\n下面是该方法的特征：\n```java\npublic void service(ServletRequest request,\n                    ServletResponse response)\n      throws ServletException, IOException{\n}\n```\n\n`service()` 方法由容器调用，且 service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等。所以对 `service()` 方法你什么都不需要做，只是根据你接收到的来自客户端的请求类型来重写 `doGet()` 或 `doPost()`。\n\n`doGet()` 和 `doPost()` 方法在每次服务请求中是最常用的方法。下面是这两种方法的特征。\n\n### doGet() 方法\n\nGET 请求来自于一个 URL 的正常请求，或者来自于一个没有 METHOD 指定的 HTML 表单，且它由 `doGet()` 方法处理。\n\n```java\npublic void doGet(HttpServletRequest request,\n                  HttpServletResponse response)\n    throws ServletException, IOException {\n    // Servlet code\n}\n```\n\n### doPost() 方法\n\nPOST 请求来自于一个 HTML 表单，该表单特别的将 POST 列为 METHOD 且它由 `doPost()` 方法处理。\n\n```java\npublic void doPost(HttpServletRequest request,\n                   HttpServletResponse response)\n    throws ServletException, IOException {\n    // Servlet code\n}\n```\n\n### destroy() 方法\n\n`destroy()` 方法只在 servlet 生命周期结束时被调用一次。`destroy()` 方法可以让你的 servlet 关闭数据库连接、停止后台线程、将 cookie 列表或点击计数器写入磁盘，并执行其他类似的清理活动。\n\n在调用 `destroy()` 方法之后，servlet 对象被标记用于垃圾回收。destroy 方法的定义如下所示：\n```java\npublic void destroy() {\n    // Finalization code...\n  }\n```\n\n---\n\n## 实例\n\nServlets 是 Java 类，服务于 HTTP 请求并实现了 javax.servlet.Servlet 接口。Web 应用程序开发人员通常编写扩展 javax.servlet.http.HttpServlet 的 servlets，它是一个实现了 Servlet 接口的抽象类并且是为处理 HTTP 请求专门设计的。\n\n我们来实现一个最简单的Servlet：\n```java\n// WebServlet注解表示这是一个Servlet，并映射到地址/:\n@WebServlet(urlPatterns = \"/\")\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        // 设置响应类型:\n        resp.setContentType(\"text/html\");\n        // 获取输出流:\n        PrintWriter pw = resp.getWriter();\n        // 写入响应:\n        pw.write(\"<h1>Hello, world!</h1>\");\n        // 最后不要忘记flush强制输出:\n        pw.flush();\n    }\n}\n```\n\n一个 Servlet 总是继承自 HttpServlet，然后覆写 `doGet()` 或 `doPost()` 方法。注意到 `doGet()` 方法传入了 HttpServletRequest 和 HttpServletResponse 两个对象，分别代表 HTTP 请求和响应。我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 HttpServletRequest 和 HttpServletResponse 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 PrintWriter，写入响应即可。\n\nServlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。编写 pom.xml 文件如下：\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.itranswarp.learnjava</groupId>\n    <artifactId>web-servlet-hello</artifactId>\n    <packaging>war</packaging>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <java.version>11</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <finalName>hello</finalName>\n    </build>\n</project>\n```\n\n注意到这个 pom.xml 与前面我们讲到的普通 Java 程序有个区别，打包类型不是 jar，而是 war，表示 Java Web Application Archive：\n```xml\n<packaging>war</packaging>\n```\n\n引入的 Servlet API 如下：\n```xml\n<dependency>\n    <groupId>javax.servlet</groupId>\n    <artifactId>javax.servlet-api</artifactId>\n    <version>4.0.0</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n注意到 `<scope>` 指定为 provided，表示编译时使用，但不会打包到 .war 文件中，因为运行期 Web 服务器本身已经提供了 Servlet API 相关的 jar 包。\n\n我们还需要在工程目录下创建一个 web.xml 描述文件，放到 src/main/webapp/WEB-INF 目录下（固定目录结构，不要修改路径，注意大小写）。文件内容可以固定如下：\n```xml\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\">\n<web-app>\n  <display-name>Archetype Created Web Application</display-name>\n</web-app>\n```\n\n整个工程结构如下：\n```\nweb-servlet-hello\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── com\n        │        └── test\n        │               └── servlet\n        │                      └── HelloServlet.java\n        ├── resources\n        └── webapp\n            └── WEB-INF\n                └── web.xml\n```\n\n运行 Maven 命令 mvn clean package，在 target 目录下得到一个 hello.war 文件，这个文件就是我们编译打包后的 Web 应用程序。\n\n普通的 Java 程序是通过启动 JVM，然后执行 `main()` 方法开始运行。但是 Web 应用程序有所不同，我们无法直接运行 war 文件，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 HelloServlet，这样就可以让 HelloServlet 处理浏览器发送的请求。\n\n把 hello.war 复制到 Tomcat 的 webapps 目录下，然后切换到 bin 目录，执行 startup.sh 或 startup.bat 启动 Tomcat 服务器\n\n在浏览器输入 http://localhost:8080/hello/ 即可看到 HelloServlet 的输出\n\n---\n\n## Maven tomcat 插件\n\n- http://tomcat.apache.org/maven-plugin-2.2/index.html\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.itranswarp.learnjava</groupId>\n    <artifactId>web-servlet-hello</artifactId>\n    <packaging>war</packaging>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <java.version>8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <finalName>hello</finalName>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <configuration>\n                    <hostName>localhost</hostName>\n                    <port>8080</port>\n                    <path>/hello</path>\n                    <uriEncoding>UTF-8</uriEncoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n```\ntomcat7:deploy --部署web war包\ntomcat7:redeploy --重新部署web war包\ntomcat7:undeploy --停止该项目运行，并删除部署的war包\ntomcat7:run --启动嵌入式tomcat ，并运行当前项目\ntomcat7:exec-war --创建一个可执行的jar文件，允许使用java -jar mywebapp.jar 运行web项目\ntomcat7:help --在tomcat7-maven-plugin显示帮助信息\n```\n\nTomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：\n* 启动 JVM 并执行 Tomcat 的 `main()` 方法；\n* 加载 war 并初始化 Servlet；\n* 正常服务。\n\n启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 main() 方法，我们完全可以把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 main() 方法，先启动 Tomcat，然后让它加载我们的 webapp 就行。\n\n我们新建一个web-servlet-embedded工程，编写pom.xml如下：\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.itranswarp.learnjava</groupId>\n    <artifactId>web-servlet-embedded</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <packaging>war</packaging>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <java.version>11</java.version>\n        <tomcat.version>9.0.26</tomcat.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-core</artifactId>\n            <version>${tomcat.version}</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n            <version>${tomcat.version}</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n其中，`<packaging>` 类型仍然为 war，引入依赖 tomcat-embed-core 和 tomcat-embed-jasper，引入的 Tomcat 版本 `<tomcat.version>` 为 9.0.26。\n\n不必引入 Servlet API，因为引入 Tomcat 依赖后自动引入了 Servlet API。因此，我们可以正常编写 Servlet 如下：\n```java\n@WebServlet(urlPatterns = \"/\")\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html\");\n        String name = req.getParameter(\"name\");\n        if (name == null) {\n            name = \"world\";\n        }\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<h1>Hello, \" + name + \"!</h1>\");\n        pw.flush();\n    }\n}\n```\n\n编写一个 main() 方法，启动 Tomcat 服务器\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 启动Tomcat:\n        Tomcat tomcat = new Tomcat();\n        tomcat.setPort(Integer.getInteger(\"port\", 8080));\n        tomcat.getConnector();\n        // 创建webapp:\n        Context ctx = tomcat.addWebapp(\"\", new File(\"src/main/webapp\").getAbsolutePath());\n        WebResourceRoot resources = new StandardRoot(ctx);\n        resources.addPreResources(\n                new DirResourceSet(resources, \"/WEB-INF/classes\", new File(\"target/classes\").getAbsolutePath(), \"/\"));\n        ctx.setResources(resources);\n        tomcat.start();\n        tomcat.getServer().await();\n    }\n}\n```\n\n这样，我们直接运行 `main()` 方法，即可启动嵌入式 Tomcat 服务器，然后，通过预设的 `tomcat.addWebapp(\"\", new File(\"src/main/webapp\")` ，Tomcat 会自动加载当前工程作为根 webapp，可直接在浏览器访问 http://localhost:8080/\n\n记得创建 webapp 目录并创建 WEB-INF 文件夹,创建 web.xml 文件\n```\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <display-name>Web Application</display-name>\n</web-app>\n\n```\n\n启动 main() 方法 报错解决方案如下:\n```\n错误: 无法初始化主类 Main\n\n原因: java.lang.NoClassDefFoundError: org/apache/catalina/WebResourceRoot\n\n解决\n打开idea的Run/Debug Configurations:\n选择Application - Main\n右侧Configuration：Use classpath of module\n钩上☑︎Include dependencies with \"Provided\" scope\n```\n\n通过 `main()` 方法启动 Tomcat 服务器并加载我们自己的 webapp 有如下好处：\n1. 启动简单，无需下载 Tomcat 或安装任何 IDE 插件；\n2. 调试方便，可在 IDE 中使用断点调试；\n3. 使用 Maven 创建 war 包后，也可以正常部署到独立的 Tomcat 服务器中。\n\nSpringBoot 也支持在 `main()` 方法中一行代码直接启动 Tomcat，并且还能方便地更换成 Jetty 等其他服务器。它的启动方式和我们介绍的是基本一样的，后续涉及到 SpringBoot 的部分我们还会详细讲解。\n\n开发 Servlet 时，推荐使用 `main()` 方法启动嵌入式 Tomcat 服务器并加载当前工程的 webapp，便于开发调试，且不影响打包部署，能极大地提升开发效率。\n\n---\n\n一个 Web App 就是由一个或多个 Servlet 组成的，每个 Servlet 通过注解说明自己能处理的路径。例如：\n```java\n@WebServlet(urlPatterns = \"/hello\")\npublic class HelloServlet extends HttpServlet {\n    ...\n}\n```\n上述 HelloServlet 能处理 /hello 这个路径的请求。\n\n> 早期的 Servlet 需要在 web.xml 中配置映射路径，但最新 Servlet 版本只需要通过注解就可以完成映射。\n\n因为浏览器发送请求的时候，还会有请求方法（HTTP Method）：即 GET、POST、PUT 等不同类型的请求。因此，要处理 GET 请求，我们要覆写 doGet() 方法：\n```java\n@WebServlet(urlPatterns = \"/hello\")\npublic class HelloServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ...\n    }\n}\n```\n\n类似的，要处理 POST 请求，就需要覆写 `doPost()` 方法。\n\n如果没有覆写 `doPost()` 方法，那么 HelloServlet 能不能处理 POST /hello 请求呢？\n\n我们查看一下 HttpServlet 的 `doPost()` 方法就一目了然了：它会直接返回 405 或 400 错误。因此，一个 Servlet 如果映射到 /hello，那么所有请求方法都会由这个 Servlet 处理，至于能不能返回 200 成功响应，要看有没有覆写对应的请求方法。\n\n一个 Webapp 完全可以有多个 Servlet，分别映射不同的路径。例如：\n```java\n@WebServlet(urlPatterns = \"/hello\")\npublic class HelloServlet extends HttpServlet {\n    ...\n}\n\n@WebServlet(urlPatterns = \"/signin\")\npublic class SignInServlet extends HttpServlet {\n    ...\n}\n\n@WebServlet(urlPatterns = \"/\")\npublic class IndexServlet extends HttpServlet {\n    ...\n}\n```\n\n浏览器发出的 HTTP 请求总是由 Web Server 先接收，然后，根据 Servlet 配置的映射，不同的路径转发到不同的 Servlet：\n```\n               ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n\n               │            /hello    ┌───────────────┐│\n                          ┌──────────>│ HelloServlet  │\n               │          │           └───────────────┘│\n┌───────┐    ┌──────────┐ │ /signin   ┌───────────────┐\n│Browser│───>│Dispatcher│─┼──────────>│ SignInServlet ││\n└───────┘    └──────────┘ │           └───────────────┘\n               │          │ /         ┌───────────────┐│\n                          └──────────>│ IndexServlet  │\n               │                      └───────────────┘│\n                              Web Server\n               └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\n这种根据路径转发的功能我们一般称为 Dispatch。映射到 / 的 IndexServlet 比较特殊，它实际上会接收所有未匹配的路径，相当于 /*，因为 Dispatcher 的逻辑可以用伪代码实现如下：\n```java\nString path = ...\nif (path.equals(\"/hello\")) {\n    dispatchTo(helloServlet);\n} else if (path.equals(\"/signin\")) {\n    dispatchTo(signinServlet);\n} else {\n    // 所有未匹配的路径均转发到\"/\"\n    dispatchTo(indexServlet);\n}\n```\n\n所以我们在浏览器输入一个 http://localhost:8080/abc 也会看到 IndexServlet 生成的页面。\n\n---\n\n## Request和Response\n\n在 b/s 架构里面，请求和响应是必不可少的。访问网页时，会发出一个 request 请求，服务器接收到请求后，根据设定代码，给我们响应对应的内容。\n\nrequest对象是来获取请求消息，response对象是来设置响应消息\n\n### HttpServletRequest\n\n`HttpServletRequest` 封装了一个 HTTP 请求，它实际上是从 ServletRequest 继承而来。最早设计 Servlet 时，设计者希望 Servlet 不仅能处理 HTTP，也能处理类似 SMTP 等其他协议，因此，单独抽出了 ServletRequest 接口，但实际上除了 HTTP 外，并没有其他协议会用 Servlet 处理，所以这是一个过度设计。\n\n我们通过 `HttpServletRequest` 提供的接口方法可以拿到 HTTP 请求的几乎全部信息，常用的方法有：\n* getMethod()：返回请求方法，例如，`\"GET\"`，`\"POST\"`；\n* getRequestURI()：返回请求路径，但不包括请求参数，例如，`\"/hello\"`；\n* getQueryString()：返回请求参数，例如，`\"name=Bob&a=1&b=2\"`；\n* getParameter(name)：返回请求参数，GET 请求从 URL 读取参数，POST 请求从 Body 中读取参数；\n* getContentType()：获取请求 Body 的类型，例如，`\"application/x-www-form-urlencoded\"`；\n* getContextPath()：获取当前 Webapp 挂载的路径，对于 ROOT 来说，总是返回空字符串 `\"\"`；\n* getCookies()：返回请求携带的所有 Cookie；\n* getHeader(name)：获取指定的 Header，对 Header 名称不区分大小写；\n* getHeaderNames()：返回所有 Header 名称；\n* getInputStream()：如果该请求带有 HTTP Body，该方法将打开一个输入流用于读取 Body；\n* getReader()：和 getInputStream() 类似，但打开的是 Reader；\n* getRemoteAddr()：返回客户端的 IP 地址；\n* getScheme()：返回协议类型，例如，`\"http\"`，`\"https\"`；\n\n此外，HttpServletRequest 还有两个方法：`setAttribute()` 和 `getAttribute()`，可以给当前 HttpServletRequest 对象附加多个 Key-Value，相当于把 HttpServletRequest 当作一个 `Map<String, Object>` 使用。\n\n调用 HttpServletRequest 的方法时，注意务必阅读接口方法的文档说明，因为有的方法会返回 null，例如 `getQueryString()` 的文档就写了：\n```\n... This method returns null if the URL does not have a query string...\n```\n\n---\n\n### HttpServletResponse\n\nHttpServletResponse 封装了一个 HTTP 响应。由于 HTTP 响应必须先发送 Header，再发送 Body，所以，操作 HttpServletResponse 对象时，必须先调用设置 Header 的方法，最后调用发送 Body 的方法。\n\n常用的设置 Header 的方法有：\n* setStatus(sc)：设置响应代码，默认是 `200`；\n* setContentType(type)：设置 Body 的类型，例如，`\"text/html\"`；\n* setCharacterEncoding(charset)：设置字符编码，例如，`\"UTF-8\"`；\n* setHeader(name, value)：设置一个 Header 的值；\n* addCookie(cookie)：给响应添加一个 Cookie；\n* addHeader(name, value)：给响应添加一个 Header，因为 HTTP 协议允许有多个相同的 Header；\n\n写入响应时，需要通过 `getOutputStream()` 获取写入流，或者通过 `getWriter()` 获取字符流，二者只能获取其中一个。\n\n写入响应前，无需设置 `setContentLength()`，因为底层服务器会根据写入的字节数自动设置，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用 Chunked 编码让浏览器能识别数据结束符而不需要设置 Content-Length 头。\n\n但是，写入完毕后调用 `flush()` 却是必须的，因为大部分 Web 服务器都基于 HTTP/1.1 协议，会复用 TCP 连接。如果没有调用 `flush()`，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用 `close()`，原因同样是因为会复用 TCP 连接，如果关闭写入流，将关闭 TCP 连接，使得 Web 服务器无法复用此 TCP 连接。\n\n> 写入完毕后对输出流调用 `flush()` 而不是 `close()` 方法！\n\n有了 `HttpServletRequest` 和 `HttpServletResponse` 这两个高级接口，我们就不需要直接处理 HTTP 协议。注意到具体的实现类是由各服务器提供的，而我们编写的 Web 应用程序只关心接口方法，并不需要关心具体实现的子类。\n\n---\n\n### ServletContext\n\nServletContext: 代表整个web应用，可以和程序的容器(服务器)来通信\n\n常用方法：\n```java\nrequest.getServletContext();   : 通过request对象获取\nthis.getServletContext();     : 通过HttpServlet获取\n\nString getMimeType(String file)  : 获取MIME对象\n\n\n域对象：共享数据\n\n1. setAttribute(String name,Object value)\n2. getAttribute(String name)\n3. removeAttribute(String name)\n\n获取文件的真实(服务器)路径：\n\nString getRealPath(String path)\n```\n\n文件下载案例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>downlaod</title>\n</head>\n<body>\n\n<a href=\"/demo/img/1.jpg\">图片查看</a>\n\n<a href=\"downloadServlet?filename=1.jpg\">图片下载</a>\n\n</body>\n</html>\n```\n\ndownloadSerlet类\n```java\n@WebServlet(\"/downloadServlet\")\npublic class downloadServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        this.doGet(request,response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        String filename = request.getParameter(\"filename\");  //接收filename传参的值\n        ServletContext servletContext = this.getServletContext();   //创建servletContext 对象\n        String Path = servletContext.getRealPath(\"/img/\" + filename);  //获取文件真实路径\n\n        String mimeType = servletContext.getMimeType(filename);//获取mimel类型\n\n        FileInputStream fis = new FileInputStream(Path);   //路径参数文件输入流对象中\n        response.setHeader(\"content-type\",mimeType);  //响应头设置mime类型\n        response.setHeader(\"content-disposition\",\"attachment;filename=\"+filename); //设置为附件类型\n            ServletOutputStream outputStream = response.getOutputStream();   //获取文件输出流\n            byte[] buff = new byte[1024];   //设置每次读取的字节大小\n            int len =0;\n            while ((len = fis.read(buff))!=-1){\n\n                outputStream.write(buff,0,len);\n            }\n\n    }\n}\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/6.png)\n\n---\n\n## Servlet 多线程模型\n\n一个 Servlet 类在服务器中只有一个实例，但对于每个 HTTP 请求，Web 服务器会使用多线程执行请求。因此，一个 Servlet 的 `doGet()`、`doPost()` 等处理请求的方法是多线程并发执行的。如果 Servlet 中定义了字段，要注意多线程并发访问的问题：\n\n```java\npublic class HelloServlet extends HttpServlet {\n    private Map<String, String> map = new ConcurrentHashMap<>();\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 注意读写map字段是多线程并发的:\n        this.map.put(key, value);\n    }\n}\n```\n\n对于每个请求，Web 服务器会创建唯一的 `HttpServletRequest` 和 `HttpServletResponse` `实例，因此，HttpServletRequest` 和 `HttpServletResponse` 实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。\n\n一个 Webapp 中的多个 Servlet 依靠路径映射来处理不同的请求；\n\n映射为 `/` 的 Servlet 可处理所有 “未匹配” 的请求；\n\n如何处理请求取决于 Servlet 覆写的对应方法；\n\nWeb 服务器通过多线程处理 HTTP 请求，一个 Servlet 的处理方法可以由多线程并发执行。\n\n---\n\n## 重定向与转发\n\n### Redirect\n\n重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。\n\n例如，我们已经编写了一个能处理 `/hello` 的 `HelloServlet`，如果收到的路径为 `/hi`，希望能重定向到 `/hello`，可以再编写一个 `RedirectServlet`：\n```java\n@WebServlet(urlPatterns = \"/hi\")\npublic class RedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 构造重定向的路径:\n        String name = req.getParameter(\"name\");\n        String redirectToUrl = \"/hello\" + (name == null ? \"\" : \"?name=\" + name);\n        // 发送重定向响应:\n        resp.sendRedirect(redirectToUrl);\n    }\n}\n```\n\n如果浏览器发送 `GET /hi` 请求，`RedirectServlet` 将处理此请求。由于 `RedirectServlet` 在内部又发送了重定向响应，因此，浏览器会收到如下响应：\n```\nHTTP/1.1 302 Found\nLocation: /hello\n```\n\n当浏览器收到 302 响应后，它会立刻根据 `Location` 的指示发送一个新的 `GET /hello` 请求，这个过程就是重定向：\n\n```\n┌───────┐   GET /hi     ┌───────────────┐\n│Browser│ ────────────> │RedirectServlet│\n│       │ <──────────── │               │\n└───────┘   302         └───────────────┘\n\n\n┌───────┐  GET /hello   ┌───────────────┐\n│Browser│ ────────────> │ HelloServlet  │\n│       │ <──────────── │               │\n└───────┘   200 <html>  └───────────────┘\n```\n\n观察Chrome浏览器的网络请求，可以看到两次HTTP请求：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/2.png)\n\n并且浏览器的地址栏路径自动更新为 /hello。\n\n重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存 /hi 到 /hello 这个重定向的关联，下次请求 /hi 的时候，浏览器就直接发送 /hello 请求了。\n\n重定向有什么作用？重定向的目的是当 Web 应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。\n\nHttpServletResponse 提供了快捷的 `redirect()` 方法实现 302 重定向。如果要实现 301 永久重定向，可以这么写：\n```java\nresp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301\nresp.setHeader(\"Location\", \"/hello\");\n```\n\n### Forward\n\nForward 是指内部转发。当一个 Servlet 处理请求的时候，它可以决定自己不继续处理，而是转发给另一个 Servlet 处理。\n\n例如，我们已经编写了一个能处理 /hello 的 HelloServlet，继续编写一个能处理 /morning 的 ForwardServlet：\n\n```java\n@WebServlet(urlPatterns = \"/morning\")\npublic class ForwardServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.getRequestDispatcher(\"/hello\").forward(req, resp);\n    }\n}\n```\n\nForwardServlet 在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为 /hello 的 Servlet，即下面的代码：\n```java\nreq.getRequestDispatcher(\"/hello\").forward(req, resp);\n```\n\n后续请求的处理实际上是由 HelloServlet 完成的。这种处理方式称为转发（Forward），我们用流程图画出来如下：\n\n```\n                          ┌────────────────────────┐\n                          │      ┌───────────────┐ │\n                          │ ────>│ForwardServlet │ │\n┌───────┐  GET /morning   │      └───────────────┘ │\n│Browser│ ──────────────> │              │         │\n│       │ <────────────── │              ▼         │\n└───────┘    200 <html>   │      ┌───────────────┐ │\n                          │ <────│ HelloServlet  │ │\n                          │      └───────────────┘ │\n                          │       Web Server       │\n                          └────────────────────────┘\n```\n\n转发和重定向的区别在于，转发是在Web服务器内部完成的，对浏览器来说，它只发出了一个HTTP请求：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/3.png)\n\n注意到使用转发的时候，浏览器的地址栏路径仍然是 /morning，浏览器并不知道该请求在 Web 服务器内部实际上做了一次转发。\n\n---\n\n## 使用 Session 和 Cookie\n\n在 Web 应用程序中，我们经常要跟踪用户身份。当一个用户登录成功后，如果他继续访问其他页面，Web 程序如何才能识别出该用户身份？\n\n因为 HTTP 协议是一个无状态协议，即 Web 应用程序无法区分收到的两个 HTTP 请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一 ID，并以 Cookie 的形式发送到浏览器，浏览器在后续访问时总是附带此 Cookie，这样，服务器就可以识别用户身份。\n\nCookie 和 Session 不同的地方是 cookie 是存在于客户端，而 session 是存在于服务器上。\n\n如果客户端关闭后，服务端不关闭，session 需要相同，则可以创建 Cookie, 键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。\n\n### Session\n\n服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。\n\n我们把这种基于唯一 ID 识别用户身份的机制称为 Session。每个用户第一次访问服务器后，会自动获得一个 Session ID。如果用户在一段时间内没有访问服务器，那么 Session 会自动失效，下次即使带着上次分配的 Session ID 访问，服务器也认为这是一个新用户，会分配新的 Session ID。\n\nJavaEE 的 Servlet 机制内建了对 Session 的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个 `HttpSession` 对象，以便后续访问其他页面的时候，能直接从 `HttpSession` 取出用户名：\n\n```java\n@WebServlet(urlPatterns = \"/signin\")\npublic class SignInServlet extends HttpServlet {\n    // 模拟一个数据库:\n    private Map<String, String> users = Map.of(\"bob\", \"bob123\", \"alice\", \"alice123\", \"tom\", \"tomcat\");\n\n    // GET请求时显示登录页:\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.setContentType(\"text/html\");\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<h1>Sign In</h1>\");\n        pw.write(\"<form action=\\\"/signin\\\" method=\\\"post\\\">\");\n        pw.write(\"<p>Username: <input name=\\\"username\\\"></p>\");\n        pw.write(\"<p>Password: <input name=\\\"password\\\" type=\\\"password\\\"></p>\");\n        pw.write(\"<p><button type=\\\"submit\\\">Sign In</button> <a href=\\\"/\\\">Cancel</a></p>\");\n        pw.write(\"</form>\");\n        pw.flush();\n    }\n\n    // POST请求时处理用户登录:\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String name = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        String expectedPassword = users.get(name.toLowerCase());\n        if (expectedPassword != null && expectedPassword.equals(password)) {\n            // 登录成功:\n            req.getSession().setAttribute(\"user\", name);\n            resp.sendRedirect(\"/\");\n        } else {\n            resp.sendError(HttpServletResponse.SC_FORBIDDEN);\n        }\n    }\n}\n```\n\n上述 `SignInServlet` 在判断用户登录成功后，立刻将用户名放入当前 `HttpSession` 中：\n\n```java\nHttpSession session = req.getSession();\nsession.setAttribute(\"user\", name);\n```\n\n在 `IndexServlet` 中，可以从 `HttpSession` 取出用户名：\n\n```java\n@WebServlet(urlPatterns = \"/\")\npublic class IndexServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 从HttpSession获取当前用户名:\n        String user = (String) req.getSession().getAttribute(\"user\");\n        resp.setContentType(\"text/html\");\n        resp.setCharacterEncoding(\"UTF-8\");\n        resp.setHeader(\"X-Powered-By\", \"JavaEE Servlet\");\n        PrintWriter pw = resp.getWriter();\n        pw.write(\"<h1>Welcome, \" + (user != null ? user : \"Guest\") + \"</h1>\");\n        if (user == null) {\n            // 未登录，显示登录链接:\n            pw.write(\"<p><a href=\\\"/signin\\\">Sign In</a></p>\");\n        } else {\n            // 已登录，显示登出链接:\n            pw.write(\"<p><a href=\\\"/signout\\\">Sign Out</a></p>\");\n        }\n        pw.flush();\n    }\n}\n```\n\n如果用户已登录，可以通过访问 `/signout` 登出。登出逻辑就是从 `HttpSession` 中移除用户相关信息：\n```java\n@WebServlet(urlPatterns = \"/signout\")\npublic class SignOutServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 从HttpSession移除用户名:\n        req.getSession().removeAttribute(\"user\");\n        resp.sendRedirect(\"/\");\n    }\n}\n```\n\n对于 Web 应用程序来说，我们总是通过 `HttpSession` 这个高级接口访问当前 Session。如果要深入理解 Session 原理，可以认为 Web 服务器在内存中自动维护了一个 ID 到 `HttpSession` 的映射表，我们可以用下图表示：\n\n```\n\n           ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n\n           │      ┌───────────────┐                │\n             ┌───>│ IndexServlet  │<──────────┐\n           │ │    └───────────────┘           ▼    │\n┌───────┐    │    ┌───────────────┐      ┌────────┐\n│Browser│──┼─┼───>│ SignInServlet │<────>│Sessions││\n└───────┘    │    └───────────────┘      └────────┘\n           │ │    ┌───────────────┐           ▲    │\n             └───>│SignOutServlet │<──────────┘\n           │      └───────────────┘                │\n\n           └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\n而服务器识别 Session 的关键就是依靠一个名为 `JSESSIONID` 的 Cookie。在 Servlet 中第一次调用 `req.getSession()` 时，Servlet 容器自动创建一个 Session ID，然后通过一个名为 `JSESSIONID` 的 Cookie 发送给浏览器：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/4.png)\n\n这里要注意的几点是：\n* `JSESSIONID` 是由 Servlet 容器自动创建的，目的是维护一个浏览器会话，它和我们的登录逻辑没有关系；\n* 登录和登出的业务逻辑是我们自己根据 `HttpSession` 是否存在一个 `\"user\"` 的 Key 判断的，登出后，Session ID 并不会改变；\n* 即使没有登录功能，仍然可以使用 `HttpSession` 追踪用户，例如，放入一些用户配置信息等。\n\n除了使用 Cookie 机制可以实现 Session 外，还可以通过隐藏表单、URL 末尾附加 ID 来追踪 Session。这些机制很少使用，最常用的 Session 机制仍然是 Cookie。\n\n使用 Session 时，由于服务器把所有用户的 Session 都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的 Session 序列化到磁盘上，这会大大降低服务器的运行效率，因此，放入 Session 的对象要小，通常我们放入一个简单的 `User` 对象就足够了：\n```java\npublic class User {\n    public long id; // 唯一标识\n    public String email;\n    public String name;\n}\n```\n\n在使用多台服务器构成集群时，使用Session会遇到一些额外的问题。通常，多台服务器集群使用反向代理作为网站入口：\n```\n                                     ┌────────────┐\n                                ┌───>│Web Server 1│\n                                │    └────────────┘\n┌───────┐     ┌─────────────┐   │    ┌────────────┐\n│Browser│────>│Reverse Proxy│───┼───>│Web Server 2│\n└───────┘     └─────────────┘   │    └────────────┘\n                                │    ┌────────────┐\n                                └───>│Web Server 3│\n                                     └────────────┘\n```\n\n如果多台 Web Server 采用无状态集群，那么反向代理总是以轮询方式将请求依次转发给每台 Web Server，这会造成一个用户在 Web Server 1 存储的 Session 信息，在 Web Server 2 和 3 上并不存在，即从 Web Server 1 登录后，如果后续请求被转发到 Web Server 2 或 3，那么用户看到的仍然是未登录状态。\n\n要解决这个问题，方案一是在所有 Web Server 之间进行 Session 复制，但这样会严重消耗网络带宽，并且，每个 Web Server 的内存均存储所有用户的 Session，内存使用率很低。\n\n另一个方案是采用粘滞会话（Sticky Session）机制，即反向代理在转发请求的时候，总是根据 JSESSIONID 的值判断，相同的 JSESSIONID 总是转发到固定的 Web Server，但这需要反向代理的支持。\n\n无论采用何种方案，使用 Session 机制，会使得 Web Server 的集群很难扩展，因此，Session 适用于中小型 Web 应用程序。对于大型 Web 应用程序来说，通常需要避免使用 Session 机制。\n\nsession是依赖于cookie的。\n\n当服务器关闭后，会将session序列化到硬盘里面，重启的时候seesion文件会转换为内存中的session对象。\n\nsession默认的过期时间是30秒，如果需要设置可以到tomcat/conf/web.xml文件里面修改。\n\n```xml\n<session-config>\n<session-timeout>60</session-timeout>\n</session-config>\n```\n\n### Cookie\n\ncookie 概念：客户端会话技术，将数据保存到客户端\n\n实际上，Servlet 提供的 `HttpSession` 本质上就是通过一个名为 `JSESSIONID` 的 Cookie 来跟踪用户会话的。除了这个名称外，其他名称的 Cookie 我们可以任意使用。\n\n如果我们想要设置一个 Cookie，例如，记录用户选择的语言，可以编写一个 `LanguageServlet`：\n```java\n@WebServlet(urlPatterns = \"/pref\")\npublic class LanguageServlet extends HttpServlet {\n\n    private static final Set<String> LANGUAGES = Set.of(\"en\", \"zh\");\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String lang = req.getParameter(\"lang\");\n        if (LANGUAGES.contains(lang)) {\n            // 创建一个新的Cookie:\n            Cookie cookie = new Cookie(\"lang\", lang);\n            // 该Cookie生效的路径范围:\n            cookie.setPath(\"/\");\n            // 该Cookie有效期:\n            cookie.setMaxAge(8640000); // 8640000秒=100天\n            // 将该Cookie添加到响应:\n            resp.addCookie(cookie);\n        }\n        resp.sendRedirect(\"/\");\n    }\n}\n```\n\n更新 IndexServlet\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(urlPatterns = \"/\")\npublic class IndexServlet extends HttpServlet {\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\tString user = (String) req.getSession().getAttribute(\"user\");\n\t\tString lang = parseLanguageFromCookie(req);\n\t\tresp.setContentType(\"text/html\");\n\t\tresp.setCharacterEncoding(\"UTF-8\");\n\t\tPrintWriter pw = resp.getWriter();\n\t\tif (lang.equals(\"zh\")) {\n\t\t\tpw.write(\"<h1>你好, \" + (user != null ? user : \"Guest\") + \"</h1>\");\n\t\t\tif (user == null) {\n\t\t\t\tpw.write(\"<p><a href=\\\"/signin\\\">登录</a></p>\");\n\t\t\t} else {\n\t\t\t\tpw.write(\"<p><a href=\\\"/signout\\\">登出</a></p>\");\n\t\t\t}\n\t\t} else {\n\t\t\tpw.write(\"<h1>Welcome, \" + (user != null ? user : \"Guest\") + \"</h1>\");\n\t\t\tif (user == null) {\n\t\t\t\tpw.write(\"<p><a href=\\\"/signin\\\">Sign In</a></p>\");\n\t\t\t} else {\n\t\t\t\tpw.write(\"<p><a href=\\\"/signout\\\">Sign Out</a></p>\");\n\t\t\t}\n\t\t}\n\t\tpw.write(\"<p><a href=\\\"/pref?lang=en\\\">English</a> | <a href=\\\"/pref?lang=zh\\\">中文</a>\");\n\t\tpw.flush();\n\t}\n\n\tprivate String parseLanguageFromCookie(HttpServletRequest req) {\n\t\tCookie[] cookies = req.getCookies();\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(\"lang\")) {\n\t\t\t\t\treturn cookie.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"en\";\n\t}\n}\n```\n\n创建一个新 Cookie 时，除了指定名称和值以外，通常需要设置 `setPath(\"/\")`，浏览器根据此前缀决定是否发送 Cookie。如果一个 Cookie 调用了 `setPath(\"/user/\")`，那么浏览器只有在请求以 / user / 开头的路径时才会附加此 Cookie。通过 `setMaxAge()` 设置 Cookie 的有效期，单位为秒，最后通过 `resp.addCookie()` 把它添加到响应。\n\n如果访问的是 https 网页，还需要调用 `setSecure(true)`，否则浏览器不会发送该 Cookie。\n\n因此，务必注意：浏览器在请求某个 URL 时，是否携带指定的 Cookie，取决于 Cookie 是否满足以下所有要求：\n* URL 前缀是设置 Cookie 时的 Path；\n* Cookie 在有效期内；\n* Cookie 设置了 secure 时必须以 https 访问。\n* 我们可以在浏览器看到服务器发送的 Cookie：\n\n我们可以在浏览器看到服务器发送的Cookie：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet/5.png)\n\n如果我们要读取 Cookie，例如，在 `IndexServlet` 中，读取名为 `lang` 的 Cookie 以获取用户设置的语言，可以写一个方法如下：\n\n```java\nprivate String parseLanguageFromCookie(HttpServletRequest req) {\n    // 获取请求附带的所有Cookie:\n    Cookie[] cookies = req.getCookies();\n    // 如果获取到Cookie:\n    if (cookies != null) {\n        // 循环每个Cookie:\n        for (Cookie cookie : cookies) {\n            // 如果Cookie名称为lang:\n            if (cookie.getName().equals(\"lang\")) {\n                // 返回Cookie的值:\n                return cookie.getValue();\n            }\n        }\n    }\n    // 返回默认值:\n    return \"en\";\n}\n```\n\n可见，读取 Cookie 主要依靠遍历 `HttpServletRequest` 附带的所有 Cookie。\n\n---\n\n## Source & Reference\n\n- [Java学习之servlet篇](https://www.cnblogs.com/nice0e3/p/13515458.html)\n- https://wiki.jikexueyuan.com/project/servlet/environment-setup.html\n- https://www.cnblogs.com/Dhouse/p/5795338.html\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1304265949708322\n- https://cloud.tencent.com/developer/article/1604809\n- https://www.cnblogs.com/hongdada/p/10123128.html\n- https://www.yiibai.com/maven/deploy-maven-based-war-file-to-tomcat.html\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1328705066500130\n- https://www.cnblogs.com/nice0e3/p/13515458.html\n- https://www.cnblogs.com/nice0e3/p/13527094.html\n- https://www.cnblogs.com/nice0e3/p/13532864.html\n", "timestamp": "2025-10-19T19:25:25.867155"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/servlet/servlet-2.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/servlet/servlet-2.md", "content": "# servlet-2\n\n---\n\n## 表单数据\n\n当你需要从浏览器到 Web 服务器传递一些信息并最终传回到后台程序时，你一定遇到了许多情况。浏览器使用两种方法向 Web 服务器传递信息。这些方法是 GET 方法和 POST 方法。\n\n**GET 方法**\n\nGET 方法向页面请求发送已编码的用户信息。页面和已编码的信息用 ? 字符分隔，如下所示：\n- http://www.test.com/hello?key1=value1&key2=value2\n\nGET 方法是从浏览器向 web 服务器传递信息的默认的方法，且它会在你的浏览器的地址栏中产生一个很长的字符串。如果你向服务器传递密码或其他敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。\n\n这些信息使用 QUERY_STRING 头传递，并通过 QUERY_STRING 环境变量访问，Servlet 使用 `doGet()` 方法处理这种类型的请求。\n\n**POST 方法**\n\n一般情况下，将信息传递给后台程序的一种更可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法相同，但是 POST 方法不是把信息作为 URL 中 ? 字符之后的文本字符串进行发送，而是把它作为一个单独的消息发送。消息以标准输出的形式传到后台程序，你可以在你的处理过程中解析并使用这些标准输出。Servlet 使用 `doPost()` 方法处理这种类型的请求。\n\n使用 Servlet 读取表单数据\n\nServlet 以自动解析的方式处理表单数据，根据不同的情况使用如下不同的方法：\n* getParameter()：你可以调用 request.getParameter() 方法来获取表单参数的值。\n* getParameterValues()：如果参数出现不止一次，那么调用该方法并返回多个值，例如复选框。\n* getParameterNames()：如果你想要得到一个当前请求的所有参数的完整列表，那么调用该方法。\n\n### 使用 URL 的 GET 方法实例\n\n这是一个简单的 URL，使用 GET 方法将两个值传递给 HelloForm 程序。\n- http://localhost:8080/HelloForm?first_name=ZARA&last_name=ALI\n\n下面是 HelloForm.java servlet 程序，处理由 web 浏览器给定的输入。我们将使用 getParameter() 方法，使访问传递的信息变得非常容易：\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\npublic class HelloForm extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Using GET Method to Read Form Data\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n                \"<ul>\\n\" +\n                \"  <li><b>First Name</b>: \"\n                + request.getParameter(\"first_name\") + \"\\n\" +\n                \"  <li><b>Last Name</b>: \"\n                + request.getParameter(\"last_name\") + \"\\n\" +\n                \"</ul>\\n\" +\n                \"</body></html>\");\n  }\n}\n```\n\n在 web.xml 文件中创建以下条目：\n```xml\n    <servlet>\n        <servlet-name>HelloForm</servlet-name>\n        <servlet-class>HelloForm</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>HelloForm</servlet-name>\n        <url-pattern>/HelloForm</url-pattern>\n    </servlet-mapping>\n```\n现在在你浏览器的地址栏中输入 http://localhost:8080/HelloForm?first_name=ZARA&last_name=ALI ，并在浏览器中触发上述命令之前，确保你已经启动 Tomcat 服务器。这将产生如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/3.png)\n\n### 使用表单的 GET 方法实例\n\n下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 Servlet HelloForm 来处理这个输入。\n\n```html\n<html>\n<body>\n<form action=\"HelloForm\" method=\"GET\">\nFirst Name: <input type=\"text\" name=\"first_name\">\n<br />\nLast Name: <input type=\"text\" name=\"last_name\" />\n<input type=\"submit\" value=\"Submit\" />\n</form>\n</body>\n</html>\n```\n\n将这个 HTML 保存到 hello.htm 文件中，并把它放在 /webapps/ROOT 目录下。当你访问 http://localhost:8080/Hello.htm 时，下面是上述表单的实际输出。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/4.png)\n\n尝试输入姓名，然后点击提交按钮来在 tomcat 运行的本地计算机上查看结果。基于提供的输入，它会产生与上述例子中相似的结果。\n\n### 使用表单的 POST 方法实例\n\n让我们对上述 servlet 做一点修改，以便它可以处理 GET 方法和 POST 方法。下面是 HelloForm.java servlet 程序，使用 GET 和 POST 方法处理由 web 浏览器给出的输入。\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\npublic class HelloForm extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Using GET Method to Read Form Data\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n                \"<ul>\\n\" +\n                \"  <li><b>First Name</b>: \"\n                + request.getParameter(\"first_name\") + \"\\n\" +\n                \"  <li><b>Last Name</b>: \"\n                + request.getParameter(\"last_name\") + \"\\n\" +\n                \"</ul>\\n\" +\n                \"</body></html>\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n现在编译，部署上述 Servlet，并使用带有 POST 方法的 Hello.htm 测试它，如下所示：\n```html\n<html>\n<body>\n<form action=\"HelloForm\" method=\"POST\">\nFirst Name: <input type=\"text\" name=\"first_name\">\n<br />\nLast Name: <input type=\"text\" name=\"last_name\" />\n<input type=\"submit\" value=\"Submit\" />\n</form>\n</body>\n</html>\n```\n这是上述表单的实际输出，尝试输入姓名，然后点击提交按钮，在 tomcat 运行的本地计算机上查看结果。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/5.png)\n\n### 将复选框数据传递到 Servlet 程序\n\n这是一个 HTML 代码实例，CheckBox.htm，一个表单带有两个复选框。\n```html\n<html>\n<body>\n<form action=\"CheckBox\" method=\"POST\" target=\"_blank\">\n<input type=\"checkbox\" name=\"maths\" checked=\"checked\" /> Maths\n<input type=\"checkbox\" name=\"physics\"  /> Physics\n<input type=\"checkbox\" name=\"chemistry\" checked=\"checked\" />\n                                                Chemistry\n<input type=\"submit\" value=\"Select Subject\" />\n</form>\n</body>\n</html>\n```\n\n下面是 CheckBox.java servlet 程序，来为复选框按钮处理 web 浏览器给定的输入。\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\npublic class CheckBox extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Reading Checkbox Data\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n                \"<ul>\\n\" +\n                \"  <li><b>Maths Flag : </b>: \"\n                + request.getParameter(\"maths\") + \"\\n\" +\n                \"  <li><b>Physics Flag: </b>: \"\n                + request.getParameter(\"physics\") + \"\\n\" +\n                \"  <li><b>Chemistry Flag: </b>: \"\n                + request.getParameter(\"chemistry\") + \"\\n\" +\n                \"</ul>\\n\" +\n                \"</body></html>\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/6.png)\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/7.png)\n\n---\n\n### 读取所有的表单参数\n\n以下是使用 HttpServletRequest 的 `getParameterNames()` 方法的通用实例来读取所有可用的表单参数。该方法返回一个枚举，包含了未指定顺序的参数名称。\n\n一旦我们得到一个枚举，我们可以以标准方式循环这个枚举，使用 `hasMoreElements()` 方法来确定何时停止循环，使用 `nextElement()` 方法来获取每个参数的名称。\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\npublic class ReadParams extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Reading All Form Parameters\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<table width=\\\"100%\\\" border=\\\"1\\\" align=\\\"center\\\">\\n\" +\n        \"<tr bgcolor=\\\"#949494\\\">\\n\" +\n        \"<th>Param Name</th><th>Param Value(s)</th>\\n\"+\n        \"</tr>\\n\");\n      Enumeration paramNames = request.getParameterNames();\n      while(paramNames.hasMoreElements()) {\n         String paramName = (String)paramNames.nextElement();\n         out.print(\"<tr><td>\" + paramName + \"</td>\\n<td>\");\n         String[] paramValues =\n                request.getParameterValues(paramName);\n         // Read single valued data\n         if (paramValues.length == 1) {\n           String paramValue = paramValues[0];\n           if (paramValue.length() == 0)\n             out.println(\"<i>No Value</i>\");\n           else\n             out.println(paramValue);\n         } else {\n             // Read multiple valued data\n             out.println(\"<ul>\");\n             for(int i=0; i < paramValues.length; i++) {\n                out.println(\"<li>\" + paramValues[i]);\n             }\n             out.println(\"</ul>\");\n         }\n      }\n      out.println(\"</tr>\\n</table>\\n</body></html>\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n现在，用下面的表单尝试上述 servlet：\n\n```html\n<html>\n<body>\n<form action=\"ReadParams\" method=\"POST\" target=\"_blank\">\n<input type=\"checkbox\" name=\"maths\" checked=\"checked\" /> Maths\n<input type=\"checkbox\" name=\"physics\"  /> Physics\n<input type=\"checkbox\" name=\"chemistry\" checked=\"checked\" /> Chem\n<input type=\"submit\" value=\"Select Subject\" />\n</form>\n</body>\n</html>\n```\n\n现在使用上述表单调用 servlet 将产生如下所示结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/8.png)\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/9.png)\n\n---\n\n## 客户端 HTTP 请求\n\n当浏览器请求网页时，它会向 web 服务器发送大量信息，这些信息不能被直接读取，因为这些信息是作为 HTTP 请求头的一部分行进的。\n\n下述方法可以用于读取 servlet 程序中的 HTTP 头信息。通过 HttpServletRequest 对象这些方法是可用的。\n\n```\nCookie[] getCookies()\n返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。\n```\n```\nEnumeration getAttributeNames()\n返回一个枚举，包含提供给该请求可用的属性名称。\n```\n```\nEnumeration getHeaderNames()\n返回一个枚举，包含在该请求中包含的所有的头名。\n```\n```\nEnumeration getParameterNames()\n返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。\n```\n```\nHttpSession getSession()\n返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。\n```\n```\nHttpSession getSession(boolean create)\n返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。\n```\n```\nLocale getLocale()\n基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。\n```\n```\nObject getAttribute(String name)\n以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。\n```\n```\nServletInputStream getInputStream()\n使用 ServletInputStream，以二进制数据形式检索请求的主体。\n```\n```\nString getAuthType()\n返回用于保护 Servlet 的身份验证方案的名称，例如，“BASIC” 或 “SSL”，如果JSP没有受到保护则返回 null。\n```\n```\nString getCharacterEncoding()\n返回请求主体中使用的字符编码的名称。\n```\n```\nString getContentType()\n返回请求主体的 MIME 类型，如果不知道类型则返回 null。\n```\n```\nString getContextPath()\n返回指示请求上下文的请求 URI 部分。\n```\n```\nString getHeader(String name)\n以字符串形式返回指定的请求头的值。\n```\n```\nString getMethod()\n返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。\n```\n```\nString getParameter(String name)\n以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。\n```\n```\nString getPathInfo()\n当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。\n```\n```\nString getProtocol()\n返回请求协议的名称和版本。\n```\n```\nString getQueryString()\n返回包含在路径后的请求 URL 中的查询字符串。\n```\n```\nString getRemoteAddr()\n返回发送请求的客户端的互联网协议（IP）地址。\n```\n```\nString getRemoteHost()\n返回发送请求的客户端的完全限定名称。\n```\n```\nString getRemoteUser()\n如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。\n```\n```\nString getRequestURI()\n从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。\n```\n```\nString getRequestedSessionId()\n返回由客户端指定的 session 会话 ID。\n```\n```\nString getServletPath()\n返回调用 JSP 的请求的 URL 的一部分。\n```\n```\nString[] getParameterValues(String name)\n返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。\n```\n```\nboolean isSecure()\n返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。\n```\n```\nint getContentLength()\n以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。\n```\n```\nint getIntHeader(String name)\n返回指定的请求头的值为一个 int 值。\n```\n```\nint getServerPort()\n返回接收到这个请求的端口号。\n```\n\n下述例子使用了 HttpServletRequest 的 `getHeaderNames()` 方法来读取 HTTP 头信息。该方法返回了一个枚举，包含与当前的 HTTP 请求相关的头信息。\n\n一旦我们得到一个枚举，我们可以以标准方式循环这个枚举，使用 `hasMoreElements()` 方法来确定何时停止循环，使用 `nextElement()` 方法来获取每个参数的名称。\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\nimport javax.servlet.annotation.WebServlet;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/DisplayHeader\")\npublic class DisplayHeader extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\"); \n      PrintWriter out = response.getWriter();\n      String title = \"HTTP Header Request Example\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\"+\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<table width=\\\"100%\\\" border=\\\"1\\\" align=\\\"center\\\">\\n\" +\n        \"<tr bgcolor=\\\"#949494\\\">\\n\" +\n        \"<th>Header Name</th><th>Header Value(s)</th>\\n\"+\n        \"</tr>\\n\"); \n      Enumeration headerNames = request.getHeaderNames();\n      while(headerNames.hasMoreElements()) {\n         String paramName = (String)headerNames.nextElement();\n         out.print(\"<tr><td>\" + paramName + \"</td>\\n\");\n         String paramValue = request.getHeader(paramName);\n         out.println(\"<td> \" + paramValue + \"</td></tr>\\n\");\n      }\n      out.println(\"</table>\\n</body></html>\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n现在，调用上述 servlet 会产生如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/11.png)\n\n---\n\n## 服务器 HTTP 响应\n\n正如在前面的章节中讨论的一样，当一个 Web 服务器对浏览器响应一个 HTTP 请求时，响应通常包括一个状态行、一些响应头信息、一个空行和文档。一个典型的响应如下所示：\n\n```\nHTTP/1.1 200 OK\nContent-Type: text/html\nHeader2: ...\n...\nHeaderN: ...\n  (Blank Line)\n<!doctype ...>\n<html>\n<head>...</head>\n<body>\n...\n</body>\n</html>\n```\n\n状态行包括 HTTP 版本（例子中的 HTTP/1.1）、一个状态码（例子中的 200）和一个对应于状态码的短消息（例子中的 OK）。\n\n下面的方法可用于在 servlet 程序中设置 HTTP 响应头信息。通过 HttpServletResponse 对象这些方法是可用的。\n\n```\nString encodeRedirectURL(String url)\n为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。\n```\n```\nString encodeURL(String url)\n对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。\n```\n```\nboolean containsHeader(String name)\n返回一个布尔值，指示是否已经设置已命名的响应头信息。\n```\n```\nboolean isCommitted()\n返回一个布尔值，指示响应是否已经提交。\n```\n```\nvoid addCookie(Cookie cookie)\n把指定的 cookie 添加到响应。\n```\n```\nvoid addDateHeader(String name, long date)\n添加一个带有给定的名称和日期值的响应头信息。\n```\n```\nvoid addHeader(String name, String value)\n添加一个带有给定的名称和值的响应头信息。\n```\n```\nvoid addIntHeader(String name, int value)\n添加一个带有给定的名称和整数值的响应头信息。\n```\n```\nvoid flushBuffer()\n强制任何在缓冲区中的内容被写入到客户端。\n```\n```\nvoid reset()\n清除缓冲区中存在的任何数据，包括状态码和头信息。\n```\n```\nvoid resetBuffer()\n清除响应中基础缓冲区的内容，不清除状态码和头信息。\n```\n```\nvoid sendError(int sc)\n使用指定的状态码发送错误响应到客户端，并清除缓冲区。\n```\n```\nvoid sendError(int sc, String msg)\n使用指定的状态发送错误响应到客户端。\n```\n```\nvoid sendRedirect(String location)\n使用指定的重定向位置 URL 发送临时重定向响应到客户端。\n```\n```\nvoid setBufferSize(int size)\n为响应主体设置首选的缓冲区大小。\n```\n```\nvoid setCharacterEncoding(String charset)\n设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。\n```\n```\nvoid setContentLength(int len)\n设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头信息。\n```\n```\nvoid setContentType(String type)\n如果响应还未被提交，设置被发送到客户端的响应的内容类型。\n```\n```\nvoid setDateHeader(String name, long date)\n设置一个带有给定的名称和日期值的响应头信息。\n```\n```\nvoid setHeader(String name, String value)\n设置一个带有给定的名称和值的响应头信息。\n```\n```\nvoid setIntHeader(String name, int value)\n设置一个带有给定的名称和整数值的响应头信息。\n```\n```\nvoid setLocale(Locale loc)\n如果响应还未被提交，设置响应的区域。\n```\n```\nvoid setStatus(int sc)\n为该响应设置状态码。\n```\n\n在前面的实例中你已经了解了 `setContentType()` 方法的工作方式，下面的实例也会用到同样的方法，此外，我们会用 `setIntHeader()` 方法来设置 Refresh 头信息。\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/Refresh\")\npublic class Refresh extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set refresh, autoload time as 5 seconds\n      response.setIntHeader(\"Refresh\", 5);\n      // Set response content type\n      response.setContentType(\"text/html\");\n      // Get current time\n      Calendar calendar = new GregorianCalendar();\n      String am_pm;\n      int hour = calendar.get(Calendar.HOUR);\n      int minute = calendar.get(Calendar.MINUTE);\n      int second = calendar.get(Calendar.SECOND);\n      if(calendar.get(Calendar.AM_PM) == 0)\n        am_pm = \"AM\";\n      else\n        am_pm = \"PM\"; \n      String CT = hour+\":\"+ minute +\":\"+ second +\" \"+ am_pm;\n      PrintWriter out = response.getWriter();\n      String title = \"Auto Refresh Header Setting\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\"+\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<p>Current Time is: \" + CT + \"</p>\\n\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n现在调用上述 servlet，每 5 秒后就会显示当前的系统时间，如下所示。运行 servlet 并等着看结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/10.png)\n\n---\n\n## HTTP 状态码\n\nHTTP 状态码相关知识见 [HTTP状态码](../../Web/HTTP/HTTP状态码.md)\n\n下面是在 servlet 程序中可以用于设置 HTTP 状态码的方法。通过 HttpServletResponse 对象这些方法是可用的。\n\njava\npublic void setStatus ( int statusCode )\n该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter 实际返回任何内容之前调用 setStatus。\n```\n\n```java\npublic void sendRedirect(String url)\n该方法生成一个 302 响应，连同一个带有新文档 URL 的 Location 头。\n```\n\n```java\npublic void sendError(int code, String message)\n该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。\n```\n\nHTTP 状态码实例：\n下述例子将发送 407 错误代码到客户端浏览器，且浏览器会向你显示 “需要身份验证！！！”的消息。\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/err\")\npublic class showError extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set error code and reason.\n      response.sendError(407, \"Need authentication!!!\" );\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/1.png)\n\n---\n\n## 过滤器\n\nServlet 过滤器是 Java 类，可用于 Servlet 编程中的下述目的：\n* 在它们访问后端资源之前，拦截这些来自客户端的请求。\n* 在它们发送回客户端之前，处理这些来自服务器端的响应。\n\n这是规范建议的各种类型的过滤器：\n* 身份验证过滤器。\n* 数据压缩过滤器。\n* 加密过滤器。\n* 触发访问事件资源的过滤器。\n* 图像转换过滤器。\n* 日志记录和审核过滤器。\n* MIME-类型链过滤器。\n* Tokenizing 过滤器。\n* 转换 XML 内容的 XSL/T 过滤器。\n\n过滤器在部署描述符文件 web.xml 中被部署，然后被映射到 servlet 名称或你的应用程序的部署描述符中的 URL 模式。\n\n当 web 容器启动你的 web 应用程序时，它会为每个在部署描述符中已声明的过滤器创建一个实例。过滤器按照它们在部署描述符中声明的顺序执行。\n\n过滤器仅仅是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三种方法：\n\n```java\npublic void doFilter (ServletRequest, ServletResponse, FilterChain)\n该方法在每次一个请求/响应对因客户端在链的末端请求资源而通过链传递时由容器调用。\n```\n\n```java\npublic void init(FilterConfig filterConfig)\n该方法由 Web 容器调用，指示一个过滤器被放入服务。\n```\n\n```java\npublic void destroy()\n该方法由 Web 容器调用，指示一个过滤器从服务被去除。\n```\n\nServlet 过滤器实例\n\n以下是 Servlet 过滤器的实例，将输出客户端的 IP 地址和当前的日期时间。这个例子使你对 Servlet 过滤器有了基本的了解，但是你可以使用相同的概念编写更复杂的过滤器应用程序：\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Implements Filter class\npublic class LogFilter implements Filter  {\n   public void  init(FilterConfig config)\n                         throws ServletException{\n      // Get init parameter\n      String testParam = config.getInitParameter(\"test-param\");\n      //Print the init parameter\n      System.out.println(\"Test Param: \" + testParam);\n   }\n   public void  doFilter(ServletRequest request,\n                 ServletResponse response,\n                 FilterChain chain)\n                 throws java.io.IOException, ServletException {\n      // Get the IP address of client machine.\n      String ipAddress = request.getRemoteAddr();\n      // Log the IP address and current timestamp.\n      System.out.println(\"IP \"+ ipAddress + \", Time \"\n                                       + new Date().toString());\n      // Pass request back down the filter chain\n      chain.doFilter(request,response);\n   }\n   public void destroy( ){\n      /* Called before the Filter instance is removed\n      from service by the web container*/\n   }\n}\n```\n\n---\n\n## 异常处理\n\n当一个 servlet 抛出一个异常时，web 容器在使用了 exception-type 元素的 web.xml 中搜索与抛出的异常类型相匹配的配置。\n\n你必须在 web.xml 中使用 error-page 元素来指定 servlet 调用，作为对特定的异常或 HTTP 状态码作出的响应。\n\n考虑这种情况，你有一个 ErrorHandler servelt，当任何已定义的异常或错误出现时就会被调用。以下是要在 web.xml 中创建的条目。\n```xml\n<!-- servlet definition -->\n<servlet>\n        <servlet-name>ErrorHandler</servlet-name>\n        <servlet-class>ErrorHandler</servlet-class>\n</servlet>\n<!-- servlet mappings -->\n<servlet-mapping>\n        <servlet-name>ErrorHandler</servlet-name>\n        <url-pattern>/ErrorHandler</url-pattern>\n</servlet-mapping>\n\n<!-- error-code related error pages -->\n<error-page>\n    <error-code>404</error-code>\n    <location>/ErrorHandler</location>\n</error-page>\n<error-page>\n    <error-code>403</error-code>\n    <location>/ErrorHandler</location>\n</error-page>\n\n<!-- exception-type related error pages -->\n<error-page>\n    <exception-type>\n          javax.servlet.ServletException\n    </exception-type >\n    <location>/ErrorHandler</location>\n</error-page>\n\n<error-page>\n    <exception-type>java.io.IOException</exception-type >\n    <location>/ErrorHandler</location>\n</error-page>\n```\n\n如果你想对所有的异常有一个通用的错误处理程序，那么你应该定义如下所示的 error-page，而不是为每个异常定义单独的 error-page 元素：\n\n```xml\n<error-page>\n    <exception-type>java.lang.Throwable</exception-type >\n    <location>/ErrorHandler</location>\n</error-page>\n```\n\n以下是异常处理中有关上述 web.xml 需要注意的点：\n* Servelt ErrorHandler 与其他的 servelt 的定义方式一样，且在 web.xml 中配置。\n* 如果状态码有任何错误出现，不管是 404（未找到）还是 403（禁止），那么 ErrorHandler servlet 会被调用。\n* 如果 web 应用程序抛出 ServletException 或 IOException，那么 web 容器就会调用 /ErrorHandler servlet。\n* 你可以定义不同的错误处理程序来处理不同类型的错误或异常。上述例子非常通用，希望它达到了让你理解基本概念的目的。\n\n以下是错误处理 servlet 可以访问的请求属性列表，用来分析错误/异常的性质。\n\n```\njavax.servlet.error.status_code\n该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。\n```\n\n```\njavax.servlet.error.exception_type\n该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。\n```\n\n```\njavax.servlet.error.message\n该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。\n```\n\n```\njavax.servlet.error.request_uri\n该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。\n```\n\n```\njavax.servlet.error.exception\n该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。\n```\n\n```\njavax.servlet.error.servlet_name\n该属性给出 servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。\n```\n\n以下是 Servlet 实例，用于任何你定义的 servlet 出现任何错误或异常时的情况。\n\n这个例子让你对 Servlet 中的异常处理有了基本的了解，但是你可以使用相同的概念编写更复杂的异常处理应用程序：\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\n@WebServlet(urlPatterns = \"/ErrorHandler\")\npublic class ErrorHandler extends HttpServlet {\n  // Method to handle GET method request.\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Analyze the servlet exception\n      Throwable throwable = (Throwable)\n      request.getAttribute(\"javax.servlet.error.exception\");\n      Integer statusCode = (Integer)\n      request.getAttribute(\"javax.servlet.error.status_code\");\n      String servletName = (String)\n      request.getAttribute(\"javax.servlet.error.servlet_name\");\n      if (servletName == null){\n         servletName = \"Unknown\";\n      }\n      String requestUri = (String)\n      request.getAttribute(\"javax.servlet.error.request_uri\");\n      if (requestUri == null){\n         requestUri = \"Unknown\";\n      }\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Error/Exception Information\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\");\n      if (throwable == null && statusCode == null){\n         out.println(\"<h2>Error information is missing</h2>\");\n         out.println(\"Please return to the <a href=\\\"\" +\n           response.encodeURL(\"http://localhost:8080/\") +\n           \"\\\">Home Page</a>.\");\n      }else if (statusCode != null){\n         out.println(\"The status code : \" + statusCode);\n      }else{\n         out.println(\"<h2>Error information</h2>\");\n         out.println(\"Servlet Name : \" + servletName +\n                             \"</br></br>\");\n         out.println(\"Exception Type : \" +\n                             throwable.getClass( ).getName( ) +\n                             \"</br></br>\");\n         out.println(\"The request URI: \" + requestUri +\n                             \"<br><br>\");\n         out.println(\"The exception message: \" +\n                                 throwable.getMessage( ));\n      }\n      out.println(\"</body>\");\n      out.println(\"</html>\");\n  }\n  // Method to handle POST method request.\n  public void doPost(HttpServletRequest request,\n                     HttpServletResponse response)\n      throws ServletException, IOException {\n     doGet(request, response);\n  }\n}\n```\n\n以常用的方式编译 ErrorHandler.java 并把你的类文件放入/webapps/ROOT/WEB-INF/classes 中。\n\n让我们将下述配置添加到 web.xml 文件中来处理异常：\n```xml\n<servlet>\n        <servlet-name>ErrorHandler</servlet-name>\n        <servlet-class>ErrorHandler</servlet-class>\n</servlet>\n<!-- servlet mappings -->\n<servlet-mapping>\n        <servlet-name>ErrorHandler</servlet-name>\n        <url-pattern>/ErrorHandler</url-pattern>\n</servlet-mapping>\n<error-page>\n    <error-code>404</error-code>\n    <location>/ErrorHandler</location>\n</error-page>\n<error-page>\n    <exception-type>java.lang.Throwable</exception-type >\n    <location>/ErrorHandler</location>\n</error-page>\n```\n\n现在，尝试使用一个会产生任何异常的 servlet 或者输入一个错误的 URL，这将触发 Web 容器调用 ErrorHandler servlet 并显示适当的消息。例如，如果你输入了一个错误的 URL，那么它将显示如下所示的结果：\n```\nThe status code : 404\n```\n上述代码在一些 web 浏览器中可能无法工作。因此请尝试使用 Mozilla 和 Safari 浏览器，这样上述代码应该能正常工作。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-2/2.png)\n\n---\n\n## Source & Reference\n\n- https://wiki.jikexueyuan.com/project/servlet/writing-filters.html\n- https://wiki.jikexueyuan.com/project/servlet/form-data.html\n- https://wiki.jikexueyuan.com/project/servlet/cookies-handling.html\n", "timestamp": "2025-10-19T19:25:26.046931"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/servlet/servlet-3.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/servlet/servlet-3.md", "content": "# servlet-3\n\n---\n\n## Cookies 处理\n\nCookies 是存储在客户端计算机上的文本文件，用于各种信息的跟踪目的。Java Servlet 透明的支持 HTTP Cookies。\n\n识别返回用户包括以下三个步骤：\n* 服务器脚本向浏览器发送一组 cookies。例如姓名、年龄或身份证号码等。\n* 浏览器将这些信息存储在本地计算机中以备将来使用。\n* 当下次浏览器向 web 服务器发送任何请求时，它会把这些 cookies 信息发送到服务器，服务器使用这些信息来识别用户。\n\n### Cookie 剖析\n\n通常情况下，Cookies 设置在 HTTP 头信息中（尽管 JavaScript 也可以直接在浏览器上设置 cookie）。设置 cookie 的 servlet 可能会发送如下所示的头信息：\n\n```\nHTTP/1.1 200 OK\nDate: Fri, 04 Feb 2000 21:03:38 GMT\nServer: Apache/1.3.9 (UNIX) PHP/4.0b3\nSet-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT;\n                 path=/; domain=tutorialspoint.com\nConnection: close\nContent-Type: text/html\n```\n\n正如你所看到的，Set-Cookie 头信息包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。有效期字段指示浏览器在给定的时间和日期之后“忘记”该 cookie。\n\n如果浏览器被配置为存储 cookies，它将会把这个信息保留到截止日期。如果用户在任何与该 cookie 的路径和域匹配的页面点击浏览器，它就会将这个 cookie 重新发送到服务器。浏览器的头信息可能如下所示：\n\n```\nGET / HTTP/1.0\nConnection: Keep-Alive\nUser-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)\nHost: zink.demon.co.uk:1126\nAccept: image/gif, */*\nAccept-Encoding: gzip\nAccept-Language: en\nAccept-Charset: iso-8859-1,*,utf-8\nCookie: name=xyz\n```\n\n之后 servlet 就能够通过请求方法 `request.getCookies()` 访问 cookie，该方法将返回一个 Cookie 对象的数组。\n\n### Servlet Cookies 方法\n\n以下是在 servlet 中操作 cookies 时你可能会用到的有用的方法列表。\n\n```\npublic void setDomain(String pattern)\n该方法设置 cookie 适用的域，例如 tutorialspoint.com。\n```\n```\npublic String getDomain()\n该方法获取 cookie 适用的域，例如 tutorialspoint.com。\n```\n```\npublic void setMaxAge(int expiry)\n该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。\n```\n```\npublic int getMaxAge()\n该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。\n```\n```\npublic String getName()\n该方法返回 cookie 的名称。名称在创建后不能改变。\n```\n```\npublic void setValue(String newValue)\n该方法设置与 cookie 关联的值。\n```\n```\npublic String getValue()\n该方法获取与 cookie 关联的值。\n```\n```\npublic void setPath(String uri)\n该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。\n```\n```\npublic String getPath()\n该方法获取 cookie 适用的路径。\n```\n```\npublic void setSecure(boolean flag)\n该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。\n```\n```\npublic void setComment(String purpose)\n该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。\n```\n```\npublic String getComment()\n该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。\n```\n\n### 用 Servlet 设置 Cookies\n\n用 servlet 设置 cookies 包括三个步骤：\n\n1. 创建一个 Cookie 对象：用 cookie 名和 cookie 值调用 Cookie 构造函数，cookie 名和 cookie 值都是字符串。\n\n    ```java\n    Cookie cookie = new Cookie(\"key\",\"value\");\n    ```\n\n    记住，无论是名字还是值，都不应该包含空格和以下任何字符：\n\n    ```\n    [ ] ( ) = , \" / ? @ : ;\n    ```\n\n2. 设置最长有效期：你可以使用 setMaxAge 方法来指定 cookie 有效的时间（以秒为单位）。下面是设置了一个最长有效期为 24 小时的 cookie。\n\n    ```java\n    cookie.setMaxAge(60*60*24);\n    ```\n\n3. 发送 Cookie 到 HTTP 响应头：你可以使用 response.addCookie 来在 HTTP 响应头中添加 cookies，如下所示：\n\n    ```java\n    response.addCookie(cookie);\n    ```\n\n    让我们修改我们的 表单实例 来为姓名设置 cookies。\n\n让我们修改我们的 表单实例 来为姓名设置 cookies。\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/HelloForm\")\npublic class HelloForm extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Create cookies for first and last names.\n      Cookie firstName = new Cookie(\"first_name\",\n                      request.getParameter(\"first_name\"));\n      Cookie lastName = new Cookie(\"last_name\",\n                      request.getParameter(\"last_name\"));\n      // Set expiry date after 24 Hrs for both the cookies.\n      firstName.setMaxAge(60*60*24);\n      lastName.setMaxAge(60*60*24);\n      // Add both the cookies in the response header.\n      response.addCookie( firstName );\n      response.addCookie( lastName );\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Setting Cookies Example\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n                \"<ul>\\n\" +\n                \"  <li><b>First Name</b>: \"\n                + request.getParameter(\"first_name\") + \"\\n\" +\n                \"  <li><b>Last Name</b>: \"\n                + request.getParameter(\"last_name\") + \"\\n\" +\n                \"</ul>\\n\" +\n                \"</body></html>\");\n  }\n}\n```\n\n编译上述 servlet HelloForm 并在 web.xml 文件中创建适当的条目，最后尝试使用下述 HTML 页面来调用 servlet。\n\n```html\n<html>\n<body>\n<form action=\"HelloForm\" method=\"GET\">\nFirst Name: <input type=\"text\" name=\"first_name\">\n<br />\nLast Name: <input type=\"text\" name=\"last_name\" />\n<input type=\"submit\" value=\"Submit\" />\n</form>\n</body>\n</html>\n```\n\n将上述 HTML 内容保存到文件 hello.htm 中并把它放在 /webapps/ROOT 目录中。当你访问 http://localhost:8080/Hello.htm 时，上述表单的实际输出如下所示：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/1.png)\n\n尝试输入姓名，然后点击提交按钮。这将在你的屏幕上显示姓名，同时会设置 firstName 和 lastName 这两个 cookies，当下次你点击提交按钮时，会将这两个 cookies 传回到服务器。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/2.png)\n\n### 用 Servlet 读取 Cookies\n\n要读取 cookies，你需要通过调用 HttpServletRequest 的 `getCookies()` 方法创建一个 javax.servlet.http.Cookie 对象的数组。然后循环遍历数组，并使用 `getName()` 和 `getValue()` 方法来访问每个 cookie 及其相关的值。\n\n让我们读取上述例子中已经设置的 cookies：\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/ReadCookies\")\npublic class ReadCookies extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      Cookie cookie = null;\n      Cookie[] cookies = null;\n      // Get an array of Cookies associated with this domain\n      cookies = request.getCookies();\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Reading Cookies Example\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" );\n      if( cookies != null ){\n         out.println(\"<h2> Found Cookies Name and Value</h2>\");\n         for (int i = 0; i < cookies.length; i++){\n            cookie = cookies[i];\n            out.print(\"Name : \" + cookie.getName( ) + \",  \");\n            out.print(\"Value: \" + cookie.getValue( )+\" <br/>\");\n         }\n      }else{\n          out.println(\n            \"<h2>No cookies founds</h2>\");\n      }\n      out.println(\"</body>\");\n      out.println(\"</html>\");\n   }\n}\n```\n\n编译上述 servlet ReadCookies 并在 web.xml 文件中创建适当的条目。如果你已经设置了 first name cookie 为 “John”，last name cookie 为 “Player” ，那么尝试运行 http://localhost:8080/ReadCookies，将显示如下所示结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/3.png)\n\n### 用 Servlet 删除 Cookies\n\n删除 cookies 非常简单。如果你想删除一个 cookie，那么只需要按照如下所示的三个步骤进行：\n* 读取一个现存的 cookie 并把它存储在 Cookie 对象中。\n* 使用 `setMaxAge()` 方法设置 cookie 的年龄为零来删除一个现存的 cookie。\n* 将这个 cookie 添加到响应z中。\n\n下述例子将删除一个现存的命名为 “first name” 的 cookie，且当你下次运行 ReadCookies servlet 时，它会为 first name 返回空值。\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/DeleteCookies\")\npublic class DeleteCookies extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      Cookie cookie = null;\n      Cookie[] cookies = null;\n      // Get an array of Cookies associated with this domain\n      cookies = request.getCookies();\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Delete Cookies Example\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" );\n       if( cookies != null ){\n         out.println(\"<h2> Cookies Name and Value</h2>\");\n         for (int i = 0; i < cookies.length; i++){\n            cookie = cookies[i];\n            if((cookie.getName( )).compareTo(\"first_name\") == 0 ){\n                 cookie.setMaxAge(0);\n                 response.addCookie(cookie);\n                 out.print(\"Deleted cookie : \" +\n                              cookie.getName( ) + \"<br/>\");\n            }\n            out.print(\"Name : \" + cookie.getName( ) + \",  \");\n            out.print(\"Value: \" + cookie.getValue( )+\" <br/>\");\n         }\n      }else{\n          out.println(\n            \"<h2>No cookies founds</h2>\");\n      }\n      out.println(\"</body>\");\n      out.println(\"</html>\");\n   }\n}\n```\n\n编译上述 servlet DeleteCookies 并在 web.xml 文件中创建适当的条目。现在运行 http://localhost:8080/DeleteCookies，将显示如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/4.png)\n\n现在尝试运行 http://localhost:8080/ReadCookies，它将只显示一个 cookie，如下所示：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/5.png)\n\n---\n\n## 会话跟踪\n\nHTTP 是一种“无状态”协议，这意味着每次客户端检索 Web 页面时，客户端打开一个单独的连接到 Web 服务器，服务器不会自动保存之前客户端请求的任何记录。\n\n仍然有以下三种方式来维持 web 客户端和 web 服务器之间的会话：\n\n### Cookies\n\n一个 web 服务器可以分配一个唯一的会话 ID 作为每个 web 客户端的 cookie，并且对于来自客户端的后续请求，它们可以使用已接收的 cookie 来识别。\n\n这可能不是一个有效的方法，因为很多时候浏览器不支持 cookie，所以我不建议使用这种方式来维持会话。\n\n**隐藏的表单字段**\n\n一个 web 服务器可以发送一个隐藏的 HTML 表单字段以及一个唯一的会话 ID，如下所示：\n\n```html\n<input type=\"hidden\" name=\"sessionid\" value=\"12345\">\n```\n\n该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 web 浏览器发送回请求时，`session_id` 的值可以用于跟踪不同的 web 浏览器。\n\n这可能是保持会话跟踪的一种有效的方式，但是点击常规的 `<A HREF...>` 超文本链接不会导致表单提交，因此隐藏的表单字段也不支持常规的会话跟踪。\n\n### URL 重写\n\n你可以在每个标识会话的 URL 末尾追加一些额外的数据，且服务器会把该会话标识符与它已存储的有关会话的数据关联起来。\n\n例如，http://aaa.com/file.htm;sessionid=12345，会话标识符被附加为 sessionid=12345，可能会在 web 服务器端被访问来识别客户端。\n\nURL 重写是维持会话的一种更好的方式，当浏览器不支持 cookie 时为浏览器工作，但是它的缺点是会动态的生成每个 URL 来分配会话 ID，即使页面是简单的静态的 HTML 页面。\n\n### HttpSession 对象\n\n除了上述提到的三种方式，servlet 还提供了 HttpSession 接口，该接口提供了一种对网站的跨多个页面请求或访问的方法来识别用户并存储有关用户的信息。\n\nServlet 容器使用这个接口来创建在 HTTP 客户端和 HTTP 服务器之间的会话。会话在一个指定的时间段内持续，跨多个连接或来自用户的请求。\n\n你可以通过调用 HttpServletRequest 的公共方法 `getSession()` 来获取 HttpSession 对象，如下所示：\n```java\nHttpSession session = request.getSession();\n```\n在向客户端发送任何文档内容之前，你需要调用 `request.getSession()`。这里是一些重要方法的总结，这些方法通过 HttpSession 对象是可用的：\n\n```\npublic Object getAttribute(String name)\n该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。\n```\n```\npublic Enumeration getAttributeNames()\n该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。\n```\n```\npublic long getCreationTime()\n该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日凌晨零点算起，以毫秒为单位。\n```\n```\npublic String getId()\n该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。\n```\n```\npublic long getLastAccessedTime()\n该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日凌晨零点算起，以毫秒为单位。\n```\n```\npublic int getMaxInactiveInterval()\n该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。\n```\n```\npublic void invalidate()\n该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。\n```\n```\npublic boolean isNew()\n如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。\n```\n```\npublic void removeAttribute(String name)\n该方法将从该 session 会话移除指定名称的对象。\n```\n```\npublic void setAttribute(String name, Object value)\n该方法使用指定的名称绑定一个对象到该 session 会话。\n```\n```\npublic void setMaxInactiveInterval(int interval)\n该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。\n```\n\n这个例子描述了如何使用 HttpSession 对象获取会话创建时间和上次访问的时间。如果不存在会话，我们将一个新的会话与请求联系起来。\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/SessionTrack\")\npublic class SessionTrack extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Create a session object if it is already not  created.\n      HttpSession session = request.getSession(true);\n      // Get session creation time.\n      Date createTime = new Date(session.getCreationTime());\n      // Get last access time of this web page.\n      Date lastAccessTime =\n                        new Date(session.getLastAccessedTime());\n      String title = \"Welcome Back to my website\";\n      Integer visitCount = new Integer(0);\n      String visitCountKey = new String(\"visitCount\");\n      String userIDKey = new String(\"userID\");\n      String userID = new String(\"ABCD\");\n      // Check if this is new comer on your web page.\n      if (session.isNew()){\n         title = \"Welcome to my website\";\n         session.setAttribute(userIDKey, userID);\n      } else {\n         visitCount = (Integer)session.getAttribute(visitCountKey);\n         visitCount = visitCount + 1;\n         userID = (String)session.getAttribute(userIDKey);\n      }\n      session.setAttribute(visitCountKey,  visitCount);\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n                 \"<h2 align=\\\"center\\\">Session Infomation</h2>\\n\" +\n                \"<table border=\\\"1\\\" align=\\\"center\\\">\\n\" +\n                \"<tr bgcolor=\\\"#949494\\\">\\n\" +\n                \"  <th>Session info</th><th>value</th></tr>\\n\" +\n                \"<tr>\\n\" +\n                \"  <td>id</td>\\n\" +\n                \"  <td>\" + session.getId() + \"</td></tr>\\n\" +\n                \"<tr>\\n\" +\n                \"  <td>Creation Time</td>\\n\" +\n                \"  <td>\" + createTime +\n                \"  </td></tr>\\n\" +\n                \"<tr>\\n\" +\n                \"  <td>Time of Last Access</td>\\n\" +\n                \"  <td>\" + lastAccessTime +\n                \"  </td></tr>\\n\" +\n                \"<tr>\\n\" +\n                \"  <td>User ID</td>\\n\" +\n                \"  <td>\" + userID +\n                \"  </td></tr>\\n\" +\n                \"<tr>\\n\" +\n                \"  <td>Number of visits</td>\\n\" +\n                \"  <td>\" + visitCount + \"</td></tr>\\n\" +\n                \"</table>\\n\" +\n                \"</body></html>\");\n  }\n}\n```\n\n编译上述 servlet SessionTrack 并在 web.xml 文件中创建适当的条目。在浏览器地址栏输入 http://localhost:8080/SessionTrack，当你第一次运行时将显示如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/6.png)\n\n现在尝试再次运行相同的 servlet，它将显示如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/7.png)\n\n### 删除会话数据\n\n当你完成了一个用户的会话数据，你有以下几种选择：\n* 移除一个特定的属性：你可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。\n* 删除整个会话：你可以调用 public void invalidate() 方法来删除整个会话。\n* 设置会话超时：你可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置会话超时。\n* 注销用户：支持 servlet 2.4 的服务器，你可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有会话设置为无效。\n\nweb.xml 配置：如果你使用的是 Tomcat，除了上述方法，你还可以在 web.xml 文件中配置会话超时，如下所示：\n```xml\n<session-config>\n    <session-timeout>15</session-timeout>\n</session-config>\n```\n超时时间是以分钟为单位的，并覆盖了 Tomcat 中默认的 30 分钟的超时时间。\n\nServlet 中的 `getMaxInactiveInterval()` 方法为会话返回的超时时间是以秒为单位的。所以如果在 web.xml 中配置会话超时时间为 15 分钟，那么 `getMaxInactiveInterval()` 会返回 900。\n\n---\n\n## 数据库访问\n\n如何使用 JDBC 访问数据库及其环境配置的更多细节，可以查看 [JDBC](../存储/JDBC.md)\n\n创建表\n```sql\nuse test;\ncreate table Employees\n    (\n     id int not null,\n     age int not null,\n     first varchar (255),\n     last varchar (255)\n    );\n\nINSERT INTO Employees VALUES (100, 18, 'Zara', 'Ali');\nINSERT INTO Employees VALUES (101, 25, 'Mahnaz', 'Fatma');\nINSERT INTO Employees VALUES (102, 30, 'Zaid', 'Khan');\nINSERT INTO Employees VALUES (103, 28, 'Sumit', 'Mittal');\n```\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/8.png)\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/9.png)\n\n这里的例子演示了如何使用 Servlet 访问 test 数据库。\n```java\n// Loading required libraries\nimport java.io.*;\nimport java.util.*;\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\nimport java.sql.*;\n\n@WebServlet(urlPatterns = \"/DatabaseAccess\")\npublic class DatabaseAccess extends HttpServlet{\n    private static JDBCUtils JDBCutiss;\n\n    public void doGet(HttpServletRequest request,\n                      HttpServletResponse response)\n            throws ServletException, IOException\n    {\n        // Set response content type\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        String title = \"Database Result\";\n        String docType =\n                \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n                        \"transitional//en\\\">\\n\";\n        out.println(docType +\n                \"<html>\\n\" +\n                \"<head><title>\" + title + \"</title></head>\\n\" +\n                \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n                \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\");\n        try{\n            // Register JDBC driver\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            // Open a connection\n\n            Connection conn = JDBCutiss.getConnection();\n\n            // Execute SQL query\n            Statement stmt = conn.createStatement();\n            String sql;\n            sql = \"SELECT id, first, last, age FROM Employees\";\n            ResultSet rs = stmt.executeQuery(sql);\n            // Extract data from result set\n            while(rs.next()){\n                //Retrieve by column name\n                int id  = rs.getInt(\"id\");\n                int age = rs.getInt(\"age\");\n                String first = rs.getString(\"first\");\n                String last = rs.getString(\"last\");\n                //Display values\n                out.println(\"ID: \" + id + \"<br>\");\n                out.println(\", Age: \" + age + \"<br>\");\n                out.println(\", First: \" + first + \"<br>\");\n                out.println(\", Last: \" + last + \"<br>\");\n            }\n            out.println(\"</body></html>\");\n            // Clean-up environment\n            rs.close();\n            JDBCutiss.close(stmt,conn);\n            conn.close();\n        }catch(SQLException se){\n            //Handle errors for JDBC\n            se.printStackTrace();\n        }catch(Exception e){\n            //Handle errors for Class.forName\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n记得弄个 JDBCUtils 类\n```java\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class JDBCUtils {\n    private static DataSource ds;\n\n    static {\n        Properties pro = new Properties();\n        InputStream rs = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n        try {\n            pro.load(rs);\n            try {\n                ds = DruidDataSourceFactory.createDataSource(pro);\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    //返回连接对象\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();\n    }\n    public  static void close(Statement stmt, Connection conn){\n        if (stmt!=null){\n            try {\n                stmt.close();\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n\n        }\n        if (conn!=null){\n            try {\n                conn.close();\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n    //该方法返回定义好的DataSource对象\n    public static DataSource getDataSource(){\n        return ds;\n    }\n}\n```\n\n在 resources 创建 druid.properties\n\n现在让我们来编译述 servlet 并在 web.xml 文件中创建以下条目：\n```xml\n <servlet>\n     <servlet-name>DatabaseAccess</servlet-name>\n     <servlet-class>DatabaseAccess</servlet-class>\n </servlet>\n <servlet-mapping>\n     <servlet-name>DatabaseAccess</servlet-name>\n     <url-pattern>/DatabaseAccess</url-pattern>\n </servlet-mapping>\n```\n\n现在使用 URL http://localhost:8080/DatabaseAccess 调用这个 servlet，将显示如下所示响应：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/10.png)\n\n---\n\n## 文件上传\n\nServlet 可以与 HTML form 标签一起使用允许用户将文件上传到服务器。上传的文件可以是文本文件或图像文件或任何文档。\n\n### 创建一个文件上传表单\n\n下述 HTML 代码创建了一个文件上传表单。以下是需要注意的几点：\n* 表单 method 属性应该设置为 POST 方法且不能使用 GET 方法。\n* 表单 enctype 属性应该设置为 multipart/form-data.\n* 表单 action 属性应该设置为 servlet 文件，能够在后端服务器处理文件上传。下面的例子是使用 UploadServlet servlet 来上传文件的。\n* 要上传单个文件，你应该使用单个带有属性 type=“file” 的 `<input .../>` 标签。为了允许多个文件上传，要包含多个带有 name 属性不同值的输入标签。浏览器将把一个浏览按钮和每个输入标签关联起来。\n\n```html\n<html>\n<head>\n<title>File Uploading Form</title>\n</head>\n<body>\n<h3>File Upload:</h3>\nSelect a file to upload: <br />\n<form action=\"UploadServlet\" method=\"post\"\n                        enctype=\"multipart/form-data\">\n<input type=\"file\" name=\"file\" size=\"50\" />\n<br />\n<input type=\"submit\" value=\"Upload File\" />\n</form>\n</body>\n</html>\n```\n\n这将允许从本地计算机中选择一个文件，当用户点击“上传文件”时，表单会和选择的文件一起提交\n\n### 编写后台 Servlet\n\n以下是 servlet UploadServlet，会接受上传的文件并把它储存在目录 /webapps/data 中。使用外部配置，如 web.xml 中的 context-param 元素，这个目录名也可以被添加，如下所示：\n```java\n<web-app>\n....\n<context-param>\n    <description>Location to store uploaded file</description>\n    <param-name>file-upload</param-name>\n    <param-value>\n         c:\\temp\\save\\\n     </param-value>\n</context-param>\n....\n</web-app>\n```\n\n以下是 UploadServlet 的源代码，可以一次处理多个文件的上传。在继续操作之前，请确认下列各项：\n\n下述例子依赖于 FileUpload，所以一定要确保在你的 classpath 中有最新版本的 commons-fileupload.x.x.jar 文件。你可以从 http://commons.apache.org/fileupload/ 中下载。\n\nFileUpload 依赖于 Commons IO，所以一定要确保在你的 classpath 中有最新版本的 commons-io-x.x.jar 文件。可以从 http://commons.apache.org/io/ 中下载。\n\n在测试下面实例时，你上传的文件大小不能大于 maxFileSize，否则文件将无法上传。\n\n请确保已经提前创建好目录 c:\\temp and c:\\apache-tomcat-5.5.29\\webapps\\data。\n```java\n// Import required java libraries\nimport java.io.*;\nimport java.util.*;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.io.output.*;\n\n@WebServlet(urlPatterns = \"/UploadServlet\")\npublic class UploadServlet extends HttpServlet {\n   private boolean isMultipart;\n   private String filePath;\n   private int maxFileSize = 50 * 1024;\n   private int maxMemSize = 4 * 1024;\n   private File file ;\n   public void init( ){\n      // Get the file location where it would be stored.\n      filePath =\n             getServletContext().getInitParameter(\"file-upload\");\n   }\n   public void doPost(HttpServletRequest request,\n               HttpServletResponse response)\n              throws ServletException, java.io.IOException {\n      // Check that we have a file upload request\n      isMultipart = ServletFileUpload.isMultipartContent(request);\n      response.setContentType(\"text/html\");\n      java.io.PrintWriter out = response.getWriter( );\n      if( !isMultipart ){\n         out.println(\"<html>\");\n         out.println(\"<head>\");\n         out.println(\"<title>Servlet upload</title>\");\n         out.println(\"</head>\");\n         out.println(\"<body>\");\n         out.println(\"<p>No file uploaded</p>\");\n         out.println(\"</body>\");\n         out.println(\"</html>\");\n         return;\n      }\n      DiskFileItemFactory factory = new DiskFileItemFactory();\n      // maximum size that will be stored in memory\n      factory.setSizeThreshold(maxMemSize);\n      // Location to save data that is larger than maxMemSize.\n      factory.setRepository(new File(\"c:\\\\temp\"));\n      // Create a new file upload handler\n      ServletFileUpload upload = new ServletFileUpload(factory);\n      // maximum file size to be uploaded.\n      upload.setSizeMax( maxFileSize );\n      try{\n      // Parse the request to get file items.\n      List fileItems = upload.parseRequest(request);\n      // Process the uploaded file items\n      Iterator i = fileItems.iterator();\n      out.println(\"<html>\");\n      out.println(\"<head>\");\n      out.println(\"<title>Servlet upload</title>\");\n      out.println(\"</head>\");\n      out.println(\"<body>\");\n      while ( i.hasNext () )\n      {\n         FileItem fi = (FileItem)i.next();\n         if ( !fi.isFormField () )\n         {\n            // Get the uploaded file parameters\n            String fieldName = fi.getFieldName();\n            String fileName = fi.getName();\n            String contentType = fi.getContentType();\n            boolean isInMemory = fi.isInMemory();\n            long sizeInBytes = fi.getSize();\n            // Write the file\n            if( fileName.lastIndexOf(\"\\\\\") >= 0 ){\n               file = new File( filePath +\n               fileName.substring( fileName.lastIndexOf(\"\\\\\"))) ;\n            }else{\n               file = new File( filePath +\n               fileName.substring(fileName.lastIndexOf(\"\\\\\")+1)) ;\n            }\n            fi.write( file ) ;\n            out.println(\"Uploaded Filename: \" + fileName + \"<br>\");\n         }\n      }\n      out.println(\"</body>\");\n      out.println(\"</html>\");\n   }catch(Exception ex) {\n       System.out.println(ex);\n   }\n   }\n   public void doGet(HttpServletRequest request,\n                       HttpServletResponse response)\n        throws ServletException, java.io.IOException {\n        throw new ServletException(\"GET method used with \" +\n                getClass( ).getName( )+\": POST method required.\");\n   }\n}\n```\n\n记得添加 maven 依赖\n```xml\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/commons-io/commons-io -->\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.4</version>\n        </dependency>\n```\n\n编译和运行 Servlet,现在尝试使用上面创建的 HTML 表单来上传文件。当你访问 http://localhost:8080/UploadFile.htm 时，它会显示如下所示的结果，这将有助于你从本地计算机中上传任何文件。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/11.png)\n\n---\n\n## 处理日期\n\n使用 Servlet 的最重要的优势之一是你可以使用核心 Java 中的大多数可用的方法。本教程将讲解 Java 提供的 Date 类，该类在 java.util 包中是可用的，这个类封装了当前的日期和时间。\n\nDate 类支持两个构造函数。第一个构造函数用当前日期和时间初始化对象。\n```\nDate( )\n```\n下面的构造函数接受一个参数，该参数等于自 1970 年 1 月 1 日凌晨零点以来经过的毫秒数。\n\n```\nDate(long millisec)\n```\n\n一旦你得到一个可用的 Date 对象，你可以调用下列任意支持的方法来使用日期：\n```\nboolean after(Date date)\n如果调用的 Date 对象中包含的日期在 date 指定的日期之后，则返回 true，否则返回 false。\n```\n```\nboolean before(Date date)\n如果调用的 Date 对象中包含的日期在 date 指定的日期之前，则返回 true，否则返回 false。\n```\n```\nObject clone( )\n重复调用 Date 对象。\n```\n```\nint compareTo(Date date)\n把调用对象的值与 date 的值进行比较。如果两个值是相等的，则返回 0。如果调用对象在 date 之前，则返回一个负值。如果调用对象在 date 之后，则返回一个正值。\n```\n```\nint compareTo(Object obj)\n如果 obj 是 Date 类，则操作等同于 compareTo(Date)。否则，它会抛出一个 ClassCastException。\n```\n```\nboolean equals(Object date)\n如果调用的 Date 对象中包含的时间和日期与 date 指定的相同，则返回 true，否则返回 false。\n```\n```\nlong getTime( )\n返回 1970 年 1 月 1 日以来经过的毫秒数。\n```\n```\nint hashCode( )\n为调用对象返回哈希代码。\n```\n```\nvoid setTime(long time)\n设置 time 指定的时间和日期，这表示从 1970 年 1 月 1 日凌晨零点以来经过的时间（以毫秒为单位）。\n```\n```\nString toString( )\n转换调用的 Date 对象为一个字符串，并返回结果。\n```\n\n### 获取当前的日期和时间\n\n在 Java Servlet 中获取当前的日期和时间是非常容易的。你可以使用一个带有 `toString()` 方法的简单的 Date 对象来输出当前的日期和时间，如下所示：\n```java\n// Import required java libraries\nimport java.io.*;\nimport java.util.Date;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/CurrentDate\")\npublic class CurrentDate extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Display Current Date & Time\";\n      Date date = new Date();\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<h2 align=\\\"center\\\">\" + date.toString() + \"</h2>\\n\" +\n        \"</body></html>\");\n  }\n}\n```\n\n现在，让我们来编译上述 servlet 并在 web.xml 文件中创建适当的条目，然后使用 URL http://localhost:8080/CurrentDate 来调用该 servlet。这将会产生如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/12.png)\n\n尝试刷新 URLhttp://localhost:8080/CurrentDate，每隔几秒刷新一次你都会发现显示时间的差异。\n\n### 日期比较\n\n正如我上面所提到的一样，你可以在 Servlet 中使用所有可用的 Java 方法。如果你需要比较两个日期，以下是方法：\n\n* 你可以使用 `getTime()` 来获取两个对象自 1970 年 1 月 1 日凌晨零点以来经过的毫秒数，然后比较这两个值。\n* 你可以使用方法 `before()`、`after()` 和 `equals()`。由于一个月里 12 号在 18 号之前，例如，new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回 true。\n* 你可以使用 `compareTo()` 方法，该方法由 Comparable 接口定义并由 Date 实现。\n\n正如我上面所提到的一样，你可以在 Servlet 中使用所有可用的 Java 方法。如果你需要比较两个日期，以下是方法：\n\n* 你可以使用 `getTime()` 来获取两个对象自 1970 年 1 月 1 日凌晨零点以来经过的毫秒数，然后比较这两个值。\n* 你可以使用方法 `before()`、`after()` 和 `equals()`。由于一个月里 12 号在 18 号之前，例如，new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回 true。\n* 你可以使用 `compareTo()` 方法，该方法由 Comparable 接口定义并由 Date 实现。\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和解析日期的具体类。 SimpleDateFormat 允许你通过为日期时间格式化选择任何用户定义的模式开始。\n```java\n// Import required java libraries\nimport java.io.*;\nimport java.text.*;\nimport java.util.Date;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n// Extend HttpServlet class\n\n@WebServlet(urlPatterns = \"/CurrentDate\")\npublic class CurrentDate extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\"); \n      PrintWriter out = response.getWriter();\n      String title = \"Display Current Date & Time\";\n      Date dNow = new Date( );\n      SimpleDateFormat ft = \n      new SimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\");\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<h2 align=\\\"center\\\">\" + ft.format(dNow) + \"</h2>\\n\" +\n        \"</body></html>\");\n  }\n}\n```\n\n再次编译上述 servlet，然后使用 URL http://localhost:8080/CurrentDate 来调用该 servlet。这将会产生如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-3/13.png)\n\n要指定时间格式，那么使用时间模式的字符串。在这种模式下，所有的 ASCII 字母被保留为模式字母，这些字母定义如下：\n\n| 字符\t| 描述\t    |    实例 |\n| - | - | - |\n| G\t    | 时代指示器\t                | AD |\n| y\t    | 四位数的年\t                | 2001 |\n| M\t    | 一年中的月\t                | July 或 07 |\n| d\t    | 一月中的第几天\t            | 10 |\n| h\t    | 带有 A.M./P.M. 的小时（1~12）\t| 12 |\n| H\t    | 一天中的第几小时（0~23）\t     | 22 |\n| m\t    | 一小时中的第几分\t             | 30 |\n| s\t    | 一分中的第几秒\t             | 55 |\n| S\t    | 毫秒\t234 |\n| E\t    | 一周中的星期几\t| Tuesday |\n| D\t    | 一年中的第几天\t| 360 |\n| F\t    | 一个月中的某一周的某一天\t| 2 (second Wed. in July) |\n| w\t    | 一年中的第几周\t| 40 |\n| W\t    | 一月中的第几周\t| 1 |\n| a\t    | A.M./P.M. 标记\t| PM |\n| k\t    | 一天中的第几小时（1~24）\t| 24 |\n| K\t    | 带有 A.M./P.M. 的小时（0~11）\t| 10 |\n| z\t    | 时区\t| Eastern Standard Time |\n| '\t    | Escape for text\t| 分隔符 |\n| \"\t    | 单引号\t| ` |\n\n---\n\n## Source & Reference\n\n- http://wiki.jikexueyuan.com/project/servlet/cookies-handling.html\n- https://wiki.jikexueyuan.com/project/servlet/session-tracking.html\n- https://wiki.jikexueyuan.com/project/servlet/database-access.html\n- https://wiki.jikexueyuan.com/project/servlet/file-uploading.html\n- https://wiki.jikexueyuan.com/project/servlet/handling-date.html\n", "timestamp": "2025-10-19T19:25:26.223052"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/servlet/servlet-4.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/servlet/servlet-4.md", "content": "# servlet-4\n\n---\n\n## 页面重定向\n\n当文档移动到一个新的位置时，通常会使用页面重定向，我们需要将客户端发送到这个新位置或者也可能是由于负载均衡，或者只是为了简单的随机。\n\n重定向请求到另一个页面的最简单的方式是使用 response 对象的 `sendRedirect()` 方法。下面是该方法的特征：\n\n```java\npublic void HttpServletResponse.sendRedirect(String location)\nthrows IOException\n```\n\n该方法将响应和状态码及新的页面位置发送回浏览器。你也可以通过一起使用 `setStatus()` 和 `setHeader()` 方法来达到同样的效果：\n```java\n....\nString site = \"http://www.newpage.com\" ;\nresponse.setStatus(response.SC_MOVED_TEMPORARILY);\nresponse.setHeader(\"Location\", site);\n....\n```\n\n这个例子显示了 servlet 如何将页面重定向到另一个位置：\n\n```java\nimport java.io.*;\nimport java.sql.Date;\nimport java.util.*;\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\n\n@WebServlet(urlPatterns = \"/PageRedirect\")\npublic class PageRedirect extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      // New location to be redirected\n      String site = new String(\"http://www.ffffffff0x.com\");\n      response.setStatus(response.SC_MOVED_TEMPORARILY);\n      response.setHeader(\"Location\", site);\n    }\n}\n```\n\n现在使用 URL http://localhost:8080/PageRedirect 来调用这个 servlet。这将使你跳转到给定的 URL http://www.ffffffff0x.com 中。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-4/1.png)\n\n---\n\n## 点击计数器\n\n### Web 页面的点击计数器\n\n很多时候，你可能有兴趣知道你网站的某个特定页面上的总点击量。使用 servlet 来计算这些点击量是非常简单的，因为一个 servlet 的生命周期是由它运行的容器控制的。\n\n以下是基于 Servlet 生命周期实现一个简单的页面点击计数器需要的步骤：\n\n* 在 `init()` 方法中初始化一个全局变量。\n* 每次调用 `doGet()` 或 `doPost()` 方法时，增加全局变量。\n* 如果需要，你可以使用一个数据库表来存储 `destroy()` 方法中的全局变量。在下次初始化 servlet 时，这个值可以在 `init()` 方法内被读取。这一步是可选的。\n* 如果你想计算一个会话内一个页面的点量击，那么你可以使用 `isNew()` 方法来查看该会话内是否已点击过相同的页面。这一步是可选的。\n* 你可以显示全局计数器的值来显示网站中的总点击量。这一步是可选的。\n\n在这里我假设 web 容器不会被重新启动。如果 web 容器被重新启动或 servlet 被销毁，计数器将被重置。\n\n这个例子演示了如何实现一个简单的页面点击计数器：\n```java\nimport java.io.*;\nimport java.sql.Date;\nimport java.util.*;\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.*;\n\n@WebServlet(urlPatterns = \"/PageHitCounter\")\npublic class PageHitCounter extends HttpServlet{\n  private int hitCount;\n  public void init()\n  {\n     // Reset hit counter.\n     hitCount = 0;\n  }\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      // This method executes whenever the servlet is hit\n      // increment hitCount\n      hitCount++;\n      PrintWriter out = response.getWriter();\n      String title = \"Total Number of Hits\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<h2 align=\\\"center\\\">\" + hitCount + \"</h2>\\n\" +\n        \"</body></html>\");\n  }\n  public void destroy()\n  {\n      // This is optional step but if you like you\n      // can write hitCount value in your database.\n  }\n}\n```\n\n现在使用 URL http://localhost:8080/PageHitCounter 来调用这个 servlet。每次页面刷新时，计数器的值都会加 1，这将产生如下所示的结果：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-4/2.png)\n\n### 网站点击计数器\n\n很多时候，你可能有兴趣知道你整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器实现这一点。\n\n以下是实现一个基于过滤器生命周期的简单的网站点击计数器需要的步骤：\n* 在过滤器的 init() 方法中初始化一个全局变量。\n* 每次调用 doFilter 方法时，增加全局变量。\n* 如果需要，你可以使用一个数据库表来存储过滤器的 destroy() 方法中的全局变量的值。在下次初始化过滤器时，该值可以在 init() 方法内被读取。这一步是可选的。\n\n在这里我假设 web 容器不会被重新启动。如果 web 容器被重新启动或 servlet 被销毁，点击计数器将被重置。\n\n这个例子演示了如何实现一个简单的网站点击计数器：\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.*;\n\npublic class SiteHitCounter implements Filter{\n  private int hitCount;\n  public void  init(FilterConfig config)\n                    throws ServletException{\n     // Reset hit counter.\n     hitCount = 0;\n  }\n  public void  doFilter(ServletRequest request,\n              ServletResponse response,\n              FilterChain chain)\n              throws java.io.IOException, ServletException {\n      // increase counter by one\n      hitCount++;\n      // Print the counter.\n      System.out.println(\"Site visits count :\"+ hitCount );\n      // Pass request back down the filter chain\n      chain.doFilter(request,response);\n  }\n  public void destroy()\n  {\n      // This is optional step but if you like you\n      // can write hitCount value in your database.\n  }\n}\n```\n\n现在让我们来编译上述 servlet 并在 web.xml 文件中创建以下条目：\n\n```xml\n....\n<filter>\n   <filter-name>SiteHitCounter</filter-name>\n   <filter-class>SiteHitCounter</filter-class>\n</filter>\n<filter-mapping>\n   <filter-name>SiteHitCounter</filter-name>\n   <url-pattern>/*</url-pattern>\n</filter-mapping>\n....\n```\n\n现在调用任意 URL 如 URLhttp://localhost:8080/。每次任意页面被点击时，计数器的值都会加 1 并且会在日志中显示如下所示的消息：\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-4/3.png)\n\n---\n\n## 自动刷新页面\n\n假设一个 web 页面，显示了现场比赛得分或股票市场状况或货币兑换率。对于所有这些类型的页面，你都需要使用你浏览器中的 refresh 或 reload 按钮来定期刷新 web 页面。\n\nJava Servlet 提供给你一个机制使这项工作变得简单，可以使得 web 页面在给定的时间间隔自动刷新。\n\n刷新一个 web 页面最简单的方式是使用响应对象的方法 `setIntHeader()`。以下是这种方法的特征：\n\n```java\npublic void setIntHeader(String header, int headerValue)\n```\n\n此方法将头信息 “Refresh” 和一个表示时间间隔的整数值（以秒为单位）发送回浏览器。\n\n---\n\n## 包\n\n涉及到 WEB-INF 子目录的 web 应用程序结构是所有的 Java web 应用程序的标准，并且是由 servlet API 规范指定的。给定一个 myapp 的顶级目录名，这里是目录结构，如下所示：\n\n```\n/myapp\n    /images\n    /WEB-INF\n        /classes\n        /lib\n```\n\nWEB-INF 子目录包含了应用程序的部署描述符，命名为 web.xml。所有的 HTML 文件都位于顶级目录 myapp 下。对于管理员用户，你会发现 ROOT 目录是和 myApp 一样的父目录。\n\n### 创建包中的 Servlets\n\nWEB-INF/classes 目录在与它们的包名称匹配的结构中包含了所有的 servlet 类和其他的类文件。例如，如果你有一个完全合格的类名称 com.myorg.MyServlet，那么这个 servlet 类必须被放置在如下所示的目录中：\n\n```\n/myapp/WEB-INF/classes/com/myorg/MyServlet.class\n```\n\n下面是创建包名为 com.myorg 的 MyServlet 类的例子\n```java\n// Name your package\npackage com.myorg;\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\npublic class MyServlet extends HttpServlet {\n  private String message;\n  public void init() throws ServletException\n  {\n      // Do required initialization\n      message = \"Hello World\";\n  }\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      // Set response content type\n      response.setContentType(\"text/html\");\n      // Actual logic goes here.\n      PrintWriter out = response.getWriter();\n      out.println(\"<h1>\" + message + \"</h1>\");\n  }\n  public void destroy()\n  {\n      // do nothing.\n  }\n}\n```\n\n### 编译包中的 Servlets\n\n编译包中可用的类没有什么大的不同。最简单的方法是将你的 java 文件保存在完全限定路径中，正如上面所提到的一样，类将被保存在 com.myorg 中。你还需要将该目录添加到 CLASSPATH 中。\n\n假设你的环境已正确设置，进入 `<Tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes` 目录并编译 MyServlet.java，如下所示：\n```\n$ javac MyServlet.java\n```\n\n如果 servlet 依赖于任何其他的库，那么你必须在你的 CLASSPATH 中包含那些 JAR 文件。我只包含了 servlet-api.jar JAR 文件，因为我在 Hello World 程序中没有使用任何其他的库。\n\n该命令行使用来自 Sun Microsystems Java 软件开发工具包（JDK）内置的 javac 编译器。为了让该命令正常工作，必须包括你在 PATH 环境变量中所使用的 Java SDK 的位置。\n\n如果一切顺利，上述编译会在相同的目录下生成 MyServlet.class 文件。下一节将解释如何在生产中部署一个已编译的 servlet。\n\n### 打包的 Servlet 部署\n\n默认情况下，servlet 应用程序位于路径 `<Tomcat-installation-directory>/webapps/ROOT` 下且类文件放在 `<Tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes` 中。\n\n如果你有一个完全合格的类名称 com.myorg.MyServlet，那么这个 servlet 类必须位于 `WEB-INF/classes/com/myorg/MyServlet.class` 中，你需要在位于 `<Tomcat-installation-directory>/webapps/ROOT/WEB-INF/` 的 web.xml 文件中创建以下条目：\n\n```xml\n<servlet>\n   <servlet-name>MyServlet</servlet-name>\n   <servlet-class>com.myorg.MyServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n   <servlet-name>MyServlet</servlet-name>\n   <url-pattern>/MyServlet</url-pattern>\n</servlet-mapping>\n```\n\n上述条目要被创建在 web.xml 文件中的 `<web-app>...</web-app>` 标签内。在该文件中可能已经有各种可用的条目，但没有关系。\n\n你基本上已经完成了，现在让我们使用 `<Tomcat-installation-directory>\\bin\\startup.bat`（Windows 操作系统中）或 `<Tomcat-installation-directory>/bin/startup.sh`（Linux/Solaris 等操作系统中）启动 tomcat 服务器，最后在浏览器的地址栏中输入 http://localhost:8080/MyServlet\n\n---\n\n## 调试\n\n测试/调试 servlet 始终是困难的。Servlets 往往涉及大量的客户端/服务器交互，可能会出现错误但是又难以重现。\n\n这里有一些提示和建议，可以帮助你调试。\n\n### System.out.println()\n\n`System.out.println()` 作为一个标记用来测试某一代码片段是否被执行，使用方法非常简单。我们也可以输出变量值。另外：\n\n由于 System 对象是核心 Java 对象的一部分，它可以用于任何不需要安装任何额外类的地方。这包括 Servlets、JSP、RMI、EJB's、普通的 Beans 和类，以及独立的应用程序。\n\n与在断点处停止相比，写入 System.out 不会对应用程序的正常执行流程有太多干扰，这使得它在时序重要的时候显得非常有价值。\n以下使用 `System.out.println()` 的语法：\n\n```\nSystem.out.println(\"Debugging message\");\n```\n\n通过上述语法生成的所有消息将被记录在 web 服务器的日志文件中。\n\n### 消息记录\n\n利用标准日志记录方法，使用适当的日志记录方法来记录所有调试、警告和错误消息是非常好的想法，我使用的是 log4J 来记录所有的消息。\n\nServlet API 还提供了一个简单的输出信息的方式，使用 `log()` 方法，如下所示：\n\n```java\n// Import required java libraries\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\n@WebServlet(urlPatterns = \"/ContextLog\")\npublic class ContextLog extends HttpServlet {\n  public void doGet(HttpServletRequest request,\n      HttpServletResponse response) throws ServletException,\n         java.io.IOException {\n      String par = request.getParameter(\"par1\");\n      //Call the two ServletContext.log methods\n      ServletContext context = getServletContext( );\n      if (par == null || par.equals(\"\"))\n      //log version with Throwable parameter\n      context.log(\"No message received:\",\n          new IllegalStateException(\"Missing parameter\"));\n      else\n          context.log(\"Here is the visitor's message: \" + par);\n      response.setContentType(\"text/html\");\n      java.io.PrintWriter out = response.getWriter( );\n      String title = \"Context Log\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + title + \"</h1>\\n\" +\n        \"<h2 align=\\\"center\\\">Messages sent</h2>\\n\" +\n        \"</body></html>\");\n    } //doGet\n}\n```\n\nServletContext 把它的文本消息记录到 servlet 容器的日志文件中。使用 Tomcat，这些日志可以在 `<Tomcat-installation-directory>/logs` 目录中找到。\n\n这些日志文件确实为新出现的错误或问题的频率给出了指示。正因为如此，在通常不会出现的异常 catch 子句中使用 `log()` 函数是很好的。\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-4/4.png)\n\n![](../../../../../../assets/img/Develop/Java/笔记/Web/servlet/servlet-4/5.png)\n\n### 使用 JDB 调试器\n\n你可以使用调试 applet 或应用程序的相同的 jdb 命令来调试 servlet。\n\n为了调试一个 servlet，我们可以调试 sun.servlet.http.HttpServer，然后把它看成是 HttpServer 执行 servlet 来响应来自浏览器端的 HTTP 请求。这与调试 applet 小程序的方式非常相似。与调试 applet 不同的是，被调试的实际程序是 sun.applet.AppletViewer。\n\n大多数调试器会自动隐藏了解如何调试 applet 的细节。直到他们为 servlet 做同样的事情，你必须做以下操作来帮助你的调试器：\n\n* 设置你的调试器的类路径，以便它可以找到 sun.servlet.http.Http-Server 和相关的类。\n* 设置你的调试器的类路径，以便它可以找到你的 servlet 和支持的类，通常是在 server_root/servlets 和 server_root/classes 中。\n\n你通常不会希望 server_root/servlets 在你的 classpath 中，因为它会禁用 servlet 的重载。然而这种包含对于调试是有用的。在 HttpServer 中的自定义的 servlet 加载器加载 servlet 之前，它允许你的调试器在 servlet 中设置断点。\n\n一旦你设置了正确的类路径，就可以开始调试 sun.servlet.http.HttpServer。你可以在任何你想要调试的 servlet 中设置断点，然后使用 web 浏览器为给定的 servlet（http://localhost:8080/servlet/ServletToDebug) 向 HttpServer 发出请求。你会看到程序执行到你设置的断点处停止。\n\n#### 使用注释\n\n代码中的注释有助于以各种方式调试程序。注释可用于调试过程中的许多其他方式中。\n\nServlet 使用 Java 注释，单行注释（//...）和多行注释（/ .../）可用于暂时移除部分 Java 代码。如果 bug 消失，仔细看看你之前注释的代码并找出问题所在。\n\n#### 客户端和服务器端头信息\n\n有时，当一个 servlet 并没有像预期那样工作时，查看原始的 HTTP 请求和响应是非常有用的。如果你对 HTTP 结构很熟悉，你可以阅读请求和响应，看看这些头信息中究竟是什么。\n\n#### 重要的调试技巧\n\n这里是 servlet 调试中的一些调试技巧列表：\n\n* 请注意 server _ root/classes 不会重载，而 server_root/servlets 可能会。\n* 要求浏览器显示它所显示的页面的原始内容。这有助于识别格式的问题。它通常是视图菜单下的一个选项。\n* 通过强制执行完全重载页面，来确保浏览器还没有缓存前一个请求的输出。在 Netscape Navigator 中，使用 Shift-Reload；在 IE 浏览器中，请使用 Shift-Refresh。\n* 确认 servlet 的 `init()` 方法接受一个 ServletConfig 参数并立即调用 `super.init(config)`。\n\n---\n\n## 国际化\n\n在我们继续之前，请让我解释三个重要术语：\n\n* 国际化（i18n）：这意味着网站能够提供翻译成访问者的语言或国籍的不同版本的内容。\n* 本地化（l10n）：这意味着向网站添加资源，使其适应特定的地理或文化区域，例如网站翻译成印地语。\n* 区域设置：这是一个特殊的文化或地理区域。它通常指语言符号后跟一个由下划线分隔的国家符号。例如 \"en_US\" 表示 US 的英语区域设置。\n当建立一个全球性的网站时有一些注意事项。本教程不会给出完整的细节，但它会通过一个很好的例子向你演示如何通过差异化定位（即区域设置）来让网页以不同的语言呈现。\n\nServlet 可以根据请求者的区域设置读出相应版本的网站，并根据当地的语言、文化和需求提供相应的网站版本。以下是 request 对象中的方法，它返回了 Locale 对象。\n```java\njava.util.Locale request.getLocale()\n```\n\n### 检测区域设置\n\n下面列出了重要的区域设置方法，你可以使用它们来检测请求者的地理位置、语言和区域设置。下面所有的方法都显示请求者浏览器中设置的国家名称和语言名称。\n\n```\nString getCountry()\n该方法以 2 个大写字母形式的 ISO 3166 格式返回该区域设置的国家/地区代码。\n```\n\n```\nString getDisplayCountry()\n该方法返回适合向用户显示的区域设置的国家的名称。\n```\n\n```\nString getLanguage()\n该方法以小写字母形式的 ISO 639 格式返回该区域设置的语言代码。\n```\n\n```\nString getDisplayLanguage()\n该方法返回适合向用户显示的区域设置的语言的名称。\n```\n\n```\nString getISO3Country()\n该方法返回该区域设置的国家的三个字母缩写。\n```\n\n```\nString getISO3Language()\n该方法返回该区域设置的语言的三个字母的缩写。\n```\n\n这个例子向你演示了如何为一个请求显示语言和相关的国家：\n```java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.Locale;\npublic class GetLocale extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n      //Get the client's Locale\n      Locale locale = request.getLocale();\n      String language = locale.getLanguage();\n      String country = locale.getCountry();\n      // Set response content type\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      String title = \"Detecting Locale\";\n      String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n        \"<html>\\n\" +\n        \"<head><title>\" + title + \"</title></head>\\n\" +\n        \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n        \"<h1 align=\\\"center\\\">\" + language + \"</h1>\\n\" +\n        \"<h2 align=\\\"center\\\">\" + country + \"</h2>\\n\" +\n        \"</body></html>\");\n  }\n}\n```\n\n### 语言设置\n\nServlet 可以输出以西欧语言编写的页面，如英语、西班牙语、德语、法语、意大利语、荷兰语等。在这里，设置 Content-Language 头信息来正确的显示所有字符是非常重要的。\n\n第二点是使用 HTML 实体显示所有的特殊字符，例如，`&#241;` 表示 \"ñ\"，`&#161;` 表示 \"¡\"，如下所示：\n```java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.Locale;\npublic class DisplaySpanish extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n    // Set response content type\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    // Set spanish language code.\n    response.setHeader(\"Content-Language\", \"es\");\n    String title = \"En Espa&ntilde;ol\";\n    String docType =\n     \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n     \"transitional//en\\\">\\n\";\n     out.println(docType +\n     \"<html>\\n\" +\n     \"<head><title>\" + title + \"</title></head>\\n\" +\n     \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n     \"<h1>\" + \"En Espa&ntilde;ol:\" + \"</h1>\\n\" +\n     \"<h1>\" + \"&iexcl;Hola Mundo!\" + \"</h1>\\n\" +\n     \"</body></html>\");\n  }\n}\n```\n\n### 特定于区域设置的日期\n\n你可以使用 java.text.DateFormat 类及其静态的 `getDateTimeInstance()` 方法来格式化特定于区域设置的日期和时间。下面的例子向你演示了如何格式化特定于一个给定的区域设置的日期：\n\n```java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.Locale;\nimport java.text.DateFormat;\nimport java.util.Date;\npublic class DateLocale extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n    // Set response content type\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    //Get the client's Locale\n    Locale locale = request.getLocale( );\n    String date = DateFormat.getDateTimeInstance(\n                                  DateFormat.FULL,\n                                  DateFormat.SHORT,\n                                  locale).format(new Date( ));\n    String title = \"Locale Specific Dates\";\n    String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n      \"<html>\\n\" +\n      \"<head><title>\" + title + \"</title></head>\\n\" +\n      \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n      \"<h1 align=\\\"center\\\">\" + date + \"</h1>\\n\" +\n      \"</body></html>\");\n  }\n}\n```\n\n### 特定于区域设置的货币\n\n你可以使用 `java.text.NumberFormat` 类及其静态的 `getCurrencyInstance()` 方法来在特定于区域设置的货币中格式化数字，比如 long 类型或 double 类型。下面的例子向你演示了如何格式化特定于一个给定的区域设置的货币：\n\n```java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.Locale;\nimport java.text.NumberFormat;\nimport java.util.Date;\npublic class CurrencyLocale extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n    // Set response content type\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    //Get the client's Locale\n    Locale locale = request.getLocale( );\n    NumberFormat nft = NumberFormat.getCurrencyInstance(locale);\n    String formattedCurr = nft.format(1000000);\n    String title = \"Locale Specific Currency\";\n    String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n      \"<html>\\n\" +\n      \"<head><title>\" + title + \"</title></head>\\n\" +\n      \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n      \"<h1 align=\\\"center\\\">\" + formattedCurr + \"</h1>\\n\" +\n      \"</body></html>\");\n  }\n}\n```\n\n### 特定于区域设置的百分比\n\n你可以使用 `java.text.NumberFormat` 类及其静态的 `getPercentInstance()` 方法来格式化特定于区域设置的百分比。下面的例子向你演示了如何格式化特定于一个给定的区域设置的百分比：\n\n```java\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\nimport java.util.Locale;\nimport java.text.NumberFormat;\nimport java.util.Date;\npublic class PercentageLocale extends HttpServlet{\n  public void doGet(HttpServletRequest request,\n                    HttpServletResponse response)\n            throws ServletException, IOException\n  {\n    // Set response content type\n    response.setContentType(\"text/html\");\n    PrintWriter out = response.getWriter();\n    //Get the client's Locale\n    Locale locale = request.getLocale( );\n    NumberFormat nft = NumberFormat.getPercentInstance(locale);\n    String formattedPerc = nft.format(0.51);\n    String title = \"Locale Specific Percentage\";\n    String docType =\n      \"<!doctype html public \\\"-//w3c//dtd html 4.0 \" +\n      \"transitional//en\\\">\\n\";\n      out.println(docType +\n      \"<html>\\n\" +\n      \"<head><title>\" + title + \"</title></head>\\n\" +\n      \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" +\n      \"<h1 align=\\\"center\\\">\" + formattedPerc + \"</h1>\\n\" +\n      \"</body></html>\");\n  }\n}\n```\n\n---\n\n## Source & Reference\n\n- https://wiki.jikexueyuan.com/project/servlet/page-redirect.html\n- https://wiki.jikexueyuan.com/project/servlet/hits-counter.html\n- https://wiki.jikexueyuan.com/project/servlet/auto-refresh.html\n- https://wiki.jikexueyuan.com/project/servlet/packaging.html\n- https://wiki.jikexueyuan.com/project/servlet/debugging.html\n- https://wiki.jikexueyuan.com/project/servlet/internationalization.html\n", "timestamp": "2025-10-19T19:25:26.400860"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/Web/部署.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/Web/%E9%83%A8%E7%BD%B2.md", "content": "# 部署\n\n---\n\n对一个 Web 应用程序来说，除了 Servlet、Filter 这些逻辑组件，还需要 JSP 这样的视图文件，外加一堆静态资源文件，如 CSS、JS 等。\n\n合理组织文件结构非常重要。我们以一个具体的 Web 应用程序为例：\n```\nwebapp\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── com\n        │       └── itranswarp\n        │           └── learnjava\n        │               ├── Main.java\n        │               ├── filter\n        │               │   └── EncodingFilter.java\n        │               └── servlet\n        │                   ├── FileServlet.java\n        │                   └── HelloServlet.java\n        ├── resources\n        └── webapp\n            ├── WEB-INF\n            │   └── web.xml\n            ├── favicon.ico\n            └── static\n                └── bootstrap.css\n```\n\n我们把所有的静态资源文件放入 `/static/` 目录，在开发阶段，有些 Web 服务器会自动为我们加一个专门负责处理静态文件的 Servlet，但如果 `IndexServlet` 映射路径为 `/`，会屏蔽掉处理静态文件的 Servlet 映射。因此，我们需要自己编写一个处理静态文件的 `FileServlet`：\n\n```java\n@WebServlet(urlPatterns = \"/static/*\")\npublic class FileServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        ServletContext ctx = req.getServletContext();\n        // RequestURI包含ContextPath,需要去掉:\n        String urlPath = req.getRequestURI().substring(ctx.getContextPath().length());\n        // 获取真实文件路径:\n        String filepath = ctx.getRealPath(urlPath);\n        if (filepath == null) {\n            // 无法获取到路径:\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        Path path = Paths.get(filepath);\n        if (!path.toFile().isFile()) {\n            // 文件不存在:\n            resp.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        // 根据文件名猜测Content-Type:\n        String mime = Files.probeContentType(path);\n        if (mime == null) {\n            mime = \"application/octet-stream\";\n        }\n        resp.setContentType(mime);\n        // 读取文件并写入Response:\n        OutputStream output = resp.getOutputStream();\n        try (InputStream input = new BufferedInputStream(new FileInputStream(filepath))) {\n            input.transferTo(output);\n        }\n        output.flush();\n    }\n}\n```\n\n这样一来，在开发阶段，我们就可以方便地高效开发。\n\n类似 Tomcat 这样的 Web 服务器，运行的 Web 应用程序通常都是业务系统，因此，这类服务器也被称为应用服务器。应用服务器并不擅长处理静态文件，也不适合直接暴露给用户。通常，我们在生产环境部署时，总是使用类似 Nginx 这样的服务器充当反向代理和静态服务器，只有动态请求才会放行给应用服务器，所以，部署架构如下：\n\n```\n             ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐\n\n             │  /static/*            │\n┌───────┐      ┌──────────> file\n│Browser├────┼─┤                     │    ┌ ─ ─ ─ ─ ─ ─ ┐\n└───────┘      │/          proxy_pass\n             │ └─────────────────────┼───>│  Web Server │\n                       Nginx\n             └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘    └ ─ ─ ─ ─ ─ ─ ┘\n```\n\n实现上述功能的 Nginx 配置文件如下：\n\n```\nserver {\n    listen 80;\n\n    server_name www.ffffffff0x.com;\n\n    # 静态文件根目录:\n    root /path/to/src/main/webapp;\n\n    access_log /var/log/nginx/webapp_access_log;\n    error_log  /var/log/nginx/webapp_error_log;\n\n    # 处理静态文件请求:\n    location /static {\n    }\n\n    # 处理静态文件请求:\n    location /favicon.ico {\n    }\n\n    # 不允许请求/WEB-INF:\n    location /WEB-INF {\n        return 404;\n    }\n\n    # 其他请求转发给Tomcat:\n    location / {\n        proxy_pass       http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n```\n\n使用 Nginx 配合 Tomcat 服务器，可以充分发挥 Nginx 作为网关的优势，既可以高效处理静态文件，也可以把 https、防火墙、限速、反爬虫等功能放到 Nginx 中，使得我们自己的 WebApp 能专注于业务逻辑。\n\n---\n\n## Source & Reference\n\n- https://www.liaoxuefeng.com/wiki/1252599548343744/1304266260086817\n", "timestamp": "2025-10-19T19:25:26.764381"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/安装与使用.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md", "content": "# 安装与使用\n\n---\n\n**下载安装包**\n\n先下载安装 JDK,访问 oracle 官网下载 https://www.oracle.com/java/technologies/javase-downloads.html\n\n![](../../../../assets/img/Develop/Java/笔记/安装与使用/1.png)\n\n**设置环境变量**\n\n安装完 JDK 后，需要设置一个 JAVA_HOME 的环境变量，它指向 JDK 的安装目录。在 Windows 下，它是安装目录，类似：\n```\nC:\\Program Files\\Java\\jdk-14.0.1\n```\n\n新建 JAVA_HOME\n```\nC:\\Program Files\\Java\\jdk-14.0.1（jdk目录路径）\n```\n\n![](../../../../assets/img/Develop/Java/笔记/安装与使用/2.png)\n\n把 JAVA_HOME 的 bin 目录附加到系统环境变量 PATH 上。它长这样：\n```\n%JAVA_HOME%\\bin\n```\n\n![](../../../../assets/img/Develop/Java/笔记/安装与使用/3.png)\n\n打开 cmd\n```\njava -version\njavac -version\n```\n\n![](../../../../assets/img/Develop/Java/笔记/安装与使用/4.png)\n\n---\n\n**JDK 目录**\n\n在 JAVA_HOME 的 bin 目录下找到很多可执行文件：\n- java：这个可执行程序其实就是 JVM，运行 Java 程序，就是启动 JVM，然后让 JVM 执行指定的编译后的代码；\n- javac：这是 Java 的编译器，它用于把 Java 源码文件（以 .java 后缀结尾）编译为 Java 字节码文件（以 .class 后缀结尾）；\n- jar：用于把一组 .class 文件打包成一个 .jar 文件，便于发布；\n- javadoc：用于从 Java 源码中自动提取注释并生成文档；\n- jdb：Java 调试器，用于开发阶段的运行调试。\n\n---\n\n**写一个 Java 程序运行测试**\n\n```java\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\");\n    }\n}\n```\n\n在一个 Java 程序中，你总能找到一个类似：\n```java\npublic class Hello {\n    ...\n}\n```\n的定义，这个定义被称为 class（类），这里的类名是 Hello，大小写敏感，class 用来定义一个类，public 表示这个类是公开的，public、class 都是 Java 的关键字，必须小写，Hello 是类的名字，按照习惯，首字母 H 要大写。而花括号 `{}` 中间则是类的定义。\n\n注意到类的定义中，我们定义了一个名为 main 的方法：\n```java\n    public static void main(String[] args) {\n        ...\n    }\n```\n\n方法是可执行的代码块，一个方法除了方法名 `main`，还有用 `()` 括起来的方法参数，这里的 `main` 方法有一个参数，参数类型是 `String[]`，参数名是 `args`，`public`、`static` 用来修饰方法，这里表示它是一个公开的静态方法，`void` 是方法的返回类型，而花括号 `{}` 中间的就是方法的代码。\n\n方法的代码每一行用 `;` 结束，这里只有一行代码，就是：\n```java\n    System.out.println(\"Hello, world!\");\n```\n\n它用来打印一个字符串到屏幕上。\n\nJava 规定，某个类定义的 `public static void main(String[] args)` 是 Java 程序的固定入口方法，因此，Java 程序总是从 main 方法开始执行。\n\n注意到 Java 源码的缩进不是必须的，但是用缩进后，格式好看，很容易看出代码块的开始和结束，缩进一般是4个空格或者一个 tab。\n\n最后，当我们把代码保存为文件时，文件名必须是 Hello.java，而且文件名也要注意大小写，因为要和我们定义的类名 Hello 完全保持一致。\n\n---\n\n**Java 程序如何运行**\n\nJava 源码本质上是一个文本文件，我们需要先用 javac 把 Hello.java 编译成字节码文件 Hello.class，然后，用 java 命令执行这个字节码文件.\n\n![](../../../../assets/img/Develop/Java/笔记/安装与使用/5.png)\n\n因此，可执行文件 javac 是编译器，而可执行文件 java 就是虚拟机。\n\n在保存 Hello.java 的目录下执行命令\n```\njavac Hello.java\n```\n\n如果源代码无误，上述命令不会有任何输出，而当前目录下会产生一个 Hello.class 文件\n```\n$ ls\nHello.class\tHello.java\n```\n\n第二步，执行 Hello.class，使用命令 java Hello\n```\n$ java Hello\nHello, world!\n```\n\n注意：给虚拟机传递的参数 Hello 是我们定义的类名，虚拟机自动查找对应的 class 文件并执行。\n\n直接运行 java Hello.java 也是可以的,这是 Java 11 新增的一个功能，它可以直接运行一个单文件源码\n```\njava Hello.java\n```\n\n需要注意的是，在实际项目中，单个不依赖第三方库的 Java 源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个 Java 源码文件，原因是它需要依赖其他的库。\n\n---\n\n**Source & Reference**\n- [java环境变量配置 - zhanghongxian - 博客园](https://www.cnblogs.com/zhanghongxian666/p/11149104.html)\n- [安装JDK - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649)\n", "timestamp": "2025-10-19T19:25:27.087349"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/工具.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7.md", "content": "# 工具\n\n---\n\n## jconsole\n\njconsole 是 JDK 自带的 GUI 工具。jconsole(Java Monitoring and Management Console) 是一种基于 JMX 的可视化监视与管理工具。\n\njconsole 的管理功能是针对 JMX MBean 进行管理，由于 MBean 可以使用代码、中间件服务器的管理控制台或所有符合 JMX 规范的软件进行访问。\n\n注意：使用 jconsole 的前提是 Java 应用开启 JMX。\n\n### 开启 JMX\n\nJava 应用开启 JMX 后，可以使用 jconsole 或 jvisualvm 进行监控 Java 程序的基本信息和运行情况。\n\n开启方法是，在 java 指令后，添加以下参数：\n```java\n-Dcom.sun.management.jmxremote=true\n-Dcom.sun.management.jmxremote.ssl=false\n-Dcom.sun.management.jmxremote.authenticate=false\n-Djava.rmi.server.hostname=127.0.0.1        //指定 Java 程序运行的服务器\n-Dcom.sun.management.jmxremote.port=18888   //指定 JMX 服务监听端口\n```\n\n### 连接 jconsole\n\n如果是本地 Java 进程，jconsole 可以直接绑定连接。\n\n如果是远程 Java 进程，需要连接 Java 进程的 JMX 端口。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/1.png)\n\n### jconsole 界面\n\n进入 jconsole 应用后，可以看到以下 tab 页面。\n\n* 概述 - 显示有关 Java VM 和监视值的概述信息。\n* 内存 - 显示有关内存使用的信息。内存页相当于可视化的 jstat 命令。\n* 线程 - 显示有关线程使用的信息。\n* 类 - 显示有关类加载的信息。\n* VM 摘要 - 显示有关 Java VM 的信息。\n* MBean - 显示有关 MBean 的信息。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/2.png)\n\n---\n\n## jvisualvm\n\njvisualvm 是 JDK 自带的 GUI 工具。jvisualvm(All-In-One Java Troubleshooting Tool) 是多合一故障处理工具。它支持运行监视、故障处理、性能分析等功能。\n\n### jvisualvm 概述页面\n\njvisualvm 概述页面可以查看当前 Java 进程的基本信息，如：JDK 版本、Java 进程、JVM 参数等。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/3.png)\n\n### jvisualvm 监控页面\n\n![](../../../../assets/img/Develop/Java/笔记/工具/4.png)\n\n### jvisualvm 线程页面\n\njvisualvm 线程页面展示了当前的线程状态。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/5.png)\n\njvisualvm 还可以生成线程 Dump 文件，帮助进一步分析线程栈信息。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/6.png)\n\n### jvisualvm 抽样器页面\n\njvisualvm 可以对 CPU、内存进行抽样，帮助我们进行性能分析。\n\n![](../../../../assets/img/Develop/Java/笔记/工具/7.png)\n\n---\n\n## MAT\n\nMAT 即 Eclipse Memory Analyzer Tool 的缩写。\n\nMAT 本身也能够获取堆的二进制快照。该功能将借助 `jps` 列出当前正在运行的 Java 进程，以供选择并获取快照。由于 `jps` 会将自己列入其中，因此你会在列表中发现一个已经结束运行的 `jps` 进程。\n\nMAT 可以独立安装，也可以作为 Eclipse IDE 的插件安装。\n\n- http://www.eclipse.org/mat/downloads.php\n\n### MAT 配置\n\nMAT 解压后，安装目录下有个 `MemoryAnalyzer.ini` 文件。\n\n`MemoryAnalyzer.ini` 中有个重要的参数 `Xmx` 表示最大内存，默认为：`-vmargs -Xmx1024m`\n\n如果试图用 MAT 导入的 dump 文件超过 1024 M，会报错：\n```\nAn internal error occurred during: \"Parsing heap dump from XXX\"\n```\n\n此时，可以适当调整 Xmx 大小。如果设置的 Xmx 数值过大，本机内存不足以支撑，启动 MAT 会报错：\n```\nFailed to create the Java Virtual Machine\n```\n\n---\n\n## Arthas\n\n- https://github.com/alibaba/arthas\n\nArthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。\n\nArthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。\n\n### 安装\n\n* 使用 arthas-boot(推荐)\n\n    下载 arthas-boot.jar，然后用 java -jar 的方式启动：\n\n    ```\n    curl -O https://arthas.aliyun.com/arthas-boot.jar\n    java -jar arthas-boot.jar\n    ```\n\n    打印帮助信息：\n\n    ```\n    java -jar arthas-boot.jar -h\n    ```\n\n    如果下载速度比较慢，可以使用 aliyun 的镜像：\n\n    ```\n    java -jar arthas-boot.jar --repo-mirror aliyun --use-http\n    ```\n\n* 使用 as.sh\n\n    Arthas 支持在 Linux/Unix/Mac 等平台上一键安装\n    ```\n    curl -L https://arthas.aliyun.com/install.sh | sh\n    ```\n    上述命令会下载启动脚本文件 as.sh 到当前目录，你可以放在任何地方或将其加入到 $PATH 中。\n\n    直接在 shell 下面执行./as.sh，就会进入交互界面。\n\n    也可以执行./as.sh -h 来获取更多参数信息。\n\n### 使用\n\n参考官方文档\n\n- https://github.com/alibaba/arthas/blob/master/README_CN.md\n- https://start.aliyun.com/handson-lab?category=arthas\n- https://arthas.aliyun.com/doc/quick-start.html\n\n---\n\n## jps\n\njps 是虚拟机进程状态工具。它可以显示指定系统内所有的 HotSpot 虚拟机进程状态信息。jps 通过 RMI 协议查询开启了 RMI 服务的远程虚拟机进程状态。\n\n### jps 命令用法\n\n```\njps [option] [hostid]\njps [-help]\n```\n\n如果不指定 hostid 就默认为当前主机或服务器。\n\n常用参数：\n\n* option - 选项参数\n    * -m - 输出 JVM 启动时传递给 `main()` 的参数。\n    * -l - 输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径。\n    * -v - 显示传递给 JVM 的参数。\n    * -q - 仅输出本地 JVM 进程 ID。\n    * -V - 仅输出本地 JVM 标识符。\n* hostid - RMI 注册表中注册的主机名。如果不指定 hostid 就默认为当前主机或服务器。\n\n其中 option、hostid 参数也可以不写。\n\n### jps 使用示例\n\n列出本地 Java 进程\n```\n$ jps\n18027 Java2Demo.JAR\n18032 jps\n18005 jstat\n```\n\n列出本地 Java 进程 ID\n```\n$ jps -q\n8841\n1292\n5398\n```\n\n列出本地 Java 进程 ID，并输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径\n```\n$ jps -l\n3002 /opt/jdk1.7.0/demo/jfc/Java2D/Java2Demo.JAR\n2857 sun.tools.jstatd.jstatd\n```\n\n---\n\n## jstat\n\n命令格式：\n```\njstat [option] VMID [interval] [count]\n```\n\n常用参数：\n* option - 选项参数，用于指定用户需要查询的虚拟机信息\n    * -class - 监视类装载、卸载数量、总空间以及类装载所耗费的时间\n    * -compiler：显示 JIT 编译的相关信息；\n    * -gc：监视 Java 堆状况，包括 Eden 区、两个 survivor 区、老年代、永久代等区的容量、已用空间、GC 时间合计等信息。\n    * -gccapacity：显示各个代的容量以及使用情况；\n    * -gcmetacapacity：显示 Metaspace 的大小；\n    * -gcnew：显示新生代信息；\n    * -gcnewcapacity：显示新生代大小和使用情况；\n    * -gcold：显示老年代和永久代的信息；\n    * -gcoldcapacity：显示老年代的大小；\n    * -gcutil：显示垃圾回收统计信息；\n    * -gccause：显示垃圾回收的相关信息（通 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；\n    * -printcompilation：输出 JIT 编译的方法信息。\n* VMID - 如果是本地虚拟机进程，则 VMID 与 LVMID 是一致的；如果是远程虚拟机进程，那 VMID 的格式应当是：`[protocol:][//]lvmid[@hostname[:port]/servername]`\n* interval - 查询间隔\n* count - 查询次数\n\n更详细说明可以参考\n- https://www.cnblogs.com/yjd_hycf_space/p/7755633.html\n\n### jstat 使用示例\n\n**类加载统计**\n\n使用 jstat -class pid 命令可以查看编译统计信息。\n* Loaded - 加载 class 的数量\n* Bytes - 所占用空间大小\n* Unloaded - 未加载数量\n* Bytes - 未加载占用空间\n* Time - 时间\n\n查看类加载信息\n```\n$ jstat -class 7129\nLoaded  Bytes  Unloaded  Bytes     Time\n 26749 50405.3      873  1216.8      19.75\n```\n\n**编译统计**\n\n使用 jstat -compiler pid 命令可以查看编译统计信息。\n* Compiled - 编译数量\n* Failed - 失败数量\n* Invalid - 不可用数量\n* Time - 时间\n* FailedType - 失败类型\n* FailedMethod - 失败的方法\n\n```\n$ jstat -compiler 7129\nCompiled Failed Invalid   Time   FailedType FailedMethod\n   42030      2       0   302.53          1 org/apache/felix/framework/BundleWiringImpl$BundleClassLoader findClass\n```\n\n**GC 统计**\n\n使用 jstat -gc pid time 命令可以查看 GC 统计信息。\n\n以 250 毫秒的间隔进行 7 个采样，并显示 -gcutil 选项指定的输出。\n```\n$ jstat -gcutil 21891 250 7\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00  97.02  70.31  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  86.23  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n  0.00  97.02  96.53  66.80  95.52  89.14      7    0.300     0    0.000    0.300\n 91.03   0.00   1.98  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  15.82  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n 91.03   0.00  17.80  68.19  95.89  91.24      8    0.378     0    0.000    0.378\n```\n\n以 1 秒的间隔进行 4 个采样，并显示-gc 选项指定的输出。\n```\n$ jstat -gc 25196 1s 4\n S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n20928.0 20928.0  0.0    0.0   167936.0  8880.5   838912.0   80291.2   106668.0 100032.1 12772.0 11602.2    760   14.332  580   656.218  670.550\n```\n\n参数说明：\n* S0C：年轻代中 To Survivor 的容量（单位 KB）；\n* S1C：年轻代中 From Survivor 的容量（单位 KB）；\n* S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；\n* S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；\n* EC：年轻代中 Eden 的容量（单位 KB）；\n* EU：年轻代中 Eden 目前已使用空间（单位 KB）；\n* OC：Old 代的容量（单位 KB）；\n* OU：Old 代目前已使用空间（单位 KB）；\n* MC：Metaspace 的容量（单位 KB）；\n* MU：Metaspace 目前已使用空间（单位 KB）；\n* YGC：从应用程序启动到采样时年轻代中 gc 次数；\n* YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；\n* FGC：从应用程序启动到采样时 old 代（全 gc）gc 次数；\n* FGCT：从应用程序启动到采样时 old 代（全 gc）gc 所用时间 (s)；\n* GCT：从应用程序启动到采样时 gc 用的总时间 (s)。\n\n---\n\n## jmap\n\njmap 是 Java 内存映像工具。jmap 用于生成堆转储快照（一般称为 heapdump 或 dump 文件）。jmap 不仅能生成 dump 文件，还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。\n\n如果不使用这个命令，还可以使用 `-XX:+HeapDumpOnOutOfMemoryError` 参数来让虚拟机出现 OOM 的时候，自动生成 dump 文件。\n\n### jmap 命令用法\n\n命令格式：\n```\njmap [option] pid\n```\n\noption 选项参数：\n* -dump - 生成堆转储快照。-dump:live 只保存堆中的存活对象。\n* -finalizerinfo - 显示在 F-Queue 队列等待执行 finalizer 方法的对象\n* -heap - 显示 Java 堆详细信息。\n* -histo - 显示堆中对象的统计信息，包括类、实例数量、合计容量。-histo:live 只统计堆中的存活对象。\n* -permstat - to print permanent generation statistics\n* -F - 当-dump 没有响应时，强制生成 dump 快照\n\n### jstat 使用示例\n\n**生成 heapdump 快照**\n\ndump 堆到文件，format 指定输出格式，live 指明是活着的对象，file 指定文件名\n```\n$ jmap -dump:live,format=b,file=dump.hprof 28920\nDumping heap to /home/xxx/dump.hprof ...\nHeap dump file created\n```\n\ndump.hprof 这个后缀是为了后续可以直接用 MAT(Memory Anlysis Tool)等工具打开。\n\n**#查看实例数最多的类**\n\n```\n$ jmap -histo 29527 | head -n 6\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:      13673280     1438961864  [C\n   2:       1207166      411277184  [I\n   3:       7382322      347307096  [Ljava.lang.Object;\n```\n\n**查看指定进程的堆信息**\n\n注意：使用 CMS GC 情况下，jmap -heap PID 的执行有可能会导致 java 进程挂起。\n```\n$ jmap -heap 12379\nAttaching to process ID 12379, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 17.0-b16\n\nusing thread-local object allocation.\nParallel GC with 6 thread(s)\n\nHeap Configuration:\n   MinHeapFreeRatio = 40\n   MaxHeapFreeRatio = 70\n   MaxHeapSize      = 83886080 (80.0MB)\n   NewSize          = 1310720 (1.25MB)\n   MaxNewSize       = 17592186044415 MB\n   OldSize          = 5439488 (5.1875MB)\n   NewRatio         = 2\n   SurvivorRatio    = 8\n   PermSize         = 20971520 (20.0MB)\n   MaxPermSize      = 88080384 (84.0MB)\n\nHeap Usage:\nPS Young Generation\nEden Space:\n   capacity = 9306112 (8.875MB)\n   used     = 5375360 (5.1263427734375MB)\n   free     = 3930752 (3.7486572265625MB)\n   57.761608714788736% used\nFrom Space:\n   capacity = 9306112 (8.875MB)\n   used     = 3425240 (3.2665634155273438MB)\n   free     = 5880872 (5.608436584472656MB)\n   36.80634834397007% used\nTo Space:\n   capacity = 9306112 (8.875MB)\n   used     = 0 (0.0MB)\n   free     = 9306112 (8.875MB)\n   0.0% used\nPS Old Generation\n   capacity = 55967744 (53.375MB)\n   used     = 48354640 (46.11457824707031MB)\n   free     = 7613104 (7.2604217529296875MB)\n   86.39733629427693% used\nPS Perm Generation\n   capacity = 62062592 (59.1875MB)\n   used     = 60243112 (57.452308654785156MB)\n   free     = 1819480 (1.7351913452148438MB)\n   97.06831451706046% used\n```\n\n---\n\n## jstack\n\njstack 是 Java 堆栈跟踪工具。jstack 用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁，并可以生成 java 虚拟机当前时刻的线程快照（一般称为 threaddump 或 javacore 文件）。\n\n线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。\n\n`jstack` 通常会结合 `top -Hp pid` 或 `pidstat -p pid -t` 一起查看具体线程的状态，也经常用来排查一些死锁的异常。\n\n线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。\n\n### jstack 命令用法\n\n命令格式：\n```\njstack [option] pid\n```\n\noption 选项参数\n* -F - 当正常输出请求不被响应时，强制输出线程堆栈\n* -l - 除堆栈外，显示关于锁的附加信息\n* -m - 打印 java 和 jni 框架的所有栈信息\n\n### jstack 使用示例\n\n**找出某 Java 进程中最耗费 CPU 的 Java 线程**\n\n1. 找出 Java 进程\n\n    假设应用名称为 myapp：\n    ```\n    $ jps | grep myapp\n    29527 myapp.jar\n    ```\n\n    得到进程 ID 为 21711\n\n2. 找出该进程内最耗费 CPU 的线程，可以使用 ps -Lfp pid 或者 ps -mp pid -o THREAD, tid, time 或者 top -Hp pid\n\n    TIME 列就是各个 Java 线程耗费的 CPU 时间，CPU 时间最长的是线程 ID 为 21742 的线程，用\n    ```\n    printf \"%x\\n\" 21742\n    ```\n\n    得到 21742 的十六进制值为 54ee\n\n3. 使用 jstack 打印线程堆栈信息\n\n    下一步终于轮到 jstack 上场了，它用来输出进程 21711 的堆栈信息，然后根据线程 ID 的十六进制值 grep，如下：\n    ```\n    $ jstack 21711 | grep 54ee\n    \"PollIntervalRetrySchedulerThread\" prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]\n    ```\n    可以看到 CPU 消耗在 PollIntervalRetrySchedulerThread 这个类的 Object.wait()。\n\n    注：上面的例子中，默认只显示了一行信息，但很多时候我们希望查看更详细的调用栈。可以通过指定 `-A <num>` 的方式来显示行数。例如：`jstack -l <pid> | grep <thread-hex-id> -A 10`\n\n3. 分析代码\n\n    定位到下面的代码：\n    ```\n    // Idle wait\n    getLog().info(\"Thread [\" + getName() + \"] is idle waiting...\");\n    schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;\n    long now = System.currentTimeMillis();\n    long waitTime = now + getIdleWaitTime();\n    long timeUntilContinue = waitTime - now;\n    synchronized(sigLock) {\n        try {\n            if(!halted.get()) {\n                sigLock.wait(timeUntilContinue);\n            }\n        }\n        catch (InterruptedException ignore) {\n        }\n    }\n    ```\n\n    它是轮询任务的空闲等待代码，上面的 `sigLock.wait(timeUntilContinue)` 就对应了前面的 `Object.wait()`。\n\n**生成 threaddump 文件**\n\n可以使用 `jstack -l <pid> > <file-path>` 命令生成 threaddump 文件\n\n生成进程 ID 为 8841 的 Java 进程的 threaddump 文件。\n```\njstack -l 8841 > /home/threaddump.txt\n```\n\n### thread dump 文件\n\njava thread dump 文件内容见 https://dunwu.github.io/javacore/jvm/jvm-cli-tools.html#_4-2-thread-dump-%E6%96%87%E4%BB%B6\n\n---\n\n## jinfo\n\njinfo 是 Java 配置信息工具。jinfo 用于实时查看和调整虚拟机运行参数。如传递给 Java 虚拟机的 `-X`（即输出中的 jvm_args）、`-XX` 参数（即输出中的 VM Flags），以及可在 Java 层面通过 System.getProperty 获取的 `-D` 参数（即输出中的 System Properties）。\n\n之前的 `jps -v` 口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用 jinfo 口令。\n\njinfo 命令格式：\n```\njinfo [option] pid\n```\n\noption 选项参数：\n* -flag - 输出指定 args 参数的值\n* -sysprops - 输出系统属性，等同于 `System.getProperties()`\n\njinfo 使用示例\n```\n$ jinfo -sysprops 29527\nAttaching to process ID 29527, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.222-b10\n...\n```\n\n---\n\n## jhat\n\njhat(JVM Heap Analysis Tool)，是虚拟机堆转储快照分析工具。jhat 与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。\n\n注意：一般不会直接在服务器上进行分析，因为 jhat 是一个耗时并且耗费硬件资源的过程，一般把服务器生成的 dump 文件，用 jvisualvm 、Eclipse Memory Analyzer、IBM HeapAnalyzer 等工具来分析。\n\n命令格式：\n```\njhat [dumpfile]\n```\n\n---\n\n## Source & Reference\n\n- https://dunwu.github.io/javacore/jvm/jvm-gui-tools.html\n- https://dunwu.github.io/javacore/jvm/jvm-cli-tools.html\n", "timestamp": "2025-10-19T19:25:27.258283"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "1earn/Develop/Java/笔记/爬虫.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/1earn/Develop/Java/%E7%AC%94%E8%AE%B0/%E7%88%AC%E8%99%AB.md", "content": "# 爬虫\n\n---\n\n**拆分过程**\n\n请求，过滤(提取)，存储\n\n---\n\n## 爬虫的请求\n\n### maven 依赖\n\n```xml\n        <dependency>\n            <groupId>org.apache.httpcomponents</groupId>\n            <artifactId>httpclient</artifactId>\n            <version>4.5.12</version>\n        </dependency>\n```\n\n### get请求\n\n```java\n    public static void main(String[] args) {\n        CloseableHttpClient client = HttpClients.createDefault(); //创建httpclient 对象。\n        HttpGet httpGet = new HttpGet(\"https://java.ffffffff0x.com/api\");  //创建get请求对象。\n        CloseableHttpResponse response = null;\n        try {\n            response = client.execute(httpGet);   //发送get请求\n            if (response.getStatusLine().getStatusCode()==200){\n                String s = EntityUtils.toString(response.getEntity(),\"utf-8\");\n                System.out.println(s);\n                System.out.println(httpGet);\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                response.close();\n                client.close();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n```\n\n### get携带参数请求\n\n```java\n    public static void main(String[] args) throws URISyntaxException {\n        CloseableHttpClient client = HttpClients.createDefault(); //创建httpclient 对象。\n        URIBuilder uriBuilder = new URIBuilder(\"https://java.ffffffff0x.com/api\");   //使用URIBuilder设置地址\n        uriBuilder.setParameter(\"page\",\"2\");    //设置传入参数\n        HttpGet httpGet = new HttpGet(uriBuilder.build());  //创建get请求对象。\n//        https://xz.aliyun.com/?page=1\n        CloseableHttpResponse response = null;\n        try {\n            response = client.execute(httpGet);   //发送get请求\n            if (response.getStatusLine().getStatusCode()==200){\n                String s = EntityUtils.toString(response.getEntity(),\"utf-8\");\n                System.out.println(s);\n                System.out.println(httpGet);\n\n            }\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                response.close();\n                client.close();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n```\n\n### post请求\n\n```java\n    public static void main(String[] args) {\n        CloseableHttpClient client = HttpClients.createDefault();\n        HttpPost httpPost = new HttpPost(\"https://java.ffffffff0x.com/api\");\n        CloseableHttpResponse response = null;\n        try {\n            response = client.execute(httpPost);\n\n                String s = EntityUtils.toString(response.getEntity());\n                System.out.println(s);\n                System.out.println(httpPost);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n在 get 和 post 的请求不携带参数请求当中，get 的请求方式和 post 的请求方式基本类似。但是创建请求对象时，get 请求用的是 HttpGet 来生成对象，而 Post 则是 HttpPost 来生成对象。\n\n### post携带参数请求\n\n```java\n    public static void main(String[] args) throws IOException {\n        CloseableHttpClient client = HttpClients.createDefault();//创建httpClients对象\n        HttpPost httpPost = new HttpPost(\"http://java.ffffffff0x.com/api\"); //设置请求对象\n        List<NameValuePair> params = new ArrayList<NameValuePair>();  //声明list集合，存储传入参数\n        params.add(new BasicNameValuePair(\"page\",\"3\"));\n        UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params,\"utf-8\"); //创建表单的Entity对象，传入params参数\n        httpPost.setEntity(formEntity);   //设置表单内容到post包中\n        CloseableHttpResponse response  = client.execute(httpPost);\n        String s = EntityUtils.toString(response.getEntity());\n        System.out.println(s);\n        System.out.println(s.length());\n        System.out.println(httpPost);\n    }\n```\n\n![](../../../../assets/img/Develop/Java/笔记/爬虫/1.png)\n\n### 走代理\n\n```java\n        //设置代理IP、端口、协议（请分别替换）\n        HttpHost proxy = new HttpHost(\"127.0.0.1\", 1080, \"http\");\n\n        //把代理设置到请求配置\n        RequestConfig defaultRequestConfig = RequestConfig.custom()\n                .setProxy(proxy)\n                .build();\n\n        //实例化CloseableHttpClient对象\n        CloseableHttpClient httpclient = HttpClients.custom().setDefaultRequestConfig(defaultRequestConfig).build();\n\n        //访问目标地址\n        HttpGet httpGet = new HttpGet(\"https://www.google.com\");\n\n        //请求返回\n        CloseableHttpResponse httpResp = httpclient.execute(httpGet);\n        try {\n            int statusCode = httpResp.getStatusLine().getStatusCode();\n            if (statusCode == HttpStatus.SC_OK) {\n                System.out.println(\"成功\");\n            }\n        } catch (Exception e) {\n\n        } finally {\n            httpResp.close();\n        }\n```\n\n---\n\n### 连接池\n\n如果每次请求都要创建 HttpClient，会有频繁创建和销毁的问题，可以使用连接池来解决这个问题。\n\n创建一个连接池对象：\n\n```java\nPoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n\npublic void setMaxTotal(int max)\n        设置最大连接数\n\npublic void setDefaultMaxPerRoute(int max)\n        设置每个主机的并发数\n```\n\n创建连接池代码\n\n```java\n    public static void main(String[] args) {\n        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();\n        cm.setMaxTotal(100); //设置最大连接数\n        cm.setDefaultMaxPerRoute(100);   //设置每个主机的并发数\n        doGet(cm);\n        doGet(cm);\n    }\n\n    private static void doGet(PoolingHttpClientConnectionManager cm) {\n        CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build();\n        HttpGet httpGet = new HttpGet(\"http://www.baidu.com\");\n        try {\n            CloseableHttpResponse response = httpClient.execute(httpGet);\n            String s = EntityUtils.toString(response.getEntity(),\"utf-8\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```\n\nHttpClient 请求配置\n\n```java\n    public static void main(String[] args) throws IOException {\n        CloseableHttpClient client = HttpClients.createDefault(); //创建httpclient 对象。\n        HttpGet httpGet = new HttpGet(\"http://www.baidu.com\");  //创建get请求对象。\n        RequestConfig config = RequestConfig.custom().setConnectTimeout(1000) // 设置创建连接的最长时间\n                .setConnectionRequestTimeout(500) //设置获取连接最长时间\n                .setSocketTimeout(500).build();  //设置数据传输最长时间\n\n        httpGet.setConfig(config);\n        CloseableHttpResponse response  = client.execute(httpGet);\n        String s = EntityUtils.toString(response.getEntity());\n        System.out.println(s);\n    }\n```\n\n## 爬虫的提取\n\n### jsoup\n\njsoup 是一款 Java 的 HTML 解析器，可直接解析某个 URL 地址、HTML 文本内容。它提供了一套非常省力的 API，可通过 DOM，CSS 以及类似于 jQuery 的操作方法来取出和操作数据。\n\njsoup 的主要功能如下：\n* 从一个 URL，文件或字符串中解析 HTML；\n* 使用 DOM 或 CSS 选择器来查找、取出数据；\n* 可操作 HTML 元素、属性、文本；\n\n**maven 依赖**\n\n```xml\n        <dependency>\n            <!-- jsoup HTML parser library @ http://jsoup.org/ -->\n            <groupId>org.jsoup</groupId>\n            <artifactId>jsoup</artifactId>\n            <version>1.10.2</version>\n        </dependency>\n```\n\n来一段爬取论坛 title 的代码\n```java\n    @Test\n    public void testUrl() throws Exception {\n        Document doc = Jsoup.parse(new URL(\"https://home.ffffffff0x.com/\"),10000);//设置请求url与超时时间\n        String title = doc.getElementsByTag(\"title\").first().text();// //获取title的内容\n        System.out.println(title);\n    }\n```\n\n这里的 first() 代表获取第一个元素，text() 表示获取标签内容\n\n### dom遍历元素\n\n```java\n    @Test\n    public void TestDom() throws IOException {\n        Document doc = Jsoup.parse(new URL(\"https://ffffffff0x.com/\"), 10000);\n        String title = doc.getElementsByTag(\"title\").text();\n        String h1 = doc.getElementsByTag(\"h1\").text();\n\n        String ex2 = doc.getElementsByClass(\"ex2\").first().text();\n        System.out.println(\"title : \"+title);\n        System.out.println(\"h1 : \"+h1);\n        System.out.println(\"ex2 : \"+ex2);\n    }\n```\n\n### 爬取文章\n\n```java\n    @Test\n    public void TestDom() throws IOException {\n        String url = \"https://www.freebuf.com/articles/network/274294.html\";\n\n        Document doc = Jsoup.parse(new URL(url), 10000);\n        String title = doc.getElementsByTag(\"title\").text();\n        String time = doc.getElementsByClass(\"author-info\").text();\n        String artical = doc.getElementsByClass(\"artical-body\").text();\n\n        System.out.println(\"title : \"+title);\n        System.out.println(\"time : \"+time);\n        System.out.println(\"artical : \"+artical);\n    }\n```\n\n![](../../../../assets/img/Develop/Java/笔记/爬虫/2.png)\n\n### 多线程爬取\n\n爬虫类\n```java\npublic class Climbimp implements Runnable {\n    private String url ;\n\n    Lock lock = new ReentrantLock();\n\n    public Climbimp(String url, int pages) {\n        this.url = url;\n    }\n\n    public void run() {\n        lock.lock();\n        Document doc = null;\n        try {\n            doc = Jsoup.parse(new URL(url), 10000);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String title = doc.getElementsByTag(\"title\").text();\n        String time = doc.getElementsByClass(\"author-info\").text();\n        String artical = doc.getElementsByClass(\"artical-body\").text();\n\n        System.out.println(\"title : \"+title);\n        //System.out.println(\"time : \"+time);\n        //System.out.println(\"artical : \"+artical);\n\n        lock.unlock();\n\n    }\n}\n```\n\n主类\n```java\npublic class main {\n\n    public static void main(String[] args) {\n\n        int Threadlist_num = 50; //线程数\n        String url = \"https://www.freebuf.com/articles/network/274294.html\";  //url\n\n        Climbimp climbimpl = new Climbimp(url,pages);\n\n        for (int i = 0; i < Threadlist_num; i++) {\n            new Thread(climbimpl).start();\n        }\n    }\n}\n```\n\n这里执行会访问 50 次 https://www.freebuf.com/articles/network/274294.html , 然后就被 freebuf 封 ip 了😂\n\n![](../../../../assets/img/Develop/Java/笔记/爬虫/3.png)\n\n---\n\n## Source & Reference\n\n- https://www.cnblogs.com/nice0e3/p/13488064.html\n- https://blog.csdn.net/ly6cyh/article/details/77141346\n- https://www.cnblogs.com/nice0e3/p/13488064.html\n", "timestamp": "2025-10-19T19:25:27.599061"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "README.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/README.md", "content": "<p align=\"center\">\n    <img src=\"./assets/img/banner/logo.png\">\n</p>\n\n<p align=\"center\">\n    <img src=\"https://img.shields.io/badge/Category-knowledge-red.svg\">\n    <img src=\"https://img.shields.io/github/repo-size/No-Github/1earn?color=yellow\">\n    <img src=\"https://img.shields.io/github/last-commit/No-Github/1earn.svg?color=blue\">\n    <img src=\"https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-lightgrey.svg?color=brightgreen\">\n</p>\n\n> 万事开头难,然后一直开头一直难...\n\n<p align=\"center\">\n    <img src=\"./assets/img/banner/readme.jpg\">\n</p>\n\n* **简介** : 本项目的初衷是分享知识资源,让更多人接触和了解安全、运维领域,但受限于本人能力有限,难免会有错误和借鉴的地方,对于内容中有疑问或建议请提交 issue.\n* **定位** : ffffffff0x 团队维护的安全知识框架\n* **项目地址** : https://github.com/ffffffff0x/1earn\n* **学习线路图** : 初学者或想快速构建知识结构请访问 [roadmap](roadmap.md)\n\n---\n\n## 项目文件一览\n\n* **[Security](./1earn/Security/Power-PenTest.md)**\n\n    * **[安全工具](https://github.com/No-Github/1earn/tree/master/1earn/Security/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7)** - 各类安全工具的使用介绍\n\n    * **安全资源**\n        * 靶机\n            * HTB\n            * VulnHub\n                * [DC Serial](./1earn/Security/安全资源/靶机/VulnHub/DC) - DC 系列靶场,难度简单至中等,可以学习各种提权和CMS漏洞利用,推荐初学者挑战\n                * [It’s_October](./1earn/Security/安全资源/靶机/VulnHub/It’s_October)\n                * [Kioptrix Serial](./1earn/Security/安全资源/靶机/VulnHub/Kioptrix) - Kioptrix 系列靶场,难度简单至中等,推荐初学者挑战\n                * [Mission-Pumpkin](./1earn/Security/安全资源/靶机/VulnHub/Mission-Pumpkin) - 难度适中,偏向于加解密比较多,漏洞利用内容较少\n                * [symfonos Serial](./1earn/Security/安全资源/靶机/VulnHub/symfonos) - 挺有难度的靶场,内容丰富,难度中等,漏洞利用内容很多,推荐有一定经验者挑战\n            * Wargames\n                * [Bandit](./1earn/Security/安全资源/靶机/Wargames/Bandit/Bandit-WalkThrough.md)\n\n    * **BlueTeam**\n        * [分析](./1earn/Security/BlueTeam/分析.md) - 分析工具与分析案例\n        * [加固](./1earn/Security/BlueTeam/加固.md) - 系统、应用加固的方法和工具资源\n        * [安全建设](./1earn/Security/BlueTeam/安全建设.md) - 有关查杀、监控、蜜罐的资源\n        * [取证](./1earn/Security/BlueTeam/取证.md) - 内容涉及操作系统的取证、web 的取证、文件的取证\n        * [应急](./1earn/Security/BlueTeam/应急.md) - 应急资源、溯源案例\n        * [笔记](https://github.com/No-Github/1earn/blob/master/1earn/Security/BlueTeam/%E7%AC%94%E8%AE%B0) - 涉及磁盘取证、内存取证、USB取证等内容\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/BlueTeam/%E5%AE%9E%E9%AA%8C) - 涉及流量分析实战、安防设施搭建等内容\n\n    * **Crypto**\n        * [Crypto](./1earn/Security/Crypto/Crypto.md) - 介绍各种编码和加密算法及相关的工具\n\n    * **CTF**\n        * [CTF](./1earn/Security/CTF/CTF.md) - 收集 CTF 相关的工具和 writeup 资源\n        * [writeup](https://github.com/No-Github/1earn/tree/master/1earn/Security/CTF/writeup) - 自己参与的一些比赛记录\n\n    * **ICS**\n        * [工控协议](./1earn/Security/ICS/工控协议.md) - 总结各类工控协议的知识点\n        * [上位机安全](./1earn/Security/ICS/上位机安全.md) - 总结上位机安全相关的知识点\n        * [PLC攻击](./1earn/Security/ICS/PLC攻击.md) - 总结 PLC 攻击的相关知识点\n        * [S7comm相关](./1earn/Security/ICS/S7comm相关.md) - 记录 S7comm 相关错误类型、功能码和相关参数\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/ICS/%E5%AE%9E%E9%AA%8C) - 仿真环境搭建和 PLC 攻击实验\n\n    * **IOT**\n        * 固件安全\n            * [固件安全](./1earn/Security/IOT/固件安全/固件安全.md) - 记录 IOT 固件分析的知识点,包括固件提取、固件分析、固件解密等\n            * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/IOT/%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/%E5%AE%9E%E9%AA%8C) - 分析固件实验\n        * 无线电安全\n            * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/IOT/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8/%E5%AE%9E%E9%AA%8C) - 无线电安全实验\n        * 硬件安全\n            * [Device-Exploits](./1earn/Security/IOT/硬件安全/Device-Exploits.md) - 嵌入式设备相关漏洞利用,不太熟悉这一块,内容不多\n            * [HID](https://github.com/No-Github/1earn/tree/master/1earn/Security/IOT/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/HID) - 和组员制作的 HID 实物记录\n\n    * **MobileSec**\n        * [Android安全](./1earn/Security/MobileSec/Android安全.md) - 记录一些安卓安全相关的内容,这块掌握较少\n\n    * **RedTeam**\n        * 安防设备\n            * [Bypass技巧](./1earn/Security/RedTeam/安防设备/Bypass技巧.md) - 记录 waf 绕过手段\n            * [SecDevice-Exploits](./1earn/Security/RedTeam/安防设备/SecDevice-Exploits.md) - 常见的安全设备的漏洞利用方法\n        * 后渗透\n            * [后渗透](./1earn/Security/RedTeam/后渗透/后渗透.md) - 后渗透知识点的大纲\n            * [权限提升](./1earn/Security/RedTeam/后渗透/权限提升.md) - 操作系统和数据库的提权方法\n            * [权限维持](./1earn/Security/RedTeam/后渗透/权限维持.md) - 权限维持的各种方法和资源\n            * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/%E5%90%8E%E6%B8%97%E9%80%8F/%E5%AE%9E%E9%AA%8C)\n        * 软件服务安全\n            * [CS-Exploits](./1earn/Security/RedTeam/软件服务安全/CS-Exploits.md) - 收集软件、业务应用服务漏洞的渗透手段和 cve 漏洞\n            * [DesktopApps-Exploits](./1earn/Security/RedTeam/软件服务安全/DesktopApps-Exploits.md) - 收集桌面软件的渗透手段和 cve 漏洞\n        * 协议安全\n            * [Protocol-Exploits](./1earn/Security/RedTeam/协议安全/Protocol-Exploits.md) - 按照协议归类各种漏洞、攻击手段\n        * 信息收集\n            * [端口安全](./1earn/Security/RedTeam/信息收集/端口安全.md) - 记录端口渗透时的方法和思路\n            * [空间测绘](./1earn/Security/RedTeam/信息收集/空间测绘.md) - 收集搜索引擎语法资源\n            * [信息收集](./1earn/Security/RedTeam/信息收集/信息收集.md) - 记录信息收集方面各类技术，如漏扫、IP 扫描、端口扫描、DNS 枚举、目录枚举、指纹等\n        * 语言安全\n            * [语言安全](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/%E8%AF%AD%E8%A8%80%E5%AE%89%E5%85%A8)\n        * 云安全\n            * [公有云安全](./1earn/Security/RedTeam/云安全/公有云安全.md) - 云主机利用工具,渗透案例,相关知识点\n        * OS安全\n            * [Linux安全](./1earn/Security/RedTeam/OS安全/Linux安全.md) - 包含 Linux 口令破解，漏洞利用、获取Shell\n            * [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md) - 收集操作系统的 cve 漏洞\n            * [Windows安全](./1earn/Security/RedTeam/OS安全/Windows安全.md) - 包含 windows pth、ptt，漏洞利用、提权、远程执行命令\n            * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/OS%E5%AE%89%E5%85%A8/%E5%AE%9E%E9%AA%8C)\n        * Web 安全\n            * [前端攻防](./1earn/Security/RedTeam/Web安全/前端攻防.md) - 前端解密,绕过访问\n            * [BS-Exploits](./1earn/Security/RedTeam/Web安全/BS-Exploits.md) - 全面收集 web 漏洞 POC | Payload | exp\n            * [IDOR](./1earn/Security/RedTeam/Web安全/IDOR.md) - 整个部分结构大部分基于乌云的几篇密码找回、逻辑漏洞类文章,在其基础上记录和归纳\n            * [靶场](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/Web%E5%AE%89%E5%85%A8/%E9%9D%B6%E5%9C%BA)\n            * [Web_Generic](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/Web%E5%AE%89%E5%85%A8/Web_Generic)\n            * [Web_Tricks](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/Web%E5%AE%89%E5%85%A8/Web_Tricks)\n\n    * **Reverse**\n        * [Reverse](./1earn/Security/Reverse/Reverse.md)\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Security/Reverse/%E5%AE%9E%E9%AA%8C)\n        * [FILE](https://github.com/No-Github/1earn/tree/master/1earn/Security/Reverse/FILE)\n\n* **Develop**\n\n    * **版本控制**\n        * [Git学习笔记](./1earn/Develop/版本控制/Git学习笔记.md) - 记录 git 的用法和平时使用 github 遇到的问题\n\n    * **标记语言**\n        * [HTML](https://github.com/No-Github/1earn/tree/master/1earn/Develop/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/HTML)\n        * [JSON](https://github.com/No-Github/1earn/tree/master/1earn/Develop/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/JSON)\n        * [XML](https://github.com/No-Github/1earn/tree/master/1earn/Develop/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/XML)\n\n    * **可视化**\n        * [gnuplot](https://github.com/No-Github/1earn/tree/master/1earn/Develop/%E5%8F%AF%E8%A7%86%E5%8C%96/gnuplot)\n\n    * **正则**\n        * [regex](./1earn/Develop/正则/regex.md) - 常用正则表达式和相关资源\n\n    * **Web**\n        * [Speed-Web](./1earn/Develop/Web/Speed-Web.md)\n        * [HTTP](https://github.com/No-Github/1earn/tree/master/1earn/Develop/Web/HTTP)\n        * [笔记](https://github.com/No-Github/1earn/tree/master/1earn/Develop/Web/%E7%AC%94%E8%AE%B0)\n\n* **Integrated**\n\n    * **数据库**\n        * [Power-SQL](https://github.com/No-Github/1earn/blob/master/1earn/Integrated/%E6%95%B0%E6%8D%AE%E5%BA%93/Power-SQL.md)\n        * [Speed-SQL](https://github.com/No-Github/1earn/blob/master/1earn/Integrated/%E6%95%B0%E6%8D%AE%E5%BA%93/Speed-SQL.md)\n        * [笔记](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0)\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AE%9E%E9%AA%8C)\n\n    * **虚拟化**\n        * [Docker](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/%E8%99%9A%E6%8B%9F%E5%8C%96/Docker)\n\n    * **Linux**\n        * [God-Linux](./1earn/Integrated/Linux/God-Linux.md) - 记录 Linux 下的骚操作,收集的较少,后面会慢慢添加\n        * [Power-Linux](./1earn/Integrated/Linux/Power-Linux.md) - 配置指南,记录各种服务搭建与配置过程\n        * [Secure-Linux](./1earn/Integrated/Linux/Secure-Linux.md) - Linux 加固+维护+应急响应参考\n        * [Speed-Linux](./1earn/Integrated/Linux/Speed-Linux.md) - 命令速查手册,记录各种基本命令操作\n        * [笔记](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/Linux/%E7%AC%94%E8%AE%B0)\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/Linux/%E5%AE%9E%E9%AA%8C) - 各种 linux 服务的搭建过程和案例\n\n    * **Network**\n        * [Speed-Net](./1earn/Integrated/Network/Speed-Net.md) - 各类帧、报文格式、掩码等\n        * [Power-Net](./1earn/Integrated/Network/Power-Net.md) - 记录 TCP/IP 协议栈的协议\n\n    * **Windows**\n        * [Secure-Win](./1earn/Integrated/Windows/Secure-Win.md) - Windows 加固+维护+应急响应参考\n        * [Speed-Win](./1earn/Integrated/Windows/Speed-Win.md) - 记录 windows 下 CMD 常用命令\n        * [笔记](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/Windows/%E7%AC%94%E8%AE%B0)\n        * [实验](https://github.com/No-Github/1earn/tree/master/1earn/Integrated/Windows/%E5%AE%9E%E9%AA%8C) -涉及域环境搭建、基础服务搭建\n        * [Powershell](./1earn/Integrated/Windows/PowerShell/PowerShell笔记.md)\n\n* **Plan**\n\n    * [Misc-Plan](./1earn/Plan/Misc-Plan.md) - 各种小技巧\n    * [Team-Plan](./1earn/Plan/Team-Plan.md) - 团队协作解决方案\n    * [Thinking-Plan](./1earn/Plan/Thinking-Plan.md) - 问题解决方式的记录和学习\n    * [VM-Plan](./1earn/Plan/VM-Plan.md) - VMWare 常见问题记录\n\n---\n\n## 三板斧\n\n`收集、归纳、分享` 我认为这是知识学习的\"三板斧\"\n\n收集,很好理解,比如收集各种学习的资源,看过的论文、文章,和各种工具\n\n归纳,或者说是总结与分类,将自己学习过程中的心得体会记载下来,写成各种笔记,文章,将收集的资源整理归类\n\n分享,在博客上传一篇文章也好,在 qq 群帮助群友解决一个问题也好,都是分享\n\n没有收集和归纳的能力,整个学习的过程就像是在用一个菜篮子接水,留不住的,同样,如果不愿意分享,就像是在闭门造车,无法接触到不同的观点,没人指正你的问题,久而久之有可能想法变得偏执,并且固步自封\n\n---\n\n## 阅读建议\n\n`本项目所有文档均在 VScode 编辑器中编写,故只兼容 VScode 侧边预览的 markdown 语法,暂不考虑兼容其他编辑器的 md 语法`\n\n~~由于 github 的 markdown 引擎 kramdown 不支持 [TOC] 链接,以及各种不兼容的排版问题, 导致阅读体验极不友好, 因此~~ 建议还是下载/clone到本地阅读\n```\ngit clone --depth 1 https://github.com/ffffffff0x/1earn.git\n```\n\n建议的阅读体验\n* [VScode](https://code.visualstudio.com/) + [FiraCode](https://github.com/tonsky/FiraCode) (推荐,整个项目在vscode环境下编写,基本不会出现排版问题)\n* [Typora](https://www.typora.io/)\n\n> 如果 clone 速度太慢,可以先导入码云中(选择从 URL 中导入),再进行 clone ： https://blog.gitee.com/2018/06/05/github_to_gitee/?from=homepage\n\n> 提高 release 速度,可以参考这几篇文章 https://jinfeijie.cn/post-805.html 、https://blog.csdn.net/weixin_44821644/article/details/107574297?utm_source=app\n\n> 现在只需按下句号(.)键，即可启用 web 版 vscode 浏览本项目\n\n---\n\n以下是该项目的灵感来源\n\n* [Micro8-渗透沉思录](https://www.secpulse.com/archives/98814.html)\n* [Teach Yourself Programming in Ten Years](http://norvig.com/21-days.html)\n* [To Find a Better Solution, Ask a Better Question  Member Feature Stories  Medium](https://medium.com/s/story/to-find-a-better-solution-ask-a-better-question-3be7fee5af65)\n* [The Magpie Developer](https://blog.codinghorror.com/the-magpie-developer/)\n\n---\n\n## CONTRIBUTORS & Thanks\n\n- [CONTRIBUTORS](./assets/CONTRIBUTORS.md)\n\n---\n\n## 联系我\n\n- 如果你有任何其他方面的问题或建议，可以在 issue 提出或发送邮件至 D2hwakH7BS5E@protonmail.com\n\n---\n\n## Disclaimer&License\n\n- <sup>本项目采用 [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/deed.zh) 协议.</sup>\n    - <sup>共享 — 在任何媒介以任何形式复制、发行本作品。</sup>\n    - <sup>演绎 — 修改、转换或以本作品为基础进行创作在任何用途下，甚至商业目的。</sup>\n    - <sup>署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。</sup>\n    - <sup>没有附加限制 — 您不得适用法律术语或者 技术措施 从而限制其他人做许可协议允许的事情。</sup>\n- <sup>注: 本项目所有文件仅供学习和研究使用,请勿使用项目中的技术源码用于非法用途,任何人造成的任何负面影响,与本人无关.</sup>\n\n---\n\n> create by ffffffff0x\n", "timestamp": "2025-10-19T19:25:30.269365"}
{"source": "github", "repo": "ffffffff0x/1earn", "file": "roadmap.md", "url": "https://github.com/ffffffff0x/1earn/blob/master/roadmap.md", "content": "# roadmap\n\n---\n\n`文档偶尔更新,如果发现链接失效或内容错误,欢迎通过 issue 告诉我`\n\n---\n\n## 前言\n\n安全知识点非常多也非常杂,要想掌握必须花费大量时间,如果仅仅看了文章、复制粘贴记个笔记、收藏了某个POC就认为自己会了,懂了,这种浅尝辄止到头来还是坑自己,一定要动手实践。\n\n美团的这篇技术文章写的非常好 [工作中如何做好技术积累](https://tech.meituan.com/2018/04/16/study-vs-work.html) 下面这段是其中的一部分,分享给大家\n\n---\n\n古人云：“纸上得来终觉浅，绝知此事要躬行。” 学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但对于工程师们来说，按照实践、学习和培训的方式进行重要性排序，大致是不错的。所以重视实践，在实践中成长是最重要的学习原则。\n\n人类的认知有两种：感性认知和理性认知。这两种认知互相不可替代性。实践很大程度来自于感性学习，看书更像是理性学习。以学开汽车做例子，很难想象什么人能够仅仅通过学习书本知识就会开汽车。\n\n书本知识主要是传道——讲述抽象原型，而对其具体应用场景的讲述往往含糊其辞，对抽象原型之间的关系也是浅尝辄止。采用同样精确的语言去描述应用场景和关联关系将会失去重点，让人摸不着头脑。所以，仅仅通过看书来获得成长就像是用一条腿走路。\n\n重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。\n\n---\n\n下面我将以安全工程师的角度来构建一个基本的学习路线图,由于我个人偏 web+misc 所以不包含逆向内容,请见谅\n\n如果您擅长 逆向、pwn、mobile安全 或其他安全相关技能 且提供了相关教程或博客、笔记等，欢迎提交 pr 一起构建 roadmap\n\n![](./assets/img/roadmap.png)\n\n## 入门知识\n\n基本功很重要\n\n- 虚拟机使用 - 学会安装、使用虚拟机,明白VMware几种网络连接的区别\n    - 略\n\n- 如何科学上网 - 懂得都懂\n    - 略\n\n- Markdown 语法 - 学会记笔记也很重要\n    - 略\n\n---\n\n## 基础开发知识\n\n- 字符编码 - 没啥好说的,基本功\n    - 略\n\n- git 及 github 的使用 - 多参与开源项目可以快速提高开发水平\n    - [Git学习笔记](./1earn/Develop/版本控制/Git学习笔记.md)\n\n- 数据类型的处理\n    - xml\n    - json\n\n- 正则 - 了解正则语法\n    - [regex](./1earn/Develop/正则/regex.md)\n\n- python - 掌握语法,能够编写POC,能够按需求修改exp\n    - 略\n\n---\n\n## WEB开发\n\n- dotnet\n    - 暂时还没学完 : )\n\n- java\n    - 暂时还没学完 : )\n\n- php\n    - 暂时还没学完 : )\n\n---\n\n## 基础运维知识\n\n### Linux运维\n\n- Linux 是啥\n    - [发行版](./1earn/Integrated/Linux/笔记/发行版.md)\n    - [进程](./1earn/Integrated/Linux/笔记/进程.md)\n\n- Linux 基础命令\n    - [Speed-Linux](./1earn/Integrated/Linux/Speed-Linux.md)\n\n- Linux 服务搭建 - 起码要学会怎么搭建 httpd、nginx\n    - [Power-Linux](./1earn/Integrated/Linux/Power-Linux.md)\n\n- Docker 使用 - 必须要掌握的,可以节约你大量时间\n    - [Speed-Docker](./1earn/Integrated/虚拟化/Docker/Speed-Docker.md)\n\n### 网络知识\n\n- TCP/IP 模型 - 需要明白什么是IP、MAC，各层的常见协议有哪些分别什么作用\n    - 略\n\n### Windows服务器\n\n- Windows 下常用命令\n    - [Speed-Win](./1earn/Integrated/Windows/Speed-Win.md)\n\n- Windows 服务器能干啥\n    - [Windows基础服务搭建](./1earn/Integrated/Windows/实验/Windows基础服务搭建.md)\n\n---\n\n## web基础\n\n- HTTP 协议\n    - 略\n\n- html+js\n    - 略\n\n- web 基础漏洞\n    - [Web_Generic](./1earn/Security/RedTeam/Web安全/Web_Generic/Web_Generic.md)\n\n- web 逻辑漏洞\n    - [IDOR](./1earn/Security/RedTeam/Web安全/IDOR.md)\n\n- 靶场 - 如果有空闲时间可以打打靶场练习\n    - [靶场](https://github.com/No-Github/1earn/tree/master/1earn/Security/RedTeam/Web%E5%AE%89%E5%85%A8/%E9%9D%B6%E5%9C%BA)\n\n## web进阶\n\n- 各类通用漏洞利用\n    - [BS-Exploits](./1earn/Security/RedTeam/Web安全/BS-Exploits.md)\n\n- OOB\n    - [OOB](./1earn/Security/RedTeam/Web安全/Web_Tricks/OOB.md)\n\n- JWT\n    - [JWT安全](./1earn/Security/RedTeam/Web安全/Web_Tricks/JWT安全.md)\n\n## 代码审计\n\n- 暂时还没学完 : )\n\n---\n\n## 主机安全\n\n### linux\n\n- linux 权限、文件\n    - [认证](./1earn/Integrated/Linux/笔记/认证.md)\n    - [文件](./1earn/Integrated/Linux/笔记/文件.md)\n\n- linux 提权、漏洞利用\n    - [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md#linux)\n\n- linux lol\n    - [Linux安全](./1earn/Security/RedTeam/OS安全/Linux安全.md#lol)\n\n### windows\n\n- windows 认证体系\n    - [认证](./1earn/Integrated/Windows/笔记/认证.md)\n\n- windows 提权、漏洞利用\n    - [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md#windows)\n\n- windows lol\n    - [Windows-LOL](./1earn/Security/RedTeam/OS安全/实验/Windows-LOL.md)\n\n- windows rdp 利用\n    - [Windows安全](./1earn/Security/RedTeam/OS安全/Windows安全.md#rdp)\n\n- windows 凭证抓取\n    - [Windows安全](./1earn/Security/RedTeam/OS安全/Windows安全.md#认证)\n\n---\n\n## 后渗透\n\n### 权限提升\n\n- linux 提权\n    - [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md#linux)\n\n- windows 提权\n    - [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md#windows)\n\n- 第三方软件提权\n    - [权限提升](./1earn/Security/RedTeam/后渗透/权限提升.md)\n\n### 权限维持\n\n- 各种 webshell\n    - [权限维持](./1earn/Security/RedTeam/后渗透/权限维持.md#web)\n\n- windows 权限维持\n    - [权限维持](./1earn/Security/RedTeam/后渗透/权限维持.md#win)\n\n- linux 权限维持\n    - [权限维持](./1earn/Security/RedTeam/后渗透/权限维持.md#linux)\n\n- 各类 C2、免杀\n    - [权限维持](./1earn/Security/RedTeam/后渗透/权限维持.md#c2-rat)\n\n### windows 域\n\n- 工作组、域是什么、如何搭建域环境\n    - [工作组](./1earn/Integrated/Windows/笔记/工作组.md)\n    - [域](./1earn/Integrated/Windows/笔记/域.md)\n    - [Windows 域搭建](./1earn/Integrated/Windows/实验/Windows域搭建.md)\n\n- Kerberos\n    - [认证](./1earn/Integrated/Windows/笔记/认证.md#域认证)\n\n- 域凭证抓取\n    - [Windows安全](./1earn/Security/RedTeam/OS安全/Windows安全.md#域)\n\n- 域控提权\n    - [OS-Exploits](./1earn/Security/RedTeam/OS安全/OS-Exploits.md#域)\n\n- pth/k/t\n    - [PTH](./1earn/Security/RedTeam/OS安全/Windows安全.md#pth)\n    - [PTT](./1earn/Security/RedTeam/OS安全/Windows安全.md#ptt)\n\n- Exchange\n    - [Exchange 搭建](./1earn/Integrated/Windows/实验/Exchange搭建.md)\n    - [Exchange](./1earn/Security/RedTeam/后渗透/实验/Exchange.md)\n\n---\n\n## 蓝队技能\n\n### 蓝队服务搭建\n\n### 分析技术\n\n- linux 日志、信息\n    - [日志](./1earn/Integrated/Linux/笔记/日志.md)\n    - [信息](./1earn/Integrated/Linux/笔记/信息.md)\n\n- windows 日志、信息\n    - [日志](./1earn/Integrated/Windows/笔记/日志.md)\n    - [信息](./1earn/Integrated/Windows/笔记/信息.md)\n\n- 恶意文件分析\n    - [分析](./1earn/Security/BlueTeam/分析.md)\n\n### 取证技术\n\n- 文件取证\n    - [取证](./1earn/Security/BlueTeam/取证.md#文件取证)\n\n- 内存取证\n    - [内存取证](./1earn/Security/BlueTeam/笔记/内存取证.md)\n\n- 流量分析\n    - [流量分析](./1earn/Security/BlueTeam/实验/流量分析.md)\n\n- 应用程序、WEB、数据库取证\n    - [取证](./1earn/Security/BlueTeam/取证.md#应用程序取证)\n", "timestamp": "2025-10-19T19:25:31.605751"}
